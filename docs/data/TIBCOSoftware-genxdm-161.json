{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "161",
    "information": {
        "errors": [
            {
                "line": "38",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class IdManager\n{\n\tprivate final HashSet<String> m_definedIds = new HashSet<String>();\n\tprivate final HashMap<String, List<LocationInSchema>> m_danglingIDREFLocations = new HashMap<String, List<LocationInSchema>>();\n\n\tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "39",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/161/IdManager.java\nindex 966888a1a0d..544b3245632 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/161/IdManager.java\n@@ -35,7 +35,7 @@ import org.genxdm.xs.types.SimpleType;\n  */\n final class IdManager\n {\n-\tprivate final HashSet<String> m_definedIds = new HashSet<String>();\n+private final HashSet<String> m_definedIds = new HashSet<String>();\n \tprivate final HashMap<String, List<LocationInSchema>> m_danglingIDREFLocations = new HashMap<String, List<LocationInSchema>>();\n \n \tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/161/IdManager.java\nindex 966888a1a0d..7e7d44aff3d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/161/IdManager.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.util.HashMap;\n@@ -33,99 +34,85 @@ import org.genxdm.xs.types.SimpleType;\n /**\n  * Responsible for implementing ID/IDREF functionality.\n  */\n-final class IdManager\n-{\n-\tprivate final HashSet<String> m_definedIds = new HashSet<String>();\n-\tprivate final HashMap<String, List<LocationInSchema>> m_danglingIDREFLocations = new HashMap<String, List<LocationInSchema>>();\n-\n-\tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tvalue(actualValue, actualType, locatable, errors, atomBridge);\n-\t}\n-\n-\tpublic <A> void attribute(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tvalue(actualValue, actualType, locatable, errors, atomBridge);\n-\t}\n-\n-\tprivate <A> void value(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tif (actualType.isID())\n-\t\t{\n-\t\t\tprocessId(castAsString(actualValue.iterator().next(), atomBridge), locatable, atomBridge, errors);\n-\t\t}\n-\t\telse if (actualType.isIDREF())\n-\t\t{\n-\t\t\tprocessIdRef(castAsString(actualValue.iterator().next(), atomBridge), locatable);\n-\t\t}\n-\t\telse if (actualType.isIDREFS())\n-\t\t{\n-\t\t\tfor (final A idref : actualValue)\n-\t\t\t{\n-\t\t\t\tprocessIdRef(castAsString(idref, atomBridge), locatable);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate <A> String castAsString(final A atom, final AtomBridge<A> atomBridge)\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(atom, \"atom\");\n-\t\tPreCondition.assertArgumentNotNull(atomBridge, \"atomBridge\");\n-\t\treturn atomBridge.getC14NForm(atom);\n-\t}\n-\n-\tpublic <A> void processId(final String id, final Locatable locatable, final AtomBridge<A> atomBridge, final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tif (!m_definedIds.add(id))\n-\t\t{\n-\t\t\terrors.error(new SmDuplicateIDException(id, locatable.getLocation()));\n-\t\t}\n-\n-\t\tm_danglingIDREFLocations.remove(id);\n-\t}\n-\n-\tprivate void processIdRef(final String idref, final Locatable locatable)\n-\t{\n-\t\tif (m_definedIds.contains(idref))\n-\t\t{\n-\t\t\tm_danglingIDREFLocations.remove(idref);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (m_danglingIDREFLocations.containsKey(idref))\n-\t\t\t{\n-\t\t\t\tm_danglingIDREFLocations.get(idref).add(locatable.getLocation());\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tfinal LinkedList<LocationInSchema> locations = new LinkedList<LocationInSchema>();\n-\t\t\t\tlocations.add(locatable.getLocation());\n-\t\t\t\tm_danglingIDREFLocations.put(idref, locations);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void reportDanglingIdRefs(final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tif (m_danglingIDREFLocations.size() != 0)\n-\t\t{\n-\t\t\tfor (final String idref : m_danglingIDREFLocations.keySet())\n-\t\t\t{\n-\t\t\t\tfinal List<LocationInSchema> locations = m_danglingIDREFLocations.get(idref);\n-\n-\t\t\t\tfor (final LocationInSchema location : locations)\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcDanglingIDReferenceException(idref, location));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treset();\n-\t}\n-\n-\tpublic void reset()\n-\t{\n-\t\tm_definedIds.clear();\n-\t\tm_danglingIDREFLocations.clear();\n-\t}\n+final class IdManager {\n+    private final HashSet<String> m_definedIds = new HashSet<String>();\n+\n+    private final HashMap<String, List<LocationInSchema>> m_danglingIDREFLocations =\n+        new HashMap<String, List<LocationInSchema>>();\n+\n+    public <A> void text(final List<? extends A> actualValue, final SimpleType actualType,\n+                         final Locatable locatable, final SchemaExceptionHandler errors,\n+                         final AtomBridge<A> atomBridge) throws AbortException {\n+        value(actualValue, actualType, locatable, errors, atomBridge);\n+    }\n+\n+    public <A> void attribute(final List<? extends A> actualValue, final SimpleType actualType,\n+                              final Locatable locatable, final SchemaExceptionHandler errors,\n+                              final AtomBridge<A> atomBridge) throws AbortException {\n+        value(actualValue, actualType, locatable, errors, atomBridge);\n+    }\n+\n+    private <A> void value(final List<? extends A> actualValue, final SimpleType actualType,\n+                           final Locatable locatable, final SchemaExceptionHandler errors,\n+                           final AtomBridge<A> atomBridge) throws AbortException {\n+        if (actualType.isID()) {\n+            processId(castAsString(actualValue.iterator().next(), atomBridge), locatable,\n+                atomBridge, errors);\n+        } else if (actualType.isIDREF()) {\n+            processIdRef(castAsString(actualValue.iterator().next(), atomBridge), locatable);\n+        } else if (actualType.isIDREFS()) {\n+            for (final A idref : actualValue) {\n+                processIdRef(castAsString(idref, atomBridge), locatable);\n+            }\n+        }\n+    }\n+\n+    private <A> String castAsString(final A atom, final AtomBridge<A> atomBridge) {\n+        PreCondition.assertArgumentNotNull(atom, \"atom\");\n+        PreCondition.assertArgumentNotNull(atomBridge, \"atomBridge\");\n+        return atomBridge.getC14NForm(atom);\n+    }\n+\n+    public <A> void processId(final String id, final Locatable locatable,\n+                              final AtomBridge<A> atomBridge, final SchemaExceptionHandler errors)\n+        throws AbortException {\n+        if (!m_definedIds.add(id)) {\n+            errors.error(new SmDuplicateIDException(id, locatable.getLocation()));\n+        }\n+\n+        m_danglingIDREFLocations.remove(id);\n+    }\n+\n+    private void processIdRef(final String idref, final Locatable locatable) {\n+        if (m_definedIds.contains(idref)) {\n+            m_danglingIDREFLocations.remove(idref);\n+        } else {\n+            if (m_danglingIDREFLocations.containsKey(idref)) {\n+                m_danglingIDREFLocations.get(idref).add(locatable.getLocation());\n+            } else {\n+                final LinkedList<LocationInSchema> locations = new LinkedList<LocationInSchema>();\n+                locations.add(locatable.getLocation());\n+                m_danglingIDREFLocations.put(idref, locations);\n+            }\n+        }\n+    }\n+\n+    public void reportDanglingIdRefs(final SchemaExceptionHandler errors) throws AbortException {\n+        if (m_danglingIDREFLocations.size() != 0) {\n+            for (final String idref : m_danglingIDREFLocations.keySet()) {\n+                final List<LocationInSchema> locations = m_danglingIDREFLocations.get(idref);\n+\n+                for (final LocationInSchema location : locations) {\n+                    errors.error(new CvcDanglingIDReferenceException(idref, location));\n+                }\n+            }\n+        }\n+\n+        reset();\n+    }\n+\n+    public void reset() {\n+        m_definedIds.clear();\n+        m_danglingIDREFLocations.clear();\n+    }\n }\n",
            "diff_size": 100
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "39",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/161/IdManager.java\nindex 966888a1a0d..024a2ab53e8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/161/IdManager.java\n@@ -35,97 +35,97 @@ import org.genxdm.xs.types.SimpleType;\n  */\n final class IdManager\n {\n-\tprivate final HashSet<String> m_definedIds = new HashSet<String>();\n+    private final HashSet<String> m_definedIds = new HashSet<String>();\n \tprivate final HashMap<String, List<LocationInSchema>> m_danglingIDREFLocations = new HashMap<String, List<LocationInSchema>>();\n \n \tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n \t{\n-\t\tvalue(actualValue, actualType, locatable, errors, atomBridge);\n-\t}\n+    value(actualValue, actualType, locatable, errors, atomBridge);\n+    }\n \n \tpublic <A> void attribute(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n \t{\n-\t\tvalue(actualValue, actualType, locatable, errors, atomBridge);\n-\t}\n+    value(actualValue, actualType, locatable, errors, atomBridge);\n+    }\n \n \tprivate <A> void value(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n \t{\n-\t\tif (actualType.isID())\n+    if (actualType.isID())\n \t\t{\n-\t\t\tprocessId(castAsString(actualValue.iterator().next(), atomBridge), locatable, atomBridge, errors);\n-\t\t}\n+    processId(castAsString(actualValue.iterator().next(), atomBridge), locatable, atomBridge, errors);\n+    }\n \t\telse if (actualType.isIDREF())\n \t\t{\n-\t\t\tprocessIdRef(castAsString(actualValue.iterator().next(), atomBridge), locatable);\n-\t\t}\n+    processIdRef(castAsString(actualValue.iterator().next(), atomBridge), locatable);\n+    }\n \t\telse if (actualType.isIDREFS())\n \t\t{\n-\t\t\tfor (final A idref : actualValue)\n+    for (final A idref : actualValue)\n \t\t\t{\n-\t\t\t\tprocessIdRef(castAsString(idref, atomBridge), locatable);\n-\t\t\t}\n-\t\t}\n-\t}\n+    processIdRef(castAsString(idref, atomBridge), locatable);\n+    }\n+    }\n+    }\n \n \tprivate <A> String castAsString(final A atom, final AtomBridge<A> atomBridge)\n \t{\n-\t\tPreCondition.assertArgumentNotNull(atom, \"atom\");\n+    PreCondition.assertArgumentNotNull(atom, \"atom\");\n \t\tPreCondition.assertArgumentNotNull(atomBridge, \"atomBridge\");\n \t\treturn atomBridge.getC14NForm(atom);\n-\t}\n+    }\n \n \tpublic <A> void processId(final String id, final Locatable locatable, final AtomBridge<A> atomBridge, final SchemaExceptionHandler errors) throws AbortException\n \t{\n-\t\tif (!m_definedIds.add(id))\n+    if (!m_definedIds.add(id))\n \t\t{\n-\t\t\terrors.error(new SmDuplicateIDException(id, locatable.getLocation()));\n-\t\t}\n+    errors.error(new SmDuplicateIDException(id, locatable.getLocation()));\n+    }\n \n \t\tm_danglingIDREFLocations.remove(id);\n-\t}\n+    }\n \n \tprivate void processIdRef(final String idref, final Locatable locatable)\n \t{\n-\t\tif (m_definedIds.contains(idref))\n+    if (m_definedIds.contains(idref))\n \t\t{\n-\t\t\tm_danglingIDREFLocations.remove(idref);\n-\t\t}\n+    m_danglingIDREFLocations.remove(idref);\n+    }\n \t\telse\n \t\t{\n-\t\t\tif (m_danglingIDREFLocations.containsKey(idref))\n+    if (m_danglingIDREFLocations.containsKey(idref))\n \t\t\t{\n-\t\t\t\tm_danglingIDREFLocations.get(idref).add(locatable.getLocation());\n-\t\t\t}\n+    m_danglingIDREFLocations.get(idref).add(locatable.getLocation());\n+    }\n \t\t\telse\n \t\t\t{\n-\t\t\t\tfinal LinkedList<LocationInSchema> locations = new LinkedList<LocationInSchema>();\n+    final LinkedList<LocationInSchema> locations = new LinkedList<LocationInSchema>();\n \t\t\t\tlocations.add(locatable.getLocation());\n \t\t\t\tm_danglingIDREFLocations.put(idref, locations);\n-\t\t\t}\n-\t\t}\n-\t}\n+    }\n+    }\n+    }\n \n \tpublic void reportDanglingIdRefs(final SchemaExceptionHandler errors) throws AbortException\n \t{\n-\t\tif (m_danglingIDREFLocations.size() != 0)\n+    if (m_danglingIDREFLocations.size() != 0)\n \t\t{\n-\t\t\tfor (final String idref : m_danglingIDREFLocations.keySet())\n+    for (final String idref : m_danglingIDREFLocations.keySet())\n \t\t\t{\n-\t\t\t\tfinal List<LocationInSchema> locations = m_danglingIDREFLocations.get(idref);\n+    final List<LocationInSchema> locations = m_danglingIDREFLocations.get(idref);\n \n \t\t\t\tfor (final LocationInSchema location : locations)\n \t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcDanglingIDReferenceException(idref, location));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+    errors.error(new CvcDanglingIDReferenceException(idref, location));\n+    }\n+    }\n+    }\n \n \t\treset();\n-\t}\n+    }\n \n \tpublic void reset()\n \t{\n-\t\tm_definedIds.clear();\n+    m_definedIds.clear();\n \t\tm_danglingIDREFLocations.clear();\n-\t}\n-}\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 42
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/161/IdManager.java\nindex 966888a1a0d..10eaa565372 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/161/IdManager.java\n@@ -19,7 +19,6 @@ import java.util.HashMap;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.processor.w3c.xs.exception.cvc.CvcDanglingIDReferenceException;\n import org.genxdm.processor.w3c.xs.exception.sm.SmDuplicateIDException;\n@@ -33,99 +32,97 @@ import org.genxdm.xs.types.SimpleType;\n /**\n  * Responsible for implementing ID/IDREF functionality.\n  */\n+\n final class IdManager\n {\n-\tprivate final HashSet<String> m_definedIds = new HashSet<String>();\n-\tprivate final HashMap<String, List<LocationInSchema>> m_danglingIDREFLocations = new HashMap<String, List<LocationInSchema>>();\n-\n-\tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tvalue(actualValue, actualType, locatable, errors, atomBridge);\n-\t}\n-\n-\tpublic <A> void attribute(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tvalue(actualValue, actualType, locatable, errors, atomBridge);\n-\t}\n-\n-\tprivate <A> void value(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tif (actualType.isID())\n-\t\t{\n-\t\t\tprocessId(castAsString(actualValue.iterator().next(), atomBridge), locatable, atomBridge, errors);\n-\t\t}\n-\t\telse if (actualType.isIDREF())\n-\t\t{\n-\t\t\tprocessIdRef(castAsString(actualValue.iterator().next(), atomBridge), locatable);\n-\t\t}\n-\t\telse if (actualType.isIDREFS())\n-\t\t{\n-\t\t\tfor (final A idref : actualValue)\n-\t\t\t{\n-\t\t\t\tprocessIdRef(castAsString(idref, atomBridge), locatable);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate <A> String castAsString(final A atom, final AtomBridge<A> atomBridge)\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(atom, \"atom\");\n-\t\tPreCondition.assertArgumentNotNull(atomBridge, \"atomBridge\");\n-\t\treturn atomBridge.getC14NForm(atom);\n-\t}\n+    private final HashSet<String> m_definedIds = new HashSet<String>();\n+    private final HashMap<String, List<LocationInSchema>> m_danglingIDREFLocations = new HashMap<String, List<LocationInSchema>>();\n+    public <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        value(actualValue, actualType, locatable, errors, atomBridge);\n+    }\n \n-\tpublic <A> void processId(final String id, final Locatable locatable, final AtomBridge<A> atomBridge, final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tif (!m_definedIds.add(id))\n-\t\t{\n-\t\t\terrors.error(new SmDuplicateIDException(id, locatable.getLocation()));\n-\t\t}\n+    public <A> void attribute(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        value(actualValue, actualType, locatable, errors, atomBridge);\n+    }\n \n-\t\tm_danglingIDREFLocations.remove(id);\n-\t}\n+    private <A> void value(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        if (actualType.isID())\n+        {\n+            processId(castAsString(actualValue.iterator().next(), atomBridge), locatable, atomBridge, errors);\n+        }\n+        else if (actualType.isIDREF())\n+        {\n+            processIdRef(castAsString(actualValue.iterator().next(), atomBridge), locatable);\n+        }\n+        else if (actualType.isIDREFS())\n+        {\n+            for (final A idref : actualValue)\n+            {\n+                processIdRef(castAsString(idref, atomBridge), locatable);\n+            }\n+        }\n+    }\n \n-\tprivate void processIdRef(final String idref, final Locatable locatable)\n-\t{\n-\t\tif (m_definedIds.contains(idref))\n-\t\t{\n-\t\t\tm_danglingIDREFLocations.remove(idref);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (m_danglingIDREFLocations.containsKey(idref))\n-\t\t\t{\n-\t\t\t\tm_danglingIDREFLocations.get(idref).add(locatable.getLocation());\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tfinal LinkedList<LocationInSchema> locations = new LinkedList<LocationInSchema>();\n-\t\t\t\tlocations.add(locatable.getLocation());\n-\t\t\t\tm_danglingIDREFLocations.put(idref, locations);\n-\t\t\t}\n-\t\t}\n-\t}\n+    private <A> String castAsString(final A atom, final AtomBridge<A> atomBridge)\n+    {\n+        PreCondition.assertArgumentNotNull(atom, \"atom\");\n+        PreCondition.assertArgumentNotNull(atomBridge, \"atomBridge\");\n+        return atomBridge.getC14NForm(atom);\n+    }\n \n-\tpublic void reportDanglingIdRefs(final SchemaExceptionHandler errors) throws AbortException\n-\t{\n-\t\tif (m_danglingIDREFLocations.size() != 0)\n-\t\t{\n-\t\t\tfor (final String idref : m_danglingIDREFLocations.keySet())\n-\t\t\t{\n-\t\t\t\tfinal List<LocationInSchema> locations = m_danglingIDREFLocations.get(idref);\n+    public <A> void processId(final String id, final Locatable locatable, final AtomBridge<A> atomBridge, final SchemaExceptionHandler errors) throws AbortException\n+    {\n+        if (!m_definedIds.add(id))\n+        {\n+            errors.error(new SmDuplicateIDException(id, locatable.getLocation()));\n+        }\n+        m_danglingIDREFLocations.remove(id);\n+    }\n \n-\t\t\t\tfor (final LocationInSchema location : locations)\n-\t\t\t\t{\n-\t\t\t\t\terrors.error(new CvcDanglingIDReferenceException(idref, location));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+    private void processIdRef(final String idref, final Locatable locatable)\n+    {\n+        if (m_definedIds.contains(idref))\n+        {\n+            m_danglingIDREFLocations.remove(idref);\n+        }\n+        else\n+        {\n+            if (m_danglingIDREFLocations.containsKey(idref))\n+            {\n+                m_danglingIDREFLocations.get(idref).add(locatable.getLocation());\n+            }\n+            else\n+            {\n+                final LinkedList<LocationInSchema> locations = new LinkedList<LocationInSchema>();\n+                locations.add(locatable.getLocation());\n+                m_danglingIDREFLocations.put(idref, locations);\n+            }\n+        }\n+    }\n \n-\t\treset();\n-\t}\n+    public void reportDanglingIdRefs(final SchemaExceptionHandler errors)\n+        throws AbortException\n+    {\n+        if (m_danglingIDREFLocations.size() != 0)\n+        {\n+            for (final String idref : m_danglingIDREFLocations.keySet())\n+            {\n+                final List<LocationInSchema> locations = m_danglingIDREFLocations.get(idref);\n+                for (final LocationInSchema location : locations)\n+                {\n+                    errors.error(new CvcDanglingIDReferenceException(idref, location));\n+                }\n+            }\n+        }\n+        reset();\n+    }\n \n-\tpublic void reset()\n-\t{\n-\t\tm_definedIds.clear();\n-\t\tm_danglingIDREFLocations.clear();\n-\t}\n-}\n+    public void reset()\n+    {\n+        m_definedIds.clear();\n+        m_danglingIDREFLocations.clear();\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 134
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "39",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/161/IdManager.java\nindex 966888a1a0d..544b3245632 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/161/IdManager.java\n@@ -35,7 +35,7 @@ import org.genxdm.xs.types.SimpleType;\n  */\n final class IdManager\n {\n-\tprivate final HashSet<String> m_definedIds = new HashSet<String>();\n+private final HashSet<String> m_definedIds = new HashSet<String>();\n \tprivate final HashMap<String, List<LocationInSchema>> m_danglingIDREFLocations = new HashMap<String, List<LocationInSchema>>();\n \n \tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "39",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/161/IdManager.java\nindex 966888a1a0d..a89df9b9f97 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/161/IdManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/161/IdManager.java\n@@ -35,7 +35,7 @@ import org.genxdm.xs.types.SimpleType;\n  */\n final class IdManager\n {\n-\tprivate final HashSet<String> m_definedIds = new HashSet<String>();\n+    private final HashSet<String> m_definedIds = new HashSet<String>();\n \tprivate final HashMap<String, List<LocationInSchema>> m_danglingIDREFLocations = new HashMap<String, List<LocationInSchema>>();\n \n \tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final Locatable locatable, final SchemaExceptionHandler errors, final AtomBridge<A> atomBridge) throws AbortException\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}