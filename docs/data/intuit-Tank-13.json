{
    "project_name": "intuit-Tank",
    "error_id": "13",
    "information": {
        "errors": [
            {
                "line": "266",
                "column": "53",
                "severity": "warning",
                "message": "'+' should be on a new line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
            }
        ]
    },
    "source_code": "     */\n    public String toString() {\n        return \"[StaticCodeTemplate: id=\" + getID() +\n                \", text=\" + getBeforeCaretText() + \"|\" + getAfterCaretText() + \"]\";\n    }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "266",
                    "column": "53",
                    "severity": "warning",
                    "message": "'+' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "252",
                    "column": "49",
                    "severity": "warning",
                    "message": "'+' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/13/StaticCodeTemplate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/intellij/13/StaticCodeTemplate.java\nindex f68ecf48afd..071d10bf435 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/13/StaticCodeTemplate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/intellij/13/StaticCodeTemplate.java\n@@ -20,6 +20,7 @@\n  * License along with this library; if not, write to the Free Software\n  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.\n  */\n+\n package org.fife.ui.rsyntaxtextarea.templates;\n \n import java.io.IOException;\n@@ -35,236 +36,221 @@ import org.fife.ui.rsyntaxtextarea.RSyntaxUtilities;\n /**\n  * A code template that inserts static text before and after the caret.\n  * <p>\n- * \n+ * <p>\n  * For example, you can associate the identifier <code>forb</code> (short for \"for-block\") with the following code:\n  * <p>\n- * \n+ *\n  * <pre>\n  *   for (&lt;caret&gt;) {\n- * \n+ *\n  *   }\n  * </pre>\n- * \n+ * <p>\n  * Then, whenever you type <code>forb</code> followed by a trigger (e.g., a space) into a text area with this\n  * <code>CodeTemplate</code>, the code snippet is added in place of <code>forb</code>. Further, the caret is placed at\n  * the position denoted by <code>&lt;caret&gt;</code>.\n- * \n+ *\n  * @author Robert Futrell\n  * @version 0.1\n  * @see CodeTemplate\n  */\n public class StaticCodeTemplate extends AbstractCodeTemplate {\n \n-    private static final long serialVersionUID = 1;\n+  private static final long serialVersionUID = 1;\n \n-    /**\n-     * The code inserted before the caret position.\n-     */\n-    private String beforeCaret;\n+  /**\n+   * The code inserted before the caret position.\n+   */\n+  private String beforeCaret;\n \n-    /**\n-     * The code inserted after the caret position.\n-     */\n-    private String afterCaret;\n+  /**\n+   * The code inserted after the caret position.\n+   */\n+  private String afterCaret;\n \n-    /**\n-     * Cached value representing whether <code>beforeCaret</code> contains one or more newlines.\n-     */\n-    private transient int firstBeforeNewline;\n+  /**\n+   * Cached value representing whether <code>beforeCaret</code> contains one or more newlines.\n+   */\n+  private transient int firstBeforeNewline;\n \n-    /**\n-     * Cached value representing whether <code>afterCaret</code> contains one or more newlines.\n-     */\n-    private transient int firstAfterNewline;\n+  /**\n+   * Cached value representing whether <code>afterCaret</code> contains one or more newlines.\n+   */\n+  private transient int firstAfterNewline;\n \n-    private static final String EMPTY_STRING = \"\";\n+  private static final String EMPTY_STRING = \"\";\n \n-    /**\n-     * Constructor. This constructor only exists to support persistance through serialization.\n-     */\n-    public StaticCodeTemplate() {\n-    }\n+  /**\n+   * Constructor. This constructor only exists to support persistance through serialization.\n+   */\n+  public StaticCodeTemplate() {\n+  }\n \n-    /**\n-     * Constructor.\n-     * \n-     * @param id\n-     *            The ID of this code template.\n-     * @param beforeCaret\n-     *            The text to place before the caret.\n-     * @param afterCaret\n-     *            The text to place after the caret.\n-     */\n-    public StaticCodeTemplate(String id, String beforeCaret, String afterCaret) {\n-        super(id);\n-        setBeforeCaretText(beforeCaret);\n-        setAfterCaretText(afterCaret);\n-    }\n+  /**\n+   * Constructor.\n+   *\n+   * @param id          The ID of this code template.\n+   * @param beforeCaret The text to place before the caret.\n+   * @param afterCaret  The text to place after the caret.\n+   */\n+  public StaticCodeTemplate(String id, String beforeCaret, String afterCaret) {\n+    super(id);\n+    setBeforeCaretText(beforeCaret);\n+    setAfterCaretText(afterCaret);\n+  }\n \n-    /**\n-     * Returns the text that will be placed after the caret.\n-     * \n-     * @return The text.\n-     * @see #setAfterCaretText\n-     */\n-    public String getAfterCaretText() {\n-        return afterCaret;\n-    }\n+  /**\n+   * Returns the text that will be placed after the caret.\n+   *\n+   * @return The text.\n+   * @see #setAfterCaretText\n+   */\n+  public String getAfterCaretText() {\n+    return afterCaret;\n+  }\n \n-    /**\n-     * Returns the text that will be placed before the caret.\n-     * \n-     * @return The text.\n-     * @see #setBeforeCaretText\n-     */\n-    public String getBeforeCaretText() {\n-        return beforeCaret;\n-    }\n+  /**\n+   * Returns the text that will be placed before the caret.\n+   *\n+   * @return The text.\n+   * @see #setBeforeCaretText\n+   */\n+  public String getBeforeCaretText() {\n+    return beforeCaret;\n+  }\n \n-    /**\n-     * Returns the \"after caret\" text, with each new line indented by the specified amount.\n-     * \n-     * @param indent\n-     *            The amount to indent.\n-     * @return The \"after caret\" text.\n-     */\n-    private String getAfterTextIndented(String indent) {\n-        return getTextIndented(getAfterCaretText(), firstAfterNewline, indent);\n-    }\n+  /**\n+   * Returns the \"after caret\" text, with each new line indented by the specified amount.\n+   *\n+   * @param indent The amount to indent.\n+   * @return The \"after caret\" text.\n+   */\n+  private String getAfterTextIndented(String indent) {\n+    return getTextIndented(getAfterCaretText(), firstAfterNewline, indent);\n+  }\n \n-    /**\n-     * Returns the \"before caret\" text, with each new line indented by the specified amount.\n-     * \n-     * @param indent\n-     *            The amount to indent.\n-     * @return The \"before caret\" text.\n-     */\n-    private String getBeforeTextIndented(String indent) {\n-        return getTextIndented(getBeforeCaretText(), firstBeforeNewline, indent);\n-    }\n+  /**\n+   * Returns the \"before caret\" text, with each new line indented by the specified amount.\n+   *\n+   * @param indent The amount to indent.\n+   * @return The \"before caret\" text.\n+   */\n+  private String getBeforeTextIndented(String indent) {\n+    return getTextIndented(getBeforeCaretText(), firstBeforeNewline, indent);\n+  }\n \n-    /**\n-     * Returns text with newlines indented by the specifed amount.\n-     * \n-     * @param text\n-     *            The original text.\n-     * @param firstNewline\n-     *            The index of the first '\\n' character.\n-     * @param indent\n-     *            The amount to indent.\n-     * @return The indented text.\n-     */\n-    private String getTextIndented(String text, int firstNewline, String indent) {\n-        if (firstNewline == -1) {\n-            return text;\n-        }\n-        int pos = 0;\n-        int old = firstNewline + 1;\n-        StringBuffer sb = new StringBuffer(text.substring(0, old));\n-        sb.append(indent);\n-        while ((pos = text.indexOf('\\n', old)) > -1) {\n-            sb.append(text.substring(old, pos + 1));\n-            sb.append(indent);\n-            old = pos + 1;\n-        }\n-        if (old < text.length()) {\n-            sb.append(text.substring(old));\n-        }\n-        return sb.toString();\n+  /**\n+   * Returns text with newlines indented by the specifed amount.\n+   *\n+   * @param text         The original text.\n+   * @param firstNewline The index of the first '\\n' character.\n+   * @param indent       The amount to indent.\n+   * @return The indented text.\n+   */\n+  private String getTextIndented(String text, int firstNewline, String indent) {\n+    if (firstNewline == -1) {\n+      return text;\n     }\n+    int pos = 0;\n+    int old = firstNewline + 1;\n+    StringBuffer sb = new StringBuffer(text.substring(0, old));\n+    sb.append(indent);\n+    while ((pos = text.indexOf('\\n', old)) > -1) {\n+      sb.append(text.substring(old, pos + 1));\n+      sb.append(indent);\n+      old = pos + 1;\n+    }\n+    if (old < text.length()) {\n+      sb.append(text.substring(old));\n+    }\n+    return sb.toString();\n+  }\n \n-    /**\n-     * Invokes this code template. The changes are made to the given text area.\n-     * \n-     * @param textArea\n-     *            The text area to operate on.\n-     * @throws BadLocationException\n-     *             If something bad happens.\n-     */\n-    public void invoke(RSyntaxTextArea textArea) throws BadLocationException {\n-\n-        Caret c = textArea.getCaret();\n-        int dot = c.getDot();\n-        int mark = c.getMark();\n-        int p0 = Math.min(dot, mark);\n-        int p1 = Math.max(dot, mark);\n-        RSyntaxDocument doc = (RSyntaxDocument) textArea.getDocument();\n-        Element map = doc.getDefaultRootElement();\n+  /**\n+   * Invokes this code template. The changes are made to the given text area.\n+   *\n+   * @param textArea The text area to operate on.\n+   * @throws BadLocationException If something bad happens.\n+   */\n+  public void invoke(RSyntaxTextArea textArea) throws BadLocationException {\n \n-        int lineNum = map.getElementIndex(dot);\n-        Element line = map.getElement(lineNum);\n-        int start = line.getStartOffset();\n-        int end = line.getEndOffset() - 1; // Why always \"-1\"?\n-        String s = textArea.getText(start, end - start);\n-        int len = s.length();\n+    Caret c = textArea.getCaret();\n+    int dot = c.getDot();\n+    int mark = c.getMark();\n+    int p0 = Math.min(dot, mark);\n+    int p1 = Math.max(dot, mark);\n+    RSyntaxDocument doc = (RSyntaxDocument) textArea.getDocument();\n+    Element map = doc.getDefaultRootElement();\n \n-        // endWS is the end of the leading whitespace\n-        // of the current line.\n-        int endWS = 0;\n-        while (endWS < len && RSyntaxUtilities.isWhitespace(s.charAt(endWS))) {\n-            endWS++;\n-        }\n-        s = s.substring(0, endWS);\n-        p0 -= getID().length();\n-        String beforeText = getBeforeTextIndented(s);\n-        String afterText = getAfterTextIndented(s);\n-        doc.replace(p0, p1 - p0, beforeText + afterText, null);\n-        textArea.setCaretPosition(p0 + beforeText.length());\n+    int lineNum = map.getElementIndex(dot);\n+    Element line = map.getElement(lineNum);\n+    int start = line.getStartOffset();\n+    int end = line.getEndOffset() - 1; // Why always \"-1\"?\n+    String s = textArea.getText(start, end - start);\n+    int len = s.length();\n \n+    // endWS is the end of the leading whitespace\n+    // of the current line.\n+    int endWS = 0;\n+    while (endWS < len && RSyntaxUtilities.isWhitespace(s.charAt(endWS))) {\n+      endWS++;\n     }\n+    s = s.substring(0, endWS);\n+    p0 -= getID().length();\n+    String beforeText = getBeforeTextIndented(s);\n+    String afterText = getAfterTextIndented(s);\n+    doc.replace(p0, p1 - p0, beforeText + afterText, null);\n+    textArea.setCaretPosition(p0 + beforeText.length());\n \n-    /**\n-     * Called when reading a serialized version of this document. This is overridden to initialize the transient members\n-     * of this class.\n-     * \n-     * @param in\n-     *            The input stream to read from.\n-     * @throws ClassNotFoundException\n-     *             Never.\n-     * @throws IOException\n-     *             If an IO error occurs.\n-     */\n-    private void readObject(ObjectInputStream in) throws ClassNotFoundException,\n-            IOException {\n-        in.defaultReadObject();\n-        // \"Resetting\" before and after text to the same values will replace\n-        // nulls with empty srings, and set transient \"first*Newline\" values.\n-        setBeforeCaretText(this.beforeCaret);\n-        setAfterCaretText(this.afterCaret);\n-    }\n+  }\n \n-    /**\n-     * Sets the text to place after the caret.\n-     * \n-     * @param afterCaret\n-     *            The text.\n-     * @see #getAfterCaretText()\n-     */\n-    public void setAfterCaretText(String afterCaret) {\n-        this.afterCaret = afterCaret == null ? EMPTY_STRING : afterCaret;\n-        firstAfterNewline = this.afterCaret.indexOf('\\n');\n-    }\n+  /**\n+   * Called when reading a serialized version of this document. This is overridden to initialize the transient members\n+   * of this class.\n+   *\n+   * @param in The input stream to read from.\n+   * @throws ClassNotFoundException Never.\n+   * @throws IOException            If an IO error occurs.\n+   */\n+  private void readObject(ObjectInputStream in) throws ClassNotFoundException,\n+    IOException {\n+    in.defaultReadObject();\n+    // \"Resetting\" before and after text to the same values will replace\n+    // nulls with empty srings, and set transient \"first*Newline\" values.\n+    setBeforeCaretText(this.beforeCaret);\n+    setAfterCaretText(this.afterCaret);\n+  }\n \n-    /**\n-     * Sets the text to place before the caret.\n-     * \n-     * @param beforeCaret\n-     *            The text.\n-     * @see #getBeforeCaretText()\n-     */\n-    public void setBeforeCaretText(String beforeCaret) {\n-        this.beforeCaret = beforeCaret == null ? EMPTY_STRING : beforeCaret;\n-        firstBeforeNewline = this.beforeCaret.indexOf('\\n');\n-    }\n+  /**\n+   * Sets the text to place after the caret.\n+   *\n+   * @param afterCaret The text.\n+   * @see #getAfterCaretText()\n+   */\n+  public void setAfterCaretText(String afterCaret) {\n+    this.afterCaret = afterCaret == null ? EMPTY_STRING : afterCaret;\n+    firstAfterNewline = this.afterCaret.indexOf('\\n');\n+  }\n \n-    /**\n-     * Returns a string representation of this template for debugging purposes.\n-     * \n-     * @return A string representation of this template.\n-     */\n-    public String toString() {\n-        return \"[StaticCodeTemplate: id=\" + getID() +\n-                \", text=\" + getBeforeCaretText() + \"|\" + getAfterCaretText() + \"]\";\n-    }\n+  /**\n+   * Sets the text to place before the caret.\n+   *\n+   * @param beforeCaret The text.\n+   * @see #getBeforeCaretText()\n+   */\n+  public void setBeforeCaretText(String beforeCaret) {\n+    this.beforeCaret = beforeCaret == null ? EMPTY_STRING : beforeCaret;\n+    firstBeforeNewline = this.beforeCaret.indexOf('\\n');\n+  }\n+\n+  /**\n+   * Returns a string representation of this template for debugging purposes.\n+   *\n+   * @return A string representation of this template.\n+   */\n+  public String toString() {\n+    return \"[StaticCodeTemplate: id=\" + getID() +\n+      \", text=\" + getBeforeCaretText() + \"|\" + getAfterCaretText() + \"]\";\n+  }\n \n }\n\\ No newline at end of file\n",
            "diff_size": 237
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "284",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/13/StaticCodeTemplate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/codebuff/13/StaticCodeTemplate.java\nindex f68ecf48afd..5b4ff695db2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/errored/1/13/StaticCodeTemplate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/intuit-Tank/codebuff/13/StaticCodeTemplate.java\n@@ -22,12 +22,13 @@\n  */\n package org.fife.ui.rsyntaxtextarea.templates;\n \n+\n+\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import javax.swing.text.BadLocationException;\n import javax.swing.text.Caret;\n import javax.swing.text.Element;\n-\n import org.fife.ui.rsyntaxtextarea.RSyntaxDocument;\n import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;\n import org.fife.ui.rsyntaxtextarea.RSyntaxUtilities;\n@@ -53,6 +54,8 @@ import org.fife.ui.rsyntaxtextarea.RSyntaxUtilities;\n  * @version 0.1\n  * @see CodeTemplate\n  */\n+\n+\n public class StaticCodeTemplate extends AbstractCodeTemplate {\n \n     private static final long serialVersionUID = 1;\n@@ -76,12 +79,12 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      * Cached value representing whether <code>afterCaret</code> contains one or more newlines.\n      */\n     private transient int firstAfterNewline;\n-\n     private static final String EMPTY_STRING = \"\";\n \n     /**\n      * Constructor. This constructor only exists to support persistance through serialization.\n      */\n+\n     public StaticCodeTemplate() {\n     }\n \n@@ -95,6 +98,8 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      * @param afterCaret\n      *            The text to place after the caret.\n      */\n+\n+\n     public StaticCodeTemplate(String id, String beforeCaret, String afterCaret) {\n         super(id);\n         setBeforeCaretText(beforeCaret);\n@@ -107,6 +112,8 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      * @return The text.\n      * @see #setAfterCaretText\n      */\n+\n+\n     public String getAfterCaretText() {\n         return afterCaret;\n     }\n@@ -117,6 +124,8 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      * @return The text.\n      * @see #setBeforeCaretText\n      */\n+\n+\n     public String getBeforeCaretText() {\n         return beforeCaret;\n     }\n@@ -128,6 +137,7 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      *            The amount to indent.\n      * @return The \"after caret\" text.\n      */\n+\n     private String getAfterTextIndented(String indent) {\n         return getTextIndented(getAfterCaretText(), firstAfterNewline, indent);\n     }\n@@ -139,6 +149,7 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      *            The amount to indent.\n      * @return The \"before caret\" text.\n      */\n+\n     private String getBeforeTextIndented(String indent) {\n         return getTextIndented(getBeforeCaretText(), firstBeforeNewline, indent);\n     }\n@@ -154,6 +165,7 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      *            The amount to indent.\n      * @return The indented text.\n      */\n+\n     private String getTextIndented(String text, int firstNewline, String indent) {\n         if (firstNewline == -1) {\n             return text;\n@@ -181,8 +193,9 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      * @throws BadLocationException\n      *             If something bad happens.\n      */\n-    public void invoke(RSyntaxTextArea textArea) throws BadLocationException {\n \n+\n+    public void invoke(RSyntaxTextArea textArea) throws BadLocationException {\n         Caret c = textArea.getCaret();\n         int dot = c.getDot();\n         int mark = c.getMark();\n@@ -190,7 +203,6 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n         int p1 = Math.max(dot, mark);\n         RSyntaxDocument doc = (RSyntaxDocument) textArea.getDocument();\n         Element map = doc.getDefaultRootElement();\n-\n         int lineNum = map.getElementIndex(dot);\n         Element line = map.getElement(lineNum);\n         int start = line.getStartOffset();\n@@ -210,7 +222,6 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n         String afterText = getAfterTextIndented(s);\n         doc.replace(p0, p1 - p0, beforeText + afterText, null);\n         textArea.setCaretPosition(p0 + beforeText.length());\n-\n     }\n \n     /**\n@@ -224,8 +235,9 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      * @throws IOException\n      *             If an IO error occurs.\n      */\n+\n     private void readObject(ObjectInputStream in) throws ClassNotFoundException,\n-            IOException {\n+        IOException {\n         in.defaultReadObject();\n         // \"Resetting\" before and after text to the same values will replace\n         // nulls with empty srings, and set transient \"first*Newline\" values.\n@@ -240,6 +252,8 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      *            The text.\n      * @see #getAfterCaretText()\n      */\n+\n+\n     public void setAfterCaretText(String afterCaret) {\n         this.afterCaret = afterCaret == null ? EMPTY_STRING : afterCaret;\n         firstAfterNewline = this.afterCaret.indexOf('\\n');\n@@ -252,6 +266,8 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      *            The text.\n      * @see #getBeforeCaretText()\n      */\n+\n+\n     public void setBeforeCaretText(String beforeCaret) {\n         this.beforeCaret = beforeCaret == null ? EMPTY_STRING : beforeCaret;\n         firstBeforeNewline = this.beforeCaret.indexOf('\\n');\n@@ -262,9 +278,10 @@ public class StaticCodeTemplate extends AbstractCodeTemplate {\n      * \n      * @return A string representation of this template.\n      */\n+\n+\n     public String toString() {\n-        return \"[StaticCodeTemplate: id=\" + getID() +\n-                \", text=\" + getBeforeCaretText() + \"|\" + getAfterCaretText() + \"]\";\n+        return \"[StaticCodeTemplate: id=\" + getID() + \", text=\" + getBeforeCaretText() + \"|\" + getAfterCaretText() + \"]\";\n     }\n \n }\n\\ No newline at end of file\n",
            "diff_size": 31
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "266",
                    "column": "53",
                    "severity": "warning",
                    "message": "'+' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "266",
                    "column": "53",
                    "severity": "warning",
                    "message": "'+' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}