{
    "project_name": "opencb-opencga",
    "error_id": "94",
    "information": {
        "errors": [
            {
                "line": "134",
                "severity": "error",
                "message": "Line is longer than 140 characters (found 153).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "    }\n\n    public ClinicalInterpretationManager(CatalogManager catalogManager, StorageEngineFactory storageEngineFactory, Path opencgaHome) throws IOException {\n        super(catalogManager, storageEngineFactory);\n\n        this.clinicalAnalysisManager = catalogManager.getClinicalAnalysisManager();",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "134",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/94/ClinicalInterpretationManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/94/ClinicalInterpretationManager.java\nindex d6dde662734..5f312760640 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/94/ClinicalInterpretationManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/94/ClinicalInterpretationManager.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.opencb.opencga.analysis.clinical;\n \n import com.fasterxml.jackson.databind.ObjectMapper;\n@@ -88,109 +89,110 @@ import static org.opencb.opencga.storage.core.variant.query.VariantQueryUtils.is\n \n public class ClinicalInterpretationManager extends StorageManager {\n \n-    public static final int LOW_COVERAGE_DEFAULT = 20;\n-    public static final int DEFAULT_COVERAGE_THRESHOLD = 20;\n+  public static final int LOW_COVERAGE_DEFAULT = 20;\n+  public static final int DEFAULT_COVERAGE_THRESHOLD = 20;\n \n-    private String database;\n+  private String database;\n \n-    private InterpretationAnalysisConfiguration config;\n+  private InterpretationAnalysisConfiguration config;\n \n-    private ClinicalAnalysisManager clinicalAnalysisManager;\n-    private ClinicalVariantEngine clinicalVariantEngine;\n-    private VariantStorageManager variantStorageManager;\n+  private ClinicalAnalysisManager clinicalAnalysisManager;\n+  private ClinicalVariantEngine clinicalVariantEngine;\n+  private VariantStorageManager variantStorageManager;\n \n-    protected CellBaseClient cellBaseClient;\n-    protected AlignmentStorageManager alignmentStorageManager;\n+  protected CellBaseClient cellBaseClient;\n+  protected AlignmentStorageManager alignmentStorageManager;\n \n-    private RoleInCancerManager roleInCancerManager;\n-    private ActionableVariantManager actionableVariantManager;\n+  private RoleInCancerManager roleInCancerManager;\n+  private ActionableVariantManager actionableVariantManager;\n \n-    private VariantCatalogQueryUtils catalogQueryUtils;\n+  private VariantCatalogQueryUtils catalogQueryUtils;\n \n-    private static Query defaultDeNovoQuery;\n-    private static Query defaultCompoundHeterozigousQuery;\n+  private static Query defaultDeNovoQuery;\n+  private static Query defaultCompoundHeterozigousQuery;\n \n-    static {\n-        defaultDeNovoQuery = new Query()\n-                .append(VariantQueryParam.ANNOT_POPULATION_ALTERNATE_FREQUENCY.key(), \"1kG_phase3:AFR<0.002;1kG_phase3:AMR<0.002;\"\n-                        + \"1kG_phase3:EAS<0.002;1kG_phase3:EUR<0.002;1kG_phase3:SAS<0.002;GNOMAD_EXOMES:AFR<0.001;GNOMAD_EXOMES:AMR<0.001;\"\n-                        + \"GNOMAD_EXOMES:EAS<0.001;GNOMAD_EXOMES:FIN<0.001;GNOMAD_EXOMES:NFE<0.001;GNOMAD_EXOMES:ASJ<0.001;\"\n-                        + \"GNOMAD_EXOMES:OTH<0.002\")\n-                .append(VariantQueryParam.STATS_MAF.key(), \"ALL<0.001\")\n-                .append(VariantQueryParam.ANNOT_BIOTYPE.key(), ModeOfInheritance.proteinCoding)\n-                .append(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key(), ModeOfInheritance.extendedLof)\n-                .append(VariantQueryParam.INCLUDE_GENOTYPE.key(), true)\n-                .append(VariantQueryParam.FILTER.key(), VCFConstants.PASSES_FILTERS_v4)\n-                .append(VariantQueryParam.UNKNOWN_GENOTYPE.key(), \"./.\");\n+  static {\n+    defaultDeNovoQuery = new Query()\n+        .append(VariantQueryParam.ANNOT_POPULATION_ALTERNATE_FREQUENCY.key(), \"1kG_phase3:AFR<0.002;1kG_phase3:AMR<0.002;\"\n+            + \"1kG_phase3:EAS<0.002;1kG_phase3:EUR<0.002;1kG_phase3:SAS<0.002;GNOMAD_EXOMES:AFR<0.001;GNOMAD_EXOMES:AMR<0.001;\"\n+            + \"GNOMAD_EXOMES:EAS<0.001;GNOMAD_EXOMES:FIN<0.001;GNOMAD_EXOMES:NFE<0.001;GNOMAD_EXOMES:ASJ<0.001;\"\n+            + \"GNOMAD_EXOMES:OTH<0.002\")\n+        .append(VariantQueryParam.STATS_MAF.key(), \"ALL<0.001\")\n+        .append(VariantQueryParam.ANNOT_BIOTYPE.key(), ModeOfInheritance.proteinCoding)\n+        .append(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key(), ModeOfInheritance.extendedLof)\n+        .append(VariantQueryParam.INCLUDE_GENOTYPE.key(), true)\n+        .append(VariantQueryParam.FILTER.key(), VCFConstants.PASSES_FILTERS_v4)\n+        .append(VariantQueryParam.UNKNOWN_GENOTYPE.key(), \"./.\");\n \n-        defaultCompoundHeterozigousQuery = new Query()\n-                .append(VariantQueryParam.ANNOT_BIOTYPE.key(), ModeOfInheritance.proteinCoding)\n-                .append(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key(), ModeOfInheritance.extendedLof)\n-                .append(VariantQueryParam.INCLUDE_GENOTYPE.key(), true)\n-                .append(VariantQueryParam.FILTER.key(), VCFConstants.PASSES_FILTERS_v4)\n-                .append(VariantQueryParam.UNKNOWN_GENOTYPE.key(), \"./.\");\n-    }\n+    defaultCompoundHeterozigousQuery = new Query()\n+        .append(VariantQueryParam.ANNOT_BIOTYPE.key(), ModeOfInheritance.proteinCoding)\n+        .append(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key(), ModeOfInheritance.extendedLof)\n+        .append(VariantQueryParam.INCLUDE_GENOTYPE.key(), true)\n+        .append(VariantQueryParam.FILTER.key(), VCFConstants.PASSES_FILTERS_v4)\n+        .append(VariantQueryParam.UNKNOWN_GENOTYPE.key(), \"./.\");\n+  }\n \n-    public ClinicalInterpretationManager(CatalogManager catalogManager, StorageEngineFactory storageEngineFactory, Path opencgaHome) throws IOException {\n-        super(catalogManager, storageEngineFactory);\n+  public ClinicalInterpretationManager(CatalogManager catalogManager, StorageEngineFactory storageEngineFactory, Path opencgaHome)\n+      throws IOException {\n+    super(catalogManager, storageEngineFactory);\n \n-        this.clinicalAnalysisManager = catalogManager.getClinicalAnalysisManager();\n-        this.variantStorageManager = new VariantStorageManager(catalogManager, StorageEngineFactory.get(storageConfiguration));\n+    this.clinicalAnalysisManager = catalogManager.getClinicalAnalysisManager();\n+    this.variantStorageManager = new VariantStorageManager(catalogManager, StorageEngineFactory.get(storageConfiguration));\n \n-        this.cellBaseClient = new CellBaseClient(storageConfiguration.getCellbase().toClientConfiguration());\n-        this.alignmentStorageManager = new AlignmentStorageManager(catalogManager, StorageEngineFactory.get(storageConfiguration));\n+    this.cellBaseClient = new CellBaseClient(storageConfiguration.getCellbase().toClientConfiguration());\n+    this.alignmentStorageManager = new AlignmentStorageManager(catalogManager, StorageEngineFactory.get(storageConfiguration));\n \n-        this.roleInCancerManager = new RoleInCancerManager(opencgaHome);\n-        this.actionableVariantManager = new ActionableVariantManager(opencgaHome);\n+    this.roleInCancerManager = new RoleInCancerManager(opencgaHome);\n+    this.actionableVariantManager = new ActionableVariantManager(opencgaHome);\n \n-        this.catalogQueryUtils = new VariantCatalogQueryUtils(catalogManager);\n+    this.catalogQueryUtils = new VariantCatalogQueryUtils(catalogManager);\n \n //        this.opencgaHome = opencgaHome;\n-        // Load interpretation analysis configuration\n-        if (opencgaHome != null) {\n-            ObjectMapper objectMapper = new ObjectMapper(new YAMLFactory());\n-            Path configPath = opencgaHome.resolve(\"analysis/clinical-variant-query.yml\");\n-            if (configPath.toFile().exists()) {\n-                FileInputStream fis = new FileInputStream(configPath.toFile());\n-                config = objectMapper.readValue(fis, InterpretationAnalysisConfiguration.class);\n-            }\n-        }\n+    // Load interpretation analysis configuration\n+    if (opencgaHome != null) {\n+      ObjectMapper objectMapper = new ObjectMapper(new YAMLFactory());\n+      Path configPath = opencgaHome.resolve(\"analysis/clinical-variant-query.yml\");\n+      if (configPath.toFile().exists()) {\n+        FileInputStream fis = new FileInputStream(configPath.toFile());\n+        config = objectMapper.readValue(fis, InterpretationAnalysisConfiguration.class);\n+      }\n+    }\n \n //        this.init();\n-    }\n+  }\n \n \n-    @Override\n-    public void testConnection() throws StorageEngineException {\n-    }\n+  @Override\n+  public void testConnection() throws StorageEngineException {\n+  }\n \n-    public DataResult<ClinicalVariant> index(String token) {\n-        return null;\n-    }\n+  public DataResult<ClinicalVariant> index(String token) {\n+    return null;\n+  }\n \n-    public DataResult<ClinicalVariant> index(String study, String token) throws IOException, ClinicalVariantException, CatalogException {\n-        DBIterator<ClinicalAnalysis> clinicalAnalysisDBIterator =\n-                clinicalAnalysisManager.iterator(study, new Query(), QueryOptions.empty(), token);\n+  public DataResult<ClinicalVariant> index(String study, String token) throws IOException, ClinicalVariantException, CatalogException {\n+    DBIterator<ClinicalAnalysis> clinicalAnalysisDBIterator =\n+        clinicalAnalysisManager.iterator(study, new Query(), QueryOptions.empty(), token);\n \n-        while (clinicalAnalysisDBIterator.hasNext()) {\n-            ClinicalAnalysis clinicalAnalysis = clinicalAnalysisDBIterator.next();\n-            if (clinicalAnalysis.getInterpretation() != null) {\n-                clinicalAnalysis.getInterpretation().getAttributes().put(\"OPENCGA_CLINICAL_ANALYSIS\", clinicalAnalysis);\n+    while (clinicalAnalysisDBIterator.hasNext()) {\n+      ClinicalAnalysis clinicalAnalysis = clinicalAnalysisDBIterator.next();\n+      if (clinicalAnalysis.getInterpretation() != null) {\n+        clinicalAnalysis.getInterpretation().getAttributes().put(\"OPENCGA_CLINICAL_ANALYSIS\", clinicalAnalysis);\n \n-                this.clinicalVariantEngine.insert(clinicalAnalysis.getInterpretation(), database);\n+        this.clinicalVariantEngine.insert(clinicalAnalysis.getInterpretation(), database);\n \n-            }\n-        }\n-        return null;\n+      }\n     }\n+    return null;\n+  }\n \n-    public DataResult<ClinicalVariant> query(Query query, QueryOptions options, String token)\n-            throws IOException, ClinicalVariantException, CatalogException {\n-        // Check permissions\n-        query = checkQueryPermissions(query, token);\n+  public DataResult<ClinicalVariant> query(Query query, QueryOptions options, String token)\n+      throws IOException, ClinicalVariantException, CatalogException {\n+    // Check permissions\n+    query = checkQueryPermissions(query, token);\n \n-        return clinicalVariantEngine.query(query, options, \"\");\n-    }\n+    return clinicalVariantEngine.query(query, options, \"\");\n+  }\n \n //    public DataResult<Interpretation> interpretationQuery(Query query, QueryOptions options, String token)\n //            throws IOException, ClinicalVariantException, CatalogException {\n@@ -200,220 +202,220 @@ public class ClinicalInterpretationManager extends StorageManager {\n //        return clinicalVariantEngine.interpretationQuery(query, options, \"\");\n //    }\n \n-    public DataResult<FacetField> facet(Query query, QueryOptions queryOptions, String token)\n-            throws IOException, ClinicalVariantException, CatalogException {\n-        // Check permissions\n-        query = checkQueryPermissions(query, token);\n+  public DataResult<FacetField> facet(Query query, QueryOptions queryOptions, String token)\n+      throws IOException, ClinicalVariantException, CatalogException {\n+    // Check permissions\n+    query = checkQueryPermissions(query, token);\n \n-        return clinicalVariantEngine.facet(query, queryOptions, \"\");\n-    }\n+    return clinicalVariantEngine.facet(query, queryOptions, \"\");\n+  }\n \n-    public ClinicalVariantIterator iterator(Query query, QueryOptions options, String token)\n-            throws IOException, ClinicalVariantException, CatalogException {\n-        // Check permissions\n-        query = checkQueryPermissions(query, token);\n+  public ClinicalVariantIterator iterator(Query query, QueryOptions options, String token)\n+      throws IOException, ClinicalVariantException, CatalogException {\n+    // Check permissions\n+    query = checkQueryPermissions(query, token);\n \n-        return clinicalVariantEngine.iterator(query, options, \"\");\n-    }\n+    return clinicalVariantEngine.iterator(query, options, \"\");\n+  }\n \n-    public void addInterpretationComment(String study, long interpretationId, ClinicalComment comment, String token)\n-            throws IOException, ClinicalVariantException, CatalogException {\n-        // Check permissions\n-        checkInterpretationPermissions(study, interpretationId, token);\n+  public void addInterpretationComment(String study, long interpretationId, ClinicalComment comment, String token)\n+      throws IOException, ClinicalVariantException, CatalogException {\n+    // Check permissions\n+    checkInterpretationPermissions(study, interpretationId, token);\n \n-        clinicalVariantEngine.addInterpretationComment(interpretationId, comment, \"\");\n-    }\n+    clinicalVariantEngine.addInterpretationComment(interpretationId, comment, \"\");\n+  }\n \n-    public void addClinicalVariantComment(String study, long interpretationId, String variantId, ClinicalComment comment, String token)\n-            throws IOException, ClinicalVariantException, CatalogException {\n-        // Check permissions\n-        checkInterpretationPermissions(study, interpretationId, token);\n+  public void addClinicalVariantComment(String study, long interpretationId, String variantId, ClinicalComment comment, String token)\n+      throws IOException, ClinicalVariantException, CatalogException {\n+    // Check permissions\n+    checkInterpretationPermissions(study, interpretationId, token);\n \n-        clinicalVariantEngine.addClinicalVariantComment(interpretationId, variantId, comment, \"\");\n-    }\n+    clinicalVariantEngine.addClinicalVariantComment(interpretationId, variantId, comment, \"\");\n+  }\n \n-    /*--------------------------------------------------------------------------*/\n-    /*  Get clinical variants                                                   */\n-    /*--------------------------------------------------------------------------*/\n+  /*--------------------------------------------------------------------------*/\n+  /*  Get clinical variants                                                   */\n+  /*--------------------------------------------------------------------------*/\n \n-    public OpenCGAResult<ClinicalVariant> get(Query query, QueryOptions queryOptions, String token)\n-            throws CatalogException, IOException, StorageEngineException {\n-        return get(query, queryOptions, config, token);\n-    }\n+  public OpenCGAResult<ClinicalVariant> get(Query query, QueryOptions queryOptions, String token)\n+      throws CatalogException, IOException, StorageEngineException {\n+    return get(query, queryOptions, config, token);\n+  }\n \n-    public OpenCGAResult<ClinicalVariant> get(Query query, QueryOptions queryOptions, InterpretationAnalysisConfiguration config,\n-                                              String token) throws CatalogException, IOException, StorageEngineException {\n+  public OpenCGAResult<ClinicalVariant> get(Query query, QueryOptions queryOptions, InterpretationAnalysisConfiguration config,\n+                                            String token) throws CatalogException, IOException, StorageEngineException {\n \n-        VariantQueryResult<Variant> variantQueryResult = variantStorageManager.get(query, queryOptions, token);\n-        List<Variant> variants = variantQueryResult.getResults();\n+    VariantQueryResult<Variant> variantQueryResult = variantStorageManager.get(query, queryOptions, token);\n+    List<Variant> variants = variantQueryResult.getResults();\n \n-        OpenCGAResult<ClinicalVariant> result = new OpenCGAResult<>(variantQueryResult.getTime(),\n-                variantQueryResult.getEvents(), variantQueryResult.getNumResults(), Collections.emptyList(),\n-                variantQueryResult.getNumMatches(), variantQueryResult.getAttributes());\n+    OpenCGAResult<ClinicalVariant> result = new OpenCGAResult<>(variantQueryResult.getTime(),\n+        variantQueryResult.getEvents(), variantQueryResult.getNumResults(), Collections.emptyList(),\n+        variantQueryResult.getNumMatches(), variantQueryResult.getAttributes());\n \n-        if (CollectionUtils.isEmpty(variantQueryResult.getResults())) {\n-            return result;\n-        }\n+    if (CollectionUtils.isEmpty(variantQueryResult.getResults())) {\n+      return result;\n+    }\n \n-        StopWatch watch = StopWatch.createStarted();\n+    StopWatch watch = StopWatch.createStarted();\n \n-        // Get study from query\n-        String studyId = query.getString(STUDY.key());\n+    // Get study from query\n+    String studyId = query.getString(STUDY.key());\n \n-        // Get assembly\n-        String assembly = getAssembly(studyId, token);\n+    // Get assembly\n+    String assembly = getAssembly(studyId, token);\n \n-        // Prepare map<gene name, set of panel names>\n-        Map<String, Set<String>> genePanelMap = new HashMap<>();\n+    // Prepare map<gene name, set of panel names>\n+    Map<String, Set<String>> genePanelMap = new HashMap<>();\n \n-        if (isValidParam(query, PANEL)) {\n-            List<String> panels = query.getAsStringList(PANEL.key());\n-            for (String panelId : panels) {\n-                org.opencb.opencga.core.models.panel.Panel panel = catalogQueryUtils.getPanel(studyId, panelId, token);\n-                for (DiseasePanel.GenePanel genePanel : panel.getGenes()) {\n-                    if (!genePanelMap.containsKey(genePanel.getName())) {\n-                        genePanelMap.put(genePanel.getName(), new HashSet<>());\n-                    }\n-                    genePanelMap.get(genePanel.getName()).add(panelId);\n-                }\n-            }\n+    if (isValidParam(query, PANEL)) {\n+      List<String> panels = query.getAsStringList(PANEL.key());\n+      for (String panelId : panels) {\n+        org.opencb.opencga.core.models.panel.Panel panel = catalogQueryUtils.getPanel(studyId, panelId, token);\n+        for (DiseasePanel.GenePanel genePanel : panel.getGenes()) {\n+          if (!genePanelMap.containsKey(genePanel.getName())) {\n+            genePanelMap.put(genePanel.getName(), new HashSet<>());\n+          }\n+          genePanelMap.get(genePanel.getName()).add(panelId);\n         }\n+      }\n+    }\n \n-        Map<String, ClinicalProperty.RoleInCancer> roleInCancer = roleInCancerManager.getRoleInCancer();\n-        Map<String, List<String>> actionableVariants = actionableVariantManager.getActionableVariants(assembly);\n-\n-        List<ClinicalVariant> clinicalVariants = new ArrayList<>();\n-\n-        for (Variant variant : variants) {\n-            ClinicalVariant clinicalVariant = createClinicalVariant(variant, genePanelMap, roleInCancer, actionableVariants, config);\n-            if (clinicalVariant != null) {\n-                clinicalVariants.add(clinicalVariant);\n-            }\n-        }\n+    Map<String, ClinicalProperty.RoleInCancer> roleInCancer = roleInCancerManager.getRoleInCancer();\n+    Map<String, List<String>> actionableVariants = actionableVariantManager.getActionableVariants(assembly);\n \n-        int dbTime = (int) watch.getTime(TimeUnit.MILLISECONDS);\n-        result.setTime(variantQueryResult.getTime() + dbTime);\n-        result.setResults(clinicalVariants);\n+    List<ClinicalVariant> clinicalVariants = new ArrayList<>();\n \n-        return result;\n+    for (Variant variant : variants) {\n+      ClinicalVariant clinicalVariant = createClinicalVariant(variant, genePanelMap, roleInCancer, actionableVariants, config);\n+      if (clinicalVariant != null) {\n+        clinicalVariants.add(clinicalVariant);\n+      }\n     }\n \n-    /*--------------------------------------------------------------------------*/\n-    /*  Get actionable variants                                                 */\n-    /*--------------------------------------------------------------------------*/\n-\n-    public OpenCGAResult<ClinicalVariant> getActionableVariants(String studyId, String sampleId, String token)\n-            throws CatalogException, IOException, StorageEngineException {\n-\n-        // Start watch\n-        StopWatch watch = StopWatch.createStarted();\n-\n-        List<Variant> variants = new ArrayList<>();\n-\n-        // Prepare query object\n-        Query query = new Query();\n-        query.put(STUDY.key(), studyId);\n-        query.put(VariantQueryParam.SAMPLE.key(), sampleId);\n-\n-        // Get the correct actionable variants for the assembly\n-        String assembly = getAssembly(studyId, token);\n-        Map<String, List<String>> actionableVariants = actionableVariantManager.getActionableVariants(assembly);\n-        if (actionableVariants != null) {\n-            Iterator<String> iterator = actionableVariants.keySet().iterator();\n-            List<String> variantIds = new ArrayList<>();\n-            while (iterator.hasNext()) {\n-                String id = iterator.next();\n-                variantIds.add(id);\n-                if (variantIds.size() >= 1000) {\n-                    query.put(VariantQueryParam.ID.key(), variantIds);\n-                    VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), token);\n-                    variants.addAll(result.getResults());\n-                    variantIds.clear();\n-                }\n-            }\n-\n-            if (variantIds.size() > 0) {\n-                query.put(VariantQueryParam.ID.key(), variantIds);\n-                VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), token);\n-                variants.addAll(result.getResults());\n-            }\n-        }\n-\n-        // Convert variant into clinical variant\n-        List<ClinicalVariant> clinicalVariants = new ArrayList<>();\n-        for (Variant variant : variants) {\n-            ClinicalVariant clinicalVariant = createClinicalVariant(variant, null, roleInCancerManager.getRoleInCancer(),\n-                    actionableVariants, null);\n-            if (clinicalVariant != null) {\n-                clinicalVariants.add(clinicalVariant);\n-            }\n+    int dbTime = (int) watch.getTime(TimeUnit.MILLISECONDS);\n+    result.setTime(variantQueryResult.getTime() + dbTime);\n+    result.setResults(clinicalVariants);\n+\n+    return result;\n+  }\n+\n+  /*--------------------------------------------------------------------------*/\n+  /*  Get actionable variants                                                 */\n+  /*--------------------------------------------------------------------------*/\n+\n+  public OpenCGAResult<ClinicalVariant> getActionableVariants(String studyId, String sampleId, String token)\n+      throws CatalogException, IOException, StorageEngineException {\n+\n+    // Start watch\n+    StopWatch watch = StopWatch.createStarted();\n+\n+    List<Variant> variants = new ArrayList<>();\n+\n+    // Prepare query object\n+    Query query = new Query();\n+    query.put(STUDY.key(), studyId);\n+    query.put(VariantQueryParam.SAMPLE.key(), sampleId);\n+\n+    // Get the correct actionable variants for the assembly\n+    String assembly = getAssembly(studyId, token);\n+    Map<String, List<String>> actionableVariants = actionableVariantManager.getActionableVariants(assembly);\n+    if (actionableVariants != null) {\n+      Iterator<String> iterator = actionableVariants.keySet().iterator();\n+      List<String> variantIds = new ArrayList<>();\n+      while (iterator.hasNext()) {\n+        String id = iterator.next();\n+        variantIds.add(id);\n+        if (variantIds.size() >= 1000) {\n+          query.put(VariantQueryParam.ID.key(), variantIds);\n+          VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), token);\n+          variants.addAll(result.getResults());\n+          variantIds.clear();\n         }\n+      }\n \n-        int dbTime = (int) watch.getTime(TimeUnit.MILLISECONDS);\n+      if (variantIds.size() > 0) {\n+        query.put(VariantQueryParam.ID.key(), variantIds);\n+        VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), token);\n+        variants.addAll(result.getResults());\n+      }\n+    }\n \n-        return new OpenCGAResult<>(dbTime, Collections.emptyList(), clinicalVariants.size(), clinicalVariants, clinicalVariants.size());\n+    // Convert variant into clinical variant\n+    List<ClinicalVariant> clinicalVariants = new ArrayList<>();\n+    for (Variant variant : variants) {\n+      ClinicalVariant clinicalVariant = createClinicalVariant(variant, null, roleInCancerManager.getRoleInCancer(),\n+          actionableVariants, null);\n+      if (clinicalVariant != null) {\n+        clinicalVariants.add(clinicalVariant);\n+      }\n     }\n \n-    /*--------------------------------------------------------------------------*/\n-\n-    private ClinicalVariant createClinicalVariant(Variant variant, Map<String, Set<String>> genePanelMap,\n-                                                  Map<String, ClinicalProperty.RoleInCancer> roleInCancer,\n-                                                  Map<String, List<String>> actionableVariants,\n-                                                  InterpretationAnalysisConfiguration config) {\n-        List<String> panelIds;\n-        GenomicFeature gFeature;\n-        List<ClinicalVariantEvidence> evidences = new ArrayList<>();\n-\n-        if (variant.getAnnotation() != null && CollectionUtils.isNotEmpty(variant.getAnnotation().getConsequenceTypes())) {\n-            for (ConsequenceType ct: variant.getAnnotation().getConsequenceTypes()) {\n-                gFeature = new GenomicFeature(ct.getGeneId(), \"GENE\", ct.getTranscriptId(), ct.getGeneName(),\n-                        ct.getSequenceOntologyTerms(), null);\n-                panelIds = null;\n-                if (genePanelMap.containsKey(ct.getGeneId())) {\n-                    panelIds = new ArrayList<>(genePanelMap.get(ct.getGeneId()));\n-                } else if (genePanelMap.containsKey(ct.getGeneName())) {\n-                    panelIds = new ArrayList<>(genePanelMap.get(ct.getGeneName()));\n-                }\n-\n-\n-                ClinicalVariantEvidence evidence;\n-                if (CollectionUtils.isNotEmpty(panelIds)) {\n-                    for (String panelId : panelIds) {\n-                        evidence = createEvidence(variant.getId(), ct, gFeature, panelId, null, null, variant.getAnnotation(),\n-                                roleInCancer, actionableVariants, config);\n-                        if (config == null || !config.isSkipUntieredVariants() || evidence.getClassification().getTier() != UNTIERED) {\n-                            evidences.add(evidence);\n-                        }\n-                    }\n-                } else {\n-                    evidence = createEvidence(variant.getId(), ct, gFeature, null, null, null, variant.getAnnotation(), roleInCancer,\n-                            actionableVariants, config);\n-                    if (config == null || !config.isSkipUntieredVariants() || evidence.getClassification().getTier() != UNTIERED) {\n-                        evidences.add(evidence);\n-                    }\n-                }\n-            }\n+    int dbTime = (int) watch.getTime(TimeUnit.MILLISECONDS);\n+\n+    return new OpenCGAResult<>(dbTime, Collections.emptyList(), clinicalVariants.size(), clinicalVariants, clinicalVariants.size());\n+  }\n+\n+  /*--------------------------------------------------------------------------*/\n+\n+  private ClinicalVariant createClinicalVariant(Variant variant, Map<String, Set<String>> genePanelMap,\n+                                                Map<String, ClinicalProperty.RoleInCancer> roleInCancer,\n+                                                Map<String, List<String>> actionableVariants,\n+                                                InterpretationAnalysisConfiguration config) {\n+    List<String> panelIds;\n+    GenomicFeature gFeature;\n+    List<ClinicalVariantEvidence> evidences = new ArrayList<>();\n+\n+    if (variant.getAnnotation() != null && CollectionUtils.isNotEmpty(variant.getAnnotation().getConsequenceTypes())) {\n+      for (ConsequenceType ct : variant.getAnnotation().getConsequenceTypes()) {\n+        gFeature = new GenomicFeature(ct.getGeneId(), \"GENE\", ct.getTranscriptId(), ct.getGeneName(),\n+            ct.getSequenceOntologyTerms(), null);\n+        panelIds = null;\n+        if (genePanelMap.containsKey(ct.getGeneId())) {\n+          panelIds = new ArrayList<>(genePanelMap.get(ct.getGeneId()));\n+        } else if (genePanelMap.containsKey(ct.getGeneName())) {\n+          panelIds = new ArrayList<>(genePanelMap.get(ct.getGeneName()));\n         }\n \n-        if (config != null && config.isSkipUntieredVariants() && CollectionUtils.isEmpty(evidences)) {\n-            return null;\n+\n+        ClinicalVariantEvidence evidence;\n+        if (CollectionUtils.isNotEmpty(panelIds)) {\n+          for (String panelId : panelIds) {\n+            evidence = createEvidence(variant.getId(), ct, gFeature, panelId, null, null, variant.getAnnotation(),\n+                roleInCancer, actionableVariants, config);\n+            if (config == null || !config.isSkipUntieredVariants() || evidence.getClassification().getTier() != UNTIERED) {\n+              evidences.add(evidence);\n+            }\n+          }\n+        } else {\n+          evidence = createEvidence(variant.getId(), ct, gFeature, null, null, null, variant.getAnnotation(), roleInCancer,\n+              actionableVariants, config);\n+          if (config == null || !config.isSkipUntieredVariants() || evidence.getClassification().getTier() != UNTIERED) {\n+            evidences.add(evidence);\n+          }\n         }\n+      }\n+    }\n \n-        ClinicalVariant clinicalVariant = new ClinicalVariant(variant.getImpl());\n-        clinicalVariant.setEvidences(evidences);\n-        return clinicalVariant;\n+    if (config != null && config.isSkipUntieredVariants() && CollectionUtils.isEmpty(evidences)) {\n+      return null;\n     }\n \n-    /*--------------------------------------------------------------------------*/\n+    ClinicalVariant clinicalVariant = new ClinicalVariant(variant.getImpl());\n+    clinicalVariant.setEvidences(evidences);\n+    return clinicalVariant;\n+  }\n+\n+  /*--------------------------------------------------------------------------*/\n \n-    protected ClinicalVariantEvidence createEvidence(String variantId, ConsequenceType consequenceType, GenomicFeature genomicFeature,\n-                                                     String panelId, ClinicalProperty.ModeOfInheritance moi,\n-                                                     ClinicalProperty.Penetrance penetrance, VariantAnnotation annotation,\n-                                                     Map<String, ClinicalProperty.RoleInCancer> roleInCancer,\n-                                                     Map<String, List<String>> actionableVariants,\n-                                                     InterpretationAnalysisConfiguration config) {\n+  protected ClinicalVariantEvidence createEvidence(String variantId, ConsequenceType consequenceType, GenomicFeature genomicFeature,\n+                                                   String panelId, ClinicalProperty.ModeOfInheritance moi,\n+                                                   ClinicalProperty.Penetrance penetrance, VariantAnnotation annotation,\n+                                                   Map<String, ClinicalProperty.RoleInCancer> roleInCancer,\n+                                                   Map<String, List<String>> actionableVariants,\n+                                                   InterpretationAnalysisConfiguration config) {\n \n-        ClinicalVariantEvidence clinicalVariantEvidence = new ClinicalVariantEvidence();\n+    ClinicalVariantEvidence clinicalVariantEvidence = new ClinicalVariantEvidence();\n \n //        // Consequence types\n //        if (CollectionUtils.isNotEmpty(consequenceType.getSequenceOntologyTerms())) {\n@@ -421,505 +423,505 @@ public class ClinicalInterpretationManager extends StorageManager {\n //            clinicalVariantEvidence.setConsequenceTypes(consequenceType.getSequenceOntologyTerms());\n //        }\n \n-        // Genomic feature\n-        if (genomicFeature != null) {\n-            clinicalVariantEvidence.setGenomicFeature(genomicFeature);\n-        }\n-\n-        // Panel ID and compute tier based on SO terms\n-        String tier = UNTIERED;\n-        if (config != null) {\n-            if (isTier1(panelId, consequenceType.getSequenceOntologyTerms(), config)) {\n-                tier = TIER_1;\n-            } else if (isTier2(panelId, consequenceType.getSequenceOntologyTerms(), config)) {\n-                tier = TIER_2;\n-            }\n-        }\n-\n-        // Mode of inheritance\n-        if (moi != null) {\n-            clinicalVariantEvidence.setModeOfInheritance(moi);\n-        }\n-\n-        // Penetrance\n-        if (penetrance != null) {\n-            clinicalVariantEvidence.setPenetrance(penetrance);\n-        }\n-\n-        // Variant classification:\n-        clinicalVariantEvidence.setClassification(new VariantClassification());\n+    // Genomic feature\n+    if (genomicFeature != null) {\n+      clinicalVariantEvidence.setGenomicFeature(genomicFeature);\n+    }\n \n-        // Variant classification: ACMG\n-        List<String> acmgs = calculateAcmgClassification(consequenceType, annotation, moi);\n-        clinicalVariantEvidence.getClassification().setAcmg(acmgs);\n+    // Panel ID and compute tier based on SO terms\n+    String tier = UNTIERED;\n+    if (config != null) {\n+      if (isTier1(panelId, consequenceType.getSequenceOntologyTerms(), config)) {\n+        tier = TIER_1;\n+      } else if (isTier2(panelId, consequenceType.getSequenceOntologyTerms(), config)) {\n+        tier = TIER_2;\n+      }\n+    }\n \n-        // Variant classification: clinical significance\n-        clinicalVariantEvidence.getClassification().setClinicalSignificance(computeClinicalSignificance(acmgs));\n+    // Mode of inheritance\n+    if (moi != null) {\n+      clinicalVariantEvidence.setModeOfInheritance(moi);\n+    }\n \n-        // Role in cancer\n-        if (roleInCancer != null && genomicFeature != null && \"GENE\".equals(genomicFeature.getType())) {\n-            if (roleInCancer.containsKey(genomicFeature.getGeneName())) {\n-                clinicalVariantEvidence.setRoleInCancer(roleInCancer.get(genomicFeature.getGeneName()));\n-            }\n-        }\n+    // Penetrance\n+    if (penetrance != null) {\n+      clinicalVariantEvidence.setPenetrance(penetrance);\n+    }\n \n-        // Set tier and actionable if necessary\n-        if (MapUtils.isNotEmpty(actionableVariants) && actionableVariants.containsKey(variantId)) {\n-            clinicalVariantEvidence.setActionable(true);\n+    // Variant classification:\n+    clinicalVariantEvidence.setClassification(new VariantClassification());\n \n-            // Set tier 3 only if it is null or untiered\n-            if (UNTIERED.equals(tier)) {\n-                clinicalVariantEvidence.getClassification().setTier(TIER_3);\n-            } else {\n-                clinicalVariantEvidence.getClassification().setTier(tier);\n-            }\n+    // Variant classification: ACMG\n+    List<String> acmgs = calculateAcmgClassification(consequenceType, annotation, moi);\n+    clinicalVariantEvidence.getClassification().setAcmg(acmgs);\n \n-            // Add 'actionable' phenotypes\n-            if (CollectionUtils.isNotEmpty(actionableVariants.get(variantId))) {\n-                List<Phenotype> phenotypes = new ArrayList<>();\n-                for (String phenotypeId : actionableVariants.get(variantId)) {\n-                    phenotypes.add(new Phenotype(phenotypeId, phenotypeId, \"\"));\n-                }\n-                if (CollectionUtils.isNotEmpty(phenotypes)) {\n-                    clinicalVariantEvidence.setPhenotypes(phenotypes);\n-                }\n-            }\n-        } else {\n-            clinicalVariantEvidence.getClassification().setTier(tier);\n-        }\n+    // Variant classification: clinical significance\n+    clinicalVariantEvidence.getClassification().setClinicalSignificance(computeClinicalSignificance(acmgs));\n \n-        return clinicalVariantEvidence;\n+    // Role in cancer\n+    if (roleInCancer != null && genomicFeature != null && \"GENE\".equals(genomicFeature.getType())) {\n+      if (roleInCancer.containsKey(genomicFeature.getGeneName())) {\n+        clinicalVariantEvidence.setRoleInCancer(roleInCancer.get(genomicFeature.getGeneName()));\n+      }\n     }\n \n-    private boolean isTier1(String panelId, List<SequenceOntologyTerm> soTerms, InterpretationAnalysisConfiguration config) {\n-        if (config.getTier1() != null) {\n-            if (StringUtils.isEmpty(panelId) && config.getTier1().isPanels()) {\n-                return false;\n-            }\n-\n-            if (CollectionUtils.isNotEmpty(config.getTier1().getConsequenceTypes())) {\n-                Set<String> tierSO = new HashSet<>(config.getTier1().getConsequenceTypes());\n-                for (SequenceOntologyTerm soTerm : soTerms) {\n-                    if (tierSO.contains(soTerm.getName())) {\n-                        return true;\n-                    }\n-                }\n-            }\n+    // Set tier and actionable if necessary\n+    if (MapUtils.isNotEmpty(actionableVariants) && actionableVariants.containsKey(variantId)) {\n+      clinicalVariantEvidence.setActionable(true);\n+\n+      // Set tier 3 only if it is null or untiered\n+      if (UNTIERED.equals(tier)) {\n+        clinicalVariantEvidence.getClassification().setTier(TIER_3);\n+      } else {\n+        clinicalVariantEvidence.getClassification().setTier(tier);\n+      }\n+\n+      // Add 'actionable' phenotypes\n+      if (CollectionUtils.isNotEmpty(actionableVariants.get(variantId))) {\n+        List<Phenotype> phenotypes = new ArrayList<>();\n+        for (String phenotypeId : actionableVariants.get(variantId)) {\n+          phenotypes.add(new Phenotype(phenotypeId, phenotypeId, \"\"));\n         }\n-        return false;\n-    }\n-\n-    private boolean isTier2(String panelId, List<SequenceOntologyTerm> soTerms, InterpretationAnalysisConfiguration config) {\n-        if (config.getTier2() != null) {\n-            if (StringUtils.isEmpty(panelId) && config.getTier2().isPanels()) {\n-                return false;\n-            }\n-\n-            if (CollectionUtils.isNotEmpty(config.getTier2().getConsequenceTypes())) {\n-                Set<String> tierSO = new HashSet<>(config.getTier1().getConsequenceTypes());\n-                for (SequenceOntologyTerm soTerm : soTerms) {\n-                    if (tierSO.contains(soTerm.getName())) {\n-                        return true;\n-                    }\n-                }\n-            }\n+        if (CollectionUtils.isNotEmpty(phenotypes)) {\n+          clinicalVariantEvidence.setPhenotypes(phenotypes);\n         }\n-        return false;\n+      }\n+    } else {\n+      clinicalVariantEvidence.getClassification().setTier(tier);\n     }\n \n-    /*--------------------------------------------------------------------------*/\n-    /*                 Clinical interpretation analysis utils                   */\n-    /*--------------------------------------------------------------------------*/\n-\n-    public List<Variant> getDeNovoVariants(String clinicalAnalysisId, String studyId, Query query, QueryOptions queryOptions,\n-                                           String sessionId)\n-            throws ToolException, CatalogException, StorageEngineException, IOException {\n-        logger.debug(\"Getting DeNovo variants\");\n+    return clinicalVariantEvidence;\n+  }\n \n-        Query currentQuery = new Query(defaultDeNovoQuery).append(STUDY.key(), studyId);\n-\n-        if (MapUtils.isNotEmpty(query)) {\n-            currentQuery.putAll(query);\n+  private boolean isTier1(String panelId, List<SequenceOntologyTerm> soTerms, InterpretationAnalysisConfiguration config) {\n+    if (config.getTier1() != null) {\n+      if (StringUtils.isEmpty(panelId) && config.getTier1().isPanels()) {\n+        return false;\n+      }\n+\n+      if (CollectionUtils.isNotEmpty(config.getTier1().getConsequenceTypes())) {\n+        Set<String> tierSO = new HashSet<>(config.getTier1().getConsequenceTypes());\n+        for (SequenceOntologyTerm soTerm : soTerms) {\n+          if (tierSO.contains(soTerm.getName())) {\n+            return true;\n+          }\n         }\n+      }\n+    }\n+    return false;\n+  }\n \n-        // Get and check clinical analysis and proband\n-        ClinicalAnalysis clinicalAnalysis = getClinicalAnalysis(studyId, clinicalAnalysisId, sessionId);\n-        Individual proband = ClinicalUtils.getProband(clinicalAnalysis);\n-\n-        OpenCGAResult<Study> studyQueryResult = catalogManager.getStudyManager().get(studyId,\n-                new QueryOptions(QueryOptions.INCLUDE, StudyDBAdaptor.QueryParams.FQN.key()), sessionId);\n-        if (studyQueryResult.getNumResults() == 0) {\n-            throw new ToolException(\"Study \" + studyId + \" not found\");\n+  private boolean isTier2(String panelId, List<SequenceOntologyTerm> soTerms, InterpretationAnalysisConfiguration config) {\n+    if (config.getTier2() != null) {\n+      if (StringUtils.isEmpty(panelId) && config.getTier2().isPanels()) {\n+        return false;\n+      }\n+\n+      if (CollectionUtils.isNotEmpty(config.getTier2().getConsequenceTypes())) {\n+        Set<String> tierSO = new HashSet<>(config.getTier1().getConsequenceTypes());\n+        for (SequenceOntologyTerm soTerm : soTerms) {\n+          if (tierSO.contains(soTerm.getName())) {\n+            return true;\n+          }\n         }\n+      }\n+    }\n+    return false;\n+  }\n \n-        List<Variant> variants;\n-\n-        String sampleId = proband.getSamples().get(0).getId();\n-        SampleMetadata sampleMetadata = variantStorageManager.getSampleMetadata(studyQueryResult.first().getFqn(), sampleId, sessionId);\n-        if (TaskMetadata.Status.READY.equals(sampleMetadata.getMendelianErrorStatus())) {\n-            logger.debug(\"Getting precomputed DE NOVO variants\");\n-\n-            // Mendelian errors are pre-calculated\n-            currentQuery.put(FAMILY.key(), clinicalAnalysis.getFamily().getId());\n-            currentQuery.put(FAMILY_SEGREGATION.key(), \"DeNovo\");\n-            currentQuery.put(INCLUDE_SAMPLE.key(), sampleId);\n-\n-            logger.debug(\"Query: {}\", currentQuery.safeToString());\n+  /*--------------------------------------------------------------------------*/\n+  /*                 Clinical interpretation analysis utils                   */\n+  /*--------------------------------------------------------------------------*/\n \n-            variants = variantStorageManager.get(currentQuery, queryOptions, sessionId).getResults();\n-        } else {\n-            // Get pedigree\n-            Pedigree pedigree = FamilyManager.getPedigreeFromFamily(clinicalAnalysis.getFamily(), proband.getId());\n-\n-            // Discard members from the pedigree that do not have any samples. If we don't do this, we will always assume\n-            ClinicalUtils.removeMembersWithoutSamples(pedigree, clinicalAnalysis.getFamily());\n-\n-            // Get the map of <individual ID, sample ID> and update proband information (to be able to navigate to the parents and their\n-            // samples easily)\n-            Map<String, String> sampleMap = ClinicalUtils.getSampleMap(clinicalAnalysis, proband);\n-            Map<String, List<String>> genotypeMap = ModeOfInheritance.deNovo(pedigree);\n-            List<String> samples = new ArrayList<>();\n-            List<String> genotypeList = new ArrayList<>();\n-            for (Map.Entry<String, List<String>> entry : genotypeMap.entrySet()) {\n-                if (sampleMap.containsKey(entry.getKey())) {\n-                    genotypeList.add(sampleMap.get(entry.getKey()) + \":\" + StringUtils.join(entry.getValue(), VariantQueryUtils.OR));\n-                }\n-            }\n-            if (genotypeList.isEmpty()) {\n-                logger.error(\"No genotypes found\");\n-                return null;\n-            }\n-            currentQuery.put(VariantQueryParam.GENOTYPE.key(), StringUtils.join(genotypeList, \";\"));\n-            samples.add(sampleMap.get(proband.getId()));\n-\n-            int motherSampleIdx = 1;\n-            int fatherSampleIdx = 2;\n-\n-            if (proband.getMother() != null && StringUtils.isNotEmpty(proband.getMother().getId())\n-                    && sampleMap.containsKey(proband.getMother().getId())) {\n-                samples.add(sampleMap.get(proband.getMother().getId()));\n-            } else {\n-                motherSampleIdx = -1;\n-                fatherSampleIdx = 1;\n-            }\n-            if (proband.getFather() != null && StringUtils.isNotEmpty(proband.getFather().getId())\n-                    && sampleMap.containsKey(proband.getFather().getId())) {\n-                samples.add(sampleMap.get(proband.getFather().getId()));\n-            } else {\n-                fatherSampleIdx = -1;\n-            }\n+  public List<Variant> getDeNovoVariants(String clinicalAnalysisId, String studyId, Query query, QueryOptions queryOptions,\n+                                         String sessionId)\n+      throws ToolException, CatalogException, StorageEngineException, IOException {\n+    logger.debug(\"Getting DeNovo variants\");\n \n-            currentQuery.put(INCLUDE_SAMPLE.key(), samples);\n-            cleanQuery(currentQuery);\n+    Query currentQuery = new Query(defaultDeNovoQuery).append(STUDY.key(), studyId);\n \n-            VariantDBIterator iterator = variantStorageManager.iterator(currentQuery, queryOptions, sessionId);\n-            variants = ModeOfInheritance.deNovo(iterator, 0, motherSampleIdx, fatherSampleIdx);\n-        }\n-        logger.debug(\"DeNovo variants obtained: {}\", variants.size());\n-\n-        return variants;\n+    if (MapUtils.isNotEmpty(query)) {\n+      currentQuery.putAll(query);\n     }\n \n-    public Map<String, List<Variant>> getCompoundHeterozigousVariants(String clinicalAnalysisId, String studyId, Query query,\n-                                                                      QueryOptions queryOptions, String sessionId)\n-            throws ToolException, CatalogException, StorageEngineException, IOException {\n-        logger.debug(\"Getting Compound Heterozigous variants\");\n+    // Get and check clinical analysis and proband\n+    ClinicalAnalysis clinicalAnalysis = getClinicalAnalysis(studyId, clinicalAnalysisId, sessionId);\n+    Individual proband = ClinicalUtils.getProband(clinicalAnalysis);\n \n-        Query currentQuery = new Query(defaultCompoundHeterozigousQuery).append(STUDY.key(), studyId);\n+    OpenCGAResult<Study> studyQueryResult = catalogManager.getStudyManager().get(studyId,\n+        new QueryOptions(QueryOptions.INCLUDE, StudyDBAdaptor.QueryParams.FQN.key()), sessionId);\n+    if (studyQueryResult.getNumResults() == 0) {\n+      throw new ToolException(\"Study \" + studyId + \" not found\");\n+    }\n \n-        if (MapUtils.isNotEmpty(query)) {\n-            currentQuery.putAll(query);\n+    List<Variant> variants;\n+\n+    String sampleId = proband.getSamples().get(0).getId();\n+    SampleMetadata sampleMetadata = variantStorageManager.getSampleMetadata(studyQueryResult.first().getFqn(), sampleId, sessionId);\n+    if (TaskMetadata.Status.READY.equals(sampleMetadata.getMendelianErrorStatus())) {\n+      logger.debug(\"Getting precomputed DE NOVO variants\");\n+\n+      // Mendelian errors are pre-calculated\n+      currentQuery.put(FAMILY.key(), clinicalAnalysis.getFamily().getId());\n+      currentQuery.put(FAMILY_SEGREGATION.key(), \"DeNovo\");\n+      currentQuery.put(INCLUDE_SAMPLE.key(), sampleId);\n+\n+      logger.debug(\"Query: {}\", currentQuery.safeToString());\n+\n+      variants = variantStorageManager.get(currentQuery, queryOptions, sessionId).getResults();\n+    } else {\n+      // Get pedigree\n+      Pedigree pedigree = FamilyManager.getPedigreeFromFamily(clinicalAnalysis.getFamily(), proband.getId());\n+\n+      // Discard members from the pedigree that do not have any samples. If we don't do this, we will always assume\n+      ClinicalUtils.removeMembersWithoutSamples(pedigree, clinicalAnalysis.getFamily());\n+\n+      // Get the map of <individual ID, sample ID> and update proband information (to be able to navigate to the parents and their\n+      // samples easily)\n+      Map<String, String> sampleMap = ClinicalUtils.getSampleMap(clinicalAnalysis, proband);\n+      Map<String, List<String>> genotypeMap = ModeOfInheritance.deNovo(pedigree);\n+      List<String> samples = new ArrayList<>();\n+      List<String> genotypeList = new ArrayList<>();\n+      for (Map.Entry<String, List<String>> entry : genotypeMap.entrySet()) {\n+        if (sampleMap.containsKey(entry.getKey())) {\n+          genotypeList.add(sampleMap.get(entry.getKey()) + \":\" + StringUtils.join(entry.getValue(), VariantQueryUtils.OR));\n         }\n+      }\n+      if (genotypeList.isEmpty()) {\n+        logger.error(\"No genotypes found\");\n+        return null;\n+      }\n+      currentQuery.put(VariantQueryParam.GENOTYPE.key(), StringUtils.join(genotypeList, \";\"));\n+      samples.add(sampleMap.get(proband.getId()));\n+\n+      int motherSampleIdx = 1;\n+      int fatherSampleIdx = 2;\n+\n+      if (proband.getMother() != null && StringUtils.isNotEmpty(proband.getMother().getId())\n+          && sampleMap.containsKey(proband.getMother().getId())) {\n+        samples.add(sampleMap.get(proband.getMother().getId()));\n+      } else {\n+        motherSampleIdx = -1;\n+        fatherSampleIdx = 1;\n+      }\n+      if (proband.getFather() != null && StringUtils.isNotEmpty(proband.getFather().getId())\n+          && sampleMap.containsKey(proband.getFather().getId())) {\n+        samples.add(sampleMap.get(proband.getFather().getId()));\n+      } else {\n+        fatherSampleIdx = -1;\n+      }\n+\n+      currentQuery.put(INCLUDE_SAMPLE.key(), samples);\n+      cleanQuery(currentQuery);\n+\n+      VariantDBIterator iterator = variantStorageManager.iterator(currentQuery, queryOptions, sessionId);\n+      variants = ModeOfInheritance.deNovo(iterator, 0, motherSampleIdx, fatherSampleIdx);\n+    }\n+    logger.debug(\"DeNovo variants obtained: {}\", variants.size());\n \n-        // Get and check clinical analysis and proband\n-        ClinicalAnalysis clinicalAnalysis = getClinicalAnalysis(studyId, clinicalAnalysisId, sessionId);\n-        Individual proband = ClinicalUtils.getProband(clinicalAnalysis);\n+    return variants;\n+  }\n \n-        // Get pedigree\n-        Pedigree pedigree = FamilyManager.getPedigreeFromFamily(clinicalAnalysis.getFamily(), proband.getId());\n+  public Map<String, List<Variant>> getCompoundHeterozigousVariants(String clinicalAnalysisId, String studyId, Query query,\n+                                                                    QueryOptions queryOptions, String sessionId)\n+      throws ToolException, CatalogException, StorageEngineException, IOException {\n+    logger.debug(\"Getting Compound Heterozigous variants\");\n \n-        // Discard members from the pedigree that do not have any samples. If we don't do this, we will always assume\n-        ClinicalUtils.removeMembersWithoutSamples(pedigree, clinicalAnalysis.getFamily());\n+    Query currentQuery = new Query(defaultCompoundHeterozigousQuery).append(STUDY.key(), studyId);\n \n-        // Get the map of individual - sample id and update proband information (to be able to navigate to the parents and their\n-        // samples easily)\n-        Map<String, String> sampleMap = ClinicalUtils.getSampleMap(clinicalAnalysis, proband);\n+    if (MapUtils.isNotEmpty(query)) {\n+      currentQuery.putAll(query);\n+    }\n \n-        Map<String, List<String>> genotypeMap = ModeOfInheritance.compoundHeterozygous(pedigree);\n+    // Get and check clinical analysis and proband\n+    ClinicalAnalysis clinicalAnalysis = getClinicalAnalysis(studyId, clinicalAnalysisId, sessionId);\n+    Individual proband = ClinicalUtils.getProband(clinicalAnalysis);\n \n-        List<String> samples = new ArrayList<>();\n-        List<String> genotypeList = new ArrayList<>();\n+    // Get pedigree\n+    Pedigree pedigree = FamilyManager.getPedigreeFromFamily(clinicalAnalysis.getFamily(), proband.getId());\n \n-        for (Map.Entry<String, List<String>> entry : genotypeMap.entrySet()) {\n-            if (sampleMap.containsKey(entry.getKey())) {\n-                samples.add(sampleMap.get(entry.getKey()));\n-                genotypeList.add(sampleMap.get(entry.getKey()) + \":\" + StringUtils.join(entry.getValue(), VariantQueryUtils.OR));\n-            }\n-        }\n+    // Discard members from the pedigree that do not have any samples. If we don't do this, we will always assume\n+    ClinicalUtils.removeMembersWithoutSamples(pedigree, clinicalAnalysis.getFamily());\n \n-        int probandSampleIdx = samples.indexOf(proband.getSamples().get(0).getId());\n-        int fatherSampleIdx = -1;\n-        int motherSampleIdx = -1;\n-        if (proband.getFather() != null && ListUtils.isNotEmpty(proband.getFather().getSamples())) {\n-            fatherSampleIdx = samples.indexOf(proband.getFather().getSamples().get(0).getId());\n-        }\n-        if (proband.getMother() != null && ListUtils.isNotEmpty(proband.getMother().getSamples())) {\n-            motherSampleIdx = samples.indexOf(proband.getMother().getSamples().get(0).getId());\n-        }\n-\n-        if (genotypeList.isEmpty()) {\n-            logger.error(\"No genotypes found\");\n-            return null;\n-        }\n+    // Get the map of individual - sample id and update proband information (to be able to navigate to the parents and their\n+    // samples easily)\n+    Map<String, String> sampleMap = ClinicalUtils.getSampleMap(clinicalAnalysis, proband);\n \n-        currentQuery.put(VariantQueryParam.GENOTYPE.key(), StringUtils.join(genotypeList, \";\"));\n-        cleanQuery(currentQuery);\n+    Map<String, List<String>> genotypeMap = ModeOfInheritance.compoundHeterozygous(pedigree);\n \n-        logger.debug(\"CH Samples: {}\", StringUtils.join(samples, \",\"));\n-        logger.debug(\"CH Proband idx: {}, mother idx: {}, father idx: {}\", probandSampleIdx, motherSampleIdx, fatherSampleIdx);\n-        logger.debug(\"CH Query: {}\", JacksonUtils.getDefaultObjectMapper().writer().writeValueAsString(currentQuery));\n-        VariantDBIterator iterator = variantStorageManager.iterator(currentQuery, queryOptions, sessionId);\n+    List<String> samples = new ArrayList<>();\n+    List<String> genotypeList = new ArrayList<>();\n \n-        return ModeOfInheritance.compoundHeterozygous(iterator, probandSampleIdx, motherSampleIdx, fatherSampleIdx);\n+    for (Map.Entry<String, List<String>> entry : genotypeMap.entrySet()) {\n+      if (sampleMap.containsKey(entry.getKey())) {\n+        samples.add(sampleMap.get(entry.getKey()));\n+        genotypeList.add(sampleMap.get(entry.getKey()) + \":\" + StringUtils.join(entry.getValue(), VariantQueryUtils.OR));\n+      }\n     }\n \n-    public DefaultClinicalVariantCreator createClinicalVariantCreator(Query query, String assembly, boolean skipUntieredVariants,\n-                                                                      String sessionId) throws ToolException {\n-        // Clinical variant creator\n-        ClinicalProperty.ModeOfInheritance moi = ClinicalProperty.ModeOfInheritance.valueOf(query.getString(FAMILY_SEGREGATION.key(),\n-                ClinicalProperty.ModeOfInheritance.UNKNOWN.name()));\n-        List<String> biotypes = query.getAsStringList(VariantQueryParam.ANNOT_BIOTYPE.key());\n-        List<String> soNames = new ArrayList<>();\n-        List<String>  consequenceTypes = query.getAsStringList(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key());\n-        if (CollectionUtils.isNotEmpty(consequenceTypes)) {\n-            for (String soName : consequenceTypes) {\n-                if (soName.startsWith(\"SO:\")) {\n-                    try {\n-                        int soAcc = Integer.valueOf(soName.replace(\"SO:\", \"\"));\n-                        soNames.add(ConsequenceTypeMappings.accessionToTerm.get(soAcc));\n-                    } catch (NumberFormatException e) {\n-                        e.printStackTrace();\n-                    }\n-                } else {\n-                    soNames.add(soName);\n-                }\n-            }\n-        }\n-        try {\n-            Disorder disorder = new Disorder().setId(query.getString(FAMILY_DISORDER.key()));\n-            List<DiseasePanel> diseasePanels = getDiseasePanels(query, sessionId);\n-            return new DefaultClinicalVariantCreator(getRoleInCancerManager().getRoleInCancer(),\n-                    getActionableVariantManager().getActionableVariants(assembly), disorder, moi, ClinicalProperty.Penetrance.COMPLETE,\n-                    diseasePanels, biotypes, soNames, !skipUntieredVariants);\n-        } catch (IOException e) {\n-            throw new ToolException(\"Error creating clinical variant creator\", e);\n-        }\n+    int probandSampleIdx = samples.indexOf(proband.getSamples().get(0).getId());\n+    int fatherSampleIdx = -1;\n+    int motherSampleIdx = -1;\n+    if (proband.getFather() != null && ListUtils.isNotEmpty(proband.getFather().getSamples())) {\n+      fatherSampleIdx = samples.indexOf(proband.getFather().getSamples().get(0).getId());\n+    }\n+    if (proband.getMother() != null && ListUtils.isNotEmpty(proband.getMother().getSamples())) {\n+      motherSampleIdx = samples.indexOf(proband.getMother().getSamples().get(0).getId());\n     }\n \n-    public ClinicalAnalysis getClinicalAnalysis(String studyId, String clinicalAnalysisId, String sessionId)\n-            throws ToolException, CatalogException {\n-        OpenCGAResult<ClinicalAnalysis> clinicalAnalysisQueryResult = catalogManager.getClinicalAnalysisManager()\n-                .get(studyId, clinicalAnalysisId, QueryOptions.empty(), sessionId);\n+    if (genotypeList.isEmpty()) {\n+      logger.error(\"No genotypes found\");\n+      return null;\n+    }\n \n-        if (clinicalAnalysisQueryResult.getNumResults() == 0) {\n-            throw new ToolException(\"Clinical analysis \" + clinicalAnalysisId + \" not found in study \" + studyId);\n+    currentQuery.put(VariantQueryParam.GENOTYPE.key(), StringUtils.join(genotypeList, \";\"));\n+    cleanQuery(currentQuery);\n+\n+    logger.debug(\"CH Samples: {}\", StringUtils.join(samples, \",\"));\n+    logger.debug(\"CH Proband idx: {}, mother idx: {}, father idx: {}\", probandSampleIdx, motherSampleIdx, fatherSampleIdx);\n+    logger.debug(\"CH Query: {}\", JacksonUtils.getDefaultObjectMapper().writer().writeValueAsString(currentQuery));\n+    VariantDBIterator iterator = variantStorageManager.iterator(currentQuery, queryOptions, sessionId);\n+\n+    return ModeOfInheritance.compoundHeterozygous(iterator, probandSampleIdx, motherSampleIdx, fatherSampleIdx);\n+  }\n+\n+  public DefaultClinicalVariantCreator createClinicalVariantCreator(Query query, String assembly, boolean skipUntieredVariants,\n+                                                                    String sessionId) throws ToolException {\n+    // Clinical variant creator\n+    ClinicalProperty.ModeOfInheritance moi = ClinicalProperty.ModeOfInheritance.valueOf(query.getString(FAMILY_SEGREGATION.key(),\n+        ClinicalProperty.ModeOfInheritance.UNKNOWN.name()));\n+    List<String> biotypes = query.getAsStringList(VariantQueryParam.ANNOT_BIOTYPE.key());\n+    List<String> soNames = new ArrayList<>();\n+    List<String> consequenceTypes = query.getAsStringList(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key());\n+    if (CollectionUtils.isNotEmpty(consequenceTypes)) {\n+      for (String soName : consequenceTypes) {\n+        if (soName.startsWith(\"SO:\")) {\n+          try {\n+            int soAcc = Integer.valueOf(soName.replace(\"SO:\", \"\"));\n+            soNames.add(ConsequenceTypeMappings.accessionToTerm.get(soAcc));\n+          } catch (NumberFormatException e) {\n+            e.printStackTrace();\n+          }\n+        } else {\n+          soNames.add(soName);\n         }\n+      }\n+    }\n+    try {\n+      Disorder disorder = new Disorder().setId(query.getString(FAMILY_DISORDER.key()));\n+      List<DiseasePanel> diseasePanels = getDiseasePanels(query, sessionId);\n+      return new DefaultClinicalVariantCreator(getRoleInCancerManager().getRoleInCancer(),\n+          getActionableVariantManager().getActionableVariants(assembly), disorder, moi, ClinicalProperty.Penetrance.COMPLETE,\n+          diseasePanels, biotypes, soNames, !skipUntieredVariants);\n+    } catch (IOException e) {\n+      throw new ToolException(\"Error creating clinical variant creator\", e);\n+    }\n+  }\n \n-        ClinicalAnalysis clinicalAnalysis = clinicalAnalysisQueryResult.first();\n-\n-        if (clinicalAnalysis.getProband() == null || StringUtils.isEmpty(clinicalAnalysis.getProband().getId())) {\n-            throw new ToolException(\"Missing proband in clinical analysis \" + clinicalAnalysisId);\n-        }\n+  public ClinicalAnalysis getClinicalAnalysis(String studyId, String clinicalAnalysisId, String sessionId)\n+      throws ToolException, CatalogException {\n+    OpenCGAResult<ClinicalAnalysis> clinicalAnalysisQueryResult = catalogManager.getClinicalAnalysisManager()\n+        .get(studyId, clinicalAnalysisId, QueryOptions.empty(), sessionId);\n \n-        return clinicalAnalysis;\n+    if (clinicalAnalysisQueryResult.getNumResults() == 0) {\n+      throw new ToolException(\"Clinical analysis \" + clinicalAnalysisId + \" not found in study \" + studyId);\n     }\n \n-    public List<DiseasePanel> getDiseasePanels(Query query, String sessionId) throws ToolException {\n-        if (!query.containsKey(STUDY.key())) {\n-            throw new ToolException(\"Missing study in query\");\n-        }\n-        List<DiseasePanel> diseasePanels = new ArrayList<>();\n-        if (!query.containsKey(PANEL.key())) {\n-            return diseasePanels;\n-        }\n-        return getDiseasePanels(query.getString(STUDY.key()), query.getAsStringList(query.getString(PANEL.key())), sessionId);\n+    ClinicalAnalysis clinicalAnalysis = clinicalAnalysisQueryResult.first();\n+\n+    if (clinicalAnalysis.getProband() == null || StringUtils.isEmpty(clinicalAnalysis.getProband().getId())) {\n+      throw new ToolException(\"Missing proband in clinical analysis \" + clinicalAnalysisId);\n     }\n \n-    public List<DiseasePanel> getDiseasePanels(String studyId, List<String> diseasePanelIds, String sessionId)\n-            throws ToolException {\n-        List<DiseasePanel> diseasePanels = new ArrayList<>();\n-        if (CollectionUtils.isNotEmpty(diseasePanelIds)) {\n-            OpenCGAResult<org.opencb.opencga.core.models.panel.Panel> queryResults;\n-            try {\n-                queryResults = catalogManager.getPanelManager().get(studyId, diseasePanelIds, QueryOptions.empty(),\n-                        sessionId);\n-            } catch (CatalogException e) {\n-                throw new ToolException(\"Error accessing panel manager\", e);\n-            }\n+    return clinicalAnalysis;\n+  }\n \n-            if (queryResults.getNumResults() != diseasePanelIds.size()) {\n-                throw new ToolException(\"The number of disease panels retrieved doesn't match the number of disease panels queried\");\n-            }\n-\n-            for (org.opencb.opencga.core.models.panel.Panel panel : queryResults.getResults()) {\n-                diseasePanels.add(panel);\n-            }\n-        }\n-        return diseasePanels;\n+  public List<DiseasePanel> getDiseasePanels(Query query, String sessionId) throws ToolException {\n+    if (!query.containsKey(STUDY.key())) {\n+      throw new ToolException(\"Missing study in query\");\n+    }\n+    List<DiseasePanel> diseasePanels = new ArrayList<>();\n+    if (!query.containsKey(PANEL.key())) {\n+      return diseasePanels;\n+    }\n+    return getDiseasePanels(query.getString(STUDY.key()), query.getAsStringList(query.getString(PANEL.key())), sessionId);\n+  }\n+\n+  public List<DiseasePanel> getDiseasePanels(String studyId, List<String> diseasePanelIds, String sessionId)\n+      throws ToolException {\n+    List<DiseasePanel> diseasePanels = new ArrayList<>();\n+    if (CollectionUtils.isNotEmpty(diseasePanelIds)) {\n+      OpenCGAResult<org.opencb.opencga.core.models.panel.Panel> queryResults;\n+      try {\n+        queryResults = catalogManager.getPanelManager().get(studyId, diseasePanelIds, QueryOptions.empty(),\n+            sessionId);\n+      } catch (CatalogException e) {\n+        throw new ToolException(\"Error accessing panel manager\", e);\n+      }\n+\n+      if (queryResults.getNumResults() != diseasePanelIds.size()) {\n+        throw new ToolException(\"The number of disease panels retrieved doesn't match the number of disease panels queried\");\n+      }\n+\n+      for (org.opencb.opencga.core.models.panel.Panel panel : queryResults.getResults()) {\n+        diseasePanels.add(panel);\n+      }\n     }\n+    return diseasePanels;\n+  }\n \n-    public List<ClinicalVariant> getPrimaryFindings(Query query, QueryOptions queryOptions, ClinicalVariantCreator clinicalVariantCreator,\n-                                                    String sessionId) throws ToolException {\n-        try {\n-            VariantQueryResult<Variant> variantQueryResult = getVariantStorageManager().get(query, queryOptions, sessionId);\n-            List<Variant> variants = variantQueryResult.getResults();\n+  public List<ClinicalVariant> getPrimaryFindings(Query query, QueryOptions queryOptions, ClinicalVariantCreator clinicalVariantCreator,\n+                                                  String sessionId) throws ToolException {\n+    try {\n+      VariantQueryResult<Variant> variantQueryResult = getVariantStorageManager().get(query, queryOptions, sessionId);\n+      List<Variant> variants = variantQueryResult.getResults();\n \n-            System.out.println(\"Number of variants = \" + variants.size());\n-            for (Variant variant : variants) {\n-                System.out.println(variant.getId());\n-            }\n+      System.out.println(\"Number of variants = \" + variants.size());\n+      for (Variant variant : variants) {\n+        System.out.println(variant.getId());\n+      }\n \n \n-            return clinicalVariantCreator.create(variants);\n-        } catch (InterpretationAnalysisException | CatalogException | StorageEngineException | IOException e) {\n-            throw new ToolException(e);\n-        }\n+      return clinicalVariantCreator.create(variants);\n+    } catch (InterpretationAnalysisException | CatalogException | StorageEngineException | IOException e) {\n+      throw new ToolException(e);\n     }\n+  }\n \n-    public List<ClinicalVariant> getPrimaryFindings(String clinicalAnalysisId, Query query, QueryOptions queryOptions,\n-                                                    ClinicalVariantCreator clinicalVariantCreator, String sessionId)\n-            throws ToolException {\n-        List<Variant> variants;\n-        List<ClinicalVariant> clinicalVariants;\n+  public List<ClinicalVariant> getPrimaryFindings(String clinicalAnalysisId, Query query, QueryOptions queryOptions,\n+                                                  ClinicalVariantCreator clinicalVariantCreator, String sessionId)\n+      throws ToolException {\n+    List<Variant> variants;\n+    List<ClinicalVariant> clinicalVariants;\n \n-        String studyId = query.getString(VariantQueryParam.STUDY.key());\n-\n-        ClinicalProperty.ModeOfInheritance moi = ClinicalProperty.ModeOfInheritance.UNKNOWN;\n-        if (query.containsKey(FAMILY_SEGREGATION.key())) {\n-            moi = ClinicalProperty.ModeOfInheritance.valueOf(query.getString(FAMILY_SEGREGATION.key()));\n-        }\n-        try {\n-            switch (moi) {\n-                case DE_NOVO:\n-                    variants = getDeNovoVariants(clinicalAnalysisId, studyId, query, queryOptions, sessionId);\n-                    clinicalVariants = clinicalVariantCreator.create(variants);\n-                    break;\n-                case COMPOUND_HETEROZYGOUS:\n-                    Map<String, List<Variant>> chVariants;\n-                    chVariants = getCompoundHeterozigousVariants(clinicalAnalysisId, studyId, query,\n-                            queryOptions, sessionId);\n-                    clinicalVariants = ClinicalUtils.getCompoundHeterozygousClinicalVariants(chVariants, clinicalVariantCreator);\n-                    break;\n-                default:\n-                    VariantQueryResult<Variant> variantQueryResult = getVariantStorageManager().get(query, queryOptions, sessionId);\n-                    variants = variantQueryResult.getResults();\n-                    clinicalVariants = clinicalVariantCreator.create(variants);\n-                    break;\n-            }\n-        } catch (Exception e) {\n-            throw new ToolException(\"Error retrieving primary findings variants\", e);\n-        }\n+    String studyId = query.getString(VariantQueryParam.STUDY.key());\n \n-        return clinicalVariants;\n+    ClinicalProperty.ModeOfInheritance moi = ClinicalProperty.ModeOfInheritance.UNKNOWN;\n+    if (query.containsKey(FAMILY_SEGREGATION.key())) {\n+      moi = ClinicalProperty.ModeOfInheritance.valueOf(query.getString(FAMILY_SEGREGATION.key()));\n+    }\n+    try {\n+      switch (moi) {\n+        case DE_NOVO:\n+          variants = getDeNovoVariants(clinicalAnalysisId, studyId, query, queryOptions, sessionId);\n+          clinicalVariants = clinicalVariantCreator.create(variants);\n+          break;\n+        case COMPOUND_HETEROZYGOUS:\n+          Map<String, List<Variant>> chVariants;\n+          chVariants = getCompoundHeterozigousVariants(clinicalAnalysisId, studyId, query,\n+              queryOptions, sessionId);\n+          clinicalVariants = ClinicalUtils.getCompoundHeterozygousClinicalVariants(chVariants, clinicalVariantCreator);\n+          break;\n+        default:\n+          VariantQueryResult<Variant> variantQueryResult = getVariantStorageManager().get(query, queryOptions, sessionId);\n+          variants = variantQueryResult.getResults();\n+          clinicalVariants = clinicalVariantCreator.create(variants);\n+          break;\n+      }\n+    } catch (Exception e) {\n+      throw new ToolException(\"Error retrieving primary findings variants\", e);\n     }\n \n-    public List<ClinicalVariant> getSecondaryFindings(String studyId, String sampleId, ClinicalVariantCreator clinicalVariantCreator,\n-                                                      String sessionId) throws ToolException {\n-        try {\n-            List<Variant> variants = new ArrayList<>();\n-\n-            // Prepare query object\n-            Query query = new Query();\n-            query.put(STUDY.key(), studyId);\n-            query.put(VariantQueryParam.SAMPLE.key(), sampleId);\n-\n-            // Get the correct actionable variants for the assembly\n-            String assembly = getAssembly(studyId, sessionId);\n-            Map<String, List<String>> actionableVariants = actionableVariantManager.getActionableVariants(assembly);\n-            if (actionableVariants != null) {\n-                Iterator<String> iterator = actionableVariants.keySet().iterator();\n-                List<String> variantIds = new ArrayList<>();\n-                while (iterator.hasNext()) {\n-                    String id = iterator.next();\n-                    variantIds.add(id);\n-                    if (variantIds.size() >= 1000) {\n-                        query.put(VariantQueryParam.ID.key(), variantIds);\n-                        VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), sessionId);\n-                        variants.addAll(result.getResults());\n-                        variantIds.clear();\n-                    }\n-                }\n-\n-                if (variantIds.size() > 0) {\n-                    query.put(VariantQueryParam.ID.key(), variantIds);\n-                    VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), sessionId);\n-                    variants.addAll(result.getResults());\n-                }\n-            }\n+    return clinicalVariants;\n+  }\n \n-            return clinicalVariantCreator.create(variants);\n-        } catch (InterpretationAnalysisException | IOException | CatalogException | StorageEngineException e) {\n-            throw new ToolException(e);\n+  public List<ClinicalVariant> getSecondaryFindings(String studyId, String sampleId, ClinicalVariantCreator clinicalVariantCreator,\n+                                                    String sessionId) throws ToolException {\n+    try {\n+      List<Variant> variants = new ArrayList<>();\n+\n+      // Prepare query object\n+      Query query = new Query();\n+      query.put(STUDY.key(), studyId);\n+      query.put(VariantQueryParam.SAMPLE.key(), sampleId);\n+\n+      // Get the correct actionable variants for the assembly\n+      String assembly = getAssembly(studyId, sessionId);\n+      Map<String, List<String>> actionableVariants = actionableVariantManager.getActionableVariants(assembly);\n+      if (actionableVariants != null) {\n+        Iterator<String> iterator = actionableVariants.keySet().iterator();\n+        List<String> variantIds = new ArrayList<>();\n+        while (iterator.hasNext()) {\n+          String id = iterator.next();\n+          variantIds.add(id);\n+          if (variantIds.size() >= 1000) {\n+            query.put(VariantQueryParam.ID.key(), variantIds);\n+            VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), sessionId);\n+            variants.addAll(result.getResults());\n+            variantIds.clear();\n+          }\n         }\n-    }\n \n-    public List<Variant> getSecondaryFindings(String inputSampleId, String clinicalAnalysisId, String studyId, String sessionId)\n-            throws CatalogException, ToolException, IOException, StorageEngineException {\n-        String sampleId = inputSampleId;\n-        // sampleId has preference over clinicalAnalysisId\n-        if (StringUtils.isEmpty(sampleId)) {\n-            // Throws an Exception if it cannot fetch analysis ID or proband is null\n-            ClinicalAnalysis clinicalAnalysis = getClinicalAnalysis(studyId, clinicalAnalysisId, sessionId);\n-            if (CollectionUtils.isNotEmpty(clinicalAnalysis.getProband().getSamples())) {\n-                for (Sample sample : clinicalAnalysis.getProband().getSamples()) {\n-                    if (!sample.isSomatic()) {\n-                        sampleId = clinicalAnalysis.getProband().getSamples().get(0).getId();\n-                        break;\n-                    }\n-                }\n-            } else {\n-                throw new ToolException(\"Missing germline sample\");\n-            }\n+        if (variantIds.size() > 0) {\n+          query.put(VariantQueryParam.ID.key(), variantIds);\n+          VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), sessionId);\n+          variants.addAll(result.getResults());\n         }\n+      }\n \n-        List<Variant> variants = new ArrayList<>();\n-\n-        // Prepare query object\n-        Query query = new Query();\n-        query.put(STUDY.key(), studyId);\n-        query.put(VariantQueryParam.SAMPLE.key(), sampleId);\n-\n-        // Get the correct actionable variants for the assembly\n-        String assembly = getAssembly(studyId, sessionId);\n-        Map<String, List<String>> actionableVariants = actionableVariantManager.getActionableVariants(assembly);\n-        if (actionableVariants != null) {\n-            Iterator<String> iterator = actionableVariants.keySet().iterator();\n-            List<String> variantIds = new ArrayList<>();\n-            while (iterator.hasNext()) {\n-                String id = iterator.next();\n-                variantIds.add(id);\n-                if (variantIds.size() >= 1000) {\n-                    query.put(VariantQueryParam.ID.key(), variantIds);\n-                    VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), sessionId);\n-                    variants.addAll(result.getResults());\n-                    variantIds.clear();\n-                }\n-            }\n+      return clinicalVariantCreator.create(variants);\n+    } catch (InterpretationAnalysisException | IOException | CatalogException | StorageEngineException e) {\n+      throw new ToolException(e);\n+    }\n+  }\n+\n+  public List<Variant> getSecondaryFindings(String inputSampleId, String clinicalAnalysisId, String studyId, String sessionId)\n+      throws CatalogException, ToolException, IOException, StorageEngineException {\n+    String sampleId = inputSampleId;\n+    // sampleId has preference over clinicalAnalysisId\n+    if (StringUtils.isEmpty(sampleId)) {\n+      // Throws an Exception if it cannot fetch analysis ID or proband is null\n+      ClinicalAnalysis clinicalAnalysis = getClinicalAnalysis(studyId, clinicalAnalysisId, sessionId);\n+      if (CollectionUtils.isNotEmpty(clinicalAnalysis.getProband().getSamples())) {\n+        for (Sample sample : clinicalAnalysis.getProband().getSamples()) {\n+          if (!sample.isSomatic()) {\n+            sampleId = clinicalAnalysis.getProband().getSamples().get(0).getId();\n+            break;\n+          }\n+        }\n+      } else {\n+        throw new ToolException(\"Missing germline sample\");\n+      }\n+    }\n \n-            if (variantIds.size() > 0) {\n-                query.put(VariantQueryParam.ID.key(), variantIds);\n-                VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), sessionId);\n-                variants.addAll(result.getResults());\n-            }\n+    List<Variant> variants = new ArrayList<>();\n+\n+    // Prepare query object\n+    Query query = new Query();\n+    query.put(STUDY.key(), studyId);\n+    query.put(VariantQueryParam.SAMPLE.key(), sampleId);\n+\n+    // Get the correct actionable variants for the assembly\n+    String assembly = getAssembly(studyId, sessionId);\n+    Map<String, List<String>> actionableVariants = actionableVariantManager.getActionableVariants(assembly);\n+    if (actionableVariants != null) {\n+      Iterator<String> iterator = actionableVariants.keySet().iterator();\n+      List<String> variantIds = new ArrayList<>();\n+      while (iterator.hasNext()) {\n+        String id = iterator.next();\n+        variantIds.add(id);\n+        if (variantIds.size() >= 1000) {\n+          query.put(VariantQueryParam.ID.key(), variantIds);\n+          VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), sessionId);\n+          variants.addAll(result.getResults());\n+          variantIds.clear();\n         }\n+      }\n \n-        return variants;\n+      if (variantIds.size() > 0) {\n+        query.put(VariantQueryParam.ID.key(), variantIds);\n+        VariantQueryResult<Variant> result = variantStorageManager.get(query, QueryOptions.empty(), sessionId);\n+        variants.addAll(result.getResults());\n+      }\n     }\n \n-    public List<ClinicalVariant> getSecondaryFindings(ClinicalAnalysis clinicalAnalysis,  List<String> sampleNames,\n-                                                      String studyId, ClinicalVariantCreator creator, String sessionId)\n-            throws StorageEngineException, ToolException, CatalogException, IOException {\n-        throw new NotImplementedException(\"Secondary findings does not exist\");\n+    return variants;\n+  }\n+\n+  public List<ClinicalVariant> getSecondaryFindings(ClinicalAnalysis clinicalAnalysis, List<String> sampleNames,\n+                                                    String studyId, ClinicalVariantCreator creator, String sessionId)\n+      throws StorageEngineException, ToolException, CatalogException, IOException {\n+    throw new NotImplementedException(\"Secondary findings does not exist\");\n //        List<ClinicalVariant> secondaryFindings = null;\n //        if (clinicalAnalysis.getConsent() != null\n //                && clinicalAnalysis.getConsent().getSecondaryFindings() == ClinicalConsent.ConsentStatus.YES) {\n@@ -930,7 +932,7 @@ public class ClinicalInterpretationManager extends StorageManager {\n //            }\n //        }\n //        return secondaryFindings;\n-    }\n+  }\n \n //    public List<ReportedLowCoverage> getReportedLowCoverage(int maxCoverage, ClinicalAnalysis clinicalAnalysis,\n //                                                            List<DiseasePanel> diseasePanels, String studyId, String sessionId)\n@@ -1014,31 +1016,31 @@ public class ClinicalInterpretationManager extends StorageManager {\n //        return reportedLowCoverages;\n //    }\n \n-    public ClinicalAnalyst getAnalyst(String token) throws ToolException {\n-        try {\n-            String userId = catalogManager.getUserManager().getUserId(token);\n-            OpenCGAResult<User> userQueryResult = catalogManager.getUserManager().get(userId, new QueryOptions(QueryOptions.INCLUDE,\n-                    Arrays.asList(UserDBAdaptor.QueryParams.EMAIL.key(), UserDBAdaptor.QueryParams.ORGANIZATION.key())), token);\n-            User user = userQueryResult.first();\n-            return new ClinicalAnalyst(userId, user.getName(), user.getEmail(), \"\", \"\");\n-        } catch (CatalogException e) {\n-            throw new ToolException(e);\n-        }\n+  public ClinicalAnalyst getAnalyst(String token) throws ToolException {\n+    try {\n+      String userId = catalogManager.getUserManager().getUserId(token);\n+      OpenCGAResult<User> userQueryResult = catalogManager.getUserManager().get(userId, new QueryOptions(QueryOptions.INCLUDE,\n+          Arrays.asList(UserDBAdaptor.QueryParams.EMAIL.key(), UserDBAdaptor.QueryParams.ORGANIZATION.key())), token);\n+      User user = userQueryResult.first();\n+      return new ClinicalAnalyst(userId, user.getName(), user.getEmail(), \"\", \"\");\n+    } catch (CatalogException e) {\n+      throw new ToolException(e);\n     }\n-\n-    public String getAssembly(String studyId, String sessionId) throws CatalogException {\n-        String assembly = \"\";\n-        OpenCGAResult<Project> projectQueryResult;\n-        projectQueryResult = catalogManager.getProjectManager().get(new Query(ProjectDBAdaptor.QueryParams.STUDY.key(), studyId),\n-                new QueryOptions(QueryOptions.INCLUDE, ProjectDBAdaptor.QueryParams.ORGANISM.key()), sessionId);\n-        if (CollectionUtils.isNotEmpty(projectQueryResult.getResults())) {\n-            assembly = projectQueryResult.first().getOrganism().getAssembly();\n-        }\n-        if (StringUtils.isNotEmpty(assembly)) {\n-            assembly = assembly.toLowerCase();\n-        }\n-        return assembly;\n+  }\n+\n+  public String getAssembly(String studyId, String sessionId) throws CatalogException {\n+    String assembly = \"\";\n+    OpenCGAResult<Project> projectQueryResult;\n+    projectQueryResult = catalogManager.getProjectManager().get(new Query(ProjectDBAdaptor.QueryParams.STUDY.key(), studyId),\n+        new QueryOptions(QueryOptions.INCLUDE, ProjectDBAdaptor.QueryParams.ORGANISM.key()), sessionId);\n+    if (CollectionUtils.isNotEmpty(projectQueryResult.getResults())) {\n+      assembly = projectQueryResult.first().getOrganism().getAssembly();\n+    }\n+    if (StringUtils.isNotEmpty(assembly)) {\n+      assembly = assembly.toLowerCase();\n     }\n+    return assembly;\n+  }\n \n //    public org.opencb.biodata.models.clinical.interpretation.Interpretation generateInterpretation(\n //            String analysisName, String clinicalAnalysisId, Query query, List<ClinicalVariant> primaryFindings,\n@@ -1101,162 +1103,162 @@ public class ClinicalInterpretationManager extends StorageManager {\n //        }\n //    }\n \n-    public RoleInCancerManager getRoleInCancerManager() {\n-        return roleInCancerManager;\n-    }\n-\n-    public ActionableVariantManager getActionableVariantManager() {\n-        return actionableVariantManager;\n-    }\n+  public RoleInCancerManager getRoleInCancerManager() {\n+    return roleInCancerManager;\n+  }\n \n-    public VariantStorageManager getVariantStorageManager() {\n-        return variantStorageManager;\n-    }\n+  public ActionableVariantManager getActionableVariantManager() {\n+    return actionableVariantManager;\n+  }\n \n-    /*--------------------------------------------------------------------------*/\n-    /*                    P R I V A T E     M E T H O D S                       */\n-    /*--------------------------------------------------------------------------*/\n+  public VariantStorageManager getVariantStorageManager() {\n+    return variantStorageManager;\n+  }\n \n-    // FIXME Class path to a new section in storage-configuration.yml file\n-    private void init() {\n-        try {\n-            this.database = catalogManager.getConfiguration().getDatabasePrefix() + \"_clinical\";\n+  /*--------------------------------------------------------------------------*/\n+  /*                    P R I V A T E     M E T H O D S                       */\n+  /*--------------------------------------------------------------------------*/\n \n-            this.clinicalVariantEngine = getClinicalStorageEngine();\n-        } catch (IllegalAccessException | InstantiationException | ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n+  // FIXME Class path to a new section in storage-configuration.yml file\n+  private void init() {\n+    try {\n+      this.database = catalogManager.getConfiguration().getDatabasePrefix() + \"_clinical\";\n \n+      this.clinicalVariantEngine = getClinicalStorageEngine();\n+    } catch (IllegalAccessException | InstantiationException | ClassNotFoundException e) {\n+      e.printStackTrace();\n     }\n \n-    private ClinicalVariantEngine getClinicalStorageEngine() throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n-        String clazz = this.storageConfiguration.getClinical().getManager();\n-        ClinicalVariantEngine storageEngine = (ClinicalVariantEngine) Class.forName(clazz).newInstance();\n-        storageEngine.setStorageConfiguration(this.storageConfiguration);\n-        return storageEngine;\n-    }\n+  }\n \n-    private Query checkQueryPermissions(Query query, String token) throws ClinicalVariantException, CatalogException {\n-        if (query == null) {\n-            throw new ClinicalVariantException(\"Query object is null\");\n-        }\n-\n-        // Get userId from token and Study numeric IDs from the query\n-        String userId = catalogManager.getUserManager().getUserId(token);\n-        List<String> studyIds = getStudyIds(userId, query);\n-\n-        // If one specific clinical analysis, sample or individual is provided we expect a single valid study as well\n-        if (isCaseProvided(query)) {\n-            if (studyIds.size() == 1) {\n-                // This checks that the user has permission to the clinical analysis, family, sample or individual\n-                DataResult<ClinicalAnalysis> clinicalAnalysisQueryResult = catalogManager.getClinicalAnalysisManager()\n-                        .search(studyIds.get(0), query, QueryOptions.empty(), token);\n-\n-                if (clinicalAnalysisQueryResult.getResults().isEmpty()) {\n-                    throw new ClinicalVariantException(\"Either the ID does not exist or the user does not have permissions to view it\");\n-                } else {\n-                    if (!query.containsKey(ClinicalVariantEngine.QueryParams.CLINICAL_ANALYSIS_ID.key())) {\n-                        query.remove(ClinicalVariantEngine.QueryParams.FAMILY.key());\n-                        query.remove(ClinicalVariantEngine.QueryParams.SAMPLE.key());\n-                        query.remove(ClinicalVariantEngine.QueryParams.SUBJECT.key());\n-                        String clinicalAnalysisList = StringUtils.join(\n-                                clinicalAnalysisQueryResult.getResults().stream().map(ClinicalAnalysis::getId).collect(Collectors.toList()),\n-                                \",\");\n-                        query.put(\"clinicalAnalysisId\", clinicalAnalysisList);\n-                    }\n-                }\n-            } else {\n-                throw new ClinicalVariantException(\"No single valid study provided: \"\n-                        + query.getString(ClinicalVariantEngine.QueryParams.STUDY.key()));\n-            }\n-        } else {\n-            // Get the owner of all the studies\n-            Set<String> users = new HashSet<>();\n-            for (String studyFqn : studyIds) {\n-                users.add(StringUtils.split(studyFqn, \"@\")[0]);\n-            }\n+  private ClinicalVariantEngine getClinicalStorageEngine() throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n+    String clazz = this.storageConfiguration.getClinical().getManager();\n+    ClinicalVariantEngine storageEngine = (ClinicalVariantEngine) Class.forName(clazz).newInstance();\n+    storageEngine.setStorageConfiguration(this.storageConfiguration);\n+    return storageEngine;\n+  }\n \n-            // There must be one single owner for all the studies, we do nt allow to query multiple databases\n-            if (users.size() == 1) {\n-                Query studyQuery = new Query(StudyDBAdaptor.QueryParams.ID.key(), StringUtils.join(studyIds, \",\"));\n-                DataResult<Study> studyQueryResult = catalogManager.getStudyManager().search(studyQuery, QueryOptions.empty(), token);\n-\n-                // If the user is the owner we do not have to check anything else\n-                List<String> studyAliases = new ArrayList<>(studyIds.size());\n-                if (users.contains(userId)) {\n-                    for (Study study : studyQueryResult.getResults()) {\n-                        studyAliases.add(study.getAlias());\n-                    }\n-                } else {\n-                    for (Study study : studyQueryResult.getResults()) {\n-                        for (Group group : study.getGroups()) {\n-                            if (group.getId().equalsIgnoreCase(\"@admins\") && group.getUserIds().contains(userId)) {\n-                                studyAliases.add(study.getAlias());\n-                                break;\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if (studyAliases.isEmpty()) {\n-                    throw new ClinicalVariantException(\"This user is not owner or admins for the provided studies\");\n-                } else {\n-                    query.put(ClinicalVariantEngine.QueryParams.STUDY.key(), StringUtils.join(studyAliases, \",\"));\n-                }\n-            } else {\n-                throw new ClinicalVariantException(\"\");\n-            }\n-        }\n-        return query;\n+  private Query checkQueryPermissions(Query query, String token) throws ClinicalVariantException, CatalogException {\n+    if (query == null) {\n+      throw new ClinicalVariantException(\"Query object is null\");\n     }\n \n-    private void checkInterpretationPermissions(String study, long interpretationId, String token)\n-            throws CatalogException, ClinicalVariantException {\n-        // Get user ID from token and study numeric ID\n-        String studyId = catalogManager.getStudyManager().get(study, StudyManager.INCLUDE_STUDY_ID, token).first().getFqn();\n+    // Get userId from token and Study numeric IDs from the query\n+    String userId = catalogManager.getUserManager().getUserId(token);\n+    List<String> studyIds = getStudyIds(userId, query);\n \n-        // This checks that the user has permission to this interpretation\n-        Query query = new Query(ClinicalAnalysisDBAdaptor.QueryParams.INTERPRETATION_ID.key(), interpretationId);\n+    // If one specific clinical analysis, sample or individual is provided we expect a single valid study as well\n+    if (isCaseProvided(query)) {\n+      if (studyIds.size() == 1) {\n+        // This checks that the user has permission to the clinical analysis, family, sample or individual\n         DataResult<ClinicalAnalysis> clinicalAnalysisQueryResult = catalogManager.getClinicalAnalysisManager()\n-                .search(studyId, query, QueryOptions.empty(), token);\n+            .search(studyIds.get(0), query, QueryOptions.empty(), token);\n \n         if (clinicalAnalysisQueryResult.getResults().isEmpty()) {\n-            throw new ClinicalVariantException(\"Either the interpretation ID (\" + interpretationId + \") does not exist or the user does\"\n-                    + \" not have access permissions\");\n+          throw new ClinicalVariantException(\"Either the ID does not exist or the user does not have permissions to view it\");\n+        } else {\n+          if (!query.containsKey(ClinicalVariantEngine.QueryParams.CLINICAL_ANALYSIS_ID.key())) {\n+            query.remove(ClinicalVariantEngine.QueryParams.FAMILY.key());\n+            query.remove(ClinicalVariantEngine.QueryParams.SAMPLE.key());\n+            query.remove(ClinicalVariantEngine.QueryParams.SUBJECT.key());\n+            String clinicalAnalysisList = StringUtils.join(\n+                clinicalAnalysisQueryResult.getResults().stream().map(ClinicalAnalysis::getId).collect(Collectors.toList()),\n+                \",\");\n+            query.put(\"clinicalAnalysisId\", clinicalAnalysisList);\n+          }\n         }\n-    }\n-\n-    private List<String> getStudyIds(String userId, Query query) throws CatalogException {\n-        List<String> studyIds = new ArrayList<>();\n-\n-        if (query != null && query.containsKey(ClinicalVariantEngine.QueryParams.STUDY.key())) {\n-            String study = query.getString(ClinicalVariantEngine.QueryParams.STUDY.key());\n-            List<String> studies = Arrays.asList(study.split(\",\"));\n-            studyIds = catalogManager.getStudyManager().get(studies, StudyManager.INCLUDE_STUDY_ID, false, userId)\n-                    .getResults()\n-                    .stream()\n-                    .map(Study::getFqn)\n-                    .collect(Collectors.toList());\n+      } else {\n+        throw new ClinicalVariantException(\"No single valid study provided: \"\n+            + query.getString(ClinicalVariantEngine.QueryParams.STUDY.key()));\n+      }\n+    } else {\n+      // Get the owner of all the studies\n+      Set<String> users = new HashSet<>();\n+      for (String studyFqn : studyIds) {\n+        users.add(StringUtils.split(studyFqn, \"@\")[0]);\n+      }\n+\n+      // There must be one single owner for all the studies, we do nt allow to query multiple databases\n+      if (users.size() == 1) {\n+        Query studyQuery = new Query(StudyDBAdaptor.QueryParams.ID.key(), StringUtils.join(studyIds, \",\"));\n+        DataResult<Study> studyQueryResult = catalogManager.getStudyManager().search(studyQuery, QueryOptions.empty(), token);\n+\n+        // If the user is the owner we do not have to check anything else\n+        List<String> studyAliases = new ArrayList<>(studyIds.size());\n+        if (users.contains(userId)) {\n+          for (Study study : studyQueryResult.getResults()) {\n+            studyAliases.add(study.getAlias());\n+          }\n+        } else {\n+          for (Study study : studyQueryResult.getResults()) {\n+            for (Group group : study.getGroups()) {\n+              if (group.getId().equalsIgnoreCase(\"@admins\") && group.getUserIds().contains(userId)) {\n+                studyAliases.add(study.getAlias());\n+                break;\n+              }\n+            }\n+          }\n         }\n-        return studyIds;\n-    }\n \n-    private boolean isCaseProvided(Query query) {\n-        if (query != null) {\n-            return query.containsKey(ClinicalVariantEngine.QueryParams.CLINICAL_ANALYSIS_ID.key())\n-                    || query.containsKey(ClinicalVariantEngine.QueryParams.FAMILY.key())\n-                    || query.containsKey(ClinicalVariantEngine.QueryParams.SUBJECT.key())\n-                    || query.containsKey(ClinicalVariantEngine.QueryParams.SAMPLE.key());\n+        if (studyAliases.isEmpty()) {\n+          throw new ClinicalVariantException(\"This user is not owner or admins for the provided studies\");\n+        } else {\n+          query.put(ClinicalVariantEngine.QueryParams.STUDY.key(), StringUtils.join(studyAliases, \",\"));\n         }\n-        return false;\n+      } else {\n+        throw new ClinicalVariantException(\"\");\n+      }\n     }\n-\n-    private void cleanQuery(Query query) {\n-        if (query.containsKey(VariantQueryParam.GENOTYPE.key())) {\n-            query.remove(VariantQueryParam.SAMPLE.key());\n-            query.remove(FAMILY.key());\n-            query.remove(FAMILY_PHENOTYPE.key());\n-            query.remove(MODE_OF_INHERITANCE.key());\n-        }\n+    return query;\n+  }\n+\n+  private void checkInterpretationPermissions(String study, long interpretationId, String token)\n+      throws CatalogException, ClinicalVariantException {\n+    // Get user ID from token and study numeric ID\n+    String studyId = catalogManager.getStudyManager().get(study, StudyManager.INCLUDE_STUDY_ID, token).first().getFqn();\n+\n+    // This checks that the user has permission to this interpretation\n+    Query query = new Query(ClinicalAnalysisDBAdaptor.QueryParams.INTERPRETATION_ID.key(), interpretationId);\n+    DataResult<ClinicalAnalysis> clinicalAnalysisQueryResult = catalogManager.getClinicalAnalysisManager()\n+        .search(studyId, query, QueryOptions.empty(), token);\n+\n+    if (clinicalAnalysisQueryResult.getResults().isEmpty()) {\n+      throw new ClinicalVariantException(\"Either the interpretation ID (\" + interpretationId + \") does not exist or the user does\"\n+          + \" not have access permissions\");\n+    }\n+  }\n+\n+  private List<String> getStudyIds(String userId, Query query) throws CatalogException {\n+    List<String> studyIds = new ArrayList<>();\n+\n+    if (query != null && query.containsKey(ClinicalVariantEngine.QueryParams.STUDY.key())) {\n+      String study = query.getString(ClinicalVariantEngine.QueryParams.STUDY.key());\n+      List<String> studies = Arrays.asList(study.split(\",\"));\n+      studyIds = catalogManager.getStudyManager().get(studies, StudyManager.INCLUDE_STUDY_ID, false, userId)\n+          .getResults()\n+          .stream()\n+          .map(Study::getFqn)\n+          .collect(Collectors.toList());\n+    }\n+    return studyIds;\n+  }\n+\n+  private boolean isCaseProvided(Query query) {\n+    if (query != null) {\n+      return query.containsKey(ClinicalVariantEngine.QueryParams.CLINICAL_ANALYSIS_ID.key())\n+          || query.containsKey(ClinicalVariantEngine.QueryParams.FAMILY.key())\n+          || query.containsKey(ClinicalVariantEngine.QueryParams.SUBJECT.key())\n+          || query.containsKey(ClinicalVariantEngine.QueryParams.SAMPLE.key());\n+    }\n+    return false;\n+  }\n+\n+  private void cleanQuery(Query query) {\n+    if (query.containsKey(VariantQueryParam.GENOTYPE.key())) {\n+      query.remove(VariantQueryParam.SAMPLE.key());\n+      query.remove(FAMILY.key());\n+      query.remove(FAMILY_PHENOTYPE.key());\n+      query.remove(MODE_OF_INHERITANCE.key());\n     }\n+  }\n }\n",
            "diff_size": 1209
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "134",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "358",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "409",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 144).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "616",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 248).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "677",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 170).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "702",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 193).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "908",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 197).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/94/ClinicalInterpretationManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/94/ClinicalInterpretationManager.java\nindex d6dde662734..30f68dffb25 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/94/ClinicalInterpretationManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/94/ClinicalInterpretationManager.java\n@@ -159,8 +159,7 @@ public class ClinicalInterpretationManager extends StorageManager {\n //        this.init();\n     }\n \n-\n-    @Override\n+@Override\n     public void testConnection() throws StorageEngineException {\n     }\n \n@@ -243,8 +242,7 @@ public class ClinicalInterpretationManager extends StorageManager {\n \n     public OpenCGAResult<ClinicalVariant> get(Query query, QueryOptions queryOptions, InterpretationAnalysisConfiguration config,\n                                               String token) throws CatalogException, IOException, StorageEngineException {\n-\n-        VariantQueryResult<Variant> variantQueryResult = variantStorageManager.get(query, queryOptions, token);\n+    VariantQueryResult<Variant> variantQueryResult = variantStorageManager.get(query, queryOptions, token);\n         List<Variant> variants = variantQueryResult.getResults();\n \n         OpenCGAResult<ClinicalVariant> result = new OpenCGAResult<>(variantQueryResult.getTime(),\n@@ -355,12 +353,10 @@ public class ClinicalInterpretationManager extends StorageManager {\n     }\n \n     /*--------------------------------------------------------------------------*/\n-\n-    private ClinicalVariant createClinicalVariant(Variant variant, Map<String, Set<String>> genePanelMap,\n+private ClinicalVariant createClinicalVariant(Variant variant, Map<String, Set<String>> genePanelMap,\n                                                   Map<String, ClinicalProperty.RoleInCancer> roleInCancer,\n-                                                  Map<String, List<String>> actionableVariants,\n-                                                  InterpretationAnalysisConfiguration config) {\n-        List<String> panelIds;\n+                                                  Map<String, List<String>> actionableVariants, InterpretationAnalysisConfiguration config) {\n+    List<String> panelIds;\n         GenomicFeature gFeature;\n         List<ClinicalVariantEvidence> evidences = new ArrayList<>();\n \n@@ -410,10 +406,8 @@ public class ClinicalInterpretationManager extends StorageManager {\n                                                      String panelId, ClinicalProperty.ModeOfInheritance moi,\n                                                      ClinicalProperty.Penetrance penetrance, VariantAnnotation annotation,\n                                                      Map<String, ClinicalProperty.RoleInCancer> roleInCancer,\n-                                                     Map<String, List<String>> actionableVariants,\n-                                                     InterpretationAnalysisConfiguration config) {\n-\n-        ClinicalVariantEvidence clinicalVariantEvidence = new ClinicalVariantEvidence();\n+                                                     Map<String, List<String>> actionableVariants, InterpretationAnalysisConfiguration config) {\n+    ClinicalVariantEvidence clinicalVariantEvidence = new ClinicalVariantEvidence();\n \n //        // Consequence types\n //        if (CollectionUtils.isNotEmpty(consequenceType.getSequenceOntologyTerms())) {\n@@ -532,8 +526,7 @@ public class ClinicalInterpretationManager extends StorageManager {\n     /*--------------------------------------------------------------------------*/\n \n     public List<Variant> getDeNovoVariants(String clinicalAnalysisId, String studyId, Query query, QueryOptions queryOptions,\n-                                           String sessionId)\n-            throws ToolException, CatalogException, StorageEngineException, IOException {\n+                                           String sessionId) throws ToolException, CatalogException, StorageEngineException, IOException {\n         logger.debug(\"Getting DeNovo variants\");\n \n         Query currentQuery = new Query(defaultDeNovoQuery).append(STUDY.key(), studyId);\n@@ -620,9 +613,7 @@ public class ClinicalInterpretationManager extends StorageManager {\n         return variants;\n     }\n \n-    public Map<String, List<Variant>> getCompoundHeterozigousVariants(String clinicalAnalysisId, String studyId, Query query,\n-                                                                      QueryOptions queryOptions, String sessionId)\n-            throws ToolException, CatalogException, StorageEngineException, IOException {\n+    public Map<String, List<Variant>> getCompoundHeterozigousVariants(String clinicalAnalysisId, String studyId, Query query, QueryOptions queryOptions, String sessionId) throws ToolException, CatalogException, StorageEngineException, IOException {\n         logger.debug(\"Getting Compound Heterozigous variants\");\n \n         Query currentQuery = new Query(defaultCompoundHeterozigousQuery).append(STUDY.key(), studyId);\n@@ -683,14 +674,13 @@ public class ClinicalInterpretationManager extends StorageManager {\n         return ModeOfInheritance.compoundHeterozygous(iterator, probandSampleIdx, motherSampleIdx, fatherSampleIdx);\n     }\n \n-    public DefaultClinicalVariantCreator createClinicalVariantCreator(Query query, String assembly, boolean skipUntieredVariants,\n-                                                                      String sessionId) throws ToolException {\n-        // Clinical variant creator\n+    public DefaultClinicalVariantCreator createClinicalVariantCreator(Query query, String assembly, boolean skipUntieredVariants, String sessionId) throws ToolException {\n+    // Clinical variant creator\n         ClinicalProperty.ModeOfInheritance moi = ClinicalProperty.ModeOfInheritance.valueOf(query.getString(FAMILY_SEGREGATION.key(),\n                 ClinicalProperty.ModeOfInheritance.UNKNOWN.name()));\n         List<String> biotypes = query.getAsStringList(VariantQueryParam.ANNOT_BIOTYPE.key());\n         List<String> soNames = new ArrayList<>();\n-        List<String>  consequenceTypes = query.getAsStringList(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key());\n+        List<String> consequenceTypes = query.getAsStringList(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key());\n         if (CollectionUtils.isNotEmpty(consequenceTypes)) {\n             for (String soName : consequenceTypes) {\n                 if (soName.startsWith(\"SO:\")) {\n@@ -709,8 +699,7 @@ public class ClinicalInterpretationManager extends StorageManager {\n             Disorder disorder = new Disorder().setId(query.getString(FAMILY_DISORDER.key()));\n             List<DiseasePanel> diseasePanels = getDiseasePanels(query, sessionId);\n             return new DefaultClinicalVariantCreator(getRoleInCancerManager().getRoleInCancer(),\n-                    getActionableVariantManager().getActionableVariants(assembly), disorder, moi, ClinicalProperty.Penetrance.COMPLETE,\n-                    diseasePanels, biotypes, soNames, !skipUntieredVariants);\n+                    getActionableVariantManager().getActionableVariants(assembly), disorder, moi, ClinicalProperty.Penetrance.COMPLETE, diseasePanels, biotypes, soNames, !skipUntieredVariants);\n         } catch (IOException e) {\n             throw new ToolException(\"Error creating clinical variant creator\", e);\n         }\n@@ -770,7 +759,7 @@ public class ClinicalInterpretationManager extends StorageManager {\n \n     public List<ClinicalVariant> getPrimaryFindings(Query query, QueryOptions queryOptions, ClinicalVariantCreator clinicalVariantCreator,\n                                                     String sessionId) throws ToolException {\n-        try {\n+    try {\n             VariantQueryResult<Variant> variantQueryResult = getVariantStorageManager().get(query, queryOptions, sessionId);\n             List<Variant> variants = variantQueryResult.getResults();\n \n@@ -787,8 +776,7 @@ public class ClinicalInterpretationManager extends StorageManager {\n     }\n \n     public List<ClinicalVariant> getPrimaryFindings(String clinicalAnalysisId, Query query, QueryOptions queryOptions,\n-                                                    ClinicalVariantCreator clinicalVariantCreator, String sessionId)\n-            throws ToolException {\n+                                                    ClinicalVariantCreator clinicalVariantCreator, String sessionId) throws ToolException {\n         List<Variant> variants;\n         List<ClinicalVariant> clinicalVariants;\n \n@@ -825,7 +813,7 @@ public class ClinicalInterpretationManager extends StorageManager {\n \n     public List<ClinicalVariant> getSecondaryFindings(String studyId, String sampleId, ClinicalVariantCreator clinicalVariantCreator,\n                                                       String sessionId) throws ToolException {\n-        try {\n+    try {\n             List<Variant> variants = new ArrayList<>();\n \n             // Prepare query object\n@@ -916,9 +904,8 @@ public class ClinicalInterpretationManager extends StorageManager {\n         return variants;\n     }\n \n-    public List<ClinicalVariant> getSecondaryFindings(ClinicalAnalysis clinicalAnalysis,  List<String> sampleNames,\n-                                                      String studyId, ClinicalVariantCreator creator, String sessionId)\n-            throws StorageEngineException, ToolException, CatalogException, IOException {\n+    public List<ClinicalVariant> getSecondaryFindings(ClinicalAnalysis clinicalAnalysis, List<String> sampleNames,\n+                                                      String studyId, ClinicalVariantCreator creator, String sessionId) throws StorageEngineException, ToolException, CatalogException, IOException {\n         throw new NotImplementedException(\"Secondary findings does not exist\");\n //        List<ClinicalVariant> secondaryFindings = null;\n //        if (clinicalAnalysis.getConsent() != null\n@@ -1259,4 +1246,4 @@ public class ClinicalInterpretationManager extends StorageManager {\n             query.remove(MODE_OF_INHERITANCE.key());\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 32
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "134",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 153).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}