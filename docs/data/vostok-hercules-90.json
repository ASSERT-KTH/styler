{
    "project_name": "vostok-hercules",
    "error_id": "90",
    "information": {
        "errors": [
            {
                "line": "198",
                "column": "56",
                "severity": "warning",
                "message": "'{' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "                                for (ConsumerRecord<UUID, Event> record : records) {\n                                    Event event = record.value();\n                                    if (event == null) {// Received non-deserializable data, should be ignored\n                                        droppedEvents++;\n                                        continue;\n                                    }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/90/Sink.java\nindex 37e81e242d7..eb2c03c2bca 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/90/Sink.java\n@@ -195,7 +195,7 @@ public class Sink implements Lifecycle {\n                                 List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                                 for (ConsumerRecord<UUID, Event> record : records) {\n                                     Event event = record.value();\n-                                    if (event == null) {// Received non-deserializable data, should be ignored\n+                                    if (event == null) { // Received non-deserializable data, should be ignored\n                                         droppedEvents++;\n                                         continue;\n                                     }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "198",
                    "column": "38",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/90/Sink.java\nindex 37e81e242d7..67e5eb61ff1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/90/Sink.java\n@@ -39,272 +39,272 @@ import java.util.regex.Pattern;\n  * @author Gregory Koshelev\n  */\n public class Sink implements Lifecycle {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(Sink.class);\n-\n-    private volatile boolean running = false;\n-\n-    private final ExecutorService executor;\n-    private final Processor processor;\n-\n-    private final List<EventFilter> filters;\n-\n-    private final long pollTimeoutMs;\n-    private final int batchSize;\n-    private final long availabilityTimeoutMs;\n-\n-    private final Pattern pattern;\n-    private final KafkaConsumer<UUID, Event> consumer;\n-\n-    private final Timer timer;\n-\n-    private final Meter droppedEventsMeter;\n-    private final Meter filteredEventsMeter;\n-    private final Meter processedEventsMeter;\n-    private final Meter rejectedEventsMeter;\n-    private final Meter totalEventsMeter;\n-\n-    public Sink(\n-            ExecutorService executor,\n-            String applicationId,\n-            Properties properties,\n-            Processor processor,\n-            Subscription subscription,\n-            EventDeserializer deserializer,\n-            MetricsCollector metricsCollector) {\n-        this(executor, applicationId, properties, processor, subscription, deserializer, metricsCollector, TimeSource.SYSTEM);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(Sink.class);\n+\n+  private volatile boolean running = false;\n+\n+  private final ExecutorService executor;\n+  private final Processor processor;\n+\n+  private final List<EventFilter> filters;\n+\n+  private final long pollTimeoutMs;\n+  private final int batchSize;\n+  private final long availabilityTimeoutMs;\n+\n+  private final Pattern pattern;\n+  private final KafkaConsumer<UUID, Event> consumer;\n+\n+  private final Timer timer;\n+\n+  private final Meter droppedEventsMeter;\n+  private final Meter filteredEventsMeter;\n+  private final Meter processedEventsMeter;\n+  private final Meter rejectedEventsMeter;\n+  private final Meter totalEventsMeter;\n+\n+  public Sink(\n+    ExecutorService executor,\n+    String applicationId,\n+    Properties properties,\n+    Processor processor,\n+    Subscription subscription,\n+    EventDeserializer deserializer,\n+    MetricsCollector metricsCollector) {\n+    this(executor, applicationId, properties, processor, subscription, deserializer, metricsCollector, TimeSource.SYSTEM);\n+  }\n+\n+  Sink(\n+    ExecutorService executor,\n+    String applicationId,\n+    Properties properties,\n+    Processor processor,\n+    Subscription subscription,\n+    EventDeserializer deserializer,\n+    MetricsCollector metricsCollector,\n+    TimeSource time) {\n+    this.executor = executor;\n+    this.processor = processor;\n+\n+    this.filters = EventFilter.from(PropertiesUtil.ofScope(properties, \"filter\"));\n+\n+    this.pollTimeoutMs = PropertiesUtil.get(Props.POLL_TIMEOUT_MS, properties).get();\n+    this.batchSize = PropertiesUtil.get(Props.BATCH_SIZE, properties).get();\n+    this.availabilityTimeoutMs = PropertiesUtil.get(Props.AVAILABILITY_TIMEOUT_MS, properties).get();\n+\n+    String consumerGroupId =\n+      PropertiesUtil.get(Props.GROUP_ID, properties).\n+        orEmpty(subscription.toGroupId(applicationId));\n+\n+    this.pattern = subscription.toPattern();\n+\n+    Properties consumerProperties = PropertiesUtil.ofScope(properties, Scopes.CONSUMER);\n+    consumerProperties.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId);\n+    consumerProperties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);\n+    consumerProperties.putIfAbsent(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, batchSize);\n+    consumerProperties.put(KafkaConfigs.METRICS_COLLECTOR_INSTANCE_CONFIG, metricsCollector);\n+\n+    UuidDeserializer keyDeserializer = new UuidDeserializer();\n+\n+    this.consumer = new KafkaConsumer<>(consumerProperties, keyDeserializer, deserializer);\n+\n+    this.timer = time.timer(pollTimeoutMs);\n+\n+    droppedEventsMeter = metricsCollector.meter(\"droppedEvents\");\n+    filteredEventsMeter = metricsCollector.meter(\"filteredEvents\");\n+    processedEventsMeter = metricsCollector.meter(\"processedEvents\");\n+    rejectedEventsMeter = metricsCollector.meter(\"rejectedEvents\");\n+    totalEventsMeter = metricsCollector.meter(\"totalEvents\");\n+  }\n+\n+  /**\n+   * Start sink.\n+   */\n+  public final void start() {\n+    running = true;\n+\n+    executor.execute(this::run);\n+  }\n+\n+  /**\n+   * Stop Sink.\n+   */\n+  @Override\n+  public final boolean stop(long timeout, TimeUnit unit) {\n+    running = false;\n+\n+    try {\n+      consumer.wakeup();\n+    } catch (Exception ex) {\n+      /* ignore */\n     }\n \n-    Sink(\n-            ExecutorService executor,\n-            String applicationId,\n-            Properties properties,\n-            Processor processor,\n-            Subscription subscription,\n-            EventDeserializer deserializer,\n-            MetricsCollector metricsCollector,\n-            TimeSource time) {\n-        this.executor = executor;\n-        this.processor = processor;\n-\n-        this.filters = EventFilter.from(PropertiesUtil.ofScope(properties, \"filter\"));\n-\n-        this.pollTimeoutMs = PropertiesUtil.get(Props.POLL_TIMEOUT_MS, properties).get();\n-        this.batchSize = PropertiesUtil.get(Props.BATCH_SIZE, properties).get();\n-        this.availabilityTimeoutMs = PropertiesUtil.get(Props.AVAILABILITY_TIMEOUT_MS, properties).get();\n-\n-        String consumerGroupId =\n-                PropertiesUtil.get(Props.GROUP_ID, properties).\n-                        orEmpty(subscription.toGroupId(applicationId));\n-\n-        this.pattern = subscription.toPattern();\n-\n-        Properties consumerProperties = PropertiesUtil.ofScope(properties, Scopes.CONSUMER);\n-        consumerProperties.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId);\n-        consumerProperties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);\n-        consumerProperties.putIfAbsent(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, batchSize);\n-        consumerProperties.put(KafkaConfigs.METRICS_COLLECTOR_INSTANCE_CONFIG, metricsCollector);\n-\n-        UuidDeserializer keyDeserializer = new UuidDeserializer();\n-\n-        this.consumer = new KafkaConsumer<>(consumerProperties, keyDeserializer, deserializer);\n-\n-        this.timer = time.timer(pollTimeoutMs);\n-\n-        droppedEventsMeter = metricsCollector.meter(\"droppedEvents\");\n-        filteredEventsMeter = metricsCollector.meter(\"filteredEvents\");\n-        processedEventsMeter = metricsCollector.meter(\"processedEvents\");\n-        rejectedEventsMeter = metricsCollector.meter(\"rejectedEvents\");\n-        totalEventsMeter = metricsCollector.meter(\"totalEvents\");\n-    }\n-\n-    /**\n-     * Start sink.\n-     */\n-    public final void start() {\n-        running = true;\n-\n-        executor.execute(this::run);\n+    try {\n+      consumer.close();\n+    } catch (Exception ex) {\n+      /* ignore */\n     }\n \n-    /**\n-     * Stop Sink.\n-     */\n-    @Override\n-    public final boolean stop(long timeout, TimeUnit unit) {\n-        running = false;\n-\n-        try {\n-            consumer.wakeup();\n-        } catch (Exception ex) {\n-            /* ignore */\n-        }\n-\n+    postStop();\n+    return true;\n+  }\n+\n+  /**\n+   * Check Sink running status.\n+   *\n+   * @return {@code true} if Sink is running and {@code false} if Sink is stopping\n+   */\n+  public final boolean isRunning() {\n+    return running;\n+  }\n+\n+  /**\n+   * Main Sink logic. Sink poll events from Kafka and processes them using {@link Processor} if possible.\n+   * <p>\n+   * Sink awaits availability of {@link Processor}. Also, it controls {@link #isRunning()} during operations.\n+   */\n+  public final void run() {\n+    while (isRunning()) {\n+      if (processor.isAvailable()) {\n         try {\n-            consumer.close();\n-        } catch (Exception ex) {\n-            /* ignore */\n-        }\n-\n-        postStop();\n-        return true;\n-    }\n \n-    /**\n-     * Check Sink running status.\n-     *\n-     * @return {@code true} if Sink is running and {@code false} if Sink is stopping\n-     */\n-    public final boolean isRunning() {\n-        return running;\n-    }\n-\n-    /**\n-     * Main Sink logic. Sink poll events from Kafka and processes them using {@link Processor} if possible.\n-     * <p>\n-     * Sink awaits availability of {@link Processor}. Also, it controls {@link #isRunning()} during operations.\n-     */\n-    public final void run() {\n-        while (isRunning()) {\n-            if (processor.isAvailable()) {\n-                try {\n-\n-                    subscribe();\n-\n-                    while (processor.isAvailable()) {\n-                        List<Event> events = new ArrayList<>(batchSize * 2);\n-\n-                        int droppedEvents = 0;\n-                        int filteredEvents = 0;\n-\n-                        timer.reset();\n-\n-                        do {\n-                            ConsumerRecords<UUID, Event> pollResult;\n-                            try {\n-                                pollResult = poll(timer.toDuration());\n-                            } catch (WakeupException ex) {\n-                                /*\n-                                 * WakeupException is used to terminate polling\n-                                 */\n-                                return;\n-                            }\n-\n-                            Set<TopicPartition> partitions = pollResult.partitions();\n-\n-                            for (TopicPartition partition : partitions) {\n-                                List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n-                                for (ConsumerRecord<UUID, Event> record : records) {\n-                                    Event event = record.value();\n-                                    if (event == null) {// Received non-deserializable data, should be ignored\n-                                        droppedEvents++;\n-                                        continue;\n-                                    }\n-                                    if (!filter(event)) {\n-                                        filteredEvents++;\n-                                        continue;\n-                                    }\n-                                    events.add(event);\n-                                }\n-                            }\n-                        } while (events.size() < batchSize && !timer.isExpired());\n-\n-                        ProcessorResult result = processor.process(events);\n-                        if (result.isSuccess()) {\n-                            try {\n-                                commit();\n-                                droppedEventsMeter.mark(droppedEvents);\n-                                filteredEventsMeter.mark(filteredEvents);\n-                                processedEventsMeter.mark(result.getProcessedEvents());\n-                                rejectedEventsMeter.mark(result.getRejectedEvents());\n-                                totalEventsMeter.mark(events.size());\n-                            } catch (CommitFailedException ex) {\n-                                LOGGER.warn(\"Commit failed due to rebalancing\", ex);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                } catch (Exception ex) {\n-                    LOGGER.error(\"Unspecified exception has been acquired\", ex);\n-                } finally {\n-                    unsubscribe();\n+          subscribe();\n+\n+          while (processor.isAvailable()) {\n+            List<Event> events = new ArrayList<>(batchSize * 2);\n+\n+            int droppedEvents = 0;\n+            int filteredEvents = 0;\n+\n+            timer.reset();\n+\n+            do {\n+              ConsumerRecords<UUID, Event> pollResult;\n+              try {\n+                pollResult = poll(timer.toDuration());\n+              } catch (WakeupException ex) {\n+                /*\n+                 * WakeupException is used to terminate polling\n+                 */\n+                return;\n+              }\n+\n+              Set<TopicPartition> partitions = pollResult.partitions();\n+\n+              for (TopicPartition partition : partitions) {\n+                List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n+                for (ConsumerRecord<UUID, Event> record : records) {\n+                  Event event = record.value();\n+                  if (event == null) {// Received non-deserializable data, should be ignored\n+                    droppedEvents++;\n+                    continue;\n+                  }\n+                  if (!filter(event)) {\n+                    filteredEvents++;\n+                    continue;\n+                  }\n+                  events.add(event);\n                 }\n+              }\n+            } while (events.size() < batchSize && !timer.isExpired());\n+\n+            ProcessorResult result = processor.process(events);\n+            if (result.isSuccess()) {\n+              try {\n+                commit();\n+                droppedEventsMeter.mark(droppedEvents);\n+                filteredEventsMeter.mark(filteredEvents);\n+                processedEventsMeter.mark(result.getProcessedEvents());\n+                rejectedEventsMeter.mark(result.getRejectedEvents());\n+                totalEventsMeter.mark(events.size());\n+              } catch (CommitFailedException ex) {\n+                LOGGER.warn(\"Commit failed due to rebalancing\", ex);\n+                continue;\n+              }\n             }\n-\n-            processor.awaitAvailability(availabilityTimeoutMs);\n-        }\n-    }\n-\n-    /**\n-     * Perform additional stop operations when Event consuming was terminated.\n-     */\n-    protected void postStop() {\n-\n-    }\n-\n-    /**\n-     * Subscribe Sink. Should be called before polling\n-     */\n-    protected final void subscribe() {\n-        consumer.subscribe(pattern);\n-    }\n-\n-    /**\n-     * Unsubscribe Sink. Should be called if Sink cannot process Events.\n-     */\n-    protected final void unsubscribe() {\n-        LOGGER.debug(\"Sink unsubscribe if any\");\n-        try {\n-            consumer.unsubscribe();\n+          }\n         } catch (Exception ex) {\n-            /* ignore */\n+          LOGGER.error(\"Unspecified exception has been acquired\", ex);\n+        } finally {\n+          unsubscribe();\n         }\n-    }\n-\n-    /**\n-     * Poll Events from Kafka. Should be called when Sink subscribed.\n-     *\n-     * @return polled Events\n-     * @throws WakeupException if poll terminated due to shutdown\n-     */\n-    protected final ConsumerRecords<UUID, Event> poll(Duration timeout) throws WakeupException {\n-        return consumer.poll(timeout);\n-    }\n+      }\n \n-    protected final void commit() {\n-        consumer.commitSync();\n+      processor.awaitAvailability(availabilityTimeoutMs);\n     }\n-\n-    protected final void commit(Map<TopicPartition, OffsetAndMetadata> offsets) {\n-        consumer.commitSync(offsets);\n-    }\n-\n-    private boolean filter(Event event) {\n-        for (EventFilter filter : filters) {\n-            if (!filter.test(event)) {\n-                return false;\n-            }\n-        }\n-        return true;\n+  }\n+\n+  /**\n+   * Perform additional stop operations when Event consuming was terminated.\n+   */\n+  protected void postStop() {\n+\n+  }\n+\n+  /**\n+   * Subscribe Sink. Should be called before polling\n+   */\n+  protected final void subscribe() {\n+    consumer.subscribe(pattern);\n+  }\n+\n+  /**\n+   * Unsubscribe Sink. Should be called if Sink cannot process Events.\n+   */\n+  protected final void unsubscribe() {\n+    LOGGER.debug(\"Sink unsubscribe if any\");\n+    try {\n+      consumer.unsubscribe();\n+    } catch (Exception ex) {\n+      /* ignore */\n     }\n-\n-    private static class Props {\n-        static final Parameter<Long> POLL_TIMEOUT_MS =\n-                Parameter.longParameter(\"pollTimeoutMs\").\n-                        withDefault(6_000L).\n-                        build();\n-\n-        static final Parameter<Integer> BATCH_SIZE =\n-                Parameter.integerParameter(\"batchSize\").\n-                        withDefault(1000).\n-                        build();\n-\n-        static final Parameter<String> GROUP_ID =\n-                Parameter.stringParameter(\"groupId\").\n-                        build();\n-\n-        static final Parameter<Long> AVAILABILITY_TIMEOUT_MS =\n-                Parameter.longParameter(\"availabilityTimeoutMs\").\n-                        withDefault(2_000L).\n-                        build();\n+  }\n+\n+  /**\n+   * Poll Events from Kafka. Should be called when Sink subscribed.\n+   *\n+   * @return polled Events\n+   * @throws WakeupException if poll terminated due to shutdown\n+   */\n+  protected final ConsumerRecords<UUID, Event> poll(Duration timeout) throws WakeupException {\n+    return consumer.poll(timeout);\n+  }\n+\n+  protected final void commit() {\n+    consumer.commitSync();\n+  }\n+\n+  protected final void commit(Map<TopicPartition, OffsetAndMetadata> offsets) {\n+    consumer.commitSync(offsets);\n+  }\n+\n+  private boolean filter(Event event) {\n+    for (EventFilter filter : filters) {\n+      if (!filter.test(event)) {\n+        return false;\n+      }\n     }\n+    return true;\n+  }\n+\n+  private static class Props {\n+    static final Parameter<Long> POLL_TIMEOUT_MS =\n+      Parameter.longParameter(\"pollTimeoutMs\").\n+        withDefault(6_000L).\n+        build();\n+\n+    static final Parameter<Integer> BATCH_SIZE =\n+      Parameter.integerParameter(\"batchSize\").\n+        withDefault(1000).\n+        build();\n+\n+    static final Parameter<String> GROUP_ID =\n+      Parameter.stringParameter(\"groupId\").\n+        build();\n+\n+    static final Parameter<Long> AVAILABILITY_TIMEOUT_MS =\n+      Parameter.longParameter(\"availabilityTimeoutMs\").\n+        withDefault(2_000L).\n+        build();\n+  }\n }\n",
            "diff_size": 386
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/90/Sink.java\nindex 37e81e242d7..00437acf981 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/90/Sink.java\n@@ -71,7 +71,7 @@ public class Sink implements Lifecycle {\n             Subscription subscription,\n             EventDeserializer deserializer,\n             MetricsCollector metricsCollector) {\n-        this(executor, applicationId, properties, processor, subscription, deserializer, metricsCollector, TimeSource.SYSTEM);\n+                  this(executor, applicationId, properties, processor, subscription, deserializer, metricsCollector, TimeSource.SYSTEM);\n     }\n \n     Sink(\n@@ -83,7 +83,7 @@ public class Sink implements Lifecycle {\n             EventDeserializer deserializer,\n             MetricsCollector metricsCollector,\n             TimeSource time) {\n-        this.executor = executor;\n+    this.executor = executor;\n         this.processor = processor;\n \n         this.filters = EventFilter.from(PropertiesUtil.ofScope(properties, \"filter\"));\n@@ -93,10 +93,8 @@ public class Sink implements Lifecycle {\n         this.availabilityTimeoutMs = PropertiesUtil.get(Props.AVAILABILITY_TIMEOUT_MS, properties).get();\n \n         String consumerGroupId =\n-                PropertiesUtil.get(Props.GROUP_ID, properties).\n-                        orEmpty(subscription.toGroupId(applicationId));\n-\n-        this.pattern = subscription.toPattern();\n+                PropertiesUtil.get(Props.GROUP_ID, properties).orEmpty(subscription.toGroupId(applicationId));\n+this.pattern = subscription.toPattern();\n \n         Properties consumerProperties = PropertiesUtil.ofScope(properties, Scopes.CONSUMER);\n         consumerProperties.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId);\n@@ -167,8 +165,7 @@ public class Sink implements Lifecycle {\n         while (isRunning()) {\n             if (processor.isAvailable()) {\n                 try {\n-\n-                    subscribe();\n+    subscribe();\n \n                     while (processor.isAvailable()) {\n                         List<Event> events = new ArrayList<>(batchSize * 2);\n@@ -177,8 +174,7 @@ public class Sink implements Lifecycle {\n                         int filteredEvents = 0;\n \n                         timer.reset();\n-\n-                        do {\n+do {\n                             ConsumerRecords<UUID, Event> pollResult;\n                             try {\n                                 pollResult = poll(timer.toDuration());\n@@ -195,7 +191,7 @@ public class Sink implements Lifecycle {\n                                 List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                                 for (ConsumerRecord<UUID, Event> record : records) {\n                                     Event event = record.value();\n-                                    if (event == null) {// Received non-deserializable data, should be ignored\n+                                    if (event == null) { // Received non-deserializable data, should be ignored\n                                         droppedEvents++;\n                                         continue;\n                                     }\n@@ -289,22 +285,15 @@ public class Sink implements Lifecycle {\n \n     private static class Props {\n         static final Parameter<Long> POLL_TIMEOUT_MS =\n-                Parameter.longParameter(\"pollTimeoutMs\").\n-                        withDefault(6_000L).\n-                        build();\n+                Parameter.longParameter(\"pollTimeoutMs\").withDefault(6_000L).build();\n \n         static final Parameter<Integer> BATCH_SIZE =\n-                Parameter.integerParameter(\"batchSize\").\n-                        withDefault(1000).\n-                        build();\n+                Parameter.integerParameter(\"batchSize\").withDefault(1000).build();\n \n         static final Parameter<String> GROUP_ID =\n-                Parameter.stringParameter(\"groupId\").\n-                        build();\n+                Parameter.stringParameter(\"groupId\").build();\n \n         static final Parameter<Long> AVAILABILITY_TIMEOUT_MS =\n-                Parameter.longParameter(\"availabilityTimeoutMs\").\n-                        withDefault(2_000L).\n-                        build();\n+                Parameter.longParameter(\"availabilityTimeoutMs\").withDefault(2_000L).build();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 23
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "81",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 213).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "190",
                    "column": "56",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/90/Sink.java\nindex 37e81e242d7..afa6db8e30e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/90/Sink.java\n@@ -23,7 +23,6 @@ import ru.kontur.vostok.hercules.util.parameter.Parameter;\n import ru.kontur.vostok.hercules.util.properties.PropertiesUtil;\n import ru.kontur.vostok.hercules.util.time.TimeSource;\n import ru.kontur.vostok.hercules.util.time.Timer;\n-\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n@@ -38,25 +37,21 @@ import java.util.regex.Pattern;\n /**\n  * @author Gregory Koshelev\n  */\n+\n+\n public class Sink implements Lifecycle {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(Sink.class);\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(Sink.class);\n     private volatile boolean running = false;\n-\n     private final ExecutorService executor;\n     private final Processor processor;\n-\n     private final List<EventFilter> filters;\n-\n     private final long pollTimeoutMs;\n     private final int batchSize;\n     private final long availabilityTimeoutMs;\n-\n     private final Pattern pattern;\n     private final KafkaConsumer<UUID, Event> consumer;\n-\n     private final Timer timer;\n-\n     private final Meter droppedEventsMeter;\n     private final Meter filteredEventsMeter;\n     private final Meter processedEventsMeter;\n@@ -64,38 +59,38 @@ public class Sink implements Lifecycle {\n     private final Meter totalEventsMeter;\n \n     public Sink(\n-            ExecutorService executor,\n-            String applicationId,\n-            Properties properties,\n-            Processor processor,\n-            Subscription subscription,\n-            EventDeserializer deserializer,\n-            MetricsCollector metricsCollector) {\n-        this(executor, applicationId, properties, processor, subscription, deserializer, metricsCollector, TimeSource.SYSTEM);\n+        ExecutorService executor,\n+        String applicationId,\n+        Properties properties,\n+        Processor processor,\n+        Subscription subscription,\n+        EventDeserializer deserializer, MetricsCollector metricsCollector\n+    ) {\n+        this(\n+        executor,\n+applicationId,\n+properties,\n+processor,\n+subscription,\n+deserializer,\n+metricsCollector,\n+TimeSource.SYSTEM\n+);\n     }\n \n-    Sink(\n-            ExecutorService executor,\n-            String applicationId,\n-            Properties properties,\n-            Processor processor,\n-            Subscription subscription,\n-            EventDeserializer deserializer,\n-            MetricsCollector metricsCollector,\n-            TimeSource time) {\n+    Sink(ExecutorService executor, String applicationId, Properties properties, Processor processor, Subscription subscription, EventDeserializer deserializer, MetricsCollector metricsCollector, TimeSource time) {\n         this.executor = executor;\n         this.processor = processor;\n-\n         this.filters = EventFilter.from(PropertiesUtil.ofScope(properties, \"filter\"));\n-\n-        this.pollTimeoutMs = PropertiesUtil.get(Props.POLL_TIMEOUT_MS, properties).get();\n-        this.batchSize = PropertiesUtil.get(Props.BATCH_SIZE, properties).get();\n-        this.availabilityTimeoutMs = PropertiesUtil.get(Props.AVAILABILITY_TIMEOUT_MS, properties).get();\n-\n-        String consumerGroupId =\n-                PropertiesUtil.get(Props.GROUP_ID, properties).\n-                        orEmpty(subscription.toGroupId(applicationId));\n-\n+        this.pollTimeoutMs = PropertiesUtil.get(Props.POLL_TIMEOUT_MS, properties)\n+        .get();\n+        this.batchSize = PropertiesUtil.get(Props.BATCH_SIZE, properties)\n+        .get();\n+        this.availabilityTimeoutMs = PropertiesUtil.get(Props.AVAILABILITY_TIMEOUT_MS, properties)\n+        .get();\n+\n+        String consumerGroupId = PropertiesUtil.get(Props.GROUP_ID, properties)\n+        .orEmpty(subscription.toGroupId(applicationId));\n         this.pattern = subscription.toPattern();\n \n         Properties consumerProperties = PropertiesUtil.ofScope(properties, Scopes.CONSUMER);\n@@ -105,11 +100,8 @@ public class Sink implements Lifecycle {\n         consumerProperties.put(KafkaConfigs.METRICS_COLLECTOR_INSTANCE_CONFIG, metricsCollector);\n \n         UuidDeserializer keyDeserializer = new UuidDeserializer();\n-\n         this.consumer = new KafkaConsumer<>(consumerProperties, keyDeserializer, deserializer);\n-\n         this.timer = time.timer(pollTimeoutMs);\n-\n         droppedEventsMeter = metricsCollector.meter(\"droppedEvents\");\n         filteredEventsMeter = metricsCollector.meter(\"filteredEvents\");\n         processedEventsMeter = metricsCollector.meter(\"processedEvents\");\n@@ -120,15 +112,16 @@ public class Sink implements Lifecycle {\n     /**\n      * Start sink.\n      */\n+\n     public final void start() {\n         running = true;\n-\n         executor.execute(this::run);\n     }\n \n     /**\n      * Stop Sink.\n      */\n+\n     @Override\n     public final boolean stop(long timeout, TimeUnit unit) {\n         running = false;\n@@ -137,12 +130,14 @@ public class Sink implements Lifecycle {\n             consumer.wakeup();\n         } catch (Exception ex) {\n             /* ignore */\n+\n         }\n \n         try {\n             consumer.close();\n         } catch (Exception ex) {\n             /* ignore */\n+\n         }\n \n         postStop();\n@@ -154,6 +149,7 @@ public class Sink implements Lifecycle {\n      *\n      * @return {@code true} if Sink is running and {@code false} if Sink is stopping\n      */\n+\n     public final boolean isRunning() {\n         return running;\n     }\n@@ -163,21 +159,18 @@ public class Sink implements Lifecycle {\n      * <p>\n      * Sink awaits availability of {@link Processor}. Also, it controls {@link #isRunning()} during operations.\n      */\n+\n     public final void run() {\n         while (isRunning()) {\n             if (processor.isAvailable()) {\n                 try {\n-\n                     subscribe();\n \n                     while (processor.isAvailable()) {\n                         List<Event> events = new ArrayList<>(batchSize * 2);\n-\n                         int droppedEvents = 0;\n                         int filteredEvents = 0;\n-\n                         timer.reset();\n-\n                         do {\n                             ConsumerRecords<UUID, Event> pollResult;\n                             try {\n@@ -190,7 +183,6 @@ public class Sink implements Lifecycle {\n                             }\n \n                             Set<TopicPartition> partitions = pollResult.partitions();\n-\n                             for (TopicPartition partition : partitions) {\n                                 List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                                 for (ConsumerRecord<UUID, Event> record : records) {\n@@ -203,6 +195,7 @@ public class Sink implements Lifecycle {\n                                         filteredEvents++;\n                                         continue;\n                                     }\n+\n                                     events.add(event);\n                                 }\n                             }\n@@ -237,6 +230,7 @@ public class Sink implements Lifecycle {\n     /**\n      * Perform additional stop operations when Event consuming was terminated.\n      */\n+\n     protected void postStop() {\n \n     }\n@@ -244,6 +238,7 @@ public class Sink implements Lifecycle {\n     /**\n      * Subscribe Sink. Should be called before polling\n      */\n+\n     protected final void subscribe() {\n         consumer.subscribe(pattern);\n     }\n@@ -251,12 +246,15 @@ public class Sink implements Lifecycle {\n     /**\n      * Unsubscribe Sink. Should be called if Sink cannot process Events.\n      */\n+\n     protected final void unsubscribe() {\n         LOGGER.debug(\"Sink unsubscribe if any\");\n+\n         try {\n             consumer.unsubscribe();\n         } catch (Exception ex) {\n             /* ignore */\n+\n         }\n     }\n \n@@ -266,6 +264,7 @@ public class Sink implements Lifecycle {\n      * @return polled Events\n      * @throws WakeupException if poll terminated due to shutdown\n      */\n+\n     protected final ConsumerRecords<UUID, Event> poll(Duration timeout) throws WakeupException {\n         return consumer.poll(timeout);\n     }\n@@ -288,23 +287,19 @@ public class Sink implements Lifecycle {\n     }\n \n     private static class Props {\n-        static final Parameter<Long> POLL_TIMEOUT_MS =\n-                Parameter.longParameter(\"pollTimeoutMs\").\n-                        withDefault(6_000L).\n-                        build();\n-\n-        static final Parameter<Integer> BATCH_SIZE =\n-                Parameter.integerParameter(\"batchSize\").\n-                        withDefault(1000).\n-                        build();\n-\n-        static final Parameter<String> GROUP_ID =\n-                Parameter.stringParameter(\"groupId\").\n-                        build();\n-\n-        static final Parameter<Long> AVAILABILITY_TIMEOUT_MS =\n-                Parameter.longParameter(\"availabilityTimeoutMs\").\n-                        withDefault(2_000L).\n-                        build();\n+        static final Parameter<Long> POLL_TIMEOUT_MS = Parameter.longParameter(\"pollTimeoutMs\")\n+        .withDefault(6_000L)\n+        .build();\n+\n+        static final Parameter<Integer> BATCH_SIZE = Parameter.integerParameter(\"batchSize\")\n+        .withDefault(1000)\n+        .build();\n+\n+        static final Parameter<String> GROUP_ID = Parameter.stringParameter(\"groupId\")\n+        .build();\n+\n+        static final Parameter<Long> AVAILABILITY_TIMEOUT_MS = Parameter.longParameter(\"availabilityTimeoutMs\")\n+        .withDefault(2_000L)\n+        .build();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 88
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/90/Sink.java\nindex 37e81e242d7..eb2c03c2bca 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/90/Sink.java\n@@ -195,7 +195,7 @@ public class Sink implements Lifecycle {\n                                 List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                                 for (ConsumerRecord<UUID, Event> record : records) {\n                                     Event event = record.value();\n-                                    if (event == null) {// Received non-deserializable data, should be ignored\n+                                    if (event == null) { // Received non-deserializable data, should be ignored\n                                         droppedEvents++;\n                                         continue;\n                                     }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/90/Sink.java\nindex 37e81e242d7..eb2c03c2bca 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/90/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/90/Sink.java\n@@ -195,7 +195,7 @@ public class Sink implements Lifecycle {\n                                 List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                                 for (ConsumerRecord<UUID, Event> record : records) {\n                                     Event event = record.value();\n-                                    if (event == null) {// Received non-deserializable data, should be ignored\n+                                    if (event == null) { // Received non-deserializable data, should be ignored\n                                         droppedEvents++;\n                                         continue;\n                                     }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}