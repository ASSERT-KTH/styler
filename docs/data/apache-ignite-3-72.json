{
    "project_name": "apache-ignite-3",
    "error_id": "72",
    "information": {
        "errors": [
            {
                "line": "58",
                "column": "5",
                "severity": "error",
                "message": "'VARIABLE_DEF' should be separated from previous line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
            }
        ]
    },
    "source_code": "\n    private String description;\n    private int currentLineNumber = -1;\n\n    public String getDescription() {\n        return description;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler/72/BytecodeBlock.java\nindex 06d2b5bbc60..1ca3c4efd68 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler/72/BytecodeBlock.java\n@@ -55,6 +55,7 @@ public class BytecodeBlock\n     private final List<BytecodeNode> nodes = new ArrayList<>();\n \n     private String description;\n+\n     private int currentLineNumber = -1;\n \n     public String getDescription() {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/intellij/72/BytecodeBlock.java\nindex 06d2b5bbc60..7fd91e27c4c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/intellij/72/BytecodeBlock.java\n@@ -11,6 +11,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package com.facebook.presto.bytecode;\n \n import com.facebook.presto.bytecode.debug.LineNumberNode;\n@@ -52,786 +53,777 @@ import static com.facebook.presto.bytecode.instruction.VariableInstruction.store\n @SuppressWarnings(\"UnusedDeclaration\")\n public class BytecodeBlock\n     implements BytecodeNode {\n-    private final List<BytecodeNode> nodes = new ArrayList<>();\n-\n-    private String description;\n-    private int currentLineNumber = -1;\n-\n-    public String getDescription() {\n-        return description;\n-    }\n-\n-    public BytecodeBlock setDescription(String description) {\n-        this.description = description;\n-        return this;\n-    }\n-\n-    @Override\n-    public List<BytecodeNode> getChildNodes() {\n-        return List.copyOf(nodes);\n-    }\n-\n-    public BytecodeBlock append(BytecodeNode node) {\n-        nodes.add(node);\n-        return this;\n-    }\n-\n-    public BytecodeBlock comment(String comment) {\n-        nodes.add(new Comment(comment));\n-        return this;\n-    }\n-\n-    public BytecodeBlock comment(String comment, Object... args) {\n-        nodes.add(new Comment(String.format(comment, args)));\n-        return this;\n-    }\n-\n-    public boolean isEmpty() {\n-        return nodes.isEmpty();\n-    }\n-\n-    public BytecodeBlock visitLabel(LabelNode label) {\n-        nodes.add(label);\n-        return this;\n-    }\n-\n-    public BytecodeBlock gotoLabel(LabelNode label) {\n-        nodes.add(JumpInstruction.jump(label));\n-        return this;\n-    }\n-\n-    public BytecodeBlock ifFalseGoto(LabelNode label) {\n-        return ifZeroGoto(label);\n-    }\n-\n-    public BytecodeBlock ifTrueGoto(LabelNode label) {\n-        return ifNotZeroGoto(label);\n-    }\n-\n-    public BytecodeBlock ifZeroGoto(LabelNode label) {\n-        nodes.add(JumpInstruction.jumpIfEqualZero(label));\n-        return this;\n-    }\n-\n-    public BytecodeBlock ifNotZeroGoto(LabelNode label) {\n-        nodes.add(JumpInstruction.jumpIfNotEqualZero(label));\n-        return this;\n-    }\n-\n-    public BytecodeBlock ifNullGoto(LabelNode label) {\n-        nodes.add(JumpInstruction.jumpIfNull(label));\n-        return this;\n-    }\n-\n-    public BytecodeBlock ifNotNullGoto(LabelNode label) {\n-        nodes.add(JumpInstruction.jumpIfNotNull(label));\n-        return this;\n-    }\n-\n-    public BytecodeBlock intAdd() {\n-        nodes.add(OpCode.IADD);\n-        return this;\n-    }\n-\n-    public BytecodeBlock longAdd() {\n-        nodes.add(OpCode.LADD);\n-        return this;\n-    }\n-\n-    public BytecodeBlock longCompare() {\n-        nodes.add(OpCode.LCMP);\n-        return this;\n-    }\n-\n-    /**\n-     * Compare two doubles. If either is NaN comparison is -1.\n-     */\n-    public BytecodeBlock doubleCompareNanLess() {\n-        nodes.add(OpCode.DCMPL);\n-        return this;\n-    }\n-\n-    /**\n-     * Compare two doubles. If either is NaN comparison is 1.\n-     */\n-    public BytecodeBlock doubleCompareNanGreater() {\n-        nodes.add(OpCode.DCMPG);\n-        return this;\n-    }\n-\n-    public BytecodeBlock intLeftShift() {\n-        nodes.add(OpCode.ISHL);\n-        return this;\n-    }\n-\n-    public BytecodeBlock intRightShift() {\n-        nodes.add(OpCode.ISHR);\n-        return this;\n-    }\n-\n-    public BytecodeBlock longLeftShift() {\n-        nodes.add(OpCode.LSHL);\n-        return this;\n-    }\n-\n-    public BytecodeBlock longRightShift() {\n-        nodes.add(OpCode.LSHR);\n-        return this;\n-    }\n-\n-    public BytecodeBlock unsignedIntRightShift() {\n-        nodes.add(OpCode.IUSHR);\n-        return this;\n-    }\n-\n-    public BytecodeBlock unsignedLongRightShift() {\n-        nodes.add(OpCode.LUSHR);\n-        return this;\n-    }\n-\n-    public BytecodeBlock intBitAnd() {\n-        nodes.add(OpCode.IAND);\n-        return this;\n-    }\n-\n-    public BytecodeBlock intBitOr() {\n-        nodes.add(OpCode.IOR);\n-        return this;\n-    }\n-\n-    public BytecodeBlock intBitXor() {\n-        nodes.add(OpCode.IXOR);\n-        return this;\n-    }\n-\n-    public BytecodeBlock longBitAnd() {\n-        nodes.add(OpCode.LAND);\n-        return this;\n-    }\n-\n-    public BytecodeBlock longBitOr() {\n-        nodes.add(OpCode.LOR);\n-        return this;\n-    }\n-\n-    public BytecodeBlock longBitXor() {\n-        nodes.add(OpCode.LXOR);\n-        return this;\n-    }\n-\n-    public BytecodeBlock intNegate() {\n-        nodes.add(OpCode.INEG);\n-        return this;\n-    }\n-\n-    public BytecodeBlock intToLong() {\n-        nodes.add(OpCode.I2L);\n-        return this;\n-    }\n-\n-    public BytecodeBlock longNegate() {\n-        nodes.add(OpCode.LNEG);\n-        return this;\n-    }\n-\n-    public BytecodeBlock longToInt() {\n-        nodes.add(OpCode.L2I);\n-        return this;\n-    }\n-\n-    public BytecodeBlock isInstanceOf(Class<?> type) {\n-        nodes.add(instanceOf(type));\n-        return this;\n-    }\n-\n-    public BytecodeBlock isInstanceOf(ParameterizedType type) {\n-        nodes.add(instanceOf(type));\n-        return this;\n-    }\n-\n-    public BytecodeBlock checkCast(Class<?> type) {\n-        nodes.add(cast(type));\n-        return this;\n-    }\n-\n-    public BytecodeBlock checkCast(ParameterizedType type) {\n-        nodes.add(cast(type));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeStatic(Method method) {\n-        nodes.add(InvokeInstruction.invokeStatic(method));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeStatic(MethodDefinition method) {\n-        nodes.add(InvokeInstruction.invokeStatic(method));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeStatic(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeStatic(Class<?> type, String name, Class<?> returnType,\n-        Collection<Class<?>> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeStatic(ParameterizedType type, String name, ParameterizedType returnType,\n-        ParameterizedType... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeStatic(ParameterizedType type, String name, ParameterizedType returnType,\n-        Collection<ParameterizedType> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeVirtual(Method method) {\n-        nodes.add(InvokeInstruction.invokeVirtual(method));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeVirtual(MethodDefinition method) {\n-        nodes.add(InvokeInstruction.invokeVirtual(method));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeVirtual(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeVirtual(Class<?> type, String name, Class<?> returnType,\n-        Collection<Class<?>> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeVirtual(ParameterizedType type, String name, ParameterizedType returnType,\n-        ParameterizedType... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeVirtual(ParameterizedType type, String name, ParameterizedType returnType,\n-        Collection<ParameterizedType> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeInterface(Method method) {\n-        nodes.add(InvokeInstruction.invokeInterface(method));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeInterface(MethodDefinition method) {\n-        nodes.add(InvokeInstruction.invokeInterface(method));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeInterface(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeInterface(Class<?> type, String name, Class<?> returnType,\n-        Collection<Class<?>> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeInterface(ParameterizedType type, String name, ParameterizedType returnType,\n-        ParameterizedType... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeInterface(ParameterizedType type, String name, ParameterizedType returnType,\n-        Collection<ParameterizedType> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeConstructor(Constructor<?> constructor) {\n-        nodes.add(InvokeInstruction.invokeConstructor(constructor));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeConstructor(Class<?> type, Class<?>... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeConstructor(Class<?> type, Collection<Class<?>> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeConstructor(ParameterizedType type, ParameterizedType... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeConstructor(ParameterizedType type, Collection<ParameterizedType> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeSpecial(Method method) {\n-        nodes.add(InvokeInstruction.invokeSpecial(method));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeSpecial(MethodDefinition method) {\n-        nodes.add(InvokeInstruction.invokeSpecial(method));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeSpecial(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeSpecial(Class<?> type, String name, Class<?> returnType,\n-        Collection<Class<?>> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeSpecial(ParameterizedType type, String name, ParameterizedType returnType,\n-        ParameterizedType... parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeSpecial(ParameterizedType type, String name, ParameterizedType returnType,\n-        Collection<ParameterizedType> parameterTypes) {\n-        nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n-        return this;\n-    }\n-\n-    public BytecodeBlock invokeDynamic(String name, MethodType methodType, Method bootstrapMethod,\n-        Object... defaultBootstrapArguments) {\n-        nodes.add(InvokeInstruction.invokeDynamic(name, methodType, bootstrapMethod, defaultBootstrapArguments));\n-        return this;\n-    }\n-\n-    public BytecodeNode invokeDynamic(String name,\n-        ParameterizedType returnType,\n-        Collection<ParameterizedType> parameterTypes,\n-        Method bootstrapMethod,\n-        List<Object> bootstrapArgs) {\n-        nodes.add(InvokeInstruction.invokeDynamic(name, returnType, parameterTypes, bootstrapMethod, bootstrapArgs));\n-        return this;\n-    }\n-\n-    public BytecodeBlock ret(Class<?> type) {\n-        if (type == long.class) {\n-            retLong();\n-        }\n-        else if (type == boolean.class) {\n-            retBoolean();\n-        }\n-        else if (type == int.class || type == byte.class || type == char.class || type == short.class) {\n-            retInt();\n-        }\n-        else if (type == float.class) {\n-            retFloat();\n-        }\n-        else if (type == double.class) {\n-            retDouble();\n-        }\n-        else if (type == void.class) {\n-            ret();\n-        }\n-        else if (!type.isPrimitive()) {\n-            retObject();\n-        }\n-        else {\n-            throw new IllegalArgumentException(\"Unsupported type: \" + type.getName());\n-        }\n-\n-        return this;\n-    }\n-\n-    public BytecodeBlock ret() {\n-        nodes.add(OpCode.RETURN);\n-        return this;\n-    }\n-\n-    public BytecodeBlock retObject() {\n-        nodes.add(OpCode.ARETURN);\n-        return this;\n-    }\n-\n-    public BytecodeBlock retFloat() {\n-        nodes.add(OpCode.FRETURN);\n-        return this;\n-    }\n-\n-    public BytecodeBlock retDouble() {\n-        nodes.add(OpCode.DRETURN);\n-        return this;\n-    }\n-\n-    public BytecodeBlock retBoolean() {\n-        nodes.add(OpCode.IRETURN);\n-        return this;\n-    }\n-\n-    public BytecodeBlock retLong() {\n-        nodes.add(OpCode.LRETURN);\n-        return this;\n-    }\n-\n-    public BytecodeBlock retInt() {\n-        nodes.add(OpCode.IRETURN);\n-        return this;\n-    }\n-\n-    public BytecodeBlock throwObject() {\n-        nodes.add(OpCode.ATHROW);\n-        return this;\n-    }\n-\n-    public BytecodeBlock newObject(Class<?> type) {\n-        nodes.add(TypeInstruction.newObject(type));\n-        return this;\n-    }\n-\n-    public BytecodeBlock newObject(ParameterizedType type) {\n-        nodes.add(TypeInstruction.newObject(type));\n-        return this;\n-    }\n-\n-    public BytecodeBlock newArray(Class<?> type) {\n-        nodes.add(TypeInstruction.newObjectArray(type));\n-        return this;\n-    }\n-\n-    public BytecodeBlock dup() {\n-        nodes.add(OpCode.DUP);\n-        return this;\n-    }\n-\n-    public BytecodeBlock dup(Class<?> type) {\n-        if (type == long.class || type == double.class) {\n-            nodes.add(OpCode.DUP2);\n-        }\n-        else if (type != void.class) {\n-            nodes.add(OpCode.DUP);\n-        }\n-        return this;\n-    }\n-\n-    public BytecodeBlock pop() {\n-        nodes.add(OpCode.POP);\n-        return this;\n-    }\n-\n-    public BytecodeBlock pop(Class<?> type) {\n-        if (type == long.class || type == double.class) {\n-            nodes.add(OpCode.POP2);\n-        }\n-        else if (type != void.class) {\n-            nodes.add(OpCode.POP);\n-        }\n-        return this;\n-    }\n-\n-    public BytecodeBlock pop(ParameterizedType type) {\n-        Class<?> primitiveType = type.getPrimitiveType();\n-        if (primitiveType == long.class || primitiveType == double.class) {\n-            nodes.add(OpCode.POP2);\n-        }\n-        else if (primitiveType != void.class) {\n-            nodes.add(OpCode.POP);\n-        }\n-        return this;\n-    }\n-\n-    public BytecodeBlock swap() {\n-        nodes.add(OpCode.SWAP);\n-        return this;\n-    }\n-\n-    //\n-    // Fields (non-static)\n-    //\n-\n-    public BytecodeBlock getField(Field field) {\n-        return getField(field.getDeclaringClass(), field.getName(), field.getType());\n-    }\n-\n-    public BytecodeBlock getField(FieldDefinition field) {\n-        getField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n-        return this;\n-    }\n-\n-    public BytecodeBlock getField(Class<?> target, String fieldName, Class<?> fieldType) {\n-        getField(type(target), fieldName, type(fieldType));\n-        return this;\n-    }\n-\n-    public BytecodeBlock getField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n-        nodes.add(getFieldInstruction(target, fieldName, fieldType));\n-        return this;\n-    }\n-\n-    public BytecodeBlock putField(Field field) {\n-        return putField(field.getDeclaringClass(), field.getName(), field.getType());\n-    }\n-\n-    public BytecodeBlock putField(Class<?> target, String fieldName, Class<?> fieldType) {\n-        putField(type(target), fieldName, type(fieldType));\n-        return this;\n-    }\n-\n-    public BytecodeBlock putField(FieldDefinition field) {\n-        checkArgument(!field.getAccess().contains(STATIC), \"Field is static: %s\", field);\n-        putField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n-        return this;\n-    }\n-\n-    public BytecodeBlock putField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n-        nodes.add(putFieldInstruction(target, fieldName, fieldType));\n-        return this;\n-    }\n-\n-    //\n-    // Static fields\n-    //\n-\n-    public BytecodeBlock getStaticField(FieldDefinition field) {\n-        getStaticField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n-        return this;\n-    }\n-\n-    public BytecodeBlock getStaticField(Field field) {\n-        checkArgument(Modifier.isStatic(field.getModifiers()), \"Field is not static: %s\", field);\n-        getStaticField(type(field.getDeclaringClass()), field.getName(), type(field.getType()));\n-        return this;\n-    }\n-\n-    public BytecodeBlock getStaticField(Class<?> target, String fieldName, Class<?> fieldType) {\n-        nodes.add(getStaticInstruction(target, fieldName, fieldType));\n-        return this;\n-    }\n-\n-    public BytecodeBlock getStaticField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n-        nodes.add(getStaticInstruction(target, fieldName, fieldType));\n-        return this;\n-    }\n-\n-    public BytecodeBlock getStaticField(ParameterizedType target, FieldDefinition field) {\n-        nodes.add(getStaticInstruction(target, field.getName(), field.getType()));\n-        return this;\n-    }\n-\n-    public BytecodeBlock putStaticField(FieldDefinition field) {\n-        putStaticField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n-        return this;\n-    }\n-\n-    public BytecodeBlock putStaticField(ParameterizedType target, FieldDefinition field) {\n-        checkArgument(field.getAccess().contains(STATIC), \"Field is not static: %s\", field);\n-        putStaticField(target, field.getName(), field.getType());\n-        return this;\n-    }\n-\n-    public BytecodeBlock putStaticField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n-        nodes.add(putStaticInstruction(target, fieldName, fieldType));\n-        return this;\n-    }\n-\n-    //\n-    // Load constants\n-    //\n-\n-    public BytecodeBlock pushNull() {\n-        nodes.add(OpCode.ACONST_NULL);\n-        return this;\n-    }\n-\n-    public BytecodeBlock push(Class<?> type) {\n-        nodes.add(loadClass(type));\n-        return this;\n-    }\n-\n-    public BytecodeBlock push(ParameterizedType type) {\n-        nodes.add(loadClass(type));\n-        return this;\n-    }\n-\n-    public BytecodeBlock push(String value) {\n-        nodes.add(Constant.loadString(value));\n-        return this;\n-    }\n-\n-    public BytecodeBlock push(Number value) {\n-        nodes.add(loadNumber(value));\n-        return this;\n-    }\n-\n-    public BytecodeBlock push(int value) {\n-        nodes.add(loadInt(value));\n-        return this;\n-    }\n-\n-    public BytecodeBlock push(boolean value) {\n-        nodes.add(loadBoolean(value));\n-        return this;\n-    }\n-\n-    public BytecodeBlock pushJavaDefault(Class<?> type) {\n-        if (type == void.class) {\n-            return this;\n-        }\n-        if (type == boolean.class || type == byte.class || type == char.class || type == short.class || type == int.class) {\n-            return push(0);\n-        }\n-        if (type == long.class) {\n-            return push(0L);\n-        }\n-        if (type == float.class) {\n-            return push(0.0f);\n-        }\n-        if (type == double.class) {\n-            return push(0.0d);\n-        }\n-        return pushNull();\n-    }\n-\n-    public BytecodeBlock initializeVariable(Variable variable) {\n-        ParameterizedType type = variable.getType();\n-        if (type.getType().length() == 1) {\n-            switch (type.getType().charAt(0)) {\n-                case 'B':\n-                case 'Z':\n-                case 'S':\n-                case 'C':\n-                case 'I':\n-                    nodes.add(loadInt(0));\n-                    break;\n-                case 'F':\n-                    nodes.add(loadFloat(0));\n-                    break;\n-                case 'D':\n-                    nodes.add(loadDouble(0));\n-                    break;\n-                case 'J':\n-                    nodes.add(loadLong(0));\n-                    break;\n-                default:\n-                    checkArgument(false, \"Unknown type '%s'\", variable.getType());\n-            }\n-        }\n-        else {\n-            nodes.add(Constant.loadNull());\n-        }\n-\n-        nodes.add(storeVariable(variable));\n-\n-        return this;\n-    }\n-\n-    public BytecodeBlock getVariable(Variable variable) {\n-        nodes.add(loadVariable(variable));\n-        return this;\n-    }\n-\n-    public BytecodeBlock putVariable(Variable variable) {\n-        nodes.add(storeVariable(variable));\n-        return this;\n-    }\n-\n-    public BytecodeBlock putVariable(Variable variable, Class<?> type) {\n-        nodes.add(loadClass(type));\n-        putVariable(variable);\n-        return this;\n-    }\n-\n-    public BytecodeBlock putVariable(Variable variable, ParameterizedType type) {\n-        nodes.add(loadClass(type));\n-        putVariable(variable);\n-        return this;\n-    }\n-\n-    public BytecodeBlock putVariable(Variable variable, String value) {\n-        nodes.add(Constant.loadString(value));\n-        putVariable(variable);\n-        return this;\n-    }\n-\n-    public BytecodeBlock putVariable(Variable variable, Number value) {\n-        nodes.add(loadNumber(value));\n-        putVariable(variable);\n-        return this;\n-    }\n-\n-    public BytecodeBlock putVariable(Variable variable, int value) {\n-        nodes.add(loadInt(value));\n-        putVariable(variable);\n-        return this;\n-    }\n-\n-    public BytecodeBlock putVariable(Variable variable, boolean value) {\n-        nodes.add(loadBoolean(value));\n-        putVariable(variable);\n-        return this;\n-    }\n-\n-    public BytecodeBlock incrementVariable(Variable variable, byte increment) {\n-        String type = variable.getType().getClassName();\n-        checkArgument(List.of(\"byte\", \"short\", \"int\").contains(type), \"variable must be an byte, short or int, but is %s\", type);\n-        nodes.add(VariableInstruction.incrementVariable(variable, increment));\n-        return this;\n-    }\n-\n-    public BytecodeBlock getObjectArrayElement() {\n-        nodes.add(OpCode.AALOAD);\n-        return this;\n-    }\n-\n-    public BytecodeBlock putObjectArrayElement() {\n-        nodes.add(OpCode.AASTORE);\n-        return this;\n-    }\n-\n-    public BytecodeBlock getIntArrayElement() {\n-        nodes.add(OpCode.IALOAD);\n-        return this;\n-    }\n-\n-    public BytecodeBlock putIntArrayElement() {\n-        nodes.add(OpCode.IASTORE);\n-        return this;\n-    }\n-\n-    public BytecodeBlock visitLineNumber(int currentLineNumber) {\n-        checkArgument(currentLineNumber >= 0, \"currentLineNumber must be positive\");\n-        if (this.currentLineNumber != currentLineNumber) {\n-            nodes.add(new LineNumberNode(currentLineNumber));\n-            this.currentLineNumber = currentLineNumber;\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public void accept(MethodVisitor visitor, MethodGenerationContext generationContext) {\n-        for (BytecodeNode node : nodes) {\n-            node.accept(visitor, generationContext);\n-        }\n-    }\n-\n-    @Override\n-    public <T> T accept(BytecodeNode parent, BytecodeVisitor<T> visitor) {\n-        return visitor.visitBlock(parent, this);\n-    }\n+  private final List<BytecodeNode> nodes = new ArrayList<>();\n+\n+  private String description;\n+\n+  private int currentLineNumber = -1;\n+\n+  public String getDescription() {\n+    return description;\n+  }\n+\n+  public BytecodeBlock setDescription(String description) {\n+    this.description = description;\n+    return this;\n+  }\n+\n+  @Override\n+  public List<BytecodeNode> getChildNodes() {\n+    return List.copyOf(nodes);\n+  }\n+\n+  public BytecodeBlock append(BytecodeNode node) {\n+    nodes.add(node);\n+    return this;\n+  }\n+\n+  public BytecodeBlock comment(String comment) {\n+    nodes.add(new Comment(comment));\n+    return this;\n+  }\n+\n+  public BytecodeBlock comment(String comment, Object... args) {\n+    nodes.add(new Comment(String.format(comment, args)));\n+    return this;\n+  }\n+\n+  public boolean isEmpty() {\n+    return nodes.isEmpty();\n+  }\n+\n+  public BytecodeBlock visitLabel(LabelNode label) {\n+    nodes.add(label);\n+    return this;\n+  }\n+\n+  public BytecodeBlock gotoLabel(LabelNode label) {\n+    nodes.add(JumpInstruction.jump(label));\n+    return this;\n+  }\n+\n+  public BytecodeBlock ifFalseGoto(LabelNode label) {\n+    return ifZeroGoto(label);\n+  }\n+\n+  public BytecodeBlock ifTrueGoto(LabelNode label) {\n+    return ifNotZeroGoto(label);\n+  }\n+\n+  public BytecodeBlock ifZeroGoto(LabelNode label) {\n+    nodes.add(JumpInstruction.jumpIfEqualZero(label));\n+    return this;\n+  }\n+\n+  public BytecodeBlock ifNotZeroGoto(LabelNode label) {\n+    nodes.add(JumpInstruction.jumpIfNotEqualZero(label));\n+    return this;\n+  }\n+\n+  public BytecodeBlock ifNullGoto(LabelNode label) {\n+    nodes.add(JumpInstruction.jumpIfNull(label));\n+    return this;\n+  }\n+\n+  public BytecodeBlock ifNotNullGoto(LabelNode label) {\n+    nodes.add(JumpInstruction.jumpIfNotNull(label));\n+    return this;\n+  }\n+\n+  public BytecodeBlock intAdd() {\n+    nodes.add(OpCode.IADD);\n+    return this;\n+  }\n+\n+  public BytecodeBlock longAdd() {\n+    nodes.add(OpCode.LADD);\n+    return this;\n+  }\n+\n+  public BytecodeBlock longCompare() {\n+    nodes.add(OpCode.LCMP);\n+    return this;\n+  }\n+\n+  /**\n+   * Compare two doubles. If either is NaN comparison is -1.\n+   */\n+  public BytecodeBlock doubleCompareNanLess() {\n+    nodes.add(OpCode.DCMPL);\n+    return this;\n+  }\n+\n+  /**\n+   * Compare two doubles. If either is NaN comparison is 1.\n+   */\n+  public BytecodeBlock doubleCompareNanGreater() {\n+    nodes.add(OpCode.DCMPG);\n+    return this;\n+  }\n+\n+  public BytecodeBlock intLeftShift() {\n+    nodes.add(OpCode.ISHL);\n+    return this;\n+  }\n+\n+  public BytecodeBlock intRightShift() {\n+    nodes.add(OpCode.ISHR);\n+    return this;\n+  }\n+\n+  public BytecodeBlock longLeftShift() {\n+    nodes.add(OpCode.LSHL);\n+    return this;\n+  }\n+\n+  public BytecodeBlock longRightShift() {\n+    nodes.add(OpCode.LSHR);\n+    return this;\n+  }\n+\n+  public BytecodeBlock unsignedIntRightShift() {\n+    nodes.add(OpCode.IUSHR);\n+    return this;\n+  }\n+\n+  public BytecodeBlock unsignedLongRightShift() {\n+    nodes.add(OpCode.LUSHR);\n+    return this;\n+  }\n+\n+  public BytecodeBlock intBitAnd() {\n+    nodes.add(OpCode.IAND);\n+    return this;\n+  }\n+\n+  public BytecodeBlock intBitOr() {\n+    nodes.add(OpCode.IOR);\n+    return this;\n+  }\n+\n+  public BytecodeBlock intBitXor() {\n+    nodes.add(OpCode.IXOR);\n+    return this;\n+  }\n+\n+  public BytecodeBlock longBitAnd() {\n+    nodes.add(OpCode.LAND);\n+    return this;\n+  }\n+\n+  public BytecodeBlock longBitOr() {\n+    nodes.add(OpCode.LOR);\n+    return this;\n+  }\n+\n+  public BytecodeBlock longBitXor() {\n+    nodes.add(OpCode.LXOR);\n+    return this;\n+  }\n+\n+  public BytecodeBlock intNegate() {\n+    nodes.add(OpCode.INEG);\n+    return this;\n+  }\n+\n+  public BytecodeBlock intToLong() {\n+    nodes.add(OpCode.I2L);\n+    return this;\n+  }\n+\n+  public BytecodeBlock longNegate() {\n+    nodes.add(OpCode.LNEG);\n+    return this;\n+  }\n+\n+  public BytecodeBlock longToInt() {\n+    nodes.add(OpCode.L2I);\n+    return this;\n+  }\n+\n+  public BytecodeBlock isInstanceOf(Class<?> type) {\n+    nodes.add(instanceOf(type));\n+    return this;\n+  }\n+\n+  public BytecodeBlock isInstanceOf(ParameterizedType type) {\n+    nodes.add(instanceOf(type));\n+    return this;\n+  }\n+\n+  public BytecodeBlock checkCast(Class<?> type) {\n+    nodes.add(cast(type));\n+    return this;\n+  }\n+\n+  public BytecodeBlock checkCast(ParameterizedType type) {\n+    nodes.add(cast(type));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeStatic(Method method) {\n+    nodes.add(InvokeInstruction.invokeStatic(method));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeStatic(MethodDefinition method) {\n+    nodes.add(InvokeInstruction.invokeStatic(method));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeStatic(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeStatic(Class<?> type, String name, Class<?> returnType,\n+                                    Collection<Class<?>> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeStatic(ParameterizedType type, String name, ParameterizedType returnType,\n+                                    ParameterizedType... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeStatic(ParameterizedType type, String name, ParameterizedType returnType,\n+                                    Collection<ParameterizedType> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeVirtual(Method method) {\n+    nodes.add(InvokeInstruction.invokeVirtual(method));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeVirtual(MethodDefinition method) {\n+    nodes.add(InvokeInstruction.invokeVirtual(method));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeVirtual(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeVirtual(Class<?> type, String name, Class<?> returnType,\n+                                     Collection<Class<?>> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeVirtual(ParameterizedType type, String name, ParameterizedType returnType,\n+                                     ParameterizedType... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeVirtual(ParameterizedType type, String name, ParameterizedType returnType,\n+                                     Collection<ParameterizedType> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeInterface(Method method) {\n+    nodes.add(InvokeInstruction.invokeInterface(method));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeInterface(MethodDefinition method) {\n+    nodes.add(InvokeInstruction.invokeInterface(method));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeInterface(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeInterface(Class<?> type, String name, Class<?> returnType,\n+                                       Collection<Class<?>> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeInterface(ParameterizedType type, String name, ParameterizedType returnType,\n+                                       ParameterizedType... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeInterface(ParameterizedType type, String name, ParameterizedType returnType,\n+                                       Collection<ParameterizedType> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeConstructor(Constructor<?> constructor) {\n+    nodes.add(InvokeInstruction.invokeConstructor(constructor));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeConstructor(Class<?> type, Class<?>... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeConstructor(Class<?> type, Collection<Class<?>> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeConstructor(ParameterizedType type, ParameterizedType... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeConstructor(ParameterizedType type, Collection<ParameterizedType> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeSpecial(Method method) {\n+    nodes.add(InvokeInstruction.invokeSpecial(method));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeSpecial(MethodDefinition method) {\n+    nodes.add(InvokeInstruction.invokeSpecial(method));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeSpecial(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeSpecial(Class<?> type, String name, Class<?> returnType,\n+                                     Collection<Class<?>> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeSpecial(ParameterizedType type, String name, ParameterizedType returnType,\n+                                     ParameterizedType... parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeSpecial(ParameterizedType type, String name, ParameterizedType returnType,\n+                                     Collection<ParameterizedType> parameterTypes) {\n+    nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n+    return this;\n+  }\n+\n+  public BytecodeBlock invokeDynamic(String name, MethodType methodType, Method bootstrapMethod,\n+                                     Object... defaultBootstrapArguments) {\n+    nodes.add(InvokeInstruction.invokeDynamic(name, methodType, bootstrapMethod, defaultBootstrapArguments));\n+    return this;\n+  }\n+\n+  public BytecodeNode invokeDynamic(String name,\n+                                    ParameterizedType returnType,\n+                                    Collection<ParameterizedType> parameterTypes,\n+                                    Method bootstrapMethod,\n+                                    List<Object> bootstrapArgs) {\n+    nodes.add(InvokeInstruction.invokeDynamic(name, returnType, parameterTypes, bootstrapMethod, bootstrapArgs));\n+    return this;\n+  }\n+\n+  public BytecodeBlock ret(Class<?> type) {\n+    if (type == long.class) {\n+      retLong();\n+    } else if (type == boolean.class) {\n+      retBoolean();\n+    } else if (type == int.class || type == byte.class || type == char.class || type == short.class) {\n+      retInt();\n+    } else if (type == float.class) {\n+      retFloat();\n+    } else if (type == double.class) {\n+      retDouble();\n+    } else if (type == void.class) {\n+      ret();\n+    } else if (!type.isPrimitive()) {\n+      retObject();\n+    } else {\n+      throw new IllegalArgumentException(\"Unsupported type: \" + type.getName());\n+    }\n+\n+    return this;\n+  }\n+\n+  public BytecodeBlock ret() {\n+    nodes.add(OpCode.RETURN);\n+    return this;\n+  }\n+\n+  public BytecodeBlock retObject() {\n+    nodes.add(OpCode.ARETURN);\n+    return this;\n+  }\n+\n+  public BytecodeBlock retFloat() {\n+    nodes.add(OpCode.FRETURN);\n+    return this;\n+  }\n+\n+  public BytecodeBlock retDouble() {\n+    nodes.add(OpCode.DRETURN);\n+    return this;\n+  }\n+\n+  public BytecodeBlock retBoolean() {\n+    nodes.add(OpCode.IRETURN);\n+    return this;\n+  }\n+\n+  public BytecodeBlock retLong() {\n+    nodes.add(OpCode.LRETURN);\n+    return this;\n+  }\n+\n+  public BytecodeBlock retInt() {\n+    nodes.add(OpCode.IRETURN);\n+    return this;\n+  }\n+\n+  public BytecodeBlock throwObject() {\n+    nodes.add(OpCode.ATHROW);\n+    return this;\n+  }\n+\n+  public BytecodeBlock newObject(Class<?> type) {\n+    nodes.add(TypeInstruction.newObject(type));\n+    return this;\n+  }\n+\n+  public BytecodeBlock newObject(ParameterizedType type) {\n+    nodes.add(TypeInstruction.newObject(type));\n+    return this;\n+  }\n+\n+  public BytecodeBlock newArray(Class<?> type) {\n+    nodes.add(TypeInstruction.newObjectArray(type));\n+    return this;\n+  }\n+\n+  public BytecodeBlock dup() {\n+    nodes.add(OpCode.DUP);\n+    return this;\n+  }\n+\n+  public BytecodeBlock dup(Class<?> type) {\n+    if (type == long.class || type == double.class) {\n+      nodes.add(OpCode.DUP2);\n+    } else if (type != void.class) {\n+      nodes.add(OpCode.DUP);\n+    }\n+    return this;\n+  }\n+\n+  public BytecodeBlock pop() {\n+    nodes.add(OpCode.POP);\n+    return this;\n+  }\n+\n+  public BytecodeBlock pop(Class<?> type) {\n+    if (type == long.class || type == double.class) {\n+      nodes.add(OpCode.POP2);\n+    } else if (type != void.class) {\n+      nodes.add(OpCode.POP);\n+    }\n+    return this;\n+  }\n+\n+  public BytecodeBlock pop(ParameterizedType type) {\n+    Class<?> primitiveType = type.getPrimitiveType();\n+    if (primitiveType == long.class || primitiveType == double.class) {\n+      nodes.add(OpCode.POP2);\n+    } else if (primitiveType != void.class) {\n+      nodes.add(OpCode.POP);\n+    }\n+    return this;\n+  }\n+\n+  public BytecodeBlock swap() {\n+    nodes.add(OpCode.SWAP);\n+    return this;\n+  }\n+\n+  //\n+  // Fields (non-static)\n+  //\n+\n+  public BytecodeBlock getField(Field field) {\n+    return getField(field.getDeclaringClass(), field.getName(), field.getType());\n+  }\n+\n+  public BytecodeBlock getField(FieldDefinition field) {\n+    getField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n+    return this;\n+  }\n+\n+  public BytecodeBlock getField(Class<?> target, String fieldName, Class<?> fieldType) {\n+    getField(type(target), fieldName, type(fieldType));\n+    return this;\n+  }\n+\n+  public BytecodeBlock getField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n+    nodes.add(getFieldInstruction(target, fieldName, fieldType));\n+    return this;\n+  }\n+\n+  public BytecodeBlock putField(Field field) {\n+    return putField(field.getDeclaringClass(), field.getName(), field.getType());\n+  }\n+\n+  public BytecodeBlock putField(Class<?> target, String fieldName, Class<?> fieldType) {\n+    putField(type(target), fieldName, type(fieldType));\n+    return this;\n+  }\n+\n+  public BytecodeBlock putField(FieldDefinition field) {\n+    checkArgument(!field.getAccess().contains(STATIC), \"Field is static: %s\", field);\n+    putField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n+    return this;\n+  }\n+\n+  public BytecodeBlock putField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n+    nodes.add(putFieldInstruction(target, fieldName, fieldType));\n+    return this;\n+  }\n+\n+  //\n+  // Static fields\n+  //\n+\n+  public BytecodeBlock getStaticField(FieldDefinition field) {\n+    getStaticField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n+    return this;\n+  }\n+\n+  public BytecodeBlock getStaticField(Field field) {\n+    checkArgument(Modifier.isStatic(field.getModifiers()), \"Field is not static: %s\", field);\n+    getStaticField(type(field.getDeclaringClass()), field.getName(), type(field.getType()));\n+    return this;\n+  }\n+\n+  public BytecodeBlock getStaticField(Class<?> target, String fieldName, Class<?> fieldType) {\n+    nodes.add(getStaticInstruction(target, fieldName, fieldType));\n+    return this;\n+  }\n+\n+  public BytecodeBlock getStaticField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n+    nodes.add(getStaticInstruction(target, fieldName, fieldType));\n+    return this;\n+  }\n+\n+  public BytecodeBlock getStaticField(ParameterizedType target, FieldDefinition field) {\n+    nodes.add(getStaticInstruction(target, field.getName(), field.getType()));\n+    return this;\n+  }\n+\n+  public BytecodeBlock putStaticField(FieldDefinition field) {\n+    putStaticField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n+    return this;\n+  }\n+\n+  public BytecodeBlock putStaticField(ParameterizedType target, FieldDefinition field) {\n+    checkArgument(field.getAccess().contains(STATIC), \"Field is not static: %s\", field);\n+    putStaticField(target, field.getName(), field.getType());\n+    return this;\n+  }\n+\n+  public BytecodeBlock putStaticField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n+    nodes.add(putStaticInstruction(target, fieldName, fieldType));\n+    return this;\n+  }\n+\n+  //\n+  // Load constants\n+  //\n+\n+  public BytecodeBlock pushNull() {\n+    nodes.add(OpCode.ACONST_NULL);\n+    return this;\n+  }\n+\n+  public BytecodeBlock push(Class<?> type) {\n+    nodes.add(loadClass(type));\n+    return this;\n+  }\n+\n+  public BytecodeBlock push(ParameterizedType type) {\n+    nodes.add(loadClass(type));\n+    return this;\n+  }\n+\n+  public BytecodeBlock push(String value) {\n+    nodes.add(Constant.loadString(value));\n+    return this;\n+  }\n+\n+  public BytecodeBlock push(Number value) {\n+    nodes.add(loadNumber(value));\n+    return this;\n+  }\n+\n+  public BytecodeBlock push(int value) {\n+    nodes.add(loadInt(value));\n+    return this;\n+  }\n+\n+  public BytecodeBlock push(boolean value) {\n+    nodes.add(loadBoolean(value));\n+    return this;\n+  }\n+\n+  public BytecodeBlock pushJavaDefault(Class<?> type) {\n+    if (type == void.class) {\n+      return this;\n+    }\n+    if (type == boolean.class || type == byte.class || type == char.class || type == short.class || type == int.class) {\n+      return push(0);\n+    }\n+    if (type == long.class) {\n+      return push(0L);\n+    }\n+    if (type == float.class) {\n+      return push(0.0f);\n+    }\n+    if (type == double.class) {\n+      return push(0.0d);\n+    }\n+    return pushNull();\n+  }\n+\n+  public BytecodeBlock initializeVariable(Variable variable) {\n+    ParameterizedType type = variable.getType();\n+    if (type.getType().length() == 1) {\n+      switch (type.getType().charAt(0)) {\n+        case 'B':\n+        case 'Z':\n+        case 'S':\n+        case 'C':\n+        case 'I':\n+          nodes.add(loadInt(0));\n+          break;\n+        case 'F':\n+          nodes.add(loadFloat(0));\n+          break;\n+        case 'D':\n+          nodes.add(loadDouble(0));\n+          break;\n+        case 'J':\n+          nodes.add(loadLong(0));\n+          break;\n+        default:\n+          checkArgument(false, \"Unknown type '%s'\", variable.getType());\n+      }\n+    } else {\n+      nodes.add(Constant.loadNull());\n+    }\n+\n+    nodes.add(storeVariable(variable));\n+\n+    return this;\n+  }\n+\n+  public BytecodeBlock getVariable(Variable variable) {\n+    nodes.add(loadVariable(variable));\n+    return this;\n+  }\n+\n+  public BytecodeBlock putVariable(Variable variable) {\n+    nodes.add(storeVariable(variable));\n+    return this;\n+  }\n+\n+  public BytecodeBlock putVariable(Variable variable, Class<?> type) {\n+    nodes.add(loadClass(type));\n+    putVariable(variable);\n+    return this;\n+  }\n+\n+  public BytecodeBlock putVariable(Variable variable, ParameterizedType type) {\n+    nodes.add(loadClass(type));\n+    putVariable(variable);\n+    return this;\n+  }\n+\n+  public BytecodeBlock putVariable(Variable variable, String value) {\n+    nodes.add(Constant.loadString(value));\n+    putVariable(variable);\n+    return this;\n+  }\n+\n+  public BytecodeBlock putVariable(Variable variable, Number value) {\n+    nodes.add(loadNumber(value));\n+    putVariable(variable);\n+    return this;\n+  }\n+\n+  public BytecodeBlock putVariable(Variable variable, int value) {\n+    nodes.add(loadInt(value));\n+    putVariable(variable);\n+    return this;\n+  }\n+\n+  public BytecodeBlock putVariable(Variable variable, boolean value) {\n+    nodes.add(loadBoolean(value));\n+    putVariable(variable);\n+    return this;\n+  }\n+\n+  public BytecodeBlock incrementVariable(Variable variable, byte increment) {\n+    String type = variable.getType().getClassName();\n+    checkArgument(List.of(\"byte\", \"short\", \"int\").contains(type), \"variable must be an byte, short or int, but is %s\",\n+        type);\n+    nodes.add(VariableInstruction.incrementVariable(variable, increment));\n+    return this;\n+  }\n+\n+  public BytecodeBlock getObjectArrayElement() {\n+    nodes.add(OpCode.AALOAD);\n+    return this;\n+  }\n+\n+  public BytecodeBlock putObjectArrayElement() {\n+    nodes.add(OpCode.AASTORE);\n+    return this;\n+  }\n+\n+  public BytecodeBlock getIntArrayElement() {\n+    nodes.add(OpCode.IALOAD);\n+    return this;\n+  }\n+\n+  public BytecodeBlock putIntArrayElement() {\n+    nodes.add(OpCode.IASTORE);\n+    return this;\n+  }\n+\n+  public BytecodeBlock visitLineNumber(int currentLineNumber) {\n+    checkArgument(currentLineNumber >= 0, \"currentLineNumber must be positive\");\n+    if (this.currentLineNumber != currentLineNumber) {\n+      nodes.add(new LineNumberNode(currentLineNumber));\n+      this.currentLineNumber = currentLineNumber;\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public void accept(MethodVisitor visitor, MethodGenerationContext generationContext) {\n+    for (BytecodeNode node : nodes) {\n+      node.accept(visitor, generationContext);\n+    }\n+  }\n+\n+  @Override\n+  public <T> T accept(BytecodeNode parent, BytecodeVisitor<T> visitor) {\n+    return visitor.visitBlock(parent, this);\n+  }\n }\n",
            "diff_size": 783
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "58",
                    "column": "5",
                    "severity": "error",
                    "message": "'VARIABLE_DEF' should be separated from previous line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/naturalize/72/BytecodeBlock.java\nindex 06d2b5bbc60..e53e9041623 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/naturalize/72/BytecodeBlock.java\n@@ -834,4 +834,4 @@ public class BytecodeBlock\n     public <T> T accept(BytecodeNode parent, BytecodeVisitor<T> visitor) {\n         return visitor.visitBlock(parent, this);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "53",
                    "column": "1",
                    "severity": "error",
                    "message": "'CLASS_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "59",
                    "column": "5",
                    "severity": "error",
                    "message": "'VARIABLE_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "62",
                    "column": "5",
                    "severity": "error",
                    "message": "'VARIABLE_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "65",
                    "column": "5",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "76",
                    "column": "5",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "1000",
                    "column": "5",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                },
                {
                    "line": "1007",
                    "column": "5",
                    "severity": "error",
                    "message": "'METHOD_DEF' has more than 1 empty lines before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyLineSeparatorCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/codebuff/72/BytecodeBlock.java\nindex 06d2b5bbc60..c526f2f3aac 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/codebuff/72/BytecodeBlock.java\n@@ -49,40 +49,49 @@ import static com.facebook.presto.bytecode.instruction.TypeInstruction.instanceO\n import static com.facebook.presto.bytecode.instruction.VariableInstruction.loadVariable;\n import static com.facebook.presto.bytecode.instruction.VariableInstruction.storeVariable;\n \n+\n @SuppressWarnings(\"UnusedDeclaration\")\n-public class BytecodeBlock\n-    implements BytecodeNode {\n+public class BytecodeBlock implements BytecodeNode {\n+\n     private final List<BytecodeNode> nodes = new ArrayList<>();\n \n+\n     private String description;\n+\n+\n     private int currentLineNumber = -1;\n \n+\n     public String getDescription() {\n         return description;\n     }\n \n     public BytecodeBlock setDescription(String description) {\n         this.description = description;\n+\n         return this;\n     }\n \n-    @Override\n-    public List<BytecodeNode> getChildNodes() {\n+\n+    @Override public List<BytecodeNode> getChildNodes() {\n         return List.copyOf(nodes);\n     }\n \n     public BytecodeBlock append(BytecodeNode node) {\n         nodes.add(node);\n+\n         return this;\n     }\n \n     public BytecodeBlock comment(String comment) {\n         nodes.add(new Comment(comment));\n+\n         return this;\n     }\n \n     public BytecodeBlock comment(String comment, Object... args) {\n         nodes.add(new Comment(String.format(comment, args)));\n+\n         return this;\n     }\n \n@@ -92,11 +101,13 @@ public class BytecodeBlock\n \n     public BytecodeBlock visitLabel(LabelNode label) {\n         nodes.add(label);\n+\n         return this;\n     }\n \n     public BytecodeBlock gotoLabel(LabelNode label) {\n         nodes.add(JumpInstruction.jump(label));\n+\n         return this;\n     }\n \n@@ -110,324 +121,410 @@ public class BytecodeBlock\n \n     public BytecodeBlock ifZeroGoto(LabelNode label) {\n         nodes.add(JumpInstruction.jumpIfEqualZero(label));\n+\n         return this;\n     }\n \n     public BytecodeBlock ifNotZeroGoto(LabelNode label) {\n         nodes.add(JumpInstruction.jumpIfNotEqualZero(label));\n+\n         return this;\n     }\n \n     public BytecodeBlock ifNullGoto(LabelNode label) {\n         nodes.add(JumpInstruction.jumpIfNull(label));\n+\n         return this;\n     }\n \n     public BytecodeBlock ifNotNullGoto(LabelNode label) {\n         nodes.add(JumpInstruction.jumpIfNotNull(label));\n+\n         return this;\n     }\n \n     public BytecodeBlock intAdd() {\n         nodes.add(OpCode.IADD);\n+\n         return this;\n     }\n \n     public BytecodeBlock longAdd() {\n         nodes.add(OpCode.LADD);\n+\n         return this;\n     }\n \n     public BytecodeBlock longCompare() {\n         nodes.add(OpCode.LCMP);\n+\n         return this;\n     }\n \n     /**\n      * Compare two doubles. If either is NaN comparison is -1.\n      */\n+\n     public BytecodeBlock doubleCompareNanLess() {\n         nodes.add(OpCode.DCMPL);\n+\n         return this;\n     }\n \n     /**\n      * Compare two doubles. If either is NaN comparison is 1.\n      */\n+\n     public BytecodeBlock doubleCompareNanGreater() {\n         nodes.add(OpCode.DCMPG);\n+\n         return this;\n     }\n \n     public BytecodeBlock intLeftShift() {\n         nodes.add(OpCode.ISHL);\n+\n         return this;\n     }\n \n     public BytecodeBlock intRightShift() {\n         nodes.add(OpCode.ISHR);\n+\n         return this;\n     }\n \n     public BytecodeBlock longLeftShift() {\n         nodes.add(OpCode.LSHL);\n+\n         return this;\n     }\n \n     public BytecodeBlock longRightShift() {\n         nodes.add(OpCode.LSHR);\n+\n         return this;\n     }\n \n     public BytecodeBlock unsignedIntRightShift() {\n         nodes.add(OpCode.IUSHR);\n+\n         return this;\n     }\n \n     public BytecodeBlock unsignedLongRightShift() {\n         nodes.add(OpCode.LUSHR);\n+\n         return this;\n     }\n \n     public BytecodeBlock intBitAnd() {\n         nodes.add(OpCode.IAND);\n+\n         return this;\n     }\n \n     public BytecodeBlock intBitOr() {\n         nodes.add(OpCode.IOR);\n+\n         return this;\n     }\n \n     public BytecodeBlock intBitXor() {\n         nodes.add(OpCode.IXOR);\n+\n         return this;\n     }\n \n     public BytecodeBlock longBitAnd() {\n         nodes.add(OpCode.LAND);\n+\n         return this;\n     }\n \n     public BytecodeBlock longBitOr() {\n         nodes.add(OpCode.LOR);\n+\n         return this;\n     }\n \n     public BytecodeBlock longBitXor() {\n         nodes.add(OpCode.LXOR);\n+\n         return this;\n     }\n \n     public BytecodeBlock intNegate() {\n         nodes.add(OpCode.INEG);\n+\n         return this;\n     }\n \n     public BytecodeBlock intToLong() {\n         nodes.add(OpCode.I2L);\n+\n         return this;\n     }\n \n     public BytecodeBlock longNegate() {\n         nodes.add(OpCode.LNEG);\n+\n         return this;\n     }\n \n     public BytecodeBlock longToInt() {\n         nodes.add(OpCode.L2I);\n+\n         return this;\n     }\n \n     public BytecodeBlock isInstanceOf(Class<?> type) {\n         nodes.add(instanceOf(type));\n+\n         return this;\n     }\n \n     public BytecodeBlock isInstanceOf(ParameterizedType type) {\n         nodes.add(instanceOf(type));\n+\n         return this;\n     }\n \n     public BytecodeBlock checkCast(Class<?> type) {\n         nodes.add(cast(type));\n+\n         return this;\n     }\n \n     public BytecodeBlock checkCast(ParameterizedType type) {\n         nodes.add(cast(type));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeStatic(Method method) {\n         nodes.add(InvokeInstruction.invokeStatic(method));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeStatic(MethodDefinition method) {\n         nodes.add(InvokeInstruction.invokeStatic(method));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeStatic(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n         nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeStatic(Class<?> type, String name, Class<?> returnType,\n-        Collection<Class<?>> parameterTypes) {\n+    public BytecodeBlock invokeStatic(Class<?> type, String name, Class<?> returnType, Collection<Class<?>> parameterTypes) {\n         nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeStatic(ParameterizedType type, String name, ParameterizedType returnType,\n-        ParameterizedType... parameterTypes) {\n+    public BytecodeBlock invokeStatic(\n+        ParameterizedType type,\n+        String name,\n+        ParameterizedType returnType, ParameterizedType... parameterTypes\n+    ) {\n         nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeStatic(ParameterizedType type, String name, ParameterizedType returnType,\n-        Collection<ParameterizedType> parameterTypes) {\n+    public BytecodeBlock invokeStatic(\n+        ParameterizedType type,\n+        String name,\n+        ParameterizedType returnType, Collection<ParameterizedType> parameterTypes\n+    ) {\n         nodes.add(InvokeInstruction.invokeStatic(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeVirtual(Method method) {\n         nodes.add(InvokeInstruction.invokeVirtual(method));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeVirtual(MethodDefinition method) {\n         nodes.add(InvokeInstruction.invokeVirtual(method));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeVirtual(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n         nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeVirtual(Class<?> type, String name, Class<?> returnType,\n-        Collection<Class<?>> parameterTypes) {\n+    public BytecodeBlock invokeVirtual(Class<?> type, String name, Class<?> returnType, Collection<Class<?>> parameterTypes) {\n         nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeVirtual(ParameterizedType type, String name, ParameterizedType returnType,\n-        ParameterizedType... parameterTypes) {\n+    public BytecodeBlock invokeVirtual(\n+        ParameterizedType type,\n+        String name,\n+        ParameterizedType returnType, ParameterizedType... parameterTypes\n+    ) {\n         nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeVirtual(ParameterizedType type, String name, ParameterizedType returnType,\n-        Collection<ParameterizedType> parameterTypes) {\n+    public BytecodeBlock invokeVirtual(\n+        ParameterizedType type,\n+        String name,\n+        ParameterizedType returnType, Collection<ParameterizedType> parameterTypes\n+    ) {\n         nodes.add(InvokeInstruction.invokeVirtual(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeInterface(Method method) {\n         nodes.add(InvokeInstruction.invokeInterface(method));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeInterface(MethodDefinition method) {\n         nodes.add(InvokeInstruction.invokeInterface(method));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeInterface(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n         nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeInterface(Class<?> type, String name, Class<?> returnType,\n-        Collection<Class<?>> parameterTypes) {\n+    public BytecodeBlock invokeInterface(Class<?> type, String name, Class<?> returnType, Collection<Class<?>> parameterTypes) {\n         nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeInterface(ParameterizedType type, String name, ParameterizedType returnType,\n-        ParameterizedType... parameterTypes) {\n+    public BytecodeBlock invokeInterface(\n+        ParameterizedType type,\n+        String name,\n+        ParameterizedType returnType, ParameterizedType... parameterTypes\n+    ) {\n         nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeInterface(ParameterizedType type, String name, ParameterizedType returnType,\n-        Collection<ParameterizedType> parameterTypes) {\n+    public BytecodeBlock invokeInterface(\n+        ParameterizedType type,\n+        String name,\n+        ParameterizedType returnType, Collection<ParameterizedType> parameterTypes\n+    ) {\n         nodes.add(InvokeInstruction.invokeInterface(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeConstructor(Constructor<?> constructor) {\n         nodes.add(InvokeInstruction.invokeConstructor(constructor));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeConstructor(Class<?> type, Class<?>... parameterTypes) {\n         nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeConstructor(Class<?> type, Collection<Class<?>> parameterTypes) {\n         nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeConstructor(ParameterizedType type, ParameterizedType... parameterTypes) {\n         nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeConstructor(ParameterizedType type, Collection<ParameterizedType> parameterTypes) {\n         nodes.add(InvokeInstruction.invokeConstructor(type, parameterTypes));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeSpecial(Method method) {\n         nodes.add(InvokeInstruction.invokeSpecial(method));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeSpecial(MethodDefinition method) {\n         nodes.add(InvokeInstruction.invokeSpecial(method));\n+\n         return this;\n     }\n \n     public BytecodeBlock invokeSpecial(Class<?> type, String name, Class<?> returnType, Class<?>... parameterTypes) {\n         nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeSpecial(Class<?> type, String name, Class<?> returnType,\n-        Collection<Class<?>> parameterTypes) {\n+    public BytecodeBlock invokeSpecial(Class<?> type, String name, Class<?> returnType, Collection<Class<?>> parameterTypes) {\n         nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeSpecial(ParameterizedType type, String name, ParameterizedType returnType,\n-        ParameterizedType... parameterTypes) {\n+    public BytecodeBlock invokeSpecial(\n+        ParameterizedType type,\n+        String name,\n+        ParameterizedType returnType, ParameterizedType... parameterTypes\n+    ) {\n         nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeSpecial(ParameterizedType type, String name, ParameterizedType returnType,\n-        Collection<ParameterizedType> parameterTypes) {\n+    public BytecodeBlock invokeSpecial(\n+        ParameterizedType type,\n+        String name,\n+        ParameterizedType returnType, Collection<ParameterizedType> parameterTypes\n+    ) {\n         nodes.add(InvokeInstruction.invokeSpecial(type, name, returnType, parameterTypes));\n+\n         return this;\n     }\n \n-    public BytecodeBlock invokeDynamic(String name, MethodType methodType, Method bootstrapMethod,\n-        Object... defaultBootstrapArguments) {\n+    public BytecodeBlock invokeDynamic(\n+        String name,\n+        MethodType methodType,\n+        Method bootstrapMethod, Object... defaultBootstrapArguments\n+    ) {\n         nodes.add(InvokeInstruction.invokeDynamic(name, methodType, bootstrapMethod, defaultBootstrapArguments));\n+\n         return this;\n     }\n \n-    public BytecodeNode invokeDynamic(String name,\n+    public BytecodeNode invokeDynamic(\n+        String name,\n         ParameterizedType returnType,\n         Collection<ParameterizedType> parameterTypes,\n-        Method bootstrapMethod,\n-        List<Object> bootstrapArgs) {\n+        Method bootstrapMethod, List<Object> bootstrapArgs\n+    ) {\n         nodes.add(InvokeInstruction.invokeDynamic(name, returnType, parameterTypes, bootstrapMethod, bootstrapArgs));\n+\n         return this;\n     }\n \n@@ -439,20 +536,20 @@ public class BytecodeBlock\n             retBoolean();\n         }\n         else if (type == int.class || type == byte.class || type == char.class || type == short.class) {\n-            retInt();\n-        }\n+                 retInt();\n+             }\n         else if (type == float.class) {\n-            retFloat();\n-        }\n+                 retFloat();\n+             }\n         else if (type == double.class) {\n-            retDouble();\n-        }\n+                 retDouble();\n+             }\n         else if (type == void.class) {\n-            ret();\n-        }\n+                 ret();\n+             }\n         else if (!type.isPrimitive()) {\n-            retObject();\n-        }\n+                 retObject();\n+             }\n         else {\n             throw new IllegalArgumentException(\"Unsupported type: \" + type.getName());\n         }\n@@ -462,61 +559,73 @@ public class BytecodeBlock\n \n     public BytecodeBlock ret() {\n         nodes.add(OpCode.RETURN);\n+\n         return this;\n     }\n \n     public BytecodeBlock retObject() {\n         nodes.add(OpCode.ARETURN);\n+\n         return this;\n     }\n \n     public BytecodeBlock retFloat() {\n         nodes.add(OpCode.FRETURN);\n+\n         return this;\n     }\n \n     public BytecodeBlock retDouble() {\n         nodes.add(OpCode.DRETURN);\n+\n         return this;\n     }\n \n     public BytecodeBlock retBoolean() {\n         nodes.add(OpCode.IRETURN);\n+\n         return this;\n     }\n \n     public BytecodeBlock retLong() {\n         nodes.add(OpCode.LRETURN);\n+\n         return this;\n     }\n \n     public BytecodeBlock retInt() {\n         nodes.add(OpCode.IRETURN);\n+\n         return this;\n     }\n \n     public BytecodeBlock throwObject() {\n         nodes.add(OpCode.ATHROW);\n+\n         return this;\n     }\n \n     public BytecodeBlock newObject(Class<?> type) {\n         nodes.add(TypeInstruction.newObject(type));\n+\n         return this;\n     }\n \n     public BytecodeBlock newObject(ParameterizedType type) {\n         nodes.add(TypeInstruction.newObject(type));\n+\n         return this;\n     }\n \n     public BytecodeBlock newArray(Class<?> type) {\n         nodes.add(TypeInstruction.newObjectArray(type));\n+\n         return this;\n     }\n \n     public BytecodeBlock dup() {\n         nodes.add(OpCode.DUP);\n+\n         return this;\n     }\n \n@@ -525,13 +634,15 @@ public class BytecodeBlock\n             nodes.add(OpCode.DUP2);\n         }\n         else if (type != void.class) {\n-            nodes.add(OpCode.DUP);\n-        }\n+                 nodes.add(OpCode.DUP);\n+             }\n+\n         return this;\n     }\n \n     public BytecodeBlock pop() {\n         nodes.add(OpCode.POP);\n+\n         return this;\n     }\n \n@@ -540,24 +651,28 @@ public class BytecodeBlock\n             nodes.add(OpCode.POP2);\n         }\n         else if (type != void.class) {\n-            nodes.add(OpCode.POP);\n-        }\n+                 nodes.add(OpCode.POP);\n+             }\n+\n         return this;\n     }\n \n     public BytecodeBlock pop(ParameterizedType type) {\n         Class<?> primitiveType = type.getPrimitiveType();\n+\n         if (primitiveType == long.class || primitiveType == double.class) {\n             nodes.add(OpCode.POP2);\n         }\n         else if (primitiveType != void.class) {\n-            nodes.add(OpCode.POP);\n-        }\n+                 nodes.add(OpCode.POP);\n+             }\n+\n         return this;\n     }\n \n     public BytecodeBlock swap() {\n         nodes.add(OpCode.SWAP);\n+\n         return this;\n     }\n \n@@ -571,16 +686,19 @@ public class BytecodeBlock\n \n     public BytecodeBlock getField(FieldDefinition field) {\n         getField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n+\n         return this;\n     }\n \n     public BytecodeBlock getField(Class<?> target, String fieldName, Class<?> fieldType) {\n         getField(type(target), fieldName, type(fieldType));\n+\n         return this;\n     }\n \n     public BytecodeBlock getField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n         nodes.add(getFieldInstruction(target, fieldName, fieldType));\n+\n         return this;\n     }\n \n@@ -590,17 +708,21 @@ public class BytecodeBlock\n \n     public BytecodeBlock putField(Class<?> target, String fieldName, Class<?> fieldType) {\n         putField(type(target), fieldName, type(fieldType));\n+\n         return this;\n     }\n \n     public BytecodeBlock putField(FieldDefinition field) {\n         checkArgument(!field.getAccess().contains(STATIC), \"Field is static: %s\", field);\n+\n         putField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n+\n         return this;\n     }\n \n     public BytecodeBlock putField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n         nodes.add(putFieldInstruction(target, fieldName, fieldType));\n+\n         return this;\n     }\n \n@@ -610,43 +732,53 @@ public class BytecodeBlock\n \n     public BytecodeBlock getStaticField(FieldDefinition field) {\n         getStaticField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n+\n         return this;\n     }\n \n     public BytecodeBlock getStaticField(Field field) {\n         checkArgument(Modifier.isStatic(field.getModifiers()), \"Field is not static: %s\", field);\n+\n         getStaticField(type(field.getDeclaringClass()), field.getName(), type(field.getType()));\n+\n         return this;\n     }\n \n     public BytecodeBlock getStaticField(Class<?> target, String fieldName, Class<?> fieldType) {\n         nodes.add(getStaticInstruction(target, fieldName, fieldType));\n+\n         return this;\n     }\n \n     public BytecodeBlock getStaticField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n         nodes.add(getStaticInstruction(target, fieldName, fieldType));\n+\n         return this;\n     }\n \n     public BytecodeBlock getStaticField(ParameterizedType target, FieldDefinition field) {\n         nodes.add(getStaticInstruction(target, field.getName(), field.getType()));\n+\n         return this;\n     }\n \n     public BytecodeBlock putStaticField(FieldDefinition field) {\n         putStaticField(field.getDeclaringClass().getType(), field.getName(), field.getType());\n+\n         return this;\n     }\n \n     public BytecodeBlock putStaticField(ParameterizedType target, FieldDefinition field) {\n         checkArgument(field.getAccess().contains(STATIC), \"Field is not static: %s\", field);\n+\n         putStaticField(target, field.getName(), field.getType());\n+\n         return this;\n     }\n \n     public BytecodeBlock putStaticField(ParameterizedType target, String fieldName, ParameterizedType fieldType) {\n         nodes.add(putStaticInstruction(target, fieldName, fieldType));\n+\n         return this;\n     }\n \n@@ -656,36 +788,43 @@ public class BytecodeBlock\n \n     public BytecodeBlock pushNull() {\n         nodes.add(OpCode.ACONST_NULL);\n+\n         return this;\n     }\n \n     public BytecodeBlock push(Class<?> type) {\n         nodes.add(loadClass(type));\n+\n         return this;\n     }\n \n     public BytecodeBlock push(ParameterizedType type) {\n         nodes.add(loadClass(type));\n+\n         return this;\n     }\n \n     public BytecodeBlock push(String value) {\n         nodes.add(Constant.loadString(value));\n+\n         return this;\n     }\n \n     public BytecodeBlock push(Number value) {\n         nodes.add(loadNumber(value));\n+\n         return this;\n     }\n \n     public BytecodeBlock push(int value) {\n         nodes.add(loadInt(value));\n+\n         return this;\n     }\n \n     public BytecodeBlock push(boolean value) {\n         nodes.add(loadBoolean(value));\n+\n         return this;\n     }\n \n@@ -705,11 +844,13 @@ public class BytecodeBlock\n         if (type == double.class) {\n             return push(0.0d);\n         }\n+\n         return pushNull();\n     }\n \n     public BytecodeBlock initializeVariable(Variable variable) {\n         ParameterizedType type = variable.getType();\n+\n         if (type.getType().length() == 1) {\n             switch (type.getType().charAt(0)) {\n                 case 'B':\n@@ -718,16 +859,21 @@ public class BytecodeBlock\n                 case 'C':\n                 case 'I':\n                     nodes.add(loadInt(0));\n+\n                     break;\n                 case 'F':\n                     nodes.add(loadFloat(0));\n+\n                     break;\n                 case 'D':\n                     nodes.add(loadDouble(0));\n+\n                     break;\n                 case 'J':\n                     nodes.add(loadLong(0));\n+\n                     break;\n+\n                 default:\n                     checkArgument(false, \"Unknown type '%s'\", variable.getType());\n             }\n@@ -743,95 +889,122 @@ public class BytecodeBlock\n \n     public BytecodeBlock getVariable(Variable variable) {\n         nodes.add(loadVariable(variable));\n+\n         return this;\n     }\n \n     public BytecodeBlock putVariable(Variable variable) {\n         nodes.add(storeVariable(variable));\n+\n         return this;\n     }\n \n     public BytecodeBlock putVariable(Variable variable, Class<?> type) {\n         nodes.add(loadClass(type));\n+\n         putVariable(variable);\n+\n         return this;\n     }\n \n     public BytecodeBlock putVariable(Variable variable, ParameterizedType type) {\n         nodes.add(loadClass(type));\n+\n         putVariable(variable);\n+\n         return this;\n     }\n \n     public BytecodeBlock putVariable(Variable variable, String value) {\n         nodes.add(Constant.loadString(value));\n+\n         putVariable(variable);\n+\n         return this;\n     }\n \n     public BytecodeBlock putVariable(Variable variable, Number value) {\n         nodes.add(loadNumber(value));\n+\n         putVariable(variable);\n+\n         return this;\n     }\n \n     public BytecodeBlock putVariable(Variable variable, int value) {\n         nodes.add(loadInt(value));\n+\n         putVariable(variable);\n+\n         return this;\n     }\n \n     public BytecodeBlock putVariable(Variable variable, boolean value) {\n         nodes.add(loadBoolean(value));\n+\n         putVariable(variable);\n+\n         return this;\n     }\n \n     public BytecodeBlock incrementVariable(Variable variable, byte increment) {\n         String type = variable.getType().getClassName();\n-        checkArgument(List.of(\"byte\", \"short\", \"int\").contains(type), \"variable must be an byte, short or int, but is %s\", type);\n+\n+        checkArgument(\n+            List.of(\"byte\", \"short\", \"int\").contains(type),\n+            \"variable must be an byte, short or int, but is %s\",\n+            type\n+        );\n+\n         nodes.add(VariableInstruction.incrementVariable(variable, increment));\n+\n         return this;\n     }\n \n     public BytecodeBlock getObjectArrayElement() {\n         nodes.add(OpCode.AALOAD);\n+\n         return this;\n     }\n \n     public BytecodeBlock putObjectArrayElement() {\n         nodes.add(OpCode.AASTORE);\n+\n         return this;\n     }\n \n     public BytecodeBlock getIntArrayElement() {\n         nodes.add(OpCode.IALOAD);\n+\n         return this;\n     }\n \n     public BytecodeBlock putIntArrayElement() {\n         nodes.add(OpCode.IASTORE);\n+\n         return this;\n     }\n \n     public BytecodeBlock visitLineNumber(int currentLineNumber) {\n         checkArgument(currentLineNumber >= 0, \"currentLineNumber must be positive\");\n+\n         if (this.currentLineNumber != currentLineNumber) {\n             nodes.add(new LineNumberNode(currentLineNumber));\n             this.currentLineNumber = currentLineNumber;\n         }\n+\n         return this;\n     }\n \n-    @Override\n-    public void accept(MethodVisitor visitor, MethodGenerationContext generationContext) {\n+\n+    @Override public void accept(MethodVisitor visitor, MethodGenerationContext generationContext) {\n         for (BytecodeNode node : nodes) {\n             node.accept(visitor, generationContext);\n         }\n     }\n \n-    @Override\n-    public <T> T accept(BytecodeNode parent, BytecodeVisitor<T> visitor) {\n+\n+    @Override public <T> T accept(BytecodeNode parent, BytecodeVisitor<T> visitor) {\n         return visitor.visitBlock(parent, this);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 232
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_random/72/BytecodeBlock.java\nindex 06d2b5bbc60..1ca3c4efd68 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_random/72/BytecodeBlock.java\n@@ -55,6 +55,7 @@ public class BytecodeBlock\n     private final List<BytecodeNode> nodes = new ArrayList<>();\n \n     private String description;\n+\n     private int currentLineNumber = -1;\n \n     public String getDescription() {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_three_grams/72/BytecodeBlock.java\nindex 06d2b5bbc60..1ca3c4efd68 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/errored/1/72/BytecodeBlock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-ignite-3/styler_three_grams/72/BytecodeBlock.java\n@@ -55,6 +55,7 @@ public class BytecodeBlock\n     private final List<BytecodeNode> nodes = new ArrayList<>();\n \n     private String description;\n+\n     private int currentLineNumber = -1;\n \n     public String getDescription() {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}