{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "74",
    "information": {
        "errors": [
            {
                "line": "14",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import org.apache.accumulo.core.data.Range;\nimport org.apache.accumulo.core.data.Value;\nimport org.apache.accumulo.core.file.FileSKVIterator;\nimport org.apache.hadoop.mapreduce.InputSplit;\nimport org.apache.hadoop.mapreduce.TaskAttemptContext;\nimport org.apache.log4j.Logger;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/74/RangeRecordReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/74/RangeRecordReader.java\nindex 9fde6fa1b4b..fbb5df530b8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/74/RangeRecordReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/74/RangeRecordReader.java\n@@ -21,149 +21,150 @@ import java.util.Collection;\n import java.util.List;\n \n public class RangeRecordReader extends RFileRecordReader {\n-    \n-    public static final String ITER_CLASSES = \"range.record.reader.iterz\";\n-    \n-    protected Collection<FileSKVIterator> fileIterators = null;\n-    \n-    private boolean readFirstKeyValue = false;\n-    \n-    protected Key startKey = null;\n-    \n-    protected Key endKey = null;\n-    \n-    protected RecordIterator splitReference = null;\n-    \n-    private static final Logger log = Logger.getLogger(RangeRecordReader.class);\n-    \n-    protected static final String PREFIX = BulkInputFormat.class.getSimpleName();\n-    protected static final String ITERATORS = PREFIX + \".iterators\";\n-    protected static final String ITERATORS_OPTIONS = PREFIX + \".iterators.options\";\n-    protected static final String ITERATORS_DELIM = \",\";\n-    \n-    @Override\n-    public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException {\n-        \n-        final long failureSleep = context.getConfiguration().getLong(RecordIterator.RECORDITER_FAILURE_SLEEP_INTERVAL, RecordIterator.DEFAULT_FAILURE_SLEEP);\n-        int retries = 0;\n-        int maxRetries = context.getConfiguration().getInt(RecordIterator.RECORDITER_FAILURE_COUNT_MAX, RecordIterator.FAILURE_MAX_DEFAULT);\n-        TabletSplitSplit tabletSplit = (TabletSplitSplit) split;\n-        do {\n-            try {\n-                splitReference = new RecordIterator(tabletSplit, context.getConfiguration());\n-            } catch (RuntimeException e) {\n-                \n-                log.info(e);\n-                \n-                splitReference = null;\n-                // an exception has occurred that won't allow us to open the files. perhaps one was moved\n-                // immediately upon opening the tablet.\n-                if (++retries > maxRetries) {\n-                    log.info(\"Giving up because\" + retries + \" >= \" + maxRetries);\n-                    throw e;\n-                } else if (log.isTraceEnabled()) {\n-                    log.trace(\"Retrying \" + split);\n-                }\n-                MultiRfileInputformat.clearMetadataCache();\n-                \n-                Thread.sleep(failureSleep);\n-                \n-                /**\n-                 * Proper initialization requires that we set the tabletsplit table. This is generally done for us, but in the event that these are built\n-                 * manually we will throw an exception since we can't re-compute the split points without knowing the table.\n-                 */\n-                if (!tabletSplit.getTable().equals(TabletSplitSplit.TABLE_NOT_SET)) {\n-                    try {\n-                        \n-                        /**\n-                         * Compute the list of ranges again. We know that since we failed on initialization we can simply use all ranges. Internally\n-                         * RecordIterator will have its own failure mechanism restarting from the failure point.\n-                         */\n-                        List<Range> ranges = Lists.newArrayList();\n-                        for (int i = 0; i < tabletSplit.getLength(); i++) {\n-                            FileRangeSplit rfileSplit = (FileRangeSplit) (tabletSplit.get(i));\n-                            ranges.addAll(rfileSplit.getRanges());\n-                        }\n-                        \n-                        Collection<InputSplit> splits = MultiRfileInputformat.computeSplitPoints(context.getConfiguration(), tabletSplit.getTable(), ranges);\n-                        \n-                        /**\n-                         * Ensure that we only have one split, otherwise splits were created underneath this table.\n-                         */\n-                        Preconditions.checkArgument(splits.size() == 1);\n-                        \n-                        tabletSplit = (TabletSplitSplit) splits.iterator().next();\n-                        \n-                    } catch (TableNotFoundException | AccumuloException | AccumuloSecurityException e1) {\n-                        throw new RuntimeException(e1);\n-                    }\n-                } else {\n-                    throw new RuntimeException(\"Cannot recompute splits points because we are not properly initialized\");\n-                }\n-                \n-            }\n-        } while (splitReference == null);\n-        \n-    }\n-    \n-    /**\n-     * merge tablet splits since we will receive one to many from MultiRfileInputformat.computeSplitPoints( when re-computing split points.\n-     * \n-     * @param newSplits\n-     *            new list of splits\n-     * @param table\n-     *            table that we're accessing.\n-     * @return\n-     * @throws IOException\n-     *             cannot build TabletSplitSplit\n-     * @throws InterruptedException\n-     *             cannot build TabletSplitSplit\n-     */\n-    private TabletSplitSplit mergeTabletSplits(List<InputSplit> newSplits, String table) throws IOException, InterruptedException {\n-        int size = 0;\n-        \n-        for (InputSplit split : newSplits) {\n-            size += ((TabletSplitSplit) split).getLength();\n-        }\n-        TabletSplitSplit newSplit = new TabletSplitSplit(size);\n-        newSplit.setTable(table);\n-        for (InputSplit split : newSplits) {\n-            newSplit.add(((TabletSplitSplit) split));\n+\n+  public static final String ITER_CLASSES = \"range.record.reader.iterz\";\n+\n+  protected Collection<FileSKVIterator> fileIterators = null;\n+\n+  private boolean readFirstKeyValue = false;\n+\n+  protected Key startKey = null;\n+\n+  protected Key endKey = null;\n+\n+  protected RecordIterator splitReference = null;\n+\n+  private static final Logger log = Logger.getLogger(RangeRecordReader.class);\n+\n+  protected static final String PREFIX = BulkInputFormat.class.getSimpleName();\n+  protected static final String ITERATORS = PREFIX + \".iterators\";\n+  protected static final String ITERATORS_OPTIONS = PREFIX + \".iterators.options\";\n+  protected static final String ITERATORS_DELIM = \",\";\n+\n+  @Override\n+  public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException {\n+\n+    final long failureSleep = context.getConfiguration()\n+        .getLong(RecordIterator.RECORDITER_FAILURE_SLEEP_INTERVAL, RecordIterator.DEFAULT_FAILURE_SLEEP);\n+    int retries = 0;\n+    int maxRetries = context.getConfiguration()\n+        .getInt(RecordIterator.RECORDITER_FAILURE_COUNT_MAX, RecordIterator.FAILURE_MAX_DEFAULT);\n+    TabletSplitSplit tabletSplit = (TabletSplitSplit) split;\n+    do {\n+      try {\n+        splitReference = new RecordIterator(tabletSplit, context.getConfiguration());\n+      } catch (RuntimeException e) {\n+\n+        log.info(e);\n+\n+        splitReference = null;\n+        // an exception has occurred that won't allow us to open the files. perhaps one was moved\n+        // immediately upon opening the tablet.\n+        if (++retries > maxRetries) {\n+          log.info(\"Giving up because\" + retries + \" >= \" + maxRetries);\n+          throw e;\n+        } else if (log.isTraceEnabled()) {\n+          log.trace(\"Retrying \" + split);\n         }\n-        return newSplit;\n-    }\n-    \n-    @Override\n-    public boolean nextKeyValue() throws IOException, InterruptedException {\n-        // Iterators start out on the first key, whereas record readers are\n-        // assumed to start on nothing and move to the first key, so we don't\n-        // want to advance the iterator the first time through.\n-        if (readFirstKeyValue) {\n-            splitReference.next();\n+        MultiRfileInputformat.clearMetadataCache();\n+\n+        Thread.sleep(failureSleep);\n+\n+        /**\n+         * Proper initialization requires that we set the tabletsplit table. This is generally done for us, but in the event that these are built\n+         * manually we will throw an exception since we can't re-compute the split points without knowing the table.\n+         */\n+        if (!tabletSplit.getTable().equals(TabletSplitSplit.TABLE_NOT_SET)) {\n+          try {\n+\n+            /**\n+             * Compute the list of ranges again. We know that since we failed on initialization we can simply use all ranges. Internally\n+             * RecordIterator will have its own failure mechanism restarting from the failure point.\n+             */\n+            List<Range> ranges = Lists.newArrayList();\n+            for (int i = 0; i < tabletSplit.getLength(); i++) {\n+              FileRangeSplit rfileSplit = (FileRangeSplit) (tabletSplit.get(i));\n+              ranges.addAll(rfileSplit.getRanges());\n+            }\n+\n+            Collection<InputSplit> splits =\n+                MultiRfileInputformat.computeSplitPoints(context.getConfiguration(), tabletSplit.getTable(), ranges);\n+\n+            /**\n+             * Ensure that we only have one split, otherwise splits were created underneath this table.\n+             */\n+            Preconditions.checkArgument(splits.size() == 1);\n+\n+            tabletSplit = (TabletSplitSplit) splits.iterator().next();\n+\n+          } catch (TableNotFoundException | AccumuloException | AccumuloSecurityException e1) {\n+            throw new RuntimeException(e1);\n+          }\n+        } else {\n+          throw new RuntimeException(\"Cannot recompute splits points because we are not properly initialized\");\n         }\n-        readFirstKeyValue = true;\n-        return splitReference.hasTop();\n-    }\n-    \n-    @Override\n-    public Key getCurrentKey() throws IOException, InterruptedException {\n-        return splitReference.getTopKey();\n+\n+      }\n+    } while (splitReference == null);\n+\n+  }\n+\n+  /**\n+   * merge tablet splits since we will receive one to many from MultiRfileInputformat.computeSplitPoints( when re-computing split points.\n+   *\n+   * @param newSplits new list of splits\n+   * @param table     table that we're accessing.\n+   * @return\n+   * @throws IOException          cannot build TabletSplitSplit\n+   * @throws InterruptedException cannot build TabletSplitSplit\n+   */\n+  private TabletSplitSplit mergeTabletSplits(List<InputSplit> newSplits, String table)\n+      throws IOException, InterruptedException {\n+    int size = 0;\n+\n+    for (InputSplit split : newSplits) {\n+      size += ((TabletSplitSplit) split).getLength();\n     }\n-    \n-    @Override\n-    public Value getCurrentValue() throws IOException, InterruptedException {\n-        return splitReference.getTopValue();\n+    TabletSplitSplit newSplit = new TabletSplitSplit(size);\n+    newSplit.setTable(table);\n+    for (InputSplit split : newSplits) {\n+      newSplit.add(((TabletSplitSplit) split));\n     }\n-    \n-    @Override\n-    public void close() throws IOException {\n-        if (null != splitReference)\n-            splitReference.close();\n+    return newSplit;\n+  }\n+\n+  @Override\n+  public boolean nextKeyValue() throws IOException, InterruptedException {\n+    // Iterators start out on the first key, whereas record readers are\n+    // assumed to start on nothing and move to the first key, so we don't\n+    // want to advance the iterator the first time through.\n+    if (readFirstKeyValue) {\n+      splitReference.next();\n     }\n-    \n-    @Override\n-    public float getProgress() throws IOException, InterruptedException {\n-        return splitReference.getProgress();\n+    readFirstKeyValue = true;\n+    return splitReference.hasTop();\n+  }\n+\n+  @Override\n+  public Key getCurrentKey() throws IOException, InterruptedException {\n+    return splitReference.getTopKey();\n+  }\n+\n+  @Override\n+  public Value getCurrentValue() throws IOException, InterruptedException {\n+    return splitReference.getTopValue();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (null != splitReference) {\n+      splitReference.close();\n     }\n-    \n+  }\n+\n+  @Override\n+  public float getProgress() throws IOException, InterruptedException {\n+    return splitReference.getProgress();\n+  }\n+\n }\n",
            "diff_size": 204
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/74/RangeRecordReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/74/RangeRecordReader.java\nindex 9fde6fa1b4b..97fb0c916d1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/74/RangeRecordReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/74/RangeRecordReader.java\n@@ -52,8 +52,7 @@ public class RangeRecordReader extends RFileRecordReader {\n             try {\n                 splitReference = new RecordIterator(tabletSplit, context.getConfiguration());\n             } catch (RuntimeException e) {\n-                \n-                log.info(e);\n+    log.info(e);\n                 \n                 splitReference = null;\n                 // an exception has occurred that won't allow us to open the files. perhaps one was moved\n@@ -74,12 +73,11 @@ public class RangeRecordReader extends RFileRecordReader {\n                  */\n                 if (!tabletSplit.getTable().equals(TabletSplitSplit.TABLE_NOT_SET)) {\n                     try {\n-                        \n-                        /**\n+    /**\n                          * Compute the list of ranges again. We know that since we failed on initialization we can simply use all ranges. Internally\n                          * RecordIterator will have its own failure mechanism restarting from the failure point.\n                          */\n-                        List<Range> ranges = Lists.newArrayList();\n+    List<Range> ranges = Lists.newArrayList();\n                         for (int i = 0; i < tabletSplit.getLength(); i++) {\n                             FileRangeSplit rfileSplit = (FileRangeSplit) (tabletSplit.get(i));\n                             ranges.addAll(rfileSplit.getRanges());\n@@ -90,12 +88,11 @@ public class RangeRecordReader extends RFileRecordReader {\n                         /**\n                          * Ensure that we only have one split, otherwise splits were created underneath this table.\n                          */\n-                        Preconditions.checkArgument(splits.size() == 1);\n-                        \n-                        tabletSplit = (TabletSplitSplit) splits.iterator().next();\n+Preconditions.checkArgument(splits.size() == 1);\n+tabletSplit = (TabletSplitSplit) splits.iterator().next();\n                         \n                     } catch (TableNotFoundException | AccumuloException | AccumuloSecurityException e1) {\n-                        throw new RuntimeException(e1);\n+    throw new RuntimeException(e1);\n                     }\n                 } else {\n                     throw new RuntimeException(\"Cannot recompute splits points because we are not properly initialized\");\n@@ -166,4 +163,4 @@ public class RangeRecordReader extends RFileRecordReader {\n         return splitReference.getProgress();\n     }\n     \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 10
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/74/RangeRecordReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/74/RangeRecordReader.java\nindex 9fde6fa1b4b..1f19d665286 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/74/RangeRecordReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/74/RangeRecordReader.java\n@@ -15,35 +15,26 @@ import org.apache.accumulo.core.file.FileSKVIterator;\n import org.apache.hadoop.mapreduce.InputSplit;\n import org.apache.hadoop.mapreduce.TaskAttemptContext;\n import org.apache.log4j.Logger;\n-\n import java.io.IOException;\n import java.util.Collection;\n import java.util.List;\n \n+\n public class RangeRecordReader extends RFileRecordReader {\n-    \n     public static final String ITER_CLASSES = \"range.record.reader.iterz\";\n-    \n     protected Collection<FileSKVIterator> fileIterators = null;\n-    \n     private boolean readFirstKeyValue = false;\n-    \n     protected Key startKey = null;\n-    \n     protected Key endKey = null;\n-    \n     protected RecordIterator splitReference = null;\n-    \n     private static final Logger log = Logger.getLogger(RangeRecordReader.class);\n-    \n     protected static final String PREFIX = BulkInputFormat.class.getSimpleName();\n     protected static final String ITERATORS = PREFIX + \".iterators\";\n     protected static final String ITERATORS_OPTIONS = PREFIX + \".iterators.options\";\n     protected static final String ITERATORS_DELIM = \",\";\n-    \n+\n     @Override\n     public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException {\n-        \n         final long failureSleep = context.getConfiguration().getLong(RecordIterator.RECORDITER_FAILURE_SLEEP_INTERVAL, RecordIterator.DEFAULT_FAILURE_SLEEP);\n         int retries = 0;\n         int maxRetries = context.getConfiguration().getInt(RecordIterator.RECORDITER_FAILURE_COUNT_MAX, RecordIterator.FAILURE_MAX_DEFAULT);\n@@ -52,9 +43,7 @@ public class RangeRecordReader extends RFileRecordReader {\n             try {\n                 splitReference = new RecordIterator(tabletSplit, context.getConfiguration());\n             } catch (RuntimeException e) {\n-                \n                 log.info(e);\n-                \n                 splitReference = null;\n                 // an exception has occurred that won't allow us to open the files. perhaps one was moved\n                 // immediately upon opening the tablet.\n@@ -65,7 +54,6 @@ public class RangeRecordReader extends RFileRecordReader {\n                     log.trace(\"Retrying \" + split);\n                 }\n                 MultiRfileInputformat.clearMetadataCache();\n-                \n                 Thread.sleep(failureSleep);\n                 \n                 /**\n@@ -84,26 +72,22 @@ public class RangeRecordReader extends RFileRecordReader {\n                             FileRangeSplit rfileSplit = (FileRangeSplit) (tabletSplit.get(i));\n                             ranges.addAll(rfileSplit.getRanges());\n                         }\n-                        \n+\n                         Collection<InputSplit> splits = MultiRfileInputformat.computeSplitPoints(context.getConfiguration(), tabletSplit.getTable(), ranges);\n                         \n                         /**\n                          * Ensure that we only have one split, otherwise splits were created underneath this table.\n                          */\n                         Preconditions.checkArgument(splits.size() == 1);\n-                        \n                         tabletSplit = (TabletSplitSplit) splits.iterator().next();\n-                        \n                     } catch (TableNotFoundException | AccumuloException | AccumuloSecurityException e1) {\n                         throw new RuntimeException(e1);\n                     }\n                 } else {\n                     throw new RuntimeException(\"Cannot recompute splits points because we are not properly initialized\");\n                 }\n-                \n             }\n         } while (splitReference == null);\n-        \n     }\n     \n     /**\n@@ -119,20 +103,22 @@ public class RangeRecordReader extends RFileRecordReader {\n      * @throws InterruptedException\n      *             cannot build TabletSplitSplit\n      */\n+\n     private TabletSplitSplit mergeTabletSplits(List<InputSplit> newSplits, String table) throws IOException, InterruptedException {\n         int size = 0;\n-        \n         for (InputSplit split : newSplits) {\n             size += ((TabletSplitSplit) split).getLength();\n         }\n+\n         TabletSplitSplit newSplit = new TabletSplitSplit(size);\n         newSplit.setTable(table);\n+\n         for (InputSplit split : newSplits) {\n             newSplit.add(((TabletSplitSplit) split));\n         }\n         return newSplit;\n     }\n-    \n+\n     @Override\n     public boolean nextKeyValue() throws IOException, InterruptedException {\n         // Iterators start out on the first key, whereas record readers are\n@@ -144,26 +130,25 @@ public class RangeRecordReader extends RFileRecordReader {\n         readFirstKeyValue = true;\n         return splitReference.hasTop();\n     }\n-    \n+\n     @Override\n     public Key getCurrentKey() throws IOException, InterruptedException {\n         return splitReference.getTopKey();\n     }\n-    \n+\n     @Override\n     public Value getCurrentValue() throws IOException, InterruptedException {\n         return splitReference.getTopValue();\n     }\n-    \n+\n     @Override\n     public void close() throws IOException {\n         if (null != splitReference)\n             splitReference.close();\n     }\n-    \n+\n     @Override\n     public float getProgress() throws IOException, InterruptedException {\n         return splitReference.getProgress();\n     }\n-    \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 31
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "14",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}