{
    "project_name": "codefollower-H2-Research",
    "error_id": "25",
    "information": {
        "errors": [
            {
                "line": "513",
                "column": "53",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "        int retentionTime = target.getRetentionTime();\n        target.setAutoCommitDelay(0);\n        target.setRetentionTime(Integer.MAX_VALUE); // disable unused chunks collection\n        MVMap<String, String> sourceMeta = source.getMetaMap();\n        MVMap<String, String> targetMeta = target.getMetaMap();\n        for (Entry<String, String> m : sourceMeta.entrySet()) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/25/MVStoreTool.java\nindex 9bf1189574a..1e69c88703c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/25/MVStoreTool.java\n@@ -510,8 +510,9 @@ public class MVStoreTool {\n         int autoCommitDelay = target.getAutoCommitDelay();\n         int retentionTime = target.getRetentionTime();\n         target.setAutoCommitDelay(0);\n-        target.setRetentionTime(Integer.MAX_VALUE); // disable unused chunks collection\n-        MVMap<String, String> sourceMeta = source.getMetaMap();\n+        target.setRetentionTime(Integer.MAX_VALUE);\n+        // disable unused chunks collection\n+         MVMap<String, String> sourceMeta = source.getMetaMap();\n         MVMap<String, String> targetMeta = target.getMetaMap();\n         for (Entry<String, String> m : sourceMeta.entrySet()) {\n             String key = m.getKey();\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "124",
                    "column": "42",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "514",
                    "column": "49",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                },
                {
                    "line": "607",
                    "column": "42",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/25/MVStoreTool.java\nindex 9bf1189574a..265dbaa384b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/25/MVStoreTool.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore;\n \n import java.io.IOException;\n@@ -33,696 +34,696 @@ import org.h2.util.Utils;\n  */\n public class MVStoreTool {\n \n-    /**\n-     * Runs this tool.\n-     * Options are case sensitive. Supported options are:\n-     * <table summary=\"command line options\">\n-     * <tr><td>[-dump &lt;fileName&gt;]</td>\n-     * <td>Dump the contends of the file</td></tr>\n-     * <tr><td>[-info &lt;fileName&gt;]</td>\n-     * <td>Get summary information about a file</td></tr>\n-     * <tr><td>[-compact &lt;fileName&gt;]</td>\n-     * <td>Compact a store</td></tr>\n-     * <tr><td>[-compress &lt;fileName&gt;]</td>\n-     * <td>Compact a store with compression enabled</td></tr>\n-     * </table>\n-     *\n-     * @param args the command line arguments\n-     */\n-    public static void main(String... args) {\n-        for (int i = 0; i < args.length; i++) {\n-            if (\"-dump\".equals(args[i])) {\n-                String fileName = args[++i];\n-                dump(fileName, new PrintWriter(System.out), true);\n-            } else if (\"-info\".equals(args[i])) {\n-                String fileName = args[++i];\n-                info(fileName, new PrintWriter(System.out));\n-            } else if (\"-compact\".equals(args[i])) {\n-                String fileName = args[++i];\n-                compact(fileName, false);\n-            } else if (\"-compress\".equals(args[i])) {\n-                String fileName = args[++i];\n-                compact(fileName, true);\n-            } else if (\"-rollback\".equals(args[i])) {\n-                String fileName = args[++i];\n-                long targetVersion = Long.decode(args[++i]);\n-                rollback(fileName, targetVersion, new PrintWriter(System.out));\n-            } else if (\"-repair\".equals(args[i])) {\n-                String fileName = args[++i];\n-                repair(fileName);\n-            }\n-        }\n+  /**\n+   * Runs this tool.\n+   * Options are case sensitive. Supported options are:\n+   * <table summary=\"command line options\">\n+   * <tr><td>[-dump &lt;fileName&gt;]</td>\n+   * <td>Dump the contends of the file</td></tr>\n+   * <tr><td>[-info &lt;fileName&gt;]</td>\n+   * <td>Get summary information about a file</td></tr>\n+   * <tr><td>[-compact &lt;fileName&gt;]</td>\n+   * <td>Compact a store</td></tr>\n+   * <tr><td>[-compress &lt;fileName&gt;]</td>\n+   * <td>Compact a store with compression enabled</td></tr>\n+   * </table>\n+   *\n+   * @param args the command line arguments\n+   */\n+  public static void main(String... args) {\n+    for (int i = 0; i < args.length; i++) {\n+      if (\"-dump\".equals(args[i])) {\n+        String fileName = args[++i];\n+        dump(fileName, new PrintWriter(System.out), true);\n+      } else if (\"-info\".equals(args[i])) {\n+        String fileName = args[++i];\n+        info(fileName, new PrintWriter(System.out));\n+      } else if (\"-compact\".equals(args[i])) {\n+        String fileName = args[++i];\n+        compact(fileName, false);\n+      } else if (\"-compress\".equals(args[i])) {\n+        String fileName = args[++i];\n+        compact(fileName, true);\n+      } else if (\"-rollback\".equals(args[i])) {\n+        String fileName = args[++i];\n+        long targetVersion = Long.decode(args[++i]);\n+        rollback(fileName, targetVersion, new PrintWriter(System.out));\n+      } else if (\"-repair\".equals(args[i])) {\n+        String fileName = args[++i];\n+        repair(fileName);\n+      }\n     }\n+  }\n \n-    /**\n-     * Read the contents of the file and write them to system out.\n-     *\n-     * @param fileName the name of the file\n-     * @param details whether to print details\n-     */\n-    public static void dump(String fileName, boolean details) {\n-        dump(fileName, new PrintWriter(System.out), details);\n-    }\n+  /**\n+   * Read the contents of the file and write them to system out.\n+   *\n+   * @param fileName the name of the file\n+   * @param details  whether to print details\n+   */\n+  public static void dump(String fileName, boolean details) {\n+    dump(fileName, new PrintWriter(System.out), details);\n+  }\n \n-    /**\n-     * Read the summary information of the file and write them to system out.\n-     *\n-     * @param fileName the name of the file\n-     */\n-    public static void info(String fileName) {\n-        info(fileName, new PrintWriter(System.out));\n-    }\n+  /**\n+   * Read the summary information of the file and write them to system out.\n+   *\n+   * @param fileName the name of the file\n+   */\n+  public static void info(String fileName) {\n+    info(fileName, new PrintWriter(System.out));\n+  }\n \n-    /**\n-     * Read the contents of the file and display them in a human-readable\n-     * format.\n-     *\n-     * @param fileName the name of the file\n-     * @param writer the print writer\n-     * @param details print the page details\n-     */\n-    public static void dump(String fileName, Writer writer, boolean details) {\n-        PrintWriter pw = new PrintWriter(writer, true);\n-        if (!FilePath.get(fileName).exists()) {\n-            pw.println(\"File not found: \" + fileName);\n-            return;\n+  /**\n+   * Read the contents of the file and display them in a human-readable\n+   * format.\n+   *\n+   * @param fileName the name of the file\n+   * @param writer   the print writer\n+   * @param details  print the page details\n+   */\n+  public static void dump(String fileName, Writer writer, boolean details) {\n+    PrintWriter pw = new PrintWriter(writer, true);\n+    if (!FilePath.get(fileName).exists()) {\n+      pw.println(\"File not found: \" + fileName);\n+      return;\n+    }\n+    long size = FileUtils.size(fileName);\n+    pw.printf(\"File %s, %d bytes, %d MB\\n\", fileName, size, size / 1024 / 1024);\n+    FileChannel file = null;\n+    int blockSize = MVStore.BLOCK_SIZE;\n+    TreeMap<Integer, Long> mapSizesTotal =\n+        new TreeMap<>();\n+    long pageSizeTotal = 0;\n+    try {\n+      file = FilePath.get(fileName).open(\"r\");\n+      long fileSize = file.size();\n+      int len = Long.toHexString(fileSize).length();\n+      ByteBuffer block = ByteBuffer.allocate(4096);\n+      long pageCount = 0;\n+      for (long pos = 0; pos < fileSize; ) {\n+        block.rewind();\n+        DataUtils.readFully(file, pos, block);\n+        block.rewind();\n+        int headerType = block.get();\n+        if (headerType == 'H') {\n+          String header = new String(block.array(), StandardCharsets.ISO_8859_1).trim();\n+          pw.printf(\"%0\" + len + \"x fileHeader %s%n\",\n+              pos, header);\n+          pos += blockSize;\n+          continue;\n+        }\n+        if (headerType != 'c') {\n+          pos += blockSize;\n+          continue;\n         }\n-        long size = FileUtils.size(fileName);\n-        pw.printf(\"File %s, %d bytes, %d MB\\n\", fileName, size, size / 1024 / 1024);\n-        FileChannel file = null;\n-        int blockSize = MVStore.BLOCK_SIZE;\n-        TreeMap<Integer, Long> mapSizesTotal =\n-                new TreeMap<>();\n-        long pageSizeTotal = 0;\n+        block.position(0);\n+        Chunk c = null;\n         try {\n-            file = FilePath.get(fileName).open(\"r\");\n-            long fileSize = file.size();\n-            int len = Long.toHexString(fileSize).length();\n-            ByteBuffer block = ByteBuffer.allocate(4096);\n-            long pageCount = 0;\n-            for (long pos = 0; pos < fileSize;) {\n-                block.rewind();\n-                DataUtils.readFully(file, pos, block);\n-                block.rewind();\n-                int headerType = block.get();\n-                if (headerType == 'H') {\n-                    String header = new String(block.array(), StandardCharsets.ISO_8859_1).trim();\n-                    pw.printf(\"%0\" + len + \"x fileHeader %s%n\",\n-                            pos, header);\n-                    pos += blockSize;\n-                    continue;\n-                }\n-                if (headerType != 'c') {\n-                    pos += blockSize;\n-                    continue;\n-                }\n-                block.position(0);\n-                Chunk c = null;\n-                try {\n-                    c = Chunk.readChunkHeader(block, pos);\n-                } catch (IllegalStateException e) {\n-                    pos += blockSize;\n-                    continue;\n-                }\n-                if (c.len <= 0) {\n-                    // not a chunk\n-                    pos += blockSize;\n-                    continue;\n-                }\n-                int length = c.len * MVStore.BLOCK_SIZE;\n-                pw.printf(\"%n%0\" + len + \"x chunkHeader %s%n\",\n-                        pos, c.toString());\n-                ByteBuffer chunk = ByteBuffer.allocate(length);\n-                DataUtils.readFully(file, pos, chunk);\n-                int p = block.position();\n-                pos += length;\n-                int remaining = c.pageCount;\n-                pageCount += c.pageCount;\n-                TreeMap<Integer, Integer> mapSizes =\n-                        new TreeMap<>();\n-                int pageSizeSum = 0;\n-                while (remaining > 0) {\n-                    int start = p;\n-                    try {\n-                        chunk.position(p);\n-                    } catch (IllegalArgumentException e) {\n-                        // too far\n-                        pw.printf(\"ERROR illegal position %d%n\", p);\n-                        break;\n-                    }\n-                    int pageSize = chunk.getInt();\n-                    // check value (ignored)\n-                    chunk.getShort();\n-                    int mapId = DataUtils.readVarInt(chunk);\n-                    int entries = DataUtils.readVarInt(chunk);\n-                    int type = chunk.get();\n-                    boolean compressed = (type & DataUtils.PAGE_COMPRESSED) != 0;\n-                    boolean node = (type & 1) != 0;\n-                    if (details) {\n-                        pw.printf(\n-                                \"+%0\" + len +\n-                                \"x %s, map %x, %d entries, %d bytes, maxLen %x%n\",\n-                                p,\n-                                (node ? \"node\" : \"leaf\") +\n-                                (compressed ? \" compressed\" : \"\"),\n-                                mapId,\n-                                node ? entries + 1 : entries,\n-                                pageSize,\n-                                DataUtils.getPageMaxLength(DataUtils.getPagePos(0, 0, pageSize, 0))\n-                                );\n-                    }\n-                    p += pageSize;\n-                    Integer mapSize = mapSizes.get(mapId);\n-                    if (mapSize == null) {\n-                        mapSize = 0;\n-                    }\n-                    mapSizes.put(mapId, mapSize + pageSize);\n-                    Long total = mapSizesTotal.get(mapId);\n-                    if (total == null) {\n-                        total = 0L;\n-                    }\n-                    mapSizesTotal.put(mapId, total + pageSize);\n-                    pageSizeSum += pageSize;\n-                    pageSizeTotal += pageSize;\n-                    remaining--;\n-                    long[] children = null;\n-                    long[] counts = null;\n-                    if (node) {\n-                        children = new long[entries + 1];\n-                        for (int i = 0; i <= entries; i++) {\n-                            children[i] = chunk.getLong();\n-                        }\n-                        counts = new long[entries + 1];\n-                        for (int i = 0; i <= entries; i++) {\n-                            long s = DataUtils.readVarLong(chunk);\n-                            counts[i] = s;\n-                        }\n-                    }\n-                    String[] keys = new String[entries];\n-                    if (mapId == 0 && details) {\n-                        ByteBuffer data;\n-                        if (compressed) {\n-                            boolean fast = (type & DataUtils.PAGE_COMPRESSED_HIGH) != DataUtils.PAGE_COMPRESSED_HIGH;\n-                            Compressor compressor = getCompressor(fast);\n-                            int lenAdd = DataUtils.readVarInt(chunk);\n-                            int compLen = pageSize + start - chunk.position();\n-                            byte[] comp = Utils.newBytes(compLen);\n-                            chunk.get(comp);\n-                            int l = compLen + lenAdd;\n-                            data = ByteBuffer.allocate(l);\n-                            compressor.expand(comp, 0, compLen, data.array(), 0, l);\n-                        } else {\n-                            data = chunk;\n-                        }\n-                        for (int i = 0; i < entries; i++) {\n-                            String k = StringDataType.INSTANCE.read(data);\n-                            keys[i] = k;\n-                        }\n-                        if (node) {\n-                            // meta map node\n-                            for (int i = 0; i < entries; i++) {\n-                                long cp = children[i];\n-                                pw.printf(\"    %d children < %s @ \" +\n-                                        \"chunk %x +%0\" +\n-                                        len + \"x%n\",\n-                                        counts[i],\n-                                        keys[i],\n-                                        DataUtils.getPageChunkId(cp),\n-                                        DataUtils.getPageOffset(cp));\n-                            }\n-                            long cp = children[entries];\n-                            pw.printf(\"    %d children >= %s @ chunk %x +%0\" +\n-                                    len + \"x%n\",\n-                                    counts[entries],\n-                                    keys.length >= entries ? null : keys[entries],\n-                                    DataUtils.getPageChunkId(cp),\n-                                    DataUtils.getPageOffset(cp));\n-                        } else {\n-                            // meta map leaf\n-                            String[] values = new String[entries];\n-                            for (int i = 0; i < entries; i++) {\n-                                String v = StringDataType.INSTANCE.read(data);\n-                                values[i] = v;\n-                            }\n-                            for (int i = 0; i < entries; i++) {\n-                                pw.println(\"    \" + keys[i] +\n-                                        \" = \" + values[i]);\n-                            }\n-                        }\n-                    } else {\n-                        if (node && details) {\n-                            for (int i = 0; i <= entries; i++) {\n-                                long cp = children[i];\n-                                pw.printf(\"    %d children @ chunk %x +%0\" +\n-                                        len + \"x%n\",\n-                                        counts[i],\n-                                        DataUtils.getPageChunkId(cp),\n-                                        DataUtils.getPageOffset(cp));\n-                            }\n-                        }\n-                    }\n-                }\n-                pageSizeSum = Math.max(1, pageSizeSum);\n-                for (Integer mapId : mapSizes.keySet()) {\n-                    int percent = 100 * mapSizes.get(mapId) / pageSizeSum;\n-                    pw.printf(\"map %x: %d bytes, %d%%%n\", mapId, mapSizes.get(mapId), percent);\n-                }\n-                int footerPos = chunk.limit() - Chunk.FOOTER_LENGTH;\n-                try {\n-                    chunk.position(footerPos);\n-                    pw.printf(\n-                            \"+%0\" + len + \"x chunkFooter %s%n\",\n-                            footerPos,\n-                            new String(chunk.array(), chunk.position(),\n-                                    Chunk.FOOTER_LENGTH, StandardCharsets.ISO_8859_1).trim());\n-                } catch (IllegalArgumentException e) {\n-                    // too far\n-                    pw.printf(\"ERROR illegal footer position %d%n\", footerPos);\n-                }\n+          c = Chunk.readChunkHeader(block, pos);\n+        } catch (IllegalStateException e) {\n+          pos += blockSize;\n+          continue;\n+        }\n+        if (c.len <= 0) {\n+          // not a chunk\n+          pos += blockSize;\n+          continue;\n+        }\n+        int length = c.len * MVStore.BLOCK_SIZE;\n+        pw.printf(\"%n%0\" + len + \"x chunkHeader %s%n\",\n+            pos, c.toString());\n+        ByteBuffer chunk = ByteBuffer.allocate(length);\n+        DataUtils.readFully(file, pos, chunk);\n+        int p = block.position();\n+        pos += length;\n+        int remaining = c.pageCount;\n+        pageCount += c.pageCount;\n+        TreeMap<Integer, Integer> mapSizes =\n+            new TreeMap<>();\n+        int pageSizeSum = 0;\n+        while (remaining > 0) {\n+          int start = p;\n+          try {\n+            chunk.position(p);\n+          } catch (IllegalArgumentException e) {\n+            // too far\n+            pw.printf(\"ERROR illegal position %d%n\", p);\n+            break;\n+          }\n+          int pageSize = chunk.getInt();\n+          // check value (ignored)\n+          chunk.getShort();\n+          int mapId = DataUtils.readVarInt(chunk);\n+          int entries = DataUtils.readVarInt(chunk);\n+          int type = chunk.get();\n+          boolean compressed = (type & DataUtils.PAGE_COMPRESSED) != 0;\n+          boolean node = (type & 1) != 0;\n+          if (details) {\n+            pw.printf(\n+                \"+%0\" + len +\n+                    \"x %s, map %x, %d entries, %d bytes, maxLen %x%n\",\n+                p,\n+                (node ? \"node\" : \"leaf\") +\n+                    (compressed ? \" compressed\" : \"\"),\n+                mapId,\n+                node ? entries + 1 : entries,\n+                pageSize,\n+                DataUtils.getPageMaxLength(DataUtils.getPagePos(0, 0, pageSize, 0))\n+            );\n+          }\n+          p += pageSize;\n+          Integer mapSize = mapSizes.get(mapId);\n+          if (mapSize == null) {\n+            mapSize = 0;\n+          }\n+          mapSizes.put(mapId, mapSize + pageSize);\n+          Long total = mapSizesTotal.get(mapId);\n+          if (total == null) {\n+            total = 0L;\n+          }\n+          mapSizesTotal.put(mapId, total + pageSize);\n+          pageSizeSum += pageSize;\n+          pageSizeTotal += pageSize;\n+          remaining--;\n+          long[] children = null;\n+          long[] counts = null;\n+          if (node) {\n+            children = new long[entries + 1];\n+            for (int i = 0; i <= entries; i++) {\n+              children[i] = chunk.getLong();\n             }\n-            pw.printf(\"%n%0\" + len + \"x eof%n\", fileSize);\n-            pw.printf(\"\\n\");\n-            pageCount = Math.max(1, pageCount);\n-            pw.printf(\"page size total: %d bytes, page count: %d, average page size: %d bytes\\n\",\n-                    pageSizeTotal, pageCount, pageSizeTotal / pageCount);\n-            pageSizeTotal = Math.max(1, pageSizeTotal);\n-            for (Integer mapId : mapSizesTotal.keySet()) {\n-                int percent = (int) (100 * mapSizesTotal.get(mapId) / pageSizeTotal);\n-                pw.printf(\"map %x: %d bytes, %d%%%n\", mapId, mapSizesTotal.get(mapId), percent);\n+            counts = new long[entries + 1];\n+            for (int i = 0; i <= entries; i++) {\n+              long s = DataUtils.readVarLong(chunk);\n+              counts[i] = s;\n             }\n-        } catch (IOException e) {\n-            pw.println(\"ERROR: \" + e);\n-            e.printStackTrace(pw);\n-        } finally {\n-            if (file != null) {\n-                try {\n-                    file.close();\n-                } catch (IOException e) {\n-                    // ignore\n-                }\n+          }\n+          String[] keys = new String[entries];\n+          if (mapId == 0 && details) {\n+            ByteBuffer data;\n+            if (compressed) {\n+              boolean fast = (type & DataUtils.PAGE_COMPRESSED_HIGH) != DataUtils.PAGE_COMPRESSED_HIGH;\n+              Compressor compressor = getCompressor(fast);\n+              int lenAdd = DataUtils.readVarInt(chunk);\n+              int compLen = pageSize + start - chunk.position();\n+              byte[] comp = Utils.newBytes(compLen);\n+              chunk.get(comp);\n+              int l = compLen + lenAdd;\n+              data = ByteBuffer.allocate(l);\n+              compressor.expand(comp, 0, compLen, data.array(), 0, l);\n+            } else {\n+              data = chunk;\n+            }\n+            for (int i = 0; i < entries; i++) {\n+              String k = StringDataType.INSTANCE.read(data);\n+              keys[i] = k;\n+            }\n+            if (node) {\n+              // meta map node\n+              for (int i = 0; i < entries; i++) {\n+                long cp = children[i];\n+                pw.printf(\"    %d children < %s @ \" +\n+                        \"chunk %x +%0\" +\n+                        len + \"x%n\",\n+                    counts[i],\n+                    keys[i],\n+                    DataUtils.getPageChunkId(cp),\n+                    DataUtils.getPageOffset(cp));\n+              }\n+              long cp = children[entries];\n+              pw.printf(\"    %d children >= %s @ chunk %x +%0\" +\n+                      len + \"x%n\",\n+                  counts[entries],\n+                  keys.length >= entries ? null : keys[entries],\n+                  DataUtils.getPageChunkId(cp),\n+                  DataUtils.getPageOffset(cp));\n+            } else {\n+              // meta map leaf\n+              String[] values = new String[entries];\n+              for (int i = 0; i < entries; i++) {\n+                String v = StringDataType.INSTANCE.read(data);\n+                values[i] = v;\n+              }\n+              for (int i = 0; i < entries; i++) {\n+                pw.println(\"    \" + keys[i] +\n+                    \" = \" + values[i]);\n+              }\n             }\n+          } else {\n+            if (node && details) {\n+              for (int i = 0; i <= entries; i++) {\n+                long cp = children[i];\n+                pw.printf(\"    %d children @ chunk %x +%0\" +\n+                        len + \"x%n\",\n+                    counts[i],\n+                    DataUtils.getPageChunkId(cp),\n+                    DataUtils.getPageOffset(cp));\n+              }\n+            }\n+          }\n         }\n-        pw.flush();\n+        pageSizeSum = Math.max(1, pageSizeSum);\n+        for (Integer mapId : mapSizes.keySet()) {\n+          int percent = 100 * mapSizes.get(mapId) / pageSizeSum;\n+          pw.printf(\"map %x: %d bytes, %d%%%n\", mapId, mapSizes.get(mapId), percent);\n+        }\n+        int footerPos = chunk.limit() - Chunk.FOOTER_LENGTH;\n+        try {\n+          chunk.position(footerPos);\n+          pw.printf(\n+              \"+%0\" + len + \"x chunkFooter %s%n\",\n+              footerPos,\n+              new String(chunk.array(), chunk.position(),\n+                  Chunk.FOOTER_LENGTH, StandardCharsets.ISO_8859_1).trim());\n+        } catch (IllegalArgumentException e) {\n+          // too far\n+          pw.printf(\"ERROR illegal footer position %d%n\", footerPos);\n+        }\n+      }\n+      pw.printf(\"%n%0\" + len + \"x eof%n\", fileSize);\n+      pw.printf(\"\\n\");\n+      pageCount = Math.max(1, pageCount);\n+      pw.printf(\"page size total: %d bytes, page count: %d, average page size: %d bytes\\n\",\n+          pageSizeTotal, pageCount, pageSizeTotal / pageCount);\n+      pageSizeTotal = Math.max(1, pageSizeTotal);\n+      for (Integer mapId : mapSizesTotal.keySet()) {\n+        int percent = (int) (100 * mapSizesTotal.get(mapId) / pageSizeTotal);\n+        pw.printf(\"map %x: %d bytes, %d%%%n\", mapId, mapSizesTotal.get(mapId), percent);\n+      }\n+    } catch (IOException e) {\n+      pw.println(\"ERROR: \" + e);\n+      e.printStackTrace(pw);\n+    } finally {\n+      if (file != null) {\n+        try {\n+          file.close();\n+        } catch (IOException e) {\n+          // ignore\n+        }\n+      }\n     }\n+    pw.flush();\n+  }\n \n-    private static Compressor getCompressor(boolean fast) {\n-        return fast ? new CompressLZF() : new CompressDeflate();\n-    }\n+  private static Compressor getCompressor(boolean fast) {\n+    return fast ? new CompressLZF() : new CompressDeflate();\n+  }\n \n-    /**\n-     * Read the summary information of the file and write them to system out.\n-     *\n-     * @param fileName the name of the file\n-     * @param writer the print writer\n-     * @return null if successful (if there was no error), otherwise the error\n-     *         message\n-     */\n-    public static String info(String fileName, Writer writer) {\n-        PrintWriter pw = new PrintWriter(writer, true);\n-        if (!FilePath.get(fileName).exists()) {\n-            pw.println(\"File not found: \" + fileName);\n-            return \"File not found: \" + fileName;\n+  /**\n+   * Read the summary information of the file and write them to system out.\n+   *\n+   * @param fileName the name of the file\n+   * @param writer   the print writer\n+   * @return null if successful (if there was no error), otherwise the error\n+   * message\n+   */\n+  public static String info(String fileName, Writer writer) {\n+    PrintWriter pw = new PrintWriter(writer, true);\n+    if (!FilePath.get(fileName).exists()) {\n+      pw.println(\"File not found: \" + fileName);\n+      return \"File not found: \" + fileName;\n+    }\n+    long fileLength = FileUtils.size(fileName);\n+    MVStore store = new MVStore.Builder().\n+        fileName(fileName).\n+        readOnly().open();\n+    try {\n+      MVMap<String, String> meta = store.getMetaMap();\n+      Map<String, Object> header = store.getStoreHeader();\n+      long fileCreated = DataUtils.readHexLong(header, \"created\", 0L);\n+      TreeMap<Integer, Chunk> chunks = new TreeMap<>();\n+      long chunkLength = 0;\n+      long maxLength = 0;\n+      long maxLengthLive = 0;\n+      long maxLengthNotEmpty = 0;\n+      for (Entry<String, String> e : meta.entrySet()) {\n+        String k = e.getKey();\n+        if (k.startsWith(\"chunk.\")) {\n+          Chunk c = Chunk.fromString(e.getValue());\n+          chunks.put(c.id, c);\n+          chunkLength += c.len * MVStore.BLOCK_SIZE;\n+          maxLength += c.maxLen;\n+          maxLengthLive += c.maxLenLive;\n+          if (c.maxLenLive > 0) {\n+            maxLengthNotEmpty += c.maxLen;\n+          }\n         }\n-        long fileLength = FileUtils.size(fileName);\n-        MVStore store = new MVStore.Builder().\n-                fileName(fileName).\n-                readOnly().open();\n-        try {\n-            MVMap<String, String> meta = store.getMetaMap();\n-            Map<String, Object> header = store.getStoreHeader();\n-            long fileCreated = DataUtils.readHexLong(header, \"created\", 0L);\n-            TreeMap<Integer, Chunk> chunks = new TreeMap<>();\n-            long chunkLength = 0;\n-            long maxLength = 0;\n-            long maxLengthLive = 0;\n-            long maxLengthNotEmpty = 0;\n-            for (Entry<String, String> e : meta.entrySet()) {\n-                String k = e.getKey();\n-                if (k.startsWith(\"chunk.\")) {\n-                    Chunk c = Chunk.fromString(e.getValue());\n-                    chunks.put(c.id, c);\n-                    chunkLength += c.len * MVStore.BLOCK_SIZE;\n-                    maxLength += c.maxLen;\n-                    maxLengthLive += c.maxLenLive;\n-                    if (c.maxLenLive > 0) {\n-                        maxLengthNotEmpty += c.maxLen;\n-                    }\n-                }\n-            }\n-            pw.printf(\"Created: %s\\n\", formatTimestamp(fileCreated, fileCreated));\n-            pw.printf(\"Last modified: %s\\n\",\n-                    formatTimestamp(FileUtils.lastModified(fileName), fileCreated));\n-            pw.printf(\"File length: %d\\n\", fileLength);\n-            pw.printf(\"The last chunk is not listed\\n\");\n-            pw.printf(\"Chunk length: %d\\n\", chunkLength);\n-            pw.printf(\"Chunk count: %d\\n\", chunks.size());\n-            pw.printf(\"Used space: %d%%\\n\", getPercent(chunkLength, fileLength));\n-            pw.printf(\"Chunk fill rate: %d%%\\n\", maxLength == 0 ? 100 :\n-                getPercent(maxLengthLive, maxLength));\n-            pw.printf(\"Chunk fill rate excluding empty chunks: %d%%\\n\",\n-                maxLengthNotEmpty == 0 ? 100 :\n-                getPercent(maxLengthLive, maxLengthNotEmpty));\n-            for (Entry<Integer, Chunk> e : chunks.entrySet()) {\n-                Chunk c = e.getValue();\n-                long created = fileCreated + c.time;\n-                pw.printf(\"  Chunk %d: %s, %d%% used, %d blocks\",\n-                        c.id, formatTimestamp(created, fileCreated),\n-                        getPercent(c.maxLenLive, c.maxLen),\n-                        c.len\n-                        );\n-                if (c.maxLenLive == 0) {\n-                    pw.printf(\", unused: %s\",\n-                            formatTimestamp(fileCreated + c.unused, fileCreated));\n-                }\n-                pw.printf(\"\\n\");\n-            }\n-            pw.printf(\"\\n\");\n-        } catch (Exception e) {\n-            pw.println(\"ERROR: \" + e);\n-            e.printStackTrace(pw);\n-            return e.getMessage();\n-        } finally {\n-            store.close();\n+      }\n+      pw.printf(\"Created: %s\\n\", formatTimestamp(fileCreated, fileCreated));\n+      pw.printf(\"Last modified: %s\\n\",\n+          formatTimestamp(FileUtils.lastModified(fileName), fileCreated));\n+      pw.printf(\"File length: %d\\n\", fileLength);\n+      pw.printf(\"The last chunk is not listed\\n\");\n+      pw.printf(\"Chunk length: %d\\n\", chunkLength);\n+      pw.printf(\"Chunk count: %d\\n\", chunks.size());\n+      pw.printf(\"Used space: %d%%\\n\", getPercent(chunkLength, fileLength));\n+      pw.printf(\"Chunk fill rate: %d%%\\n\", maxLength == 0 ? 100 :\n+          getPercent(maxLengthLive, maxLength));\n+      pw.printf(\"Chunk fill rate excluding empty chunks: %d%%\\n\",\n+          maxLengthNotEmpty == 0 ? 100 :\n+              getPercent(maxLengthLive, maxLengthNotEmpty));\n+      for (Entry<Integer, Chunk> e : chunks.entrySet()) {\n+        Chunk c = e.getValue();\n+        long created = fileCreated + c.time;\n+        pw.printf(\"  Chunk %d: %s, %d%% used, %d blocks\",\n+            c.id, formatTimestamp(created, fileCreated),\n+            getPercent(c.maxLenLive, c.maxLen),\n+            c.len\n+        );\n+        if (c.maxLenLive == 0) {\n+          pw.printf(\", unused: %s\",\n+              formatTimestamp(fileCreated + c.unused, fileCreated));\n         }\n-        pw.flush();\n-        return null;\n+        pw.printf(\"\\n\");\n+      }\n+      pw.printf(\"\\n\");\n+    } catch (Exception e) {\n+      pw.println(\"ERROR: \" + e);\n+      e.printStackTrace(pw);\n+      return e.getMessage();\n+    } finally {\n+      store.close();\n     }\n+    pw.flush();\n+    return null;\n+  }\n \n-    private static String formatTimestamp(long t, long start) {\n-        String x = new Timestamp(t).toString();\n-        String s = x.substring(0, 19);\n-        s += \" (+\" + ((t - start) / 1000) + \" s)\";\n-        return s;\n-    }\n+  private static String formatTimestamp(long t, long start) {\n+    String x = new Timestamp(t).toString();\n+    String s = x.substring(0, 19);\n+    s += \" (+\" + ((t - start) / 1000) + \" s)\";\n+    return s;\n+  }\n \n-    private static int getPercent(long value, long max) {\n-        if (value == 0) {\n-            return 0;\n-        } else if (value == max) {\n-            return 100;\n-        }\n-        return (int) (1 + 98 * value / Math.max(1, max));\n+  private static int getPercent(long value, long max) {\n+    if (value == 0) {\n+      return 0;\n+    } else if (value == max) {\n+      return 100;\n     }\n+    return (int) (1 + 98 * value / Math.max(1, max));\n+  }\n \n-    /**\n-     * Compress the store by creating a new file and copying the live pages\n-     * there. Temporarily, a file with the suffix \".tempFile\" is created. This\n-     * file is then renamed, replacing the original file, if possible. If not,\n-     * the new file is renamed to \".newFile\", then the old file is removed, and\n-     * the new file is renamed. This might be interrupted, so it's better to\n-     * compactCleanUp before opening a store, in case this method was used.\n-     *\n-     * @param fileName the file name\n-     * @param compress whether to compress the data\n-     */\n-    public static void compact(String fileName, boolean compress) {\n-        String tempName = fileName + Constants.SUFFIX_MV_STORE_TEMP_FILE;\n-        FileUtils.delete(tempName);\n-        compact(fileName, tempName, compress);\n-        try {\n-            FileUtils.moveAtomicReplace(tempName, fileName);\n-        } catch (DbException e) {\n-            String newName = fileName + Constants.SUFFIX_MV_STORE_NEW_FILE;\n-            FileUtils.delete(newName);\n-            FileUtils.move(tempName, newName);\n-            FileUtils.delete(fileName);\n-            FileUtils.move(newName, fileName);\n-        }\n+  /**\n+   * Compress the store by creating a new file and copying the live pages\n+   * there. Temporarily, a file with the suffix \".tempFile\" is created. This\n+   * file is then renamed, replacing the original file, if possible. If not,\n+   * the new file is renamed to \".newFile\", then the old file is removed, and\n+   * the new file is renamed. This might be interrupted, so it's better to\n+   * compactCleanUp before opening a store, in case this method was used.\n+   *\n+   * @param fileName the file name\n+   * @param compress whether to compress the data\n+   */\n+  public static void compact(String fileName, boolean compress) {\n+    String tempName = fileName + Constants.SUFFIX_MV_STORE_TEMP_FILE;\n+    FileUtils.delete(tempName);\n+    compact(fileName, tempName, compress);\n+    try {\n+      FileUtils.moveAtomicReplace(tempName, fileName);\n+    } catch (DbException e) {\n+      String newName = fileName + Constants.SUFFIX_MV_STORE_NEW_FILE;\n+      FileUtils.delete(newName);\n+      FileUtils.move(tempName, newName);\n+      FileUtils.delete(fileName);\n+      FileUtils.move(newName, fileName);\n     }\n+  }\n \n-    /**\n-     * Clean up if needed, in a case a compact operation was interrupted due to\n-     * killing the process or a power failure. This will delete temporary files\n-     * (if any), and in case atomic file replacements were not used, rename the\n-     * new file.\n-     *\n-     * @param fileName the file name\n-     */\n-    public static void compactCleanUp(String fileName) {\n-        String tempName = fileName + Constants.SUFFIX_MV_STORE_TEMP_FILE;\n-        if (FileUtils.exists(tempName)) {\n-            FileUtils.delete(tempName);\n-        }\n-        String newName = fileName + Constants.SUFFIX_MV_STORE_NEW_FILE;\n-        if (FileUtils.exists(newName)) {\n-            if (FileUtils.exists(fileName)) {\n-                FileUtils.delete(newName);\n-            } else {\n-                FileUtils.move(newName, fileName);\n-            }\n-        }\n+  /**\n+   * Clean up if needed, in a case a compact operation was interrupted due to\n+   * killing the process or a power failure. This will delete temporary files\n+   * (if any), and in case atomic file replacements were not used, rename the\n+   * new file.\n+   *\n+   * @param fileName the file name\n+   */\n+  public static void compactCleanUp(String fileName) {\n+    String tempName = fileName + Constants.SUFFIX_MV_STORE_TEMP_FILE;\n+    if (FileUtils.exists(tempName)) {\n+      FileUtils.delete(tempName);\n     }\n+    String newName = fileName + Constants.SUFFIX_MV_STORE_NEW_FILE;\n+    if (FileUtils.exists(newName)) {\n+      if (FileUtils.exists(fileName)) {\n+        FileUtils.delete(newName);\n+      } else {\n+        FileUtils.move(newName, fileName);\n+      }\n+    }\n+  }\n \n-    /**\n-     * Copy all live pages from the source store to the target store.\n-     *\n-     * @param sourceFileName the name of the source store\n-     * @param targetFileName the name of the target store\n-     * @param compress whether to compress the data\n-     */\n-    public static void compact(String sourceFileName, String targetFileName, boolean compress) {\n-        try (MVStore source = new MVStore.Builder().\n-                fileName(sourceFileName).readOnly().open()) {\n-            // Bugfix - Add double \"try-finally\" statements to close source and target stores for\n-            //releasing lock and file resources in these stores even if OOM occurs.\n-            // Fix issues such as \"Cannot delete file \"/h2/data/test.mv.db.tempFile\" [90025-197]\"\n-            //when client connects to this server and reopens this store database in this process.\n-            // @since 2018-09-13 little-pan\n-            FileUtils.delete(targetFileName);\n-            MVStore.Builder b = new MVStore.Builder().\n-                fileName(targetFileName);\n-            if (compress) {\n-                b.compress();\n-            }\n-            try (MVStore target = b.open()) {\n-                compact(source, target);\n-            }\n-        }\n+  /**\n+   * Copy all live pages from the source store to the target store.\n+   *\n+   * @param sourceFileName the name of the source store\n+   * @param targetFileName the name of the target store\n+   * @param compress       whether to compress the data\n+   */\n+  public static void compact(String sourceFileName, String targetFileName, boolean compress) {\n+    try (MVStore source = new MVStore.Builder().\n+        fileName(sourceFileName).readOnly().open()) {\n+      // Bugfix - Add double \"try-finally\" statements to close source and target stores for\n+      //releasing lock and file resources in these stores even if OOM occurs.\n+      // Fix issues such as \"Cannot delete file \"/h2/data/test.mv.db.tempFile\" [90025-197]\"\n+      //when client connects to this server and reopens this store database in this process.\n+      // @since 2018-09-13 little-pan\n+      FileUtils.delete(targetFileName);\n+      MVStore.Builder b = new MVStore.Builder().\n+          fileName(targetFileName);\n+      if (compress) {\n+        b.compress();\n+      }\n+      try (MVStore target = b.open()) {\n+        compact(source, target);\n+      }\n     }\n+  }\n \n-    /**\n-     * Copy all live pages from the source store to the target store.\n-     *\n-     * @param source the source store\n-     * @param target the target store\n-     */\n-    public static void compact(MVStore source, MVStore target) {\n-        int autoCommitDelay = target.getAutoCommitDelay();\n-        int retentionTime = target.getRetentionTime();\n-        target.setAutoCommitDelay(0);\n-        target.setRetentionTime(Integer.MAX_VALUE); // disable unused chunks collection\n-        MVMap<String, String> sourceMeta = source.getMetaMap();\n-        MVMap<String, String> targetMeta = target.getMetaMap();\n-        for (Entry<String, String> m : sourceMeta.entrySet()) {\n-            String key = m.getKey();\n-            if (key.startsWith(\"chunk.\")) {\n-                // ignore\n-            } else if (key.startsWith(\"map.\")) {\n-                // ignore\n-            } else if (key.startsWith(\"name.\")) {\n-                // ignore\n-            } else if (key.startsWith(\"root.\")) {\n-                // ignore\n-            } else {\n-                targetMeta.put(key, m.getValue());\n-            }\n-        }\n-        for (String mapName : source.getMapNames()) {\n-            MVMap.Builder<Object, Object> mp =\n-                    new MVMap.Builder<>().\n-                    keyType(new GenericDataType()).\n-                    valueType(new GenericDataType());\n-            MVMap<Object, Object> sourceMap = source.openMap(mapName, mp);\n-            MVMap<Object, Object> targetMap = target.openMap(mapName, mp);\n-            targetMap.copyFrom(sourceMap);\n-        }\n-        target.setRetentionTime(retentionTime);\n-        target.setAutoCommitDelay(autoCommitDelay);\n+  /**\n+   * Copy all live pages from the source store to the target store.\n+   *\n+   * @param source the source store\n+   * @param target the target store\n+   */\n+  public static void compact(MVStore source, MVStore target) {\n+    int autoCommitDelay = target.getAutoCommitDelay();\n+    int retentionTime = target.getRetentionTime();\n+    target.setAutoCommitDelay(0);\n+    target.setRetentionTime(Integer.MAX_VALUE); // disable unused chunks collection\n+    MVMap<String, String> sourceMeta = source.getMetaMap();\n+    MVMap<String, String> targetMeta = target.getMetaMap();\n+    for (Entry<String, String> m : sourceMeta.entrySet()) {\n+      String key = m.getKey();\n+      if (key.startsWith(\"chunk.\")) {\n+        // ignore\n+      } else if (key.startsWith(\"map.\")) {\n+        // ignore\n+      } else if (key.startsWith(\"name.\")) {\n+        // ignore\n+      } else if (key.startsWith(\"root.\")) {\n+        // ignore\n+      } else {\n+        targetMeta.put(key, m.getValue());\n+      }\n     }\n+    for (String mapName : source.getMapNames()) {\n+      MVMap.Builder<Object, Object> mp =\n+          new MVMap.Builder<>().\n+              keyType(new GenericDataType()).\n+              valueType(new GenericDataType());\n+      MVMap<Object, Object> sourceMap = source.openMap(mapName, mp);\n+      MVMap<Object, Object> targetMap = target.openMap(mapName, mp);\n+      targetMap.copyFrom(sourceMap);\n+    }\n+    target.setRetentionTime(retentionTime);\n+    target.setAutoCommitDelay(autoCommitDelay);\n+  }\n \n-    /**\n-     * Repair a store by rolling back to the newest good version.\n-     *\n-     * @param fileName the file name\n-     */\n-    public static void repair(String fileName) {\n-        PrintWriter pw = new PrintWriter(System.out);\n-        long version = Long.MAX_VALUE;\n-        OutputStream ignore = new OutputStream() {\n-            @Override\n-            public void write(int b) throws IOException {\n-                // ignore\n-            }\n-        };\n-        while (version >= 0) {\n-            pw.println(version == Long.MAX_VALUE ? \"Trying latest version\"\n-                    : (\"Trying version \" + version));\n-            pw.flush();\n-            version = rollback(fileName, version, new PrintWriter(ignore));\n-            try {\n-                String error = info(fileName + \".temp\", new PrintWriter(ignore));\n-                if (error == null) {\n-                    FilePath.get(fileName).moveTo(FilePath.get(fileName + \".back\"), true);\n-                    FilePath.get(fileName + \".temp\").moveTo(FilePath.get(fileName), true);\n-                    pw.println(\"Success\");\n-                    break;\n-                }\n-                pw.println(\"    ... failed: \" + error);\n-            } catch (Exception e) {\n-                pw.println(\"Fail: \" + e.getMessage());\n-                pw.flush();\n-            }\n-            version--;\n+  /**\n+   * Repair a store by rolling back to the newest good version.\n+   *\n+   * @param fileName the file name\n+   */\n+  public static void repair(String fileName) {\n+    PrintWriter pw = new PrintWriter(System.out);\n+    long version = Long.MAX_VALUE;\n+    OutputStream ignore = new OutputStream() {\n+      @Override\n+      public void write(int b) throws IOException {\n+        // ignore\n+      }\n+    };\n+    while (version >= 0) {\n+      pw.println(version == Long.MAX_VALUE ? \"Trying latest version\"\n+          : (\"Trying version \" + version));\n+      pw.flush();\n+      version = rollback(fileName, version, new PrintWriter(ignore));\n+      try {\n+        String error = info(fileName + \".temp\", new PrintWriter(ignore));\n+        if (error == null) {\n+          FilePath.get(fileName).moveTo(FilePath.get(fileName + \".back\"), true);\n+          FilePath.get(fileName + \".temp\").moveTo(FilePath.get(fileName), true);\n+          pw.println(\"Success\");\n+          break;\n         }\n+        pw.println(\"    ... failed: \" + error);\n+      } catch (Exception e) {\n+        pw.println(\"Fail: \" + e.getMessage());\n         pw.flush();\n+      }\n+      version--;\n     }\n+    pw.flush();\n+  }\n \n-    /**\n-     * Roll back to a given revision into a file called *.temp.\n-     *\n-     * @param fileName the file name\n-     * @param targetVersion the version to roll back to (Long.MAX_VALUE for the\n-     *            latest version)\n-     * @param writer the log writer\n-     * @return the version rolled back to (-1 if no version)\n-     */\n-    public static long rollback(String fileName, long targetVersion, Writer writer) {\n-        long newestVersion = -1;\n-        PrintWriter pw = new PrintWriter(writer, true);\n-        if (!FilePath.get(fileName).exists()) {\n-            pw.println(\"File not found: \" + fileName);\n-            return newestVersion;\n+  /**\n+   * Roll back to a given revision into a file called *.temp.\n+   *\n+   * @param fileName      the file name\n+   * @param targetVersion the version to roll back to (Long.MAX_VALUE for the\n+   *                      latest version)\n+   * @param writer        the log writer\n+   * @return the version rolled back to (-1 if no version)\n+   */\n+  public static long rollback(String fileName, long targetVersion, Writer writer) {\n+    long newestVersion = -1;\n+    PrintWriter pw = new PrintWriter(writer, true);\n+    if (!FilePath.get(fileName).exists()) {\n+      pw.println(\"File not found: \" + fileName);\n+      return newestVersion;\n+    }\n+    FileChannel file = null;\n+    FileChannel target = null;\n+    int blockSize = MVStore.BLOCK_SIZE;\n+    try {\n+      file = FilePath.get(fileName).open(\"r\");\n+      FilePath.get(fileName + \".temp\").delete();\n+      target = FilePath.get(fileName + \".temp\").open(\"rw\");\n+      long fileSize = file.size();\n+      ByteBuffer block = ByteBuffer.allocate(4096);\n+      Chunk newestChunk = null;\n+      for (long pos = 0; pos < fileSize; ) {\n+        block.rewind();\n+        DataUtils.readFully(file, pos, block);\n+        block.rewind();\n+        int headerType = block.get();\n+        if (headerType == 'H') {\n+          block.rewind();\n+          target.write(block, pos);\n+          pos += blockSize;\n+          continue;\n+        }\n+        if (headerType != 'c') {\n+          pos += blockSize;\n+          continue;\n         }\n-        FileChannel file = null;\n-        FileChannel target = null;\n-        int blockSize = MVStore.BLOCK_SIZE;\n+        Chunk c = null;\n         try {\n-            file = FilePath.get(fileName).open(\"r\");\n-            FilePath.get(fileName + \".temp\").delete();\n-            target = FilePath.get(fileName + \".temp\").open(\"rw\");\n-            long fileSize = file.size();\n-            ByteBuffer block = ByteBuffer.allocate(4096);\n-            Chunk newestChunk = null;\n-            for (long pos = 0; pos < fileSize;) {\n-                block.rewind();\n-                DataUtils.readFully(file, pos, block);\n-                block.rewind();\n-                int headerType = block.get();\n-                if (headerType == 'H') {\n-                    block.rewind();\n-                    target.write(block, pos);\n-                    pos += blockSize;\n-                    continue;\n-                }\n-                if (headerType != 'c') {\n-                    pos += blockSize;\n-                    continue;\n-                }\n-                Chunk c = null;\n-                try {\n-                    c = Chunk.readChunkHeader(block, pos);\n-                } catch (IllegalStateException e) {\n-                    pos += blockSize;\n-                    continue;\n-                }\n-                if (c.len <= 0) {\n-                    // not a chunk\n-                    pos += blockSize;\n-                    continue;\n-                }\n-                int length = c.len * MVStore.BLOCK_SIZE;\n-                ByteBuffer chunk = ByteBuffer.allocate(length);\n-                DataUtils.readFully(file, pos, chunk);\n-                if (c.version > targetVersion) {\n-                    // newer than the requested version\n-                    pos += length;\n-                    continue;\n-                }\n-                chunk.rewind();\n-                target.write(chunk, pos);\n-                if (newestChunk == null || c.version > newestChunk.version) {\n-                    newestChunk = c;\n-                    newestVersion = c.version;\n-                }\n-                pos += length;\n-            }\n-            int length = newestChunk.len * MVStore.BLOCK_SIZE;\n-            ByteBuffer chunk = ByteBuffer.allocate(length);\n-            DataUtils.readFully(file, newestChunk.block * MVStore.BLOCK_SIZE, chunk);\n-            chunk.rewind();\n-            target.write(chunk, fileSize);\n+          c = Chunk.readChunkHeader(block, pos);\n+        } catch (IllegalStateException e) {\n+          pos += blockSize;\n+          continue;\n+        }\n+        if (c.len <= 0) {\n+          // not a chunk\n+          pos += blockSize;\n+          continue;\n+        }\n+        int length = c.len * MVStore.BLOCK_SIZE;\n+        ByteBuffer chunk = ByteBuffer.allocate(length);\n+        DataUtils.readFully(file, pos, chunk);\n+        if (c.version > targetVersion) {\n+          // newer than the requested version\n+          pos += length;\n+          continue;\n+        }\n+        chunk.rewind();\n+        target.write(chunk, pos);\n+        if (newestChunk == null || c.version > newestChunk.version) {\n+          newestChunk = c;\n+          newestVersion = c.version;\n+        }\n+        pos += length;\n+      }\n+      int length = newestChunk.len * MVStore.BLOCK_SIZE;\n+      ByteBuffer chunk = ByteBuffer.allocate(length);\n+      DataUtils.readFully(file, newestChunk.block * MVStore.BLOCK_SIZE, chunk);\n+      chunk.rewind();\n+      target.write(chunk, fileSize);\n+    } catch (IOException e) {\n+      pw.println(\"ERROR: \" + e);\n+      e.printStackTrace(pw);\n+    } finally {\n+      if (file != null) {\n+        try {\n+          file.close();\n         } catch (IOException e) {\n-            pw.println(\"ERROR: \" + e);\n-            e.printStackTrace(pw);\n-        } finally {\n-            if (file != null) {\n-                try {\n-                    file.close();\n-                } catch (IOException e) {\n-                    // ignore\n-                }\n-            }\n-            if (target != null) {\n-                try {\n-                    target.close();\n-                } catch (IOException e) {\n-                    // ignore\n-                }\n-            }\n+          // ignore\n         }\n-        pw.flush();\n-        return newestVersion;\n+      }\n+      if (target != null) {\n+        try {\n+          target.close();\n+        } catch (IOException e) {\n+          // ignore\n+        }\n+      }\n     }\n+    pw.flush();\n+    return newestVersion;\n+  }\n \n-    /**\n-     * A data type that can read any data that is persisted, and converts it to\n-     * a byte array.\n-     */\n-    static class GenericDataType implements DataType {\n+  /**\n+   * A data type that can read any data that is persisted, and converts it to\n+   * a byte array.\n+   */\n+  static class GenericDataType implements DataType {\n \n-        @Override\n-        public int compare(Object a, Object b) {\n-            throw DataUtils.newUnsupportedOperationException(\"Can not compare\");\n-        }\n-\n-        @Override\n-        public int getMemory(Object obj) {\n-            return obj == null ? 0 : ((byte[]) obj).length * 8;\n-        }\n+    @Override\n+    public int compare(Object a, Object b) {\n+      throw DataUtils.newUnsupportedOperationException(\"Can not compare\");\n+    }\n \n-        @Override\n-        public void write(WriteBuffer buff, Object obj) {\n-            if (obj != null) {\n-                buff.put((byte[]) obj);\n-            }\n-        }\n+    @Override\n+    public int getMemory(Object obj) {\n+      return obj == null ? 0 : ((byte[]) obj).length * 8;\n+    }\n \n-        @Override\n-        public void write(WriteBuffer buff, Object[] obj, int len, boolean key) {\n-            for (Object o : obj) {\n-                write(buff, o);\n-            }\n-        }\n+    @Override\n+    public void write(WriteBuffer buff, Object obj) {\n+      if (obj != null) {\n+        buff.put((byte[]) obj);\n+      }\n+    }\n \n-        @Override\n-        public Object read(ByteBuffer buff) {\n-            int len = buff.remaining();\n-            if (len == 0) {\n-                return null;\n-            }\n-            byte[] data = new byte[len];\n-            buff.get(data);\n-            return data;\n-        }\n+    @Override\n+    public void write(WriteBuffer buff, Object[] obj, int len, boolean key) {\n+      for (Object o : obj) {\n+        write(buff, o);\n+      }\n+    }\n \n-        @Override\n-        public void read(ByteBuffer buff, Object[] obj, int len, boolean key) {\n-            for (int i = 0; i < obj.length; i++) {\n-                obj[i] = read(buff);\n-            }\n-        }\n+    @Override\n+    public Object read(ByteBuffer buff) {\n+      int len = buff.remaining();\n+      if (len == 0) {\n+        return null;\n+      }\n+      byte[] data = new byte[len];\n+      buff.get(data);\n+      return data;\n+    }\n \n+    @Override\n+    public void read(ByteBuffer buff, Object[] obj, int len, boolean key) {\n+      for (int i = 0; i < obj.length; i++) {\n+        obj[i] = read(buff);\n+      }\n     }\n \n+  }\n+\n \n }\n",
            "diff_size": 881
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/25/MVStoreTool.java\nindex 9bf1189574a..55ab54a8536 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/25/MVStoreTool.java\n@@ -510,7 +510,8 @@ public class MVStoreTool {\n         int autoCommitDelay = target.getAutoCommitDelay();\n         int retentionTime = target.getRetentionTime();\n         target.setAutoCommitDelay(0);\n-        target.setRetentionTime(Integer.MAX_VALUE); // disable unused chunks collection\n+        target.setRetentionTime(Integer.MAX_VALUE);\n+// disable unused chunks collection\n         MVMap<String, String> sourceMeta = source.getMetaMap();\n         MVMap<String, String> targetMeta = target.getMetaMap();\n         for (Entry<String, String> m : sourceMeta.entrySet()) {\n@@ -555,8 +556,7 @@ public class MVStoreTool {\n             }\n         };\n         while (version >= 0) {\n-            pw.println(version == Long.MAX_VALUE ? \"Trying latest version\"\n-                    : (\"Trying version \" + version));\n+            pw.println(version == Long.MAX_VALUE ? \"Trying latest version\" : (\"Trying version \" + version));\n             pw.flush();\n             version = rollback(fileName, version, new PrintWriter(ignore));\n             try {\n@@ -725,4 +725,4 @@ public class MVStoreTool {\n     }\n \n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 5
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "487",
                    "column": "53",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/25/MVStoreTool.java\nindex 9bf1189574a..2a9c48b321b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/25/MVStoreTool.java\n@@ -16,7 +16,6 @@ import java.sql.Timestamp;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.TreeMap;\n-\n import org.h2.compress.CompressDeflate;\n import org.h2.compress.CompressLZF;\n import org.h2.compress.Compressor;\n@@ -31,6 +30,8 @@ import org.h2.util.Utils;\n /**\n  * Utility methods used in combination with the MVStore.\n  */\n+\n+\n public class MVStoreTool {\n \n     /**\n@@ -49,6 +50,8 @@ public class MVStoreTool {\n      *\n      * @param args the command line arguments\n      */\n+\n+\n     public static void main(String... args) {\n         for (int i = 0; i < args.length; i++) {\n             if (\"-dump\".equals(args[i])) {\n@@ -57,20 +60,20 @@ public class MVStoreTool {\n             } else if (\"-info\".equals(args[i])) {\n                 String fileName = args[++i];\n                 info(fileName, new PrintWriter(System.out));\n-            } else if (\"-compact\".equals(args[i])) {\n-                String fileName = args[++i];\n-                compact(fileName, false);\n+                                              } else if (\"-compact\".equals(args[i])) {\n+                       String fileName = args[++i];\n+                       compact(fileName, false);\n             } else if (\"-compress\".equals(args[i])) {\n-                String fileName = args[++i];\n-                compact(fileName, true);\n+                                                         String fileName = args[++i];\n+                                                         compact(fileName, true);\n             } else if (\"-rollback\".equals(args[i])) {\n-                String fileName = args[++i];\n-                long targetVersion = Long.decode(args[++i]);\n-                rollback(fileName, targetVersion, new PrintWriter(System.out));\n-            } else if (\"-repair\".equals(args[i])) {\n-                String fileName = args[++i];\n-                repair(fileName);\n-            }\n+                       String fileName = args[++i];\n+                       long targetVersion = Long.decode(args[++i]);\n+                       rollback(fileName, targetVersion, new PrintWriter(System.out));\n+                   } else if (\"-repair\".equals(args[i])) {\n+                       String fileName = args[++i];\n+                       repair(fileName);\n+                   }\n         }\n     }\n \n@@ -80,6 +83,8 @@ public class MVStoreTool {\n      * @param fileName the name of the file\n      * @param details whether to print details\n      */\n+\n+\n     public static void dump(String fileName, boolean details) {\n         dump(fileName, new PrintWriter(System.out), details);\n     }\n@@ -89,6 +94,8 @@ public class MVStoreTool {\n      *\n      * @param fileName the name of the file\n      */\n+\n+\n     public static void info(String fileName) {\n         info(fileName, new PrintWriter(System.out));\n     }\n@@ -101,6 +108,8 @@ public class MVStoreTool {\n      * @param writer the print writer\n      * @param details print the page details\n      */\n+\n+\n     public static void dump(String fileName, Writer writer, boolean details) {\n         PrintWriter pw = new PrintWriter(writer, true);\n         if (!FilePath.get(fileName).exists()) {\n@@ -111,8 +120,7 @@ public class MVStoreTool {\n         pw.printf(\"File %s, %d bytes, %d MB\\n\", fileName, size, size / 1024 / 1024);\n         FileChannel file = null;\n         int blockSize = MVStore.BLOCK_SIZE;\n-        TreeMap<Integer, Long> mapSizesTotal =\n-                new TreeMap<>();\n+        TreeMap<Integer, Long> mapSizesTotal = new TreeMap< >();\n         long pageSizeTotal = 0;\n         try {\n             file = FilePath.get(fileName).open(\"r\");\n@@ -127,8 +135,7 @@ public class MVStoreTool {\n                 int headerType = block.get();\n                 if (headerType == 'H') {\n                     String header = new String(block.array(), StandardCharsets.ISO_8859_1).trim();\n-                    pw.printf(\"%0\" + len + \"x fileHeader %s%n\",\n-                            pos, header);\n+                    pw.printf(\"%0\" + len + \"x fileHeader %s%n\", pos, header);\n                     pos += blockSize;\n                     continue;\n                 }\n@@ -150,16 +157,14 @@ public class MVStoreTool {\n                     continue;\n                 }\n                 int length = c.len * MVStore.BLOCK_SIZE;\n-                pw.printf(\"%n%0\" + len + \"x chunkHeader %s%n\",\n-                        pos, c.toString());\n+                pw.printf(\"%n%0\" + len + \"x chunkHeader %s%n\", pos, c.toString());\n                 ByteBuffer chunk = ByteBuffer.allocate(length);\n                 DataUtils.readFully(file, pos, chunk);\n                 int p = block.position();\n                 pos += length;\n                 int remaining = c.pageCount;\n                 pageCount += c.pageCount;\n-                TreeMap<Integer, Integer> mapSizes =\n-                        new TreeMap<>();\n+                TreeMap<Integer, Integer> mapSizes = new TreeMap< >();\n                 int pageSizeSum = 0;\n                 while (remaining > 0) {\n                     int start = p;\n@@ -179,17 +184,7 @@ public class MVStoreTool {\n                     boolean compressed = (type & DataUtils.PAGE_COMPRESSED) != 0;\n                     boolean node = (type & 1) != 0;\n                     if (details) {\n-                        pw.printf(\n-                                \"+%0\" + len +\n-                                \"x %s, map %x, %d entries, %d bytes, maxLen %x%n\",\n-                                p,\n-                                (node ? \"node\" : \"leaf\") +\n-                                (compressed ? \" compressed\" : \"\"),\n-                                mapId,\n-                                node ? entries + 1 : entries,\n-                                pageSize,\n-                                DataUtils.getPageMaxLength(DataUtils.getPagePos(0, 0, pageSize, 0))\n-                                );\n+                        pw.printf(\"+%0\" + len + \"x %s, map %x, %d entries, %d bytes, maxLen %x%n\", p, (node ? \"node\" : \"leaf\") + (compressed ? \" compressed\" : \"\"), mapId, node ? entries + 1 : entries, pageSize, DataUtils.getPageMaxLength(DataUtils.getPagePos(0, 0, pageSize, 0)));\n                     }\n                     p += pageSize;\n                     Integer mapSize = mapSizes.get(mapId);\n@@ -242,21 +237,11 @@ public class MVStoreTool {\n                             // meta map node\n                             for (int i = 0; i < entries; i++) {\n                                 long cp = children[i];\n-                                pw.printf(\"    %d children < %s @ \" +\n-                                        \"chunk %x +%0\" +\n-                                        len + \"x%n\",\n-                                        counts[i],\n-                                        keys[i],\n-                                        DataUtils.getPageChunkId(cp),\n-                                        DataUtils.getPageOffset(cp));\n+                                pw.printf(\"    %d children < %s @ \" + \"chunk %x +%0\"\n+                                + len + \"x%n\", counts[i], keys[i], DataUtils.getPageChunkId(cp), DataUtils.getPageOffset(cp));\n                             }\n                             long cp = children[entries];\n-                            pw.printf(\"    %d children >= %s @ chunk %x +%0\" +\n-                                    len + \"x%n\",\n-                                    counts[entries],\n-                                    keys.length >= entries ? null : keys[entries],\n-                                    DataUtils.getPageChunkId(cp),\n-                                    DataUtils.getPageOffset(cp));\n+                            pw.printf(\"    %d children >= %s @ chunk %x +%0\" + len + \"x%n\", counts[entries], keys.length >= entries ? null : keys[entries], DataUtils.getPageChunkId(cp), DataUtils.getPageOffset(cp));\n                         } else {\n                             // meta map leaf\n                             String[] values = new String[entries];\n@@ -265,19 +250,14 @@ public class MVStoreTool {\n                                 values[i] = v;\n                             }\n                             for (int i = 0; i < entries; i++) {\n-                                pw.println(\"    \" + keys[i] +\n-                                        \" = \" + values[i]);\n+                                pw.println(\"    \" + keys[i] + \" = \" + values[i]);\n                             }\n                         }\n                     } else {\n                         if (node && details) {\n                             for (int i = 0; i <= entries; i++) {\n                                 long cp = children[i];\n-                                pw.printf(\"    %d children @ chunk %x +%0\" +\n-                                        len + \"x%n\",\n-                                        counts[i],\n-                                        DataUtils.getPageChunkId(cp),\n-                                        DataUtils.getPageOffset(cp));\n+                                pw.printf(\"    %d children @ chunk %x +%0\" + len + \"x%n\", counts[i], DataUtils.getPageChunkId(cp), DataUtils.getPageOffset(cp));\n                             }\n                         }\n                     }\n@@ -290,11 +270,7 @@ public class MVStoreTool {\n                 int footerPos = chunk.limit() - Chunk.FOOTER_LENGTH;\n                 try {\n                     chunk.position(footerPos);\n-                    pw.printf(\n-                            \"+%0\" + len + \"x chunkFooter %s%n\",\n-                            footerPos,\n-                            new String(chunk.array(), chunk.position(),\n-                                    Chunk.FOOTER_LENGTH, StandardCharsets.ISO_8859_1).trim());\n+                    pw.printf(\"+%0\" + len + \"x chunkFooter %s%n\", footerPos, new String(chunk.array(), chunk.position(), Chunk.FOOTER_LENGTH, StandardCharsets.ISO_8859_1).trim());\n                 } catch (IllegalArgumentException e) {\n                     // too far\n                     pw.printf(\"ERROR illegal footer position %d%n\", footerPos);\n@@ -303,8 +279,7 @@ public class MVStoreTool {\n             pw.printf(\"%n%0\" + len + \"x eof%n\", fileSize);\n             pw.printf(\"\\n\");\n             pageCount = Math.max(1, pageCount);\n-            pw.printf(\"page size total: %d bytes, page count: %d, average page size: %d bytes\\n\",\n-                    pageSizeTotal, pageCount, pageSizeTotal / pageCount);\n+            pw.printf(\"page size total: %d bytes, page count: %d, average page size: %d bytes\\n\", pageSizeTotal, pageCount, pageSizeTotal / pageCount);\n             pageSizeTotal = Math.max(1, pageSizeTotal);\n             for (Integer mapId : mapSizesTotal.keySet()) {\n                 int percent = (int) (100 * mapSizesTotal.get(mapId) / pageSizeTotal);\n@@ -319,6 +294,7 @@ public class MVStoreTool {\n                     file.close();\n                 } catch (IOException e) {\n                     // ignore\n+\n                 }\n             }\n         }\n@@ -337,6 +313,8 @@ public class MVStoreTool {\n      * @return null if successful (if there was no error), otherwise the error\n      *         message\n      */\n+\n+\n     public static String info(String fileName, Writer writer) {\n         PrintWriter pw = new PrintWriter(writer, true);\n         if (!FilePath.get(fileName).exists()) {\n@@ -344,14 +322,12 @@ public class MVStoreTool {\n             return \"File not found: \" + fileName;\n         }\n         long fileLength = FileUtils.size(fileName);\n-        MVStore store = new MVStore.Builder().\n-                fileName(fileName).\n-                readOnly().open();\n+        MVStore store = new MVStore.Builder().fileName(fileName).readOnly().open();\n         try {\n             MVMap<String, String> meta = store.getMetaMap();\n             Map<String, Object> header = store.getStoreHeader();\n             long fileCreated = DataUtils.readHexLong(header, \"created\", 0L);\n-            TreeMap<Integer, Chunk> chunks = new TreeMap<>();\n+            TreeMap<Integer, Chunk> chunks = new TreeMap< >();\n             long chunkLength = 0;\n             long maxLength = 0;\n             long maxLengthLive = 0;\n@@ -370,29 +346,20 @@ public class MVStoreTool {\n                 }\n             }\n             pw.printf(\"Created: %s\\n\", formatTimestamp(fileCreated, fileCreated));\n-            pw.printf(\"Last modified: %s\\n\",\n-                    formatTimestamp(FileUtils.lastModified(fileName), fileCreated));\n+            pw.printf(\"Last modified: %s\\n\", formatTimestamp(FileUtils.lastModified(fileName), fileCreated));\n             pw.printf(\"File length: %d\\n\", fileLength);\n             pw.printf(\"The last chunk is not listed\\n\");\n             pw.printf(\"Chunk length: %d\\n\", chunkLength);\n             pw.printf(\"Chunk count: %d\\n\", chunks.size());\n             pw.printf(\"Used space: %d%%\\n\", getPercent(chunkLength, fileLength));\n-            pw.printf(\"Chunk fill rate: %d%%\\n\", maxLength == 0 ? 100 :\n-                getPercent(maxLengthLive, maxLength));\n-            pw.printf(\"Chunk fill rate excluding empty chunks: %d%%\\n\",\n-                maxLengthNotEmpty == 0 ? 100 :\n-                getPercent(maxLengthLive, maxLengthNotEmpty));\n+            pw.printf(\"Chunk fill rate: %d%%\\n\", maxLength == 0 ? 100 : getPercent(maxLengthLive, maxLength));\n+            pw.printf(\"Chunk fill rate excluding empty chunks: %d%%\\n\", maxLengthNotEmpty == 0 ? 100 : getPercent(maxLengthLive, maxLengthNotEmpty));\n             for (Entry<Integer, Chunk> e : chunks.entrySet()) {\n                 Chunk c = e.getValue();\n                 long created = fileCreated + c.time;\n-                pw.printf(\"  Chunk %d: %s, %d%% used, %d blocks\",\n-                        c.id, formatTimestamp(created, fileCreated),\n-                        getPercent(c.maxLenLive, c.maxLen),\n-                        c.len\n-                        );\n+                pw.printf(\"  Chunk %d: %s, %d%% used, %d blocks\", c.id, formatTimestamp(created, fileCreated), getPercent(c.maxLenLive, c.maxLen), c.len);\n                 if (c.maxLenLive == 0) {\n-                    pw.printf(\", unused: %s\",\n-                            formatTimestamp(fileCreated + c.unused, fileCreated));\n+                    pw.printf(\", unused: %s\", formatTimestamp(fileCreated + c.unused, fileCreated));\n                 }\n                 pw.printf(\"\\n\");\n             }\n@@ -435,6 +402,8 @@ public class MVStoreTool {\n      * @param fileName the file name\n      * @param compress whether to compress the data\n      */\n+\n+\n     public static void compact(String fileName, boolean compress) {\n         String tempName = fileName + Constants.SUFFIX_MV_STORE_TEMP_FILE;\n         FileUtils.delete(tempName);\n@@ -458,6 +427,8 @@ public class MVStoreTool {\n      *\n      * @param fileName the file name\n      */\n+\n+\n     public static void compactCleanUp(String fileName) {\n         String tempName = fileName + Constants.SUFFIX_MV_STORE_TEMP_FILE;\n         if (FileUtils.exists(tempName)) {\n@@ -480,17 +451,18 @@ public class MVStoreTool {\n      * @param targetFileName the name of the target store\n      * @param compress whether to compress the data\n      */\n-    public static void compact(String sourceFileName, String targetFileName, boolean compress) {\n-        try (MVStore source = new MVStore.Builder().\n-                fileName(sourceFileName).readOnly().open()) {\n+\n+\n+    public static void compact(String sourceFileName,\n+        String targetFileName, boolean compress) {\n+        try (MVStore source = new MVStore.Builder().fileName(sourceFileName).readOnly().open()) {\n             // Bugfix - Add double \"try-finally\" statements to close source and target stores for\n             //releasing lock and file resources in these stores even if OOM occurs.\n             // Fix issues such as \"Cannot delete file \"/h2/data/test.mv.db.tempFile\" [90025-197]\"\n             //when client connects to this server and reopens this store database in this process.\n             // @since 2018-09-13 little-pan\n             FileUtils.delete(targetFileName);\n-            MVStore.Builder b = new MVStore.Builder().\n-                fileName(targetFileName);\n+            MVStore.Builder b = new MVStore.Builder().fileName(targetFileName);\n             if (compress) {\n                 b.compress();\n             }\n@@ -506,6 +478,8 @@ public class MVStoreTool {\n      * @param source the source store\n      * @param target the target store\n      */\n+\n+\n     public static void compact(MVStore source, MVStore target) {\n         int autoCommitDelay = target.getAutoCommitDelay();\n         int retentionTime = target.getRetentionTime();\n@@ -517,21 +491,22 @@ public class MVStoreTool {\n             String key = m.getKey();\n             if (key.startsWith(\"chunk.\")) {\n                 // ignore\n+\n             } else if (key.startsWith(\"map.\")) {\n                 // ignore\n+\n             } else if (key.startsWith(\"name.\")) {\n                 // ignore\n-            } else if (key.startsWith(\"root.\")) {\n+\n+                   } else if (key.startsWith(\"root.\")) {\n                 // ignore\n-            } else {\n-                targetMeta.put(key, m.getValue());\n-            }\n+\n+                   } else {\n+                       targetMeta.put(key, m.getValue());\n+                   }\n         }\n         for (String mapName : source.getMapNames()) {\n-            MVMap.Builder<Object, Object> mp =\n-                    new MVMap.Builder<>().\n-                    keyType(new GenericDataType()).\n-                    valueType(new GenericDataType());\n+            MVMap.Builder<Object, Object> mp = new MVMap.Builder< >().keyType(new GenericDataType()).valueType(new GenericDataType());\n             MVMap<Object, Object> sourceMap = source.openMap(mapName, mp);\n             MVMap<Object, Object> targetMap = target.openMap(mapName, mp);\n             targetMap.copyFrom(sourceMap);\n@@ -545,18 +520,20 @@ public class MVStoreTool {\n      *\n      * @param fileName the file name\n      */\n+\n+\n     public static void repair(String fileName) {\n         PrintWriter pw = new PrintWriter(System.out);\n         long version = Long.MAX_VALUE;\n         OutputStream ignore = new OutputStream() {\n-            @Override\n-            public void write(int b) throws IOException {\n+                         @Override\n+                         public void write(int b) throws IOException {\n                 // ignore\n-            }\n-        };\n+\n+                         }\n+                     };\n         while (version >= 0) {\n-            pw.println(version == Long.MAX_VALUE ? \"Trying latest version\"\n-                    : (\"Trying version \" + version));\n+            pw.println(version == Long.MAX_VALUE ? \"Trying latest version\" : (\"Trying version \" + version));\n             pw.flush();\n             version = rollback(fileName, version, new PrintWriter(ignore));\n             try {\n@@ -586,6 +563,8 @@ public class MVStoreTool {\n      * @param writer the log writer\n      * @return the version rolled back to (-1 if no version)\n      */\n+\n+\n     public static long rollback(String fileName, long targetVersion, Writer writer) {\n         long newestVersion = -1;\n         PrintWriter pw = new PrintWriter(writer, true);\n@@ -660,6 +639,7 @@ public class MVStoreTool {\n                     file.close();\n                 } catch (IOException e) {\n                     // ignore\n+\n                 }\n             }\n             if (target != null) {\n@@ -667,6 +647,7 @@ public class MVStoreTool {\n                     target.close();\n                 } catch (IOException e) {\n                     // ignore\n+\n                 }\n             }\n         }\n@@ -678,8 +659,9 @@ public class MVStoreTool {\n      * A data type that can read any data that is persisted, and converts it to\n      * a byte array.\n      */\n-    static class GenericDataType implements DataType {\n \n+\n+    static class GenericDataType implements DataType {\n         @Override\n         public int compare(Object a, Object b) {\n             throw DataUtils.newUnsupportedOperationException(\"Can not compare\");\n@@ -724,5 +706,4 @@ public class MVStoreTool {\n \n     }\n \n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 133
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/25/MVStoreTool.java\nindex 9bf1189574a..1e69c88703c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/25/MVStoreTool.java\n@@ -510,8 +510,9 @@ public class MVStoreTool {\n         int autoCommitDelay = target.getAutoCommitDelay();\n         int retentionTime = target.getRetentionTime();\n         target.setAutoCommitDelay(0);\n-        target.setRetentionTime(Integer.MAX_VALUE); // disable unused chunks collection\n-        MVMap<String, String> sourceMeta = source.getMetaMap();\n+        target.setRetentionTime(Integer.MAX_VALUE);\n+        // disable unused chunks collection\n+         MVMap<String, String> sourceMeta = source.getMetaMap();\n         MVMap<String, String> targetMeta = target.getMetaMap();\n         for (Entry<String, String> m : sourceMeta.entrySet()) {\n             String key = m.getKey();\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/25/MVStoreTool.java\nindex 9bf1189574a..682d85512e5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/25/MVStoreTool.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/25/MVStoreTool.java\n@@ -510,8 +510,9 @@ public class MVStoreTool {\n         int autoCommitDelay = target.getAutoCommitDelay();\n         int retentionTime = target.getRetentionTime();\n         target.setAutoCommitDelay(0);\n-        target.setRetentionTime(Integer.MAX_VALUE); // disable unused chunks collection\n-        MVMap<String, String> sourceMeta = source.getMetaMap();\n+        target.setRetentionTime(Integer.MAX_VALUE);\n+            // disable unused chunks collection\n+         MVMap<String, String> sourceMeta = source.getMetaMap();\n         MVMap<String, String> targetMeta = target.getMetaMap();\n         for (Entry<String, String> m : sourceMeta.entrySet()) {\n             String key = m.getKey();\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}