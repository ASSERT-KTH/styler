{
    "project_name": "graphfoundation-ongdb",
    "error_id": "2136",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "53",
                    "column": "25",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "53",
                    "column": "42",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "68",
                    "column": "23",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "68",
                    "column": "40",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "86",
                    "column": "23",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "86",
                    "column": "81",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "106",
                    "column": "33",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "106",
                    "column": "50",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "121",
                    "column": "37",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "121",
                    "column": "54",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "139",
                    "column": "37",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "140",
                    "column": "77",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "160",
                    "column": "39",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "160",
                    "column": "80",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "177",
                    "column": "26",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "177",
                    "column": "93",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "194",
                    "column": "29",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "194",
                    "column": "82",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2136/IndexManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/2136/IndexManager.java\nindex 16fb69e937d..0d3b763ec78 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2136/IndexManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/2136/IndexManager.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.graphdb.index;\n \n import java.util.Map;\n@@ -34,173 +35,175 @@ import org.neo4j.graphdb.Relationship;\n  */\n public interface IndexManager\n {\n-    /**\n-     * The configuration key to use for specifying which provider an index\n-     * will have, i.e. which implementation will be used to back that index.\n-     */\n-    String PROVIDER = \"provider\";\n-\n-    /**\n-     * Returns whether or not there exists a node index with the name\n-     * {@code indexName}. Indexes are created when needed in calls to\n-     * {@link #forNodes(String)} and {@link #forNodes(String, Map)}.\n-     * @param indexName the name of the index to check.\n-     * @return whether or not there exists a node index with the name\n-     * {@code indexName}.\n-     */\n-    boolean existsForNodes( String indexName );\n-\n-    /**\n-     * Returns an {@link Index} for {@link Node}s with the name {@code indexName}.\n-     * If such an index doesn't exist it will be created with default configuration.\n-     * Indexes created with {@link #forNodes(String, Map)} can be returned by this\n-     * method also, so that you don't have to supply and match its configuration\n-     * for consecutive accesses.\n-     *\n-     * This is the prefered way of accessing indexes, whether they were created with\n-     * {#forNodes(String)} or {@link #forNodes(String, Map)}.\n-     *\n-     * @param indexName the name of the node index.\n-     * @return the {@link Index} corresponding to the {@code indexName}.\n-     */\n-    Index<Node> forNodes( String indexName );\n-\n-    /**\n-     * Returns an {@link Index} for {@link Node}s with the name {@code indexName}.\n-     * If the index exists it will be returned if the provider and customConfiguration\n-     * matches, else an {@link IllegalArgumentException} will be thrown.\n-     * If the index doesn't exist it will be created with the given\n-     * provider (given in the configuration map).\n-     *\n-     * @param indexName the name of the index to create.\n-     * @param customConfiguration configuration for the index being created.\n-     * Use the <b>provider</b> key to control which index implementation to use for this index if it's created.\n-     * The value represents the service name corresponding to the index implementation.\n-     * Other options can f.ex. say that the index will be a fulltext index and that it\n-     * should be case insensitive. The parameters given here (except \"provider\") are\n-     * only interpreted by the implementation represented by the provider.\n-     * @return a named {@link Index} for {@link Node}s\n-     */\n-    Index<Node> forNodes( String indexName, Map<String, String> customConfiguration );\n-\n-    /**\n-     * Returns the names of all existing {@link Node} indexes.\n-     * Those names can then be used to get to the actual {@link Index}\n-     * instances.\n-     *\n-     * @return the names of all existing {@link Node} indexes.\n-     */\n-    String[] nodeIndexNames();\n-\n-    /**\n-     * Returns whether or not there exists a relationship index with the name\n-     * {@code indexName}. Indexes are created when needed in calls to\n-     * {@link #forRelationships(String)} and {@link #forRelationships(String, Map)}.\n-     * @param indexName the name of the index to check.\n-     * @return whether or not there exists a relationship index with the name\n-     * {@code indexName}.\n-     */\n-    boolean existsForRelationships( String indexName );\n-\n-    /**\n-     * Returns an {@link Index} for {@link Relationship}s with the name {@code indexName}.\n-     * If such an index doesn't exist it will be created with default configuration.\n-     * Indexes created with {@link #forRelationships(String, Map)} can be returned by this\n-     * method also, so that you don't have to supply and match its configuration\n-     * for consecutive accesses.\n-     *\n-     * This is the prefered way of accessing indexes, whether they were created with\n-     * {@link #forRelationships(String)} or {@link #forRelationships(String, Map)}.\n-     *\n-     * @param indexName the name of the node index.\n-     * @return the {@link Index} corresponding to the {@code indexName}.\n-     */\n-    RelationshipIndex forRelationships( String indexName );\n-\n-    /**\n-     * Returns an {@link Index} for {@link Relationship}s with the name {@code indexName}.\n-     * If the index exists it will be returned if the provider and customConfiguration\n-     * matches, else an {@link IllegalArgumentException} will be thrown.\n-     * If the index doesn't exist it will be created with the given\n-     * provider (given in the configuration map).\n-     *\n-     * @param indexName the name of the index to create.\n-     * @param customConfiguration configuration for the index being created.\n-     * Use the <b>provider</b> key to control which index implementation. The\n-     * value represents the service name corresponding to the index provider implementation.\n-     * Other options can f.ex. say that the index will be a fulltext index and that it\n-     * should be case insensitive. The parameters given here (except \"provider\") are\n-     * only interpreted by the implementation represented by the provider.\n-     * @return a named {@link Index} for {@link Relationship}s\n-     */\n-    RelationshipIndex forRelationships( String indexName,\n-            Map<String, String> customConfiguration );\n-\n-    /**\n-     * Returns the names of all existing {@link Relationship} indexes.\n-     * Those names can then be used to get to the actual {@link Index}\n-     * instances.\n-     *\n-     * @return the names of all existing {@link Relationship} indexes.\n-     */\n-    String[] relationshipIndexNames();\n-\n-    /**\n-     * Returns the configuration for {@code index}. Configuration can be\n-     * set when creating an index, with f.ex {@link #forNodes(String, Map)}\n-     * or with {@link #setConfiguration(Index, String, String)} or\n-     * {@link #removeConfiguration(Index, String)}.\n-     *\n-     * @param index the index to get the configuration for\n-     * @return configuration for the {@code index}.\n-     */\n-    Map<String, String> getConfiguration( Index<? extends PropertyContainer> index );\n-\n-    /**\n-     * EXPERT: Sets a configuration parameter for an index. If a configuration\n-     * parameter with the given {@code key} it will be overwritten.\n-     *\n-     * WARNING: Overwriting parameters which controls the storage format of index\n-     * data may lead to existing index data being unusable.\n-     *\n-     * The key \"provider\" is a reserved parameter and cannot be overwritten,\n-     * if key is \"provider\" then an {@link IllegalArgumentException} will be thrown.\n-     *\n-     * @param index the index to set a configuration parameter for.\n-     * @param key the configuration parameter key.\n-     * @param value the new value of the configuration parameter.\n-     * @return the overwritten value if any.\n-     */\n-    String setConfiguration( Index<? extends PropertyContainer> index, String key, String value );\n-\n-    /**\n-     * EXPERT: Removes a configuration parameter from an index. If there's no\n-     * value for the given {@code key} nothing will happen and {@code null}\n-     * will be returned.\n-     *\n-     * WARNING: Removing parameters which controls the storage format of index\n-     * data may lead to existing index data being unusable.\n-     *\n-     * The key \"provider\" is a reserved parameter and cannot be removed,\n-     * if key is \"provider\" then an {@link IllegalArgumentException} will be thrown.\n-     *\n-     * @param index the index to remove a configuration parameter from.\n-     * @param key the configuration parameter key.\n-     * @return the removed value if any.\n-     */\n-    String removeConfiguration( Index<? extends PropertyContainer> index, String key );\n-\n-    /**\n-     * @deprecated this feature will be removed in a future release, please consider using schema indexes instead\n-     * @return the auto indexing manager for nodes\n-     */\n-    @Deprecated\n-    AutoIndexer<Node> getNodeAutoIndexer();\n-\n-    /**\n-     * @deprecated this feature will be removed in a future release, please consider using schema indexes instead\n-     * @return the auto indexing manager for relationships\n-     */\n-    @Deprecated\n-    RelationshipAutoIndexer getRelationshipAutoIndexer();\n+  /**\n+   * The configuration key to use for specifying which provider an index\n+   * will have, i.e. which implementation will be used to back that index.\n+   */\n+  String PROVIDER = \"provider\";\n+\n+  /**\n+   * Returns whether or not there exists a node index with the name\n+   * {@code indexName}. Indexes are created when needed in calls to\n+   * {@link #forNodes(String)} and {@link #forNodes(String, Map)}.\n+   *\n+   * @param indexName the name of the index to check.\n+   * @return whether or not there exists a node index with the name\n+   * {@code indexName}.\n+   */\n+  boolean existsForNodes(String indexName);\n+\n+  /**\n+   * Returns an {@link Index} for {@link Node}s with the name {@code indexName}.\n+   * If such an index doesn't exist it will be created with default configuration.\n+   * Indexes created with {@link #forNodes(String, Map)} can be returned by this\n+   * method also, so that you don't have to supply and match its configuration\n+   * for consecutive accesses.\n+   * <p>\n+   * This is the prefered way of accessing indexes, whether they were created with\n+   * {#forNodes(String)} or {@link #forNodes(String, Map)}.\n+   *\n+   * @param indexName the name of the node index.\n+   * @return the {@link Index} corresponding to the {@code indexName}.\n+   */\n+  Index<Node> forNodes(String indexName);\n+\n+  /**\n+   * Returns an {@link Index} for {@link Node}s with the name {@code indexName}.\n+   * If the index exists it will be returned if the provider and customConfiguration\n+   * matches, else an {@link IllegalArgumentException} will be thrown.\n+   * If the index doesn't exist it will be created with the given\n+   * provider (given in the configuration map).\n+   *\n+   * @param indexName           the name of the index to create.\n+   * @param customConfiguration configuration for the index being created.\n+   *                            Use the <b>provider</b> key to control which index implementation to use for this index if it's created.\n+   *                            The value represents the service name corresponding to the index implementation.\n+   *                            Other options can f.ex. say that the index will be a fulltext index and that it\n+   *                            should be case insensitive. The parameters given here (except \"provider\") are\n+   *                            only interpreted by the implementation represented by the provider.\n+   * @return a named {@link Index} for {@link Node}s\n+   */\n+  Index<Node> forNodes(String indexName, Map<String, String> customConfiguration);\n+\n+  /**\n+   * Returns the names of all existing {@link Node} indexes.\n+   * Those names can then be used to get to the actual {@link Index}\n+   * instances.\n+   *\n+   * @return the names of all existing {@link Node} indexes.\n+   */\n+  String[] nodeIndexNames();\n+\n+  /**\n+   * Returns whether or not there exists a relationship index with the name\n+   * {@code indexName}. Indexes are created when needed in calls to\n+   * {@link #forRelationships(String)} and {@link #forRelationships(String, Map)}.\n+   *\n+   * @param indexName the name of the index to check.\n+   * @return whether or not there exists a relationship index with the name\n+   * {@code indexName}.\n+   */\n+  boolean existsForRelationships(String indexName);\n+\n+  /**\n+   * Returns an {@link Index} for {@link Relationship}s with the name {@code indexName}.\n+   * If such an index doesn't exist it will be created with default configuration.\n+   * Indexes created with {@link #forRelationships(String, Map)} can be returned by this\n+   * method also, so that you don't have to supply and match its configuration\n+   * for consecutive accesses.\n+   * <p>\n+   * This is the prefered way of accessing indexes, whether they were created with\n+   * {@link #forRelationships(String)} or {@link #forRelationships(String, Map)}.\n+   *\n+   * @param indexName the name of the node index.\n+   * @return the {@link Index} corresponding to the {@code indexName}.\n+   */\n+  RelationshipIndex forRelationships(String indexName);\n+\n+  /**\n+   * Returns an {@link Index} for {@link Relationship}s with the name {@code indexName}.\n+   * If the index exists it will be returned if the provider and customConfiguration\n+   * matches, else an {@link IllegalArgumentException} will be thrown.\n+   * If the index doesn't exist it will be created with the given\n+   * provider (given in the configuration map).\n+   *\n+   * @param indexName           the name of the index to create.\n+   * @param customConfiguration configuration for the index being created.\n+   *                            Use the <b>provider</b> key to control which index implementation. The\n+   *                            value represents the service name corresponding to the index provider implementation.\n+   *                            Other options can f.ex. say that the index will be a fulltext index and that it\n+   *                            should be case insensitive. The parameters given here (except \"provider\") are\n+   *                            only interpreted by the implementation represented by the provider.\n+   * @return a named {@link Index} for {@link Relationship}s\n+   */\n+  RelationshipIndex forRelationships(String indexName,\n+                                     Map<String, String> customConfiguration);\n+\n+  /**\n+   * Returns the names of all existing {@link Relationship} indexes.\n+   * Those names can then be used to get to the actual {@link Index}\n+   * instances.\n+   *\n+   * @return the names of all existing {@link Relationship} indexes.\n+   */\n+  String[] relationshipIndexNames();\n+\n+  /**\n+   * Returns the configuration for {@code index}. Configuration can be\n+   * set when creating an index, with f.ex {@link #forNodes(String, Map)}\n+   * or with {@link #setConfiguration(Index, String, String)} or\n+   * {@link #removeConfiguration(Index, String)}.\n+   *\n+   * @param index the index to get the configuration for\n+   * @return configuration for the {@code index}.\n+   */\n+  Map<String, String> getConfiguration(Index<? extends PropertyContainer> index);\n+\n+  /**\n+   * EXPERT: Sets a configuration parameter for an index. If a configuration\n+   * parameter with the given {@code key} it will be overwritten.\n+   * <p>\n+   * WARNING: Overwriting parameters which controls the storage format of index\n+   * data may lead to existing index data being unusable.\n+   * <p>\n+   * The key \"provider\" is a reserved parameter and cannot be overwritten,\n+   * if key is \"provider\" then an {@link IllegalArgumentException} will be thrown.\n+   *\n+   * @param index the index to set a configuration parameter for.\n+   * @param key   the configuration parameter key.\n+   * @param value the new value of the configuration parameter.\n+   * @return the overwritten value if any.\n+   */\n+  String setConfiguration(Index<? extends PropertyContainer> index, String key, String value);\n+\n+  /**\n+   * EXPERT: Removes a configuration parameter from an index. If there's no\n+   * value for the given {@code key} nothing will happen and {@code null}\n+   * will be returned.\n+   * <p>\n+   * WARNING: Removing parameters which controls the storage format of index\n+   * data may lead to existing index data being unusable.\n+   * <p>\n+   * The key \"provider\" is a reserved parameter and cannot be removed,\n+   * if key is \"provider\" then an {@link IllegalArgumentException} will be thrown.\n+   *\n+   * @param index the index to remove a configuration parameter from.\n+   * @param key   the configuration parameter key.\n+   * @return the removed value if any.\n+   */\n+  String removeConfiguration(Index<? extends PropertyContainer> index, String key);\n+\n+  /**\n+   * @return the auto indexing manager for nodes\n+   * @deprecated this feature will be removed in a future release, please consider using schema indexes instead\n+   */\n+  @Deprecated\n+  AutoIndexer<Node> getNodeAutoIndexer();\n+\n+  /**\n+   * @return the auto indexing manager for relationships\n+   * @deprecated this feature will be removed in a future release, please consider using schema indexes instead\n+   */\n+  @Deprecated\n+  RelationshipAutoIndexer getRelationshipAutoIndexer();\n }\n",
            "diff_size": 172
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2136/IndexManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/2136/IndexManager.java\nindex 16fb69e937d..d91cf65a6c3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2136/IndexManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/2136/IndexManager.java\n@@ -81,7 +81,7 @@ public interface IndexManager\n      * only interpreted by the implementation represented by the provider.\n      * @return a named {@link Index} for {@link Node}s\n      */\n-    Index<Node> forNodes( String indexName, Map<String, String> customConfiguration );\n+    Index<Node> forNodes( String indexName, Map<String,String> customConfiguration );\n \n     /**\n      * Returns the names of all existing {@link Node} indexes.\n@@ -133,10 +133,9 @@ public interface IndexManager\n      * only interpreted by the implementation represented by the provider.\n      * @return a named {@link Index} for {@link Relationship}s\n      */\n-    RelationshipIndex forRelationships( String indexName,\n-            Map<String, String> customConfiguration );\n+    RelationshipIndex forRelationships( String indexName, Map<String,String> customConfiguration );\n \n-    /**\n+/**\n      * Returns the names of all existing {@link Relationship} indexes.\n      * Those names can then be used to get to the actual {@link Index}\n      * instances.\n@@ -154,7 +153,7 @@ public interface IndexManager\n      * @param index the index to get the configuration for\n      * @return configuration for the {@code index}.\n      */\n-    Map<String, String> getConfiguration( Index<? extends PropertyContainer> index );\n+    Map<String,String> getConfiguration( Index<? extends PropertyContainer> index );\n \n     /**\n      * EXPERT: Sets a configuration parameter for an index. If a configuration\n@@ -203,4 +202,4 @@ public interface IndexManager\n      */\n     @Deprecated\n     RelationshipAutoIndexer getRelationshipAutoIndexer();\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 6
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}