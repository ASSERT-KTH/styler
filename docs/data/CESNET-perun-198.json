{
    "project_name": "CESNET-perun",
    "error_id": "198",
    "information": {
        "errors": [
            {
                "line": "856",
                "severity": "error",
                "message": "Line matches the illegal pattern 'Wrong number of tabs before space on next line. Indent must use tab characters.'.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpCheck"
            }
        ]
    },
    "source_code": "\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t  // 14) IN OTHER CASES\n\t\t} else {\n\t\t\tlog.debug(\"Nothing to resolve for message with number : \" + idOfMessage);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/198/EventProcessorImpl.java\nindex a11ed424452..8b682c3827e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/198/EventProcessorImpl.java\n@@ -854,7 +854,7 @@ public class EventProcessorImpl implements EventProcessor, Runnable {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t  // 14) IN OTHER CASES\n+\t\t// 14) IN OTHER CASES\n \t\t} else {\n \t\t\tlog.debug(\"Nothing to resolve for message with number : \" + idOfMessage);\n \t\t}\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/198/EventProcessorImpl.java\nindex a11ed424452..14ad888846c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/198/EventProcessorImpl.java\n@@ -23,6 +23,7 @@ import cz.metacentrum.perun.ldapc.processor.EventProcessor;\n import cz.metacentrum.perun.ldapc.processor.LdapConnector;\n import cz.metacentrum.perun.ldapc.service.LdapcManager;\n import cz.metacentrum.perun.rpclib.Rpc;\n+\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n import java.util.ArrayList;\n@@ -42,1397 +43,1527 @@ import javax.naming.directory.Attribute;\n @org.springframework.stereotype.Service(value = \"eventProcessor\")\n public class EventProcessorImpl implements EventProcessor, Runnable {\n \n-\t//Autowired variables\n-\t@Autowired\n-\tprivate LdapConnector ldapConnector;\n-\t@Autowired\n-\tprivate LdapcManager ldapcManager;\n-\t@Autowired\n-\tprivate LdapProperties ldapProperties;\n-\n-\t//Other variables\n-\tprivate AuditerConsumer auditerConsumer;\n-\tprivate final static Logger log = LoggerFactory.getLogger(EventProcessorImpl.class);\n-\tprivate boolean running = false;\n-\n-\t//All parsable and useable objects\n-\tResource resource;\n-\tMember member;\n-\tGroup group;\n-\tGroup parentGroup;\n-\tVo vo;\n-\tUser user;\n-\tUser specificUser;\n-\tFacility facility;\n-\tcz.metacentrum.perun.core.api.Attribute attribute;\n-\tAttributeDefinition attributeDef;\n-\tUserExtSource userExtSource;\n-\n-\t//PATTERNS (used for searching in messages)\n-\t//Common patterns\n-\tprivate Pattern deletedPattern = Pattern.compile(\" deleted.$\");\n-\tprivate Pattern createdPattern = Pattern.compile(\" created.$\");\n-\tprivate Pattern updatedPattern = Pattern.compile(\" updated.$\");\n-\t//Resources patterns\n-\tprivate Pattern deletedResourcePattern = Pattern.compile(\" deleted.#Facility\");\n-\t//Groups patterns\n-\tprivate Pattern newGroupPattern = Pattern.compile(\" created in Vo:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern subGroupPattern = Pattern.compile(\" created in Vo:\\\\[(.*)\\\\] as subgroup of Group:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern assignGroupToResourcePattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] assigned to Resource:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\tprivate Pattern removeGroupFromResourcePattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] removed from Resource:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\tprivate Pattern moveGroupPattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] was moved\\\\.$\", Pattern.DOTALL);\n-\t//Members patterns\n-\tprivate Pattern addedToPattern = Pattern.compile(\" added to Group:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern totallyRemovedFromPatter = Pattern.compile(\" was removed from Group:\\\\[(.*)\\\\] totally\", Pattern.DOTALL);\n-\tprivate Pattern validatedPattern = Pattern.compile(\" validated.$\");\n-\tprivate Pattern otherStateOfMemberPattern = Pattern.compile(\"expired.$|disabled.$|invalidated.$|suspended #\");\n-\t//Attributes patterns\n-\tprivate Pattern facilitySetPattern = Pattern.compile(\" set for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern facilityRemovePattern = Pattern.compile(\" removed for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern facilityAllAttrsRemovedPattern = Pattern.compile(\"^All attributes removed for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\n-\tprivate Pattern userSetPattern = Pattern.compile(\" set for User:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern userRemovePattern = Pattern.compile(\" removed for User:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern userAllAttrsRemovedPattern = Pattern.compile(\"^All attributes removed for User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\n-\tprivate Pattern userUidNamespacePattern = Pattern.compile(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":uid-namespace:\");\n-\tprivate Pattern userLoginNamespacePattern = Pattern.compile(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":login-namespace:\");\n-\t//UserExtSources patterns\n-\tprivate Pattern addUserExtSourcePattern = Pattern.compile(\"^UserExtSource:\\\\[(.*)\\\\] added to User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\tprivate Pattern removeUserExtSourcePattern = Pattern.compile(\"^UserExtSource:\\\\[(.*)\\\\] removed from User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\n-\t//CONSTANTS\n-\tprivate static final String LDAP_NAME = \"ldap\";\n-\tprivate static final String PATH_TO_ERROR_FILE = \"./errorParseMessageForLDAP.log\";\n-\tprivate static final String PATH_TO_NOT_EXECUTED_ERROR_FILE = \"./notExecutedMessages.log\";\n-\tprivate static final DateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n-\n-\t//PERUN ATTRIBUTES NAMES\n-\tpublic static final String perunAttrPreferredMail = \"preferredMail\";\n-\tpublic static final String perunAttrMail = \"mail\";\n-\tpublic static final String perunAttrOrganization = \"organization\";\n-\tpublic static final String perunAttrPhone = \"phone\";\n-\tpublic static final String perunAttrUserCertDNs = \"userCertDNs\";\n-\tpublic static final String perunAttrBonaFideStatus = \"elixirBonaFideStatus\";\n-\tpublic static final String perunAttrSchacHomeOrganizations = \"schacHomeOrganizations\";\n-\tpublic static final String perunAttrEduPersonScopedAffiliations = \"eduPersonScopedAffiliations\";\n-\tpublic static final String perunAttrLibraryIDs = \"libraryIDs\";\n-\tpublic static final String perunAttrEntityID = \"entityID\";\n-\tpublic static final String perunAttrClientID = \"OIDCClientID\";\n-\tpublic static final String perunAttrGroupNames = \"groupNames\";\n-\tpublic static final String perunAttrInstitutionsCountries = \"institutionsCountries\";\n-\n-\t//LDAP ATTRIBUTES NAMES\n-\tpublic static final String ldapAttrAssignedToResourceId = \"assignedToResourceId\";\n-\tpublic static final String ldapAttrAssignedGroupId = \"assignedGroupId\";\n-\tpublic static final String ldapAttrDescription = \"description\";\n-\tpublic static final String ldapAttrCommonName = \"cn\";\n-\tpublic static final String ldapAttrPerunUniqueGroupName= \"perunUniqueGroupName\";\n-\tpublic static final String ldapAttrEduPersonPrincipalNames = \"eduPersonPrincipalNames\";\n-\tpublic static final String ldapAttrPreferredMail = perunAttrPreferredMail;\n-\tpublic static final String ldapAttrMail = perunAttrMail;\n-\tpublic static final String ldapAttrOrganization = \"o\";\n-\tpublic static final String ldapAttrTelephoneNumber = \"telephoneNumber\";\n-\tpublic static final String ldapAttrUserCertDNs = \"userCertificateSubject\";\n-\tpublic static final String ldapAttrBonaFideStatus = \"bonaFideStatus\";\n-\tpublic static final String ldapAttrSchacHomeOrganizations = perunAttrSchacHomeOrganizations;\n-\tpublic static final String ldapAttrEduPersonScopedAffiliations = perunAttrEduPersonScopedAffiliations;\n-\tpublic static final String ldapAttrLibraryIDs = perunAttrLibraryIDs;\n-\tpublic static final String ldapAttrUidNumber = \"uidNumber;x-ns-\";\n-\tpublic static final String ldapAttrLogin = \"login;x-ns-\";\n-\tpublic static final String ldapAttrUserPassword = \"userPassword\";\n-\tpublic static final String ldapAttrSurname = \"sn\";\n-\tpublic static final String ldapAttrGivenName = \"givenName\";\n-\tpublic static final String ldapAttrEntityID = perunAttrEntityID;\n-\tpublic static final String ldapAttrClientID = perunAttrClientID;\n-\tpublic static final String ldapAttrObjectClass = \"objectClass\";\n-\tpublic static final String ldapAttrPerunVoId = \"perunVoId\";\n-\tpublic static final String ldapAttrPerunFacilityId = \"perunFacilityId\";\n-\tpublic static final String ldapAttrPerunUserId = \"perunUserId\";\n-\tpublic static final String ldapAttrPerunGroupId = \"perunGroupId\";\n-\tpublic static final String ldapAttrPerunResourceId = \"perunResourceId\";\n-\tpublic static final String ldapAttrPerunParentGroup = \"perunParentGroup\";\n-\tpublic static final String ldapAttrPerunParentGroupId = \"perunParentGroupId\";\n-\tpublic static final String ldapAttrMemberOf = \"memberOf\";\n-\tpublic static final String ldapAttrUniqueMember = \"uniqueMember\";\n-\tpublic static final String ldapAttrMemberOfPerunVo = \"memberOfPerunVo\";\n-\tpublic static final String ldapAttrEntryStatus = \"entryStatus\";\n-\tpublic static final String ldapAttrIsServiceUser = \"isServiceUser\";\n-\tpublic static final String ldapAttrIsSponsoredUser = \"isSponsoredUser\";\n-\tpublic static final String ldapAttrGroupNames = perunAttrGroupNames;\n-\tpublic static final String ldapAttrInstitutionsCountries = perunAttrInstitutionsCountries;\n-\n-\t//LDAP OBJECT CLASSES\n-\tpublic static final String objectClassTop = \"top\";\n-\tpublic static final String objectClassPerunResource = \"perunResource\";\n-\tpublic static final String objectClassPerunGroup = \"perunGroup\";\n-\tpublic static final String objectClassOrganization = \"organization\";\n-\tpublic static final String objectClassPerunVO = \"perunVO\";\n-\tpublic static final String objectClassPerson = \"person\";\n-\tpublic static final String objectClassOrganizationalPerson = \"organizationalPerson\";\n-\tpublic static final String objectClassInetOrgPerson = \"inetOrgPerson\";\n-\tpublic static final String objectClassPerunUser = \"perunUser\";\n-\tpublic static final String objectClassTenOperEntry = \"tenOperEntry\";\n-\tpublic static final String objectClassInetUser = \"inetUser\";\n-\n-\t//LDAP ORGANIZATION UNITS\n-\tpublic static final String organizationalUnitPeople = \"ou=People\";\n-\n-\t/**\n-\t * This method waiting for new messages in AuditLog (using AuditerConsumer)\n-\t * and then call method resolveMessage or catch exceptions and log data to files.\n-\t *\n-\t * @throws InterruptedException if thread is interrupted\n-\t * @throws Exception if some other exception like InternalErrorException are thrown\n-\t *\n-\t */\n-\tpublic void run() {\n-\n-\t\tif(!ldapProperties.propsLoaded()) throw new RuntimeException(\"LdapcProperties is not autowired correctly!\");\n-\n-\t\t//Get instance of auditerConsumer and set runnig to true\n-\n-\t\trunning = true;\n-\t\tInteger lastProcessedIdNumber = 0;\n-\t\tAuditMessage message = new AuditMessage(0, \"Empty\", null, null, null);\n-\t\tList<AuditMessage> messages;\n-\n-\t\ttry {\n-\t\t\t//If running is true, then this proccess will be continously\n-\t\t\twhile (running) {\n-\n-\t\t\t\tmessages = null;\n-\t\t\t\tint sleepTime = 1000;\n-\t\t\t\t//Waiting for new messages. If consumer failed in some internal case, waiting until it will be repaired (waiting time is increases by each attempt)\n-\t\t\t\tdo {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\t//IMPORTANT STEP1: Get new bulk of messages\n-\t\t\t\t\t\tmessages = Rpc.AuditMessagesManager.pollConsumerMessagesForParser(ldapcManager.getRpcCaller(), ldapProperties.getLdapConsumerName());\n-\t\t\t\t\t} catch (InternalErrorException ex) {\n-\t\t\t\t\t\tlog.error(\"Consumer failed due to {}. Sleeping for {} ms.\",ex, sleepTime);\n-\t\t\t\t\t\tThread.sleep(sleepTime);\n-\t\t\t\t\t\tsleepTime+=sleepTime;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//If there are no messages, sleep for 1 sec and then try it again\n-\t\t\t\t\tif(messages == null) Thread.sleep(1000);\n-\t\t\t\t} while(messages == null);\n-\t\t\t\t//If new messages exist, resolve them all\n-\t\t\t\tIterator<AuditMessage> messagesIterator = messages.iterator();\n-\t\t\t\twhile(messagesIterator.hasNext()) {\n-\t\t\t\t\tmessage = messagesIterator.next();\n-\t\t\t\t\tmessagesIterator.remove();\n-\t\t\t\t\t//Warning when two consecutive messages are separated by more than 15 ids\n-\t\t\t\t\tif(lastProcessedIdNumber > 0 && lastProcessedIdNumber < message.getId()) {\n-\t\t\t\t\t\tif((message.getId() - lastProcessedIdNumber) > 15) log.debug(\"SKIP FLAG WARNING: lastProcessedIdNumber: \" + lastProcessedIdNumber + \" - newMessageNumber: \" + message.getId() + \" = \" + (lastProcessedIdNumber - message.getId()));\n-\t\t\t\t\t}\n-\t\t\t\t\tlastProcessedIdNumber = message.getId();\n-\t\t\t\t\t//IMPORTANT STEP2: Resolve next message\n-\t\t\t\t\tthis.resolveMessage(message.getMsg(), message.getId());\n-\t\t\t\t}\n-\t\t\t\t//After all messages has been resolved, test interrupting of thread and if its ok, wait and go for another bulk of messages\n-\t\t\t\tif (Thread.interrupted()) {\n-\t\t\t\t\trunning = false;\n-\t\t\t\t} else {\n-\t\t\t\t\tThread.sleep(5000);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t//If ldapc is interrupted\n-\t\t} catch (InterruptedException e) {\n-\t\t\tDate date = new Date();\n-\t\t\tlog.error(\"Last message has ID='\" + message.getId()+ \"' and was INTERRUPTED at \" + DATE_FORMAT.format(date) + \" due to interrupting.\");\n-\t\t\trunning = false;\n-\t\t\tThread.currentThread().interrupt();\n-\t\t\t//If some other exception is thrown\n-\t\t} catch (Exception e) {\n-\t\t\tDate date = new Date();\n-\t\t\tlog.error(\"Last message has ID='\" + message.getId() + \"' and was bad PARSED or EXECUTE at \" + DATE_FORMAT.format(date) + \" due to exception \" + e.toString());\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get a message and id of this message.\n-\t * Parse the message and decide which way will be further processed.\n-\t * Using patterns and objects to choose the way.\n-\t *\n-\t * Additional Information:\n-\t * -> For user and serviceUser there is the same behavior.\n-\t * -> If there is only serviceUser (not serviceUser and user) the behavior for serviceUser is the same like for user (in LDAP)\n-\t * -> If there are 2 groups in one message, expecting the first is subGroup and second is parentGroup\n-\t *\n-\t * Possible ways (first and only 1 possible way with the lowest number is choose):\n-\t * -> 1) GROUP and MEMBER exist\n-\t *   -> 1.1) if member status is valid => add member to group in LDAP\n-\t *   -> 1.2) if member was totally removed from group (totally means there is no direct or indirect existence of member in this group yet)\n-\t *           => remove member from this group in LDAP\n-\t * -> 2) GROUP and PARENT_GROUP exist\n-\t *   -> 2.1) if there is message with adding subgroup => add group like subgroup of parentGroup in LDAP\n-\t * -> 3) GROUP AND RESOURCE exist\n-\t *   -> 3.1) if there is message with adding group to resource => add resource to group (like attribute) in LDAP\n-\t *   -> 3.2) if there is message with removing group from resource => remove resource from group (like attribute) in LDAP\n-\t * -> 4) only RESOURCE exists (resource must be before group because of\n-\t *   -> 4.1) if there is message with deleting resource => delete this resource from LDAP\n-\t *   -> 4.2) if there is message with createing resource => create this resource in LDAP\n-\t *   -> 4.3) if there is message with updating resource => update this resource in LDAP\n-\t * -> 5) only GROUP exists\n-\t *   -> 5.1) if there is message with deleting group => delete this group from LDAP\n-\t *   -> 5.2) if there is message with creating group => create this group in LDAP\n-\t *   -> 5.3) if there is message with updating group => update this group in LDAP\n-\t *   -> 5.4) if there is message with moving group in the structure => modify existing group to the new state\n-\t * -> 6) only MEMBER exists (RPC CALLING used)\n-\t *   -> 6.1) if there is message with changing of member state to valid => add member to all groups in LDAP where he needs to be\n-\t *   -> 6.2) if there is message with changing of member state to other than valid => remove member from all groups in LDAP where is needed\n-\t * -> 7) only VO exists\n-\t *   -> 7.1) if there is message with deleting vo => delete this vo from LDAP\n-\t *   -> 7.2) if there is message with creating vo => create this vo in LDAP\n-\t *   -> 7.3) if there is message with updating vo => update this vo in LDAP\n-\t * -> 8) USER and USER_EXT_SOURCE exist\n-\t *   -> 8.1) if there is message with adding userExtSource (IDP) to user => create or update attribute of user in LDAP\n-\t *   -> 8.2) if there is message with removing userExtSource (IDP) from user => remove or update attribute of user in LDAP\n-\t * -> 9) USER and ATTRIBUTE exist\n-\t *   -> 9.1) if there is message with setting attribute to user => set Attribute to user in LDAP\n-\t * -> 10) USER and ATTRIBUTE_DEFINITION exist\n-\t *   -> 10.1) if there is message with removing attribute from user => remove Attribute from user in LDAP\n-\t * -> 11) only USER exists\n-\t *   -> 11.1) if there is message with deleting user => delete user from LDAP\n-\t *   -> 11.2) if there is message with creating user => create user in LDAP\n-\t *   -> 11.3) if there is message with updating user => update user in LDAP\n-\t *   -> 11.4) if there is message with removing all attribute from user => remove all attributes from user in LDAP (only removeable attributes)\n-\t * -> 12) FACILITY and ATTRIBUTE exist\n-\t *   -> 12.1) if there is message with setting attribute to facility => set Attribute to resources (assigned to facility) in LDAP\n-\t * -> 13) FACILITY and ATTRIBUTE_DEF exist\n-\t *   -> 13.1) if there is message with removing attribute from facility => remove Attribute from resources (assigned to facility) in LDAP\n-\t * -> 14) in all other cases\n-\t *   -> 14.1) always => only log some information\n-\t *\n-\t * @param msg message which need to be parse and resolve\n-\t * @param idOfMessage id of paring/resolving message\n-\t *\n-\t * @throws InternalErrorException when some internal error in core occurs\n-\t */\n-\tprotected void resolveMessage(String msg, Integer idOfMessage) throws InternalErrorException {\n-\n-\t\tList<PerunBean> listOfBeans;\n-\t\tlistOfBeans = AuditParser.parseLog(msg);\n-\n-\t\t//Debug information to check parsing of message.\n-\t\tif(!listOfBeans.isEmpty()){\n-\t\t\tint i=0;\n-\t\t\tfor(PerunBean p: listOfBeans) {\n-\t\t\t\ti++;\n-\t\t\t\tif(p!=null) log.debug(\"There is object number \" + i + \") \" + p.serializeToString());\n-\t\t\t\telse log.debug(\"There is unknow object which is null\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Fill perunBeans\n-\t\temptyAndFillPerunBeans(listOfBeans);\n-\n-\t\t//Log debug data for looking in messages\n-\t\tlog.debug(\"MessageNumber=\" + idOfMessage + \" -- OBJECTS: \" + this.member + '/' + this.group + '/' + this.facility + \"/\" + this.parentGroup + '/' + this.vo + '/'\n-\t\t\t\t+ this.resource + '/' + this.user + '/' + this.attribute + '/' + this.attributeDef + '/' + this.userExtSource);\n-\n-\t\t//If specific user is the only one user in message, so behavior will be same for him like for any other user!\n-\t\tif(this.specificUser != null && this.user == null) this.user = this.specificUser;\n-\n-\t\t//------------------------------------------------------------------\n-\t\t//-----------------OPERATIONS ON FILLED OBJECTS---------------------\n-\t\t//------------------------------------------------------------------\n-\t\t//Choose first possible solution for existing objects.\n-\n-\t\t// 1) IF GROUP AND MEMBER WERE FOUND, TRY TO WORK WITH GROUP-MEMBER SPECIFIC OPERATIONS\n-\t\tif(this.group != null && this.member != null) {\n-\t\t\t// 1.1) ONLY FOR VALID MEMBER WE ADD HIM TO THE GROUP IN LDAP\n-\t\t\tif(this.member.getStatus().equals(Status.VALID)) {\n-\t\t\t\tMatcher addedTo = addedToPattern.matcher(msg);\n-\n-\t\t\t\tif(addedTo.find()) {\n-\t\t\t\t\tif(!ldapConnector.isAlreadyMember(this.member, this.group)) ldapConnector.addMemberToGroup(this.member, this.group);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// 1.2) MEMBER WILL BE REMOVED FROM GROUP\n-\t\t\tMatcher totallyRemovedFrom = totallyRemovedFromPatter.matcher(msg);\n-\n-\t\t\tif(totallyRemovedFrom.find()) {\n-\t\t\t\tif(ldapConnector.isAlreadyMember(this.member, this.group)) ldapConnector.removeMemberFromGroup(this.member, this.group);\n-\t\t\t}\n-\n-\t\t\t// 2) IF 2 GROUPS WERE FOUND, TRY TO WORK WITH PARENT_GROUP-SUBGROUP SPECIFIC OPERATIONS\n-\t\t} else if(this.group != null && this.parentGroup != null) {\n-\t\t\tMatcher newSubGroup = subGroupPattern.matcher(msg);\n-\n-\t\t\t// 2.1) ADD GROUP AS SUBGROUP TO PARENT_GROUP\n-\t\t\tif(newSubGroup.find()) {\n-\t\t\t\tldapConnector.addGroupAsSubGroup(this.group, this.parentGroup);\n-\t\t\t}\n-\n-\t\t\t// 3) IF GROUP AND RESOURCE WERE FOUND, TRY TO WORK WITH GROUP-RESOURCE SPECIFIC OPERATIONS\n-\t\t} else if(this.group != null && this.resource != null) {\n-\t\t\tMatcher assigned = assignGroupToResourcePattern.matcher(msg);\n-\t\t\tMatcher removed = removeGroupFromResourcePattern.matcher(msg);\n-\n-\t\t\t// 3.1) ADD NEW RESOURCE FOR GROUP IN LDAP\n-\t\t\tif(assigned.find()) {\n-\t\t\t\tupdateGroupAttribute(ldapAttrAssignedToResourceId, String.valueOf(this.resource.getId()), LdapOperation.ADD_ATTRIBUTE, this.group);\n-\t\t\t\tupdateResourceAttribute(ldapAttrAssignedGroupId, String.valueOf(this.group.getId()), LdapOperation.ADD_ATTRIBUTE, this.resource);\n-\t\t\t\t// 3.2) REMOVE RESOURCE FROM GROUP IN LDAP\n-\t\t\t} else if(removed.find()) {\n-\t\t\t\tupdateGroupAttribute(ldapAttrAssignedToResourceId, String.valueOf(this.resource.getId()), LdapOperation.REMOVE_ATTRIBUTE, this.group);\n-\t\t\t\tupdateResourceAttribute(ldapAttrAssignedGroupId, String.valueOf(this.group.getId()), LdapOperation.REMOVE_ATTRIBUTE, this.resource);\n-\t\t\t}\n-\t\t\t// 4) IF ONLY RESOURCE WERE FOUND, TRY TO WORK WITH RESOURCE SPECIFIC OPERATIONS\n-\t\t} else if(this.resource != null) {\n-\t\t\tMatcher deleted = deletedResourcePattern.matcher(msg);\n-\t\t\tMatcher created = createdPattern.matcher(msg);\n-\t\t\tMatcher updated = updatedPattern.matcher(msg);\n-\n-\t\t\t// 4.1) RESOURCE WILL BE DELETED\n-\t\t\tif(deleted.find()) {\n-\t\t\t\tldapConnector.deleteResource(resource);\n-\t\t\t\t// 4.2) RESOURCE WILL BE CREATED\n-\t\t\t} else if(created.find()) {\n-\t\t\t\tldapConnector.createResource(resource, getFacilityEntityIdValue(resource.getFacilityId()));\n-\t\t\t\t// 4.3) RESOURCE WILL BE UPDATED\n-\t\t\t} else if(updated.find()) {\n-\t\t\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<>();\n-\t\t\t\tList<Pair<String,String>> replaceList = new ArrayList<>();\n-\t\t\t\treplaceList.add(new Pair(ldapAttrCommonName,this.resource.getName()));\n-\t\t\t\tif(this.resource.getDescription() != null && !this.resource.getDescription().isEmpty()) replaceList.add(new Pair(ldapAttrDescription, this.resource.getDescription()));\n-\t\t\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n-\t\t\t\tupdateResourceAttributes(attributes, this.resource);\n-\t\t\t}\n-\t\t\t// 5) IF ONLY GROUP WERE FOUND, TRY TO WORK WITH GROUP SPECIFIC OPERATIONS\n-\t\t} else if(this.group != null) {\n-\t\t\tMatcher deleted = deletedPattern.matcher(msg);\n-\t\t\tMatcher newGroup = newGroupPattern.matcher(msg);\n-\t\t\tMatcher updated = updatedPattern.matcher(msg);\n-\t\t\tMatcher moveGroup = moveGroupPattern.matcher(msg);\n-\n-\t\t\tif(deleted.find()){\n-\t\t\t\t// 5.1) GROUP WILL BE DELETED\n-\t\t\t\tldapConnector.removeGroup(this.group);\n-\t\t\t} else if(newGroup.find()) {\n-\t\t\t\t// 5.2) GROUP WILL BE CREATED\n-\t\t\t\tldapConnector.addGroup(this.group);\n-\t\t\t} else if(updated.find()) {\n-\t\t\t\t// 5.3) GROUP WILL BE UPDATED\n-\t\t\t\tupdateGroup(group);\n-\t\t\t} else if(moveGroup.find()) {\n-\t\t\t\t// 5.4) MOVE GROUP IN STRUCTURE\n-\t\t\t\tmoveGroup(group);\n-\t\t\t}\n-\n-\t\t\t// 6) IF MEMBER WAS FOUND, TRY TO WORK WITH MEMBER SPECIFIC OPERATIONS (! RPC CALLING used there !)\n-\t\t} else if(this.member != null) {\n-\t\t\tMatcher validated = validatedPattern.matcher(msg);\n-\t\t\tMatcher otherStateOfMember = otherStateOfMemberPattern.matcher(msg);\n-\n-\t\t\t// 6.1) MEMBER WAS VALIDATED, NEED TO ADD HIM TO ALL GROUPS\n-\t\t\tif(validated.find()) {\n-\t\t\t\tList<Group> memberGroups = new ArrayList<Group>();\n-\t\t\t\ttry {\n-\t\t\t\t\tmemberGroups = Rpc.GroupsManager.getAllMemberGroups(ldapcManager.getRpcCaller(), this.member);\n-\t\t\t\t} catch (MemberNotExistsException e) {\n-\t\t\t\t\t//IMPORTANT this is not problem, if member not exist, we expected that will be deleted in some message after that, in DB is deleted\n-\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting member's groups\", e);\n-\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\tthrow e;\n-\t\t\t\t}\n-\t\t\t\tfor(Group g: memberGroups) {\n-\t\t\t\t\tif(!ldapConnector.isAlreadyMember(this.member, g)) ldapConnector.addMemberToGroup(this.member, g);\n-\t\t\t\t}\n-\t\t\t\t// 6.2) MEMBER STATE WAS CHANGED TO OTHER STATE THAN VALIDATE\n-\t\t\t} else if(otherStateOfMember.find()) {\n-\t\t\t\tList<Group> memberGroups = new ArrayList<Group>();\n-\t\t\t\ttry {\n-\t\t\t\t\tmemberGroups = Rpc.GroupsManager.getAllMemberGroups(ldapcManager.getRpcCaller(), this.member);\n-\t\t\t\t} catch (MemberNotExistsException e) {\n-\t\t\t\t\t//IMPORTATNT this is not problem, if member not exist, we expected that will be deleted in some message after that, in DB is deleted\n-\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting member's groups\", e);\n-\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\tthrow e;\n-\t\t\t\t}\n-\t\t\t\tfor(Group g: memberGroups) {\n-\t\t\t\t\tif(ldapConnector.isAlreadyMember(this.member, g)) ldapConnector.removeMemberFromGroup(this.member, g);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// 7) IF VO WAS FOUND, TRY TO WORK WITH VO SPECIFIC OPERATIONS\n-\t\t} else if(this.vo != null) {\n-\t\t\tMatcher deleted = deletedPattern.matcher(msg);\n-\t\t\tMatcher created = createdPattern.matcher(msg);\n-\t\t\tMatcher updated = updatedPattern.matcher(msg);\n-\n-\t\t\t// 7.1) VO WILL BE DELETED\n-\t\t\tif(deleted.find()) {\n-\t\t\t\tldapConnector.deleteVo(this.vo);\n-\t\t\t\t// 7.2) VO WILL BE CREATED\n-\t\t\t} else if(created.find()) {\n-\t\t\t\tldapConnector.createVo(this.vo);\n-\t\t\t\t// 7.3) VO WILL BE UPDATED\n-\t\t\t} else if(updated.find()) {\n-\t\t\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n-\t\t\t\tList<Pair<String,String>> replaceList = new ArrayList<Pair<String, String>>();\n-\t\t\t\treplaceList.add(new Pair(ldapAttrDescription,this.vo.getName()));\n-\t\t\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n-\t\t\t\tupdateVoAttributes(attributes, this.vo);\n-\t\t\t}\n-\n-\t\t\t// 8) IF USER AND USEREXTSOURCE WERE FOUND, TRY TO WORK WITH USER-USEREXTSOURCE SPECIFIC OPERATIONS (LIKE SET EXT LOGINS FOR IDP EXTSOURCES)\n-\t\t} else if(this.user != null && this.userExtSource != null) {\n-\t\t\tMatcher addExtSource = addUserExtSourcePattern.matcher(msg);\n-\t\t\tMatcher removeExtSource = removeUserExtSourcePattern.matcher(msg);\n-\n-\t\t\t// 8.1) ADD ATTRIBUTE WITH IDP EXTSOURCE\n-\t\t\tif(addExtSource.find()) {\n-\t\t\t\tif(this.userExtSource.getExtSource() != null && this.userExtSource.getExtSource().getType() != null) {\n-\t\t\t\t\tString extLogin;\n-\t\t\t\t\tif(this.userExtSource.getExtSource().getType().equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n-\t\t\t\t\t\textLogin = this.userExtSource.getLogin();\n-\t\t\t\t\t\tif(extLogin == null) extLogin = \"\";\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrEduPersonPrincipalNames, extLogin, LdapOperation.ADD_ATTRIBUTE, user);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// 8.2) REMOVE ATTRIBUTE WITH IDP EXTSOURCE\n-\t\t\t} else if(removeExtSource.find()) {\n-\t\t\t\tif(this.userExtSource.getExtSource() != null && this.userExtSource.getExtSource().getType() != null) {\n-\t\t\t\t\tString extLogin;\n-\t\t\t\t\tif(this.userExtSource.getExtSource().getType().equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n-\t\t\t\t\t\textLogin = this.userExtSource.getLogin();\n-\t\t\t\t\t\tif(extLogin == null) extLogin = \"\";\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrEduPersonPrincipalNames, extLogin, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// 9) IF USER AND ATTRIBUTE WERE FOUND, TRY TO WORK WITH USER-ATTR SPECIFIC OPERATIONS (LIKE SET USER ATTRIBUTES)\n-\t\t} else if(this.user != null && this.attribute != null) {\n-\t\t\tMatcher set = userSetPattern.matcher(msg);\n-\n-\t\t\t// 9.1) SOME USER ATTRIBUTE WILL BE PROBABLY SET (IF IT IS ONE OF SPECIFIC ATTRIBUTES)\n-\t\t\tif(set.find()) {\n-\t\t\t\tMatcher uidMatcher = userUidNamespacePattern.matcher(this.attribute.getName());\n-\t\t\t\tMatcher loginMatcher = userLoginNamespacePattern.matcher(this.attribute.getName());\n-\n-\t\t\t\tif(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail)) {\n-\t\t\t\t\t//this mean change of attribute preferredMail in User\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrPreferredMail, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, user);\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrMail, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrPreferredMail)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrPreferredMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrMail)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrOrganization)) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrOrganization, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrOrganization)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrOrganization, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPhone)) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrTelephoneNumber, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrTelephoneNumber)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrTelephoneNumber, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrUserCertDNs)) {\n-\t\t\t\t\tMap<String, String> certDNsMap = (this.attribute.getValue() != null) ? (Map) this.attribute.getValue() : null;\n-\n-\t\t\t\t\tif (certDNsMap == null || certDNsMap.isEmpty()) {\n-\t\t\t\t\t\tif (ldapConnector.userAttributeExist(this.user, ldapAttrUserCertDNs)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserCertDNs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tSet<String> certSubjectsWithPrefixes = ((Map) this.attribute.getValue()).keySet();\n-\t\t\t\t\t\tSet<String> certSubjectsWithoutPrefixes = new HashSet<>();\n-\t\t\t\t\t\t//remove prefixes from certificates\n-\t\t\t\t\t\tfor (String key : certSubjectsWithPrefixes) {\n-\t\t\t\t\t\t\tcertSubjectsWithoutPrefixes.add(key.replaceFirst(\"^[0-9]+[:]\", \"\"));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tString[] subjectsArray = Arrays.copyOf(certSubjectsWithoutPrefixes.toArray(), certSubjectsWithoutPrefixes.toArray().length, String[].class);\n-\t\t\t\t\t\tldapConnector.updateUsersAttributeInLDAP(String.valueOf(this.user.getId()), ldapAttrUserCertDNs, subjectsArray);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrBonaFideStatus)) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrBonaFideStatus, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrBonaFideStatus)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrBonaFideStatus, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrSchacHomeOrganizations)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrSchacHomeOrganizations);\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrEduPersonScopedAffiliations)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrEduPersonScopedAffiliations);\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrGroupNames)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrGroupNames);\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrInstitutionsCountries)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrInstitutionsCountries);\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrLibraryIDs)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrLibraryIDs);\n-\n-\t\t\t\t} else if(uidMatcher.find()) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrUidNumber + this.attribute.getFriendlyNameParameter(), String.valueOf((Integer) this.attribute.getValue()), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrUidNumber + this.attribute.getFriendlyNameParameter())) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUidNumber + this.attribute.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(loginMatcher.find()) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrLogin + this.attribute.getFriendlyNameParameter(), (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t//if login is from loginNamespace (eg. EINFRA) (new value), then userPassword must be set or modified\n-\t\t\t\t\t\tif(ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attribute.getFriendlyNameParameter())) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserPassword, \"{SASL}\" + this.attribute.getValue() + \"@\" + ldapProperties.getLdapLoginNamespace(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrLogin + this.attribute.getFriendlyNameParameter())) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrLogin + this.attribute.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif(ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attribute.getFriendlyNameParameter())) {\n-\t\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrUserPassword)) {\n-\t\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserPassword, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// 10) IF USER AND ATTRIBTUE DEFINITION WERE FOUND, TRY TO WORK WITH USER-ATTRDEF SPECIFIC OPERATIONS\n-\t\t} else if(this.user != null && attributeDef != null) {\n-\t\t\tMatcher remove = userRemovePattern.matcher(msg);\n-\t\t\t// 10.1) REMOVE SPECIFIC USER ATTRIBUTE\n-\t\t\tif(remove.find() &&  ldapConnector.userExist(this.user)) {\n-\t\t\t\tMatcher uidMatcher = userUidNamespacePattern.matcher(this.attributeDef.getName());\n-\t\t\t\tMatcher loginMatcher = userLoginNamespacePattern.matcher(this.attributeDef.getName());\n-\t\t\t\tif(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrPreferredMail)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrPreferredMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrMail)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t\t//TODO: organization (user) will not exists\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrOrganization)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrOrganization)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrOrganization, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPhone)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrTelephoneNumber)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrTelephoneNumber, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrUserCertDNs)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrUserCertDNs)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserCertDNs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrEduPersonScopedAffiliations)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrEduPersonScopedAffiliations)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrEduPersonScopedAffiliations, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrGroupNames)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrGroupNames)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrGroupNames, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrInstitutionsCountries)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrInstitutionsCountries)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrInstitutionsCountries, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrBonaFideStatus)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrBonaFideStatus)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrBonaFideStatus, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrSchacHomeOrganizations)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrSchacHomeOrganizations)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrSchacHomeOrganizations, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrLibraryIDs)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrLibraryIDs)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrLibraryIDs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(uidMatcher.find()) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrUidNumber + this.attributeDef.getFriendlyNameParameter())) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrUidNumber + this.attributeDef.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(loginMatcher.find()) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrLogin + this.attributeDef.getFriendlyNameParameter())) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrLogin + this.attributeDef.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t\tif(ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attributeDef.getFriendlyNameParameter())) {\n-\t\t\t\t\t\tif(ldapConnector.userPasswordExists(this.user)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserPassword, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// 11) IF ONLY USER WAS FOUND, TRY TO WORK WITH USER SPECIFIC OPERATIONS\n-\t\t} else if(this.user != null) {\n-\t\t\tMatcher deleted = deletedPattern.matcher(msg);\n-\t\t\tMatcher created = createdPattern.matcher(msg);\n-\t\t\tMatcher updated = updatedPattern.matcher(msg);\n-\t\t\tMatcher removedAllAttrs = userAllAttrsRemovedPattern.matcher(msg);\n-\t\t\t// 11.1) DELETE USER\n-\t\t\tif(deleted.find()) {\n-\t\t\t\tldapConnector.deleteUser(this.user);\n-\t\t\t\t// 11.2) CREATE USER\n-\t\t\t} else if(created.find()) {\n-\t\t\t\tldapConnector.createUser(this.user);\n-\t\t\t\t// 11.3) UPDATE USER\n-\t\t\t} else if(updated.find()) {\n-\t\t\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n-\t\t\t\tList<Pair<String,String>> replaceList = new ArrayList<Pair<String, String>>();\n-\t\t\t\tString firstName = this.user.getFirstName();\n-\t\t\t\tString lastName = this.user.getLastName();\n-\t\t\t\tString commonName = \"\";\n-\t\t\t\tif(firstName == null || firstName.isEmpty()) firstName = \"\";\n-\t\t\t\telse commonName+= firstName + \" \";\n-\t\t\t\tif(lastName == null || lastName.isEmpty()) lastName = \"N/A\";\n-\t\t\t\tcommonName+=lastName;\n-\t\t\t\treplaceList.add(new Pair(ldapAttrSurname,lastName));\n-\t\t\t\treplaceList.add(new Pair(ldapAttrCommonName, commonName));\n-\t\t\t\t// IF firstName is empty, maybe need to be removed first\n-\t\t\t\tif(firstName.isEmpty()) {\n-\t\t\t\t\t//if first name exists and new one is empty, then remove it, else do nothing\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrGivenName)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrGivenName, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t//if first name is not empty, replace it by new first name\n-\t\t\t\t\treplaceList.add(new Pair(ldapAttrGivenName, firstName));\n-\t\t\t\t}\n-\t\t\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n-\t\t\t\tupdateUserAttributes(attributes, this.user);\n-\t\t\t\t// 11.4) REMOVE ALL USER ATTRIBUTES\n-\t\t\t} else if(removedAllAttrs.find()) {\n-\t\t\t\tif(ldapConnector.userExist(this.user)) {\n-\t\t\t\t\tAttributes usersAttrs = ldapConnector.getAllUsersAttributes(this.user);\n-\t\t\t\t\tList<ModificationItem> listOfItems = new ArrayList<ModificationItem>();\n-\t\t\t\t\tif(usersAttrs != null) {\n-\t\t\t\t\t\tNamingEnumeration<? extends Attribute> attributesEnumeration;\n-\t\t\t\t\t\tattributesEnumeration = usersAttrs.getAll();\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\twhile(attributesEnumeration.hasMore()) {\n-\t\t\t\t\t\t\t\tAttribute attr = attributesEnumeration.nextElement();\n-\t\t\t\t\t\t\t\tif(attr != null && attr.getID() != null) {\n-\t\t\t\t\t\t\t\t\tif(isRemovableUserAttribute(attr.getID())) {\n-\t\t\t\t\t\t\t\t\t\tModificationItem item = new ModificationItem(LdapOperation.REMOVE_ATTRIBUTE.getCode(), attr);\n-\t\t\t\t\t\t\t\t\t\tlistOfItems.add(item);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} catch (NamingException ex) {\n-\t\t\t\t\t\t\tthrow new InternalErrorException(\"Error at Deleting All Users Attribute, throw namingException.\", ex);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif(!listOfItems.isEmpty()) {\n-\t\t\t\t\t\tModificationItem[] items = Arrays.copyOf(listOfItems.toArray(), listOfItems.toArray().length, ModificationItem[].class);\n-\t\t\t\t\t\tldapConnector.updateUser(this.user, items);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//12) IF FACILITY AND ATTRIBUTE TO SET WAS FOUND\n-\t\t} else if(this.facility != null && attribute != null) {\n-\t\t\tMatcher set = facilitySetPattern.matcher(msg);\n-\n-\t\t\t// 12.1) SOME FACILITY ATTRIBUTE WILL BE PROBABLY SET (IF IT IS ONE OF SPECIFIC ATTRIBUTES)\n-\t\t\tif(set.find()) {\n-\t\t\t\t//EntityID WILL BE SET\n-\t\t\t\tif(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tList<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n-\t\t\t\t\t\t//this mean change of attribute entityID in all assigned resources\n-\t\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrEntityID, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\t\tif(ldapConnector.resourceAttributeExist(res, ldapAttrEntityID)) {\n-\t\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrEntityID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t\t\t\t//this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n-\t\t\t\t\t\t//so skip it just log\n-\t\t\t\t\t\tlog.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n-\t\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n-\t\t\t\t\t}\n-\t\t\t\t//OIDCClientID WILL BE SET\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrClientID)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tList<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n-\t\t\t\t\t\t//this mean change of attribute clientID in all assigned resources\n-\t\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrClientID, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\t\tif(ldapConnector.resourceAttributeExist(res, ldapAttrClientID)) {\n-\t\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrClientID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t\t\t\t//this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n-\t\t\t\t\t\t//so skip it just log\n-\t\t\t\t\t\tlog.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n-\t\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t//13) IF FACILITY AND ATTRIBUTE DEF TO REMOVE WAS FOUND\n-\t\t} else if(this.facility != null && attributeDef != null) {\n-\t\t\tMatcher remove = facilityRemovePattern.matcher(msg);\n-\t\t\t// 13.1) REMOVE SPECIFIC FACILITY ATTRIBUTE\n-\t\t\tif(remove.find()) {\n-\t\t\t\tif(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tList<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n-\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\tif(ldapConnector.resourceAttributeExist(res, ldapAttrEntityID)) {\n-\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrEntityID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t\t\t\t//this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n-\t\t\t\t\t\t//so skip it just log\n-\t\t\t\t\t\tlog.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n-\t\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n-\t\t\t\t\t}\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrClientID)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tList<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n-\t\t\t\t\t\tfor (Resource res : resources) {\n-\t\t\t\t\t\t\tif (ldapConnector.resourceAttributeExist(res, ldapAttrClientID)) {\n-\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrClientID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t\t\t\t//this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n-\t\t\t\t\t\t//so skip it just log\n-\t\t\t\t\t\tlog.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n-\t\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t  // 14) IN OTHER CASES\n-\t\t} else {\n-\t\t\tlog.debug(\"Nothing to resolve for message with number : \" + idOfMessage);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Choose if attribute is removable or not.\n-\t * It means if is this attribute is required and can't be null.\n-\t *\n-\t * @param attributeName name of attribute in ldap\n-\t * @return true if attribute is removable, false if not\n-\t */\n-\tprivate boolean isRemovableUserAttribute(String attributeName) {\n-\t\tList<String> attributesWithoutOption = new ArrayList<String>();\n-\t\t//Attributes without option like \"x-ns-namespace\"\n-\t\tattributesWithoutOption.add(ldapAttrMail);\n-\t\tattributesWithoutOption.add(ldapAttrPreferredMail);\n-\t\tattributesWithoutOption.add(ldapAttrOrganization);\n-\t\tattributesWithoutOption.add(ldapAttrUserCertDNs);\n-\t\tattributesWithoutOption.add(ldapAttrSchacHomeOrganizations);\n-\t\tattributesWithoutOption.add(ldapAttrBonaFideStatus);\n-\t\tattributesWithoutOption.add(ldapAttrEduPersonScopedAffiliations);\n-\t\tattributesWithoutOption.add(ldapAttrLibraryIDs);\n-\t\tattributesWithoutOption.add(ldapAttrTelephoneNumber);\n-\t\tattributesWithoutOption.add(ldapAttrInstitutionsCountries);\n-\t\tattributesWithoutOption.add(ldapAttrGroupNames);\n-\t\tattributesWithoutOption.add(ldapAttrMemberOfPerunVo);\n-\t\tattributesWithoutOption.add(ldapAttrEduPersonPrincipalNames);\n-\t\tif(attributesWithoutOption.contains(attributeName)) return true;\n-\n-\t\t//Attributes with option like \"x-ns-namespace\"\n-\t\tList<String> attributesWithOption = new ArrayList<String>();\n-\t\tattributesWithOption.add(ldapAttrUidNumber);\n-\t\tattributesWithOption.add(ldapAttrLogin);\n-\t\tattributesWithOption.add(ldapAttrUserPassword);\n-\n-\t\tfor(String s: attributesWithOption) {\n-\t\t\tif(attributeName.startsWith(s)) return true;\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Get User preferred Mail value from perun.\n-\t *\n-\t * @param user the user\n-\t * @return value of user's preferredMail or null, if value is null or user not exists yet\n-\t * @throws InternalErrorException if some exception (except UserNotExistsException) is thrown from RPC\n-\t */\n-\tprivate String getUserPreferredMailValue(User user) throws InternalErrorException {\n-\t\tcz.metacentrum.perun.core.api.Attribute preferredMailAttr = null;\n-\t\ttry {\n-\t\t\tpreferredMailAttr = Rpc.AttributesManager.getAttribute(ldapcManager.getRpcCaller(), user, cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail);\n-\t\t} catch(PrivilegeException ex) {\n-\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting user's attribute.\", ex);\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new InternalErrorException(\"There is no such attribute.\", ex);\n-\t\t} catch(UserNotExistsException ex) {\n-\t\t\t//If user not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n-\t\t\treturn null;\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(\"There is problem with wrong attribute assignment exception.\", ex);\n-\t\t}\n-\t\tif(preferredMailAttr.getValue() == null) return null;\n-\t\telse return (String) preferredMailAttr.getValue();\n-\t}\n-\n-\t/**\n-\t * Get entityID value from perun by facilityId.\n-\t *\n-\t * @param facilityId the facilityId\n-\t * @return value of entityID or null, if value is null or user not exists yet\n-\t * @throws InternalErrorException if some exception is thrown from RPC\n-\t */\n-\tprivate String getFacilityEntityIdValue(int facilityId) throws InternalErrorException {\n-\t\tFacility facility = null;\n-\t\ttry {\n-\t\t\tfacility = Rpc.FacilitiesManager.getFacilityById(ldapcManager.getRpcCaller(), facilityId);\n-\t\t} catch (PrivilegeException ex) {\n-\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting facility by id.\", ex);\n-\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t//If facility not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tcz.metacentrum.perun.core.api.Attribute entityID = null;\n-\t\ttry {\n-\t\t\tentityID = Rpc.AttributesManager.getAttribute(ldapcManager.getRpcCaller(), facility, AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID);\n-\t\t} catch(PrivilegeException ex) {\n-\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting facility attribute.\", ex);\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new InternalErrorException(\"There is no such attribute.\", ex);\n-\t\t} catch(FacilityNotExistsException ex) {\n-\t\t\t//If facility not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n-\t\t\treturn null;\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(\"There is problem with wrong attribute assignment exception.\", ex);\n-\t\t}\n-\t\tif(entityID.getValue() == null) return null;\n-\t\telse return (String) entityID.getValue();\n-\t}\n-\n-\t/**\n-\t * Update ldap attribute with attributeName for the user by value with operation.\n-\t *\n-\t *\n-\t * @param attributeName name of attribute, is mandatory, cant be null\n-\t * @param attributeValue value of attribute, is not mandatory, can be null\n-\t * @param operation add, remove or replace (can't be null)\n-\t * @param user cant be null\n-\t *\n-\t * @exception InternalErrorException if an error occurs\n-\t *\n-\t */\n-\tprivate void updateUserAttribute(String attributeName, String attributeValue, LdapOperation operation, User user) throws InternalErrorException {\n-\t\tif(operation == null) throw new InternalErrorException(\"Operation can't be null\");\n-\t\tif(attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateUserAttribute :\" + attributeName);\n-\t\tif(user == null) throw new InternalErrorException(\"User is null in method updateUserAttribute\");\n-\n-\t\tAttribute attribute;\n-\t\tif(attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n-\t\telse attribute = new BasicAttribute(attributeName);\n-\n-\t\tModificationItem attributeItem =  new ModificationItem(operation.getCode(), attribute);\n-\t\tldapConnector.updateUser(user, new ModificationItem[] {attributeItem});\n-\t}\n-\n-\t/**\n-\t * Update user's ldap attributes from Map by operation in key.\n-\t *\n-\t * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n-\t *\n-\t *\n-\t * attributeName cant be null and empty String\n-\t * attributeValue can be null\n-\t *\n-\t * Execute all operations on all attributes with (or without value) in 1 task.\n-\t *\n-\t * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n-\t * @param user cant be null\n-\t * @throws InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateUserAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, User user) throws InternalErrorException {\n-\t\t//User cant be null\n-\t\tif(user == null) throw new InternalErrorException(\"User is null in method updateUserAttributes\");\n-\n-\t\tSet<LdapOperation> keys = mapOfAttributes.keySet();\n-\n-\t\t//Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n-\t\tfor(LdapOperation operation: keys) {\n-\t\t\tList<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n-\t\t\tfor(Pair<String, String> pair: listOfAttrs) {\n-\t\t\t\tif(pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//If all is correct, can execute operations on attributes\n-\t\tList<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n-\n-\t\t//Execute all changes on the notEmpty list of items\n-\t\tif(!listOfItemsToModify.isEmpty()) {\n-\t\t\tModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n-\t\t\tldapConnector.updateUser(user, items);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update ldap attribute with attributeName for the resource by value with operation.\n-\t *\n-\t *\n-\t * @param attributeName name of attribute, is mandatory, cant be null\n-\t * @param attributeValue value of attribute, is not mandatory, can be null\n-\t * @param operation add, replace or remove, can't be null\n-\t * @param resource cant be null\n-\t *\n-\t * @exception InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateResourceAttribute(String attributeName, String attributeValue, LdapOperation operation, Resource resource) throws InternalErrorException {\n-\t\tif(operation == null) throw new InternalErrorException(\"Operation can't be null.\");\n-\t\tif(attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateResourceAttribute :\" + attributeName);\n-\t\tif(resource == null) throw new InternalErrorException(\"Resource is null in method updateResourceAttribute\");\n-\n-\t\tAttribute attribute;\n-\t\tif(attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n-\t\telse attribute = new BasicAttribute(attributeName);\n-\n-\t\tModificationItem attributeItem =  new ModificationItem(operation.getCode(), attribute);\n-\t\tldapConnector.updateResource(resource, new ModificationItem[] {attributeItem});\n-\t}\n-\n-\t/**\n-\t * Update resource's ldap attributes from Map by operation in key.\n-\t *\n-\t * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n-\t *\n-\t * attributeName cant be null and empty String\n-\t * attributeValue can be null\n-\t *\n-\t * Execute all operations on all attributes with (or without value) in 1 task.\n-\t *\n-\t * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n-\t * @param resource cant be null\n-\t * @throws InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateResourceAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Resource resource) throws InternalErrorException {\n-\t\t//Resource cant be null\n-\t\tif(resource == null) throw new InternalErrorException(\"Resource is null in method updateGroupAttributes\");\n-\n-\t\tSet<LdapOperation> keys = mapOfAttributes.keySet();\n-\n-\t\t//Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n-\t\tfor(LdapOperation operation: keys) {\n-\t\t\tList<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n-\t\t\tfor(Pair<String, String> pair: listOfAttrs) {\n-\t\t\t\tif(pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//If all is correct, can execute operations on attributes\n-\t\tList<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n-\n-\t\t//Execute all changes on the notEmpty list of items\n-\t\tif(!listOfItemsToModify.isEmpty()) {\n-\t\t\tModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n-\t\t\tldapConnector.updateResource(resource, items);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Move group in hierarchical structure of it's VO.\n-\t *\n-\t * That means to change attributes in LDAP with name of group (structure is defined in name of group)\n-\t * and references to parentGroup if any exist.\n-\t *\n-\t * @param group group object after moving\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate void moveGroup(Group group) throws InternalErrorException {\n-\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n-\n-\t\tList<Pair<String,String>> listAttributesToBeRemoved = new ArrayList<>();\n-\t\tList<Pair<String,String>> listAttributesToBeReplaced = new ArrayList<>();\n-\n-\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrCommonName,group.getName()));\n-\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrPerunUniqueGroupName, ldapConnector.getVoShortName(group.getVoId()) + \":\" + group.getName()));\n-\n-\t\t//Check if group is now as subgroup or as top group\n-\t\tif(group.getName().contains(\":\")) {\n-\t\t\t//group is moved as subgroup\n-\t\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrPerunParentGroup, ldapAttrPerunGroupId + \"=\" + group.getParentGroupId().toString() + \",\" + ldapAttrPerunVoId + \"=\" + group.getVoId() + \",\" + ldapProperties.getLdapBase()));\n-\t\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrPerunParentGroupId, group.getParentGroupId().toString()));\n-\t\t} else {\n-\t\t\t//group is moved as top group\n-\t\t\tif(ldapConnector.groupAttributeExist(group, ldapAttrPerunParentGroup)) {\n-\t\t\t\tlistAttributesToBeRemoved.add(new Pair(ldapAttrPerunParentGroup, null));\n-\t\t\t}\n-\t\t\tif(ldapConnector.groupAttributeExist(group, ldapAttrPerunParentGroupId)) {\n-\t\t\t\tlistAttributesToBeRemoved.add(new Pair(ldapAttrPerunParentGroupId, null ));\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Add all attributes which will be replaced for the group (that also mean added if not exists yet)\n-\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, listAttributesToBeReplaced);\n-\t\t//Add all attributes (if any) which will be removed for group\n-\t\tif(!listAttributesToBeReplaced.isEmpty()) attributes.put(LdapOperation.REMOVE_ATTRIBUTE, listAttributesToBeRemoved);\n-\n-\t\t//update attributes in LDAP for group\n-\t\tupdateGroupAttributes(attributes, group);\n-\t}\n-\n-\t/**\n-\t * Update basic group attributes (name and description) in LDAP\n-\t *\n-\t * @param group group after update\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate void updateGroup(Group group) throws InternalErrorException {\n-\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<>();\n-\n-\t\tList<Pair<String,String>> listAttributesToBeRemoved = new ArrayList<>();\n-\t\tList<Pair<String,String>> listAttributesToBeReplaced = new ArrayList<>();\n-\n-\t\t//change name\n-\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrCommonName,this.group.getName()));\n-\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrPerunUniqueGroupName, ldapConnector.getVoShortName(this.group.getVoId()) + \":\" + this.group.getName()));\n-\n-\t\t//change description (or remove it if there is none)\n-\t\tif(group.getDescription() != null && !group.getDescription().isEmpty()) {\n-\t\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrDescription, this.group.getDescription()));\n-\t\t} else {\n-\t\t\tif(ldapConnector.groupAttributeExist(group, ldapAttrDescription)) {\n-\t\t\t\tlistAttributesToBeRemoved.add(new Pair(ldapAttrDescription, null));\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Add all attributes which will be replaced for the group (that also mean added if not exists yet)\n-\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, listAttributesToBeReplaced);\n-\t\t//Add all attributes (if any) which will be removed for group\n-\t\tif(!listAttributesToBeReplaced.isEmpty()) attributes.put(LdapOperation.REMOVE_ATTRIBUTE, listAttributesToBeRemoved);\n-\n-\t\t//update attributes in LDAP for group\n-\t\tupdateGroupAttributes(attributes, group);\n-\t}\n-\n-\t/**\n-\t * Update ldap attribute with attributeName for the group by value with operation.\n-\t *\n-\t * @param attributeName name of attribute, is mandatory, cant be null\n-\t * @param attributeValue value of attribute, is not mandatory, can be null\n-\t * @param operation add, replace or remove, can't be null\n-\t * @param group cant be null\n-\t *\n-\t * @exception InternalErrorException if an error occurs\n-\t *\n-\t */\n-\tprivate void updateGroupAttribute(String attributeName, String attributeValue, LdapOperation operation, Group group) throws InternalErrorException {\n-\t\tif(operation == null) throw new InternalErrorException(\"Operation can't be null.\");\n-\t\tif(attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateGroupAttribute :\" + attributeName);\n-\t\tif(group == null) throw new InternalErrorException(\"Group is null in method updateGroupAttribute\");\n-\n-\t\tAttribute attribute;\n-\t\tif(attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n-\t\telse attribute = new BasicAttribute(attributeName);\n-\n-\t\tModificationItem attributeItem =  new ModificationItem(operation.getCode(), attribute);\n-\t\tldapConnector.updateGroup(group, new ModificationItem[] {attributeItem});\n-\t}\n-\n-\t/**\n-\t * Update group's ldap attributes from Map by operation in key.\n-\t *\n-\t * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n-\t *\n-\t * attributeName cant be null and empty String\n-\t * attributeValue can be null\n-\t *\n-\t * Execute all operations on all attributes with (or without value) in 1 task.\n-\t *\n-\t * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n-\t * @param group cant be null\n-\t * @throws InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateGroupAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Group group) throws InternalErrorException {\n-\t\t//Group cant be null\n-\t\tif(group == null) throw new InternalErrorException(\"group is null in method updateGroupAttributes\");\n-\n-\t\tSet<LdapOperation> keys = mapOfAttributes.keySet();\n-\n-\t\t//Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n-\t\tfor(LdapOperation operation: keys) {\n-\t\t\tList<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n-\t\t\tfor(Pair<String, String> pair: listOfAttrs) {\n-\t\t\t\tif(pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//If all is correct, can execute operations on attributes\n-\t\tList<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n-\n-\t\t//Execute all changes on the notEmpty list of items\n-\t\tif(!listOfItemsToModify.isEmpty()) {\n-\t\t\tModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n-\t\t\tldapConnector.updateGroup(group, items);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update ldap attribute with attributeName for the vo by value with operation.\n-\t *\n-\t * @param attributeName name of attribute, is mandatory, cant be null\n-\t * @param attributeValue value of attribute, is not mandatory, can be null\n-\t * @param operation add, replace or remove, can't be null\n-\t * @param vo cant be null\n-\t *\n-\t * @exception InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateVoAttribute(String attributeName, String attributeValue, LdapOperation operation, Vo vo) throws InternalErrorException {\n-\t\tif(operation == null) throw new InternalErrorException(\"Operation can't be null.\");\n-\t\tif(attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateVoAttribute :\" + attributeName);\n-\t\tif(vo == null) throw new InternalErrorException(\"Vo is null in method updateVoAttribute\");\n-\n-\t\tAttribute attribute;\n-\t\tif(attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n-\t\telse attribute = new BasicAttribute(attributeName);\n-\n-\t\tModificationItem attributeItem =  new ModificationItem(operation.getCode(), attribute);\n-\t\tldapConnector.updateVo(vo, new ModificationItem[] {attributeItem});\n-\t}\n-\n-\t/**\n-\t * Update vo's ldap attributes from Map by operation in key.\n-\t *\n-\t * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n-\t *\n-\t *\n-\t * attributeName cant be null and empty String\n-\t * attributeValue can be null\n-\t *\n-\t * Execute all operations on all attributes with (or without value) in 1 task.\n-\t *\n-\t * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n-\t * @param vo cant be null\n-\t * @throws InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateVoAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Vo vo) throws InternalErrorException {\n-\t\t//User cant be null\n-\t\tif(vo == null) throw new InternalErrorException(\"Vo is null in method updateVoAttributes\");\n-\t\t//Only 3 types of key are allowed (1,2 or 3) Modification classes\n-\t\tSet<LdapOperation> keys = mapOfAttributes.keySet();\n-\n-\t\t//Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n-\t\tfor(LdapOperation operation: keys) {\n-\t\t\tList<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n-\t\t\tfor(Pair<String, String> pair: listOfAttrs) {\n-\t\t\t\tif(pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//If all is correct, can execute operations on attributes\n-\t\tList<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n-\n-\t\t//Execute all changes on the notEmpty list of items\n-\t\tif(!listOfItemsToModify.isEmpty()) {\n-\t\t\tModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n-\t\t\tldapConnector.updateVo(vo, items);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update multi value attribute for user in LDAP by name and values\n-\t *\n-\t * @param listOfValues to set, can be empty or null (that means no values should be set - remove existing values if any)\n-\t * @param user not null user to set attribute in ldap\n-\t * @param attributeLDAPName not null, not empty name of attribute in ldap\n-\t * @throws InternalErrorException if any of mandatory arguments are empty or any internal error occurred\n-\t */\n-\tprivate void updateUserMultivalueAttributeInLDAP(List<String> listOfValues, User user, String attributeLDAPName) throws InternalErrorException {\n-\t\tif(user == null) throw new InternalErrorException(\"User can't be null.\");\n-\t\tif(attributeLDAPName == null || attributeLDAPName.isEmpty()) throw new InternalErrorException(\"Attribute name can't be null.\");\n-\n-\t\tif (listOfValues == null || listOfValues.isEmpty()) {\n-\t\t\tif (ldapConnector.userAttributeExist(user, attributeLDAPName)) {\n-\t\t\t\tupdateUserAttribute(attributeLDAPName, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tString[] subjectsArray = Arrays.copyOf(listOfValues.toArray(), listOfValues.toArray().length, String[].class);\n-\t\t\tldapConnector.updateUsersAttributeInLDAP(String.valueOf(this.user.getId()), attributeLDAPName, subjectsArray);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Take map of operations and associated items to be add, replaced or removed from LDAP. Then convert this map to\n-\t * list of ModificationItems (Modification Item is attribute in LDAP with new value and operation which will be\n-\t * processed for it. Return this map.\n-\t *\n-\t * Possible Operations:\n-\t * 1 - ADD_ATTRIBUTE\n-\t * 2 - REPLACE_ATTRIBUTE\n-\t * 3 - REMOVE_ATTRIBUTES\n-\t *\n-\t * Skip not existing operations in map. If map is null, return empty list. If list of operations under operation is\n-\t * null, skipt it too.\n-\t *\n-\t * @param mapOfAttributes map of operations and associated items with new values to be processed\n-\t * @return list of modificationItems to be processed\n-\t */\n-\tprivate List<ModificationItem> getListOfModificationItems(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes) {\n-\t\tList<ModificationItem> listOfItemsToModify = new ArrayList<>();\n-\t\tif(mapOfAttributes == null) return listOfItemsToModify;\n-\n-\t\t//For all attributes with operation ADD (1)\n-\t\tif(mapOfAttributes.containsKey(LdapOperation.ADD_ATTRIBUTE)) {\n-\t\t\tList<Pair<String,String>> listOfAttributesToAdd = mapOfAttributes.get(LdapOperation.ADD_ATTRIBUTE);\n-\t\t\tif(listOfAttributesToAdd != null) {\n-\t\t\t\tfor (Pair<String, String> pair : listOfAttributesToAdd) {\n-\t\t\t\t\tAttribute attribute;\n-\t\t\t\t\tif (pair.getRight() != null) attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n-\t\t\t\t\telse attribute = new BasicAttribute(pair.getLeft());\n-\t\t\t\t\tModificationItem attributeItem = new ModificationItem(LdapOperation.ADD_ATTRIBUTE.getCode(), attribute);\n-\t\t\t\t\tlistOfItemsToModify.add(attributeItem);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t//For all attributes with operation REPLACE (2)\n-\t\tif(mapOfAttributes.containsKey(LdapOperation.REPLACE_ATTRIBUTE)) {\n-\t\t\tList<Pair<String,String>> listOfAttributesToReplace = mapOfAttributes.get(LdapOperation.REPLACE_ATTRIBUTE);\n-\t\t\tif(listOfAttributesToReplace != null) {\n-\t\t\t\tfor (Pair<String, String> pair : listOfAttributesToReplace) {\n-\t\t\t\t\tAttribute attribute;\n-\t\t\t\t\tif (pair.getRight() != null) attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n-\t\t\t\t\telse attribute = new BasicAttribute(pair.getLeft());\n-\t\t\t\t\tModificationItem attributeItem = new ModificationItem(LdapOperation.REPLACE_ATTRIBUTE.getCode(), attribute);\n-\t\t\t\t\tlistOfItemsToModify.add(attributeItem);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t//For all attributes with operation REMOVE (3)\n-\t\tif(mapOfAttributes.containsKey(LdapOperation.REMOVE_ATTRIBUTE)) {\n-\t\t\tList<Pair<String,String>> listOfAttributesToRemove = mapOfAttributes.get(LdapOperation.REMOVE_ATTRIBUTE);\n-\t\t\tif(listOfAttributesToRemove != null) {\n-\t\t\t\tfor (Pair<String, String> pair : listOfAttributesToRemove) {\n-\t\t\t\t\tAttribute attribute;\n-\t\t\t\t\tif (pair.getRight() != null) attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n-\t\t\t\t\telse attribute = new BasicAttribute(pair.getLeft());\n-\t\t\t\t\tModificationItem attributeItem = new ModificationItem(LdapOperation.REMOVE_ATTRIBUTE.getCode(), attribute);\n-\t\t\t\t\tlistOfItemsToModify.add(attributeItem);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn listOfItemsToModify;\n-\t}\n-\n-\t/**\n-\t * Fill objects from list of beans.\n-\t * If list of beans is empty or null, fill nothing.\n-\t *\n-\t * @param listOfBeans list of beans already parsed from message\n-\t *\n-\t * @throws InternalErrorException If there is some inconsistence in number of one type's objects.\n-\t */\n-\tprivate void emptyAndFillPerunBeans(List<PerunBean> listOfBeans) throws InternalErrorException {\n-\t\t//First null all usefull objects\n-\t\tresource = null;\n-\t\tmember = null;\n-\t\tgroup = null;\n-\t\tparentGroup = null;\n-\t\tvo = null;\n-\t\tuser = null;\n-\t\tspecificUser = null;\n-\t\tattribute = null;\n-\t\tattributeDef = null;\n-\t\tuserExtSource = null;\n-\t\tfacility = null;\n-\n-\t\t//If there is no usefull object, exit method\n-\t\tif(listOfBeans == null) return;\n-\n-\t\tfor(PerunBean perunBean: listOfBeans) {\n-\t\t\tif(perunBean instanceof Group) {\n-\t\t\t\tif(this.group == null) this.group = (Group) perunBean;\n-\t\t\t\telse this.parentGroup = (Group) perunBean;\n-\t\t\t} else if(perunBean instanceof Member) {\n-\t\t\t\tif(this.member == null) this.member = (Member) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one member come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof Vo) {\n-\t\t\t\tif(this.vo == null) this.vo = (Vo) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one vo come to method parserMessages!\");\n-\t\t\t} else if(perunBean instanceof User) {\n-\t\t\t\tUser u = (User) perunBean;\n-\t\t\t\tif(u.isServiceUser() || u.isSponsoredUser()) {\n-\t\t\t\t\tif(this.specificUser == null) this.specificUser = u;\n-\t\t\t\t\telse throw new InternalErrorException(\"More than one specificUser come to method parseMessages!\");\n-\t\t\t\t} else {\n-\t\t\t\t\tif(this.user == null) this.user = u;\n-\t\t\t\t\telse throw new InternalErrorException(\"More than one user come to method parseMessages!\");\n-\t\t\t\t}\n-\t\t\t} else if(perunBean instanceof AttributeDefinition && perunBean instanceof cz.metacentrum.perun.core.api.Attribute) {\n-\t\t\t\tif(this.attribute == null) this.attribute = (cz.metacentrum.perun.core.api.Attribute) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one attribute come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof AttributeDefinition ) {\n-\t\t\t\tif(this.attributeDef == null) this.attributeDef = (AttributeDefinition) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one attribute come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof UserExtSource) {\n-\t\t\t\tif(this.userExtSource == null) this.userExtSource = (UserExtSource) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one userExtSource come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof Resource) {\n-\t\t\t\tif(this.resource == null) this.resource = (Resource) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one Resource come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof Facility) {\n-\t\t\t\tif(this.facility == null) this.facility = (Facility) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one Facility come to method parseMessages!\");\n-\t\t\t}\n-\t\t}\n-\t}\n+    //Autowired variables\n+    @Autowired\n+    private LdapConnector ldapConnector;\n+    @Autowired\n+    private LdapcManager ldapcManager;\n+    @Autowired\n+    private LdapProperties ldapProperties;\n+\n+    //Other variables\n+    private AuditerConsumer auditerConsumer;\n+    private final static Logger log = LoggerFactory.getLogger(EventProcessorImpl.class);\n+    private boolean running = false;\n+\n+    //All parsable and useable objects\n+    Resource resource;\n+    Member member;\n+    Group group;\n+    Group parentGroup;\n+    Vo vo;\n+    User user;\n+    User specificUser;\n+    Facility facility;\n+    cz.metacentrum.perun.core.api.Attribute attribute;\n+    AttributeDefinition attributeDef;\n+    UserExtSource userExtSource;\n+\n+    //PATTERNS (used for searching in messages)\n+    //Common patterns\n+    private Pattern deletedPattern = Pattern.compile(\" deleted.$\");\n+    private Pattern createdPattern = Pattern.compile(\" created.$\");\n+    private Pattern updatedPattern = Pattern.compile(\" updated.$\");\n+    //Resources patterns\n+    private Pattern deletedResourcePattern = Pattern.compile(\" deleted.#Facility\");\n+    //Groups patterns\n+    private Pattern newGroupPattern = Pattern.compile(\" created in Vo:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+    private Pattern subGroupPattern = Pattern.compile(\" created in Vo:\\\\[(.*)\\\\] as subgroup of Group:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+    private Pattern assignGroupToResourcePattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] assigned to Resource:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+    private Pattern removeGroupFromResourcePattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] removed from Resource:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+    private Pattern moveGroupPattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] was moved\\\\.$\", Pattern.DOTALL);\n+    //Members patterns\n+    private Pattern addedToPattern = Pattern.compile(\" added to Group:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+    private Pattern totallyRemovedFromPatter = Pattern.compile(\" was removed from Group:\\\\[(.*)\\\\] totally\", Pattern.DOTALL);\n+    private Pattern validatedPattern = Pattern.compile(\" validated.$\");\n+    private Pattern otherStateOfMemberPattern = Pattern.compile(\"expired.$|disabled.$|invalidated.$|suspended #\");\n+    //Attributes patterns\n+    private Pattern facilitySetPattern = Pattern.compile(\" set for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+    private Pattern facilityRemovePattern = Pattern.compile(\" removed for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+    private Pattern facilityAllAttrsRemovedPattern = Pattern.compile(\"^All attributes removed for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+\n+    private Pattern userSetPattern = Pattern.compile(\" set for User:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+    private Pattern userRemovePattern = Pattern.compile(\" removed for User:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+    private Pattern userAllAttrsRemovedPattern = Pattern.compile(\"^All attributes removed for User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+\n+    private Pattern userUidNamespacePattern = Pattern.compile(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":uid-namespace:\");\n+    private Pattern userLoginNamespacePattern = Pattern.compile(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":login-namespace:\");\n+    //UserExtSources patterns\n+    private Pattern addUserExtSourcePattern = Pattern.compile(\"^UserExtSource:\\\\[(.*)\\\\] added to User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+    private Pattern removeUserExtSourcePattern = Pattern.compile(\"^UserExtSource:\\\\[(.*)\\\\] removed from User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+\n+    //CONSTANTS\n+    private static final String LDAP_NAME = \"ldap\";\n+    private static final String PATH_TO_ERROR_FILE = \"./errorParseMessageForLDAP.log\";\n+    private static final String PATH_TO_NOT_EXECUTED_ERROR_FILE = \"./notExecutedMessages.log\";\n+    private static final DateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n+\n+    //PERUN ATTRIBUTES NAMES\n+    public static final String perunAttrPreferredMail = \"preferredMail\";\n+    public static final String perunAttrMail = \"mail\";\n+    public static final String perunAttrOrganization = \"organization\";\n+    public static final String perunAttrPhone = \"phone\";\n+    public static final String perunAttrUserCertDNs = \"userCertDNs\";\n+    public static final String perunAttrBonaFideStatus = \"elixirBonaFideStatus\";\n+    public static final String perunAttrSchacHomeOrganizations = \"schacHomeOrganizations\";\n+    public static final String perunAttrEduPersonScopedAffiliations = \"eduPersonScopedAffiliations\";\n+    public static final String perunAttrLibraryIDs = \"libraryIDs\";\n+    public static final String perunAttrEntityID = \"entityID\";\n+    public static final String perunAttrClientID = \"OIDCClientID\";\n+    public static final String perunAttrGroupNames = \"groupNames\";\n+    public static final String perunAttrInstitutionsCountries = \"institutionsCountries\";\n+\n+    //LDAP ATTRIBUTES NAMES\n+    public static final String ldapAttrAssignedToResourceId = \"assignedToResourceId\";\n+    public static final String ldapAttrAssignedGroupId = \"assignedGroupId\";\n+    public static final String ldapAttrDescription = \"description\";\n+    public static final String ldapAttrCommonName = \"cn\";\n+    public static final String ldapAttrPerunUniqueGroupName = \"perunUniqueGroupName\";\n+    public static final String ldapAttrEduPersonPrincipalNames = \"eduPersonPrincipalNames\";\n+    public static final String ldapAttrPreferredMail = perunAttrPreferredMail;\n+    public static final String ldapAttrMail = perunAttrMail;\n+    public static final String ldapAttrOrganization = \"o\";\n+    public static final String ldapAttrTelephoneNumber = \"telephoneNumber\";\n+    public static final String ldapAttrUserCertDNs = \"userCertificateSubject\";\n+    public static final String ldapAttrBonaFideStatus = \"bonaFideStatus\";\n+    public static final String ldapAttrSchacHomeOrganizations = perunAttrSchacHomeOrganizations;\n+    public static final String ldapAttrEduPersonScopedAffiliations = perunAttrEduPersonScopedAffiliations;\n+    public static final String ldapAttrLibraryIDs = perunAttrLibraryIDs;\n+    public static final String ldapAttrUidNumber = \"uidNumber;x-ns-\";\n+    public static final String ldapAttrLogin = \"login;x-ns-\";\n+    public static final String ldapAttrUserPassword = \"userPassword\";\n+    public static final String ldapAttrSurname = \"sn\";\n+    public static final String ldapAttrGivenName = \"givenName\";\n+    public static final String ldapAttrEntityID = perunAttrEntityID;\n+    public static final String ldapAttrClientID = perunAttrClientID;\n+    public static final String ldapAttrObjectClass = \"objectClass\";\n+    public static final String ldapAttrPerunVoId = \"perunVoId\";\n+    public static final String ldapAttrPerunFacilityId = \"perunFacilityId\";\n+    public static final String ldapAttrPerunUserId = \"perunUserId\";\n+    public static final String ldapAttrPerunGroupId = \"perunGroupId\";\n+    public static final String ldapAttrPerunResourceId = \"perunResourceId\";\n+    public static final String ldapAttrPerunParentGroup = \"perunParentGroup\";\n+    public static final String ldapAttrPerunParentGroupId = \"perunParentGroupId\";\n+    public static final String ldapAttrMemberOf = \"memberOf\";\n+    public static final String ldapAttrUniqueMember = \"uniqueMember\";\n+    public static final String ldapAttrMemberOfPerunVo = \"memberOfPerunVo\";\n+    public static final String ldapAttrEntryStatus = \"entryStatus\";\n+    public static final String ldapAttrIsServiceUser = \"isServiceUser\";\n+    public static final String ldapAttrIsSponsoredUser = \"isSponsoredUser\";\n+    public static final String ldapAttrGroupNames = perunAttrGroupNames;\n+    public static final String ldapAttrInstitutionsCountries = perunAttrInstitutionsCountries;\n+\n+    //LDAP OBJECT CLASSES\n+    public static final String objectClassTop = \"top\";\n+    public static final String objectClassPerunResource = \"perunResource\";\n+    public static final String objectClassPerunGroup = \"perunGroup\";\n+    public static final String objectClassOrganization = \"organization\";\n+    public static final String objectClassPerunVO = \"perunVO\";\n+    public static final String objectClassPerson = \"person\";\n+    public static final String objectClassOrganizationalPerson = \"organizationalPerson\";\n+    public static final String objectClassInetOrgPerson = \"inetOrgPerson\";\n+    public static final String objectClassPerunUser = \"perunUser\";\n+    public static final String objectClassTenOperEntry = \"tenOperEntry\";\n+    public static final String objectClassInetUser = \"inetUser\";\n+\n+    //LDAP ORGANIZATION UNITS\n+    public static final String organizationalUnitPeople = \"ou=People\";\n+\n+    /**\n+     * This method waiting for new messages in AuditLog (using AuditerConsumer)\n+     * and then call method resolveMessage or catch exceptions and log data to files.\n+     *\n+     * @throws InterruptedException if thread is interrupted\n+     * @throws Exception            if some other exception like InternalErrorException are thrown\n+     */\n+    public void run() {\n+\n+        if (!ldapProperties.propsLoaded()) {\n+            throw new RuntimeException(\"LdapcProperties is not autowired correctly!\");\n+        }\n+\n+        //Get instance of auditerConsumer and set runnig to true\n+\n+        running = true;\n+        Integer lastProcessedIdNumber = 0;\n+        AuditMessage message = new AuditMessage(0, \"Empty\", null, null, null);\n+        List<AuditMessage> messages;\n+\n+        try {\n+            //If running is true, then this proccess will be continously\n+            while (running) {\n+\n+                messages = null;\n+                int sleepTime = 1000;\n+                //Waiting for new messages. If consumer failed in some internal case, waiting until it will be repaired (waiting time is increases by each attempt)\n+                do {\n+                    try {\n+                        //IMPORTANT STEP1: Get new bulk of messages\n+                        messages = Rpc.AuditMessagesManager.pollConsumerMessagesForParser(ldapcManager.getRpcCaller(), ldapProperties.getLdapConsumerName());\n+                    } catch (InternalErrorException ex) {\n+                        log.error(\"Consumer failed due to {}. Sleeping for {} ms.\", ex, sleepTime);\n+                        Thread.sleep(sleepTime);\n+                        sleepTime += sleepTime;\n+                    }\n+\n+                    //If there are no messages, sleep for 1 sec and then try it again\n+                    if (messages == null) {\n+                        Thread.sleep(1000);\n+                    }\n+                } while (messages == null);\n+                //If new messages exist, resolve them all\n+                Iterator<AuditMessage> messagesIterator = messages.iterator();\n+                while (messagesIterator.hasNext()) {\n+                    message = messagesIterator.next();\n+                    messagesIterator.remove();\n+                    //Warning when two consecutive messages are separated by more than 15 ids\n+                    if (lastProcessedIdNumber > 0 && lastProcessedIdNumber < message.getId()) {\n+                        if ((message.getId() - lastProcessedIdNumber) > 15) {\n+                            log.debug(\"SKIP FLAG WARNING: lastProcessedIdNumber: \" + lastProcessedIdNumber + \" - newMessageNumber: \" + message.getId() + \" = \" + (lastProcessedIdNumber - message.getId()));\n+                        }\n+                    }\n+                    lastProcessedIdNumber = message.getId();\n+                    //IMPORTANT STEP2: Resolve next message\n+                    this.resolveMessage(message.getMsg(), message.getId());\n+                }\n+                //After all messages has been resolved, test interrupting of thread and if its ok, wait and go for another bulk of messages\n+                if (Thread.interrupted()) {\n+                    running = false;\n+                } else {\n+                    Thread.sleep(5000);\n+                }\n+            }\n+            //If ldapc is interrupted\n+        } catch (InterruptedException e) {\n+            Date date = new Date();\n+            log.error(\"Last message has ID='\" + message.getId() + \"' and was INTERRUPTED at \" + DATE_FORMAT.format(date) + \" due to interrupting.\");\n+            running = false;\n+            Thread.currentThread().interrupt();\n+            //If some other exception is thrown\n+        } catch (Exception e) {\n+            Date date = new Date();\n+            log.error(\"Last message has ID='\" + message.getId() + \"' and was bad PARSED or EXECUTE at \" + DATE_FORMAT.format(date) + \" due to exception \" + e.toString());\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get a message and id of this message.\n+     * Parse the message and decide which way will be further processed.\n+     * Using patterns and objects to choose the way.\n+     * <p>\n+     * Additional Information:\n+     * -> For user and serviceUser there is the same behavior.\n+     * -> If there is only serviceUser (not serviceUser and user) the behavior for serviceUser is the same like for user (in LDAP)\n+     * -> If there are 2 groups in one message, expecting the first is subGroup and second is parentGroup\n+     * <p>\n+     * Possible ways (first and only 1 possible way with the lowest number is choose):\n+     * -> 1) GROUP and MEMBER exist\n+     * -> 1.1) if member status is valid => add member to group in LDAP\n+     * -> 1.2) if member was totally removed from group (totally means there is no direct or indirect existence of member in this group yet)\n+     * => remove member from this group in LDAP\n+     * -> 2) GROUP and PARENT_GROUP exist\n+     * -> 2.1) if there is message with adding subgroup => add group like subgroup of parentGroup in LDAP\n+     * -> 3) GROUP AND RESOURCE exist\n+     * -> 3.1) if there is message with adding group to resource => add resource to group (like attribute) in LDAP\n+     * -> 3.2) if there is message with removing group from resource => remove resource from group (like attribute) in LDAP\n+     * -> 4) only RESOURCE exists (resource must be before group because of\n+     * -> 4.1) if there is message with deleting resource => delete this resource from LDAP\n+     * -> 4.2) if there is message with createing resource => create this resource in LDAP\n+     * -> 4.3) if there is message with updating resource => update this resource in LDAP\n+     * -> 5) only GROUP exists\n+     * -> 5.1) if there is message with deleting group => delete this group from LDAP\n+     * -> 5.2) if there is message with creating group => create this group in LDAP\n+     * -> 5.3) if there is message with updating group => update this group in LDAP\n+     * -> 5.4) if there is message with moving group in the structure => modify existing group to the new state\n+     * -> 6) only MEMBER exists (RPC CALLING used)\n+     * -> 6.1) if there is message with changing of member state to valid => add member to all groups in LDAP where he needs to be\n+     * -> 6.2) if there is message with changing of member state to other than valid => remove member from all groups in LDAP where is needed\n+     * -> 7) only VO exists\n+     * -> 7.1) if there is message with deleting vo => delete this vo from LDAP\n+     * -> 7.2) if there is message with creating vo => create this vo in LDAP\n+     * -> 7.3) if there is message with updating vo => update this vo in LDAP\n+     * -> 8) USER and USER_EXT_SOURCE exist\n+     * -> 8.1) if there is message with adding userExtSource (IDP) to user => create or update attribute of user in LDAP\n+     * -> 8.2) if there is message with removing userExtSource (IDP) from user => remove or update attribute of user in LDAP\n+     * -> 9) USER and ATTRIBUTE exist\n+     * -> 9.1) if there is message with setting attribute to user => set Attribute to user in LDAP\n+     * -> 10) USER and ATTRIBUTE_DEFINITION exist\n+     * -> 10.1) if there is message with removing attribute from user => remove Attribute from user in LDAP\n+     * -> 11) only USER exists\n+     * -> 11.1) if there is message with deleting user => delete user from LDAP\n+     * -> 11.2) if there is message with creating user => create user in LDAP\n+     * -> 11.3) if there is message with updating user => update user in LDAP\n+     * -> 11.4) if there is message with removing all attribute from user => remove all attributes from user in LDAP (only removeable attributes)\n+     * -> 12) FACILITY and ATTRIBUTE exist\n+     * -> 12.1) if there is message with setting attribute to facility => set Attribute to resources (assigned to facility) in LDAP\n+     * -> 13) FACILITY and ATTRIBUTE_DEF exist\n+     * -> 13.1) if there is message with removing attribute from facility => remove Attribute from resources (assigned to facility) in LDAP\n+     * -> 14) in all other cases\n+     * -> 14.1) always => only log some information\n+     *\n+     * @param msg         message which need to be parse and resolve\n+     * @param idOfMessage id of paring/resolving message\n+     * @throws InternalErrorException when some internal error in core occurs\n+     */\n+    protected void resolveMessage(String msg, Integer idOfMessage) throws InternalErrorException {\n+\n+        List<PerunBean> listOfBeans;\n+        listOfBeans = AuditParser.parseLog(msg);\n+\n+        //Debug information to check parsing of message.\n+        if (!listOfBeans.isEmpty()) {\n+            int i = 0;\n+            for (PerunBean p : listOfBeans) {\n+                i++;\n+                if (p != null) {\n+                    log.debug(\"There is object number \" + i + \") \" + p.serializeToString());\n+                } else {\n+                    log.debug(\"There is unknow object which is null\");\n+                }\n+            }\n+        }\n+\n+        //Fill perunBeans\n+        emptyAndFillPerunBeans(listOfBeans);\n+\n+        //Log debug data for looking in messages\n+        log.debug(\"MessageNumber=\" + idOfMessage + \" -- OBJECTS: \" + this.member + '/' + this.group + '/' + this.facility + \"/\" + this.parentGroup + '/' + this.vo + '/'\n+                + this.resource + '/' + this.user + '/' + this.attribute + '/' + this.attributeDef + '/' + this.userExtSource);\n+\n+        //If specific user is the only one user in message, so behavior will be same for him like for any other user!\n+        if (this.specificUser != null && this.user == null) {\n+            this.user = this.specificUser;\n+        }\n+\n+        //------------------------------------------------------------------\n+        //-----------------OPERATIONS ON FILLED OBJECTS---------------------\n+        //------------------------------------------------------------------\n+        //Choose first possible solution for existing objects.\n+\n+        // 1) IF GROUP AND MEMBER WERE FOUND, TRY TO WORK WITH GROUP-MEMBER SPECIFIC OPERATIONS\n+        if (this.group != null && this.member != null) {\n+            // 1.1) ONLY FOR VALID MEMBER WE ADD HIM TO THE GROUP IN LDAP\n+            if (this.member.getStatus().equals(Status.VALID)) {\n+                Matcher addedTo = addedToPattern.matcher(msg);\n+\n+                if (addedTo.find()) {\n+                    if (!ldapConnector.isAlreadyMember(this.member, this.group)) {\n+                        ldapConnector.addMemberToGroup(this.member, this.group);\n+                    }\n+                }\n+            }\n+            // 1.2) MEMBER WILL BE REMOVED FROM GROUP\n+            Matcher totallyRemovedFrom = totallyRemovedFromPatter.matcher(msg);\n+\n+            if (totallyRemovedFrom.find()) {\n+                if (ldapConnector.isAlreadyMember(this.member, this.group)) {\n+                    ldapConnector.removeMemberFromGroup(this.member, this.group);\n+                }\n+            }\n+\n+            // 2) IF 2 GROUPS WERE FOUND, TRY TO WORK WITH PARENT_GROUP-SUBGROUP SPECIFIC OPERATIONS\n+        } else if (this.group != null && this.parentGroup != null) {\n+            Matcher newSubGroup = subGroupPattern.matcher(msg);\n+\n+            // 2.1) ADD GROUP AS SUBGROUP TO PARENT_GROUP\n+            if (newSubGroup.find()) {\n+                ldapConnector.addGroupAsSubGroup(this.group, this.parentGroup);\n+            }\n+\n+            // 3) IF GROUP AND RESOURCE WERE FOUND, TRY TO WORK WITH GROUP-RESOURCE SPECIFIC OPERATIONS\n+        } else if (this.group != null && this.resource != null) {\n+            Matcher assigned = assignGroupToResourcePattern.matcher(msg);\n+            Matcher removed = removeGroupFromResourcePattern.matcher(msg);\n+\n+            // 3.1) ADD NEW RESOURCE FOR GROUP IN LDAP\n+            if (assigned.find()) {\n+                updateGroupAttribute(ldapAttrAssignedToResourceId, String.valueOf(this.resource.getId()), LdapOperation.ADD_ATTRIBUTE, this.group);\n+                updateResourceAttribute(ldapAttrAssignedGroupId, String.valueOf(this.group.getId()), LdapOperation.ADD_ATTRIBUTE, this.resource);\n+                // 3.2) REMOVE RESOURCE FROM GROUP IN LDAP\n+            } else if (removed.find()) {\n+                updateGroupAttribute(ldapAttrAssignedToResourceId, String.valueOf(this.resource.getId()), LdapOperation.REMOVE_ATTRIBUTE, this.group);\n+                updateResourceAttribute(ldapAttrAssignedGroupId, String.valueOf(this.group.getId()), LdapOperation.REMOVE_ATTRIBUTE, this.resource);\n+            }\n+            // 4) IF ONLY RESOURCE WERE FOUND, TRY TO WORK WITH RESOURCE SPECIFIC OPERATIONS\n+        } else if (this.resource != null) {\n+            Matcher deleted = deletedResourcePattern.matcher(msg);\n+            Matcher created = createdPattern.matcher(msg);\n+            Matcher updated = updatedPattern.matcher(msg);\n+\n+            // 4.1) RESOURCE WILL BE DELETED\n+            if (deleted.find()) {\n+                ldapConnector.deleteResource(resource);\n+                // 4.2) RESOURCE WILL BE CREATED\n+            } else if (created.find()) {\n+                ldapConnector.createResource(resource, getFacilityEntityIdValue(resource.getFacilityId()));\n+                // 4.3) RESOURCE WILL BE UPDATED\n+            } else if (updated.find()) {\n+                Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<>();\n+                List<Pair<String, String>> replaceList = new ArrayList<>();\n+                replaceList.add(new Pair(ldapAttrCommonName, this.resource.getName()));\n+                if (this.resource.getDescription() != null && !this.resource.getDescription().isEmpty()) {\n+                    replaceList.add(new Pair(ldapAttrDescription, this.resource.getDescription()));\n+                }\n+                attributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n+                updateResourceAttributes(attributes, this.resource);\n+            }\n+            // 5) IF ONLY GROUP WERE FOUND, TRY TO WORK WITH GROUP SPECIFIC OPERATIONS\n+        } else if (this.group != null) {\n+            Matcher deleted = deletedPattern.matcher(msg);\n+            Matcher newGroup = newGroupPattern.matcher(msg);\n+            Matcher updated = updatedPattern.matcher(msg);\n+            Matcher moveGroup = moveGroupPattern.matcher(msg);\n+\n+            if (deleted.find()) {\n+                // 5.1) GROUP WILL BE DELETED\n+                ldapConnector.removeGroup(this.group);\n+            } else if (newGroup.find()) {\n+                // 5.2) GROUP WILL BE CREATED\n+                ldapConnector.addGroup(this.group);\n+            } else if (updated.find()) {\n+                // 5.3) GROUP WILL BE UPDATED\n+                updateGroup(group);\n+            } else if (moveGroup.find()) {\n+                // 5.4) MOVE GROUP IN STRUCTURE\n+                moveGroup(group);\n+            }\n+\n+            // 6) IF MEMBER WAS FOUND, TRY TO WORK WITH MEMBER SPECIFIC OPERATIONS (! RPC CALLING used there !)\n+        } else if (this.member != null) {\n+            Matcher validated = validatedPattern.matcher(msg);\n+            Matcher otherStateOfMember = otherStateOfMemberPattern.matcher(msg);\n+\n+            // 6.1) MEMBER WAS VALIDATED, NEED TO ADD HIM TO ALL GROUPS\n+            if (validated.find()) {\n+                List<Group> memberGroups = new ArrayList<Group>();\n+                try {\n+                    memberGroups = Rpc.GroupsManager.getAllMemberGroups(ldapcManager.getRpcCaller(), this.member);\n+                } catch (MemberNotExistsException e) {\n+                    //IMPORTANT this is not problem, if member not exist, we expected that will be deleted in some message after that, in DB is deleted\n+                } catch (PrivilegeException e) {\n+                    throw new InternalErrorException(\"There are no privilegies for getting member's groups\", e);\n+                } catch (InternalErrorException e) {\n+                    throw e;\n+                }\n+                for (Group g : memberGroups) {\n+                    if (!ldapConnector.isAlreadyMember(this.member, g)) {\n+                        ldapConnector.addMemberToGroup(this.member, g);\n+                    }\n+                }\n+                // 6.2) MEMBER STATE WAS CHANGED TO OTHER STATE THAN VALIDATE\n+            } else if (otherStateOfMember.find()) {\n+                List<Group> memberGroups = new ArrayList<Group>();\n+                try {\n+                    memberGroups = Rpc.GroupsManager.getAllMemberGroups(ldapcManager.getRpcCaller(), this.member);\n+                } catch (MemberNotExistsException e) {\n+                    //IMPORTATNT this is not problem, if member not exist, we expected that will be deleted in some message after that, in DB is deleted\n+                } catch (PrivilegeException e) {\n+                    throw new InternalErrorException(\"There are no privilegies for getting member's groups\", e);\n+                } catch (InternalErrorException e) {\n+                    throw e;\n+                }\n+                for (Group g : memberGroups) {\n+                    if (ldapConnector.isAlreadyMember(this.member, g)) {\n+                        ldapConnector.removeMemberFromGroup(this.member, g);\n+                    }\n+                }\n+            }\n+\n+            // 7) IF VO WAS FOUND, TRY TO WORK WITH VO SPECIFIC OPERATIONS\n+        } else if (this.vo != null) {\n+            Matcher deleted = deletedPattern.matcher(msg);\n+            Matcher created = createdPattern.matcher(msg);\n+            Matcher updated = updatedPattern.matcher(msg);\n+\n+            // 7.1) VO WILL BE DELETED\n+            if (deleted.find()) {\n+                ldapConnector.deleteVo(this.vo);\n+                // 7.2) VO WILL BE CREATED\n+            } else if (created.find()) {\n+                ldapConnector.createVo(this.vo);\n+                // 7.3) VO WILL BE UPDATED\n+            } else if (updated.find()) {\n+                Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n+                List<Pair<String, String>> replaceList = new ArrayList<Pair<String, String>>();\n+                replaceList.add(new Pair(ldapAttrDescription, this.vo.getName()));\n+                attributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n+                updateVoAttributes(attributes, this.vo);\n+            }\n+\n+            // 8) IF USER AND USEREXTSOURCE WERE FOUND, TRY TO WORK WITH USER-USEREXTSOURCE SPECIFIC OPERATIONS (LIKE SET EXT LOGINS FOR IDP EXTSOURCES)\n+        } else if (this.user != null && this.userExtSource != null) {\n+            Matcher addExtSource = addUserExtSourcePattern.matcher(msg);\n+            Matcher removeExtSource = removeUserExtSourcePattern.matcher(msg);\n+\n+            // 8.1) ADD ATTRIBUTE WITH IDP EXTSOURCE\n+            if (addExtSource.find()) {\n+                if (this.userExtSource.getExtSource() != null && this.userExtSource.getExtSource().getType() != null) {\n+                    String extLogin;\n+                    if (this.userExtSource.getExtSource().getType().equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n+                        extLogin = this.userExtSource.getLogin();\n+                        if (extLogin == null) {\n+                            extLogin = \"\";\n+                        }\n+                        updateUserAttribute(ldapAttrEduPersonPrincipalNames, extLogin, LdapOperation.ADD_ATTRIBUTE, user);\n+                    }\n+                }\n+                // 8.2) REMOVE ATTRIBUTE WITH IDP EXTSOURCE\n+            } else if (removeExtSource.find()) {\n+                if (this.userExtSource.getExtSource() != null && this.userExtSource.getExtSource().getType() != null) {\n+                    String extLogin;\n+                    if (this.userExtSource.getExtSource().getType().equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n+                        extLogin = this.userExtSource.getLogin();\n+                        if (extLogin == null) {\n+                            extLogin = \"\";\n+                        }\n+                        updateUserAttribute(ldapAttrEduPersonPrincipalNames, extLogin, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+                }\n+            }\n+\n+            // 9) IF USER AND ATTRIBUTE WERE FOUND, TRY TO WORK WITH USER-ATTR SPECIFIC OPERATIONS (LIKE SET USER ATTRIBUTES)\n+        } else if (this.user != null && this.attribute != null) {\n+            Matcher set = userSetPattern.matcher(msg);\n+\n+            // 9.1) SOME USER ATTRIBUTE WILL BE PROBABLY SET (IF IT IS ONE OF SPECIFIC ATTRIBUTES)\n+            if (set.find()) {\n+                Matcher uidMatcher = userUidNamespacePattern.matcher(this.attribute.getName());\n+                Matcher loginMatcher = userLoginNamespacePattern.matcher(this.attribute.getName());\n+\n+                if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail)) {\n+                    //this mean change of attribute preferredMail in User\n+                    if (this.attribute.getValue() != null) {\n+                        updateUserAttribute(ldapAttrPreferredMail, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, user);\n+                        updateUserAttribute(ldapAttrMail, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, user);\n+                    } else {\n+                        if (ldapConnector.userAttributeExist(this.user, ldapAttrPreferredMail)) {\n+                            updateUserAttribute(ldapAttrPreferredMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                        }\n+                        if (ldapConnector.userAttributeExist(this.user, ldapAttrMail)) {\n+                            updateUserAttribute(ldapAttrMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                        }\n+                    }\n+\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrOrganization)) {\n+                    if (this.attribute.getValue() != null) {\n+                        updateUserAttribute(ldapAttrOrganization, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                    } else {\n+                        if (ldapConnector.userAttributeExist(this.user, ldapAttrOrganization)) {\n+                            updateUserAttribute(ldapAttrOrganization, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                        }\n+                    }\n+\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPhone)) {\n+                    if (this.attribute.getValue() != null) {\n+                        updateUserAttribute(ldapAttrTelephoneNumber, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                    } else {\n+                        if (ldapConnector.userAttributeExist(this.user, ldapAttrTelephoneNumber)) {\n+                            updateUserAttribute(ldapAttrTelephoneNumber, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                        }\n+                    }\n+\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrUserCertDNs)) {\n+                    Map<String, String> certDNsMap = (this.attribute.getValue() != null) ? (Map) this.attribute.getValue() : null;\n+\n+                    if (certDNsMap == null || certDNsMap.isEmpty()) {\n+                        if (ldapConnector.userAttributeExist(this.user, ldapAttrUserCertDNs)) {\n+                            updateUserAttribute(ldapAttrUserCertDNs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                        }\n+                    } else {\n+                        Set<String> certSubjectsWithPrefixes = ((Map) this.attribute.getValue()).keySet();\n+                        Set<String> certSubjectsWithoutPrefixes = new HashSet<>();\n+                        //remove prefixes from certificates\n+                        for (String key : certSubjectsWithPrefixes) {\n+                            certSubjectsWithoutPrefixes.add(key.replaceFirst(\"^[0-9]+[:]\", \"\"));\n+                        }\n+                        String[] subjectsArray = Arrays.copyOf(certSubjectsWithoutPrefixes.toArray(), certSubjectsWithoutPrefixes.toArray().length, String[].class);\n+                        ldapConnector.updateUsersAttributeInLDAP(String.valueOf(this.user.getId()), ldapAttrUserCertDNs, subjectsArray);\n+                    }\n+\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrBonaFideStatus)) {\n+                    if (this.attribute.getValue() != null) {\n+                        updateUserAttribute(ldapAttrBonaFideStatus, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                    } else {\n+                        if (ldapConnector.userAttributeExist(this.user, ldapAttrBonaFideStatus)) {\n+                            updateUserAttribute(ldapAttrBonaFideStatus, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                        }\n+                    }\n+\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrSchacHomeOrganizations)) {\n+                    updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrSchacHomeOrganizations);\n+\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrEduPersonScopedAffiliations)) {\n+                    updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrEduPersonScopedAffiliations);\n+\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrGroupNames)) {\n+                    updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrGroupNames);\n+\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrInstitutionsCountries)) {\n+                    updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrInstitutionsCountries);\n+\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrLibraryIDs)) {\n+                    updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrLibraryIDs);\n+\n+                } else if (uidMatcher.find()) {\n+                    if (this.attribute.getValue() != null) {\n+                        updateUserAttribute(ldapAttrUidNumber + this.attribute.getFriendlyNameParameter(), String.valueOf((Integer) this.attribute.getValue()), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                    } else {\n+                        if (ldapConnector.userAttributeExist(this.user, ldapAttrUidNumber + this.attribute.getFriendlyNameParameter())) {\n+                            updateUserAttribute(ldapAttrUidNumber + this.attribute.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                        }\n+                    }\n+\n+                } else if (loginMatcher.find()) {\n+                    if (this.attribute.getValue() != null) {\n+                        updateUserAttribute(ldapAttrLogin + this.attribute.getFriendlyNameParameter(), (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                        //if login is from loginNamespace (eg. EINFRA) (new value), then userPassword must be set or modified\n+                        if (ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attribute.getFriendlyNameParameter())) {\n+                            updateUserAttribute(ldapAttrUserPassword, \"{SASL}\" + this.attribute.getValue() + \"@\" + ldapProperties.getLdapLoginNamespace(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                        }\n+                    } else {\n+                        if (ldapConnector.userAttributeExist(this.user, ldapAttrLogin + this.attribute.getFriendlyNameParameter())) {\n+                            updateUserAttribute(ldapAttrLogin + this.attribute.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                        }\n+                        if (ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attribute.getFriendlyNameParameter())) {\n+                            if (ldapConnector.userAttributeExist(this.user, ldapAttrUserPassword)) {\n+                                updateUserAttribute(ldapAttrUserPassword, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // 10) IF USER AND ATTRIBTUE DEFINITION WERE FOUND, TRY TO WORK WITH USER-ATTRDEF SPECIFIC OPERATIONS\n+        } else if (this.user != null && attributeDef != null) {\n+            Matcher remove = userRemovePattern.matcher(msg);\n+            // 10.1) REMOVE SPECIFIC USER ATTRIBUTE\n+            if (remove.find() && ldapConnector.userExist(this.user)) {\n+                Matcher uidMatcher = userUidNamespacePattern.matcher(this.attributeDef.getName());\n+                Matcher loginMatcher = userLoginNamespacePattern.matcher(this.attributeDef.getName());\n+                if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrPreferredMail)) {\n+                        updateUserAttribute(ldapAttrPreferredMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrMail)) {\n+                        updateUserAttribute(ldapAttrMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+                    //TODO: organization (user) will not exists\n+\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrOrganization)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrOrganization)) {\n+                        updateUserAttribute(ldapAttrOrganization, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPhone)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrTelephoneNumber)) {\n+                        updateUserAttribute(ldapAttrTelephoneNumber, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrUserCertDNs)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrUserCertDNs)) {\n+                        updateUserAttribute(ldapAttrUserCertDNs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrEduPersonScopedAffiliations)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrEduPersonScopedAffiliations)) {\n+                        updateUserAttribute(ldapAttrEduPersonScopedAffiliations, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrGroupNames)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrGroupNames)) {\n+                        updateUserAttribute(ldapAttrGroupNames, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrInstitutionsCountries)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrInstitutionsCountries)) {\n+                        updateUserAttribute(ldapAttrInstitutionsCountries, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrBonaFideStatus)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrBonaFideStatus)) {\n+                        updateUserAttribute(ldapAttrBonaFideStatus, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrSchacHomeOrganizations)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrSchacHomeOrganizations)) {\n+                        updateUserAttribute(ldapAttrSchacHomeOrganizations, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrLibraryIDs)) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrLibraryIDs)) {\n+                        updateUserAttribute(ldapAttrLibraryIDs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (uidMatcher.find()) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrUidNumber + this.attributeDef.getFriendlyNameParameter())) {\n+                        updateUserAttribute(ldapAttrUidNumber + this.attributeDef.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+\n+                } else if (loginMatcher.find()) {\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrLogin + this.attributeDef.getFriendlyNameParameter())) {\n+                        updateUserAttribute(ldapAttrLogin + this.attributeDef.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+                    if (ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attributeDef.getFriendlyNameParameter())) {\n+                        if (ldapConnector.userPasswordExists(this.user)) {\n+                            updateUserAttribute(ldapAttrUserPassword, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                        }\n+                    }\n+                }\n+            }\n+            // 11) IF ONLY USER WAS FOUND, TRY TO WORK WITH USER SPECIFIC OPERATIONS\n+        } else if (this.user != null) {\n+            Matcher deleted = deletedPattern.matcher(msg);\n+            Matcher created = createdPattern.matcher(msg);\n+            Matcher updated = updatedPattern.matcher(msg);\n+            Matcher removedAllAttrs = userAllAttrsRemovedPattern.matcher(msg);\n+            // 11.1) DELETE USER\n+            if (deleted.find()) {\n+                ldapConnector.deleteUser(this.user);\n+                // 11.2) CREATE USER\n+            } else if (created.find()) {\n+                ldapConnector.createUser(this.user);\n+                // 11.3) UPDATE USER\n+            } else if (updated.find()) {\n+                Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n+                List<Pair<String, String>> replaceList = new ArrayList<Pair<String, String>>();\n+                String firstName = this.user.getFirstName();\n+                String lastName = this.user.getLastName();\n+                String commonName = \"\";\n+                if (firstName == null || firstName.isEmpty()) {\n+                    firstName = \"\";\n+                } else {\n+                    commonName += firstName + \" \";\n+                }\n+                if (lastName == null || lastName.isEmpty()) {\n+                    lastName = \"N/A\";\n+                }\n+                commonName += lastName;\n+                replaceList.add(new Pair(ldapAttrSurname, lastName));\n+                replaceList.add(new Pair(ldapAttrCommonName, commonName));\n+                // IF firstName is empty, maybe need to be removed first\n+                if (firstName.isEmpty()) {\n+                    //if first name exists and new one is empty, then remove it, else do nothing\n+                    if (ldapConnector.userAttributeExist(this.user, ldapAttrGivenName)) {\n+                        updateUserAttribute(ldapAttrGivenName, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                    }\n+                } else {\n+                    //if first name is not empty, replace it by new first name\n+                    replaceList.add(new Pair(ldapAttrGivenName, firstName));\n+                }\n+                attributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n+                updateUserAttributes(attributes, this.user);\n+                // 11.4) REMOVE ALL USER ATTRIBUTES\n+            } else if (removedAllAttrs.find()) {\n+                if (ldapConnector.userExist(this.user)) {\n+                    Attributes usersAttrs = ldapConnector.getAllUsersAttributes(this.user);\n+                    List<ModificationItem> listOfItems = new ArrayList<ModificationItem>();\n+                    if (usersAttrs != null) {\n+                        NamingEnumeration<? extends Attribute> attributesEnumeration;\n+                        attributesEnumeration = usersAttrs.getAll();\n+                        try {\n+                            while (attributesEnumeration.hasMore()) {\n+                                Attribute attr = attributesEnumeration.nextElement();\n+                                if (attr != null && attr.getID() != null) {\n+                                    if (isRemovableUserAttribute(attr.getID())) {\n+                                        ModificationItem item = new ModificationItem(LdapOperation.REMOVE_ATTRIBUTE.getCode(), attr);\n+                                        listOfItems.add(item);\n+                                    }\n+                                }\n+                            }\n+                        } catch (NamingException ex) {\n+                            throw new InternalErrorException(\"Error at Deleting All Users Attribute, throw namingException.\", ex);\n+                        }\n+                    }\n+                    if (!listOfItems.isEmpty()) {\n+                        ModificationItem[] items = Arrays.copyOf(listOfItems.toArray(), listOfItems.toArray().length, ModificationItem[].class);\n+                        ldapConnector.updateUser(this.user, items);\n+                    }\n+                }\n+            }\n+\n+            //12) IF FACILITY AND ATTRIBUTE TO SET WAS FOUND\n+        } else if (this.facility != null && attribute != null) {\n+            Matcher set = facilitySetPattern.matcher(msg);\n+\n+            // 12.1) SOME FACILITY ATTRIBUTE WILL BE PROBABLY SET (IF IT IS ONE OF SPECIFIC ATTRIBUTES)\n+            if (set.find()) {\n+                //EntityID WILL BE SET\n+                if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID)) {\n+                    try {\n+                        List<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n+                        //this mean change of attribute entityID in all assigned resources\n+                        if (this.attribute.getValue() != null) {\n+                            for (Resource res : resources) {\n+                                updateResourceAttribute(ldapAttrEntityID, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, res);\n+                            }\n+                        } else {\n+                            for (Resource res : resources) {\n+                                if (ldapConnector.resourceAttributeExist(res, ldapAttrEntityID)) {\n+                                    updateResourceAttribute(ldapAttrEntityID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n+                                }\n+                            }\n+                        }\n+                    } catch (FacilityNotExistsException ex) {\n+                        //this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n+                        //so skip it just log\n+                        log.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n+                    } catch (PrivilegeException e) {\n+                        throw new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n+                    }\n+                    //OIDCClientID WILL BE SET\n+                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrClientID)) {\n+                    try {\n+                        List<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n+                        //this mean change of attribute clientID in all assigned resources\n+                        if (this.attribute.getValue() != null) {\n+                            for (Resource res : resources) {\n+                                updateResourceAttribute(ldapAttrClientID, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, res);\n+                            }\n+                        } else {\n+                            for (Resource res : resources) {\n+                                if (ldapConnector.resourceAttributeExist(res, ldapAttrClientID)) {\n+                                    updateResourceAttribute(ldapAttrClientID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n+                                }\n+                            }\n+                        }\n+                    } catch (FacilityNotExistsException ex) {\n+                        //this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n+                        //so skip it just log\n+                        log.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n+                    } catch (PrivilegeException e) {\n+                        throw new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n+                    }\n+                }\n+            }\n+            //13) IF FACILITY AND ATTRIBUTE DEF TO REMOVE WAS FOUND\n+        } else if (this.facility != null && attributeDef != null) {\n+            Matcher remove = facilityRemovePattern.matcher(msg);\n+            // 13.1) REMOVE SPECIFIC FACILITY ATTRIBUTE\n+            if (remove.find()) {\n+                if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID)) {\n+                    try {\n+                        List<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n+                        for (Resource res : resources) {\n+                            if (ldapConnector.resourceAttributeExist(res, ldapAttrEntityID)) {\n+                                updateResourceAttribute(ldapAttrEntityID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n+                            }\n+                        }\n+                    } catch (FacilityNotExistsException ex) {\n+                        //this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n+                        //so skip it just log\n+                        log.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n+                    } catch (PrivilegeException e) {\n+                        throw new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n+                    }\n+                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrClientID)) {\n+                    try {\n+                        List<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n+                        for (Resource res : resources) {\n+                            if (ldapConnector.resourceAttributeExist(res, ldapAttrClientID)) {\n+                                updateResourceAttribute(ldapAttrClientID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n+                            }\n+                        }\n+                    } catch (FacilityNotExistsException ex) {\n+                        //this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n+                        //so skip it just log\n+                        log.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n+                    } catch (PrivilegeException e) {\n+                        throw new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n+                    }\n+                }\n+            }\n+            // 14) IN OTHER CASES\n+        } else {\n+            log.debug(\"Nothing to resolve for message with number : \" + idOfMessage);\n+        }\n+    }\n+\n+    /**\n+     * Choose if attribute is removable or not.\n+     * It means if is this attribute is required and can't be null.\n+     *\n+     * @param attributeName name of attribute in ldap\n+     * @return true if attribute is removable, false if not\n+     */\n+    private boolean isRemovableUserAttribute(String attributeName) {\n+        List<String> attributesWithoutOption = new ArrayList<String>();\n+        //Attributes without option like \"x-ns-namespace\"\n+        attributesWithoutOption.add(ldapAttrMail);\n+        attributesWithoutOption.add(ldapAttrPreferredMail);\n+        attributesWithoutOption.add(ldapAttrOrganization);\n+        attributesWithoutOption.add(ldapAttrUserCertDNs);\n+        attributesWithoutOption.add(ldapAttrSchacHomeOrganizations);\n+        attributesWithoutOption.add(ldapAttrBonaFideStatus);\n+        attributesWithoutOption.add(ldapAttrEduPersonScopedAffiliations);\n+        attributesWithoutOption.add(ldapAttrLibraryIDs);\n+        attributesWithoutOption.add(ldapAttrTelephoneNumber);\n+        attributesWithoutOption.add(ldapAttrInstitutionsCountries);\n+        attributesWithoutOption.add(ldapAttrGroupNames);\n+        attributesWithoutOption.add(ldapAttrMemberOfPerunVo);\n+        attributesWithoutOption.add(ldapAttrEduPersonPrincipalNames);\n+        if (attributesWithoutOption.contains(attributeName)) {\n+            return true;\n+        }\n+\n+        //Attributes with option like \"x-ns-namespace\"\n+        List<String> attributesWithOption = new ArrayList<String>();\n+        attributesWithOption.add(ldapAttrUidNumber);\n+        attributesWithOption.add(ldapAttrLogin);\n+        attributesWithOption.add(ldapAttrUserPassword);\n+\n+        for (String s : attributesWithOption) {\n+            if (attributeName.startsWith(s)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Get User preferred Mail value from perun.\n+     *\n+     * @param user the user\n+     * @return value of user's preferredMail or null, if value is null or user not exists yet\n+     * @throws InternalErrorException if some exception (except UserNotExistsException) is thrown from RPC\n+     */\n+    private String getUserPreferredMailValue(User user) throws InternalErrorException {\n+        cz.metacentrum.perun.core.api.Attribute preferredMailAttr = null;\n+        try {\n+            preferredMailAttr = Rpc.AttributesManager.getAttribute(ldapcManager.getRpcCaller(), user, cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail);\n+        } catch (PrivilegeException ex) {\n+            throw new InternalErrorException(\"There are no privilegies for getting user's attribute.\", ex);\n+        } catch (AttributeNotExistsException ex) {\n+            throw new InternalErrorException(\"There is no such attribute.\", ex);\n+        } catch (UserNotExistsException ex) {\n+            //If user not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n+            return null;\n+        } catch (WrongAttributeAssignmentException ex) {\n+            throw new InternalErrorException(\"There is problem with wrong attribute assignment exception.\", ex);\n+        }\n+        if (preferredMailAttr.getValue() == null) {\n+            return null;\n+        } else {\n+            return (String) preferredMailAttr.getValue();\n+        }\n+    }\n+\n+    /**\n+     * Get entityID value from perun by facilityId.\n+     *\n+     * @param facilityId the facilityId\n+     * @return value of entityID or null, if value is null or user not exists yet\n+     * @throws InternalErrorException if some exception is thrown from RPC\n+     */\n+    private String getFacilityEntityIdValue(int facilityId) throws InternalErrorException {\n+        Facility facility = null;\n+        try {\n+            facility = Rpc.FacilitiesManager.getFacilityById(ldapcManager.getRpcCaller(), facilityId);\n+        } catch (PrivilegeException ex) {\n+            throw new InternalErrorException(\"There are no privilegies for getting facility by id.\", ex);\n+        } catch (FacilityNotExistsException ex) {\n+            //If facility not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n+            return null;\n+        }\n+\n+        cz.metacentrum.perun.core.api.Attribute entityID = null;\n+        try {\n+            entityID = Rpc.AttributesManager.getAttribute(ldapcManager.getRpcCaller(), facility, AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID);\n+        } catch (PrivilegeException ex) {\n+            throw new InternalErrorException(\"There are no privilegies for getting facility attribute.\", ex);\n+        } catch (AttributeNotExistsException ex) {\n+            throw new InternalErrorException(\"There is no such attribute.\", ex);\n+        } catch (FacilityNotExistsException ex) {\n+            //If facility not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n+            return null;\n+        } catch (WrongAttributeAssignmentException ex) {\n+            throw new InternalErrorException(\"There is problem with wrong attribute assignment exception.\", ex);\n+        }\n+        if (entityID.getValue() == null) {\n+            return null;\n+        } else {\n+            return (String) entityID.getValue();\n+        }\n+    }\n+\n+    /**\n+     * Update ldap attribute with attributeName for the user by value with operation.\n+     *\n+     * @param attributeName  name of attribute, is mandatory, cant be null\n+     * @param attributeValue value of attribute, is not mandatory, can be null\n+     * @param operation      add, remove or replace (can't be null)\n+     * @param user           cant be null\n+     * @throws InternalErrorException if an error occurs\n+     */\n+    private void updateUserAttribute(String attributeName, String attributeValue, LdapOperation operation, User user) throws InternalErrorException {\n+        if (operation == null) {\n+            throw new InternalErrorException(\"Operation can't be null\");\n+        }\n+        if (attributeName == null || attributeName.equals(\"\")) {\n+            throw new InternalErrorException(\"Bad attribute Name in method updateUserAttribute :\" + attributeName);\n+        }\n+        if (user == null) {\n+            throw new InternalErrorException(\"User is null in method updateUserAttribute\");\n+        }\n+\n+        Attribute attribute;\n+        if (attributeValue != null) {\n+            attribute = new BasicAttribute(attributeName, attributeValue);\n+        } else {\n+            attribute = new BasicAttribute(attributeName);\n+        }\n+\n+        ModificationItem attributeItem = new ModificationItem(operation.getCode(), attribute);\n+        ldapConnector.updateUser(user, new ModificationItem[] {attributeItem});\n+    }\n+\n+    /**\n+     * Update user's ldap attributes from Map by operation in key.\n+     * <p>\n+     * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n+     * <p>\n+     * <p>\n+     * attributeName cant be null and empty String\n+     * attributeValue can be null\n+     * <p>\n+     * Execute all operations on all attributes with (or without value) in 1 task.\n+     *\n+     * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n+     * @param user            cant be null\n+     * @throws InternalErrorException if an error occurs\n+     */\n+    private void updateUserAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, User user) throws InternalErrorException {\n+        //User cant be null\n+        if (user == null) {\n+            throw new InternalErrorException(\"User is null in method updateUserAttributes\");\n+        }\n+\n+        Set<LdapOperation> keys = mapOfAttributes.keySet();\n+\n+        //Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n+        for (LdapOperation operation : keys) {\n+            List<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n+            for (Pair<String, String> pair : listOfAttrs) {\n+                if (pair.getLeft() == null || pair.getLeft().equals(\"\")) {\n+                    throw new InternalErrorException(\"Some attributes in map has no name.\");\n+                }\n+            }\n+        }\n+\n+        //If all is correct, can execute operations on attributes\n+        List<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n+\n+        //Execute all changes on the notEmpty list of items\n+        if (!listOfItemsToModify.isEmpty()) {\n+            ModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n+            ldapConnector.updateUser(user, items);\n+        }\n+    }\n+\n+    /**\n+     * Update ldap attribute with attributeName for the resource by value with operation.\n+     *\n+     * @param attributeName  name of attribute, is mandatory, cant be null\n+     * @param attributeValue value of attribute, is not mandatory, can be null\n+     * @param operation      add, replace or remove, can't be null\n+     * @param resource       cant be null\n+     * @throws InternalErrorException if an error occurs\n+     */\n+    private void updateResourceAttribute(String attributeName, String attributeValue, LdapOperation operation, Resource resource) throws InternalErrorException {\n+        if (operation == null) {\n+            throw new InternalErrorException(\"Operation can't be null.\");\n+        }\n+        if (attributeName == null || attributeName.equals(\"\")) {\n+            throw new InternalErrorException(\"Bad attribute Name in method updateResourceAttribute :\" + attributeName);\n+        }\n+        if (resource == null) {\n+            throw new InternalErrorException(\"Resource is null in method updateResourceAttribute\");\n+        }\n+\n+        Attribute attribute;\n+        if (attributeValue != null) {\n+            attribute = new BasicAttribute(attributeName, attributeValue);\n+        } else {\n+            attribute = new BasicAttribute(attributeName);\n+        }\n+\n+        ModificationItem attributeItem = new ModificationItem(operation.getCode(), attribute);\n+        ldapConnector.updateResource(resource, new ModificationItem[] {attributeItem});\n+    }\n+\n+    /**\n+     * Update resource's ldap attributes from Map by operation in key.\n+     * <p>\n+     * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n+     * <p>\n+     * attributeName cant be null and empty String\n+     * attributeValue can be null\n+     * <p>\n+     * Execute all operations on all attributes with (or without value) in 1 task.\n+     *\n+     * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n+     * @param resource        cant be null\n+     * @throws InternalErrorException if an error occurs\n+     */\n+    private void updateResourceAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Resource resource) throws InternalErrorException {\n+        //Resource cant be null\n+        if (resource == null) {\n+            throw new InternalErrorException(\"Resource is null in method updateGroupAttributes\");\n+        }\n+\n+        Set<LdapOperation> keys = mapOfAttributes.keySet();\n+\n+        //Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n+        for (LdapOperation operation : keys) {\n+            List<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n+            for (Pair<String, String> pair : listOfAttrs) {\n+                if (pair.getLeft() == null || pair.getLeft().equals(\"\")) {\n+                    throw new InternalErrorException(\"Some attributes in map has no name.\");\n+                }\n+            }\n+        }\n+\n+        //If all is correct, can execute operations on attributes\n+        List<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n+\n+        //Execute all changes on the notEmpty list of items\n+        if (!listOfItemsToModify.isEmpty()) {\n+            ModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n+            ldapConnector.updateResource(resource, items);\n+        }\n+    }\n+\n+    /**\n+     * Move group in hierarchical structure of it's VO.\n+     * <p>\n+     * That means to change attributes in LDAP with name of group (structure is defined in name of group)\n+     * and references to parentGroup if any exist.\n+     *\n+     * @param group group object after moving\n+     * @throws InternalErrorException\n+     */\n+    private void moveGroup(Group group) throws InternalErrorException {\n+        Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n+\n+        List<Pair<String, String>> listAttributesToBeRemoved = new ArrayList<>();\n+        List<Pair<String, String>> listAttributesToBeReplaced = new ArrayList<>();\n+\n+        listAttributesToBeReplaced.add(new Pair(ldapAttrCommonName, group.getName()));\n+        listAttributesToBeReplaced.add(new Pair(ldapAttrPerunUniqueGroupName, ldapConnector.getVoShortName(group.getVoId()) + \":\" + group.getName()));\n+\n+        //Check if group is now as subgroup or as top group\n+        if (group.getName().contains(\":\")) {\n+            //group is moved as subgroup\n+            listAttributesToBeReplaced.add(new Pair(ldapAttrPerunParentGroup, ldapAttrPerunGroupId + \"=\" + group.getParentGroupId().toString() + \",\" + ldapAttrPerunVoId + \"=\" + group.getVoId() + \",\" + ldapProperties.getLdapBase()));\n+            listAttributesToBeReplaced.add(new Pair(ldapAttrPerunParentGroupId, group.getParentGroupId().toString()));\n+        } else {\n+            //group is moved as top group\n+            if (ldapConnector.groupAttributeExist(group, ldapAttrPerunParentGroup)) {\n+                listAttributesToBeRemoved.add(new Pair(ldapAttrPerunParentGroup, null));\n+            }\n+            if (ldapConnector.groupAttributeExist(group, ldapAttrPerunParentGroupId)) {\n+                listAttributesToBeRemoved.add(new Pair(ldapAttrPerunParentGroupId, null));\n+            }\n+        }\n+\n+        //Add all attributes which will be replaced for the group (that also mean added if not exists yet)\n+        attributes.put(LdapOperation.REPLACE_ATTRIBUTE, listAttributesToBeReplaced);\n+        //Add all attributes (if any) which will be removed for group\n+        if (!listAttributesToBeReplaced.isEmpty()) {\n+            attributes.put(LdapOperation.REMOVE_ATTRIBUTE, listAttributesToBeRemoved);\n+        }\n+\n+        //update attributes in LDAP for group\n+        updateGroupAttributes(attributes, group);\n+    }\n+\n+    /**\n+     * Update basic group attributes (name and description) in LDAP\n+     *\n+     * @param group group after update\n+     * @throws InternalErrorException\n+     */\n+    private void updateGroup(Group group) throws InternalErrorException {\n+        Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<>();\n+\n+        List<Pair<String, String>> listAttributesToBeRemoved = new ArrayList<>();\n+        List<Pair<String, String>> listAttributesToBeReplaced = new ArrayList<>();\n+\n+        //change name\n+        listAttributesToBeReplaced.add(new Pair(ldapAttrCommonName, this.group.getName()));\n+        listAttributesToBeReplaced.add(new Pair(ldapAttrPerunUniqueGroupName, ldapConnector.getVoShortName(this.group.getVoId()) + \":\" + this.group.getName()));\n+\n+        //change description (or remove it if there is none)\n+        if (group.getDescription() != null && !group.getDescription().isEmpty()) {\n+            listAttributesToBeReplaced.add(new Pair(ldapAttrDescription, this.group.getDescription()));\n+        } else {\n+            if (ldapConnector.groupAttributeExist(group, ldapAttrDescription)) {\n+                listAttributesToBeRemoved.add(new Pair(ldapAttrDescription, null));\n+            }\n+        }\n+\n+        //Add all attributes which will be replaced for the group (that also mean added if not exists yet)\n+        attributes.put(LdapOperation.REPLACE_ATTRIBUTE, listAttributesToBeReplaced);\n+        //Add all attributes (if any) which will be removed for group\n+        if (!listAttributesToBeReplaced.isEmpty()) {\n+            attributes.put(LdapOperation.REMOVE_ATTRIBUTE, listAttributesToBeRemoved);\n+        }\n+\n+        //update attributes in LDAP for group\n+        updateGroupAttributes(attributes, group);\n+    }\n+\n+    /**\n+     * Update ldap attribute with attributeName for the group by value with operation.\n+     *\n+     * @param attributeName  name of attribute, is mandatory, cant be null\n+     * @param attributeValue value of attribute, is not mandatory, can be null\n+     * @param operation      add, replace or remove, can't be null\n+     * @param group          cant be null\n+     * @throws InternalErrorException if an error occurs\n+     */\n+    private void updateGroupAttribute(String attributeName, String attributeValue, LdapOperation operation, Group group) throws InternalErrorException {\n+        if (operation == null) {\n+            throw new InternalErrorException(\"Operation can't be null.\");\n+        }\n+        if (attributeName == null || attributeName.equals(\"\")) {\n+            throw new InternalErrorException(\"Bad attribute Name in method updateGroupAttribute :\" + attributeName);\n+        }\n+        if (group == null) {\n+            throw new InternalErrorException(\"Group is null in method updateGroupAttribute\");\n+        }\n+\n+        Attribute attribute;\n+        if (attributeValue != null) {\n+            attribute = new BasicAttribute(attributeName, attributeValue);\n+        } else {\n+            attribute = new BasicAttribute(attributeName);\n+        }\n+\n+        ModificationItem attributeItem = new ModificationItem(operation.getCode(), attribute);\n+        ldapConnector.updateGroup(group, new ModificationItem[] {attributeItem});\n+    }\n+\n+    /**\n+     * Update group's ldap attributes from Map by operation in key.\n+     * <p>\n+     * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n+     * <p>\n+     * attributeName cant be null and empty String\n+     * attributeValue can be null\n+     * <p>\n+     * Execute all operations on all attributes with (or without value) in 1 task.\n+     *\n+     * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n+     * @param group           cant be null\n+     * @throws InternalErrorException if an error occurs\n+     */\n+    private void updateGroupAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Group group) throws InternalErrorException {\n+        //Group cant be null\n+        if (group == null) {\n+            throw new InternalErrorException(\"group is null in method updateGroupAttributes\");\n+        }\n+\n+        Set<LdapOperation> keys = mapOfAttributes.keySet();\n+\n+        //Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n+        for (LdapOperation operation : keys) {\n+            List<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n+            for (Pair<String, String> pair : listOfAttrs) {\n+                if (pair.getLeft() == null || pair.getLeft().equals(\"\")) {\n+                    throw new InternalErrorException(\"Some attributes in map has no name.\");\n+                }\n+            }\n+        }\n+\n+        //If all is correct, can execute operations on attributes\n+        List<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n+\n+        //Execute all changes on the notEmpty list of items\n+        if (!listOfItemsToModify.isEmpty()) {\n+            ModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n+            ldapConnector.updateGroup(group, items);\n+        }\n+    }\n+\n+    /**\n+     * Update ldap attribute with attributeName for the vo by value with operation.\n+     *\n+     * @param attributeName  name of attribute, is mandatory, cant be null\n+     * @param attributeValue value of attribute, is not mandatory, can be null\n+     * @param operation      add, replace or remove, can't be null\n+     * @param vo             cant be null\n+     * @throws InternalErrorException if an error occurs\n+     */\n+    private void updateVoAttribute(String attributeName, String attributeValue, LdapOperation operation, Vo vo) throws InternalErrorException {\n+        if (operation == null) {\n+            throw new InternalErrorException(\"Operation can't be null.\");\n+        }\n+        if (attributeName == null || attributeName.equals(\"\")) {\n+            throw new InternalErrorException(\"Bad attribute Name in method updateVoAttribute :\" + attributeName);\n+        }\n+        if (vo == null) {\n+            throw new InternalErrorException(\"Vo is null in method updateVoAttribute\");\n+        }\n+\n+        Attribute attribute;\n+        if (attributeValue != null) {\n+            attribute = new BasicAttribute(attributeName, attributeValue);\n+        } else {\n+            attribute = new BasicAttribute(attributeName);\n+        }\n+\n+        ModificationItem attributeItem = new ModificationItem(operation.getCode(), attribute);\n+        ldapConnector.updateVo(vo, new ModificationItem[] {attributeItem});\n+    }\n+\n+    /**\n+     * Update vo's ldap attributes from Map by operation in key.\n+     * <p>\n+     * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n+     * <p>\n+     * <p>\n+     * attributeName cant be null and empty String\n+     * attributeValue can be null\n+     * <p>\n+     * Execute all operations on all attributes with (or without value) in 1 task.\n+     *\n+     * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n+     * @param vo              cant be null\n+     * @throws InternalErrorException if an error occurs\n+     */\n+    private void updateVoAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Vo vo) throws InternalErrorException {\n+        //User cant be null\n+        if (vo == null) {\n+            throw new InternalErrorException(\"Vo is null in method updateVoAttributes\");\n+        }\n+        //Only 3 types of key are allowed (1,2 or 3) Modification classes\n+        Set<LdapOperation> keys = mapOfAttributes.keySet();\n+\n+        //Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n+        for (LdapOperation operation : keys) {\n+            List<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n+            for (Pair<String, String> pair : listOfAttrs) {\n+                if (pair.getLeft() == null || pair.getLeft().equals(\"\")) {\n+                    throw new InternalErrorException(\"Some attributes in map has no name.\");\n+                }\n+            }\n+        }\n+\n+        //If all is correct, can execute operations on attributes\n+        List<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n+\n+        //Execute all changes on the notEmpty list of items\n+        if (!listOfItemsToModify.isEmpty()) {\n+            ModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n+            ldapConnector.updateVo(vo, items);\n+        }\n+    }\n+\n+    /**\n+     * Update multi value attribute for user in LDAP by name and values\n+     *\n+     * @param listOfValues      to set, can be empty or null (that means no values should be set - remove existing values if any)\n+     * @param user              not null user to set attribute in ldap\n+     * @param attributeLDAPName not null, not empty name of attribute in ldap\n+     * @throws InternalErrorException if any of mandatory arguments are empty or any internal error occurred\n+     */\n+    private void updateUserMultivalueAttributeInLDAP(List<String> listOfValues, User user, String attributeLDAPName) throws InternalErrorException {\n+        if (user == null) {\n+            throw new InternalErrorException(\"User can't be null.\");\n+        }\n+        if (attributeLDAPName == null || attributeLDAPName.isEmpty()) {\n+            throw new InternalErrorException(\"Attribute name can't be null.\");\n+        }\n+\n+        if (listOfValues == null || listOfValues.isEmpty()) {\n+            if (ldapConnector.userAttributeExist(user, attributeLDAPName)) {\n+                updateUserAttribute(attributeLDAPName, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+            }\n+        } else {\n+            String[] subjectsArray = Arrays.copyOf(listOfValues.toArray(), listOfValues.toArray().length, String[].class);\n+            ldapConnector.updateUsersAttributeInLDAP(String.valueOf(this.user.getId()), attributeLDAPName, subjectsArray);\n+        }\n+    }\n+\n+    /**\n+     * Take map of operations and associated items to be add, replaced or removed from LDAP. Then convert this map to\n+     * list of ModificationItems (Modification Item is attribute in LDAP with new value and operation which will be\n+     * processed for it. Return this map.\n+     * <p>\n+     * Possible Operations:\n+     * 1 - ADD_ATTRIBUTE\n+     * 2 - REPLACE_ATTRIBUTE\n+     * 3 - REMOVE_ATTRIBUTES\n+     * <p>\n+     * Skip not existing operations in map. If map is null, return empty list. If list of operations under operation is\n+     * null, skipt it too.\n+     *\n+     * @param mapOfAttributes map of operations and associated items with new values to be processed\n+     * @return list of modificationItems to be processed\n+     */\n+    private List<ModificationItem> getListOfModificationItems(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes) {\n+        List<ModificationItem> listOfItemsToModify = new ArrayList<>();\n+        if (mapOfAttributes == null) {\n+            return listOfItemsToModify;\n+        }\n+\n+        //For all attributes with operation ADD (1)\n+        if (mapOfAttributes.containsKey(LdapOperation.ADD_ATTRIBUTE)) {\n+            List<Pair<String, String>> listOfAttributesToAdd = mapOfAttributes.get(LdapOperation.ADD_ATTRIBUTE);\n+            if (listOfAttributesToAdd != null) {\n+                for (Pair<String, String> pair : listOfAttributesToAdd) {\n+                    Attribute attribute;\n+                    if (pair.getRight() != null) {\n+                        attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n+                    } else {\n+                        attribute = new BasicAttribute(pair.getLeft());\n+                    }\n+                    ModificationItem attributeItem = new ModificationItem(LdapOperation.ADD_ATTRIBUTE.getCode(), attribute);\n+                    listOfItemsToModify.add(attributeItem);\n+                }\n+            }\n+        }\n+\n+        //For all attributes with operation REPLACE (2)\n+        if (mapOfAttributes.containsKey(LdapOperation.REPLACE_ATTRIBUTE)) {\n+            List<Pair<String, String>> listOfAttributesToReplace = mapOfAttributes.get(LdapOperation.REPLACE_ATTRIBUTE);\n+            if (listOfAttributesToReplace != null) {\n+                for (Pair<String, String> pair : listOfAttributesToReplace) {\n+                    Attribute attribute;\n+                    if (pair.getRight() != null) {\n+                        attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n+                    } else {\n+                        attribute = new BasicAttribute(pair.getLeft());\n+                    }\n+                    ModificationItem attributeItem = new ModificationItem(LdapOperation.REPLACE_ATTRIBUTE.getCode(), attribute);\n+                    listOfItemsToModify.add(attributeItem);\n+                }\n+            }\n+        }\n+\n+        //For all attributes with operation REMOVE (3)\n+        if (mapOfAttributes.containsKey(LdapOperation.REMOVE_ATTRIBUTE)) {\n+            List<Pair<String, String>> listOfAttributesToRemove = mapOfAttributes.get(LdapOperation.REMOVE_ATTRIBUTE);\n+            if (listOfAttributesToRemove != null) {\n+                for (Pair<String, String> pair : listOfAttributesToRemove) {\n+                    Attribute attribute;\n+                    if (pair.getRight() != null) {\n+                        attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n+                    } else {\n+                        attribute = new BasicAttribute(pair.getLeft());\n+                    }\n+                    ModificationItem attributeItem = new ModificationItem(LdapOperation.REMOVE_ATTRIBUTE.getCode(), attribute);\n+                    listOfItemsToModify.add(attributeItem);\n+                }\n+            }\n+        }\n+\n+        return listOfItemsToModify;\n+    }\n+\n+    /**\n+     * Fill objects from list of beans.\n+     * If list of beans is empty or null, fill nothing.\n+     *\n+     * @param listOfBeans list of beans already parsed from message\n+     * @throws InternalErrorException If there is some inconsistence in number of one type's objects.\n+     */\n+    private void emptyAndFillPerunBeans(List<PerunBean> listOfBeans) throws InternalErrorException {\n+        //First null all usefull objects\n+        resource = null;\n+        member = null;\n+        group = null;\n+        parentGroup = null;\n+        vo = null;\n+        user = null;\n+        specificUser = null;\n+        attribute = null;\n+        attributeDef = null;\n+        userExtSource = null;\n+        facility = null;\n+\n+        //If there is no usefull object, exit method\n+        if (listOfBeans == null) {\n+            return;\n+        }\n+\n+        for (PerunBean perunBean : listOfBeans) {\n+            if (perunBean instanceof Group) {\n+                if (this.group == null) {\n+                    this.group = (Group) perunBean;\n+                } else {\n+                    this.parentGroup = (Group) perunBean;\n+                }\n+            } else if (perunBean instanceof Member) {\n+                if (this.member == null) {\n+                    this.member = (Member) perunBean;\n+                } else {\n+                    throw new InternalErrorException(\"More than one member come to method parseMessages!\");\n+                }\n+            } else if (perunBean instanceof Vo) {\n+                if (this.vo == null) {\n+                    this.vo = (Vo) perunBean;\n+                } else {\n+                    throw new InternalErrorException(\"More than one vo come to method parserMessages!\");\n+                }\n+            } else if (perunBean instanceof User) {\n+                User u = (User) perunBean;\n+                if (u.isServiceUser() || u.isSponsoredUser()) {\n+                    if (this.specificUser == null) {\n+                        this.specificUser = u;\n+                    } else {\n+                        throw new InternalErrorException(\"More than one specificUser come to method parseMessages!\");\n+                    }\n+                } else {\n+                    if (this.user == null) {\n+                        this.user = u;\n+                    } else {\n+                        throw new InternalErrorException(\"More than one user come to method parseMessages!\");\n+                    }\n+                }\n+            } else if (perunBean instanceof AttributeDefinition && perunBean instanceof cz.metacentrum.perun.core.api.Attribute) {\n+                if (this.attribute == null) {\n+                    this.attribute = (cz.metacentrum.perun.core.api.Attribute) perunBean;\n+                } else {\n+                    throw new InternalErrorException(\"More than one attribute come to method parseMessages!\");\n+                }\n+            } else if (perunBean instanceof AttributeDefinition) {\n+                if (this.attributeDef == null) {\n+                    this.attributeDef = (AttributeDefinition) perunBean;\n+                } else {\n+                    throw new InternalErrorException(\"More than one attribute come to method parseMessages!\");\n+                }\n+            } else if (perunBean instanceof UserExtSource) {\n+                if (this.userExtSource == null) {\n+                    this.userExtSource = (UserExtSource) perunBean;\n+                } else {\n+                    throw new InternalErrorException(\"More than one userExtSource come to method parseMessages!\");\n+                }\n+            } else if (perunBean instanceof Resource) {\n+                if (this.resource == null) {\n+                    this.resource = (Resource) perunBean;\n+                } else {\n+                    throw new InternalErrorException(\"More than one Resource come to method parseMessages!\");\n+                }\n+            } else if (perunBean instanceof Facility) {\n+                if (this.facility == null) {\n+                    this.facility = (Facility) perunBean;\n+                } else {\n+                    throw new InternalErrorException(\"More than one Facility come to method parseMessages!\");\n+                }\n+            }\n+        }\n+    }\n }\n",
            "diff_size": 1524
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/198/EventProcessorImpl.java\nindex a11ed424452..6e8155bd987 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/198/EventProcessorImpl.java\n@@ -2,12 +2,10 @@ package cz.metacentrum.perun.ldapc.processor.impl;\n \n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-\n import cz.metacentrum.perun.core.api.*;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n-\n import cz.metacentrum.perun.ldapc.beans.LdapOperation;\n import cz.metacentrum.perun.auditparser.AuditParser;\n import cz.metacentrum.perun.core.api.exceptions.AttributeNotExistsException;\n@@ -39,1400 +37,1494 @@ import javax.naming.NamingException;\n import javax.naming.directory.*;\n import javax.naming.directory.Attribute;\n \n+\n @org.springframework.stereotype.Service(value = \"eventProcessor\")\n public class EventProcessorImpl implements EventProcessor, Runnable {\n \n-\t//Autowired variables\n-\t@Autowired\n-\tprivate LdapConnector ldapConnector;\n-\t@Autowired\n-\tprivate LdapcManager ldapcManager;\n-\t@Autowired\n-\tprivate LdapProperties ldapProperties;\n-\n-\t//Other variables\n-\tprivate AuditerConsumer auditerConsumer;\n-\tprivate final static Logger log = LoggerFactory.getLogger(EventProcessorImpl.class);\n-\tprivate boolean running = false;\n-\n-\t//All parsable and useable objects\n-\tResource resource;\n-\tMember member;\n-\tGroup group;\n-\tGroup parentGroup;\n-\tVo vo;\n-\tUser user;\n-\tUser specificUser;\n-\tFacility facility;\n-\tcz.metacentrum.perun.core.api.Attribute attribute;\n-\tAttributeDefinition attributeDef;\n-\tUserExtSource userExtSource;\n-\n-\t//PATTERNS (used for searching in messages)\n-\t//Common patterns\n-\tprivate Pattern deletedPattern = Pattern.compile(\" deleted.$\");\n-\tprivate Pattern createdPattern = Pattern.compile(\" created.$\");\n-\tprivate Pattern updatedPattern = Pattern.compile(\" updated.$\");\n-\t//Resources patterns\n-\tprivate Pattern deletedResourcePattern = Pattern.compile(\" deleted.#Facility\");\n-\t//Groups patterns\n-\tprivate Pattern newGroupPattern = Pattern.compile(\" created in Vo:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern subGroupPattern = Pattern.compile(\" created in Vo:\\\\[(.*)\\\\] as subgroup of Group:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern assignGroupToResourcePattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] assigned to Resource:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\tprivate Pattern removeGroupFromResourcePattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] removed from Resource:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\tprivate Pattern moveGroupPattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] was moved\\\\.$\", Pattern.DOTALL);\n-\t//Members patterns\n-\tprivate Pattern addedToPattern = Pattern.compile(\" added to Group:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern totallyRemovedFromPatter = Pattern.compile(\" was removed from Group:\\\\[(.*)\\\\] totally\", Pattern.DOTALL);\n-\tprivate Pattern validatedPattern = Pattern.compile(\" validated.$\");\n-\tprivate Pattern otherStateOfMemberPattern = Pattern.compile(\"expired.$|disabled.$|invalidated.$|suspended #\");\n-\t//Attributes patterns\n-\tprivate Pattern facilitySetPattern = Pattern.compile(\" set for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern facilityRemovePattern = Pattern.compile(\" removed for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern facilityAllAttrsRemovedPattern = Pattern.compile(\"^All attributes removed for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\n-\tprivate Pattern userSetPattern = Pattern.compile(\" set for User:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern userRemovePattern = Pattern.compile(\" removed for User:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n-\tprivate Pattern userAllAttrsRemovedPattern = Pattern.compile(\"^All attributes removed for User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\n-\tprivate Pattern userUidNamespacePattern = Pattern.compile(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":uid-namespace:\");\n-\tprivate Pattern userLoginNamespacePattern = Pattern.compile(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":login-namespace:\");\n-\t//UserExtSources patterns\n-\tprivate Pattern addUserExtSourcePattern = Pattern.compile(\"^UserExtSource:\\\\[(.*)\\\\] added to User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\tprivate Pattern removeUserExtSourcePattern = Pattern.compile(\"^UserExtSource:\\\\[(.*)\\\\] removed from User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n-\n-\t//CONSTANTS\n-\tprivate static final String LDAP_NAME = \"ldap\";\n-\tprivate static final String PATH_TO_ERROR_FILE = \"./errorParseMessageForLDAP.log\";\n-\tprivate static final String PATH_TO_NOT_EXECUTED_ERROR_FILE = \"./notExecutedMessages.log\";\n-\tprivate static final DateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n-\n-\t//PERUN ATTRIBUTES NAMES\n-\tpublic static final String perunAttrPreferredMail = \"preferredMail\";\n-\tpublic static final String perunAttrMail = \"mail\";\n-\tpublic static final String perunAttrOrganization = \"organization\";\n-\tpublic static final String perunAttrPhone = \"phone\";\n-\tpublic static final String perunAttrUserCertDNs = \"userCertDNs\";\n-\tpublic static final String perunAttrBonaFideStatus = \"elixirBonaFideStatus\";\n-\tpublic static final String perunAttrSchacHomeOrganizations = \"schacHomeOrganizations\";\n-\tpublic static final String perunAttrEduPersonScopedAffiliations = \"eduPersonScopedAffiliations\";\n-\tpublic static final String perunAttrLibraryIDs = \"libraryIDs\";\n-\tpublic static final String perunAttrEntityID = \"entityID\";\n-\tpublic static final String perunAttrClientID = \"OIDCClientID\";\n-\tpublic static final String perunAttrGroupNames = \"groupNames\";\n-\tpublic static final String perunAttrInstitutionsCountries = \"institutionsCountries\";\n-\n-\t//LDAP ATTRIBUTES NAMES\n-\tpublic static final String ldapAttrAssignedToResourceId = \"assignedToResourceId\";\n-\tpublic static final String ldapAttrAssignedGroupId = \"assignedGroupId\";\n-\tpublic static final String ldapAttrDescription = \"description\";\n-\tpublic static final String ldapAttrCommonName = \"cn\";\n-\tpublic static final String ldapAttrPerunUniqueGroupName= \"perunUniqueGroupName\";\n-\tpublic static final String ldapAttrEduPersonPrincipalNames = \"eduPersonPrincipalNames\";\n-\tpublic static final String ldapAttrPreferredMail = perunAttrPreferredMail;\n-\tpublic static final String ldapAttrMail = perunAttrMail;\n-\tpublic static final String ldapAttrOrganization = \"o\";\n-\tpublic static final String ldapAttrTelephoneNumber = \"telephoneNumber\";\n-\tpublic static final String ldapAttrUserCertDNs = \"userCertificateSubject\";\n-\tpublic static final String ldapAttrBonaFideStatus = \"bonaFideStatus\";\n-\tpublic static final String ldapAttrSchacHomeOrganizations = perunAttrSchacHomeOrganizations;\n-\tpublic static final String ldapAttrEduPersonScopedAffiliations = perunAttrEduPersonScopedAffiliations;\n-\tpublic static final String ldapAttrLibraryIDs = perunAttrLibraryIDs;\n-\tpublic static final String ldapAttrUidNumber = \"uidNumber;x-ns-\";\n-\tpublic static final String ldapAttrLogin = \"login;x-ns-\";\n-\tpublic static final String ldapAttrUserPassword = \"userPassword\";\n-\tpublic static final String ldapAttrSurname = \"sn\";\n-\tpublic static final String ldapAttrGivenName = \"givenName\";\n-\tpublic static final String ldapAttrEntityID = perunAttrEntityID;\n-\tpublic static final String ldapAttrClientID = perunAttrClientID;\n-\tpublic static final String ldapAttrObjectClass = \"objectClass\";\n-\tpublic static final String ldapAttrPerunVoId = \"perunVoId\";\n-\tpublic static final String ldapAttrPerunFacilityId = \"perunFacilityId\";\n-\tpublic static final String ldapAttrPerunUserId = \"perunUserId\";\n-\tpublic static final String ldapAttrPerunGroupId = \"perunGroupId\";\n-\tpublic static final String ldapAttrPerunResourceId = \"perunResourceId\";\n-\tpublic static final String ldapAttrPerunParentGroup = \"perunParentGroup\";\n-\tpublic static final String ldapAttrPerunParentGroupId = \"perunParentGroupId\";\n-\tpublic static final String ldapAttrMemberOf = \"memberOf\";\n-\tpublic static final String ldapAttrUniqueMember = \"uniqueMember\";\n-\tpublic static final String ldapAttrMemberOfPerunVo = \"memberOfPerunVo\";\n-\tpublic static final String ldapAttrEntryStatus = \"entryStatus\";\n-\tpublic static final String ldapAttrIsServiceUser = \"isServiceUser\";\n-\tpublic static final String ldapAttrIsSponsoredUser = \"isSponsoredUser\";\n-\tpublic static final String ldapAttrGroupNames = perunAttrGroupNames;\n-\tpublic static final String ldapAttrInstitutionsCountries = perunAttrInstitutionsCountries;\n-\n-\t//LDAP OBJECT CLASSES\n-\tpublic static final String objectClassTop = \"top\";\n-\tpublic static final String objectClassPerunResource = \"perunResource\";\n-\tpublic static final String objectClassPerunGroup = \"perunGroup\";\n-\tpublic static final String objectClassOrganization = \"organization\";\n-\tpublic static final String objectClassPerunVO = \"perunVO\";\n-\tpublic static final String objectClassPerson = \"person\";\n-\tpublic static final String objectClassOrganizationalPerson = \"organizationalPerson\";\n-\tpublic static final String objectClassInetOrgPerson = \"inetOrgPerson\";\n-\tpublic static final String objectClassPerunUser = \"perunUser\";\n-\tpublic static final String objectClassTenOperEntry = \"tenOperEntry\";\n-\tpublic static final String objectClassInetUser = \"inetUser\";\n-\n-\t//LDAP ORGANIZATION UNITS\n-\tpublic static final String organizationalUnitPeople = \"ou=People\";\n-\n-\t/**\n-\t * This method waiting for new messages in AuditLog (using AuditerConsumer)\n-\t * and then call method resolveMessage or catch exceptions and log data to files.\n-\t *\n-\t * @throws InterruptedException if thread is interrupted\n-\t * @throws Exception if some other exception like InternalErrorException are thrown\n-\t *\n-\t */\n-\tpublic void run() {\n-\n-\t\tif(!ldapProperties.propsLoaded()) throw new RuntimeException(\"LdapcProperties is not autowired correctly!\");\n-\n-\t\t//Get instance of auditerConsumer and set runnig to true\n-\n-\t\trunning = true;\n-\t\tInteger lastProcessedIdNumber = 0;\n-\t\tAuditMessage message = new AuditMessage(0, \"Empty\", null, null, null);\n-\t\tList<AuditMessage> messages;\n-\n-\t\ttry {\n-\t\t\t//If running is true, then this proccess will be continously\n-\t\t\twhile (running) {\n-\n-\t\t\t\tmessages = null;\n-\t\t\t\tint sleepTime = 1000;\n-\t\t\t\t//Waiting for new messages. If consumer failed in some internal case, waiting until it will be repaired (waiting time is increases by each attempt)\n-\t\t\t\tdo {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\t//IMPORTANT STEP1: Get new bulk of messages\n-\t\t\t\t\t\tmessages = Rpc.AuditMessagesManager.pollConsumerMessagesForParser(ldapcManager.getRpcCaller(), ldapProperties.getLdapConsumerName());\n-\t\t\t\t\t} catch (InternalErrorException ex) {\n-\t\t\t\t\t\tlog.error(\"Consumer failed due to {}. Sleeping for {} ms.\",ex, sleepTime);\n-\t\t\t\t\t\tThread.sleep(sleepTime);\n-\t\t\t\t\t\tsleepTime+=sleepTime;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//If there are no messages, sleep for 1 sec and then try it again\n-\t\t\t\t\tif(messages == null) Thread.sleep(1000);\n-\t\t\t\t} while(messages == null);\n-\t\t\t\t//If new messages exist, resolve them all\n-\t\t\t\tIterator<AuditMessage> messagesIterator = messages.iterator();\n-\t\t\t\twhile(messagesIterator.hasNext()) {\n-\t\t\t\t\tmessage = messagesIterator.next();\n-\t\t\t\t\tmessagesIterator.remove();\n-\t\t\t\t\t//Warning when two consecutive messages are separated by more than 15 ids\n-\t\t\t\t\tif(lastProcessedIdNumber > 0 && lastProcessedIdNumber < message.getId()) {\n-\t\t\t\t\t\tif((message.getId() - lastProcessedIdNumber) > 15) log.debug(\"SKIP FLAG WARNING: lastProcessedIdNumber: \" + lastProcessedIdNumber + \" - newMessageNumber: \" + message.getId() + \" = \" + (lastProcessedIdNumber - message.getId()));\n-\t\t\t\t\t}\n-\t\t\t\t\tlastProcessedIdNumber = message.getId();\n-\t\t\t\t\t//IMPORTANT STEP2: Resolve next message\n-\t\t\t\t\tthis.resolveMessage(message.getMsg(), message.getId());\n-\t\t\t\t}\n-\t\t\t\t//After all messages has been resolved, test interrupting of thread and if its ok, wait and go for another bulk of messages\n-\t\t\t\tif (Thread.interrupted()) {\n-\t\t\t\t\trunning = false;\n-\t\t\t\t} else {\n-\t\t\t\t\tThread.sleep(5000);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t//If ldapc is interrupted\n-\t\t} catch (InterruptedException e) {\n-\t\t\tDate date = new Date();\n-\t\t\tlog.error(\"Last message has ID='\" + message.getId()+ \"' and was INTERRUPTED at \" + DATE_FORMAT.format(date) + \" due to interrupting.\");\n-\t\t\trunning = false;\n-\t\t\tThread.currentThread().interrupt();\n-\t\t\t//If some other exception is thrown\n-\t\t} catch (Exception e) {\n-\t\t\tDate date = new Date();\n-\t\t\tlog.error(\"Last message has ID='\" + message.getId() + \"' and was bad PARSED or EXECUTE at \" + DATE_FORMAT.format(date) + \" due to exception \" + e.toString());\n-\t\t\tthrow new RuntimeException(e);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get a message and id of this message.\n-\t * Parse the message and decide which way will be further processed.\n-\t * Using patterns and objects to choose the way.\n-\t *\n-\t * Additional Information:\n-\t * -> For user and serviceUser there is the same behavior.\n-\t * -> If there is only serviceUser (not serviceUser and user) the behavior for serviceUser is the same like for user (in LDAP)\n-\t * -> If there are 2 groups in one message, expecting the first is subGroup and second is parentGroup\n-\t *\n-\t * Possible ways (first and only 1 possible way with the lowest number is choose):\n-\t * -> 1) GROUP and MEMBER exist\n-\t *   -> 1.1) if member status is valid => add member to group in LDAP\n-\t *   -> 1.2) if member was totally removed from group (totally means there is no direct or indirect existence of member in this group yet)\n-\t *           => remove member from this group in LDAP\n-\t * -> 2) GROUP and PARENT_GROUP exist\n-\t *   -> 2.1) if there is message with adding subgroup => add group like subgroup of parentGroup in LDAP\n-\t * -> 3) GROUP AND RESOURCE exist\n-\t *   -> 3.1) if there is message with adding group to resource => add resource to group (like attribute) in LDAP\n-\t *   -> 3.2) if there is message with removing group from resource => remove resource from group (like attribute) in LDAP\n-\t * -> 4) only RESOURCE exists (resource must be before group because of\n-\t *   -> 4.1) if there is message with deleting resource => delete this resource from LDAP\n-\t *   -> 4.2) if there is message with createing resource => create this resource in LDAP\n-\t *   -> 4.3) if there is message with updating resource => update this resource in LDAP\n-\t * -> 5) only GROUP exists\n-\t *   -> 5.1) if there is message with deleting group => delete this group from LDAP\n-\t *   -> 5.2) if there is message with creating group => create this group in LDAP\n-\t *   -> 5.3) if there is message with updating group => update this group in LDAP\n-\t *   -> 5.4) if there is message with moving group in the structure => modify existing group to the new state\n-\t * -> 6) only MEMBER exists (RPC CALLING used)\n-\t *   -> 6.1) if there is message with changing of member state to valid => add member to all groups in LDAP where he needs to be\n-\t *   -> 6.2) if there is message with changing of member state to other than valid => remove member from all groups in LDAP where is needed\n-\t * -> 7) only VO exists\n-\t *   -> 7.1) if there is message with deleting vo => delete this vo from LDAP\n-\t *   -> 7.2) if there is message with creating vo => create this vo in LDAP\n-\t *   -> 7.3) if there is message with updating vo => update this vo in LDAP\n-\t * -> 8) USER and USER_EXT_SOURCE exist\n-\t *   -> 8.1) if there is message with adding userExtSource (IDP) to user => create or update attribute of user in LDAP\n-\t *   -> 8.2) if there is message with removing userExtSource (IDP) from user => remove or update attribute of user in LDAP\n-\t * -> 9) USER and ATTRIBUTE exist\n-\t *   -> 9.1) if there is message with setting attribute to user => set Attribute to user in LDAP\n-\t * -> 10) USER and ATTRIBUTE_DEFINITION exist\n-\t *   -> 10.1) if there is message with removing attribute from user => remove Attribute from user in LDAP\n-\t * -> 11) only USER exists\n-\t *   -> 11.1) if there is message with deleting user => delete user from LDAP\n-\t *   -> 11.2) if there is message with creating user => create user in LDAP\n-\t *   -> 11.3) if there is message with updating user => update user in LDAP\n-\t *   -> 11.4) if there is message with removing all attribute from user => remove all attributes from user in LDAP (only removeable attributes)\n-\t * -> 12) FACILITY and ATTRIBUTE exist\n-\t *   -> 12.1) if there is message with setting attribute to facility => set Attribute to resources (assigned to facility) in LDAP\n-\t * -> 13) FACILITY and ATTRIBUTE_DEF exist\n-\t *   -> 13.1) if there is message with removing attribute from facility => remove Attribute from resources (assigned to facility) in LDAP\n-\t * -> 14) in all other cases\n-\t *   -> 14.1) always => only log some information\n-\t *\n-\t * @param msg message which need to be parse and resolve\n-\t * @param idOfMessage id of paring/resolving message\n-\t *\n-\t * @throws InternalErrorException when some internal error in core occurs\n-\t */\n-\tprotected void resolveMessage(String msg, Integer idOfMessage) throws InternalErrorException {\n-\n-\t\tList<PerunBean> listOfBeans;\n-\t\tlistOfBeans = AuditParser.parseLog(msg);\n-\n-\t\t//Debug information to check parsing of message.\n-\t\tif(!listOfBeans.isEmpty()){\n-\t\t\tint i=0;\n-\t\t\tfor(PerunBean p: listOfBeans) {\n-\t\t\t\ti++;\n-\t\t\t\tif(p!=null) log.debug(\"There is object number \" + i + \") \" + p.serializeToString());\n-\t\t\t\telse log.debug(\"There is unknow object which is null\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Fill perunBeans\n-\t\temptyAndFillPerunBeans(listOfBeans);\n-\n-\t\t//Log debug data for looking in messages\n-\t\tlog.debug(\"MessageNumber=\" + idOfMessage + \" -- OBJECTS: \" + this.member + '/' + this.group + '/' + this.facility + \"/\" + this.parentGroup + '/' + this.vo + '/'\n-\t\t\t\t+ this.resource + '/' + this.user + '/' + this.attribute + '/' + this.attributeDef + '/' + this.userExtSource);\n-\n-\t\t//If specific user is the only one user in message, so behavior will be same for him like for any other user!\n-\t\tif(this.specificUser != null && this.user == null) this.user = this.specificUser;\n-\n-\t\t//------------------------------------------------------------------\n-\t\t//-----------------OPERATIONS ON FILLED OBJECTS---------------------\n-\t\t//------------------------------------------------------------------\n-\t\t//Choose first possible solution for existing objects.\n-\n-\t\t// 1) IF GROUP AND MEMBER WERE FOUND, TRY TO WORK WITH GROUP-MEMBER SPECIFIC OPERATIONS\n-\t\tif(this.group != null && this.member != null) {\n-\t\t\t// 1.1) ONLY FOR VALID MEMBER WE ADD HIM TO THE GROUP IN LDAP\n-\t\t\tif(this.member.getStatus().equals(Status.VALID)) {\n-\t\t\t\tMatcher addedTo = addedToPattern.matcher(msg);\n-\n-\t\t\t\tif(addedTo.find()) {\n-\t\t\t\t\tif(!ldapConnector.isAlreadyMember(this.member, this.group)) ldapConnector.addMemberToGroup(this.member, this.group);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// 1.2) MEMBER WILL BE REMOVED FROM GROUP\n-\t\t\tMatcher totallyRemovedFrom = totallyRemovedFromPatter.matcher(msg);\n-\n-\t\t\tif(totallyRemovedFrom.find()) {\n-\t\t\t\tif(ldapConnector.isAlreadyMember(this.member, this.group)) ldapConnector.removeMemberFromGroup(this.member, this.group);\n-\t\t\t}\n-\n-\t\t\t// 2) IF 2 GROUPS WERE FOUND, TRY TO WORK WITH PARENT_GROUP-SUBGROUP SPECIFIC OPERATIONS\n-\t\t} else if(this.group != null && this.parentGroup != null) {\n-\t\t\tMatcher newSubGroup = subGroupPattern.matcher(msg);\n-\n-\t\t\t// 2.1) ADD GROUP AS SUBGROUP TO PARENT_GROUP\n-\t\t\tif(newSubGroup.find()) {\n-\t\t\t\tldapConnector.addGroupAsSubGroup(this.group, this.parentGroup);\n-\t\t\t}\n-\n-\t\t\t// 3) IF GROUP AND RESOURCE WERE FOUND, TRY TO WORK WITH GROUP-RESOURCE SPECIFIC OPERATIONS\n-\t\t} else if(this.group != null && this.resource != null) {\n-\t\t\tMatcher assigned = assignGroupToResourcePattern.matcher(msg);\n-\t\t\tMatcher removed = removeGroupFromResourcePattern.matcher(msg);\n-\n-\t\t\t// 3.1) ADD NEW RESOURCE FOR GROUP IN LDAP\n-\t\t\tif(assigned.find()) {\n-\t\t\t\tupdateGroupAttribute(ldapAttrAssignedToResourceId, String.valueOf(this.resource.getId()), LdapOperation.ADD_ATTRIBUTE, this.group);\n-\t\t\t\tupdateResourceAttribute(ldapAttrAssignedGroupId, String.valueOf(this.group.getId()), LdapOperation.ADD_ATTRIBUTE, this.resource);\n-\t\t\t\t// 3.2) REMOVE RESOURCE FROM GROUP IN LDAP\n-\t\t\t} else if(removed.find()) {\n-\t\t\t\tupdateGroupAttribute(ldapAttrAssignedToResourceId, String.valueOf(this.resource.getId()), LdapOperation.REMOVE_ATTRIBUTE, this.group);\n-\t\t\t\tupdateResourceAttribute(ldapAttrAssignedGroupId, String.valueOf(this.group.getId()), LdapOperation.REMOVE_ATTRIBUTE, this.resource);\n-\t\t\t}\n-\t\t\t// 4) IF ONLY RESOURCE WERE FOUND, TRY TO WORK WITH RESOURCE SPECIFIC OPERATIONS\n-\t\t} else if(this.resource != null) {\n-\t\t\tMatcher deleted = deletedResourcePattern.matcher(msg);\n-\t\t\tMatcher created = createdPattern.matcher(msg);\n-\t\t\tMatcher updated = updatedPattern.matcher(msg);\n-\n-\t\t\t// 4.1) RESOURCE WILL BE DELETED\n-\t\t\tif(deleted.find()) {\n-\t\t\t\tldapConnector.deleteResource(resource);\n-\t\t\t\t// 4.2) RESOURCE WILL BE CREATED\n-\t\t\t} else if(created.find()) {\n-\t\t\t\tldapConnector.createResource(resource, getFacilityEntityIdValue(resource.getFacilityId()));\n-\t\t\t\t// 4.3) RESOURCE WILL BE UPDATED\n-\t\t\t} else if(updated.find()) {\n-\t\t\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<>();\n-\t\t\t\tList<Pair<String,String>> replaceList = new ArrayList<>();\n-\t\t\t\treplaceList.add(new Pair(ldapAttrCommonName,this.resource.getName()));\n-\t\t\t\tif(this.resource.getDescription() != null && !this.resource.getDescription().isEmpty()) replaceList.add(new Pair(ldapAttrDescription, this.resource.getDescription()));\n-\t\t\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n-\t\t\t\tupdateResourceAttributes(attributes, this.resource);\n-\t\t\t}\n-\t\t\t// 5) IF ONLY GROUP WERE FOUND, TRY TO WORK WITH GROUP SPECIFIC OPERATIONS\n-\t\t} else if(this.group != null) {\n-\t\t\tMatcher deleted = deletedPattern.matcher(msg);\n-\t\t\tMatcher newGroup = newGroupPattern.matcher(msg);\n-\t\t\tMatcher updated = updatedPattern.matcher(msg);\n-\t\t\tMatcher moveGroup = moveGroupPattern.matcher(msg);\n-\n-\t\t\tif(deleted.find()){\n-\t\t\t\t// 5.1) GROUP WILL BE DELETED\n-\t\t\t\tldapConnector.removeGroup(this.group);\n-\t\t\t} else if(newGroup.find()) {\n-\t\t\t\t// 5.2) GROUP WILL BE CREATED\n-\t\t\t\tldapConnector.addGroup(this.group);\n-\t\t\t} else if(updated.find()) {\n-\t\t\t\t// 5.3) GROUP WILL BE UPDATED\n-\t\t\t\tupdateGroup(group);\n-\t\t\t} else if(moveGroup.find()) {\n-\t\t\t\t// 5.4) MOVE GROUP IN STRUCTURE\n-\t\t\t\tmoveGroup(group);\n-\t\t\t}\n-\n-\t\t\t// 6) IF MEMBER WAS FOUND, TRY TO WORK WITH MEMBER SPECIFIC OPERATIONS (! RPC CALLING used there !)\n-\t\t} else if(this.member != null) {\n-\t\t\tMatcher validated = validatedPattern.matcher(msg);\n-\t\t\tMatcher otherStateOfMember = otherStateOfMemberPattern.matcher(msg);\n-\n-\t\t\t// 6.1) MEMBER WAS VALIDATED, NEED TO ADD HIM TO ALL GROUPS\n-\t\t\tif(validated.find()) {\n-\t\t\t\tList<Group> memberGroups = new ArrayList<Group>();\n-\t\t\t\ttry {\n-\t\t\t\t\tmemberGroups = Rpc.GroupsManager.getAllMemberGroups(ldapcManager.getRpcCaller(), this.member);\n-\t\t\t\t} catch (MemberNotExistsException e) {\n-\t\t\t\t\t//IMPORTANT this is not problem, if member not exist, we expected that will be deleted in some message after that, in DB is deleted\n-\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting member's groups\", e);\n-\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\tthrow e;\n-\t\t\t\t}\n-\t\t\t\tfor(Group g: memberGroups) {\n-\t\t\t\t\tif(!ldapConnector.isAlreadyMember(this.member, g)) ldapConnector.addMemberToGroup(this.member, g);\n-\t\t\t\t}\n-\t\t\t\t// 6.2) MEMBER STATE WAS CHANGED TO OTHER STATE THAN VALIDATE\n-\t\t\t} else if(otherStateOfMember.find()) {\n-\t\t\t\tList<Group> memberGroups = new ArrayList<Group>();\n-\t\t\t\ttry {\n-\t\t\t\t\tmemberGroups = Rpc.GroupsManager.getAllMemberGroups(ldapcManager.getRpcCaller(), this.member);\n-\t\t\t\t} catch (MemberNotExistsException e) {\n-\t\t\t\t\t//IMPORTATNT this is not problem, if member not exist, we expected that will be deleted in some message after that, in DB is deleted\n-\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting member's groups\", e);\n-\t\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\t\tthrow e;\n-\t\t\t\t}\n-\t\t\t\tfor(Group g: memberGroups) {\n-\t\t\t\t\tif(ldapConnector.isAlreadyMember(this.member, g)) ldapConnector.removeMemberFromGroup(this.member, g);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// 7) IF VO WAS FOUND, TRY TO WORK WITH VO SPECIFIC OPERATIONS\n-\t\t} else if(this.vo != null) {\n-\t\t\tMatcher deleted = deletedPattern.matcher(msg);\n-\t\t\tMatcher created = createdPattern.matcher(msg);\n-\t\t\tMatcher updated = updatedPattern.matcher(msg);\n-\n-\t\t\t// 7.1) VO WILL BE DELETED\n-\t\t\tif(deleted.find()) {\n-\t\t\t\tldapConnector.deleteVo(this.vo);\n-\t\t\t\t// 7.2) VO WILL BE CREATED\n-\t\t\t} else if(created.find()) {\n-\t\t\t\tldapConnector.createVo(this.vo);\n-\t\t\t\t// 7.3) VO WILL BE UPDATED\n-\t\t\t} else if(updated.find()) {\n-\t\t\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n-\t\t\t\tList<Pair<String,String>> replaceList = new ArrayList<Pair<String, String>>();\n-\t\t\t\treplaceList.add(new Pair(ldapAttrDescription,this.vo.getName()));\n-\t\t\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n-\t\t\t\tupdateVoAttributes(attributes, this.vo);\n-\t\t\t}\n-\n-\t\t\t// 8) IF USER AND USEREXTSOURCE WERE FOUND, TRY TO WORK WITH USER-USEREXTSOURCE SPECIFIC OPERATIONS (LIKE SET EXT LOGINS FOR IDP EXTSOURCES)\n-\t\t} else if(this.user != null && this.userExtSource != null) {\n-\t\t\tMatcher addExtSource = addUserExtSourcePattern.matcher(msg);\n-\t\t\tMatcher removeExtSource = removeUserExtSourcePattern.matcher(msg);\n-\n-\t\t\t// 8.1) ADD ATTRIBUTE WITH IDP EXTSOURCE\n-\t\t\tif(addExtSource.find()) {\n-\t\t\t\tif(this.userExtSource.getExtSource() != null && this.userExtSource.getExtSource().getType() != null) {\n-\t\t\t\t\tString extLogin;\n-\t\t\t\t\tif(this.userExtSource.getExtSource().getType().equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n-\t\t\t\t\t\textLogin = this.userExtSource.getLogin();\n-\t\t\t\t\t\tif(extLogin == null) extLogin = \"\";\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrEduPersonPrincipalNames, extLogin, LdapOperation.ADD_ATTRIBUTE, user);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// 8.2) REMOVE ATTRIBUTE WITH IDP EXTSOURCE\n-\t\t\t} else if(removeExtSource.find()) {\n-\t\t\t\tif(this.userExtSource.getExtSource() != null && this.userExtSource.getExtSource().getType() != null) {\n-\t\t\t\t\tString extLogin;\n-\t\t\t\t\tif(this.userExtSource.getExtSource().getType().equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n-\t\t\t\t\t\textLogin = this.userExtSource.getLogin();\n-\t\t\t\t\t\tif(extLogin == null) extLogin = \"\";\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrEduPersonPrincipalNames, extLogin, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// 9) IF USER AND ATTRIBUTE WERE FOUND, TRY TO WORK WITH USER-ATTR SPECIFIC OPERATIONS (LIKE SET USER ATTRIBUTES)\n-\t\t} else if(this.user != null && this.attribute != null) {\n-\t\t\tMatcher set = userSetPattern.matcher(msg);\n-\n-\t\t\t// 9.1) SOME USER ATTRIBUTE WILL BE PROBABLY SET (IF IT IS ONE OF SPECIFIC ATTRIBUTES)\n-\t\t\tif(set.find()) {\n-\t\t\t\tMatcher uidMatcher = userUidNamespacePattern.matcher(this.attribute.getName());\n-\t\t\t\tMatcher loginMatcher = userLoginNamespacePattern.matcher(this.attribute.getName());\n-\n-\t\t\t\tif(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail)) {\n-\t\t\t\t\t//this mean change of attribute preferredMail in User\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrPreferredMail, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, user);\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrMail, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrPreferredMail)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrPreferredMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrMail)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrOrganization)) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrOrganization, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrOrganization)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrOrganization, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPhone)) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrTelephoneNumber, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrTelephoneNumber)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrTelephoneNumber, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrUserCertDNs)) {\n-\t\t\t\t\tMap<String, String> certDNsMap = (this.attribute.getValue() != null) ? (Map) this.attribute.getValue() : null;\n-\n-\t\t\t\t\tif (certDNsMap == null || certDNsMap.isEmpty()) {\n-\t\t\t\t\t\tif (ldapConnector.userAttributeExist(this.user, ldapAttrUserCertDNs)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserCertDNs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tSet<String> certSubjectsWithPrefixes = ((Map) this.attribute.getValue()).keySet();\n-\t\t\t\t\t\tSet<String> certSubjectsWithoutPrefixes = new HashSet<>();\n-\t\t\t\t\t\t//remove prefixes from certificates\n-\t\t\t\t\t\tfor (String key : certSubjectsWithPrefixes) {\n-\t\t\t\t\t\t\tcertSubjectsWithoutPrefixes.add(key.replaceFirst(\"^[0-9]+[:]\", \"\"));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tString[] subjectsArray = Arrays.copyOf(certSubjectsWithoutPrefixes.toArray(), certSubjectsWithoutPrefixes.toArray().length, String[].class);\n-\t\t\t\t\t\tldapConnector.updateUsersAttributeInLDAP(String.valueOf(this.user.getId()), ldapAttrUserCertDNs, subjectsArray);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrBonaFideStatus)) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrBonaFideStatus, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrBonaFideStatus)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrBonaFideStatus, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrSchacHomeOrganizations)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrSchacHomeOrganizations);\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrEduPersonScopedAffiliations)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrEduPersonScopedAffiliations);\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrGroupNames)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrGroupNames);\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrInstitutionsCountries)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrInstitutionsCountries);\n-\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrLibraryIDs)) {\n-\t\t\t\t\tupdateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrLibraryIDs);\n-\n-\t\t\t\t} else if(uidMatcher.find()) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrUidNumber + this.attribute.getFriendlyNameParameter(), String.valueOf((Integer) this.attribute.getValue()), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrUidNumber + this.attribute.getFriendlyNameParameter())) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUidNumber + this.attribute.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(loginMatcher.find()) {\n-\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrLogin + this.attribute.getFriendlyNameParameter(), (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t//if login is from loginNamespace (eg. EINFRA) (new value), then userPassword must be set or modified\n-\t\t\t\t\t\tif(ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attribute.getFriendlyNameParameter())) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserPassword, \"{SASL}\" + this.attribute.getValue() + \"@\" + ldapProperties.getLdapLoginNamespace(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrLogin + this.attribute.getFriendlyNameParameter())) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrLogin + this.attribute.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif(ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attribute.getFriendlyNameParameter())) {\n-\t\t\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrUserPassword)) {\n-\t\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserPassword, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// 10) IF USER AND ATTRIBTUE DEFINITION WERE FOUND, TRY TO WORK WITH USER-ATTRDEF SPECIFIC OPERATIONS\n-\t\t} else if(this.user != null && attributeDef != null) {\n-\t\t\tMatcher remove = userRemovePattern.matcher(msg);\n-\t\t\t// 10.1) REMOVE SPECIFIC USER ATTRIBUTE\n-\t\t\tif(remove.find() &&  ldapConnector.userExist(this.user)) {\n-\t\t\t\tMatcher uidMatcher = userUidNamespacePattern.matcher(this.attributeDef.getName());\n-\t\t\t\tMatcher loginMatcher = userLoginNamespacePattern.matcher(this.attributeDef.getName());\n-\t\t\t\tif(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrPreferredMail)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrPreferredMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrMail)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t\t//TODO: organization (user) will not exists\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrOrganization)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrOrganization)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrOrganization, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPhone)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrTelephoneNumber)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrTelephoneNumber, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrUserCertDNs)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrUserCertDNs)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserCertDNs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrEduPersonScopedAffiliations)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrEduPersonScopedAffiliations)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrEduPersonScopedAffiliations, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrGroupNames)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrGroupNames)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrGroupNames, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrInstitutionsCountries)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrInstitutionsCountries)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrInstitutionsCountries, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrBonaFideStatus)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrBonaFideStatus)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrBonaFideStatus, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrSchacHomeOrganizations)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrSchacHomeOrganizations)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrSchacHomeOrganizations, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrLibraryIDs)) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrLibraryIDs)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrLibraryIDs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(uidMatcher.find()) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrUidNumber + this.attributeDef.getFriendlyNameParameter())) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrUidNumber + this.attributeDef.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\n-\t\t\t\t} else if(loginMatcher.find()) {\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrLogin + this.attributeDef.getFriendlyNameParameter())) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrLogin + this.attributeDef.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t\tif(ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attributeDef.getFriendlyNameParameter())) {\n-\t\t\t\t\t\tif(ldapConnector.userPasswordExists(this.user)) {\n-\t\t\t\t\t\t\tupdateUserAttribute(ldapAttrUserPassword, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// 11) IF ONLY USER WAS FOUND, TRY TO WORK WITH USER SPECIFIC OPERATIONS\n-\t\t} else if(this.user != null) {\n-\t\t\tMatcher deleted = deletedPattern.matcher(msg);\n-\t\t\tMatcher created = createdPattern.matcher(msg);\n-\t\t\tMatcher updated = updatedPattern.matcher(msg);\n-\t\t\tMatcher removedAllAttrs = userAllAttrsRemovedPattern.matcher(msg);\n-\t\t\t// 11.1) DELETE USER\n-\t\t\tif(deleted.find()) {\n-\t\t\t\tldapConnector.deleteUser(this.user);\n-\t\t\t\t// 11.2) CREATE USER\n-\t\t\t} else if(created.find()) {\n-\t\t\t\tldapConnector.createUser(this.user);\n-\t\t\t\t// 11.3) UPDATE USER\n-\t\t\t} else if(updated.find()) {\n-\t\t\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n-\t\t\t\tList<Pair<String,String>> replaceList = new ArrayList<Pair<String, String>>();\n-\t\t\t\tString firstName = this.user.getFirstName();\n-\t\t\t\tString lastName = this.user.getLastName();\n-\t\t\t\tString commonName = \"\";\n-\t\t\t\tif(firstName == null || firstName.isEmpty()) firstName = \"\";\n-\t\t\t\telse commonName+= firstName + \" \";\n-\t\t\t\tif(lastName == null || lastName.isEmpty()) lastName = \"N/A\";\n-\t\t\t\tcommonName+=lastName;\n-\t\t\t\treplaceList.add(new Pair(ldapAttrSurname,lastName));\n-\t\t\t\treplaceList.add(new Pair(ldapAttrCommonName, commonName));\n-\t\t\t\t// IF firstName is empty, maybe need to be removed first\n-\t\t\t\tif(firstName.isEmpty()) {\n-\t\t\t\t\t//if first name exists and new one is empty, then remove it, else do nothing\n-\t\t\t\t\tif(ldapConnector.userAttributeExist(this.user, ldapAttrGivenName)) {\n-\t\t\t\t\t\tupdateUserAttribute(ldapAttrGivenName, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t//if first name is not empty, replace it by new first name\n-\t\t\t\t\treplaceList.add(new Pair(ldapAttrGivenName, firstName));\n-\t\t\t\t}\n-\t\t\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n-\t\t\t\tupdateUserAttributes(attributes, this.user);\n-\t\t\t\t// 11.4) REMOVE ALL USER ATTRIBUTES\n-\t\t\t} else if(removedAllAttrs.find()) {\n-\t\t\t\tif(ldapConnector.userExist(this.user)) {\n-\t\t\t\t\tAttributes usersAttrs = ldapConnector.getAllUsersAttributes(this.user);\n-\t\t\t\t\tList<ModificationItem> listOfItems = new ArrayList<ModificationItem>();\n-\t\t\t\t\tif(usersAttrs != null) {\n-\t\t\t\t\t\tNamingEnumeration<? extends Attribute> attributesEnumeration;\n-\t\t\t\t\t\tattributesEnumeration = usersAttrs.getAll();\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\twhile(attributesEnumeration.hasMore()) {\n-\t\t\t\t\t\t\t\tAttribute attr = attributesEnumeration.nextElement();\n-\t\t\t\t\t\t\t\tif(attr != null && attr.getID() != null) {\n-\t\t\t\t\t\t\t\t\tif(isRemovableUserAttribute(attr.getID())) {\n-\t\t\t\t\t\t\t\t\t\tModificationItem item = new ModificationItem(LdapOperation.REMOVE_ATTRIBUTE.getCode(), attr);\n-\t\t\t\t\t\t\t\t\t\tlistOfItems.add(item);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} catch (NamingException ex) {\n-\t\t\t\t\t\t\tthrow new InternalErrorException(\"Error at Deleting All Users Attribute, throw namingException.\", ex);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif(!listOfItems.isEmpty()) {\n-\t\t\t\t\t\tModificationItem[] items = Arrays.copyOf(listOfItems.toArray(), listOfItems.toArray().length, ModificationItem[].class);\n-\t\t\t\t\t\tldapConnector.updateUser(this.user, items);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//12) IF FACILITY AND ATTRIBUTE TO SET WAS FOUND\n-\t\t} else if(this.facility != null && attribute != null) {\n-\t\t\tMatcher set = facilitySetPattern.matcher(msg);\n-\n-\t\t\t// 12.1) SOME FACILITY ATTRIBUTE WILL BE PROBABLY SET (IF IT IS ONE OF SPECIFIC ATTRIBUTES)\n-\t\t\tif(set.find()) {\n-\t\t\t\t//EntityID WILL BE SET\n-\t\t\t\tif(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tList<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n-\t\t\t\t\t\t//this mean change of attribute entityID in all assigned resources\n-\t\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrEntityID, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\t\tif(ldapConnector.resourceAttributeExist(res, ldapAttrEntityID)) {\n-\t\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrEntityID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t\t\t\t//this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n-\t\t\t\t\t\t//so skip it just log\n-\t\t\t\t\t\tlog.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n-\t\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n-\t\t\t\t\t}\n-\t\t\t\t//OIDCClientID WILL BE SET\n-\t\t\t\t} else if(this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrClientID)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tList<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n-\t\t\t\t\t\t//this mean change of attribute clientID in all assigned resources\n-\t\t\t\t\t\tif(this.attribute.getValue() != null) {\n-\t\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrClientID, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\t\tif(ldapConnector.resourceAttributeExist(res, ldapAttrClientID)) {\n-\t\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrClientID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t\t\t\t//this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n-\t\t\t\t\t\t//so skip it just log\n-\t\t\t\t\t\tlog.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n-\t\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t//13) IF FACILITY AND ATTRIBUTE DEF TO REMOVE WAS FOUND\n-\t\t} else if(this.facility != null && attributeDef != null) {\n-\t\t\tMatcher remove = facilityRemovePattern.matcher(msg);\n-\t\t\t// 13.1) REMOVE SPECIFIC FACILITY ATTRIBUTE\n-\t\t\tif(remove.find()) {\n-\t\t\t\tif(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tList<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n-\t\t\t\t\t\tfor(Resource res: resources) {\n-\t\t\t\t\t\t\tif(ldapConnector.resourceAttributeExist(res, ldapAttrEntityID)) {\n-\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrEntityID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t\t\t\t//this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n-\t\t\t\t\t\t//so skip it just log\n-\t\t\t\t\t\tlog.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n-\t\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n-\t\t\t\t\t}\n-\t\t\t\t} else if(this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrClientID)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tList<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n-\t\t\t\t\t\tfor (Resource res : resources) {\n-\t\t\t\t\t\t\tif (ldapConnector.resourceAttributeExist(res, ldapAttrClientID)) {\n-\t\t\t\t\t\t\t\tupdateResourceAttribute(ldapAttrClientID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t\t\t\t//this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n-\t\t\t\t\t\t//so skip it just log\n-\t\t\t\t\t\tlog.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n-\t\t\t\t\t} catch (PrivilegeException e) {\n-\t\t\t\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t  // 14) IN OTHER CASES\n-\t\t} else {\n-\t\t\tlog.debug(\"Nothing to resolve for message with number : \" + idOfMessage);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Choose if attribute is removable or not.\n-\t * It means if is this attribute is required and can't be null.\n-\t *\n-\t * @param attributeName name of attribute in ldap\n-\t * @return true if attribute is removable, false if not\n-\t */\n-\tprivate boolean isRemovableUserAttribute(String attributeName) {\n-\t\tList<String> attributesWithoutOption = new ArrayList<String>();\n-\t\t//Attributes without option like \"x-ns-namespace\"\n-\t\tattributesWithoutOption.add(ldapAttrMail);\n-\t\tattributesWithoutOption.add(ldapAttrPreferredMail);\n-\t\tattributesWithoutOption.add(ldapAttrOrganization);\n-\t\tattributesWithoutOption.add(ldapAttrUserCertDNs);\n-\t\tattributesWithoutOption.add(ldapAttrSchacHomeOrganizations);\n-\t\tattributesWithoutOption.add(ldapAttrBonaFideStatus);\n-\t\tattributesWithoutOption.add(ldapAttrEduPersonScopedAffiliations);\n-\t\tattributesWithoutOption.add(ldapAttrLibraryIDs);\n-\t\tattributesWithoutOption.add(ldapAttrTelephoneNumber);\n-\t\tattributesWithoutOption.add(ldapAttrInstitutionsCountries);\n-\t\tattributesWithoutOption.add(ldapAttrGroupNames);\n-\t\tattributesWithoutOption.add(ldapAttrMemberOfPerunVo);\n-\t\tattributesWithoutOption.add(ldapAttrEduPersonPrincipalNames);\n-\t\tif(attributesWithoutOption.contains(attributeName)) return true;\n-\n-\t\t//Attributes with option like \"x-ns-namespace\"\n-\t\tList<String> attributesWithOption = new ArrayList<String>();\n-\t\tattributesWithOption.add(ldapAttrUidNumber);\n-\t\tattributesWithOption.add(ldapAttrLogin);\n-\t\tattributesWithOption.add(ldapAttrUserPassword);\n-\n-\t\tfor(String s: attributesWithOption) {\n-\t\t\tif(attributeName.startsWith(s)) return true;\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Get User preferred Mail value from perun.\n-\t *\n-\t * @param user the user\n-\t * @return value of user's preferredMail or null, if value is null or user not exists yet\n-\t * @throws InternalErrorException if some exception (except UserNotExistsException) is thrown from RPC\n-\t */\n-\tprivate String getUserPreferredMailValue(User user) throws InternalErrorException {\n-\t\tcz.metacentrum.perun.core.api.Attribute preferredMailAttr = null;\n-\t\ttry {\n-\t\t\tpreferredMailAttr = Rpc.AttributesManager.getAttribute(ldapcManager.getRpcCaller(), user, cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail);\n-\t\t} catch(PrivilegeException ex) {\n-\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting user's attribute.\", ex);\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new InternalErrorException(\"There is no such attribute.\", ex);\n-\t\t} catch(UserNotExistsException ex) {\n-\t\t\t//If user not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n-\t\t\treturn null;\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(\"There is problem with wrong attribute assignment exception.\", ex);\n-\t\t}\n-\t\tif(preferredMailAttr.getValue() == null) return null;\n-\t\telse return (String) preferredMailAttr.getValue();\n-\t}\n-\n-\t/**\n-\t * Get entityID value from perun by facilityId.\n-\t *\n-\t * @param facilityId the facilityId\n-\t * @return value of entityID or null, if value is null or user not exists yet\n-\t * @throws InternalErrorException if some exception is thrown from RPC\n-\t */\n-\tprivate String getFacilityEntityIdValue(int facilityId) throws InternalErrorException {\n-\t\tFacility facility = null;\n-\t\ttry {\n-\t\t\tfacility = Rpc.FacilitiesManager.getFacilityById(ldapcManager.getRpcCaller(), facilityId);\n-\t\t} catch (PrivilegeException ex) {\n-\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting facility by id.\", ex);\n-\t\t} catch (FacilityNotExistsException ex) {\n-\t\t\t//If facility not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tcz.metacentrum.perun.core.api.Attribute entityID = null;\n-\t\ttry {\n-\t\t\tentityID = Rpc.AttributesManager.getAttribute(ldapcManager.getRpcCaller(), facility, AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID);\n-\t\t} catch(PrivilegeException ex) {\n-\t\t\tthrow new InternalErrorException(\"There are no privilegies for getting facility attribute.\", ex);\n-\t\t} catch(AttributeNotExistsException ex) {\n-\t\t\tthrow new InternalErrorException(\"There is no such attribute.\", ex);\n-\t\t} catch(FacilityNotExistsException ex) {\n-\t\t\t//If facility not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n-\t\t\treturn null;\n-\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\tthrow new InternalErrorException(\"There is problem with wrong attribute assignment exception.\", ex);\n-\t\t}\n-\t\tif(entityID.getValue() == null) return null;\n-\t\telse return (String) entityID.getValue();\n-\t}\n-\n-\t/**\n-\t * Update ldap attribute with attributeName for the user by value with operation.\n-\t *\n-\t *\n-\t * @param attributeName name of attribute, is mandatory, cant be null\n-\t * @param attributeValue value of attribute, is not mandatory, can be null\n-\t * @param operation add, remove or replace (can't be null)\n-\t * @param user cant be null\n-\t *\n-\t * @exception InternalErrorException if an error occurs\n-\t *\n-\t */\n-\tprivate void updateUserAttribute(String attributeName, String attributeValue, LdapOperation operation, User user) throws InternalErrorException {\n-\t\tif(operation == null) throw new InternalErrorException(\"Operation can't be null\");\n-\t\tif(attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateUserAttribute :\" + attributeName);\n-\t\tif(user == null) throw new InternalErrorException(\"User is null in method updateUserAttribute\");\n-\n-\t\tAttribute attribute;\n-\t\tif(attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n-\t\telse attribute = new BasicAttribute(attributeName);\n-\n-\t\tModificationItem attributeItem =  new ModificationItem(operation.getCode(), attribute);\n-\t\tldapConnector.updateUser(user, new ModificationItem[] {attributeItem});\n-\t}\n-\n-\t/**\n-\t * Update user's ldap attributes from Map by operation in key.\n-\t *\n-\t * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n-\t *\n-\t *\n-\t * attributeName cant be null and empty String\n-\t * attributeValue can be null\n-\t *\n-\t * Execute all operations on all attributes with (or without value) in 1 task.\n-\t *\n-\t * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n-\t * @param user cant be null\n-\t * @throws InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateUserAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, User user) throws InternalErrorException {\n-\t\t//User cant be null\n-\t\tif(user == null) throw new InternalErrorException(\"User is null in method updateUserAttributes\");\n-\n-\t\tSet<LdapOperation> keys = mapOfAttributes.keySet();\n-\n-\t\t//Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n-\t\tfor(LdapOperation operation: keys) {\n-\t\t\tList<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n-\t\t\tfor(Pair<String, String> pair: listOfAttrs) {\n-\t\t\t\tif(pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//If all is correct, can execute operations on attributes\n-\t\tList<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n-\n-\t\t//Execute all changes on the notEmpty list of items\n-\t\tif(!listOfItemsToModify.isEmpty()) {\n-\t\t\tModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n-\t\t\tldapConnector.updateUser(user, items);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update ldap attribute with attributeName for the resource by value with operation.\n-\t *\n-\t *\n-\t * @param attributeName name of attribute, is mandatory, cant be null\n-\t * @param attributeValue value of attribute, is not mandatory, can be null\n-\t * @param operation add, replace or remove, can't be null\n-\t * @param resource cant be null\n-\t *\n-\t * @exception InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateResourceAttribute(String attributeName, String attributeValue, LdapOperation operation, Resource resource) throws InternalErrorException {\n-\t\tif(operation == null) throw new InternalErrorException(\"Operation can't be null.\");\n-\t\tif(attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateResourceAttribute :\" + attributeName);\n-\t\tif(resource == null) throw new InternalErrorException(\"Resource is null in method updateResourceAttribute\");\n-\n-\t\tAttribute attribute;\n-\t\tif(attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n-\t\telse attribute = new BasicAttribute(attributeName);\n-\n-\t\tModificationItem attributeItem =  new ModificationItem(operation.getCode(), attribute);\n-\t\tldapConnector.updateResource(resource, new ModificationItem[] {attributeItem});\n-\t}\n-\n-\t/**\n-\t * Update resource's ldap attributes from Map by operation in key.\n-\t *\n-\t * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n-\t *\n-\t * attributeName cant be null and empty String\n-\t * attributeValue can be null\n-\t *\n-\t * Execute all operations on all attributes with (or without value) in 1 task.\n-\t *\n-\t * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n-\t * @param resource cant be null\n-\t * @throws InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateResourceAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Resource resource) throws InternalErrorException {\n-\t\t//Resource cant be null\n-\t\tif(resource == null) throw new InternalErrorException(\"Resource is null in method updateGroupAttributes\");\n-\n-\t\tSet<LdapOperation> keys = mapOfAttributes.keySet();\n-\n-\t\t//Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n-\t\tfor(LdapOperation operation: keys) {\n-\t\t\tList<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n-\t\t\tfor(Pair<String, String> pair: listOfAttrs) {\n-\t\t\t\tif(pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//If all is correct, can execute operations on attributes\n-\t\tList<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n-\n-\t\t//Execute all changes on the notEmpty list of items\n-\t\tif(!listOfItemsToModify.isEmpty()) {\n-\t\t\tModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n-\t\t\tldapConnector.updateResource(resource, items);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Move group in hierarchical structure of it's VO.\n-\t *\n-\t * That means to change attributes in LDAP with name of group (structure is defined in name of group)\n-\t * and references to parentGroup if any exist.\n-\t *\n-\t * @param group group object after moving\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate void moveGroup(Group group) throws InternalErrorException {\n-\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n-\n-\t\tList<Pair<String,String>> listAttributesToBeRemoved = new ArrayList<>();\n-\t\tList<Pair<String,String>> listAttributesToBeReplaced = new ArrayList<>();\n-\n-\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrCommonName,group.getName()));\n-\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrPerunUniqueGroupName, ldapConnector.getVoShortName(group.getVoId()) + \":\" + group.getName()));\n-\n-\t\t//Check if group is now as subgroup or as top group\n-\t\tif(group.getName().contains(\":\")) {\n-\t\t\t//group is moved as subgroup\n-\t\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrPerunParentGroup, ldapAttrPerunGroupId + \"=\" + group.getParentGroupId().toString() + \",\" + ldapAttrPerunVoId + \"=\" + group.getVoId() + \",\" + ldapProperties.getLdapBase()));\n-\t\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrPerunParentGroupId, group.getParentGroupId().toString()));\n-\t\t} else {\n-\t\t\t//group is moved as top group\n-\t\t\tif(ldapConnector.groupAttributeExist(group, ldapAttrPerunParentGroup)) {\n-\t\t\t\tlistAttributesToBeRemoved.add(new Pair(ldapAttrPerunParentGroup, null));\n-\t\t\t}\n-\t\t\tif(ldapConnector.groupAttributeExist(group, ldapAttrPerunParentGroupId)) {\n-\t\t\t\tlistAttributesToBeRemoved.add(new Pair(ldapAttrPerunParentGroupId, null ));\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Add all attributes which will be replaced for the group (that also mean added if not exists yet)\n-\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, listAttributesToBeReplaced);\n-\t\t//Add all attributes (if any) which will be removed for group\n-\t\tif(!listAttributesToBeReplaced.isEmpty()) attributes.put(LdapOperation.REMOVE_ATTRIBUTE, listAttributesToBeRemoved);\n-\n-\t\t//update attributes in LDAP for group\n-\t\tupdateGroupAttributes(attributes, group);\n-\t}\n-\n-\t/**\n-\t * Update basic group attributes (name and description) in LDAP\n-\t *\n-\t * @param group group after update\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate void updateGroup(Group group) throws InternalErrorException {\n-\t\tMap<LdapOperation, List<Pair<String,String>>> attributes = new HashMap<>();\n-\n-\t\tList<Pair<String,String>> listAttributesToBeRemoved = new ArrayList<>();\n-\t\tList<Pair<String,String>> listAttributesToBeReplaced = new ArrayList<>();\n-\n-\t\t//change name\n-\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrCommonName,this.group.getName()));\n-\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrPerunUniqueGroupName, ldapConnector.getVoShortName(this.group.getVoId()) + \":\" + this.group.getName()));\n-\n-\t\t//change description (or remove it if there is none)\n-\t\tif(group.getDescription() != null && !group.getDescription().isEmpty()) {\n-\t\t\tlistAttributesToBeReplaced.add(new Pair(ldapAttrDescription, this.group.getDescription()));\n-\t\t} else {\n-\t\t\tif(ldapConnector.groupAttributeExist(group, ldapAttrDescription)) {\n-\t\t\t\tlistAttributesToBeRemoved.add(new Pair(ldapAttrDescription, null));\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Add all attributes which will be replaced for the group (that also mean added if not exists yet)\n-\t\tattributes.put(LdapOperation.REPLACE_ATTRIBUTE, listAttributesToBeReplaced);\n-\t\t//Add all attributes (if any) which will be removed for group\n-\t\tif(!listAttributesToBeReplaced.isEmpty()) attributes.put(LdapOperation.REMOVE_ATTRIBUTE, listAttributesToBeRemoved);\n-\n-\t\t//update attributes in LDAP for group\n-\t\tupdateGroupAttributes(attributes, group);\n-\t}\n-\n-\t/**\n-\t * Update ldap attribute with attributeName for the group by value with operation.\n-\t *\n-\t * @param attributeName name of attribute, is mandatory, cant be null\n-\t * @param attributeValue value of attribute, is not mandatory, can be null\n-\t * @param operation add, replace or remove, can't be null\n-\t * @param group cant be null\n-\t *\n-\t * @exception InternalErrorException if an error occurs\n-\t *\n-\t */\n-\tprivate void updateGroupAttribute(String attributeName, String attributeValue, LdapOperation operation, Group group) throws InternalErrorException {\n-\t\tif(operation == null) throw new InternalErrorException(\"Operation can't be null.\");\n-\t\tif(attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateGroupAttribute :\" + attributeName);\n-\t\tif(group == null) throw new InternalErrorException(\"Group is null in method updateGroupAttribute\");\n-\n-\t\tAttribute attribute;\n-\t\tif(attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n-\t\telse attribute = new BasicAttribute(attributeName);\n-\n-\t\tModificationItem attributeItem =  new ModificationItem(operation.getCode(), attribute);\n-\t\tldapConnector.updateGroup(group, new ModificationItem[] {attributeItem});\n-\t}\n-\n-\t/**\n-\t * Update group's ldap attributes from Map by operation in key.\n-\t *\n-\t * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n-\t *\n-\t * attributeName cant be null and empty String\n-\t * attributeValue can be null\n-\t *\n-\t * Execute all operations on all attributes with (or without value) in 1 task.\n-\t *\n-\t * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n-\t * @param group cant be null\n-\t * @throws InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateGroupAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Group group) throws InternalErrorException {\n-\t\t//Group cant be null\n-\t\tif(group == null) throw new InternalErrorException(\"group is null in method updateGroupAttributes\");\n-\n-\t\tSet<LdapOperation> keys = mapOfAttributes.keySet();\n-\n-\t\t//Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n-\t\tfor(LdapOperation operation: keys) {\n-\t\t\tList<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n-\t\t\tfor(Pair<String, String> pair: listOfAttrs) {\n-\t\t\t\tif(pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//If all is correct, can execute operations on attributes\n-\t\tList<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n-\n-\t\t//Execute all changes on the notEmpty list of items\n-\t\tif(!listOfItemsToModify.isEmpty()) {\n-\t\t\tModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n-\t\t\tldapConnector.updateGroup(group, items);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update ldap attribute with attributeName for the vo by value with operation.\n-\t *\n-\t * @param attributeName name of attribute, is mandatory, cant be null\n-\t * @param attributeValue value of attribute, is not mandatory, can be null\n-\t * @param operation add, replace or remove, can't be null\n-\t * @param vo cant be null\n-\t *\n-\t * @exception InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateVoAttribute(String attributeName, String attributeValue, LdapOperation operation, Vo vo) throws InternalErrorException {\n-\t\tif(operation == null) throw new InternalErrorException(\"Operation can't be null.\");\n-\t\tif(attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateVoAttribute :\" + attributeName);\n-\t\tif(vo == null) throw new InternalErrorException(\"Vo is null in method updateVoAttribute\");\n-\n-\t\tAttribute attribute;\n-\t\tif(attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n-\t\telse attribute = new BasicAttribute(attributeName);\n-\n-\t\tModificationItem attributeItem =  new ModificationItem(operation.getCode(), attribute);\n-\t\tldapConnector.updateVo(vo, new ModificationItem[] {attributeItem});\n-\t}\n-\n-\t/**\n-\t * Update vo's ldap attributes from Map by operation in key.\n-\t *\n-\t * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n-\t *\n-\t *\n-\t * attributeName cant be null and empty String\n-\t * attributeValue can be null\n-\t *\n-\t * Execute all operations on all attributes with (or without value) in 1 task.\n-\t *\n-\t * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n-\t * @param vo cant be null\n-\t * @throws InternalErrorException if an error occurs\n-\t */\n-\tprivate void updateVoAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Vo vo) throws InternalErrorException {\n-\t\t//User cant be null\n-\t\tif(vo == null) throw new InternalErrorException(\"Vo is null in method updateVoAttributes\");\n-\t\t//Only 3 types of key are allowed (1,2 or 3) Modification classes\n-\t\tSet<LdapOperation> keys = mapOfAttributes.keySet();\n-\n-\t\t//Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n-\t\tfor(LdapOperation operation: keys) {\n-\t\t\tList<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n-\t\t\tfor(Pair<String, String> pair: listOfAttrs) {\n-\t\t\t\tif(pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t//If all is correct, can execute operations on attributes\n-\t\tList<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n-\n-\t\t//Execute all changes on the notEmpty list of items\n-\t\tif(!listOfItemsToModify.isEmpty()) {\n-\t\t\tModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n-\t\t\tldapConnector.updateVo(vo, items);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Update multi value attribute for user in LDAP by name and values\n-\t *\n-\t * @param listOfValues to set, can be empty or null (that means no values should be set - remove existing values if any)\n-\t * @param user not null user to set attribute in ldap\n-\t * @param attributeLDAPName not null, not empty name of attribute in ldap\n-\t * @throws InternalErrorException if any of mandatory arguments are empty or any internal error occurred\n-\t */\n-\tprivate void updateUserMultivalueAttributeInLDAP(List<String> listOfValues, User user, String attributeLDAPName) throws InternalErrorException {\n-\t\tif(user == null) throw new InternalErrorException(\"User can't be null.\");\n-\t\tif(attributeLDAPName == null || attributeLDAPName.isEmpty()) throw new InternalErrorException(\"Attribute name can't be null.\");\n-\n-\t\tif (listOfValues == null || listOfValues.isEmpty()) {\n-\t\t\tif (ldapConnector.userAttributeExist(user, attributeLDAPName)) {\n-\t\t\t\tupdateUserAttribute(attributeLDAPName, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tString[] subjectsArray = Arrays.copyOf(listOfValues.toArray(), listOfValues.toArray().length, String[].class);\n-\t\t\tldapConnector.updateUsersAttributeInLDAP(String.valueOf(this.user.getId()), attributeLDAPName, subjectsArray);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Take map of operations and associated items to be add, replaced or removed from LDAP. Then convert this map to\n-\t * list of ModificationItems (Modification Item is attribute in LDAP with new value and operation which will be\n-\t * processed for it. Return this map.\n-\t *\n-\t * Possible Operations:\n-\t * 1 - ADD_ATTRIBUTE\n-\t * 2 - REPLACE_ATTRIBUTE\n-\t * 3 - REMOVE_ATTRIBUTES\n-\t *\n-\t * Skip not existing operations in map. If map is null, return empty list. If list of operations under operation is\n-\t * null, skipt it too.\n-\t *\n-\t * @param mapOfAttributes map of operations and associated items with new values to be processed\n-\t * @return list of modificationItems to be processed\n-\t */\n-\tprivate List<ModificationItem> getListOfModificationItems(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes) {\n-\t\tList<ModificationItem> listOfItemsToModify = new ArrayList<>();\n-\t\tif(mapOfAttributes == null) return listOfItemsToModify;\n-\n-\t\t//For all attributes with operation ADD (1)\n-\t\tif(mapOfAttributes.containsKey(LdapOperation.ADD_ATTRIBUTE)) {\n-\t\t\tList<Pair<String,String>> listOfAttributesToAdd = mapOfAttributes.get(LdapOperation.ADD_ATTRIBUTE);\n-\t\t\tif(listOfAttributesToAdd != null) {\n-\t\t\t\tfor (Pair<String, String> pair : listOfAttributesToAdd) {\n-\t\t\t\t\tAttribute attribute;\n-\t\t\t\t\tif (pair.getRight() != null) attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n-\t\t\t\t\telse attribute = new BasicAttribute(pair.getLeft());\n-\t\t\t\t\tModificationItem attributeItem = new ModificationItem(LdapOperation.ADD_ATTRIBUTE.getCode(), attribute);\n-\t\t\t\t\tlistOfItemsToModify.add(attributeItem);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t//For all attributes with operation REPLACE (2)\n-\t\tif(mapOfAttributes.containsKey(LdapOperation.REPLACE_ATTRIBUTE)) {\n-\t\t\tList<Pair<String,String>> listOfAttributesToReplace = mapOfAttributes.get(LdapOperation.REPLACE_ATTRIBUTE);\n-\t\t\tif(listOfAttributesToReplace != null) {\n-\t\t\t\tfor (Pair<String, String> pair : listOfAttributesToReplace) {\n-\t\t\t\t\tAttribute attribute;\n-\t\t\t\t\tif (pair.getRight() != null) attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n-\t\t\t\t\telse attribute = new BasicAttribute(pair.getLeft());\n-\t\t\t\t\tModificationItem attributeItem = new ModificationItem(LdapOperation.REPLACE_ATTRIBUTE.getCode(), attribute);\n-\t\t\t\t\tlistOfItemsToModify.add(attributeItem);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t//For all attributes with operation REMOVE (3)\n-\t\tif(mapOfAttributes.containsKey(LdapOperation.REMOVE_ATTRIBUTE)) {\n-\t\t\tList<Pair<String,String>> listOfAttributesToRemove = mapOfAttributes.get(LdapOperation.REMOVE_ATTRIBUTE);\n-\t\t\tif(listOfAttributesToRemove != null) {\n-\t\t\t\tfor (Pair<String, String> pair : listOfAttributesToRemove) {\n-\t\t\t\t\tAttribute attribute;\n-\t\t\t\t\tif (pair.getRight() != null) attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n-\t\t\t\t\telse attribute = new BasicAttribute(pair.getLeft());\n-\t\t\t\t\tModificationItem attributeItem = new ModificationItem(LdapOperation.REMOVE_ATTRIBUTE.getCode(), attribute);\n-\t\t\t\t\tlistOfItemsToModify.add(attributeItem);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn listOfItemsToModify;\n-\t}\n-\n-\t/**\n-\t * Fill objects from list of beans.\n-\t * If list of beans is empty or null, fill nothing.\n-\t *\n-\t * @param listOfBeans list of beans already parsed from message\n-\t *\n-\t * @throws InternalErrorException If there is some inconsistence in number of one type's objects.\n-\t */\n-\tprivate void emptyAndFillPerunBeans(List<PerunBean> listOfBeans) throws InternalErrorException {\n-\t\t//First null all usefull objects\n-\t\tresource = null;\n-\t\tmember = null;\n-\t\tgroup = null;\n-\t\tparentGroup = null;\n-\t\tvo = null;\n-\t\tuser = null;\n-\t\tspecificUser = null;\n-\t\tattribute = null;\n-\t\tattributeDef = null;\n-\t\tuserExtSource = null;\n-\t\tfacility = null;\n-\n-\t\t//If there is no usefull object, exit method\n-\t\tif(listOfBeans == null) return;\n-\n-\t\tfor(PerunBean perunBean: listOfBeans) {\n-\t\t\tif(perunBean instanceof Group) {\n-\t\t\t\tif(this.group == null) this.group = (Group) perunBean;\n-\t\t\t\telse this.parentGroup = (Group) perunBean;\n-\t\t\t} else if(perunBean instanceof Member) {\n-\t\t\t\tif(this.member == null) this.member = (Member) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one member come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof Vo) {\n-\t\t\t\tif(this.vo == null) this.vo = (Vo) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one vo come to method parserMessages!\");\n-\t\t\t} else if(perunBean instanceof User) {\n-\t\t\t\tUser u = (User) perunBean;\n-\t\t\t\tif(u.isServiceUser() || u.isSponsoredUser()) {\n-\t\t\t\t\tif(this.specificUser == null) this.specificUser = u;\n-\t\t\t\t\telse throw new InternalErrorException(\"More than one specificUser come to method parseMessages!\");\n-\t\t\t\t} else {\n-\t\t\t\t\tif(this.user == null) this.user = u;\n-\t\t\t\t\telse throw new InternalErrorException(\"More than one user come to method parseMessages!\");\n-\t\t\t\t}\n-\t\t\t} else if(perunBean instanceof AttributeDefinition && perunBean instanceof cz.metacentrum.perun.core.api.Attribute) {\n-\t\t\t\tif(this.attribute == null) this.attribute = (cz.metacentrum.perun.core.api.Attribute) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one attribute come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof AttributeDefinition ) {\n-\t\t\t\tif(this.attributeDef == null) this.attributeDef = (AttributeDefinition) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one attribute come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof UserExtSource) {\n-\t\t\t\tif(this.userExtSource == null) this.userExtSource = (UserExtSource) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one userExtSource come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof Resource) {\n-\t\t\t\tif(this.resource == null) this.resource = (Resource) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one Resource come to method parseMessages!\");\n-\t\t\t} else if(perunBean instanceof Facility) {\n-\t\t\t\tif(this.facility == null) this.facility = (Facility) perunBean;\n-\t\t\t\telse throw new InternalErrorException(\"More than one Facility come to method parseMessages!\");\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n+ //Autowired variables\n+ @Autowired\n+ private LdapConnector ldapConnector;\n+\n+ @Autowired\n+ private LdapcManager ldapcManager;\n+\n+ @Autowired\n+ private LdapProperties ldapProperties;\n+\n+ //Other variables\n+ private AuditerConsumer auditerConsumer;\n+ private final static Logger log = LoggerFactory.getLogger(EventProcessorImpl.class);\n+ private boolean running = false;\n+\n+ //All parsable and useable objects\n+ Resource resource;\n+ Member member;\n+ Group group;\n+ Group parentGroup;\n+ Vo vo;\n+ User user;\n+ User specificUser;\n+ Facility facility;\n+ cz.metacentrum.perun.core.api.Attribute attribute;\n+ AttributeDefinition attributeDef;\n+ UserExtSource userExtSource;\n+\n+ //PATTERNS (used for searching in messages)\n+ //Common patterns\n+ private Pattern deletedPattern = Pattern.compile(\" deleted.$\");\n+ private Pattern createdPattern = Pattern.compile(\" created.$\");\n+ private Pattern updatedPattern = Pattern.compile(\" updated.$\");\n+ //Resources patterns\n+ private Pattern deletedResourcePattern = Pattern.compile(\" deleted.#Facility\");\n+ //Groups patterns\n+ private Pattern newGroupPattern = Pattern.compile(\" created in Vo:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+ private Pattern subGroupPattern = Pattern.compile(\" created in Vo:\\\\[(.*)\\\\] as subgroup of Group:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+ private Pattern assignGroupToResourcePattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] assigned to Resource:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+ private Pattern removeGroupFromResourcePattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] removed from Resource:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+ private Pattern moveGroupPattern = Pattern.compile(\"^Group:\\\\[(.*)\\\\] was moved\\\\.$\", Pattern.DOTALL);\n+ //Members patterns\n+ private Pattern addedToPattern = Pattern.compile(\" added to Group:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+ private Pattern totallyRemovedFromPatter = Pattern.compile(\" was removed from Group:\\\\[(.*)\\\\] totally\", Pattern.DOTALL);\n+ private Pattern validatedPattern = Pattern.compile(\" validated.$\");\n+ private Pattern otherStateOfMemberPattern = Pattern.compile(\"expired.$|disabled.$|invalidated.$|suspended #\");\n+ //Attributes patterns\n+ private Pattern facilitySetPattern = Pattern.compile(\" set for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+ private Pattern facilityRemovePattern = Pattern.compile(\" removed for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+ private Pattern facilityAllAttrsRemovedPattern = Pattern.compile(\"^All attributes removed for Facility:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+ private Pattern userSetPattern = Pattern.compile(\" set for User:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+ private Pattern userRemovePattern = Pattern.compile(\" removed for User:\\\\[(.*)\\\\]\", Pattern.DOTALL);\n+ private Pattern userAllAttrsRemovedPattern = Pattern.compile(\"^All attributes removed for User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+ private Pattern userUidNamespacePattern = Pattern.compile(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":uid-namespace:\");\n+ private Pattern userLoginNamespacePattern = Pattern.compile(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":login-namespace:\");\n+ //UserExtSources patterns\n+ private Pattern addUserExtSourcePattern = Pattern.compile(\"^UserExtSource:\\\\[(.*)\\\\] added to User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+ private Pattern removeUserExtSourcePattern = Pattern.compile(\"^UserExtSource:\\\\[(.*)\\\\] removed from User:\\\\[(.*)\\\\]$\", Pattern.DOTALL);\n+\n+ //CONSTANTS\n+ private static final String LDAP_NAME = \"ldap\";\n+ private static final String PATH_TO_ERROR_FILE = \"./errorParseMessageForLDAP.log\";\n+ private static final String PATH_TO_NOT_EXECUTED_ERROR_FILE = \"./notExecutedMessages.log\";\n+ private static final DateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n+\n+ //PERUN ATTRIBUTES NAMES\n+\n+ public static final String perunAttrPreferredMail = \"preferredMail\";\n+\n+ public static final String perunAttrMail = \"mail\";\n+\n+ public static final String perunAttrOrganization = \"organization\";\n+\n+ public static final String perunAttrPhone = \"phone\";\n+\n+ public static final String perunAttrUserCertDNs = \"userCertDNs\";\n+\n+ public static final String perunAttrBonaFideStatus = \"elixirBonaFideStatus\";\n+\n+ public static final String perunAttrSchacHomeOrganizations = \"schacHomeOrganizations\";\n+\n+ public static final String perunAttrEduPersonScopedAffiliations = \"eduPersonScopedAffiliations\";\n+\n+ public static final String perunAttrLibraryIDs = \"libraryIDs\";\n+\n+ public static final String perunAttrEntityID = \"entityID\";\n+\n+ public static final String perunAttrClientID = \"OIDCClientID\";\n+\n+ public static final String perunAttrGroupNames = \"groupNames\";\n+\n+ public static final String perunAttrInstitutionsCountries = \"institutionsCountries\";\n+\n+ //LDAP ATTRIBUTES NAMES\n+\n+ public static final String ldapAttrAssignedToResourceId = \"assignedToResourceId\";\n+\n+ public static final String ldapAttrAssignedGroupId = \"assignedGroupId\";\n+\n+ public static final String ldapAttrDescription = \"description\";\n+\n+ public static final String ldapAttrCommonName = \"cn\";\n+\n+ public static final String ldapAttrPerunUniqueGroupName = \"perunUniqueGroupName\";\n+\n+ public static final String ldapAttrEduPersonPrincipalNames = \"eduPersonPrincipalNames\";\n+\n+ public static final String ldapAttrPreferredMail = perunAttrPreferredMail;\n+\n+ public static final String ldapAttrMail = perunAttrMail;\n+\n+ public static final String ldapAttrOrganization = \"o\";\n+\n+ public static final String ldapAttrTelephoneNumber = \"telephoneNumber\";\n+\n+ public static final String ldapAttrUserCertDNs = \"userCertificateSubject\";\n+\n+ public static final String ldapAttrBonaFideStatus = \"bonaFideStatus\";\n+\n+ public static final String ldapAttrSchacHomeOrganizations = perunAttrSchacHomeOrganizations;\n+\n+ public static final String ldapAttrEduPersonScopedAffiliations = perunAttrEduPersonScopedAffiliations;\n+\n+ public static final String ldapAttrLibraryIDs = perunAttrLibraryIDs;\n+\n+ public static final String ldapAttrUidNumber = \"uidNumber;x-ns-\";\n+\n+ public static final String ldapAttrLogin = \"login;x-ns-\";\n+\n+ public static final String ldapAttrUserPassword = \"userPassword\";\n+\n+ public static final String ldapAttrSurname = \"sn\";\n+\n+ public static final String ldapAttrGivenName = \"givenName\";\n+\n+ public static final String ldapAttrEntityID = perunAttrEntityID;\n+\n+ public static final String ldapAttrClientID = perunAttrClientID;\n+\n+ public static final String ldapAttrObjectClass = \"objectClass\";\n+\n+ public static final String ldapAttrPerunVoId = \"perunVoId\";\n+\n+ public static final String ldapAttrPerunFacilityId = \"perunFacilityId\";\n+\n+ public static final String ldapAttrPerunUserId = \"perunUserId\";\n+\n+ public static final String ldapAttrPerunGroupId = \"perunGroupId\";\n+\n+ public static final String ldapAttrPerunResourceId = \"perunResourceId\";\n+\n+ public static final String ldapAttrPerunParentGroup = \"perunParentGroup\";\n+\n+ public static final String ldapAttrPerunParentGroupId = \"perunParentGroupId\";\n+\n+ public static final String ldapAttrMemberOf = \"memberOf\";\n+\n+ public static final String ldapAttrUniqueMember = \"uniqueMember\";\n+\n+ public static final String ldapAttrMemberOfPerunVo = \"memberOfPerunVo\";\n+\n+ public static final String ldapAttrEntryStatus = \"entryStatus\";\n+\n+ public static final String ldapAttrIsServiceUser = \"isServiceUser\";\n+\n+ public static final String ldapAttrIsSponsoredUser = \"isSponsoredUser\";\n+\n+ public static final String ldapAttrGroupNames = perunAttrGroupNames;\n+\n+ public static final String ldapAttrInstitutionsCountries = perunAttrInstitutionsCountries;\n+\n+ //LDAP OBJECT CLASSES\n+\n+ public static final String objectClassTop = \"top\";\n+\n+ public static final String objectClassPerunResource = \"perunResource\";\n+\n+ public static final String objectClassPerunGroup = \"perunGroup\";\n+\n+ public static final String objectClassOrganization = \"organization\";\n+\n+ public static final String objectClassPerunVO = \"perunVO\";\n+\n+ public static final String objectClassPerson = \"person\";\n+\n+ public static final String objectClassOrganizationalPerson = \"organizationalPerson\";\n+\n+ public static final String objectClassInetOrgPerson = \"inetOrgPerson\";\n+\n+ public static final String objectClassPerunUser = \"perunUser\";\n+\n+ public static final String objectClassTenOperEntry = \"tenOperEntry\";\n+\n+ public static final String objectClassInetUser = \"inetUser\";\n+\n+ //LDAP ORGANIZATION UNITS\n+\n+ public static final String organizationalUnitPeople = \"ou=People\";\n+\n+ /**\n+  * This method waiting for new messages in AuditLog (using AuditerConsumer)\n+  * and then call method resolveMessage or catch exceptions and log data to files.\n+  *\n+  * @throws InterruptedException if thread is interrupted\n+  * @throws Exception if some other exception like InternalErrorException are thrown\n+  *\n+  */\n+\n+ public void run() {\n+  if (!ldapProperties.propsLoaded()) throw new RuntimeException(\"LdapcProperties is not autowired correctly!\");\n+\n+  //Get instance of auditerConsumer and set runnig to true\n+  running = true;\n+  Integer lastProcessedIdNumber = 0;\n+  AuditMessage message = new AuditMessage(0, \"Empty\", null, null, null);\n+  List<AuditMessage> messages;\n+  try {\n+   //If running is true, then this proccess will be continously\n+   while (running) {\n+    messages = null;\n+\n+    int sleepTime = 1000;\n+    //Waiting for new messages. If consumer failed in some internal case, waiting until it will be repaired (waiting time is increases by each attempt)\n+    do {\n+     try {\n+      //IMPORTANT STEP1: Get new bulk of messages\n+      messages = Rpc.AuditMessagesManager.pollConsumerMessagesForParser(ldapcManager.getRpcCaller(), ldapProperties.getLdapConsumerName());\n+     } catch (InternalErrorException ex) {\n+      log.error(\"Consumer failed due to {}. Sleeping for {} ms.\", ex, sleepTime);\n+      Thread.sleep(sleepTime);\n+      sleepTime += sleepTime;\n+     }\n+\n+     //If there are no messages, sleep for 1 sec and then try it again\n+     if (messages == null) Thread.sleep(1000);\n+    } while (messages == null);\n+    //If new messages exist, resolve them all\n+    Iterator<AuditMessage> messagesIterator = messages.iterator();\n+    while (messagesIterator.hasNext()) {\n+     message = messagesIterator.next();\n+     messagesIterator.remove();\n+     //Warning when two consecutive messages are separated by more than 15 ids\n+     if (lastProcessedIdNumber > 0 && lastProcessedIdNumber<message.getId()) {\n+      if ((message.getId()- lastProcessedIdNumber) > 15) log.debug(\"SKIP FLAG WARNING: lastProcessedIdNumber: \" + lastProcessedIdNumber + \" - newMessageNumber: \" + message.getId() + \" = \" + (lastProcessedIdNumber - message.getId()));\n+     }\n+     lastProcessedIdNumber = message.getId();\n+     //IMPORTANT STEP2: Resolve next message\n+     this.resolveMessage(message.getMsg(), message.getId());\n+    }\n+    //After all messages has been resolved, test interrupting of thread and if its ok, wait and go for another bulk of messages\n+    if (Thread.interrupted()) {\n+     running = false;\n+    } else {\n+     Thread.sleep(5000);\n+    }\n+   }\n+   //If ldapc is interrupted\n+  } catch (InterruptedException e) {\n+   Date date = new Date();\n+   log.error(\"Last message has ID='\" + message.getId() + \"' and was INTERRUPTED at \" + DATE_FORMAT.format(date) + \" due to interrupting.\");\n+   running = false;\n+   Thread.currentThread().interrupt();\n+   //If some other exception is thrown\n+  } catch (Exception e) {\n+   Date date = new Date();\n+   log.error(\"Last message has ID='\" + message.getId() + \"' and was bad PARSED or EXECUTE at \" + DATE_FORMAT.format(date) + \" due to exception \" + e.toString());\n+   throw new RuntimeException(e);\n+  }\n+ }\n+\n+ /**\n+  * Get a message and id of this message.\n+  * Parse the message and decide which way will be further processed.\n+  * Using patterns and objects to choose the way.\n+  *\n+  * Additional Information:\n+  * -> For user and serviceUser there is the same behavior.\n+  * -> If there is only serviceUser (not serviceUser and user) the behavior for serviceUser is the same like for user (in LDAP)\n+  * -> If there are 2 groups in one message, expecting the first is subGroup and second is parentGroup\n+  *\n+  * Possible ways (first and only 1 possible way with the lowest number is choose):\n+  * -> 1) GROUP and MEMBER exist\n+  *   -> 1.1) if member status is valid => add member to group in LDAP\n+  *   -> 1.2) if member was totally removed from group (totally means there is no direct or indirect existence of member in this group yet)\n+  *           => remove member from this group in LDAP\n+  * -> 2) GROUP and PARENT_GROUP exist\n+  *   -> 2.1) if there is message with adding subgroup => add group like subgroup of parentGroup in LDAP\n+  * -> 3) GROUP AND RESOURCE exist\n+  *   -> 3.1) if there is message with adding group to resource => add resource to group (like attribute) in LDAP\n+  *   -> 3.2) if there is message with removing group from resource => remove resource from group (like attribute) in LDAP\n+  * -> 4) only RESOURCE exists (resource must be before group because of\n+  *   -> 4.1) if there is message with deleting resource => delete this resource from LDAP\n+  *   -> 4.2) if there is message with createing resource => create this resource in LDAP\n+  *   -> 4.3) if there is message with updating resource => update this resource in LDAP\n+  * -> 5) only GROUP exists\n+  *   -> 5.1) if there is message with deleting group => delete this group from LDAP\n+  *   -> 5.2) if there is message with creating group => create this group in LDAP\n+  *   -> 5.3) if there is message with updating group => update this group in LDAP\n+  *   -> 5.4) if there is message with moving group in the structure => modify existing group to the new state\n+  * -> 6) only MEMBER exists (RPC CALLING used)\n+  *   -> 6.1) if there is message with changing of member state to valid => add member to all groups in LDAP where he needs to be\n+  *   -> 6.2) if there is message with changing of member state to other than valid => remove member from all groups in LDAP where is needed\n+  * -> 7) only VO exists\n+  *   -> 7.1) if there is message with deleting vo => delete this vo from LDAP\n+  *   -> 7.2) if there is message with creating vo => create this vo in LDAP\n+  *   -> 7.3) if there is message with updating vo => update this vo in LDAP\n+  * -> 8) USER and USER_EXT_SOURCE exist\n+  *   -> 8.1) if there is message with adding userExtSource (IDP) to user => create or update attribute of user in LDAP\n+  *   -> 8.2) if there is message with removing userExtSource (IDP) from user => remove or update attribute of user in LDAP\n+  * -> 9) USER and ATTRIBUTE exist\n+  *   -> 9.1) if there is message with setting attribute to user => set Attribute to user in LDAP\n+  * -> 10) USER and ATTRIBUTE_DEFINITION exist\n+  *   -> 10.1) if there is message with removing attribute from user => remove Attribute from user in LDAP\n+  * -> 11) only USER exists\n+  *   -> 11.1) if there is message with deleting user => delete user from LDAP\n+  *   -> 11.2) if there is message with creating user => create user in LDAP\n+  *   -> 11.3) if there is message with updating user => update user in LDAP\n+  *   -> 11.4) if there is message with removing all attribute from user => remove all attributes from user in LDAP (only removeable attributes)\n+  * -> 12) FACILITY and ATTRIBUTE exist\n+  *   -> 12.1) if there is message with setting attribute to facility => set Attribute to resources (assigned to facility) in LDAP\n+  * -> 13) FACILITY and ATTRIBUTE_DEF exist\n+  *   -> 13.1) if there is message with removing attribute from facility => remove Attribute from resources (assigned to facility) in LDAP\n+  * -> 14) in all other cases\n+  *   -> 14.1) always => only log some information\n+  *\n+  * @param msg message which need to be parse and resolve\n+  * @param idOfMessage id of paring/resolving message\n+  *\n+  * @throws InternalErrorException when some internal error in core occurs\n+  */\n+\n+ protected void resolveMessage(String msg, Integer idOfMessage) throws InternalErrorException {\n+  List<PerunBean> listOfBeans;\n+  listOfBeans = AuditParser.parseLog(msg);\n+\n+  //Debug information to check parsing of message.\n+  if (!listOfBeans.isEmpty()) {\n+   int i = 0;\n+   for (PerunBean p : listOfBeans) {\n+    i++;\n+    if (p != null) log.debug(\"There is object number \" + i + \") \" + p.serializeToString());\n+    else log.debug(\"There is unknow object which is null\");\n+   }\n+  }\n+\n+  //Fill perunBeans\n+  emptyAndFillPerunBeans(listOfBeans);\n+\n+  //Log debug data for looking in messages\n+  log.debug(\"MessageNumber=\" + idOfMessage + \" -- OBJECTS: \" + this.member + '/' + this.group + '/' + this.facility + \"/\" + this.parentGroup + '/' + this.vo + '/' + this.resource + '/' + this.user + '/' + this.attribute + '/' + this.attributeDef + '/' + this.userExtSource);\n+\n+  //If specific user is the only one user in message, so behavior will be same for him like for any other user!\n+  if (this.specificUser != null && this.user == null) this.user = this.specificUser;\n+\n+  //------------------------------------------------------------------\n+  //-----------------OPERATIONS ON FILLED OBJECTS---------------------\n+  //------------------------------------------------------------------\n+  //Choose first possible solution for existing objects.\n+\n+  // 1) IF GROUP AND MEMBER WERE FOUND, TRY TO WORK WITH GROUP-MEMBER SPECIFIC OPERATIONS\n+  if (this.group != null && this.member != null) {\n+   // 1.1) ONLY FOR VALID MEMBER WE ADD HIM TO THE GROUP IN LDAP\n+   if (this.member.getStatus().equals(Status.VALID)) {\n+    Matcher addedTo = addedToPattern.matcher(msg);\n+    if (addedTo.find()) {\n+     if (!ldapConnector.isAlreadyMember(this.member, this.group)) ldapConnector.addMemberToGroup(this.member, this.group);\n+    }\n+   }\n+   // 1.2) MEMBER WILL BE REMOVED FROM GROUP\n+   Matcher totallyRemovedFrom = totallyRemovedFromPatter.matcher(msg);\n+   if (totallyRemovedFrom.find()) {\n+    if (ldapConnector.isAlreadyMember(this.member, this.group)) ldapConnector.removeMemberFromGroup(this.member, this.group);\n+   }\n+\n+   // 2) IF 2 GROUPS WERE FOUND, TRY TO WORK WITH PARENT_GROUP-SUBGROUP SPECIFIC OPERATIONS\n+  } else if (this.group != null && this.parentGroup != null) {\n+   Matcher newSubGroup = subGroupPattern.matcher(msg);\n+\n+   // 2.1) ADD GROUP AS SUBGROUP TO PARENT_GROUP\n+   if (newSubGroup.find()) {\n+    ldapConnector.addGroupAsSubGroup(this.group, this.parentGroup);\n+   }\n+\n+   // 3) IF GROUP AND RESOURCE WERE FOUND, TRY TO WORK WITH GROUP-RESOURCE SPECIFIC OPERATIONS\n+  } else if (this.group != null && this.resource != null) {\n+          Matcher assigned = assignGroupToResourcePattern.matcher(msg);\n+          Matcher removed = removeGroupFromResourcePattern.matcher(msg);\n+\n+   // 3.1) ADD NEW RESOURCE FOR GROUP IN LDAP\n+          if (assigned.find()) {\n+           updateGroupAttribute(ldapAttrAssignedToResourceId,\n+            String.valueOf(this.resource.getId()),\n+             LdapOperation.ADD_ATTRIBUTE,\n+             this.group);\n+           updateResourceAttribute(ldapAttrAssignedGroupId, String.valueOf(this.group.getId()), LdapOperation.ADD_ATTRIBUTE, this.resource);\n+    // 3.2) REMOVE RESOURCE FROM GROUP IN LDAP\n+          } else if (removed.find()) {\n+           updateGroupAttribute(ldapAttrAssignedToResourceId,\n+            String.valueOf(this.resource.getId()),\n+             LdapOperation.REMOVE_ATTRIBUTE,\n+                    this.group);\n+           updateResourceAttribute(ldapAttrAssignedGroupId,\n+            String.valueOf(this.group.getId()),\n+             LdapOperation.REMOVE_ATTRIBUTE,\n+                    this.resource);\n+          }\n+   // 4) IF ONLY RESOURCE WERE FOUND, TRY TO WORK WITH RESOURCE SPECIFIC OPERATIONS\n+         } else if (this.resource != null) {\n+          Matcher deleted = deletedResourcePattern.matcher(msg);\n+          Matcher created = createdPattern.matcher(msg);\n+          Matcher updated = updatedPattern.matcher(msg);\n+\n+   // 4.1) RESOURCE WILL BE DELETED\n+          if (deleted.find()) {\n+           ldapConnector.deleteResource(resource);\n+    // 4.2) RESOURCE WILL BE CREATED\n+          } else if (created.find()) {\n+           ldapConnector.createResource(resource, getFacilityEntityIdValue(resource.getFacilityId()));\n+    // 4.3) RESOURCE WILL BE UPDATED\n+          } else if (updated.find()) {\n+                  Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<>();\n+                  List<Pair<String, String>> replaceList = new ArrayList<>();\n+                  replaceList.add(new Pair(ldapAttrCommonName, this.resource.getName()));\n+                  if (this.resource.getDescription() != null && !this.resource.getDescription().isEmpty()) replaceList.add(new Pair(ldapAttrDescription, this.resource.getDescription()));\n+                  attributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n+                  updateResourceAttributes(attributes, this.resource);\n+                 }\n+   // 5) IF ONLY GROUP WERE FOUND, TRY TO WORK WITH GROUP SPECIFIC OPERATIONS\n+         } else if (this.group != null) {\n+                 Matcher deleted = deletedPattern.matcher(msg);\n+                 Matcher newGroup = newGroupPattern.matcher(msg);\n+                 Matcher updated = updatedPattern.matcher(msg);\n+                 Matcher moveGroup = moveGroupPattern.matcher(msg);\n+                 if (deleted.find()) {\n+    // 5.1) GROUP WILL BE DELETED\n+                  ldapConnector.removeGroup(this.group);\n+                 } else if (newGroup.find()) {\n+    // 5.2) GROUP WILL BE CREATED\n+                  ldapConnector.addGroup(this.group);\n+                 } else if (updated.find()) {\n+    // 5.3) GROUP WILL BE UPDATED\n+                         updateGroup(group);\n+                        } else if (moveGroup.find()) {\n+    // 5.4) MOVE GROUP IN STRUCTURE\n+                         moveGroup(group);\n+                        }\n+\n+   // 6) IF MEMBER WAS FOUND, TRY TO WORK WITH MEMBER SPECIFIC OPERATIONS (! RPC CALLING used there !)\n+                } else if (this.member != null) {\n+                 Matcher validated = validatedPattern.matcher(msg);\n+                 Matcher otherStateOfMember = otherStateOfMemberPattern.matcher(msg);\n+\n+   // 6.1) MEMBER WAS VALIDATED, NEED TO ADD HIM TO ALL GROUPS\n+                 if (validated.find()) {\n+                  List<Group> memberGroups = new ArrayList<Group>();\n+                  try {\n+                   memberGroups = Rpc.GroupsManager.getAllMemberGroups(ldapcManager.getRpcCaller(), this.member);\n+                  } catch (MemberNotExistsException e) {\n+     //IMPORTANT this is not problem, if member not exist, we expected that will be deleted in some message after that, in DB is deleted\n+\n+                  } catch (PrivilegeException e) {\n+                   throw new InternalErrorException(\"There are no privilegies for getting member's groups\", e);\n+                  } catch (InternalErrorException e) {\n+                   throw e;\n+                  }\n+\n+                  for (Group g : memberGroups) {\n+                   if (!ldapConnector.isAlreadyMember(this.member, g)) ldapConnector.addMemberToGroup(this.member, g);\n+                  }\n+    // 6.2) MEMBER STATE WAS CHANGED TO OTHER STATE THAN VALIDATE\n+                 } else if (otherStateOfMember.find()) {\n+                  List<Group> memberGroups = new ArrayList<Group>();\n+                  try {\n+                   memberGroups = Rpc.GroupsManager.getAllMemberGroups(ldapcManager.getRpcCaller(), this.member);\n+                  } catch (MemberNotExistsException e) {\n+     //IMPORTATNT this is not problem, if member not exist, we expected that will be deleted in some message after that, in DB is deleted\n+\n+                  } catch (PrivilegeException e) {\n+                   throw new InternalErrorException(\"There are no privilegies for getting member's groups\", e);\n+                  } catch (InternalErrorException e) {\n+                   throw e;\n+                  }\n+\n+                  for (Group g : memberGroups) {\n+                   if (ldapConnector.isAlreadyMember(this.member, g)) ldapConnector.removeMemberFromGroup(this.member, g);\n+                  }\n+                 }\n+\n+   // 7) IF VO WAS FOUND, TRY TO WORK WITH VO SPECIFIC OPERATIONS\n+                } else if (this.vo != null) {\n+                        Matcher deleted = deletedPattern.matcher(msg);\n+                        Matcher created = createdPattern.matcher(msg);\n+                        Matcher updated = updatedPattern.matcher(msg);\n+\n+   // 7.1) VO WILL BE DELETED\n+                        if (deleted.find()) {\n+                         ldapConnector.deleteVo(this.vo);\n+    // 7.2) VO WILL BE CREATED\n+                        } else if (created.find()) {\n+                         ldapConnector.createVo(this.vo);\n+    // 7.3) VO WILL BE UPDATED\n+                        } else if (updated.find()) {\n+                                Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n+                                List<Pair<String, String>> replaceList = new ArrayList<Pair<String, String>>();\n+                                replaceList.add(new Pair(ldapAttrDescription, this.vo.getName()));\n+                                attributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n+                                updateVoAttributes(attributes, this.vo);\n+                               }\n+\n+   // 8) IF USER AND USEREXTSOURCE WERE FOUND, TRY TO WORK WITH USER-USEREXTSOURCE SPECIFIC OPERATIONS (LIKE SET EXT LOGINS FOR IDP EXTSOURCES)\n+                       } else if (this.user != null && this.userExtSource != null) {\n+                        Matcher addExtSource = addUserExtSourcePattern.matcher(msg);\n+                        Matcher removeExtSource = removeUserExtSourcePattern.matcher(msg);\n+\n+   // 8.1) ADD ATTRIBUTE WITH IDP EXTSOURCE\n+                        if (addExtSource.find()) {\n+                         if (this.userExtSource.getExtSource() != null && this.userExtSource.getExtSource().getType() != null) {\n+                          String extLogin;\n+                          if (this.userExtSource.getExtSource().getType().equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n+                           extLogin = this.userExtSource.getLogin();\n+                           if (extLogin == null) extLogin = \"\";\n+                           updateUserAttribute(ldapAttrEduPersonPrincipalNames, extLogin, LdapOperation.ADD_ATTRIBUTE, user);\n+                          }\n+                         }\n+    // 8.2) REMOVE ATTRIBUTE WITH IDP EXTSOURCE\n+                        } else if (removeExtSource.find()) {\n+                         if (this.userExtSource.getExtSource() != null && this.userExtSource.getExtSource().getType() != null) {\n+                          String extLogin;\n+                          if (this.userExtSource.getExtSource().getType().equals(ExtSourcesManager.EXTSOURCE_IDP)) {\n+                           extLogin = this.userExtSource.getLogin();\n+                           if (extLogin == null) extLogin = \"\";\n+                           updateUserAttribute(ldapAttrEduPersonPrincipalNames, extLogin, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                          }\n+                         }\n+                        }\n+\n+   // 9) IF USER AND ATTRIBUTE WERE FOUND, TRY TO WORK WITH USER-ATTR SPECIFIC OPERATIONS (LIKE SET USER ATTRIBUTES)\n+                       } else if (this.user != null && this.attribute != null) {\n+                               Matcher set = userSetPattern.matcher(msg);\n+\n+   // 9.1) SOME USER ATTRIBUTE WILL BE PROBABLY SET (IF IT IS ONE OF SPECIFIC ATTRIBUTES)\n+                               if (set.find()) {\n+                                Matcher uidMatcher = userUidNamespacePattern.matcher(this.attribute.getName());\n+                                Matcher loginMatcher = userLoginNamespacePattern.matcher(this.attribute.getName());\n+                                if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail)) {\n+     //this mean change of attribute preferredMail in User\n+                                 if (this.attribute.getValue() != null) {\n+                                  updateUserAttribute(ldapAttrPreferredMail, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, user);\n+                                  updateUserAttribute(ldapAttrMail, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, user);\n+                                 } else {\n+                                  if (ldapConnector.userAttributeExist(this.user, ldapAttrPreferredMail)) {\n+                                   updateUserAttribute(ldapAttrPreferredMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                  }\n+                                  if (ldapConnector.userAttributeExist(this.user, ldapAttrMail)) {\n+                                   updateUserAttribute(ldapAttrMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                  }\n+                                 }\n+                                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrOrganization)) {\n+                                 if (this.attribute.getValue() != null) {\n+                                  updateUserAttribute(ldapAttrOrganization, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                                 } else {\n+                                  if (ldapConnector.userAttributeExist(this.user, ldapAttrOrganization)) {\n+                                   updateUserAttribute(ldapAttrOrganization, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                  }\n+                                 }\n+                                } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPhone)) {\n+                                        if (this.attribute.getValue() != null) {\n+                                         updateUserAttribute(ldapAttrTelephoneNumber, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                                        } else {\n+                                         if (ldapConnector.userAttributeExist(this.user, ldapAttrTelephoneNumber)) {\n+                                          updateUserAttribute(ldapAttrTelephoneNumber, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                         }\n+                                        }\n+                                       } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrUserCertDNs)) {\n+                                        Map<String, String> certDNsMap = (this.attribute.getValue() != null) ? (Map) this.attribute.getValue() : null;\n+                                        if (certDNsMap == null || certDNsMap.isEmpty()) {\n+                                         if (ldapConnector.userAttributeExist(this.user, ldapAttrUserCertDNs)) {\n+                                          updateUserAttribute(ldapAttrUserCertDNs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                         }\n+                                        } else {\n+                                         Set<String> certSubjectsWithPrefixes = ((Map) this.attribute.getValue()).keySet();\n+                                         Set<String> certSubjectsWithoutPrefixes = new HashSet<>();\n+      //remove prefixes from certificates\n+                                         for (String key : certSubjectsWithPrefixes) {\n+                                          certSubjectsWithoutPrefixes.add(key.replaceFirst(\"^[0-9]+[:]\", \"\"));\n+                                         }\n+                                         String[] subjectsArray = Arrays.copyOf(certSubjectsWithoutPrefixes.toArray(), certSubjectsWithoutPrefixes.toArray().length, String[].class);\n+                                         ldapConnector.updateUsersAttributeInLDAP(String.valueOf(this.user.getId()), ldapAttrUserCertDNs, subjectsArray);\n+                                        }\n+                                       } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrBonaFideStatus)) {\n+                                               if (this.attribute.getValue() != null) {\n+                                                updateUserAttribute(ldapAttrBonaFideStatus, (String) attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                                               } else {\n+                                                if (ldapConnector.userAttributeExist(this.user, ldapAttrBonaFideStatus)) {\n+                                                 updateUserAttribute(ldapAttrBonaFideStatus, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                                }\n+                                               }\n+                                              } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrSchacHomeOrganizations)) {\n+                                               updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrSchacHomeOrganizations);\n+                                              } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrEduPersonScopedAffiliations)) {\n+                                                      updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrEduPersonScopedAffiliations);\n+                                                     } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrGroupNames)) {\n+                                                      updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrGroupNames);\n+                                                     } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrInstitutionsCountries)) {\n+                                                             updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrInstitutionsCountries);\n+                                                            } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrLibraryIDs)) {\n+                                                             updateUserMultivalueAttributeInLDAP((ArrayList) this.attribute.getValue(), this.user, ldapAttrLibraryIDs);\n+                                                            } else if (uidMatcher.find()) {\n+                                                                    if (this.attribute.getValue() != null) {\n+                                                                     updateUserAttribute(ldapAttrUidNumber + this.attribute.getFriendlyNameParameter(), String.valueOf((Integer) this.attribute.getValue()), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                                                                    } else {\n+                                                                     if (ldapConnector.userAttributeExist(this.user, ldapAttrUidNumber + this.attribute.getFriendlyNameParameter())) {\n+                                                                      updateUserAttribute(ldapAttrUidNumber + this.attribute.getFriendlyNameParameter(),\n+null,\n+LdapOperation.REMOVE_ATTRIBUTE,\n+                                                                        this.user);\n+                                                                     }\n+                                                                    }\n+                                                                   } else if (loginMatcher.find()) {\n+                                                                    if (this.attribute.getValue() != null) {\n+                                                                     updateUserAttribute(ldapAttrLogin + this.attribute.getFriendlyNameParameter(), (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+      //if login is from loginNamespace (eg. EINFRA) (new value), then userPassword must be set or modified\n+                                                                     if (ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attribute.getFriendlyNameParameter())) {\n+                                                                      updateUserAttribute(ldapAttrUserPassword, \"{SASL}\" + this.attribute.getValue() + \"@\" + ldapProperties.getLdapLoginNamespace(), LdapOperation.REPLACE_ATTRIBUTE, this.user);\n+                                                                     }\n+                                                                    } else {\n+                                                                     if (ldapConnector.userAttributeExist(this.user, ldapAttrLogin + this.attribute.getFriendlyNameParameter())) {\n+                                                                      updateUserAttribute(ldapAttrLogin + this.attribute.getFriendlyNameParameter(), null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                                                     }\n+                                                                     if (ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attribute.getFriendlyNameParameter())) {\n+                                                                      if (ldapConnector.userAttributeExist(this.user, ldapAttrUserPassword)) {\n+                                                                       updateUserAttribute(ldapAttrUserPassword, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                                                      }\n+                                                                     }\n+                                                                    }\n+                                                                   }\n+                               }\n+\n+   // 10) IF USER AND ATTRIBTUE DEFINITION WERE FOUND, TRY TO WORK WITH USER-ATTRDEF SPECIFIC OPERATIONS\n+                              } else if (this.user != null && attributeDef != null) {\n+                               Matcher remove = userRemovePattern.matcher(msg);\n+   // 10.1) REMOVE SPECIFIC USER ATTRIBUTE\n+                               if (remove.find() && ldapConnector.userExist(this.user)) {\n+                                Matcher uidMatcher = userUidNamespacePattern.matcher(this.attributeDef.getName());\n+                                Matcher loginMatcher = userLoginNamespacePattern.matcher(this.attributeDef.getName());\n+                                if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail)) {\n+                                 if (ldapConnector.userAttributeExist(this.user, ldapAttrPreferredMail)) {\n+                                  updateUserAttribute(ldapAttrPreferredMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                 }\n+                                 if (ldapConnector.userAttributeExist(this.user, ldapAttrMail)) {\n+                                  updateUserAttribute(ldapAttrMail, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                 }\n+     //TODO: organization (user) will not exists\n+                                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrOrganization)) {\n+                                 if (ldapConnector.userAttributeExist(this.user, ldapAttrOrganization)) {\n+                                  updateUserAttribute(ldapAttrOrganization, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                 }\n+                                } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPhone)) {\n+                                        if (ldapConnector.userAttributeExist(this.user, ldapAttrTelephoneNumber)) {\n+                                         updateUserAttribute(ldapAttrTelephoneNumber, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                        }\n+                                       } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrUserCertDNs)) {\n+                                        if (ldapConnector.userAttributeExist(this.user, ldapAttrUserCertDNs)) {\n+                                         updateUserAttribute(ldapAttrUserCertDNs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                        }\n+                                       } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrEduPersonScopedAffiliations)) {\n+                                               if (ldapConnector.userAttributeExist(this.user, ldapAttrEduPersonScopedAffiliations)) {\n+                                                updateUserAttribute(ldapAttrEduPersonScopedAffiliations, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                               }\n+                                              } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrGroupNames)) {\n+                                               if (ldapConnector.userAttributeExist(this.user, ldapAttrGroupNames)) {\n+                                                updateUserAttribute(ldapAttrGroupNames, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                               }\n+                                              } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrInstitutionsCountries)) {\n+                                                      if (ldapConnector.userAttributeExist(this.user, ldapAttrInstitutionsCountries)) {\n+                                                       updateUserAttribute(ldapAttrInstitutionsCountries, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                                      }\n+                                                     } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrBonaFideStatus)) {\n+                                                      if (ldapConnector.userAttributeExist(this.user, ldapAttrBonaFideStatus)) {\n+                                                       updateUserAttribute(ldapAttrBonaFideStatus, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                                      }\n+                                                     } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_VIRT + \":\" + perunAttrSchacHomeOrganizations)) {\n+                                                             if (ldapConnector.userAttributeExist(this.user, ldapAttrSchacHomeOrganizations)) {\n+                                                              updateUserAttribute(ldapAttrSchacHomeOrganizations, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                                             }\n+                                                            } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrLibraryIDs)) {\n+                                                             if (ldapConnector.userAttributeExist(this.user, ldapAttrLibraryIDs)) {\n+                                                              updateUserAttribute(ldapAttrLibraryIDs, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                                             }\n+                                                            } else if (uidMatcher.find()) {\n+                                                                    if (ldapConnector.userAttributeExist(this.user, ldapAttrUidNumber + this.attributeDef.getFriendlyNameParameter())) {\n+                                                                     updateUserAttribute(ldapAttrUidNumber + this.attributeDef.getFriendlyNameParameter(),\n+null,\n+LdapOperation.REMOVE_ATTRIBUTE,\n+                                                                       this.user);\n+                                                                    }\n+                                                                   } else if (loginMatcher.find()) {\n+                                                                    if (ldapConnector.userAttributeExist(this.user, ldapAttrLogin + this.attributeDef.getFriendlyNameParameter())) {\n+                                                                     updateUserAttribute(ldapAttrLogin + this.attributeDef.getFriendlyNameParameter(),\n+null,\n+LdapOperation.REMOVE_ATTRIBUTE,\n+                                                                       this.user);\n+                                                                    }\n+                                                                    if (ldapProperties.getLdapLoginNamespace().toLowerCase().equals(this.attributeDef.getFriendlyNameParameter())) {\n+                                                                     if (ldapConnector.userPasswordExists(this.user)) {\n+                                                                      updateUserAttribute(ldapAttrUserPassword, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                                                     }\n+                                                                    }\n+                                                                   }\n+                               }\n+   // 11) IF ONLY USER WAS FOUND, TRY TO WORK WITH USER SPECIFIC OPERATIONS\n+                              } else if (this.user != null) {\n+                                      Matcher deleted = deletedPattern.matcher(msg);\n+                                      Matcher created = createdPattern.matcher(msg);\n+                                      Matcher updated = updatedPattern.matcher(msg);\n+                                      Matcher removedAllAttrs = userAllAttrsRemovedPattern.matcher(msg);\n+   // 11.1) DELETE USER\n+                                      if (deleted.find()) {\n+                                       ldapConnector.deleteUser(this.user);\n+    // 11.2) CREATE USER\n+                                      } else if (created.find()) {\n+                                       ldapConnector.createUser(this.user);\n+    // 11.3) UPDATE USER\n+                                      } else if (updated.find()) {\n+                                              Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n+                                              List<Pair<String, String>> replaceList = new ArrayList<Pair<String, String>>();\n+                                              String firstName = this.user.getFirstName();\n+                                              String lastName = this.user.getLastName();\n+                                              String commonName = \"\";\n+                                              if (firstName == null || firstName.isEmpty()) firstName = \"\";\n+                                              else commonName += firstName + \" \";\n+                                              if (lastName == null || lastName.isEmpty()) lastName = \"N/A\";\n+                                              commonName += lastName;\n+                                              replaceList.add(new Pair(ldapAttrSurname, lastName));\n+                                              replaceList.add(new Pair(ldapAttrCommonName, commonName));\n+    // IF firstName is empty, maybe need to be removed first\n+                                              if (firstName.isEmpty()) {\n+     //if first name exists and new one is empty, then remove it, else do nothing\n+                                               if (ldapConnector.userAttributeExist(this.user, ldapAttrGivenName)) {\n+                                                updateUserAttribute(ldapAttrGivenName, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+                                               }\n+                                              } else {\n+     //if first name is not empty, replace it by new first name\n+                                               replaceList.add(new Pair(ldapAttrGivenName, firstName));\n+                                              }\n+                                              attributes.put(LdapOperation.REPLACE_ATTRIBUTE, replaceList);\n+                                              updateUserAttributes(attributes, this.user);\n+    // 11.4) REMOVE ALL USER ATTRIBUTES\n+                                             } else if (removedAllAttrs.find()) {\n+                                              if (ldapConnector.userExist(this.user)) {\n+                                               Attributes usersAttrs = ldapConnector.getAllUsersAttributes(this.user);\n+                                               List<ModificationItem> listOfItems = new ArrayList<ModificationItem>();\n+                                               if (usersAttrs != null) {\n+                                                NamingEnumeration<? extends Attribute> attributesEnumeration;\n+                                                attributesEnumeration = usersAttrs.getAll();\n+\n+                                                try {\n+                                                 while (attributesEnumeration.hasMore()) {\n+                                                  Attribute attr = attributesEnumeration.nextElement();\n+                                                  if (attr != null && attr.getID() != null) {\n+                                                   if (isRemovableUserAttribute(attr.getID())) {\n+                                                    ModificationItem item = new ModificationItem(LdapOperation.REMOVE_ATTRIBUTE.getCode(), attr);\n+                                                    listOfItems.add(item);\n+                                                   }\n+                                                  }\n+                                                 }\n+                                                } catch (NamingException ex) {\n+                                                 throw new InternalErrorException(\"Error at Deleting All Users Attribute, throw namingException.\", ex);\n+                                                }\n+                                               }\n+                                               if (!listOfItems.isEmpty()) {\n+                                                ModificationItem[] items = Arrays.copyOf(listOfItems.toArray(), listOfItems.toArray().length, ModificationItem[].class);\n+                                                ldapConnector.updateUser(this.user, items);\n+                                               }\n+                                              }\n+                                             }\n+\n+   //12) IF FACILITY AND ATTRIBUTE TO SET WAS FOUND\n+                                     } else if (this.facility != null && attribute != null) {\n+                                      Matcher set = facilitySetPattern.matcher(msg);\n+\n+   // 12.1) SOME FACILITY ATTRIBUTE WILL BE PROBABLY SET (IF IT IS ONE OF SPECIFIC ATTRIBUTES)\n+                                      if (set.find()) {\n+    //EntityID WILL BE SET\n+                                       if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID)) {\n+                                        try {\n+                                         List<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n+      //this mean change of attribute entityID in all assigned resources\n+                                         if (this.attribute.getValue() != null) {\n+\n+                                          for (Resource res : resources) {\n+                                           updateResourceAttribute(ldapAttrEntityID, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, res);\n+                                          }\n+                                         } else {\n+\n+                                          for (Resource res : resources) {\n+                                           if (ldapConnector.resourceAttributeExist(res, ldapAttrEntityID)) {\n+                                            updateResourceAttribute(ldapAttrEntityID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n+                                           }\n+                                          }\n+                                         }\n+                                        } catch (FacilityNotExistsException ex) {\n+      //this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n+      //so skip it just log\n+                                         log.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n+                                        } catch (PrivilegeException e) {\n+                                         throw new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n+                                        }\n+    //OIDCClientID WILL BE SET\n+                                       } else if (this.attribute.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrClientID)) {\n+                                        try {\n+                                         List<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n+      //this mean change of attribute clientID in all assigned resources\n+                                         if (this.attribute.getValue() != null) {\n+\n+                                          for (Resource res : resources) {\n+                                           updateResourceAttribute(ldapAttrClientID, (String) this.attribute.getValue(), LdapOperation.REPLACE_ATTRIBUTE, res);\n+                                          }\n+                                         } else {\n+\n+                                          for (Resource res : resources) {\n+                                           if (ldapConnector.resourceAttributeExist(res, ldapAttrClientID)) {\n+                                            updateResourceAttribute(ldapAttrClientID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n+                                           }\n+                                          }\n+                                         }\n+                                        } catch (FacilityNotExistsException ex) {\n+      //this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n+      //so skip it just log\n+                                         log.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n+                                        } catch (PrivilegeException e) {\n+                                         throw new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n+                                        }\n+                                       }\n+                                      }\n+   //13) IF FACILITY AND ATTRIBUTE DEF TO REMOVE WAS FOUND\n+                                     } else if (this.facility != null && attributeDef != null) {\n+                                             Matcher remove = facilityRemovePattern.matcher(msg);\n+   // 13.1) REMOVE SPECIFIC FACILITY ATTRIBUTE\n+                                             if (remove.find()) {\n+                                              if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID)) {\n+                                               try {\n+                                                List<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n+                                                for (Resource res : resources) {\n+                                                 if (ldapConnector.resourceAttributeExist(res, ldapAttrEntityID)) {\n+                                                  updateResourceAttribute(ldapAttrEntityID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n+                                                 }\n+                                                }\n+                                               } catch (FacilityNotExistsException ex) {\n+      //this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n+      //so skip it just log\n+                                                log.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n+                                               } catch (PrivilegeException e) {\n+                                                throw new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n+                                               }\n+                                              } else if (this.attributeDef.getName().equals(cz.metacentrum.perun.core.api.AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrClientID)) {\n+                                               try {\n+                                                List<Resource> resources = Rpc.FacilitiesManager.getAssignedResources(ldapcManager.getRpcCaller(), this.facility);\n+                                                for (Resource res : resources) {\n+                                                 if (ldapConnector.resourceAttributeExist(res, ldapAttrClientID)) {\n+                                                  updateResourceAttribute(ldapAttrClientID, null, LdapOperation.REMOVE_ATTRIBUTE, res);\n+                                                 }\n+                                                }\n+                                               } catch (FacilityNotExistsException ex) {\n+      //this probably means that facility is already removed, so also resources are removed and we just delete them in some other message\n+      //so skip it just log\n+                                                log.debug(\"Try to get resources from facility, but facility just not exists. Skip it!\");\n+                                               } catch (PrivilegeException e) {\n+                                                throw new InternalErrorException(\"There are no privilegies for getting all assigned resources of facility\" + this.facility, e);\n+                                               }\n+                                              }\n+                                             }\n+    // 14) IN OTHER CASES\n+                                            } else {\n+                                             log.debug(\"Nothing to resolve for message with number : \" + idOfMessage);\n+                                            }\n+ }\n+\n+ /**\n+  * Choose if attribute is removable or not.\n+  * It means if is this attribute is required and can't be null.\n+  *\n+  * @param attributeName name of attribute in ldap\n+  * @return true if attribute is removable, false if not\n+  */\n+\n+\n+ private boolean isRemovableUserAttribute(String attributeName) {\n+  List<String> attributesWithoutOption = new ArrayList<String>();\n+  //Attributes without option like \"x-ns-namespace\"\n+  attributesWithoutOption.add(ldapAttrMail);\n+  attributesWithoutOption.add(ldapAttrPreferredMail);\n+  attributesWithoutOption.add(ldapAttrOrganization);\n+  attributesWithoutOption.add(ldapAttrUserCertDNs);\n+  attributesWithoutOption.add(ldapAttrSchacHomeOrganizations);\n+  attributesWithoutOption.add(ldapAttrBonaFideStatus);\n+  attributesWithoutOption.add(ldapAttrEduPersonScopedAffiliations);\n+  attributesWithoutOption.add(ldapAttrLibraryIDs);\n+  attributesWithoutOption.add(ldapAttrTelephoneNumber);\n+  attributesWithoutOption.add(ldapAttrInstitutionsCountries);\n+  attributesWithoutOption.add(ldapAttrGroupNames);\n+  attributesWithoutOption.add(ldapAttrMemberOfPerunVo);\n+  attributesWithoutOption.add(ldapAttrEduPersonPrincipalNames);\n+  if (attributesWithoutOption.contains(attributeName))\n+   return true;\n+\n+  //Attributes with option like \"x-ns-namespace\"\n+  List<String> attributesWithOption = new ArrayList<String>();\n+  attributesWithOption.add(ldapAttrUidNumber);\n+  attributesWithOption.add(ldapAttrLogin);\n+  attributesWithOption.add(ldapAttrUserPassword);\n+  for (String s : attributesWithOption) {\n+   if (attributeName.startsWith(s))\n+    return true;\n+  }\n+\n+  return false;\n+ }\n+\n+ /**\n+  * Get User preferred Mail value from perun.\n+  *\n+  * @param user the user\n+  * @return value of user's preferredMail or null, if value is null or user not exists yet\n+  * @throws InternalErrorException if some exception (except UserNotExistsException) is thrown from RPC\n+  */\n+\n+\n+ private String getUserPreferredMailValue(User user) throws InternalErrorException {\n+  cz.metacentrum.perun.core.api.Attribute preferredMailAttr = null;\n+  try {\n+   preferredMailAttr = Rpc.AttributesManager.getAttribute(ldapcManager.getRpcCaller(),\n+   user,\n+   cz.metacentrum.perun.core.api.AttributesManager.NS_USER_ATTR_DEF + \":\" + perunAttrPreferredMail);\n+  } catch (PrivilegeException ex) {\n+   throw new InternalErrorException(\"There are no privilegies for getting user's attribute.\", ex);\n+  } catch (AttributeNotExistsException ex) {\n+   throw new InternalErrorException(\"There is no such attribute.\", ex);\n+  } catch (UserNotExistsException ex) {\n+   //If user not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n+   return null;\n+  } catch (WrongAttributeAssignmentException ex) {\n+   throw new InternalErrorException(\"There is problem with wrong attribute assignment exception.\", ex);\n+  }\n+  if (preferredMailAttr.getValue() == null) return null;\n+  else return (String) preferredMailAttr.getValue();\n+ }\n+\n+ /**\n+  * Get entityID value from perun by facilityId.\n+  *\n+  * @param facilityId the facilityId\n+  * @return value of entityID or null, if value is null or user not exists yet\n+  * @throws InternalErrorException if some exception is thrown from RPC\n+  */\n+\n+\n+ private String getFacilityEntityIdValue(int facilityId) throws InternalErrorException {\n+  Facility facility = null;\n+  try {\n+   facility = Rpc.FacilitiesManager.getFacilityById(ldapcManager.getRpcCaller(), facilityId);\n+  } catch (PrivilegeException ex) {\n+   throw new InternalErrorException(\"There are no privilegies for getting facility by id.\", ex);\n+  } catch (FacilityNotExistsException ex) {\n+   //If facility not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n+   return null;\n+  }\n+  cz.metacentrum.perun.core.api.Attribute entityID = null;\n+  try {\n+   entityID = Rpc.AttributesManager.getAttribute(ldapcManager.getRpcCaller(), facility, AttributesManager.NS_FACILITY_ATTR_DEF + \":\" + perunAttrEntityID);\n+  } catch (PrivilegeException ex) {\n+   throw new InternalErrorException(\"There are no privilegies for getting facility attribute.\", ex);\n+  } catch (AttributeNotExistsException ex) {\n+   throw new InternalErrorException(\"There is no such attribute.\", ex);\n+  } catch (FacilityNotExistsException ex) {\n+   //If facility not exist in perun now, probably will be deleted in next step so its ok. The value is null anyway.\n+   return null;\n+  } catch (WrongAttributeAssignmentException ex) {\n+   throw new InternalErrorException(\"There is problem with wrong attribute assignment exception.\", ex);\n+  }\n+  if (entityID.getValue() == null) return null;\n+  else return (String) entityID.getValue();\n+ }\n+\n+ /**\n+  * Update ldap attribute with attributeName for the user by value with operation.\n+  *\n+  *\n+  * @param attributeName name of attribute, is mandatory, cant be null\n+  * @param attributeValue value of attribute, is not mandatory, can be null\n+  * @param operation add, remove or replace (can't be null)\n+  * @param user cant be null\n+  *\n+  * @exception InternalErrorException if an error occurs\n+  *\n+  */\n+\n+\n+ private void updateUserAttribute(String attributeName,\n+                                  String attributeValue,\n+                                  LdapOperation operation, User user) throws InternalErrorException {\n+  if (operation == null) throw new InternalErrorException(\"Operation can't be null\");\n+  if (attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateUserAttribute :\" + attributeName);\n+  if (user == null) throw new InternalErrorException(\"User is null in method updateUserAttribute\");\n+  Attribute attribute;\n+  if (attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n+  else attribute = new BasicAttribute(attributeName);\n+  ModificationItem attributeItem = new ModificationItem(operation.getCode(), attribute);\n+  ldapConnector.updateUser(user, new ModificationItem[] {attributeItem});\n+ }\n+\n+ /**\n+  * Update user's ldap attributes from Map by operation in key.\n+  *\n+  * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n+  *\n+  *\n+  * attributeName cant be null and empty String\n+  * attributeValue can be null\n+  *\n+  * Execute all operations on all attributes with (or without value) in 1 task.\n+  *\n+  * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n+  * @param user cant be null\n+  * @throws InternalErrorException if an error occurs\n+  */\n+\n+\n+ private void updateUserAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, User user) throws InternalErrorException {\n+  //User cant be null\n+  if (user == null) throw new InternalErrorException(\"User is null in method updateUserAttributes\");\n+  Set<LdapOperation> keys = mapOfAttributes.keySet();\n+\n+  //Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n+  for (LdapOperation operation : keys) {\n+   List<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n+   for (Pair<String, String> pair : listOfAttrs) {\n+    if (pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n+   }\n+  }\n+\n+  //If all is correct, can execute operations on attributes\n+  List<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n+\n+  //Execute all changes on the notEmpty list of items\n+  if (!listOfItemsToModify.isEmpty()) {\n+   ModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n+   ldapConnector.updateUser(user, items);\n+  }\n+ }\n+\n+ /**\n+  * Update ldap attribute with attributeName for the resource by value with operation.\n+  *\n+  *\n+  * @param attributeName name of attribute, is mandatory, cant be null\n+  * @param attributeValue value of attribute, is not mandatory, can be null\n+  * @param operation add, replace or remove, can't be null\n+  * @param resource cant be null\n+  *\n+  * @exception InternalErrorException if an error occurs\n+  */\n+\n+\n+ private void updateResourceAttribute(String attributeName,\n+                                      String attributeValue,\n+                                      LdapOperation operation, Resource resource) throws InternalErrorException {\n+  if (operation == null) throw new InternalErrorException(\"Operation can't be null.\");\n+  if (attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateResourceAttribute :\" + attributeName);\n+  if (resource == null) throw new InternalErrorException(\"Resource is null in method updateResourceAttribute\");\n+  Attribute attribute;\n+  if (attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n+  else attribute = new BasicAttribute(attributeName);\n+  ModificationItem attributeItem = new ModificationItem(operation.getCode(), attribute);\n+  ldapConnector.updateResource(resource, new ModificationItem[] {attributeItem});\n+ }\n+\n+ /**\n+  * Update resource's ldap attributes from Map by operation in key.\n+  *\n+  * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n+  *\n+  * attributeName cant be null and empty String\n+  * attributeValue can be null\n+  *\n+  * Execute all operations on all attributes with (or without value) in 1 task.\n+  *\n+  * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n+  * @param resource cant be null\n+  * @throws InternalErrorException if an error occurs\n+  */\n+\n+\n+ private void updateResourceAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Resource resource) throws InternalErrorException {\n+  //Resource cant be null\n+  if (resource == null) throw new InternalErrorException(\"Resource is null in method updateGroupAttributes\");\n+  Set<LdapOperation> keys = mapOfAttributes.keySet();\n+\n+  //Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n+  for (LdapOperation operation : keys) {\n+   List<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n+   for (Pair<String, String> pair : listOfAttrs) {\n+    if (pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n+   }\n+  }\n+\n+  //If all is correct, can execute operations on attributes\n+  List<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n+\n+  //Execute all changes on the notEmpty list of items\n+  if (!listOfItemsToModify.isEmpty()) {\n+   ModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n+   ldapConnector.updateResource(resource, items);\n+  }\n+ }\n+\n+ /**\n+  * Move group in hierarchical structure of it's VO.\n+  *\n+  * That means to change attributes in LDAP with name of group (structure is defined in name of group)\n+  * and references to parentGroup if any exist.\n+  *\n+  * @param group group object after moving\n+  *\n+  * @throws InternalErrorException\n+  */\n+\n+\n+ private void moveGroup(Group group) throws InternalErrorException {\n+  Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<LdapOperation, List<Pair<String, String>>>();\n+  List<Pair<String, String>> listAttributesToBeRemoved = new ArrayList<>();\n+  List<Pair<String, String>> listAttributesToBeReplaced = new ArrayList<>();\n+  listAttributesToBeReplaced.add(new Pair(ldapAttrCommonName, group.getName()));\n+  listAttributesToBeReplaced.add(new Pair(ldapAttrPerunUniqueGroupName, ldapConnector.getVoShortName(group.getVoId()) + \":\" + group.getName()));\n+\n+  //Check if group is now as subgroup or as top group\n+  if (group.getName().contains(\":\")) {\n+   //group is moved as subgroup\n+   listAttributesToBeReplaced.add(new Pair(ldapAttrPerunParentGroup, ldapAttrPerunGroupId + \"=\" + group.getParentGroupId().toString() + \",\" + ldapAttrPerunVoId + \"=\" + group.getVoId() + \",\" + ldapProperties.getLdapBase()));\n+   listAttributesToBeReplaced.add(new Pair(ldapAttrPerunParentGroupId, group.getParentGroupId().toString()));\n+  } else {\n+   //group is moved as top group\n+   if (ldapConnector.groupAttributeExist(group, ldapAttrPerunParentGroup)) {\n+    listAttributesToBeRemoved.add(new Pair(ldapAttrPerunParentGroup, null));\n+   }\n+   if (ldapConnector.groupAttributeExist(group, ldapAttrPerunParentGroupId)) {\n+    listAttributesToBeRemoved.add(new Pair(ldapAttrPerunParentGroupId, null));\n+   }\n+  }\n+\n+  //Add all attributes which will be replaced for the group (that also mean added if not exists yet)\n+  attributes.put(LdapOperation.REPLACE_ATTRIBUTE, listAttributesToBeReplaced);\n+  //Add all attributes (if any) which will be removed for group\n+  if (!listAttributesToBeReplaced.isEmpty()) attributes.put(LdapOperation.REMOVE_ATTRIBUTE, listAttributesToBeRemoved);\n+\n+  //update attributes in LDAP for group\n+  updateGroupAttributes(attributes, group);\n+ }\n+\n+ /**\n+  * Update basic group attributes (name and description) in LDAP\n+  *\n+  * @param group group after update\n+  *\n+  * @throws InternalErrorException\n+  */\n+\n+\n+ private void updateGroup(Group group) throws InternalErrorException {\n+  Map<LdapOperation, List<Pair<String, String>>> attributes = new HashMap<>();\n+  List<Pair<String, String>> listAttributesToBeRemoved = new ArrayList<>();\n+  List<Pair<String, String>> listAttributesToBeReplaced = new ArrayList<>();\n+\n+  //change name\n+  listAttributesToBeReplaced.add(new Pair(ldapAttrCommonName, this.group.getName()));\n+  listAttributesToBeReplaced.add(new Pair(ldapAttrPerunUniqueGroupName,\n+ldapConnector.getVoShortName(this.group.getVoId()) + \":\" + this.group.getName()));\n+\n+  //change description (or remove it if there is none)\n+  if (group.getDescription() != null && !group.getDescription().isEmpty()) {\n+   listAttributesToBeReplaced.add(new Pair(ldapAttrDescription, this.group.getDescription()));\n+  } else {\n+   if (ldapConnector.groupAttributeExist(group, ldapAttrDescription)) {\n+    listAttributesToBeRemoved.add(new Pair(ldapAttrDescription, null));\n+   }\n+  }\n+\n+  //Add all attributes which will be replaced for the group (that also mean added if not exists yet)\n+  attributes.put(LdapOperation.REPLACE_ATTRIBUTE, listAttributesToBeReplaced);\n+  //Add all attributes (if any) which will be removed for group\n+  if (!listAttributesToBeReplaced.isEmpty()) attributes.put(LdapOperation.REMOVE_ATTRIBUTE, listAttributesToBeRemoved);\n+\n+  //update attributes in LDAP for group\n+  updateGroupAttributes(attributes, group);\n+ }\n+\n+ /**\n+  * Update ldap attribute with attributeName for the group by value with operation.\n+  *\n+  * @param attributeName name of attribute, is mandatory, cant be null\n+  * @param attributeValue value of attribute, is not mandatory, can be null\n+  * @param operation add, replace or remove, can't be null\n+  * @param group cant be null\n+  *\n+  * @exception InternalErrorException if an error occurs\n+  *\n+  */\n+\n+\n+ private void updateGroupAttribute(String attributeName,\n+                                   String attributeValue,\n+                                   LdapOperation operation, Group group) throws InternalErrorException {\n+  if (operation == null) throw new InternalErrorException(\"Operation can't be null.\");\n+  if (attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateGroupAttribute :\" + attributeName);\n+  if (group == null) throw new InternalErrorException(\"Group is null in method updateGroupAttribute\");\n+  Attribute attribute;\n+  if (attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n+  else attribute = new BasicAttribute(attributeName);\n+  ModificationItem attributeItem = new ModificationItem(operation.getCode(), attribute);\n+  ldapConnector.updateGroup(group, new ModificationItem[] {attributeItem});\n+ }\n+\n+ /**\n+  * Update group's ldap attributes from Map by operation in key.\n+  *\n+  * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n+  *\n+  * attributeName cant be null and empty String\n+  * attributeValue can be null\n+  *\n+  * Execute all operations on all attributes with (or without value) in 1 task.\n+  *\n+  * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n+  * @param group cant be null\n+  * @throws InternalErrorException if an error occurs\n+  */\n+\n+\n+ private void updateGroupAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Group group) throws InternalErrorException {\n+  //Group cant be null\n+  if (group == null) throw new InternalErrorException(\"group is null in method updateGroupAttributes\");\n+  Set<LdapOperation> keys = mapOfAttributes.keySet();\n+\n+  //Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n+  for (LdapOperation operation : keys) {\n+   List<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n+   for (Pair<String, String> pair : listOfAttrs) {\n+    if (pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n+   }\n+  }\n+\n+  //If all is correct, can execute operations on attributes\n+  List<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n+\n+  //Execute all changes on the notEmpty list of items\n+  if (!listOfItemsToModify.isEmpty()) {\n+   ModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n+   ldapConnector.updateGroup(group, items);\n+  }\n+ }\n+\n+ /**\n+  * Update ldap attribute with attributeName for the vo by value with operation.\n+  *\n+  * @param attributeName name of attribute, is mandatory, cant be null\n+  * @param attributeValue value of attribute, is not mandatory, can be null\n+  * @param operation add, replace or remove, can't be null\n+  * @param vo cant be null\n+  *\n+  * @exception InternalErrorException if an error occurs\n+  */\n+\n+\n+ private void updateVoAttribute(String attributeName,\n+                                String attributeValue,\n+                                LdapOperation operation, Vo vo) throws InternalErrorException {\n+  if (operation == null) throw new InternalErrorException(\"Operation can't be null.\");\n+  if (attributeName == null || attributeName.equals(\"\")) throw new InternalErrorException(\"Bad attribute Name in method updateVoAttribute :\" + attributeName);\n+  if (vo == null) throw new InternalErrorException(\"Vo is null in method updateVoAttribute\");\n+  Attribute attribute;\n+  if (attributeValue != null) attribute = new BasicAttribute(attributeName, attributeValue);\n+  else attribute = new BasicAttribute(attributeName);\n+  ModificationItem attributeItem = new ModificationItem(operation.getCode(), attribute);\n+  ldapConnector.updateVo(vo, new ModificationItem[] {attributeItem});\n+ }\n+\n+ /**\n+  * Update vo's ldap attributes from Map by operation in key.\n+  *\n+  * Map<LdapOperation, List<Pair<String, String>>> => Map<LdapOperation, List<Pair<attributeName, attributeValue>>>\n+  *\n+  *\n+  * attributeName cant be null and empty String\n+  * attributeValue can be null\n+  *\n+  * Execute all operations on all attributes with (or without value) in 1 task.\n+  *\n+  * @param mapOfAttributes map of Operation to list of pairs where left is attributeName and right is attributeValue\n+  * @param vo cant be null\n+  * @throws InternalErrorException if an error occurs\n+  */\n+\n+\n+ private void updateVoAttributes(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes, Vo vo) throws InternalErrorException {\n+  //User cant be null\n+  if (vo == null) throw new InternalErrorException(\"Vo is null in method updateVoAttributes\");\n+  //Only 3 types of key are allowed (1,2 or 3) Modification classes\n+  Set<LdapOperation> keys = mapOfAttributes.keySet();\n+\n+  //Every Pair in List need to have \"attributeName\" and may have \"attributeValue\"\n+  for (LdapOperation operation : keys) {\n+   List<Pair<String, String>> listOfAttrs = mapOfAttributes.get(operation);\n+   for (Pair<String, String> pair : listOfAttrs) {\n+    if (pair.getLeft() == null || pair.getLeft().equals(\"\")) throw new InternalErrorException(\"Some attributes in map has no name.\");\n+   }\n+  }\n+\n+  //If all is correct, can execute operations on attributes\n+  List<ModificationItem> listOfItemsToModify = getListOfModificationItems(mapOfAttributes);\n+\n+  //Execute all changes on the notEmpty list of items\n+  if (!listOfItemsToModify.isEmpty()) {\n+   ModificationItem[] items = Arrays.copyOf(listOfItemsToModify.toArray(), listOfItemsToModify.toArray().length, ModificationItem[].class);\n+   ldapConnector.updateVo(vo, items);\n+  }\n+ }\n+\n+ /**\n+  * Update multi value attribute for user in LDAP by name and values\n+  *\n+  * @param listOfValues to set, can be empty or null (that means no values should be set - remove existing values if any)\n+  * @param user not null user to set attribute in ldap\n+  * @param attributeLDAPName not null, not empty name of attribute in ldap\n+  * @throws InternalErrorException if any of mandatory arguments are empty or any internal error occurred\n+  */\n+\n+\n+ private void updateUserMultivalueAttributeInLDAP(List<String> listOfValues, User user, String attributeLDAPName) throws InternalErrorException {\n+  if (user == null) throw new InternalErrorException(\"User can't be null.\");\n+  if (attributeLDAPName == null || attributeLDAPName.isEmpty()) throw new InternalErrorException(\"Attribute name can't be null.\");\n+  if (listOfValues == null || listOfValues.isEmpty()) {\n+   if (ldapConnector.userAttributeExist(user, attributeLDAPName)) {\n+    updateUserAttribute(attributeLDAPName, null, LdapOperation.REMOVE_ATTRIBUTE, this.user);\n+   }\n+  } else {\n+   String[] subjectsArray = Arrays.copyOf(listOfValues.toArray(), listOfValues.toArray().length, String[].class);\n+   ldapConnector.updateUsersAttributeInLDAP(String.valueOf(this.user.getId()), attributeLDAPName, subjectsArray);\n+  }\n+ }\n+\n+ /**\n+  * Take map of operations and associated items to be add, replaced or removed from LDAP. Then convert this map to\n+  * list of ModificationItems (Modification Item is attribute in LDAP with new value and operation which will be\n+  * processed for it. Return this map.\n+  *\n+  * Possible Operations:\n+  * 1 - ADD_ATTRIBUTE\n+  * 2 - REPLACE_ATTRIBUTE\n+  * 3 - REMOVE_ATTRIBUTES\n+  *\n+  * Skip not existing operations in map. If map is null, return empty list. If list of operations under operation is\n+  * null, skipt it too.\n+  *\n+  * @param mapOfAttributes map of operations and associated items with new values to be processed\n+  * @return list of modificationItems to be processed\n+  */\n+\n+\n+ private List<ModificationItem> getListOfModificationItems(Map<LdapOperation, List<Pair<String, String>>> mapOfAttributes) {\n+  List<ModificationItem> listOfItemsToModify = new ArrayList<>();\n+  if (mapOfAttributes == null)\n+   return listOfItemsToModify;\n+\n+  //For all attributes with operation ADD (1)\n+  if (mapOfAttributes.containsKey(LdapOperation.ADD_ATTRIBUTE)) {\n+   List<Pair<String, String>> listOfAttributesToAdd = mapOfAttributes.get(LdapOperation.ADD_ATTRIBUTE);\n+   if (listOfAttributesToAdd != null) {\n+\n+    for (Pair<String, String> pair : listOfAttributesToAdd) {\n+     Attribute attribute;\n+     if (pair.getRight() != null) attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n+     else attribute = new BasicAttribute(pair.getLeft());\n+     ModificationItem attributeItem = new ModificationItem(LdapOperation.ADD_ATTRIBUTE.getCode(), attribute);\n+     listOfItemsToModify.add(attributeItem);\n+    }\n+   }\n+  }\n+\n+  //For all attributes with operation REPLACE (2)\n+  if (mapOfAttributes.containsKey(LdapOperation.REPLACE_ATTRIBUTE)) {\n+   List<Pair<String, String>> listOfAttributesToReplace = mapOfAttributes.get(LdapOperation.REPLACE_ATTRIBUTE);\n+   if (listOfAttributesToReplace != null) {\n+\n+    for (Pair<String, String> pair : listOfAttributesToReplace) {\n+     Attribute attribute;\n+     if (pair.getRight() != null) attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n+     else attribute = new BasicAttribute(pair.getLeft());\n+     ModificationItem attributeItem = new ModificationItem(LdapOperation.REPLACE_ATTRIBUTE.getCode(), attribute);\n+     listOfItemsToModify.add(attributeItem);\n+    }\n+   }\n+  }\n+\n+  //For all attributes with operation REMOVE (3)\n+  if (mapOfAttributes.containsKey(LdapOperation.REMOVE_ATTRIBUTE)) {\n+   List<Pair<String, String>> listOfAttributesToRemove = mapOfAttributes.get(LdapOperation.REMOVE_ATTRIBUTE);\n+   if (listOfAttributesToRemove != null) {\n+\n+    for (Pair<String, String> pair : listOfAttributesToRemove) {\n+     Attribute attribute;\n+     if (pair.getRight() != null) attribute = new BasicAttribute(pair.getLeft(), pair.getRight());\n+     else attribute = new BasicAttribute(pair.getLeft());\n+     ModificationItem attributeItem = new ModificationItem(LdapOperation.REMOVE_ATTRIBUTE.getCode(), attribute);\n+     listOfItemsToModify.add(attributeItem);\n+    }\n+   }\n+  }\n+\n+  return listOfItemsToModify;\n+ }\n+\n+ /**\n+  * Fill objects from list of beans.\n+  * If list of beans is empty or null, fill nothing.\n+  *\n+  * @param listOfBeans list of beans already parsed from message\n+  *\n+  * @throws InternalErrorException If there is some inconsistence in number of one type's objects.\n+  */\n+\n+\n+ private void emptyAndFillPerunBeans(List<PerunBean> listOfBeans) throws InternalErrorException {\n+  //First null all usefull objects\n+  resource = null;\n+  member = null;\n+  group = null;\n+  parentGroup = null;\n+  vo = null;\n+  user = null;\n+  specificUser = null;\n+  attribute = null;\n+  attributeDef = null;\n+  userExtSource = null;\n+  facility = null;\n+\n+  //If there is no usefull object, exit method\n+  if (listOfBeans == null)\n+   return;\n+  for (PerunBean perunBean : listOfBeans) {\n+   if (perunBean instanceof Group) {\n+    if (this.group == null) this.group = (Group) perunBean;\n+    else this.parentGroup = (Group) perunBean;\n+   } else if (perunBean instanceof Member) {\n+    if (this.member == null) this.member = (Member) perunBean;\n+    else throw new InternalErrorException(\"More than one member come to method parseMessages!\");\n+   } else if (perunBean instanceof Vo) {\n+           if (this.vo == null) this.vo = (Vo) perunBean;\n+           else throw new InternalErrorException(\"More than one vo come to method parserMessages!\");\n+          } else if (perunBean instanceof User) {\n+           User u = (User) perunBean;\n+           if (u.isServiceUser() || u.isSponsoredUser()) {\n+            if (this.specificUser == null) this.specificUser = u;\n+            else throw new InternalErrorException(\"More than one specificUser come to method parseMessages!\");\n+           } else {\n+            if (this.user == null) this.user = u;\n+            else throw new InternalErrorException(\"More than one user come to method parseMessages!\");\n+           }\n+          } else if (perunBean instanceof AttributeDefinition && perunBean instanceof cz.metacentrum.perun.core.api.Attribute) {\n+                  if (this.attribute == null) this.attribute = (cz.metacentrum.perun.core.api.Attribute) perunBean;\n+                  else throw new InternalErrorException(\"More than one attribute come to method parseMessages!\");\n+                 } else if (perunBean instanceof AttributeDefinition) {\n+                  if (this.attributeDef == null) this.attributeDef = (AttributeDefinition) perunBean;\n+                  else throw new InternalErrorException(\"More than one attribute come to method parseMessages!\");\n+                 } else if (perunBean instanceof UserExtSource) {\n+                         if (this.userExtSource == null) this.userExtSource = (UserExtSource) perunBean;\n+                         else throw new InternalErrorException(\"More than one userExtSource come to method parseMessages!\");\n+                        } else if (perunBean instanceof Resource) {\n+                         if (this.resource == null) this.resource = (Resource) perunBean;\n+                         else throw new InternalErrorException(\"More than one Resource come to method parseMessages!\");\n+                        } else if (perunBean instanceof Facility) {\n+                                if (this.facility == null) this.facility = (Facility) perunBean;\n+                                else throw new InternalErrorException(\"More than one Facility come to method parseMessages!\");\n+                               }\n+  }\n+ }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 1490
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/198/EventProcessorImpl.java\nindex a11ed424452..8b682c3827e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/198/EventProcessorImpl.java\n@@ -854,7 +854,7 @@ public class EventProcessorImpl implements EventProcessor, Runnable {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t  // 14) IN OTHER CASES\n+\t\t// 14) IN OTHER CASES\n \t\t} else {\n \t\t\tlog.debug(\"Nothing to resolve for message with number : \" + idOfMessage);\n \t\t}\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/198/EventProcessorImpl.java\nindex a11ed424452..ca309681433 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/198/EventProcessorImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/198/EventProcessorImpl.java\n@@ -854,8 +854,8 @@ public class EventProcessorImpl implements EventProcessor, Runnable {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t  // 14) IN OTHER CASES\n-\t\t} else {\n+\t\t\t// 14) IN OTHER CASES\n+\t\t\t} else {\n \t\t\tlog.debug(\"Nothing to resolve for message with number : \" + idOfMessage);\n \t\t}\n \t}\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}