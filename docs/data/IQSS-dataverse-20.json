{
    "project_name": "IQSS-dataverse",
    "error_id": "20",
    "information": {
        "errors": [
            {
                "line": "360",
                "column": "5",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "\n    public void downloadCitationXML(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n    \tDataCitation citation=null;\n        if (dataset != null){\n        \tcitation = new DataCitation(dataset.getLatestVersion());\n        } else {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "362",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/20/FileDownloadServiceBean.java\nindex 7fa1b5c4846..5b5cda2ffb4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/20/FileDownloadServiceBean.java\n@@ -357,7 +357,7 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n     }\n \n     public void downloadCitationXML(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n-    \tDataCitation citation=null;\n+    DataCitation citation=null;\n         if (dataset != null){\n         \tcitation = new DataCitation(dataset.getLatestVersion());\n         } else {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/20/FileDownloadServiceBean.java\nindex 7fa1b5c4846..97a27d5f213 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/20/FileDownloadServiceBean.java\n@@ -43,7 +43,6 @@ import org.primefaces.PrimeFaces;\n //import org.primefaces.context.RequestContext;\n \n /**\n- *\n  * @author skraffmi\n  * Handles All File Download processes\n  * including Guestbook responses\n@@ -52,523 +51,545 @@ import org.primefaces.PrimeFaces;\n @Named\n public class FileDownloadServiceBean implements java.io.Serializable {\n \n-    @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n-    private EntityManager em;\n-    \n-    @EJB\n-    GuestbookResponseServiceBean guestbookResponseService;\n-    @EJB\n-    DatasetServiceBean datasetService;\n-    @EJB\n-    DatasetVersionServiceBean datasetVersionService;\n-    @EJB\n-    DataFileServiceBean datafileService;\n-    @EJB\n-    PermissionServiceBean permissionService;\n-    @EJB\n-    DataverseServiceBean dataverseService;\n-    @EJB\n-    UserNotificationServiceBean userNotificationService;\n-    @EJB\n-    AuthenticationServiceBean authService;\n-    @EJB\n-    PrivateUrlServiceBean privateUrlService;\n-    @EJB\n-    SettingsServiceBean settingsService;\n-\n-    @Inject\n-    DataverseSession session;\n-    \n-    @EJB\n-    EjbDataverseEngine commandEngine;\n-    \n-    @Inject\n-    DataverseRequestServiceBean dvRequestService;\n-    \n-    @Inject FileDownloadHelper fileDownloadHelper;\n-    @Inject\n-    MakeDataCountLoggingServiceBean mdcLogService;\n-\n-    private static final Logger logger = Logger.getLogger(FileDownloadServiceBean.class.getCanonicalName());   \n-    \n-    public void writeGuestbookAndStartBatchDownload(GuestbookResponse guestbookResponse){ \n-        writeGuestbookAndStartBatchDownload(guestbookResponse, false);\n+  @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n+  private EntityManager em;\n+\n+  @EJB\n+  GuestbookResponseServiceBean guestbookResponseService;\n+  @EJB\n+  DatasetServiceBean datasetService;\n+  @EJB\n+  DatasetVersionServiceBean datasetVersionService;\n+  @EJB\n+  DataFileServiceBean datafileService;\n+  @EJB\n+  PermissionServiceBean permissionService;\n+  @EJB\n+  DataverseServiceBean dataverseService;\n+  @EJB\n+  UserNotificationServiceBean userNotificationService;\n+  @EJB\n+  AuthenticationServiceBean authService;\n+  @EJB\n+  PrivateUrlServiceBean privateUrlService;\n+  @EJB\n+  SettingsServiceBean settingsService;\n+\n+  @Inject\n+  DataverseSession session;\n+\n+  @EJB\n+  EjbDataverseEngine commandEngine;\n+\n+  @Inject\n+  DataverseRequestServiceBean dvRequestService;\n+\n+  @Inject\n+  FileDownloadHelper fileDownloadHelper;\n+  @Inject\n+  MakeDataCountLoggingServiceBean mdcLogService;\n+\n+  private static final Logger logger = Logger.getLogger(FileDownloadServiceBean.class.getCanonicalName());\n+\n+  public void writeGuestbookAndStartBatchDownload(GuestbookResponse guestbookResponse) {\n+    writeGuestbookAndStartBatchDownload(guestbookResponse, false);\n+  }\n+\n+  public void writeGuestbookAndStartBatchDownload(GuestbookResponse guestbookResponse,\n+                                                  Boolean doNotSaveGuestbookRecord) {\n+\n+    if (guestbookResponse == null || guestbookResponse.getSelectedFileIds() == null) {\n+      return;\n     }\n-    \n-    public void writeGuestbookAndStartBatchDownload(GuestbookResponse guestbookResponse, Boolean doNotSaveGuestbookRecord){\n \n-        if (guestbookResponse == null || guestbookResponse.getSelectedFileIds() == null) {\n-            return;\n-        }\n-        \n-        boolean original = \"original\".equals(guestbookResponse.getFileFormat());\n-\n-        // Let's intercept the case where a multiple download method was called, \n-        // with only 1 file on the list. We'll treat it like a single file download \n-        // instead:\n-        String[] fileIds = guestbookResponse.getSelectedFileIds().split(\",\");\n-        if (fileIds.length == 1) {\n-            Long fileId;\n-            try {\n-                fileId = Long.parseLong(fileIds[0]);\n-            } catch (NumberFormatException nfe) {\n-                logger.warning(\"A file id passed to the writeGuestbookAndStartBatchDownload method as a string could not be converted back to Long: \" + fileIds[0]);\n-                return;\n-            }\n-            // If we need to create a GuestBookResponse record, we have to \n-            // look up the DataFile object for this file: \n-            if (!doNotSaveGuestbookRecord) {\n-                DataFile df = datafileService.findCheapAndEasy(Long.parseLong(fileIds[0]));\n-                guestbookResponse.setDataFile(df);\n-                writeGuestbookResponseRecord(guestbookResponse);\n-            }\n-        \n-            redirectToDownloadAPI(guestbookResponse.getFileFormat(), fileId, true, null);\n-            return;\n-        }\n-        \n-        // OK, this is a real batch (multi-file) download. \n-        \n-        String customZipDownloadUrl = settingsService.getValueForKey(SettingsServiceBean.Key.CustomZipDownloadServiceUrl);\n-        boolean useCustomZipService = customZipDownloadUrl != null; \n-        String zipServiceKey = null; \n-\n-        // Do we need to write GuestbookRecord entries for the files? \n-        if (!doNotSaveGuestbookRecord || useCustomZipService) {\n-\n-            List<String> list = new ArrayList<>(Arrays.asList(guestbookResponse.getSelectedFileIds().split(\",\")));\n-            Timestamp timestamp = null; \n-            \n-            for (String idAsString : list) {\n-                //DataFile df = datafileService.findCheapAndEasy(new Long(idAsString));\n-                DataFile df = datafileService.find(new Long(idAsString));\n-                if (df != null) {\n-                    if (!doNotSaveGuestbookRecord) {\n-                        guestbookResponse.setDataFile(df);\n-                        writeGuestbookResponseRecord(guestbookResponse);\n-                    }\n-                    \n-                    if (useCustomZipService) {\n-                        if (zipServiceKey == null) {\n-                            zipServiceKey = generateServiceKey();\n-                        }\n-                        if (timestamp == null) {\n-                            timestamp = new Timestamp(new Date().getTime());\n-                        }\n-                        \n-                        addFileToCustomZipJob(zipServiceKey, df, timestamp, original);\n-                    }\n-                }\n-            }\n-        }\n-        \n-        if (useCustomZipService) {\n-            redirectToCustomZipDownloadService(customZipDownloadUrl, zipServiceKey);\n-        } else {\n-            // Use the \"normal\" /api/access/datafiles/ API:\n-            redirectToBatchDownloadAPI(guestbookResponse.getSelectedFileIds(),original);\n-        }\n-    }\n-    \n-    public void writeGuestbookAndStartFileDownload(GuestbookResponse guestbookResponse, FileMetadata fileMetadata, String format) {\n-        if(!fileMetadata.getDatasetVersion().isDraft()){\n-            guestbookResponse = guestbookResponseService.modifyDatafileAndFormat(guestbookResponse, fileMetadata, format);\n-            writeGuestbookResponseRecord(guestbookResponse);\n-        }\n-        \n-        // Make sure to set the \"do not write Guestbook response\" flag to TRUE when calling the Access API:\n-        redirectToDownloadAPI(format, fileMetadata.getDataFile().getId(), true, fileMetadata.getId());\n-        logger.fine(\"issued file download redirect for filemetadata \"+fileMetadata.getId()+\", datafile \"+fileMetadata.getDataFile().getId());\n-    }\n-    \n-    public void writeGuestbookAndStartFileDownload(GuestbookResponse guestbookResponse) {\n-        if (guestbookResponse.getDataFile() == null) {\n-            logger.warning(\"writeGuestbookAndStartFileDownload(GuestbookResponse) called without the DataFile in the GuestbookResponse.\");\n-            return;\n-        }\n+    boolean original = \"original\".equals(guestbookResponse.getFileFormat());\n+\n+    // Let's intercept the case where a multiple download method was called,\n+    // with only 1 file on the list. We'll treat it like a single file download\n+    // instead:\n+    String[] fileIds = guestbookResponse.getSelectedFileIds().split(\",\");\n+    if (fileIds.length == 1) {\n+      Long fileId;\n+      try {\n+        fileId = Long.parseLong(fileIds[0]);\n+      } catch (NumberFormatException nfe) {\n+        logger.warning(\n+          \"A file id passed to the writeGuestbookAndStartBatchDownload method as a string could not be converted back to Long: \" +\n+            fileIds[0]);\n+        return;\n+      }\n+      // If we need to create a GuestBookResponse record, we have to\n+      // look up the DataFile object for this file:\n+      if (!doNotSaveGuestbookRecord) {\n+        DataFile df = datafileService.findCheapAndEasy(Long.parseLong(fileIds[0]));\n+        guestbookResponse.setDataFile(df);\n         writeGuestbookResponseRecord(guestbookResponse);\n-        \n-        redirectToDownloadAPI(guestbookResponse.getFileFormat(), guestbookResponse.getDataFile().getId());\n-        logger.fine(\"issued file download redirect for datafile \"+guestbookResponse.getDataFile().getId());\n+      }\n+\n+      redirectToDownloadAPI(guestbookResponse.getFileFormat(), fileId, true, null);\n+      return;\n     }\n \n-    public void writeGuestbookResponseRecord(GuestbookResponse guestbookResponse, FileMetadata fileMetadata, String format) {\n-        if(!fileMetadata.getDatasetVersion().isDraft()){           \n-            guestbookResponse = guestbookResponseService.modifyDatafileAndFormat(guestbookResponse, fileMetadata, format);\n+    // OK, this is a real batch (multi-file) download.\n+\n+    String customZipDownloadUrl = settingsService.getValueForKey(SettingsServiceBean.Key.CustomZipDownloadServiceUrl);\n+    boolean useCustomZipService = customZipDownloadUrl != null;\n+    String zipServiceKey = null;\n+\n+    // Do we need to write GuestbookRecord entries for the files?\n+    if (!doNotSaveGuestbookRecord || useCustomZipService) {\n+\n+      List<String> list = new ArrayList<>(Arrays.asList(guestbookResponse.getSelectedFileIds().split(\",\")));\n+      Timestamp timestamp = null;\n+\n+      for (String idAsString : list) {\n+        //DataFile df = datafileService.findCheapAndEasy(new Long(idAsString));\n+        DataFile df = datafileService.find(new Long(idAsString));\n+        if (df != null) {\n+          if (!doNotSaveGuestbookRecord) {\n+            guestbookResponse.setDataFile(df);\n             writeGuestbookResponseRecord(guestbookResponse);\n-        }\n-    }\n-    \n-    public void writeGuestbookResponseRecord(GuestbookResponse guestbookResponse) {\n-        try {\n-            CreateGuestbookResponseCommand cmd = new CreateGuestbookResponseCommand(dvRequestService.getDataverseRequest(), guestbookResponse, guestbookResponse.getDataset());\n-            commandEngine.submit(cmd);\n-            DatasetVersion version = guestbookResponse.getDatasetVersion();\n-            \n-            //Sometimes guestbookResponse doesn't have a version, so we grab the released version\n-            if (null == version) {\n-                version = guestbookResponse.getDataset().getReleasedVersion();\n+          }\n+\n+          if (useCustomZipService) {\n+            if (zipServiceKey == null) {\n+              zipServiceKey = generateServiceKey();\n             }\n-            MakeDataCountEntry entry = new MakeDataCountEntry(FacesContext.getCurrentInstance(), dvRequestService, version, guestbookResponse.getDataFile());\n-            //As the api download url is not available at this point we construct it manually\n-            entry.setTargetUrl(\"/api/access/datafile/\" + guestbookResponse.getDataFile().getId());\n-            entry.setRequestUrl(\"/api/access/datafile/\" + guestbookResponse.getDataFile().getId());\n-            mdcLogService.logEntry(entry);\n-        } catch (CommandException e) {\n-            //if an error occurs here then download won't happen no need for response recs...\n-            logger.warning(\"Exception writing GuestbookResponse for file: \" + guestbookResponse.getDataFile().getId() + \" : \" + e.getLocalizedMessage());\n+            if (timestamp == null) {\n+              timestamp = new Timestamp(new Date().getTime());\n+            }\n+\n+            addFileToCustomZipJob(zipServiceKey, df, timestamp, original);\n+          }\n         }\n+      }\n     }\n-    \n-    // The \"guestBookRecord(s)AlreadyWritten\" parameter in the 2 methods \n-    // below (redirectToBatchDownloadAPI() and redirectToDownloadAPI(), for the \n-    // multiple- and single-file downloads respectively) are passed to the \n-    // Download API, where it is treated as a \"SKIP writing the GuestbookResponse \n-    // record for this download on the API side\" flag. In other words, we want \n-    // to create and save this record *either* on the UI, or the API side - but \n-    // not both. \n-    // As of now (Aug. 2018) we always set this flag to true when redirecting the \n-    // user to the Access API. That's because we have either just created the \n-    // record ourselves, on the UI side; or we have skipped creating one, \n-    // because this was a draft file and we don't want to count the download. \n-    // But either way, it is NEVER the API side's job to count the download that \n-    // was initiated in the GUI. \n-    // But note that this may change - there may be some future situations where it will \n-    // become necessary again, to pass the job of creating the access record \n-    // to the API.\n-    private void redirectToBatchDownloadAPI(String multiFileString, Boolean guestbookRecordsAlreadyWritten, Boolean downloadOriginal){\n-\n-        String fileDownloadUrl = \"/api/access/datafiles\";\n-        if (guestbookRecordsAlreadyWritten && !downloadOriginal){\n-            fileDownloadUrl += \"?gbrecs=true\";\n-        } else if (guestbookRecordsAlreadyWritten && downloadOriginal){\n-            fileDownloadUrl += \"?gbrecs=true&format=original\";\n-        } else if (!guestbookRecordsAlreadyWritten && downloadOriginal){\n-            fileDownloadUrl += \"?format=original\";\n-        }\n-        \n-        PrimeFaces.current().executeScript(\"downloadFiles('\"+fileDownloadUrl + \"','\"+ multiFileString+\"');\");\n \n+    if (useCustomZipService) {\n+      redirectToCustomZipDownloadService(customZipDownloadUrl, zipServiceKey);\n+    } else {\n+      // Use the \"normal\" /api/access/datafiles/ API:\n+      redirectToBatchDownloadAPI(guestbookResponse.getSelectedFileIds(), original);\n     }\n-    \n-    private void redirectToCustomZipDownloadService(String customZipServiceUrl, String jobKey) {\n-        \n-        customZipServiceUrl += \"?\" + jobKey; \n-        \n-        try {\n-            FacesContext.getCurrentInstance().getExternalContext().redirect(customZipServiceUrl);\n-        } catch (IOException ex) {\n-            logger.info(\"Failed to issue a redirect to the custom Zip download service.\");\n-        }\n+  }\n+\n+  public void writeGuestbookAndStartFileDownload(GuestbookResponse guestbookResponse, FileMetadata fileMetadata,\n+                                                 String format) {\n+    if (!fileMetadata.getDatasetVersion().isDraft()) {\n+      guestbookResponse = guestbookResponseService.modifyDatafileAndFormat(guestbookResponse, fileMetadata, format);\n+      writeGuestbookResponseRecord(guestbookResponse);\n     }\n \n-    private void redirectToDownloadAPI(String downloadType, Long fileId, boolean guestBookRecordAlreadyWritten, Long fileMetadataId) {\n-        String fileDownloadUrl = FileUtil.getFileDownloadUrlPath(downloadType, fileId, guestBookRecordAlreadyWritten, fileMetadataId);\n-        logger.fine(\"Redirecting to file download url: \" + fileDownloadUrl);\n-        try {\n-            FacesContext.getCurrentInstance().getExternalContext().redirect(fileDownloadUrl);\n-        } catch (IOException ex) {\n-            logger.info(\"Failed to issue a redirect to file download url (\" + fileDownloadUrl + \"): \" + ex);\n-        }\n+    // Make sure to set the \"do not write Guestbook response\" flag to TRUE when calling the Access API:\n+    redirectToDownloadAPI(format, fileMetadata.getDataFile().getId(), true, fileMetadata.getId());\n+    logger.fine(\"issued file download redirect for filemetadata \" + fileMetadata.getId() + \", datafile \" +\n+      fileMetadata.getDataFile().getId());\n+  }\n+\n+  public void writeGuestbookAndStartFileDownload(GuestbookResponse guestbookResponse) {\n+    if (guestbookResponse.getDataFile() == null) {\n+      logger.warning(\n+        \"writeGuestbookAndStartFileDownload(GuestbookResponse) called without the DataFile in the GuestbookResponse.\");\n+      return;\n     }\n-    \n-    private void redirectToDownloadAPI(String downloadType, Long fileId) {\n-        redirectToDownloadAPI(downloadType, fileId, true, null);\n+    writeGuestbookResponseRecord(guestbookResponse);\n+\n+    redirectToDownloadAPI(guestbookResponse.getFileFormat(), guestbookResponse.getDataFile().getId());\n+    logger.fine(\"issued file download redirect for datafile \" + guestbookResponse.getDataFile().getId());\n+  }\n+\n+  public void writeGuestbookResponseRecord(GuestbookResponse guestbookResponse, FileMetadata fileMetadata,\n+                                           String format) {\n+    if (!fileMetadata.getDatasetVersion().isDraft()) {\n+      guestbookResponse = guestbookResponseService.modifyDatafileAndFormat(guestbookResponse, fileMetadata, format);\n+      writeGuestbookResponseRecord(guestbookResponse);\n     }\n-    \n-    private void redirectToBatchDownloadAPI(String multiFileString, Boolean downloadOriginal){\n-        redirectToBatchDownloadAPI(multiFileString, true, downloadOriginal);\n+  }\n+\n+  public void writeGuestbookResponseRecord(GuestbookResponse guestbookResponse) {\n+    try {\n+      CreateGuestbookResponseCommand cmd =\n+        new CreateGuestbookResponseCommand(dvRequestService.getDataverseRequest(), guestbookResponse,\n+          guestbookResponse.getDataset());\n+      commandEngine.submit(cmd);\n+      DatasetVersion version = guestbookResponse.getDatasetVersion();\n+\n+      //Sometimes guestbookResponse doesn't have a version, so we grab the released version\n+      if (null == version) {\n+        version = guestbookResponse.getDataset().getReleasedVersion();\n+      }\n+      MakeDataCountEntry entry = new MakeDataCountEntry(FacesContext.getCurrentInstance(), dvRequestService, version,\n+        guestbookResponse.getDataFile());\n+      //As the api download url is not available at this point we construct it manually\n+      entry.setTargetUrl(\"/api/access/datafile/\" + guestbookResponse.getDataFile().getId());\n+      entry.setRequestUrl(\"/api/access/datafile/\" + guestbookResponse.getDataFile().getId());\n+      mdcLogService.logEntry(entry);\n+    } catch (CommandException e) {\n+      //if an error occurs here then download won't happen no need for response recs...\n+      logger.warning(\n+        \"Exception writing GuestbookResponse for file: \" + guestbookResponse.getDataFile().getId() + \" : \" +\n+          e.getLocalizedMessage());\n+    }\n+  }\n+\n+  // The \"guestBookRecord(s)AlreadyWritten\" parameter in the 2 methods\n+  // below (redirectToBatchDownloadAPI() and redirectToDownloadAPI(), for the\n+  // multiple- and single-file downloads respectively) are passed to the\n+  // Download API, where it is treated as a \"SKIP writing the GuestbookResponse\n+  // record for this download on the API side\" flag. In other words, we want\n+  // to create and save this record *either* on the UI, or the API side - but\n+  // not both.\n+  // As of now (Aug. 2018) we always set this flag to true when redirecting the\n+  // user to the Access API. That's because we have either just created the\n+  // record ourselves, on the UI side; or we have skipped creating one,\n+  // because this was a draft file and we don't want to count the download.\n+  // But either way, it is NEVER the API side's job to count the download that\n+  // was initiated in the GUI.\n+  // But note that this may change - there may be some future situations where it will\n+  // become necessary again, to pass the job of creating the access record\n+  // to the API.\n+  private void redirectToBatchDownloadAPI(String multiFileString, Boolean guestbookRecordsAlreadyWritten,\n+                                          Boolean downloadOriginal) {\n+\n+    String fileDownloadUrl = \"/api/access/datafiles\";\n+    if (guestbookRecordsAlreadyWritten && !downloadOriginal) {\n+      fileDownloadUrl += \"?gbrecs=true\";\n+    } else if (guestbookRecordsAlreadyWritten && downloadOriginal) {\n+      fileDownloadUrl += \"?gbrecs=true&format=original\";\n+    } else if (!guestbookRecordsAlreadyWritten && downloadOriginal) {\n+      fileDownloadUrl += \"?format=original\";\n     }\n \n-    public void redirectToAuxFileDownloadAPI(Long fileId, String formatTag, String formatVersion) {\n-        String fileDownloadUrl = \"/api/access/datafile/\" + fileId + \"/auxiliary/\" + formatTag + \"/\" + formatVersion;\n-        try {\n-            FacesContext.getCurrentInstance().getExternalContext().redirect(fileDownloadUrl);\n-        } catch (IOException ex) {\n-            logger.info(\"Failed to issue a redirect to aux file download url (\" + fileDownloadUrl + \"): \" + ex);\n-        }\n+    PrimeFaces.current().executeScript(\"downloadFiles('\" + fileDownloadUrl + \"','\" + multiFileString + \"');\");\n+\n+  }\n+\n+  private void redirectToCustomZipDownloadService(String customZipServiceUrl, String jobKey) {\n+\n+    customZipServiceUrl += \"?\" + jobKey;\n+\n+    try {\n+      FacesContext.getCurrentInstance().getExternalContext().redirect(customZipServiceUrl);\n+    } catch (IOException ex) {\n+      logger.info(\"Failed to issue a redirect to the custom Zip download service.\");\n     }\n-    \n-    /**\n-     * Launch an \"explore\" tool which is a type of ExternalTool such as\n-     * TwoRavens or Data Explorer. This method may be invoked directly from the\n-     * xhtml if no popup is required (no terms of use, no guestbook, etc.).\n-     */\n-    public void explore(GuestbookResponse guestbookResponse, FileMetadata fmd, ExternalTool externalTool) {\n-        ApiToken apiToken = null;\n-        User user = session.getUser();\n-        DatasetVersion version = fmd.getDatasetVersion();\n-        if (version.isDraft() || (fmd.getDataFile().isRestricted())) {\n-            if (user instanceof AuthenticatedUser) {\n-                AuthenticatedUser authenticatedUser = (AuthenticatedUser) user;\n-                apiToken = authService.findApiTokenByUser(authenticatedUser);\n-                if (apiToken == null) {\n-                    //No un-expired token\n-                    apiToken = authService.generateApiTokenForUser(authenticatedUser);\n-                }\n-            } else if (user instanceof PrivateUrlUser) {\n-                PrivateUrlUser privateUrlUser = (PrivateUrlUser) user;\n-                PrivateUrl privateUrl = privateUrlService.getPrivateUrlFromDatasetId(privateUrlUser.getDatasetId());\n-                apiToken = new ApiToken();\n-                apiToken.setTokenString(privateUrl.getToken());\n-            }\n-        }\n-        DataFile dataFile = null;\n-        if (fmd != null) {\n-            dataFile = fmd.getDataFile();\n-        } else {\n-            if (guestbookResponse != null) {\n-                dataFile = guestbookResponse.getDataFile();\n-            }\n-        }\n-        String localeCode = session.getLocaleCode();\n-        ExternalToolHandler externalToolHandler = new ExternalToolHandler(externalTool, dataFile, apiToken, fmd, localeCode);\n-        // Back when we only had TwoRavens, the downloadType was always \"Explore\". Now we persist the name of the tool (i.e. \"TwoRavens\", \"Data Explorer\", etc.)\n-        guestbookResponse.setDownloadtype(externalTool.getDisplayName());\n-        String toolUrl = externalToolHandler.getToolUrlWithQueryParams();\n-        logger.fine(\"Exploring with \" + toolUrl);\n-        PrimeFaces.current().executeScript(\"window.open('\"+toolUrl + \"', target='_blank');\");\n-        // This is the old logic from TwoRavens, null checks and all.\n-        if (guestbookResponse != null && guestbookResponse.isWriteResponse()\n-                && ((fmd != null && fmd.getDataFile() != null) || guestbookResponse.getDataFile() != null)) {\n-            if (guestbookResponse.getDataFile() == null && fmd != null) {\n-                guestbookResponse.setDataFile(fmd.getDataFile());\n-            }\n-            if (fmd == null || !fmd.getDatasetVersion().isDraft()) {\n-                writeGuestbookResponseRecord(guestbookResponse);\n-            }\n+  }\n+\n+  private void redirectToDownloadAPI(String downloadType, Long fileId, boolean guestBookRecordAlreadyWritten,\n+                                     Long fileMetadataId) {\n+    String fileDownloadUrl =\n+      FileUtil.getFileDownloadUrlPath(downloadType, fileId, guestBookRecordAlreadyWritten, fileMetadataId);\n+    logger.fine(\"Redirecting to file download url: \" + fileDownloadUrl);\n+    try {\n+      FacesContext.getCurrentInstance().getExternalContext().redirect(fileDownloadUrl);\n+    } catch (IOException ex) {\n+      logger.info(\"Failed to issue a redirect to file download url (\" + fileDownloadUrl + \"): \" + ex);\n+    }\n+  }\n+\n+  private void redirectToDownloadAPI(String downloadType, Long fileId) {\n+    redirectToDownloadAPI(downloadType, fileId, true, null);\n+  }\n+\n+  private void redirectToBatchDownloadAPI(String multiFileString, Boolean downloadOriginal) {\n+    redirectToBatchDownloadAPI(multiFileString, true, downloadOriginal);\n+  }\n+\n+  public void redirectToAuxFileDownloadAPI(Long fileId, String formatTag, String formatVersion) {\n+    String fileDownloadUrl = \"/api/access/datafile/\" + fileId + \"/auxiliary/\" + formatTag + \"/\" + formatVersion;\n+    try {\n+      FacesContext.getCurrentInstance().getExternalContext().redirect(fileDownloadUrl);\n+    } catch (IOException ex) {\n+      logger.info(\"Failed to issue a redirect to aux file download url (\" + fileDownloadUrl + \"): \" + ex);\n+    }\n+  }\n+\n+  /**\n+   * Launch an \"explore\" tool which is a type of ExternalTool such as\n+   * TwoRavens or Data Explorer. This method may be invoked directly from the\n+   * xhtml if no popup is required (no terms of use, no guestbook, etc.).\n+   */\n+  public void explore(GuestbookResponse guestbookResponse, FileMetadata fmd, ExternalTool externalTool) {\n+    ApiToken apiToken = null;\n+    User user = session.getUser();\n+    DatasetVersion version = fmd.getDatasetVersion();\n+    if (version.isDraft() || (fmd.getDataFile().isRestricted())) {\n+      if (user instanceof AuthenticatedUser) {\n+        AuthenticatedUser authenticatedUser = (AuthenticatedUser) user;\n+        apiToken = authService.findApiTokenByUser(authenticatedUser);\n+        if (apiToken == null) {\n+          //No un-expired token\n+          apiToken = authService.generateApiTokenForUser(authenticatedUser);\n         }\n+      } else if (user instanceof PrivateUrlUser) {\n+        PrivateUrlUser privateUrlUser = (PrivateUrlUser) user;\n+        PrivateUrl privateUrl = privateUrlService.getPrivateUrlFromDatasetId(privateUrlUser.getDatasetId());\n+        apiToken = new ApiToken();\n+        apiToken.setTokenString(privateUrl.getToken());\n+      }\n     }\n-\n-    public Boolean canSeeTwoRavensExploreButton(){\n-        return false;\n+    DataFile dataFile = null;\n+    if (fmd != null) {\n+      dataFile = fmd.getDataFile();\n+    } else {\n+      if (guestbookResponse != null) {\n+        dataFile = guestbookResponse.getDataFile();\n+      }\n     }\n-\n-    public void downloadDatasetCitationXML(Dataset dataset) {\n-        downloadCitationXML(null, dataset, false);\n+    String localeCode = session.getLocaleCode();\n+    ExternalToolHandler externalToolHandler =\n+      new ExternalToolHandler(externalTool, dataFile, apiToken, fmd, localeCode);\n+    // Back when we only had TwoRavens, the downloadType was always \"Explore\". Now we persist the name of the tool (i.e. \"TwoRavens\", \"Data Explorer\", etc.)\n+    guestbookResponse.setDownloadtype(externalTool.getDisplayName());\n+    String toolUrl = externalToolHandler.getToolUrlWithQueryParams();\n+    logger.fine(\"Exploring with \" + toolUrl);\n+    PrimeFaces.current().executeScript(\"window.open('\" + toolUrl + \"', target='_blank');\");\n+    // This is the old logic from TwoRavens, null checks and all.\n+    if (guestbookResponse != null && guestbookResponse.isWriteResponse()\n+      && ((fmd != null && fmd.getDataFile() != null) || guestbookResponse.getDataFile() != null)) {\n+      if (guestbookResponse.getDataFile() == null && fmd != null) {\n+        guestbookResponse.setDataFile(fmd.getDataFile());\n+      }\n+      if (fmd == null || !fmd.getDatasetVersion().isDraft()) {\n+        writeGuestbookResponseRecord(guestbookResponse);\n+      }\n     }\n-\n-    public void downloadDatafileCitationXML(FileMetadata fileMetadata) {\n-        downloadCitationXML(fileMetadata, null, false);\n+  }\n+\n+  public Boolean canSeeTwoRavensExploreButton() {\n+    return false;\n+  }\n+\n+  public void downloadDatasetCitationXML(Dataset dataset) {\n+    downloadCitationXML(null, dataset, false);\n+  }\n+\n+  public void downloadDatafileCitationXML(FileMetadata fileMetadata) {\n+    downloadCitationXML(fileMetadata, null, false);\n+  }\n+\n+  public void downloadDirectDatafileCitationXML(FileMetadata fileMetadata) {\n+    downloadCitationXML(fileMetadata, null, true);\n+  }\n+\n+  public void downloadCitationXML(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n+    DataCitation citation = null;\n+    if (dataset != null) {\n+      citation = new DataCitation(dataset.getLatestVersion());\n+    } else {\n+      citation = new DataCitation(fileMetadata, direct);\n     }\n-    \n-    public void downloadDirectDatafileCitationXML(FileMetadata fileMetadata) {\n-        downloadCitationXML(fileMetadata, null, true);\n+    FacesContext ctx = FacesContext.getCurrentInstance();\n+    HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n+    response.setContentType(\"text/xml\");\n+    String fileNameString;\n+    if (fileMetadata == null || fileMetadata.getLabel() == null) {\n+      // Dataset-level citation:\n+      fileNameString = \"attachment;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \".xml\";\n+    } else {\n+      // Datafile-level citation:\n+      fileNameString = \"attachment;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \"-\" +\n+        FileUtil.getCiteDataFileFilename(citation.getFileTitle(), FileUtil.FileCitationExtension.ENDNOTE);\n     }\n+    response.setHeader(\"Content-Disposition\", fileNameString);\n+    try {\n+      ServletOutputStream out = response.getOutputStream();\n+      citation.writeAsEndNoteCitation(out);\n+      out.flush();\n+      ctx.responseComplete();\n+    } catch (IOException e) {\n \n-    public void downloadCitationXML(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n-    \tDataCitation citation=null;\n-        if (dataset != null){\n-        \tcitation = new DataCitation(dataset.getLatestVersion());\n-        } else {\n-            citation= new DataCitation(fileMetadata, direct);\n-        }\n-        FacesContext ctx = FacesContext.getCurrentInstance();\n-        HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n-        response.setContentType(\"text/xml\");\n-        String fileNameString;\n-        if (fileMetadata == null || fileMetadata.getLabel() == null) {\n-            // Dataset-level citation: \n-            fileNameString = \"attachment;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \".xml\";\n-        } else {\n-            // Datafile-level citation:\n-            fileNameString = \"attachment;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \"-\" + FileUtil.getCiteDataFileFilename(citation.getFileTitle(), FileUtil.FileCitationExtension.ENDNOTE);\n-        }\n-        response.setHeader(\"Content-Disposition\", fileNameString);\n-        try {\n-            ServletOutputStream out = response.getOutputStream();\n-            citation.writeAsEndNoteCitation(out);\n-            out.flush();\n-            ctx.responseComplete();\n-        } catch (IOException e) {\n-\n-        }\n     }\n-    \n-    public void downloadDatasetCitationRIS(Dataset dataset) {\n+  }\n+\n+  public void downloadDatasetCitationRIS(Dataset dataset) {\n+\n+    downloadCitationRIS(null, dataset, false);\n+\n+  }\n \n-        downloadCitationRIS(null, dataset, false);\n+  public void downloadDatafileCitationRIS(FileMetadata fileMetadata) {\n+    downloadCitationRIS(fileMetadata, null, false);\n+  }\n \n+  public void downloadDirectDatafileCitationRIS(FileMetadata fileMetadata) {\n+    downloadCitationRIS(fileMetadata, null, true);\n+  }\n+\n+  public void downloadCitationRIS(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n+    DataCitation citation = null;\n+    if (dataset != null) {\n+      citation = new DataCitation(dataset.getLatestVersion());\n+    } else {\n+      citation = new DataCitation(fileMetadata, direct);\n     }\n \n-    public void downloadDatafileCitationRIS(FileMetadata fileMetadata) {\n-        downloadCitationRIS(fileMetadata, null, false);\n+    FacesContext ctx = FacesContext.getCurrentInstance();\n+    HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n+    response.setContentType(\"application/download\");\n+\n+    String fileNameString;\n+    if (fileMetadata == null || fileMetadata.getLabel() == null) {\n+      // Dataset-level citation:\n+      fileNameString = \"attachment;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \".ris\";\n+    } else {\n+      // Datafile-level citation:\n+      fileNameString = \"attachment;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \"-\" +\n+        FileUtil.getCiteDataFileFilename(citation.getFileTitle(), FileUtil.FileCitationExtension.RIS);\n     }\n-    \n-    public void downloadDirectDatafileCitationRIS(FileMetadata fileMetadata) {\n-        downloadCitationRIS(fileMetadata, null, true);\n+    response.setHeader(\"Content-Disposition\", fileNameString);\n+\n+    try {\n+      ServletOutputStream out = response.getOutputStream();\n+      citation.writeAsRISCitation(out);\n+      out.flush();\n+      ctx.responseComplete();\n+    } catch (IOException e) {\n+\n     }\n+  }\n \n-    public void downloadCitationRIS(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n-    \tDataCitation citation=null;\n-        if (dataset != null){\n-        \tcitation = new DataCitation(dataset.getLatestVersion());\n-        } else {\n-            citation= new DataCitation(fileMetadata, direct);\n-        }\n+  private String getFileNameFromPid(GlobalId id) {\n+    return id.asString();\n+  }\n \n-        FacesContext ctx = FacesContext.getCurrentInstance();\n-        HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n-        response.setContentType(\"application/download\");\n-\n-        String fileNameString;\n-        if (fileMetadata == null || fileMetadata.getLabel() == null) {\n-            // Dataset-level citation: \n-            fileNameString = \"attachment;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \".ris\";\n-        } else {\n-            // Datafile-level citation:\n-            fileNameString = \"attachment;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \"-\" + FileUtil.getCiteDataFileFilename(citation.getFileTitle(), FileUtil.FileCitationExtension.RIS);\n-        }\n-        response.setHeader(\"Content-Disposition\", fileNameString);\n+  public void downloadDatasetCitationBibtex(Dataset dataset) {\n \n-        try {\n-            ServletOutputStream out = response.getOutputStream();\n-            citation.writeAsRISCitation(out);\n-            out.flush();\n-            ctx.responseComplete();\n-        } catch (IOException e) {\n+    downloadCitationBibtex(null, dataset, false);\n \n-        }\n-    }\n-    \n-    private String getFileNameFromPid(GlobalId id) {\n-        return id.asString();\n-    }\n+  }\n \n-    public void downloadDatasetCitationBibtex(Dataset dataset) {\n+  public void downloadDatafileCitationBibtex(FileMetadata fileMetadata) {\n+    downloadCitationBibtex(fileMetadata, null, false);\n+  }\n \n-        downloadCitationBibtex(null, dataset, false);\n+  public void downloadDirectDatafileCitationBibtex(FileMetadata fileMetadata) {\n+    downloadCitationBibtex(fileMetadata, null, true);\n+  }\n \n+  public void downloadCitationBibtex(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n+    DataCitation citation = null;\n+    if (dataset != null) {\n+      citation = new DataCitation(dataset.getLatestVersion());\n+    } else {\n+      citation = new DataCitation(fileMetadata, direct);\n     }\n-\n-    public void downloadDatafileCitationBibtex(FileMetadata fileMetadata) {\n-        downloadCitationBibtex(fileMetadata, null, false);\n+    //SEK 12/3/2018 changing this to open the json in a new tab.\n+    FacesContext ctx = FacesContext.getCurrentInstance();\n+    HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n+\n+    //Fix for 6029 FireFox was failing to parse it when content type was set to json\n+    response.setContentType(\"text/plain\");\n+\n+    String fileNameString;\n+    if (fileMetadata == null || fileMetadata.getLabel() == null) {\n+      // Dataset-level citation:\n+      fileNameString = \"inline;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \".bib\";\n+    } else {\n+      // Datafile-level citation:\n+      fileNameString = \"inline;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \"-\" +\n+        FileUtil.getCiteDataFileFilename(citation.getFileTitle(), FileUtil.FileCitationExtension.BIBTEX);\n     }\n+    response.setHeader(\"Content-Disposition\", fileNameString);\n \n-    public void downloadDirectDatafileCitationBibtex(FileMetadata fileMetadata) {\n-        downloadCitationBibtex(fileMetadata, null, true);\n-    }\n-    \n-    public void downloadCitationBibtex(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n-    \tDataCitation citation=null;\n-        if (dataset != null){\n-        \tcitation = new DataCitation(dataset.getLatestVersion());\n-        } else {\n-            citation= new DataCitation(fileMetadata, direct);\n-        }\n-        //SEK 12/3/2018 changing this to open the json in a new tab. \n-        FacesContext ctx = FacesContext.getCurrentInstance();\n-        HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n-        \n-        //Fix for 6029 FireFox was failing to parse it when content type was set to json \n-        response.setContentType(\"text/plain\");\n-        \n-        String fileNameString;\n-        if (fileMetadata == null || fileMetadata.getLabel() == null) {\n-            // Dataset-level citation:\n-            fileNameString = \"inline;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \".bib\";\n-        } else {\n-            // Datafile-level citation:\n-            fileNameString = \"inline;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \"-\" + FileUtil.getCiteDataFileFilename(citation.getFileTitle(), FileUtil.FileCitationExtension.BIBTEX);\n-        }\n-        response.setHeader(\"Content-Disposition\", fileNameString);\n+    try {\n+      ServletOutputStream out = response.getOutputStream();\n+      citation.writeAsBibtexCitation(out);\n+      out.flush();\n+      ctx.responseComplete();\n+    } catch (IOException e) {\n \n-        try {\n-            ServletOutputStream out = response.getOutputStream();\n-            citation.writeAsBibtexCitation(out);\n-            out.flush();\n-            ctx.responseComplete();\n-        } catch (IOException e) {\n+    }\n+  }\n \n-        }\n+  public boolean requestAccess(Long fileId) {\n+    if (dvRequestService.getDataverseRequest().getAuthenticatedUser() == null) {\n+      return false;\n     }\n-    \n-    public boolean requestAccess(Long fileId) {   \n-        if (dvRequestService.getDataverseRequest().getAuthenticatedUser() == null){\n-            return false;\n-        }\n-        DataFile file = datafileService.find(fileId);\n-        if (!file.getFileAccessRequesters().contains((AuthenticatedUser)session.getUser())) {\n-            try {\n-                commandEngine.submit(new RequestAccessCommand(dvRequestService.getDataverseRequest(), file));                        \n-                return true;\n-            } catch (CommandException ex) {\n-                logger.info(\"Unable to request access for file id \" + fileId + \". Exception: \" + ex);\n-                return false;\n-            }             \n-        }        \n+    DataFile file = datafileService.find(fileId);\n+    if (!file.getFileAccessRequesters().contains((AuthenticatedUser) session.getUser())) {\n+      try {\n+        commandEngine.submit(new RequestAccessCommand(dvRequestService.getDataverseRequest(), file));\n+        return true;\n+      } catch (CommandException ex) {\n+        logger.info(\"Unable to request access for file id \" + fileId + \". Exception: \" + ex);\n         return false;\n-    }    \n-    \n-    public void sendRequestFileAccessNotification(Dataset dataset, Long fileId, AuthenticatedUser requestor) {\n-        permissionService.getUsersWithPermissionOn(Permission.ManageDatasetPermissions, dataset).stream().forEach((au) -> {\n-            userNotificationService.sendNotification(au, new Timestamp(new Date().getTime()), UserNotification.Type.REQUESTFILEACCESS, fileId, null, requestor, false);\n-        });\n-\n-    } \n-    \n-    public String generateServiceKey() {\n-        UUID uid = UUID.randomUUID();\n-        // last 8 bytes, of the random UUID, 16 hex digits: \n-        return uid.toString().substring(20);\n+      }\n     }\n-    \n-    public void addFileToCustomZipJob(String key, DataFile dataFile, Timestamp timestamp, boolean orig) {\n-        String location = null; \n-        String fileName = null; \n-        \n-        try {\n-            StorageIO<DataFile> storageIO = DataAccess.getStorageIO(dataFile);\n-            location = getDirectStorageLocatrion(storageIO.getStorageLocation());\n-\n-            if (orig && dataFile.isTabularData()) {\n-                location = location.concat(\".orig\");\n-            }\n-        } catch (IOException ioex) {\n-            logger.info(\"Failed to open StorageIO for datafile \" + dataFile.getId());\n-        }\n-        \n-        if (dataFile.getFileMetadata() != null) {\n-            if (orig && dataFile.isTabularData()) {\n-                fileName = dataFile.getOriginalFileName();\n-            } else {\n-                fileName = dataFile.getFileMetadata().getLabel();\n-            }\n-        }\n-        \n-        if (StringUtil.nonEmpty(dataFile.getFileMetadata().getDirectoryLabel())) {\n-            fileName = dataFile.getFileMetadata().getDirectoryLabel() + \"/\" + fileName;\n-        }\n-                \n-        if (location != null && fileName != null) {\n-            em.createNativeQuery(\"INSERT INTO CUSTOMZIPSERVICEREQUEST (KEY, STORAGELOCATION, FILENAME, ISSUETIME) VALUES (\"\n-                    + \"'\" + key + \"',\"\n-                    + \"'\" + location + \"',\"\n-                    + \"'\" + fileName + \"',\"\n-                    + \"'\" + timestamp + \"');\").executeUpdate();\n-        }\n-        \n-        // TODO:\n-        // While we are here, issue another query, to delete all the entries that are \n-        // more than N seconds old?\n-        Timestamp deleteTime = new Timestamp(new Date().getTime() - 300000L);\n-        em.createNativeQuery(\"DELETE FROM CUSTOMZIPSERVICEREQUEST WHERE ISSUETIME < \" \n-                + \"'\" + deleteTime + \"';\").executeUpdate();\n+    return false;\n+  }\n+\n+  public void sendRequestFileAccessNotification(Dataset dataset, Long fileId, AuthenticatedUser requestor) {\n+    permissionService.getUsersWithPermissionOn(Permission.ManageDatasetPermissions, dataset).stream().forEach((au) -> {\n+      userNotificationService\n+        .sendNotification(au, new Timestamp(new Date().getTime()), UserNotification.Type.REQUESTFILEACCESS, fileId,\n+          null, requestor, false);\n+    });\n+\n+  }\n+\n+  public String generateServiceKey() {\n+    UUID uid = UUID.randomUUID();\n+    // last 8 bytes, of the random UUID, 16 hex digits:\n+    return uid.toString().substring(20);\n+  }\n+\n+  public void addFileToCustomZipJob(String key, DataFile dataFile, Timestamp timestamp, boolean orig) {\n+    String location = null;\n+    String fileName = null;\n+\n+    try {\n+      StorageIO<DataFile> storageIO = DataAccess.getStorageIO(dataFile);\n+      location = getDirectStorageLocatrion(storageIO.getStorageLocation());\n+\n+      if (orig && dataFile.isTabularData()) {\n+        location = location.concat(\".orig\");\n+      }\n+    } catch (IOException ioex) {\n+      logger.info(\"Failed to open StorageIO for datafile \" + dataFile.getId());\n     }\n-    \n-    public String getDirectStorageLocatrion(String storageLocation) {\n-        String storageDriverId;\n-        int separatorIndex = storageLocation.indexOf(\"://\");\n-        if ( separatorIndex > 0 ) {\n-            storageDriverId = storageLocation.substring(0,separatorIndex);\n-        \n-            String storageType = DataAccess.getDriverType(storageDriverId);\n-            if (\"file\".equals(storageType) || \"s3\".equals(storageType)) {\n-                return storageType.concat(storageLocation.substring(separatorIndex));\n-            }\n-        }\n-            \n-        return null; \n+\n+    if (dataFile.getFileMetadata() != null) {\n+      if (orig && dataFile.isTabularData()) {\n+        fileName = dataFile.getOriginalFileName();\n+      } else {\n+        fileName = dataFile.getFileMetadata().getLabel();\n+      }\n+    }\n+\n+    if (StringUtil.nonEmpty(dataFile.getFileMetadata().getDirectoryLabel())) {\n+      fileName = dataFile.getFileMetadata().getDirectoryLabel() + \"/\" + fileName;\n+    }\n+\n+    if (location != null && fileName != null) {\n+      em.createNativeQuery(\"INSERT INTO CUSTOMZIPSERVICEREQUEST (KEY, STORAGELOCATION, FILENAME, ISSUETIME) VALUES (\"\n+        + \"'\" + key + \"',\"\n+        + \"'\" + location + \"',\"\n+        + \"'\" + fileName + \"',\"\n+        + \"'\" + timestamp + \"');\").executeUpdate();\n+    }\n+\n+    // TODO:\n+    // While we are here, issue another query, to delete all the entries that are\n+    // more than N seconds old?\n+    Timestamp deleteTime = new Timestamp(new Date().getTime() - 300000L);\n+    em.createNativeQuery(\"DELETE FROM CUSTOMZIPSERVICEREQUEST WHERE ISSUETIME < \"\n+      + \"'\" + deleteTime + \"';\").executeUpdate();\n+  }\n+\n+  public String getDirectStorageLocatrion(String storageLocation) {\n+    String storageDriverId;\n+    int separatorIndex = storageLocation.indexOf(\"://\");\n+    if (separatorIndex > 0) {\n+      storageDriverId = storageLocation.substring(0, separatorIndex);\n+\n+      String storageType = DataAccess.getDriverType(storageDriverId);\n+      if (\"file\".equals(storageType) || \"s3\".equals(storageType)) {\n+        return storageType.concat(storageLocation.substring(separatorIndex));\n+      }\n     }\n-    \n+\n+    return null;\n+  }\n+\n }\n",
            "diff_size": 715
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/20/FileDownloadServiceBean.java\nindex 7fa1b5c4846..d490873882e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/20/FileDownloadServiceBean.java\n@@ -38,7 +38,6 @@ import javax.persistence.PersistenceContext;\n import javax.persistence.Query;\n import javax.servlet.ServletOutputStream;\n import javax.servlet.http.HttpServletResponse;\n-\n import org.primefaces.PrimeFaces;\n //import org.primefaces.context.RequestContext;\n \n@@ -48,59 +47,70 @@ import org.primefaces.PrimeFaces;\n  * Handles All File Download processes\n  * including Guestbook responses\n  */\n+\n+\n @Stateless\n @Named\n public class FileDownloadServiceBean implements java.io.Serializable {\n \n     @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n     private EntityManager em;\n-    \n+\n     @EJB\n     GuestbookResponseServiceBean guestbookResponseService;\n+\n     @EJB\n     DatasetServiceBean datasetService;\n+\n     @EJB\n     DatasetVersionServiceBean datasetVersionService;\n+\n     @EJB\n     DataFileServiceBean datafileService;\n+\n     @EJB\n     PermissionServiceBean permissionService;\n+\n     @EJB\n     DataverseServiceBean dataverseService;\n+\n     @EJB\n     UserNotificationServiceBean userNotificationService;\n+\n     @EJB\n     AuthenticationServiceBean authService;\n+\n     @EJB\n     PrivateUrlServiceBean privateUrlService;\n+\n     @EJB\n     SettingsServiceBean settingsService;\n \n     @Inject\n     DataverseSession session;\n-    \n+\n     @EJB\n     EjbDataverseEngine commandEngine;\n-    \n+\n     @Inject\n     DataverseRequestServiceBean dvRequestService;\n-    \n-    @Inject FileDownloadHelper fileDownloadHelper;\n+\n+    @Inject\n+    FileDownloadHelper fileDownloadHelper;\n+\n     @Inject\n     MakeDataCountLoggingServiceBean mdcLogService;\n+    private static final Logger logger = Logger.getLogger(FileDownloadServiceBean.class.getCanonicalName());\n \n-    private static final Logger logger = Logger.getLogger(FileDownloadServiceBean.class.getCanonicalName());   \n-    \n-    public void writeGuestbookAndStartBatchDownload(GuestbookResponse guestbookResponse){ \n+    public void writeGuestbookAndStartBatchDownload(GuestbookResponse guestbookResponse) {\n         writeGuestbookAndStartBatchDownload(guestbookResponse, false);\n     }\n-    \n-    public void writeGuestbookAndStartBatchDownload(GuestbookResponse guestbookResponse, Boolean doNotSaveGuestbookRecord){\n \n+    public void writeGuestbookAndStartBatchDownload(GuestbookResponse guestbookResponse, Boolean doNotSaveGuestbookRecord) {\n         if (guestbookResponse == null || guestbookResponse.getSelectedFileIds() == null) {\n             return;\n         }\n-        \n+\n         boolean original = \"original\".equals(guestbookResponse.getFileFormat());\n \n         // Let's intercept the case where a multiple download method was called, \n@@ -117,28 +127,26 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n             }\n             // If we need to create a GuestBookResponse record, we have to \n             // look up the DataFile object for this file: \n+\n             if (!doNotSaveGuestbookRecord) {\n                 DataFile df = datafileService.findCheapAndEasy(Long.parseLong(fileIds[0]));\n                 guestbookResponse.setDataFile(df);\n                 writeGuestbookResponseRecord(guestbookResponse);\n             }\n-        \n             redirectToDownloadAPI(guestbookResponse.getFileFormat(), fileId, true, null);\n             return;\n         }\n         \n         // OK, this is a real batch (multi-file) download. \n-        \n+\n         String customZipDownloadUrl = settingsService.getValueForKey(SettingsServiceBean.Key.CustomZipDownloadServiceUrl);\n-        boolean useCustomZipService = customZipDownloadUrl != null; \n+        boolean useCustomZipService = customZipDownloadUrl != null;\n         String zipServiceKey = null; \n \n         // Do we need to write GuestbookRecord entries for the files? \n         if (!doNotSaveGuestbookRecord || useCustomZipService) {\n-\n             List<String> list = new ArrayList<>(Arrays.asList(guestbookResponse.getSelectedFileIds().split(\",\")));\n-            Timestamp timestamp = null; \n-            \n+            Timestamp timestamp = null;\n             for (String idAsString : list) {\n                 //DataFile df = datafileService.findCheapAndEasy(new Long(idAsString));\n                 DataFile df = datafileService.find(new Long(idAsString));\n@@ -147,58 +155,57 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n                         guestbookResponse.setDataFile(df);\n                         writeGuestbookResponseRecord(guestbookResponse);\n                     }\n-                    \n+\n                     if (useCustomZipService) {\n                         if (zipServiceKey == null) {\n                             zipServiceKey = generateServiceKey();\n                         }\n+\n                         if (timestamp == null) {\n                             timestamp = new Timestamp(new Date().getTime());\n                         }\n-                        \n                         addFileToCustomZipJob(zipServiceKey, df, timestamp, original);\n                     }\n                 }\n             }\n         }\n-        \n+\n         if (useCustomZipService) {\n             redirectToCustomZipDownloadService(customZipDownloadUrl, zipServiceKey);\n         } else {\n             // Use the \"normal\" /api/access/datafiles/ API:\n-            redirectToBatchDownloadAPI(guestbookResponse.getSelectedFileIds(),original);\n+            redirectToBatchDownloadAPI(guestbookResponse.getSelectedFileIds(), original);\n         }\n     }\n-    \n+\n     public void writeGuestbookAndStartFileDownload(GuestbookResponse guestbookResponse, FileMetadata fileMetadata, String format) {\n-        if(!fileMetadata.getDatasetVersion().isDraft()){\n+        if (!fileMetadata.getDatasetVersion().isDraft()) {\n             guestbookResponse = guestbookResponseService.modifyDatafileAndFormat(guestbookResponse, fileMetadata, format);\n             writeGuestbookResponseRecord(guestbookResponse);\n         }\n         \n         // Make sure to set the \"do not write Guestbook response\" flag to TRUE when calling the Access API:\n         redirectToDownloadAPI(format, fileMetadata.getDataFile().getId(), true, fileMetadata.getId());\n-        logger.fine(\"issued file download redirect for filemetadata \"+fileMetadata.getId()+\", datafile \"+fileMetadata.getDataFile().getId());\n+        logger.fine(\"issued file download redirect for filemetadata \" + fileMetadata.getId() + \", datafile \" + fileMetadata.getDataFile().getId());\n     }\n-    \n+\n     public void writeGuestbookAndStartFileDownload(GuestbookResponse guestbookResponse) {\n         if (guestbookResponse.getDataFile() == null) {\n             logger.warning(\"writeGuestbookAndStartFileDownload(GuestbookResponse) called without the DataFile in the GuestbookResponse.\");\n             return;\n         }\n         writeGuestbookResponseRecord(guestbookResponse);\n-        \n         redirectToDownloadAPI(guestbookResponse.getFileFormat(), guestbookResponse.getDataFile().getId());\n-        logger.fine(\"issued file download redirect for datafile \"+guestbookResponse.getDataFile().getId());\n+        logger.fine(\"issued file download redirect for datafile \" + guestbookResponse.getDataFile().getId());\n     }\n \n     public void writeGuestbookResponseRecord(GuestbookResponse guestbookResponse, FileMetadata fileMetadata, String format) {\n-        if(!fileMetadata.getDatasetVersion().isDraft()){           \n+        if (!fileMetadata.getDatasetVersion().isDraft()) {\n             guestbookResponse = guestbookResponseService.modifyDatafileAndFormat(guestbookResponse, fileMetadata, format);\n             writeGuestbookResponseRecord(guestbookResponse);\n         }\n     }\n-    \n+\n     public void writeGuestbookResponseRecord(GuestbookResponse guestbookResponse) {\n         try {\n             CreateGuestbookResponseCommand cmd = new CreateGuestbookResponseCommand(dvRequestService.getDataverseRequest(), guestbookResponse, guestbookResponse.getDataset());\n@@ -209,6 +216,7 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n             if (null == version) {\n                 version = guestbookResponse.getDataset().getReleasedVersion();\n             }\n+\n             MakeDataCountEntry entry = new MakeDataCountEntry(FacesContext.getCurrentInstance(), dvRequestService, version, guestbookResponse.getDataFile());\n             //As the api download url is not available at this point we construct it manually\n             entry.setTargetUrl(\"/api/access/datafile/\" + guestbookResponse.getDataFile().getId());\n@@ -236,25 +244,21 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n     // But note that this may change - there may be some future situations where it will \n     // become necessary again, to pass the job of creating the access record \n     // to the API.\n-    private void redirectToBatchDownloadAPI(String multiFileString, Boolean guestbookRecordsAlreadyWritten, Boolean downloadOriginal){\n \n+    private void redirectToBatchDownloadAPI(String multiFileString, Boolean guestbookRecordsAlreadyWritten, Boolean downloadOriginal) {\n         String fileDownloadUrl = \"/api/access/datafiles\";\n-        if (guestbookRecordsAlreadyWritten && !downloadOriginal){\n+        if (guestbookRecordsAlreadyWritten && !downloadOriginal) {\n             fileDownloadUrl += \"?gbrecs=true\";\n-        } else if (guestbookRecordsAlreadyWritten && downloadOriginal){\n+        } else if (guestbookRecordsAlreadyWritten && downloadOriginal) {\n             fileDownloadUrl += \"?gbrecs=true&format=original\";\n-        } else if (!guestbookRecordsAlreadyWritten && downloadOriginal){\n-            fileDownloadUrl += \"?format=original\";\n-        }\n-        \n-        PrimeFaces.current().executeScript(\"downloadFiles('\"+fileDownloadUrl + \"','\"+ multiFileString+\"');\");\n-\n+        } else if (!guestbookRecordsAlreadyWritten && downloadOriginal) {\n+                   fileDownloadUrl += \"?format=original\";\n+               }\n+        PrimeFaces.current().executeScript(\"downloadFiles('\" + fileDownloadUrl + \"','\" + multiFileString + \"');\");\n     }\n-    \n+\n     private void redirectToCustomZipDownloadService(String customZipServiceUrl, String jobKey) {\n-        \n-        customZipServiceUrl += \"?\" + jobKey; \n-        \n+        customZipServiceUrl += \"?\" + jobKey;\n         try {\n             FacesContext.getCurrentInstance().getExternalContext().redirect(customZipServiceUrl);\n         } catch (IOException ex) {\n@@ -271,12 +275,12 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n             logger.info(\"Failed to issue a redirect to file download url (\" + fileDownloadUrl + \"): \" + ex);\n         }\n     }\n-    \n+\n     private void redirectToDownloadAPI(String downloadType, Long fileId) {\n         redirectToDownloadAPI(downloadType, fileId, true, null);\n     }\n-    \n-    private void redirectToBatchDownloadAPI(String multiFileString, Boolean downloadOriginal){\n+\n+    private void redirectToBatchDownloadAPI(String multiFileString, Boolean downloadOriginal) {\n         redirectToBatchDownloadAPI(multiFileString, true, downloadOriginal);\n     }\n \n@@ -294,6 +298,7 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n      * TwoRavens or Data Explorer. This method may be invoked directly from the\n      * xhtml if no popup is required (no terms of use, no guestbook, etc.).\n      */\n+\n     public void explore(GuestbookResponse guestbookResponse, FileMetadata fmd, ExternalTool externalTool) {\n         ApiToken apiToken = null;\n         User user = session.getUser();\n@@ -313,6 +318,7 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n                 apiToken.setTokenString(privateUrl.getToken());\n             }\n         }\n+\n         DataFile dataFile = null;\n         if (fmd != null) {\n             dataFile = fmd.getDataFile();\n@@ -321,26 +327,27 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n                 dataFile = guestbookResponse.getDataFile();\n             }\n         }\n+\n         String localeCode = session.getLocaleCode();\n         ExternalToolHandler externalToolHandler = new ExternalToolHandler(externalTool, dataFile, apiToken, fmd, localeCode);\n         // Back when we only had TwoRavens, the downloadType was always \"Explore\". Now we persist the name of the tool (i.e. \"TwoRavens\", \"Data Explorer\", etc.)\n         guestbookResponse.setDownloadtype(externalTool.getDisplayName());\n         String toolUrl = externalToolHandler.getToolUrlWithQueryParams();\n         logger.fine(\"Exploring with \" + toolUrl);\n-        PrimeFaces.current().executeScript(\"window.open('\"+toolUrl + \"', target='_blank');\");\n+        PrimeFaces.current().executeScript(\"window.open('\" + toolUrl + \"', target='_blank');\");\n         // This is the old logic from TwoRavens, null checks and all.\n-        if (guestbookResponse != null && guestbookResponse.isWriteResponse()\n-                && ((fmd != null && fmd.getDataFile() != null) || guestbookResponse.getDataFile() != null)) {\n+        if (guestbookResponse != null && guestbookResponse.isWriteResponse() && ((fmd != null && fmd.getDataFile() != null) || guestbookResponse.getDataFile() != null)) {\n             if (guestbookResponse.getDataFile() == null && fmd != null) {\n                 guestbookResponse.setDataFile(fmd.getDataFile());\n             }\n+\n             if (fmd == null || !fmd.getDatasetVersion().isDraft()) {\n                 writeGuestbookResponseRecord(guestbookResponse);\n             }\n         }\n     }\n \n-    public Boolean canSeeTwoRavensExploreButton(){\n+    public Boolean canSeeTwoRavensExploreButton() {\n         return false;\n     }\n \n@@ -351,18 +358,19 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n     public void downloadDatafileCitationXML(FileMetadata fileMetadata) {\n         downloadCitationXML(fileMetadata, null, false);\n     }\n-    \n+\n     public void downloadDirectDatafileCitationXML(FileMetadata fileMetadata) {\n         downloadCitationXML(fileMetadata, null, true);\n     }\n \n     public void downloadCitationXML(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n-    \tDataCitation citation=null;\n-        if (dataset != null){\n-        \tcitation = new DataCitation(dataset.getLatestVersion());\n+        DataCitation citation = null;\n+        if (dataset != null) {\n+            citation = new DataCitation(dataset.getLatestVersion());\n         } else {\n-            citation= new DataCitation(fileMetadata, direct);\n+            citation = new DataCitation(fileMetadata, direct);\n         }\n+\n         FacesContext ctx = FacesContext.getCurrentInstance();\n         HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n         response.setContentType(\"text/xml\");\n@@ -380,37 +388,32 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n             citation.writeAsEndNoteCitation(out);\n             out.flush();\n             ctx.responseComplete();\n-        } catch (IOException e) {\n-\n-        }\n+        } catch (IOException e) {}\n     }\n-    \n-    public void downloadDatasetCitationRIS(Dataset dataset) {\n \n+    public void downloadDatasetCitationRIS(Dataset dataset) {\n         downloadCitationRIS(null, dataset, false);\n-\n     }\n \n     public void downloadDatafileCitationRIS(FileMetadata fileMetadata) {\n         downloadCitationRIS(fileMetadata, null, false);\n     }\n-    \n+\n     public void downloadDirectDatafileCitationRIS(FileMetadata fileMetadata) {\n         downloadCitationRIS(fileMetadata, null, true);\n     }\n \n     public void downloadCitationRIS(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n-    \tDataCitation citation=null;\n-        if (dataset != null){\n-        \tcitation = new DataCitation(dataset.getLatestVersion());\n+        DataCitation citation = null;\n+        if (dataset != null) {\n+            citation = new DataCitation(dataset.getLatestVersion());\n         } else {\n-            citation= new DataCitation(fileMetadata, direct);\n+            citation = new DataCitation(fileMetadata, direct);\n         }\n \n         FacesContext ctx = FacesContext.getCurrentInstance();\n         HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n         response.setContentType(\"application/download\");\n-\n         String fileNameString;\n         if (fileMetadata == null || fileMetadata.getLabel() == null) {\n             // Dataset-level citation: \n@@ -420,25 +423,20 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n             fileNameString = \"attachment;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \"-\" + FileUtil.getCiteDataFileFilename(citation.getFileTitle(), FileUtil.FileCitationExtension.RIS);\n         }\n         response.setHeader(\"Content-Disposition\", fileNameString);\n-\n         try {\n             ServletOutputStream out = response.getOutputStream();\n             citation.writeAsRISCitation(out);\n             out.flush();\n             ctx.responseComplete();\n-        } catch (IOException e) {\n-\n-        }\n+        } catch (IOException e) {}\n     }\n-    \n+\n     private String getFileNameFromPid(GlobalId id) {\n         return id.asString();\n     }\n \n     public void downloadDatasetCitationBibtex(Dataset dataset) {\n-\n         downloadCitationBibtex(null, dataset, false);\n-\n     }\n \n     public void downloadDatafileCitationBibtex(FileMetadata fileMetadata) {\n@@ -448,21 +446,21 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n     public void downloadDirectDatafileCitationBibtex(FileMetadata fileMetadata) {\n         downloadCitationBibtex(fileMetadata, null, true);\n     }\n-    \n+\n     public void downloadCitationBibtex(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n-    \tDataCitation citation=null;\n-        if (dataset != null){\n-        \tcitation = new DataCitation(dataset.getLatestVersion());\n+        DataCitation citation = null;\n+        if (dataset != null) {\n+            citation = new DataCitation(dataset.getLatestVersion());\n         } else {\n-            citation= new DataCitation(fileMetadata, direct);\n+            citation = new DataCitation(fileMetadata, direct);\n         }\n         //SEK 12/3/2018 changing this to open the json in a new tab. \n+\n         FacesContext ctx = FacesContext.getCurrentInstance();\n         HttpServletResponse response = (HttpServletResponse) ctx.getExternalContext().getResponse();\n         \n         //Fix for 6029 FireFox was failing to parse it when content type was set to json \n         response.setContentType(\"text/plain\");\n-        \n         String fileNameString;\n         if (fileMetadata == null || fileMetadata.getLabel() == null) {\n             // Dataset-level citation:\n@@ -472,62 +470,62 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n             fileNameString = \"inline;filename=\" + getFileNameFromPid(citation.getPersistentId()) + \"-\" + FileUtil.getCiteDataFileFilename(citation.getFileTitle(), FileUtil.FileCitationExtension.BIBTEX);\n         }\n         response.setHeader(\"Content-Disposition\", fileNameString);\n-\n         try {\n             ServletOutputStream out = response.getOutputStream();\n             citation.writeAsBibtexCitation(out);\n             out.flush();\n             ctx.responseComplete();\n-        } catch (IOException e) {\n-\n-        }\n+        } catch (IOException e) {}\n     }\n-    \n-    public boolean requestAccess(Long fileId) {   \n-        if (dvRequestService.getDataverseRequest().getAuthenticatedUser() == null){\n+\n+    public boolean requestAccess(Long fileId) {\n+        if (dvRequestService.getDataverseRequest().getAuthenticatedUser() == null) {\n             return false;\n         }\n+\n         DataFile file = datafileService.find(fileId);\n-        if (!file.getFileAccessRequesters().contains((AuthenticatedUser)session.getUser())) {\n+        if (!file.getFileAccessRequesters().contains((AuthenticatedUser) session.getUser())) {\n             try {\n-                commandEngine.submit(new RequestAccessCommand(dvRequestService.getDataverseRequest(), file));                        \n+                commandEngine.submit(new RequestAccessCommand(dvRequestService.getDataverseRequest(), file));\n                 return true;\n             } catch (CommandException ex) {\n                 logger.info(\"Unable to request access for file id \" + fileId + \". Exception: \" + ex);\n                 return false;\n-            }             \n-        }        \n+            }\n+        }\n         return false;\n-    }    \n-    \n+    }\n+\n     public void sendRequestFileAccessNotification(Dataset dataset, Long fileId, AuthenticatedUser requestor) {\n         permissionService.getUsersWithPermissionOn(Permission.ManageDatasetPermissions, dataset).stream().forEach((au) -> {\n-            userNotificationService.sendNotification(au, new Timestamp(new Date().getTime()), UserNotification.Type.REQUESTFILEACCESS, fileId, null, requestor, false);\n+            userNotificationService.sendNotification(au,\n+                                    new Timestamp(new Date().getTime()),\n+                                    UserNotification.Type.REQUESTFILEACCESS,\n+                                    fileId, null,\n+                                    requestor,\n+                                                     false);\n         });\n+    }\n \n-    } \n-    \n     public String generateServiceKey() {\n         UUID uid = UUID.randomUUID();\n         // last 8 bytes, of the random UUID, 16 hex digits: \n         return uid.toString().substring(20);\n     }\n-    \n+\n     public void addFileToCustomZipJob(String key, DataFile dataFile, Timestamp timestamp, boolean orig) {\n-        String location = null; \n-        String fileName = null; \n-        \n+        String location = null;\n+        String fileName = null;\n         try {\n             StorageIO<DataFile> storageIO = DataAccess.getStorageIO(dataFile);\n             location = getDirectStorageLocatrion(storageIO.getStorageLocation());\n-\n             if (orig && dataFile.isTabularData()) {\n                 location = location.concat(\".orig\");\n             }\n         } catch (IOException ioex) {\n             logger.info(\"Failed to open StorageIO for datafile \" + dataFile.getId());\n         }\n-        \n+\n         if (dataFile.getFileMetadata() != null) {\n             if (orig && dataFile.isTabularData()) {\n                 fileName = dataFile.getOriginalFileName();\n@@ -535,40 +533,34 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n                 fileName = dataFile.getFileMetadata().getLabel();\n             }\n         }\n-        \n+\n         if (StringUtil.nonEmpty(dataFile.getFileMetadata().getDirectoryLabel())) {\n             fileName = dataFile.getFileMetadata().getDirectoryLabel() + \"/\" + fileName;\n         }\n-                \n+\n         if (location != null && fileName != null) {\n-            em.createNativeQuery(\"INSERT INTO CUSTOMZIPSERVICEREQUEST (KEY, STORAGELOCATION, FILENAME, ISSUETIME) VALUES (\"\n-                    + \"'\" + key + \"',\"\n-                    + \"'\" + location + \"',\"\n-                    + \"'\" + fileName + \"',\"\n-                    + \"'\" + timestamp + \"');\").executeUpdate();\n+            em.createNativeQuery(\"INSERT INTO CUSTOMZIPSERVICEREQUEST (KEY, STORAGELOCATION, FILENAME, ISSUETIME) VALUES (\" + \"'\" + key + \"',\" + \"'\" + location + \"',\" + \"'\" + fileName + \"',\" + \"'\" + timestamp + \"');\").executeUpdate();\n         }\n         \n         // TODO:\n         // While we are here, issue another query, to delete all the entries that are \n         // more than N seconds old?\n+\n         Timestamp deleteTime = new Timestamp(new Date().getTime() - 300000L);\n-        em.createNativeQuery(\"DELETE FROM CUSTOMZIPSERVICEREQUEST WHERE ISSUETIME < \" \n-                + \"'\" + deleteTime + \"';\").executeUpdate();\n+        em.createNativeQuery(\"DELETE FROM CUSTOMZIPSERVICEREQUEST WHERE ISSUETIME < \" + \"'\" + deleteTime + \"';\").executeUpdate();\n     }\n-    \n+\n     public String getDirectStorageLocatrion(String storageLocation) {\n         String storageDriverId;\n         int separatorIndex = storageLocation.indexOf(\"://\");\n-        if ( separatorIndex > 0 ) {\n-            storageDriverId = storageLocation.substring(0,separatorIndex);\n-        \n+        if (separatorIndex > 0) {\n+            storageDriverId = storageLocation.substring(0, separatorIndex);\n             String storageType = DataAccess.getDriverType(storageDriverId);\n             if (\"file\".equals(storageType) || \"s3\".equals(storageType)) {\n                 return storageType.concat(storageLocation.substring(separatorIndex));\n             }\n         }\n-            \n-        return null; \n+        return null;\n     }\n-    \n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 153
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "362",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/20/FileDownloadServiceBean.java\nindex 7fa1b5c4846..5b5cda2ffb4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/20/FileDownloadServiceBean.java\n@@ -357,7 +357,7 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n     }\n \n     public void downloadCitationXML(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n-    \tDataCitation citation=null;\n+    DataCitation citation=null;\n         if (dataset != null){\n         \tcitation = new DataCitation(dataset.getLatestVersion());\n         } else {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "362",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/20/FileDownloadServiceBean.java\nindex 7fa1b5c4846..72431632ed5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/20/FileDownloadServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/20/FileDownloadServiceBean.java\n@@ -357,7 +357,7 @@ public class FileDownloadServiceBean implements java.io.Serializable {\n     }\n \n     public void downloadCitationXML(FileMetadata fileMetadata, Dataset dataset, boolean direct) {\n-    \tDataCitation citation=null;\n+        DataCitation citation=null;\n         if (dataset != null){\n         \tcitation = new DataCitation(dataset.getLatestVersion());\n         } else {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}