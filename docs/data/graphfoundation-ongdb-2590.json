{
    "project_name": "graphfoundation-ongdb",
    "error_id": "2590",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "109",
                    "column": "12",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "111",
                    "column": "41",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "198",
                    "column": "20",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "200",
                    "column": "55",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "218",
                    "column": "24",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "218",
                    "column": "42",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "231",
                    "column": "29",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "231",
                    "column": "43",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "243",
                    "column": "41",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "243",
                    "column": "59",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "256",
                    "column": "25",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "257",
                    "column": "96",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "260",
                    "column": "37",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "262",
                    "column": "72",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "287",
                    "column": "24",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "287",
                    "column": "33",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "289",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "289",
                    "column": "18",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "293",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "293",
                    "column": "48",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2590/TreeState.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/2590/TreeState.java\nindex 850fb0661f1..5acb7f740af 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/2590/TreeState.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/2590/TreeState.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.index.internal.gbptree;\n \n import java.util.Objects;\n@@ -39,278 +40,278 @@ import org.neo4j.io.pagecache.PageCursor;\n  */\n class TreeState\n {\n-    private static final byte CLEAN_BYTE = 0x01;\n-    private static final byte DIRTY_BYTE = 0x00;\n-\n-    /**\n-     * Page id this tree state has been read from.\n-     */\n-    private final long pageId;\n-\n-    /**\n-     * Stable generation of the tree.\n-     */\n-    private final long stableGeneration;\n-\n-    /**\n-     * Unstable generation of the tree.\n-     */\n-    private final long unstableGeneration;\n-\n-    /**\n-     * Page id which is the root of the tree.\n-     */\n-    private final long rootId;\n-\n-    /**\n-     * Generation of {@link #rootId}.\n-     */\n-    private final long rootGeneration;\n-\n-    /**\n-     * Highest allocated page id in the store. This id may not be in use currently and cannot decrease\n-     * since {@link PageCache} doesn't allow shrinking files.\n-     */\n-    private final long lastId;\n-\n-    /**\n-     * Page id to write new released tree node ids into.\n-     */\n-    private final long freeListWritePageId;\n-\n-    /**\n-     * Page id to read released tree node ids from, when acquiring ids.\n-     */\n-    private final long freeListReadPageId;\n-\n-    /**\n-     * Offset in page {@link #freeListWritePageId} to write new released tree node ids at.\n-     */\n-    private final int freeListWritePos;\n-\n-    /**\n-     * Offset in page {@link #freeListReadPageId} to read released tree node ids from, when acquiring ids.\n-     */\n-    private final int freeListReadPos;\n-\n-    /**\n-     * Due to writing with potential concurrent page flushing tree state is written twice, the second\n-     * state acting as checksum. If both states match this variable should be set to {@code true},\n-     * otherwise to {@code false}.\n-     */\n-    private boolean valid;\n-\n-    /**\n-     * Is tree clean or dirty. Clean means it was closed without any non-checkpointed changes.\n-     */\n-    private final boolean clean;\n-\n-    TreeState( long pageId, long stableGeneration, long unstableGeneration, long rootId, long rootGeneration,\n+  private static final byte CLEAN_BYTE = 0x01;\n+  private static final byte DIRTY_BYTE = 0x00;\n+\n+  /**\n+   * Page id this tree state has been read from.\n+   */\n+  private final long pageId;\n+\n+  /**\n+   * Stable generation of the tree.\n+   */\n+  private final long stableGeneration;\n+\n+  /**\n+   * Unstable generation of the tree.\n+   */\n+  private final long unstableGeneration;\n+\n+  /**\n+   * Page id which is the root of the tree.\n+   */\n+  private final long rootId;\n+\n+  /**\n+   * Generation of {@link #rootId}.\n+   */\n+  private final long rootGeneration;\n+\n+  /**\n+   * Highest allocated page id in the store. This id may not be in use currently and cannot decrease\n+   * since {@link PageCache} doesn't allow shrinking files.\n+   */\n+  private final long lastId;\n+\n+  /**\n+   * Page id to write new released tree node ids into.\n+   */\n+  private final long freeListWritePageId;\n+\n+  /**\n+   * Page id to read released tree node ids from, when acquiring ids.\n+   */\n+  private final long freeListReadPageId;\n+\n+  /**\n+   * Offset in page {@link #freeListWritePageId} to write new released tree node ids at.\n+   */\n+  private final int freeListWritePos;\n+\n+  /**\n+   * Offset in page {@link #freeListReadPageId} to read released tree node ids from, when acquiring ids.\n+   */\n+  private final int freeListReadPos;\n+\n+  /**\n+   * Due to writing with potential concurrent page flushing tree state is written twice, the second\n+   * state acting as checksum. If both states match this variable should be set to {@code true},\n+   * otherwise to {@code false}.\n+   */\n+  private boolean valid;\n+\n+  /**\n+   * Is tree clean or dirty. Clean means it was closed without any non-checkpointed changes.\n+   */\n+  private final boolean clean;\n+\n+  TreeState(long pageId, long stableGeneration, long unstableGeneration, long rootId, long rootGeneration,\n             long lastId, long freeListWritePageId, long freeListReadPageId, int freeListWritePos, int freeListReadPos,\n-            boolean clean, boolean valid )\n-    {\n-        this.pageId = pageId;\n-        this.stableGeneration = stableGeneration;\n-        this.unstableGeneration = unstableGeneration;\n-        this.rootId = rootId;\n-        this.rootGeneration = rootGeneration;\n-        this.lastId = lastId;\n-        this.freeListWritePageId = freeListWritePageId;\n-        this.freeListReadPageId = freeListReadPageId;\n-        this.freeListWritePos = freeListWritePos;\n-        this.freeListReadPos = freeListReadPos;\n-        this.clean = clean;\n-        this.valid = valid;\n-    }\n-\n-    long pageId()\n-    {\n-        return pageId;\n-    }\n-\n-    long stableGeneration()\n-    {\n-        return stableGeneration;\n-    }\n-\n-    long unstableGeneration()\n-    {\n-        return unstableGeneration;\n-    }\n-\n-    long rootId()\n-    {\n-        return rootId;\n-    }\n-\n-    long rootGeneration()\n-    {\n-        return rootGeneration;\n-    }\n-\n-    long lastId()\n-    {\n-        return lastId;\n-    }\n-\n-    long freeListWritePageId()\n-    {\n-        return freeListWritePageId;\n-    }\n-\n-    long freeListReadPageId()\n-    {\n-        return freeListReadPageId;\n-    }\n-\n-    int freeListWritePos()\n-    {\n-        return freeListWritePos;\n-    }\n-\n-    int freeListReadPos()\n-    {\n-        return freeListReadPos;\n-    }\n-\n-    boolean isValid()\n-    {\n-        return valid;\n-    }\n-\n-    /**\n-     * Writes provided tree state to {@code cursor} at its current offset. Two versions of the state\n-     * are written after each other, the second one acting as checksum for the first, see {@link #valid} field.\n-     *\n-     * @param cursor {@link PageCursor} to write into, at its current offset.\n-     * @param stableGeneration stable generation.\n-     * @param unstableGeneration unstable generation.\n-     * @param rootId root id.\n-     * @param rootGeneration root generation.\n-     * @param lastId last id.\n-     * @param freeListWritePageId free-list page id to write released ids into.\n-     * @param freeListReadPageId free-list page id to read released ids from.\n-     * @param freeListWritePos offset into free-list write page id to write released ids into.\n-     * @param freeListReadPos offset into free-list read page id to read released ids from.\n-     * @param clean is tree clean or dirty\n-     */\n-    static void write( PageCursor cursor, long stableGeneration, long unstableGeneration, long rootId,\n-            long rootGeneration, long lastId, long freeListWritePageId, long freeListReadPageId, int freeListWritePos,\n-            int freeListReadPos, boolean clean )\n-    {\n-        GenerationSafePointer.assertGenerationOnWrite( stableGeneration );\n-        GenerationSafePointer.assertGenerationOnWrite( unstableGeneration );\n-\n-        writeStateOnce( cursor, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n-                freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean ); // Write state\n-        writeStateOnce( cursor, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n-                freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean ); // Write checksum\n-    }\n-\n-    /**\n-     * Reads tree state from {@code cursor} at its current offset. If checksum matches then {@link #valid}\n-     * is set to {@code true}, otherwise {@code false}.\n-     *\n-     * @param cursor {@link PageCursor} to read tree state from, at its current offset.\n-     * @return {@link TreeState} instance containing read tree state.\n-     */\n-    static TreeState read( PageCursor cursor )\n-    {\n-        TreeState state = readStateOnce( cursor );\n-        TreeState checksumState = readStateOnce( cursor );\n-\n-        boolean valid = state.equals( checksumState );\n-\n-        boolean isEmpty = state.isEmpty();\n-        valid &= !isEmpty;\n-\n-        return state.setValid( valid );\n-    }\n-\n-    private TreeState setValid( boolean valid )\n-    {\n-        this.valid = valid;\n-        return this;\n-    }\n-\n-    boolean isEmpty()\n+            boolean clean, boolean valid)\n+  {\n+    this.pageId = pageId;\n+    this.stableGeneration = stableGeneration;\n+    this.unstableGeneration = unstableGeneration;\n+    this.rootId = rootId;\n+    this.rootGeneration = rootGeneration;\n+    this.lastId = lastId;\n+    this.freeListWritePageId = freeListWritePageId;\n+    this.freeListReadPageId = freeListReadPageId;\n+    this.freeListWritePos = freeListWritePos;\n+    this.freeListReadPos = freeListReadPos;\n+    this.clean = clean;\n+    this.valid = valid;\n+  }\n+\n+  long pageId()\n+  {\n+    return pageId;\n+  }\n+\n+  long stableGeneration()\n+  {\n+    return stableGeneration;\n+  }\n+\n+  long unstableGeneration()\n+  {\n+    return unstableGeneration;\n+  }\n+\n+  long rootId()\n+  {\n+    return rootId;\n+  }\n+\n+  long rootGeneration()\n+  {\n+    return rootGeneration;\n+  }\n+\n+  long lastId()\n+  {\n+    return lastId;\n+  }\n+\n+  long freeListWritePageId()\n+  {\n+    return freeListWritePageId;\n+  }\n+\n+  long freeListReadPageId()\n+  {\n+    return freeListReadPageId;\n+  }\n+\n+  int freeListWritePos()\n+  {\n+    return freeListWritePos;\n+  }\n+\n+  int freeListReadPos()\n+  {\n+    return freeListReadPos;\n+  }\n+\n+  boolean isValid()\n+  {\n+    return valid;\n+  }\n+\n+  /**\n+   * Writes provided tree state to {@code cursor} at its current offset. Two versions of the state\n+   * are written after each other, the second one acting as checksum for the first, see {@link #valid} field.\n+   *\n+   * @param cursor              {@link PageCursor} to write into, at its current offset.\n+   * @param stableGeneration    stable generation.\n+   * @param unstableGeneration  unstable generation.\n+   * @param rootId              root id.\n+   * @param rootGeneration      root generation.\n+   * @param lastId              last id.\n+   * @param freeListWritePageId free-list page id to write released ids into.\n+   * @param freeListReadPageId  free-list page id to read released ids from.\n+   * @param freeListWritePos    offset into free-list write page id to write released ids into.\n+   * @param freeListReadPos     offset into free-list read page id to read released ids from.\n+   * @param clean               is tree clean or dirty\n+   */\n+  static void write(PageCursor cursor, long stableGeneration, long unstableGeneration, long rootId,\n+                    long rootGeneration, long lastId, long freeListWritePageId, long freeListReadPageId, int freeListWritePos,\n+                    int freeListReadPos, boolean clean)\n+  {\n+    GenerationSafePointer.assertGenerationOnWrite(stableGeneration);\n+    GenerationSafePointer.assertGenerationOnWrite(unstableGeneration);\n+\n+    writeStateOnce(cursor, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n+        freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean); // Write state\n+    writeStateOnce(cursor, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n+        freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean); // Write checksum\n+  }\n+\n+  /**\n+   * Reads tree state from {@code cursor} at its current offset. If checksum matches then {@link #valid}\n+   * is set to {@code true}, otherwise {@code false}.\n+   *\n+   * @param cursor {@link PageCursor} to read tree state from, at its current offset.\n+   * @return {@link TreeState} instance containing read tree state.\n+   */\n+  static TreeState read(PageCursor cursor)\n+  {\n+    TreeState state = readStateOnce(cursor);\n+    TreeState checksumState = readStateOnce(cursor);\n+\n+    boolean valid = state.equals(checksumState);\n+\n+    boolean isEmpty = state.isEmpty();\n+    valid &= !isEmpty;\n+\n+    return state.setValid(valid);\n+  }\n+\n+  private TreeState setValid(boolean valid)\n+  {\n+    this.valid = valid;\n+    return this;\n+  }\n+\n+  boolean isEmpty()\n+  {\n+    return stableGeneration == 0L && unstableGeneration == 0L && rootId == 0L && lastId == 0L &&\n+        freeListWritePageId == 0L && freeListReadPageId == 0L && freeListWritePos == 0 && freeListReadPos == 0;\n+  }\n+\n+  private static TreeState readStateOnce(PageCursor cursor)\n+  {\n+    long pageId = cursor.getCurrentPageId();\n+    long stableGeneration = cursor.getInt() & GenerationSafePointer.GENERATION_MASK;\n+    long unstableGeneration = cursor.getInt() & GenerationSafePointer.GENERATION_MASK;\n+    long rootId = cursor.getLong();\n+    long rootGeneration = cursor.getLong();\n+    long lastId = cursor.getLong();\n+    long freeListWritePageId = cursor.getLong();\n+    long freeListReadPageId = cursor.getLong();\n+    int freeListWritePos = cursor.getInt();\n+    int freeListReadPos = cursor.getInt();\n+    boolean clean = cursor.getByte() == CLEAN_BYTE;\n+    return new TreeState(pageId, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n+        freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean, true);\n+  }\n+\n+  private static void writeStateOnce(PageCursor cursor, long stableGeneration, long unstableGeneration, long rootId,\n+                                     long rootGeneration, long lastId, long freeListWritePageId, long freeListReadPageId, int freeListWritePos,\n+                                     int freeListReadPos, boolean clean)\n+  {\n+    cursor.putInt((int) stableGeneration);\n+    cursor.putInt((int) unstableGeneration);\n+    cursor.putLong(rootId);\n+    cursor.putLong(rootGeneration);\n+    cursor.putLong(lastId);\n+    cursor.putLong(freeListWritePageId);\n+    cursor.putLong(freeListReadPageId);\n+    cursor.putInt(freeListWritePos);\n+    cursor.putInt(freeListReadPos);\n+    cursor.putByte(clean ? CLEAN_BYTE : DIRTY_BYTE);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return String.format(\"pageId=%d, stableGeneration=%d, unstableGeneration=%d, rootId=%d, rootGeneration=%d, \" +\n+            \"lastId=%d, freeListWritePageId=%d, freeListReadPageId=%d, freeListWritePos=%d, freeListReadPos=%d, \" +\n+            \"clean=%b, valid=%b\",\n+        pageId, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n+        freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean, valid);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o)\n     {\n-        return stableGeneration == 0L && unstableGeneration == 0L && rootId == 0L && lastId == 0L &&\n-                freeListWritePageId == 0L && freeListReadPageId == 0L && freeListWritePos == 0 && freeListReadPos == 0;\n+      return true;\n     }\n-\n-    private static TreeState readStateOnce( PageCursor cursor )\n-    {\n-        long pageId = cursor.getCurrentPageId();\n-        long stableGeneration = cursor.getInt() & GenerationSafePointer.GENERATION_MASK;\n-        long unstableGeneration = cursor.getInt() & GenerationSafePointer.GENERATION_MASK;\n-        long rootId = cursor.getLong();\n-        long rootGeneration = cursor.getLong();\n-        long lastId = cursor.getLong();\n-        long freeListWritePageId = cursor.getLong();\n-        long freeListReadPageId = cursor.getLong();\n-        int freeListWritePos = cursor.getInt();\n-        int freeListReadPos = cursor.getInt();\n-        boolean clean = cursor.getByte() == CLEAN_BYTE;\n-        return new TreeState( pageId, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n-                freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean, true );\n-    }\n-\n-    private static void writeStateOnce( PageCursor cursor, long stableGeneration, long unstableGeneration, long rootId,\n-            long rootGeneration, long lastId, long freeListWritePageId, long freeListReadPageId, int freeListWritePos,\n-            int freeListReadPos, boolean clean )\n-    {\n-        cursor.putInt( (int) stableGeneration );\n-        cursor.putInt( (int) unstableGeneration );\n-        cursor.putLong( rootId );\n-        cursor.putLong( rootGeneration );\n-        cursor.putLong( lastId );\n-        cursor.putLong( freeListWritePageId );\n-        cursor.putLong( freeListReadPageId );\n-        cursor.putInt( freeListWritePos );\n-        cursor.putInt( freeListReadPos );\n-        cursor.putByte( clean ? CLEAN_BYTE : DIRTY_BYTE );\n-    }\n-\n-    @Override\n-    public String toString()\n-    {\n-        return String.format( \"pageId=%d, stableGeneration=%d, unstableGeneration=%d, rootId=%d, rootGeneration=%d, \" +\n-                \"lastId=%d, freeListWritePageId=%d, freeListReadPageId=%d, freeListWritePos=%d, freeListReadPos=%d, \" +\n-                \"clean=%b, valid=%b\",\n-                pageId, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n-                freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean, valid );\n-    }\n-\n-    @Override\n-    public boolean equals( Object o )\n-    {\n-        if ( this == o )\n-        {\n-            return true;\n-        }\n-        if ( o == null || getClass() != o.getClass() )\n-        {\n-            return false;\n-        }\n-        TreeState treeState = (TreeState) o;\n-        return pageId == treeState.pageId && stableGeneration == treeState.stableGeneration &&\n-                unstableGeneration == treeState.unstableGeneration && rootId == treeState.rootId &&\n-                rootGeneration == treeState.rootGeneration && lastId == treeState.lastId &&\n-                freeListWritePageId == treeState.freeListWritePageId &&\n-                freeListReadPageId == treeState.freeListReadPageId && freeListWritePos == treeState.freeListWritePos &&\n-                freeListReadPos == treeState.freeListReadPos && clean == treeState.clean && valid == treeState.valid;\n-    }\n-\n-    @Override\n-    public int hashCode()\n-    {\n-        return Objects.hash( pageId, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n-                freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean, valid );\n-    }\n-\n-    public boolean isClean()\n+    if (o == null || getClass() != o.getClass())\n     {\n-        return this.clean;\n+      return false;\n     }\n+    TreeState treeState = (TreeState) o;\n+    return pageId == treeState.pageId && stableGeneration == treeState.stableGeneration &&\n+        unstableGeneration == treeState.unstableGeneration && rootId == treeState.rootId &&\n+        rootGeneration == treeState.rootGeneration && lastId == treeState.lastId &&\n+        freeListWritePageId == treeState.freeListWritePageId &&\n+        freeListReadPageId == treeState.freeListReadPageId && freeListWritePos == treeState.freeListWritePos &&\n+        freeListReadPos == treeState.freeListReadPos && clean == treeState.clean && valid == treeState.valid;\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(pageId, stableGeneration, unstableGeneration, rootId, rootGeneration, lastId,\n+        freeListWritePageId, freeListReadPageId, freeListWritePos, freeListReadPos, clean, valid);\n+  }\n+\n+  public boolean isClean()\n+  {\n+    return this.clean;\n+  }\n }\n",
            "diff_size": 342
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}