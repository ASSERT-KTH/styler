{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "114",
    "information": {
        "errors": [
            {
                "line": "25",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import org.apache.accumulo.core.client.ScannerBase;\nimport org.apache.accumulo.core.client.TableNotFoundException;\nimport org.apache.accumulo.core.conf.ClientProperty;\nimport org.apache.accumulo.core.security.Authorizations;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.log4j.Logger;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "25",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "25",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/114/ScannerFactory.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/114/ScannerFactory.java\nindex 642da6f56a6..58eb8267631 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/114/ScannerFactory.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/114/ScannerFactory.java\n@@ -30,259 +30,273 @@ import org.apache.log4j.Logger;\n import com.google.common.base.Preconditions;\n \n /**\n- * \n+ *\n  */\n public class ScannerFactory {\n-    \n-    protected int maxQueue = 1000;\n-    protected HashSet<ScannerBase> instances = new HashSet<>();\n-    protected HashSet<ScannerSession> sessionInstances = new HashSet<>();\n-    protected AccumuloClient cxn;\n-    protected boolean open = true;\n-    protected boolean accrueStats = false;\n-    protected Query settings;\n-    protected ResourceQueue scanQueue = null;\n-    ShardQueryConfiguration config = null;\n-    \n-    private static final Logger log = Logger.getLogger(ScannerFactory.class);\n-    \n-    public ScannerFactory(GenericQueryConfiguration queryConfiguration) {\n-        \n-        this.cxn = queryConfiguration.getClient();\n-        \n-        if (queryConfiguration instanceof ShardQueryConfiguration) {\n-            this.settings = ((ShardQueryConfiguration) queryConfiguration).getQuery();\n-            this.accrueStats = ((ShardQueryConfiguration) queryConfiguration).getAccrueStats();\n-        }\n-        log.debug(\"Created scanner factory \" + System.identityHashCode(this) + \" is wrapped ? \" + (cxn instanceof WrappedConnector));\n-        \n-        if (queryConfiguration instanceof ShardQueryConfiguration) {\n-            config = ((ShardQueryConfiguration) queryConfiguration);\n-            maxQueue = ((ShardQueryConfiguration) queryConfiguration).getMaxScannerBatchSize();\n-            this.settings = ((ShardQueryConfiguration) queryConfiguration).getQuery();\n-            try {\n-                scanQueue = new ResourceQueue(((ShardQueryConfiguration) queryConfiguration).getNumQueryThreads(), this.cxn);\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-    \n-    public ScannerFactory(AccumuloClient client) {\n-        this(client, 100);\n-        \n-    }\n-    \n-    public ScannerFactory(AccumuloClient client, int queueSize) {\n-        try {\n-            this.cxn = client;\n-            scanQueue = new ResourceQueue(queueSize, client);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    \n-    public synchronized Scanner newSingleScanner(String tableName, Set<Authorizations> auths, Query query) throws TableNotFoundException {\n-        if (open) {\n-            Scanner bs = QueryScannerHelper.createScannerWithoutInfo(cxn, tableName, auths, query);\n-            log.debug(\"Created scanner \" + System.identityHashCode(bs));\n-            if (log.isTraceEnabled()) {\n-                log.trace(\"Adding instance \" + bs.hashCode());\n-            }\n-            \n-            return bs;\n-        } else {\n-            throw new IllegalStateException(\"Factory has been locked. No new scanners can be created.\");\n-        }\n-    }\n-    \n-    public synchronized BatchScanner newScanner(String tableName, Set<Authorizations> auths, int threads, Query query) throws TableNotFoundException {\n-        if (open) {\n-            BatchScanner bs = QueryScannerHelper.createBatchScanner(cxn, tableName, auths, threads, query);\n-            log.debug(\"Created scanner \" + System.identityHashCode(bs));\n-            if (log.isTraceEnabled()) {\n-                log.trace(\"Adding instance \" + bs.hashCode());\n-            }\n-            instances.add(bs);\n-            return bs;\n-        } else {\n-            throw new IllegalStateException(\"Factory has been locked. No new scanners can be created.\");\n-        }\n-    }\n-    \n-    public synchronized BatchScanner newScanner(String tableName, Set<Authorizations> auths, int threads, Query query, boolean reportErrors)\n-                    throws TableNotFoundException {\n-        if (open) {\n-            BatchScanner bs = QueryScannerHelper.createBatchScanner(cxn, tableName, auths, threads, query, reportErrors);\n-            log.debug(\"Created scanner \" + System.identityHashCode(bs));\n-            if (log.isTraceEnabled()) {\n-                log.trace(\"Adding instance \" + bs.hashCode());\n-            }\n-            instances.add(bs);\n-            return bs;\n-        } else {\n-            throw new IllegalStateException(\"Factory has been locked. No new scanners can be created.\");\n-        }\n-    }\n-    \n-    public BatchScanner newScanner(String tableName, Set<Authorizations> auths, Query query) throws TableNotFoundException {\n-        return newScanner(tableName, auths, 1, query);\n-    }\n-    \n-    public BatchScanner newScanner(String tableName, Query query) throws TableNotFoundException {\n-        return newScanner(tableName, Collections.singleton(Authorizations.EMPTY), query);\n-    }\n-    \n-    /**\n-     * Builds a new scanner session using a finalized table name and set of authorizations using the previously defined queue. Note that the number of entries\n-     * is hardcoded, below, to 1000, but can be changed\n-     * \n-     * @param tableName\n-     * @param auths\n-     * @return\n-     * @throws Exception\n-     */\n-    public synchronized BatchScannerSession newQueryScanner(final String tableName, final Set<Authorizations> auths, Query settings) throws Exception {\n-        \n-        return newLimitedScanner(BatchScannerSession.class, tableName, auths, settings).setThreads(scanQueue.getCapacity());\n+\n+  protected int maxQueue = 1000;\n+  protected HashSet<ScannerBase> instances = new HashSet<>();\n+  protected HashSet<ScannerSession> sessionInstances = new HashSet<>();\n+  protected AccumuloClient cxn;\n+  protected boolean open = true;\n+  protected boolean accrueStats = false;\n+  protected Query settings;\n+  protected ResourceQueue scanQueue = null;\n+  ShardQueryConfiguration config = null;\n+\n+  private static final Logger log = Logger.getLogger(ScannerFactory.class);\n+\n+  public ScannerFactory(GenericQueryConfiguration queryConfiguration) {\n+\n+    this.cxn = queryConfiguration.getClient();\n+\n+    if (queryConfiguration instanceof ShardQueryConfiguration) {\n+      this.settings = ((ShardQueryConfiguration) queryConfiguration).getQuery();\n+      this.accrueStats = ((ShardQueryConfiguration) queryConfiguration).getAccrueStats();\n     }\n-    \n-    /**\n-     * Builds a new scanner session using a finalized table name and set of authorizations using the previously defined queue. Note that the number of entries\n-     * is hardcoded, below, to 1000, but can be changed\n-     * \n-     * @param tableName\n-     * @param auths\n-     * @return\n-     * @throws Exception\n-     */\n-    public synchronized <T extends ScannerSession> T newLimitedScanner(Class<T> wrapper, final String tableName, final Set<Authorizations> auths,\n-                    final Query settings) throws Exception {\n-        Preconditions.checkNotNull(scanQueue);\n-        Preconditions.checkNotNull(wrapper);\n-        Preconditions.checkArgument(open, \"Factory has been locked. No New scanners can be created\");\n-        \n-        log.debug(\"Creating limited scanner whose max threads is is \" + scanQueue.getCapacity() + \" and max capacity is \" + maxQueue);\n-        \n-        ScanSessionStats stats = null;\n-        if (accrueStats) {\n-            stats = new ScanSessionStats();\n-        }\n-        \n-        T session = null;\n-        if (wrapper == ScannerSession.class) {\n-            session = (T) new ScannerSession(tableName, auths, scanQueue, maxQueue, settings).applyStats(stats);\n-        } else {\n-            session = wrapper.getConstructor(ScannerSession.class).newInstance(\n-                            new ScannerSession(tableName, auths, scanQueue, maxQueue, settings).applyStats(stats));\n-        }\n-        \n-        log.debug(\"Created session \" + System.identityHashCode(session));\n-        if (log.isTraceEnabled()) {\n-            log.trace(\"Adding instance \" + session.hashCode());\n-        }\n-        sessionInstances.add(session);\n-        \n-        return session;\n+    log.debug(\"Created scanner factory \" + System.identityHashCode(this) + \" is wrapped ? \" +\n+        (cxn instanceof WrappedConnector));\n+\n+    if (queryConfiguration instanceof ShardQueryConfiguration) {\n+      config = ((ShardQueryConfiguration) queryConfiguration);\n+      maxQueue = ((ShardQueryConfiguration) queryConfiguration).getMaxScannerBatchSize();\n+      this.settings = ((ShardQueryConfiguration) queryConfiguration).getQuery();\n+      try {\n+        scanQueue = new ResourceQueue(((ShardQueryConfiguration) queryConfiguration).getNumQueryThreads(), this.cxn);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n     }\n-    \n-    /**\n-     * Builds a new scanner session using a finalized table name and set of authorizations using the previously defined queue. Note that the number of entries\n-     * is hardcoded, below, to 1000, but can be changed\n-     * \n-     * @param tableName\n-     * @param auths\n-     * @return\n-     * @throws Exception\n-     */\n-    public synchronized RangeStreamScanner newRangeScanner(final String tableName, final Set<Authorizations> auths, final Query settings) throws Exception {\n-        return newRangeScanner(tableName, auths, settings, Integer.MAX_VALUE);\n+  }\n+\n+  public ScannerFactory(AccumuloClient client) {\n+    this(client, 100);\n+\n+  }\n+\n+  public ScannerFactory(AccumuloClient client, int queueSize) {\n+    try {\n+      this.cxn = client;\n+      scanQueue = new ResourceQueue(queueSize, client);\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n     }\n-    \n-    public RangeStreamScanner newRangeScanner(String tableName, Set<Authorizations> auths, Query query, int shardsPerDayThreshold) throws Exception {\n-        return newLimitedScanner(RangeStreamScanner.class, tableName, auths, settings).setShardsPerDayThreshold(shardsPerDayThreshold).setScannerFactory(this);\n+  }\n+\n+  public synchronized Scanner newSingleScanner(String tableName, Set<Authorizations> auths, Query query)\n+      throws TableNotFoundException {\n+    if (open) {\n+      Scanner bs = QueryScannerHelper.createScannerWithoutInfo(cxn, tableName, auths, query);\n+      log.debug(\"Created scanner \" + System.identityHashCode(bs));\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Adding instance \" + bs.hashCode());\n+      }\n+\n+      return bs;\n+    } else {\n+      throw new IllegalStateException(\"Factory has been locked. No new scanners can be created.\");\n     }\n-    \n-    public RangeStreamScanner newCondensedRangeScanner(String tableName, Set<Authorizations> auths, Query query, int shardsPerDayThreshold) throws Exception {\n-        return newLimitedScanner(CondensedRangeStreamScanner.class, tableName, auths, settings).setShardsPerDayThreshold(shardsPerDayThreshold)\n-                        .setScannerFactory(this);\n+  }\n+\n+  public synchronized BatchScanner newScanner(String tableName, Set<Authorizations> auths, int threads, Query query)\n+      throws TableNotFoundException {\n+    if (open) {\n+      BatchScanner bs = QueryScannerHelper.createBatchScanner(cxn, tableName, auths, threads, query);\n+      log.debug(\"Created scanner \" + System.identityHashCode(bs));\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Adding instance \" + bs.hashCode());\n+      }\n+      instances.add(bs);\n+      return bs;\n+    } else {\n+      throw new IllegalStateException(\"Factory has been locked. No new scanners can be created.\");\n     }\n-    \n-    public synchronized boolean close(ScannerBase bs) {\n-        boolean removed = instances.remove(bs);\n-        if (removed) {\n-            log.debug(\"Closed scanner \" + System.identityHashCode(bs));\n-            if (log.isTraceEnabled()) {\n-                log.trace(\"Closing instance \" + bs.hashCode());\n-            }\n-            bs.close();\n-        }\n-        return removed;\n+  }\n+\n+  public synchronized BatchScanner newScanner(String tableName, Set<Authorizations> auths, int threads, Query query,\n+                                              boolean reportErrors)\n+      throws TableNotFoundException {\n+    if (open) {\n+      BatchScanner bs = QueryScannerHelper.createBatchScanner(cxn, tableName, auths, threads, query, reportErrors);\n+      log.debug(\"Created scanner \" + System.identityHashCode(bs));\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Adding instance \" + bs.hashCode());\n+      }\n+      instances.add(bs);\n+      return bs;\n+    } else {\n+      throw new IllegalStateException(\"Factory has been locked. No new scanners can be created.\");\n     }\n-    \n-    public synchronized Collection<ScannerBase> currentScanners() {\n-        return Collections.unmodifiableSet(instances);\n+  }\n+\n+  public BatchScanner newScanner(String tableName, Set<Authorizations> auths, Query query)\n+      throws TableNotFoundException {\n+    return newScanner(tableName, auths, 1, query);\n+  }\n+\n+  public BatchScanner newScanner(String tableName, Query query) throws TableNotFoundException {\n+    return newScanner(tableName, Collections.singleton(Authorizations.EMPTY), query);\n+  }\n+\n+  /**\n+   * Builds a new scanner session using a finalized table name and set of authorizations using the previously defined queue. Note that the number of entries\n+   * is hardcoded, below, to 1000, but can be changed\n+   *\n+   * @param tableName\n+   * @param auths\n+   * @return\n+   * @throws Exception\n+   */\n+  public synchronized BatchScannerSession newQueryScanner(final String tableName, final Set<Authorizations> auths,\n+                                                          Query settings) throws Exception {\n+\n+    return newLimitedScanner(BatchScannerSession.class, tableName, auths, settings).setThreads(scanQueue.getCapacity());\n+  }\n+\n+  /**\n+   * Builds a new scanner session using a finalized table name and set of authorizations using the previously defined queue. Note that the number of entries\n+   * is hardcoded, below, to 1000, but can be changed\n+   *\n+   * @param tableName\n+   * @param auths\n+   * @return\n+   * @throws Exception\n+   */\n+  public synchronized <T extends ScannerSession> T newLimitedScanner(Class<T> wrapper, final String tableName,\n+                                                                     final Set<Authorizations> auths,\n+                                                                     final Query settings) throws Exception {\n+    Preconditions.checkNotNull(scanQueue);\n+    Preconditions.checkNotNull(wrapper);\n+    Preconditions.checkArgument(open, \"Factory has been locked. No New scanners can be created\");\n+\n+    log.debug(\"Creating limited scanner whose max threads is is \" + scanQueue.getCapacity() + \" and max capacity is \" +\n+        maxQueue);\n+\n+    ScanSessionStats stats = null;\n+    if (accrueStats) {\n+      stats = new ScanSessionStats();\n     }\n-    \n-    public synchronized Collection<ScannerSession> currentSessions() {\n-        return Collections.unmodifiableSet(sessionInstances);\n+\n+    T session = null;\n+    if (wrapper == ScannerSession.class) {\n+      session = (T) new ScannerSession(tableName, auths, scanQueue, maxQueue, settings).applyStats(stats);\n+    } else {\n+      session = wrapper.getConstructor(ScannerSession.class).newInstance(\n+          new ScannerSession(tableName, auths, scanQueue, maxQueue, settings).applyStats(stats));\n     }\n-    \n-    public synchronized boolean lockdown() {\n-        log.debug(\"Locked scanner factory \" + System.identityHashCode(this));\n-        if (log.isTraceEnabled()) {\n-            log.trace(\"Locked down with following stacktrace\", new Exception(\"stacktrace for debugging\"));\n-        }\n-        \n-        open = false;\n-        return open;\n+\n+    log.debug(\"Created session \" + System.identityHashCode(session));\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"Adding instance \" + session.hashCode());\n     }\n-    \n-    /**\n-     * @param bs\n-     */\n-    public void close(ScannerSession bs) {\n-        try {\n-            log.debug(\"Closed session \" + System.identityHashCode(bs));\n-            sessionInstances.remove(bs);\n-            if (log.isTraceEnabled()) {\n-                log.trace(\"Closing instance \" + bs.hashCode());\n-            }\n-            bs.close();\n-        } catch (Exception e) {\n-            // ANY EXCEPTION HERE CAN SAFELY BE IGNORED\n-            log.trace(\"Exception closing ScannerSession, can be safely ignored: {}\", e);\n-        }\n+    sessionInstances.add(session);\n+\n+    return session;\n+  }\n+\n+  /**\n+   * Builds a new scanner session using a finalized table name and set of authorizations using the previously defined queue. Note that the number of entries\n+   * is hardcoded, below, to 1000, but can be changed\n+   *\n+   * @param tableName\n+   * @param auths\n+   * @return\n+   * @throws Exception\n+   */\n+  public synchronized RangeStreamScanner newRangeScanner(final String tableName, final Set<Authorizations> auths,\n+                                                         final Query settings) throws Exception {\n+    return newRangeScanner(tableName, auths, settings, Integer.MAX_VALUE);\n+  }\n+\n+  public RangeStreamScanner newRangeScanner(String tableName, Set<Authorizations> auths, Query query,\n+                                            int shardsPerDayThreshold) throws Exception {\n+    return newLimitedScanner(RangeStreamScanner.class, tableName, auths, settings)\n+        .setShardsPerDayThreshold(shardsPerDayThreshold).setScannerFactory(this);\n+  }\n+\n+  public RangeStreamScanner newCondensedRangeScanner(String tableName, Set<Authorizations> auths, Query query,\n+                                                     int shardsPerDayThreshold) throws Exception {\n+    return newLimitedScanner(CondensedRangeStreamScanner.class, tableName, auths, settings)\n+        .setShardsPerDayThreshold(shardsPerDayThreshold)\n+        .setScannerFactory(this);\n+  }\n+\n+  public synchronized boolean close(ScannerBase bs) {\n+    boolean removed = instances.remove(bs);\n+    if (removed) {\n+      log.debug(\"Closed scanner \" + System.identityHashCode(bs));\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Closing instance \" + bs.hashCode());\n+      }\n+      bs.close();\n     }\n-    \n-    public void setMaxQueue(int size) {\n-        this.maxQueue = size;\n+    return removed;\n+  }\n+\n+  public synchronized Collection<ScannerBase> currentScanners() {\n+    return Collections.unmodifiableSet(instances);\n+  }\n+\n+  public synchronized Collection<ScannerSession> currentSessions() {\n+    return Collections.unmodifiableSet(sessionInstances);\n+  }\n+\n+  public synchronized boolean lockdown() {\n+    log.debug(\"Locked scanner factory \" + System.identityHashCode(this));\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"Locked down with following stacktrace\", new Exception(\"stacktrace for debugging\"));\n     }\n-    \n-    public synchronized ScannerBase newRfileScanner(String tableName, Set<Authorizations> auths, Query setting) {\n-        Configuration conf = new Configuration();\n-        \n-        AccumuloClient con = cxn;\n-        \n-        Properties clientProps = con.properties();\n-        final String instanceName = clientProps.getProperty(ClientProperty.INSTANCE_NAME.getKey());\n-        final String zookeepers = clientProps.getProperty(ClientProperty.INSTANCE_ZOOKEEPERS.getKey());\n-        \n-        AccumuloHelper.setInstanceName(conf, instanceName);\n-        AccumuloHelper.setUsername(conf, con.whoami());\n-        \n-        AccumuloHelper.setZooKeepers(conf, zookeepers);\n-        BulkInputFormat.setZooKeeperInstance(conf, instanceName, zookeepers);\n-        \n-        AccumuloHelper.setPassword(conf, config.getAccumuloPassword().getBytes());\n-        BulkInputFormat.setMemoryInput(conf, con.whoami(), config.getAccumuloPassword().getBytes(), tableName, auths.iterator().next());\n-        \n-        conf.set(MultiRfileInputformat.CACHE_METADATA, \"true\");\n-        \n-        ScannerBase baseScanner = new RfileScanner(con, conf, tableName, auths, 1);\n-        \n-        instances.add(baseScanner);\n-        \n-        return baseScanner;\n+\n+    open = false;\n+    return open;\n+  }\n+\n+  /**\n+   * @param bs\n+   */\n+  public void close(ScannerSession bs) {\n+    try {\n+      log.debug(\"Closed session \" + System.identityHashCode(bs));\n+      sessionInstances.remove(bs);\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Closing instance \" + bs.hashCode());\n+      }\n+      bs.close();\n+    } catch (Exception e) {\n+      // ANY EXCEPTION HERE CAN SAFELY BE IGNORED\n+      log.trace(\"Exception closing ScannerSession, can be safely ignored: {}\", e);\n     }\n+  }\n+\n+  public void setMaxQueue(int size) {\n+    this.maxQueue = size;\n+  }\n+\n+  public synchronized ScannerBase newRfileScanner(String tableName, Set<Authorizations> auths, Query setting) {\n+    Configuration conf = new Configuration();\n+\n+    AccumuloClient con = cxn;\n+\n+    Properties clientProps = con.properties();\n+    final String instanceName = clientProps.getProperty(ClientProperty.INSTANCE_NAME.getKey());\n+    final String zookeepers = clientProps.getProperty(ClientProperty.INSTANCE_ZOOKEEPERS.getKey());\n+\n+    AccumuloHelper.setInstanceName(conf, instanceName);\n+    AccumuloHelper.setUsername(conf, con.whoami());\n+\n+    AccumuloHelper.setZooKeepers(conf, zookeepers);\n+    BulkInputFormat.setZooKeeperInstance(conf, instanceName, zookeepers);\n+\n+    AccumuloHelper.setPassword(conf, config.getAccumuloPassword().getBytes());\n+    BulkInputFormat.setMemoryInput(conf, con.whoami(), config.getAccumuloPassword().getBytes(), tableName,\n+        auths.iterator().next());\n+\n+    conf.set(MultiRfileInputformat.CACHE_METADATA, \"true\");\n+\n+    ScannerBase baseScanner = new RfileScanner(con, conf, tableName, auths, 1);\n+\n+    instances.add(baseScanner);\n+\n+    return baseScanner;\n+  }\n }\n",
            "diff_size": 385
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "25",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/114/ScannerFactory.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/114/ScannerFactory.java\nindex 642da6f56a6..0386254289b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/114/ScannerFactory.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/114/ScannerFactory.java\n@@ -285,4 +285,4 @@ public class ScannerFactory {\n         \n         return baseScanner;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "23",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/114/ScannerFactory.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/114/ScannerFactory.java\nindex 642da6f56a6..a91e370bc3f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/114/ScannerFactory.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/114/ScannerFactory.java\n@@ -5,7 +5,6 @@ import java.util.Collections;\n import java.util.HashSet;\n import java.util.Properties;\n import java.util.Set;\n-\n import datawave.ingest.data.config.ingest.AccumuloHelper;\n import datawave.mr.bulk.BulkInputFormat;\n import datawave.mr.bulk.MultiRfileInputformat;\n@@ -16,7 +15,6 @@ import datawave.query.util.QueryScannerHelper;\n import datawave.webservice.common.connection.WrappedConnector;\n import datawave.webservice.query.Query;\n import datawave.webservice.query.configuration.GenericQueryConfiguration;\n-\n import org.apache.accumulo.core.client.AccumuloClient;\n import org.apache.accumulo.core.client.BatchScanner;\n import org.apache.accumulo.core.client.Scanner;\n@@ -26,14 +24,15 @@ import org.apache.accumulo.core.conf.ClientProperty;\n import org.apache.accumulo.core.security.Authorizations;\n import org.apache.hadoop.conf.Configuration;\n import org.apache.log4j.Logger;\n-\n import com.google.common.base.Preconditions;\n \n /**\n  * \n  */\n+\n+\n public class ScannerFactory {\n-    \n+\n     protected int maxQueue = 1000;\n     protected HashSet<ScannerBase> instances = new HashSet<>();\n     protected HashSet<ScannerSession> sessionInstances = new HashSet<>();\n@@ -43,19 +42,15 @@ public class ScannerFactory {\n     protected Query settings;\n     protected ResourceQueue scanQueue = null;\n     ShardQueryConfiguration config = null;\n-    \n     private static final Logger log = Logger.getLogger(ScannerFactory.class);\n-    \n+\n     public ScannerFactory(GenericQueryConfiguration queryConfiguration) {\n-        \n         this.cxn = queryConfiguration.getClient();\n-        \n         if (queryConfiguration instanceof ShardQueryConfiguration) {\n             this.settings = ((ShardQueryConfiguration) queryConfiguration).getQuery();\n             this.accrueStats = ((ShardQueryConfiguration) queryConfiguration).getAccrueStats();\n         }\n         log.debug(\"Created scanner factory \" + System.identityHashCode(this) + \" is wrapped ? \" + (cxn instanceof WrappedConnector));\n-        \n         if (queryConfiguration instanceof ShardQueryConfiguration) {\n             config = ((ShardQueryConfiguration) queryConfiguration);\n             maxQueue = ((ShardQueryConfiguration) queryConfiguration).getMaxScannerBatchSize();\n@@ -67,12 +62,11 @@ public class ScannerFactory {\n             }\n         }\n     }\n-    \n+\n     public ScannerFactory(AccumuloClient client) {\n         this(client, 100);\n-        \n     }\n-    \n+\n     public ScannerFactory(AccumuloClient client, int queueSize) {\n         try {\n             this.cxn = client;\n@@ -81,7 +75,7 @@ public class ScannerFactory {\n             throw new RuntimeException(e);\n         }\n     }\n-    \n+\n     public synchronized Scanner newSingleScanner(String tableName, Set<Authorizations> auths, Query query) throws TableNotFoundException {\n         if (open) {\n             Scanner bs = QueryScannerHelper.createScannerWithoutInfo(cxn, tableName, auths, query);\n@@ -89,13 +83,12 @@ public class ScannerFactory {\n             if (log.isTraceEnabled()) {\n                 log.trace(\"Adding instance \" + bs.hashCode());\n             }\n-            \n             return bs;\n         } else {\n             throw new IllegalStateException(\"Factory has been locked. No new scanners can be created.\");\n         }\n     }\n-    \n+\n     public synchronized BatchScanner newScanner(String tableName, Set<Authorizations> auths, int threads, Query query) throws TableNotFoundException {\n         if (open) {\n             BatchScanner bs = QueryScannerHelper.createBatchScanner(cxn, tableName, auths, threads, query);\n@@ -109,9 +102,8 @@ public class ScannerFactory {\n             throw new IllegalStateException(\"Factory has been locked. No new scanners can be created.\");\n         }\n     }\n-    \n-    public synchronized BatchScanner newScanner(String tableName, Set<Authorizations> auths, int threads, Query query, boolean reportErrors)\n-                    throws TableNotFoundException {\n+\n+    public synchronized BatchScanner newScanner(String tableName, Set<Authorizations> auths, int threads, Query query, boolean reportErrors) throws TableNotFoundException {\n         if (open) {\n             BatchScanner bs = QueryScannerHelper.createBatchScanner(cxn, tableName, auths, threads, query, reportErrors);\n             log.debug(\"Created scanner \" + System.identityHashCode(bs));\n@@ -124,11 +116,11 @@ public class ScannerFactory {\n             throw new IllegalStateException(\"Factory has been locked. No new scanners can be created.\");\n         }\n     }\n-    \n+\n     public BatchScanner newScanner(String tableName, Set<Authorizations> auths, Query query) throws TableNotFoundException {\n         return newScanner(tableName, auths, 1, query);\n     }\n-    \n+\n     public BatchScanner newScanner(String tableName, Query query) throws TableNotFoundException {\n         return newScanner(tableName, Collections.singleton(Authorizations.EMPTY), query);\n     }\n@@ -142,8 +134,8 @@ public class ScannerFactory {\n      * @return\n      * @throws Exception\n      */\n+\n     public synchronized BatchScannerSession newQueryScanner(final String tableName, final Set<Authorizations> auths, Query settings) throws Exception {\n-        \n         return newLimitedScanner(BatchScannerSession.class, tableName, auths, settings).setThreads(scanQueue.getCapacity());\n     }\n     \n@@ -156,33 +148,29 @@ public class ScannerFactory {\n      * @return\n      * @throws Exception\n      */\n-    public synchronized <T extends ScannerSession> T newLimitedScanner(Class<T> wrapper, final String tableName, final Set<Authorizations> auths,\n-                    final Query settings) throws Exception {\n+\n+    public synchronized <T extends ScannerSession> T newLimitedScanner(Class<T> wrapper, final String tableName, final Set<Authorizations> auths, final Query settings) throws Exception {\n         Preconditions.checkNotNull(scanQueue);\n         Preconditions.checkNotNull(wrapper);\n         Preconditions.checkArgument(open, \"Factory has been locked. No New scanners can be created\");\n-        \n         log.debug(\"Creating limited scanner whose max threads is is \" + scanQueue.getCapacity() + \" and max capacity is \" + maxQueue);\n-        \n+\n         ScanSessionStats stats = null;\n         if (accrueStats) {\n             stats = new ScanSessionStats();\n         }\n-        \n+\n         T session = null;\n         if (wrapper == ScannerSession.class) {\n             session = (T) new ScannerSession(tableName, auths, scanQueue, maxQueue, settings).applyStats(stats);\n         } else {\n-            session = wrapper.getConstructor(ScannerSession.class).newInstance(\n-                            new ScannerSession(tableName, auths, scanQueue, maxQueue, settings).applyStats(stats));\n+            session = wrapper.getConstructor(ScannerSession.class).newInstance(new ScannerSession(tableName, auths, scanQueue, maxQueue, settings).applyStats(stats));\n         }\n-        \n         log.debug(\"Created session \" + System.identityHashCode(session));\n         if (log.isTraceEnabled()) {\n             log.trace(\"Adding instance \" + session.hashCode());\n         }\n         sessionInstances.add(session);\n-        \n         return session;\n     }\n     \n@@ -195,19 +183,19 @@ public class ScannerFactory {\n      * @return\n      * @throws Exception\n      */\n+\n     public synchronized RangeStreamScanner newRangeScanner(final String tableName, final Set<Authorizations> auths, final Query settings) throws Exception {\n         return newRangeScanner(tableName, auths, settings, Integer.MAX_VALUE);\n     }\n-    \n+\n     public RangeStreamScanner newRangeScanner(String tableName, Set<Authorizations> auths, Query query, int shardsPerDayThreshold) throws Exception {\n         return newLimitedScanner(RangeStreamScanner.class, tableName, auths, settings).setShardsPerDayThreshold(shardsPerDayThreshold).setScannerFactory(this);\n     }\n-    \n+\n     public RangeStreamScanner newCondensedRangeScanner(String tableName, Set<Authorizations> auths, Query query, int shardsPerDayThreshold) throws Exception {\n-        return newLimitedScanner(CondensedRangeStreamScanner.class, tableName, auths, settings).setShardsPerDayThreshold(shardsPerDayThreshold)\n-                        .setScannerFactory(this);\n+        return newLimitedScanner(CondensedRangeStreamScanner.class, tableName, auths, settings).setShardsPerDayThreshold(shardsPerDayThreshold).setScannerFactory(this);\n     }\n-    \n+\n     public synchronized boolean close(ScannerBase bs) {\n         boolean removed = instances.remove(bs);\n         if (removed) {\n@@ -219,21 +207,20 @@ public class ScannerFactory {\n         }\n         return removed;\n     }\n-    \n+\n     public synchronized Collection<ScannerBase> currentScanners() {\n         return Collections.unmodifiableSet(instances);\n     }\n-    \n+\n     public synchronized Collection<ScannerSession> currentSessions() {\n         return Collections.unmodifiableSet(sessionInstances);\n     }\n-    \n+\n     public synchronized boolean lockdown() {\n         log.debug(\"Locked scanner factory \" + System.identityHashCode(this));\n         if (log.isTraceEnabled()) {\n             log.trace(\"Locked down with following stacktrace\", new Exception(\"stacktrace for debugging\"));\n         }\n-        \n         open = false;\n         return open;\n     }\n@@ -241,6 +228,7 @@ public class ScannerFactory {\n     /**\n      * @param bs\n      */\n+\n     public void close(ScannerSession bs) {\n         try {\n             log.debug(\"Closed session \" + System.identityHashCode(bs));\n@@ -254,35 +242,27 @@ public class ScannerFactory {\n             log.trace(\"Exception closing ScannerSession, can be safely ignored: {}\", e);\n         }\n     }\n-    \n+\n     public void setMaxQueue(int size) {\n         this.maxQueue = size;\n     }\n-    \n+\n     public synchronized ScannerBase newRfileScanner(String tableName, Set<Authorizations> auths, Query setting) {\n         Configuration conf = new Configuration();\n-        \n         AccumuloClient con = cxn;\n-        \n         Properties clientProps = con.properties();\n         final String instanceName = clientProps.getProperty(ClientProperty.INSTANCE_NAME.getKey());\n         final String zookeepers = clientProps.getProperty(ClientProperty.INSTANCE_ZOOKEEPERS.getKey());\n-        \n         AccumuloHelper.setInstanceName(conf, instanceName);\n         AccumuloHelper.setUsername(conf, con.whoami());\n-        \n         AccumuloHelper.setZooKeepers(conf, zookeepers);\n         BulkInputFormat.setZooKeeperInstance(conf, instanceName, zookeepers);\n-        \n         AccumuloHelper.setPassword(conf, config.getAccumuloPassword().getBytes());\n         BulkInputFormat.setMemoryInput(conf, con.whoami(), config.getAccumuloPassword().getBytes(), tableName, auths.iterator().next());\n-        \n         conf.set(MultiRfileInputformat.CACHE_METADATA, \"true\");\n-        \n+\n         ScannerBase baseScanner = new RfileScanner(con, conf, tableName, auths, 1);\n-        \n         instances.add(baseScanner);\n-        \n         return baseScanner;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 56
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "25",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "25",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}