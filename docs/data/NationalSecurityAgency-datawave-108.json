{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "108",
    "information": {
        "errors": [
            {
                "line": "27",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import org.apache.accumulo.core.data.Range;\nimport org.apache.accumulo.core.dataImpl.KeyExtent;\nimport org.apache.accumulo.core.master.state.tables.TableState;\nimport org.apache.commons.jexl2.parser.ParseException;\nimport org.apache.hadoop.io.Text;\nimport org.apache.log4j.Logger;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "27",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "27",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/108/PushdownFunction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/108/PushdownFunction.java\nindex a9cecbe0741..027428b5284 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/108/PushdownFunction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/108/PushdownFunction.java\n@@ -41,192 +41,204 @@ import datawave.query.tables.SessionOptions;\n import datawave.query.tables.async.ScannerChunk;\n import datawave.webservice.query.configuration.QueryData;\n \n-public class PushdownFunction implements Function<QueryData,List<ScannerChunk>> {\n-    \n-    /**\n-     * Logger\n-     */\n-    private static final Logger log = Logger.getLogger(PushdownFunction.class);\n-    \n-    /**\n-     * Configuration object\n-     */\n-    private ShardQueryConfiguration config;\n-    \n-    /**\n-     * Tablet locator\n-     */\n-    private TabletLocator tl;\n-    \n-    /**\n-     * Set of query plans\n-     */\n-    protected Set<Integer> queryPlanSet;\n-    protected Collection<IteratorSetting> customSettings;\n-    \n-    protected TableId tableId;\n-    \n-    public PushdownFunction(TabletLocator tl, ShardQueryConfiguration config, Collection<IteratorSetting> settings, TableId tableId) {\n-        this.tl = tl;\n-        this.config = config;\n-        queryPlanSet = Sets.newHashSet();\n-        this.customSettings = settings;\n-        this.tableId = tableId;\n-        \n-    }\n-    \n-    public List<ScannerChunk> apply(QueryData qd) {\n-        Multimap<String,QueryPlan> serverPlan = ArrayListMultimap.create();\n-        List<ScannerChunk> chunks = Lists.newArrayList();\n-        try {\n-            \n-            redistributeQueries(serverPlan, tl, new QueryPlan(qd));\n-            \n-            for (String server : serverPlan.keySet()) {\n-                Collection<QueryPlan> plans = serverPlan.get(server);\n-                Set<QueryPlan> reducedSet = Sets.newHashSet(plans);\n-                for (QueryPlan plan : reducedSet) {\n-                    Integer hashCode = plan.hashCode();\n-                    if (queryPlanSet.contains(hashCode)) {\n-                        continue;\n-                    } else\n-                        queryPlanSet.clear();\n-                    \n-                    queryPlanSet.add(hashCode);\n-                    try {\n-                        \n-                        SessionOptions options = new SessionOptions();\n-                        \n-                        if (log.isTraceEnabled()) {\n-                            log.trace(\"setting ranges\" + plan.getRanges());\n-                            log.trace(\"range set size\" + plan.getSettings().size());\n-                        }\n-                        for (IteratorSetting setting : plan.getSettings()) {\n-                            options.addScanIterator(setting);\n-                        }\n-                        \n-                        for (IteratorSetting setting : customSettings) {\n-                            options.addScanIterator(setting);\n-                        }\n-                        \n-                        for (String cf : plan.getColumnFamilies()) {\n-                            options.fetchColumnFamily(new Text(cf));\n-                        }\n-                        \n-                        options.setQueryConfig(this.config);\n-                        \n-                        chunks.add(new ScannerChunk(options, Lists.newArrayList(plan.getRanges()), server));\n-                        \n-                    } catch (Exception e) {\n-                        log.error(e);\n-                        throw new AccumuloException(e);\n-                    }\n-                }\n+public class PushdownFunction implements Function<QueryData, List<ScannerChunk>> {\n+\n+  /**\n+   * Logger\n+   */\n+  private static final Logger log = Logger.getLogger(PushdownFunction.class);\n+\n+  /**\n+   * Configuration object\n+   */\n+  private ShardQueryConfiguration config;\n+\n+  /**\n+   * Tablet locator\n+   */\n+  private TabletLocator tl;\n+\n+  /**\n+   * Set of query plans\n+   */\n+  protected Set<Integer> queryPlanSet;\n+  protected Collection<IteratorSetting> customSettings;\n+\n+  protected TableId tableId;\n+\n+  public PushdownFunction(TabletLocator tl, ShardQueryConfiguration config, Collection<IteratorSetting> settings,\n+                          TableId tableId) {\n+    this.tl = tl;\n+    this.config = config;\n+    queryPlanSet = Sets.newHashSet();\n+    this.customSettings = settings;\n+    this.tableId = tableId;\n+\n+  }\n+\n+  public List<ScannerChunk> apply(QueryData qd) {\n+    Multimap<String, QueryPlan> serverPlan = ArrayListMultimap.create();\n+    List<ScannerChunk> chunks = Lists.newArrayList();\n+    try {\n+\n+      redistributeQueries(serverPlan, tl, new QueryPlan(qd));\n+\n+      for (String server : serverPlan.keySet()) {\n+        Collection<QueryPlan> plans = serverPlan.get(server);\n+        Set<QueryPlan> reducedSet = Sets.newHashSet(plans);\n+        for (QueryPlan plan : reducedSet) {\n+          Integer hashCode = plan.hashCode();\n+          if (queryPlanSet.contains(hashCode)) {\n+            continue;\n+          } else {\n+            queryPlanSet.clear();\n+          }\n+\n+          queryPlanSet.add(hashCode);\n+          try {\n+\n+            SessionOptions options = new SessionOptions();\n+\n+            if (log.isTraceEnabled()) {\n+              log.trace(\"setting ranges\" + plan.getRanges());\n+              log.trace(\"range set size\" + plan.getSettings().size());\n+            }\n+            for (IteratorSetting setting : plan.getSettings()) {\n+              options.addScanIterator(setting);\n+            }\n+\n+            for (IteratorSetting setting : customSettings) {\n+              options.addScanIterator(setting);\n             }\n-            \n-        } catch (AccumuloException e) {\n-            throw new RuntimeException(e);\n-        } catch (AccumuloSecurityException e) {\n-            throw new RuntimeException(e);\n-        } catch (TableNotFoundException e) {\n-            throw new RuntimeException(e);\n-        } catch (ParseException e) {\n-            throw new RuntimeException(e);\n+\n+            for (String cf : plan.getColumnFamilies()) {\n+              options.fetchColumnFamily(new Text(cf));\n+            }\n+\n+            options.setQueryConfig(this.config);\n+\n+            chunks.add(new ScannerChunk(options, Lists.newArrayList(plan.getRanges()), server));\n+\n+          } catch (Exception e) {\n+            log.error(e);\n+            throw new AccumuloException(e);\n+          }\n         }\n-        return chunks;\n+      }\n+\n+    } catch (AccumuloException e) {\n+      throw new RuntimeException(e);\n+    } catch (AccumuloSecurityException e) {\n+      throw new RuntimeException(e);\n+    } catch (TableNotFoundException e) {\n+      throw new RuntimeException(e);\n+    } catch (ParseException e) {\n+      throw new RuntimeException(e);\n     }\n-    \n-    protected void redistributeQueries(Multimap<String,QueryPlan> serverPlan, TabletLocator tl, QueryPlan currentPlan) throws AccumuloException,\n-                    AccumuloSecurityException, TableNotFoundException {\n-        \n-        List<Range> ranges = Lists.newArrayList(currentPlan.getRanges());\n-        if (!ranges.isEmpty()) {\n-            Map<String,Map<KeyExtent,List<Range>>> binnedRanges = binRanges(tl, config.getClient(), ranges);\n-            \n-            for (String server : binnedRanges.keySet()) {\n-                Map<KeyExtent,List<Range>> hostedExtentMap = binnedRanges.get(server);\n-                \n-                Iterable<Range> rangeIter = Lists.newArrayList();\n-                \n-                for (Map.Entry<KeyExtent,List<Range>> rangeEntry : hostedExtentMap.entrySet()) {\n-                    if (log.isTraceEnabled())\n-                        log.trace(\"Adding range from \" + rangeEntry.getValue());\n-                    rangeIter = Iterables.concat(rangeIter, rangeEntry.getValue());\n-                }\n-                \n-                if (log.isTraceEnabled())\n-                    log.trace(\"Adding query tree \" + JexlStringBuildingVisitor.buildQuery(currentPlan.getQueryTree()) + \" \" + currentPlan.getSettings().size()\n-                                    + \" for \" + server);\n-                \n-                serverPlan.put(server, new QueryPlan(currentPlan.getQueryTree(), rangeIter, currentPlan.getSettings(), currentPlan.getColumnFamilies()));\n-                \n-            }\n+    return chunks;\n+  }\n+\n+  protected void redistributeQueries(Multimap<String, QueryPlan> serverPlan, TabletLocator tl, QueryPlan currentPlan)\n+      throws AccumuloException,\n+      AccumuloSecurityException, TableNotFoundException {\n+\n+    List<Range> ranges = Lists.newArrayList(currentPlan.getRanges());\n+    if (!ranges.isEmpty()) {\n+      Map<String, Map<KeyExtent, List<Range>>> binnedRanges = binRanges(tl, config.getClient(), ranges);\n+\n+      for (String server : binnedRanges.keySet()) {\n+        Map<KeyExtent, List<Range>> hostedExtentMap = binnedRanges.get(server);\n+\n+        Iterable<Range> rangeIter = Lists.newArrayList();\n+\n+        for (Map.Entry<KeyExtent, List<Range>> rangeEntry : hostedExtentMap.entrySet()) {\n+          if (log.isTraceEnabled()) {\n+            log.trace(\"Adding range from \" + rangeEntry.getValue());\n+          }\n+          rangeIter = Iterables.concat(rangeIter, rangeEntry.getValue());\n         }\n-        \n+\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"Adding query tree \" + JexlStringBuildingVisitor.buildQuery(currentPlan.getQueryTree()) + \" \" +\n+              currentPlan.getSettings().size()\n+              + \" for \" + server);\n+        }\n+\n+        serverPlan.put(server, new QueryPlan(currentPlan.getQueryTree(), rangeIter, currentPlan.getSettings(),\n+            currentPlan.getColumnFamilies()));\n+\n+      }\n     }\n-    \n-    protected Map<String,Map<KeyExtent,List<Range>>> binRanges(TabletLocator tl, AccumuloClient client, List<Range> ranges) throws AccumuloException,\n-                    AccumuloSecurityException, TableNotFoundException {\n-        Map<String,Map<KeyExtent,List<Range>>> binnedRanges = new HashMap<>();\n-        \n-        int lastFailureSize = Integer.MAX_VALUE;\n-        \n-        while (true) {\n-            \n-            binnedRanges.clear();\n-            ClientContext ctx = AccumuloConnectionFactory.getClientContext(client);\n-            List<Range> failures = tl.binRanges(ctx, ranges, binnedRanges);\n-            \n-            if (!failures.isEmpty()) {\n-                // tried to only do table state checks when failures.size()\n-                // == ranges.size(), however this did\n-                // not work because nothing ever invalidated entries in the\n-                // tabletLocator cache... so even though\n-                // the table was deleted the tablet locator entries for the\n-                // deleted table were not cleared... so\n-                // need to always do the check when failures occur\n-                if (failures.size() >= lastFailureSize)\n-                    if (!Tables.exists(ctx, tableId))\n-                        throw new TableDeletedException(tableId.canonical());\n-                    else if (Tables.getTableState(ctx, tableId) == TableState.OFFLINE)\n-                        throw new TableOfflineException(\"Table \" + tableId + \" is offline\");\n-                \n-                lastFailureSize = failures.size();\n-                \n-                if (log.isTraceEnabled())\n-                    log.trace(\"Failed to bin \" + failures.size() + \" ranges, tablet locations were null, retrying in 100ms\");\n-                try {\n-                    Thread.sleep(100);\n-                } catch (InterruptedException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } else {\n-                break;\n-            }\n-            \n+\n+  }\n+\n+  protected Map<String, Map<KeyExtent, List<Range>>> binRanges(TabletLocator tl, AccumuloClient client,\n+                                                               List<Range> ranges) throws AccumuloException,\n+      AccumuloSecurityException, TableNotFoundException {\n+    Map<String, Map<KeyExtent, List<Range>>> binnedRanges = new HashMap<>();\n+\n+    int lastFailureSize = Integer.MAX_VALUE;\n+\n+    while (true) {\n+\n+      binnedRanges.clear();\n+      ClientContext ctx = AccumuloConnectionFactory.getClientContext(client);\n+      List<Range> failures = tl.binRanges(ctx, ranges, binnedRanges);\n+\n+      if (!failures.isEmpty()) {\n+        // tried to only do table state checks when failures.size()\n+        // == ranges.size(), however this did\n+        // not work because nothing ever invalidated entries in the\n+        // tabletLocator cache... so even though\n+        // the table was deleted the tablet locator entries for the\n+        // deleted table were not cleared... so\n+        // need to always do the check when failures occur\n+        if (failures.size() >= lastFailureSize) {\n+          if (!Tables.exists(ctx, tableId)) {\n+            throw new TableDeletedException(tableId.canonical());\n+          } else if (Tables.getTableState(ctx, tableId) == TableState.OFFLINE) {\n+            throw new TableOfflineException(\"Table \" + tableId + \" is offline\");\n+          }\n         }\n-        \n-        // truncate the ranges to within the tablets... this makes it easier\n-        // to know what work\n-        // needs to be redone when failures occurs and tablets have merged\n-        // or split\n-        Map<String,Map<KeyExtent,List<Range>>> binnedRanges2 = new HashMap<>();\n-        for (Map.Entry<String,Map<KeyExtent,List<Range>>> entry : binnedRanges.entrySet()) {\n-            Map<KeyExtent,List<Range>> tabletMap = new HashMap<>();\n-            binnedRanges2.put(entry.getKey(), tabletMap);\n-            for (Map.Entry<KeyExtent,List<Range>> tabletRanges : entry.getValue().entrySet()) {\n-                Range tabletRange = tabletRanges.getKey().toDataRange();\n-                List<Range> clippedRanges = new ArrayList<>();\n-                tabletMap.put(tabletRanges.getKey(), clippedRanges);\n-                for (Range range : tabletRanges.getValue())\n-                    clippedRanges.add(tabletRange.clip(range));\n-            }\n+\n+        lastFailureSize = failures.size();\n+\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"Failed to bin \" + failures.size() + \" ranges, tablet locations were null, retrying in 100ms\");\n         }\n-        \n-        binnedRanges.clear();\n-        binnedRanges.putAll(binnedRanges2);\n-        \n-        return binnedRanges;\n+        try {\n+          Thread.sleep(100);\n+        } catch (InterruptedException e) {\n+          throw new RuntimeException(e);\n+        }\n+      } else {\n+        break;\n+      }\n+\n     }\n-    \n+\n+    // truncate the ranges to within the tablets... this makes it easier\n+    // to know what work\n+    // needs to be redone when failures occurs and tablets have merged\n+    // or split\n+    Map<String, Map<KeyExtent, List<Range>>> binnedRanges2 = new HashMap<>();\n+    for (Map.Entry<String, Map<KeyExtent, List<Range>>> entry : binnedRanges.entrySet()) {\n+      Map<KeyExtent, List<Range>> tabletMap = new HashMap<>();\n+      binnedRanges2.put(entry.getKey(), tabletMap);\n+      for (Map.Entry<KeyExtent, List<Range>> tabletRanges : entry.getValue().entrySet()) {\n+        Range tabletRange = tabletRanges.getKey().toDataRange();\n+        List<Range> clippedRanges = new ArrayList<>();\n+        tabletMap.put(tabletRanges.getKey(), clippedRanges);\n+        for (Range range : tabletRanges.getValue()) {\n+          clippedRanges.add(tabletRange.clip(range));\n+        }\n+      }\n+    }\n+\n+    binnedRanges.clear();\n+    binnedRanges.putAll(binnedRanges2);\n+\n+    return binnedRanges;\n+  }\n+\n }\n",
            "diff_size": 231
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "27",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/108/PushdownFunction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/108/PushdownFunction.java\nindex a9cecbe0741..8505dc8c7b8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/108/PushdownFunction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/108/PushdownFunction.java\n@@ -94,8 +94,7 @@ public class PushdownFunction implements Function<QueryData,List<ScannerChunk>>\n                     \n                     queryPlanSet.add(hashCode);\n                     try {\n-                        \n-                        SessionOptions options = new SessionOptions();\n+    SessionOptions options = new SessionOptions();\n                         \n                         if (log.isTraceEnabled()) {\n                             log.trace(\"setting ranges\" + plan.getRanges());\n@@ -104,12 +103,10 @@ public class PushdownFunction implements Function<QueryData,List<ScannerChunk>>\n                         for (IteratorSetting setting : plan.getSettings()) {\n                             options.addScanIterator(setting);\n                         }\n-                        \n-                        for (IteratorSetting setting : customSettings) {\n+for (IteratorSetting setting : customSettings) {\n                             options.addScanIterator(setting);\n                         }\n-                        \n-                        for (String cf : plan.getColumnFamilies()) {\n+for (String cf : plan.getColumnFamilies()) {\n                             options.fetchColumnFamily(new Text(cf));\n                         }\n                         \n@@ -229,4 +226,4 @@ public class PushdownFunction implements Function<QueryData,List<ScannerChunk>>\n         return binnedRanges;\n     }\n     \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "26",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/108/PushdownFunction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/108/PushdownFunction.java\nindex a9cecbe0741..b96f16c537c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/108/PushdownFunction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/108/PushdownFunction.java\n@@ -6,7 +6,6 @@ import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n import datawave.query.config.ShardQueryConfiguration;\n import datawave.query.planner.QueryPlan;\n import datawave.webservice.common.connection.AccumuloConnectionFactory;\n@@ -28,19 +27,18 @@ import org.apache.accumulo.core.master.state.tables.TableState;\n import org.apache.commons.jexl2.parser.ParseException;\n import org.apache.hadoop.io.Text;\n import org.apache.log4j.Logger;\n-\n import com.google.common.base.Function;\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n-\n import datawave.query.jexl.visitors.JexlStringBuildingVisitor;\n import datawave.query.tables.SessionOptions;\n import datawave.query.tables.async.ScannerChunk;\n import datawave.webservice.query.configuration.QueryData;\n \n+\n public class PushdownFunction implements Function<QueryData,List<ScannerChunk>> {\n     \n     /**\n@@ -63,25 +61,22 @@ public class PushdownFunction implements Function<QueryData,List<ScannerChunk>>\n      */\n     protected Set<Integer> queryPlanSet;\n     protected Collection<IteratorSetting> customSettings;\n-    \n     protected TableId tableId;\n-    \n+\n     public PushdownFunction(TabletLocator tl, ShardQueryConfiguration config, Collection<IteratorSetting> settings, TableId tableId) {\n         this.tl = tl;\n         this.config = config;\n         queryPlanSet = Sets.newHashSet();\n         this.customSettings = settings;\n         this.tableId = tableId;\n-        \n     }\n-    \n+\n     public List<ScannerChunk> apply(QueryData qd) {\n         Multimap<String,QueryPlan> serverPlan = ArrayListMultimap.create();\n         List<ScannerChunk> chunks = Lists.newArrayList();\n         try {\n-            \n             redistributeQueries(serverPlan, tl, new QueryPlan(qd));\n-            \n+\n             for (String server : serverPlan.keySet()) {\n                 Collection<QueryPlan> plans = serverPlan.get(server);\n                 Set<QueryPlan> reducedSet = Sets.newHashSet(plans);\n@@ -91,12 +86,9 @@ public class PushdownFunction implements Function<QueryData,List<ScannerChunk>>\n                         continue;\n                     } else\n                         queryPlanSet.clear();\n-                    \n                     queryPlanSet.add(hashCode);\n                     try {\n-                        \n                         SessionOptions options = new SessionOptions();\n-                        \n                         if (log.isTraceEnabled()) {\n                             log.trace(\"setting ranges\" + plan.getRanges());\n                             log.trace(\"range set size\" + plan.getSettings().size());\n@@ -104,26 +96,20 @@ public class PushdownFunction implements Function<QueryData,List<ScannerChunk>>\n                         for (IteratorSetting setting : plan.getSettings()) {\n                             options.addScanIterator(setting);\n                         }\n-                        \n                         for (IteratorSetting setting : customSettings) {\n                             options.addScanIterator(setting);\n                         }\n-                        \n                         for (String cf : plan.getColumnFamilies()) {\n                             options.fetchColumnFamily(new Text(cf));\n                         }\n-                        \n                         options.setQueryConfig(this.config);\n-                        \n                         chunks.add(new ScannerChunk(options, Lists.newArrayList(plan.getRanges()), server));\n-                        \n                     } catch (Exception e) {\n                         log.error(e);\n                         throw new AccumuloException(e);\n                     }\n                 }\n             }\n-            \n         } catch (AccumuloException e) {\n             throw new RuntimeException(e);\n         } catch (AccumuloSecurityException e) {\n@@ -135,48 +121,36 @@ public class PushdownFunction implements Function<QueryData,List<ScannerChunk>>\n         }\n         return chunks;\n     }\n-    \n-    protected void redistributeQueries(Multimap<String,QueryPlan> serverPlan, TabletLocator tl, QueryPlan currentPlan) throws AccumuloException,\n-                    AccumuloSecurityException, TableNotFoundException {\n-        \n+\n+    protected void redistributeQueries(Multimap<String,QueryPlan> serverPlan, TabletLocator tl, QueryPlan currentPlan) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n         List<Range> ranges = Lists.newArrayList(currentPlan.getRanges());\n         if (!ranges.isEmpty()) {\n             Map<String,Map<KeyExtent,List<Range>>> binnedRanges = binRanges(tl, config.getClient(), ranges);\n-            \n             for (String server : binnedRanges.keySet()) {\n                 Map<KeyExtent,List<Range>> hostedExtentMap = binnedRanges.get(server);\n-                \n                 Iterable<Range> rangeIter = Lists.newArrayList();\n-                \n                 for (Map.Entry<KeyExtent,List<Range>> rangeEntry : hostedExtentMap.entrySet()) {\n                     if (log.isTraceEnabled())\n                         log.trace(\"Adding range from \" + rangeEntry.getValue());\n                     rangeIter = Iterables.concat(rangeIter, rangeEntry.getValue());\n                 }\n-                \n+\n+\n                 if (log.isTraceEnabled())\n-                    log.trace(\"Adding query tree \" + JexlStringBuildingVisitor.buildQuery(currentPlan.getQueryTree()) + \" \" + currentPlan.getSettings().size()\n-                                    + \" for \" + server);\n-                \n+                    log.trace(\"Adding query tree \" + JexlStringBuildingVisitor.buildQuery(currentPlan.getQueryTree()) + \" \" + currentPlan.getSettings().size() + \" for \" + server);\n                 serverPlan.put(server, new QueryPlan(currentPlan.getQueryTree(), rangeIter, currentPlan.getSettings(), currentPlan.getColumnFamilies()));\n-                \n             }\n         }\n-        \n     }\n-    \n-    protected Map<String,Map<KeyExtent,List<Range>>> binRanges(TabletLocator tl, AccumuloClient client, List<Range> ranges) throws AccumuloException,\n-                    AccumuloSecurityException, TableNotFoundException {\n+\n+    protected Map<String,Map<KeyExtent,List<Range>>> binRanges(TabletLocator tl, AccumuloClient client, List<Range> ranges) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n         Map<String,Map<KeyExtent,List<Range>>> binnedRanges = new HashMap<>();\n-        \n         int lastFailureSize = Integer.MAX_VALUE;\n-        \n         while (true) {\n-            \n             binnedRanges.clear();\n+\n             ClientContext ctx = AccumuloConnectionFactory.getClientContext(client);\n             List<Range> failures = tl.binRanges(ctx, ranges, binnedRanges);\n-            \n             if (!failures.isEmpty()) {\n                 // tried to only do table state checks when failures.size()\n                 // == ranges.size(), however this did\n@@ -187,12 +161,10 @@ public class PushdownFunction implements Function<QueryData,List<ScannerChunk>>\n                 // need to always do the check when failures occur\n                 if (failures.size() >= lastFailureSize)\n                     if (!Tables.exists(ctx, tableId))\n-                        throw new TableDeletedException(tableId.canonical());\n-                    else if (Tables.getTableState(ctx, tableId) == TableState.OFFLINE)\n+                    throw new TableDeletedException(tableId.canonical());\n+                else if (Tables.getTableState(ctx, tableId) == TableState.OFFLINE)\n                         throw new TableOfflineException(\"Table \" + tableId + \" is offline\");\n-                \n                 lastFailureSize = failures.size();\n-                \n                 if (log.isTraceEnabled())\n                     log.trace(\"Failed to bin \" + failures.size() + \" ranges, tablet locations were null, retrying in 100ms\");\n                 try {\n@@ -203,30 +175,29 @@ public class PushdownFunction implements Function<QueryData,List<ScannerChunk>>\n             } else {\n                 break;\n             }\n-            \n         }\n         \n         // truncate the ranges to within the tablets... this makes it easier\n         // to know what work\n         // needs to be redone when failures occurs and tablets have merged\n         // or split\n+\n         Map<String,Map<KeyExtent,List<Range>>> binnedRanges2 = new HashMap<>();\n         for (Map.Entry<String,Map<KeyExtent,List<Range>>> entry : binnedRanges.entrySet()) {\n             Map<KeyExtent,List<Range>> tabletMap = new HashMap<>();\n             binnedRanges2.put(entry.getKey(), tabletMap);\n+\n             for (Map.Entry<KeyExtent,List<Range>> tabletRanges : entry.getValue().entrySet()) {\n                 Range tabletRange = tabletRanges.getKey().toDataRange();\n                 List<Range> clippedRanges = new ArrayList<>();\n                 tabletMap.put(tabletRanges.getKey(), clippedRanges);\n+\n                 for (Range range : tabletRanges.getValue())\n                     clippedRanges.add(tabletRange.clip(range));\n             }\n         }\n-        \n         binnedRanges.clear();\n         binnedRanges.putAll(binnedRanges2);\n-        \n         return binnedRanges;\n     }\n-    \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 53
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "27",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "27",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}