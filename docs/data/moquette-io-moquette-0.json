{
    "project_name": "moquette-io-moquette",
    "error_id": "0",
    "information": {
        "errors": [
            {
                "line": "95",
                "severity": "warning",
                "message": "two or more consecutive empty lines",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpMultilineCheck"
            }
        ]
    },
    "source_code": "    private abstract static class PipelineInitializer {\n\n        abstract void init(SocketChannel channel) throws Exception;\n    }\n\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler/0/NewNettyAcceptor.java\nindex 30c3fa03d4c..aa7f2decf57 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler/0/NewNettyAcceptor.java\n@@ -95,7 +95,6 @@ class NewNettyAcceptor {\n         abstract void init(SocketChannel channel) throws Exception;\n     }\n \n-\n     private class LocalPortReaderFutureListener implements ChannelFutureListener {\n         private String transportName;\n \n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "95",
                    "severity": "warning",
                    "message": "two or more consecutive empty lines",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpMultilineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/0/NewNettyAcceptor.java\nindex 30c3fa03d4c..81e98d9a5c0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/0/NewNettyAcceptor.java\n@@ -59,362 +59,362 @@ import static io.netty.channel.ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE;\n \n class NewNettyAcceptor {\n \n-    private static final String MQTT_SUBPROTOCOL_CSV_LIST = \"mqtt, mqttv3.1, mqttv3.1.1\";\n-    public static final String PLAIN_MQTT_PROTO = \"TCP MQTT\";\n-    public static final String SSL_MQTT_PROTO = \"SSL MQTT\";\n-\n-    static class WebSocketFrameToByteBufDecoder extends MessageToMessageDecoder<BinaryWebSocketFrame> {\n-\n-        @Override\n-        protected void decode(ChannelHandlerContext chc, BinaryWebSocketFrame frame, List<Object> out)\n-                throws Exception {\n-            // convert the frame to a ByteBuf\n-            ByteBuf bb = frame.content();\n-            // System.out.println(\"WebSocketFrameToByteBufDecoder decode - \" +\n-            // ByteBufUtil.hexDump(bb));\n-            bb.retain();\n-            out.add(bb);\n-        }\n+  private static final String MQTT_SUBPROTOCOL_CSV_LIST = \"mqtt, mqttv3.1, mqttv3.1.1\";\n+  public static final String PLAIN_MQTT_PROTO = \"TCP MQTT\";\n+  public static final String SSL_MQTT_PROTO = \"SSL MQTT\";\n+\n+  static class WebSocketFrameToByteBufDecoder extends MessageToMessageDecoder<BinaryWebSocketFrame> {\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext chc, BinaryWebSocketFrame frame, List<Object> out)\n+        throws Exception {\n+      // convert the frame to a ByteBuf\n+      ByteBuf bb = frame.content();\n+      // System.out.println(\"WebSocketFrameToByteBufDecoder decode - \" +\n+      // ByteBufUtil.hexDump(bb));\n+      bb.retain();\n+      out.add(bb);\n     }\n-\n-    static class ByteBufToWebSocketFrameEncoder extends MessageToMessageEncoder<ByteBuf> {\n-\n-        @Override\n-        protected void encode(ChannelHandlerContext chc, ByteBuf bb, List<Object> out) throws Exception {\n-            // convert the ByteBuf to a WebSocketFrame\n-            BinaryWebSocketFrame result = new BinaryWebSocketFrame();\n-            // System.out.println(\"ByteBufToWebSocketFrameEncoder encode - \" +\n-            // ByteBufUtil.hexDump(bb));\n-            result.content().writeBytes(bb);\n-            out.add(result);\n-        }\n+  }\n+\n+  static class ByteBufToWebSocketFrameEncoder extends MessageToMessageEncoder<ByteBuf> {\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext chc, ByteBuf bb, List<Object> out) throws Exception {\n+      // convert the ByteBuf to a WebSocketFrame\n+      BinaryWebSocketFrame result = new BinaryWebSocketFrame();\n+      // System.out.println(\"ByteBufToWebSocketFrameEncoder encode - \" +\n+      // ByteBufUtil.hexDump(bb));\n+      result.content().writeBytes(bb);\n+      out.add(result);\n     }\n+  }\n \n-    private abstract static class PipelineInitializer {\n-\n-        abstract void init(SocketChannel channel) throws Exception;\n-    }\n+  private abstract static class PipelineInitializer {\n \n+    abstract void init(SocketChannel channel) throws Exception;\n+  }\n \n-    private class LocalPortReaderFutureListener implements ChannelFutureListener {\n-        private String transportName;\n \n-        LocalPortReaderFutureListener(String transportName) {\n-            this.transportName = transportName;\n-        }\n+  private class LocalPortReaderFutureListener implements ChannelFutureListener {\n+    private String transportName;\n \n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final SocketAddress localAddress = future.channel().localAddress();\n-                if (localAddress instanceof InetSocketAddress) {\n-                    InetSocketAddress inetAddress = (InetSocketAddress) localAddress;\n-                    LOG.debug(\"bound {} port: {}\", transportName, inetAddress.getPort());\n-                    int port = inetAddress.getPort();\n-                    ports.put(transportName, port);\n-                }\n-            }\n-        }\n+    LocalPortReaderFutureListener(String transportName) {\n+      this.transportName = transportName;\n     }\n \n-    private static final Logger LOG = LoggerFactory.getLogger(NewNettyAcceptor.class);\n-\n-    private EventLoopGroup bossGroup;\n-    private EventLoopGroup workerGroup;\n-    private final Map<String, Integer> ports = new HashMap<>();\n-    private BytesMetricsCollector bytesMetricsCollector = new BytesMetricsCollector();\n-    private MessageMetricsCollector metricsCollector = new MessageMetricsCollector();\n-    private Optional<? extends ChannelInboundHandler> metrics;\n-    private Optional<? extends ChannelInboundHandler> errorsCather;\n-\n-    private int nettySoBacklog;\n-    private boolean nettySoReuseaddr;\n-    private boolean nettyTcpNodelay;\n-    private boolean nettySoKeepalive;\n-    private int nettyChannelTimeoutSeconds;\n-    private int maxBytesInMessage;\n-\n-    private Class<? extends ServerSocketChannel> channelClass;\n-\n-    public void initialize(NewNettyMQTTHandler mqttHandler, IConfig props, ISslContextCreator sslCtxCreator) {\n-        LOG.debug(\"Initializing Netty acceptor\");\n-\n-        nettySoBacklog = props.intProp(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, 128);\n-        nettySoReuseaddr = props.boolProp(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, true);\n-        nettyTcpNodelay = props.boolProp(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, true);\n-        nettySoKeepalive = props.boolProp(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, true);\n-        nettyChannelTimeoutSeconds = props.intProp(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, 10);\n-        maxBytesInMessage = props.intProp(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME,\n-                BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE);\n-\n-        boolean epoll = props.boolProp(BrokerConstants.NETTY_EPOLL_PROPERTY_NAME, false);\n-        if (epoll) {\n-            LOG.info(\"Netty is using Epoll\");\n-            bossGroup = new EpollEventLoopGroup();\n-            workerGroup = new EpollEventLoopGroup();\n-            channelClass = EpollServerSocketChannel.class;\n-        } else {\n-            LOG.info(\"Netty is using NIO\");\n-            bossGroup = new NioEventLoopGroup();\n-            workerGroup = new NioEventLoopGroup();\n-            channelClass = NioServerSocketChannel.class;\n-        }\n-\n-        final boolean useFineMetrics = props.boolProp(METRICS_ENABLE_PROPERTY_NAME, false);\n-        if (useFineMetrics) {\n-            DropWizardMetricsHandler metricsHandler = new DropWizardMetricsHandler();\n-            metricsHandler.init(props);\n-            this.metrics = Optional.of(metricsHandler);\n-        } else {\n-            this.metrics = Optional.empty();\n-        }\n-\n-        final boolean useBugSnag = props.boolProp(BUGSNAG_ENABLE_PROPERTY_NAME, false);\n-        if (useBugSnag) {\n-            BugSnagErrorsHandler bugSnagHandler = new BugSnagErrorsHandler();\n-            bugSnagHandler.init(props);\n-            this.errorsCather = Optional.of(bugSnagHandler);\n-        } else {\n-            this.errorsCather = Optional.empty();\n-        }\n-        initializePlainTCPTransport(mqttHandler, props);\n-        initializeWebSocketTransport(mqttHandler, props);\n-        if (securityPortsConfigured(props)) {\n-            SslContext sslContext = sslCtxCreator.initSSLContext();\n-            if (sslContext == null) {\n-                LOG.error(\"Can't initialize SSLHandler layer! Exiting, check your configuration of jks\");\n-                return;\n-            }\n-            initializeSSLTCPTransport(mqttHandler, props, sslContext);\n-            initializeWSSTransport(mqttHandler, props, sslContext);\n+    @Override\n+    public void operationComplete(ChannelFuture future) throws Exception {\n+      if (future.isSuccess()) {\n+        final SocketAddress localAddress = future.channel().localAddress();\n+        if (localAddress instanceof InetSocketAddress) {\n+          InetSocketAddress inetAddress = (InetSocketAddress) localAddress;\n+          LOG.debug(\"bound {} port: {}\", transportName, inetAddress.getPort());\n+          int port = inetAddress.getPort();\n+          ports.put(transportName, port);\n         }\n+      }\n     }\n-\n-    private boolean securityPortsConfigured(IConfig props) {\n-        String sslTcpPortProp = props.getProperty(BrokerConstants.SSL_PORT_PROPERTY_NAME);\n-        String wssPortProp = props.getProperty(BrokerConstants.WSS_PORT_PROPERTY_NAME);\n-        return sslTcpPortProp != null || wssPortProp != null;\n+  }\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(NewNettyAcceptor.class);\n+\n+  private EventLoopGroup bossGroup;\n+  private EventLoopGroup workerGroup;\n+  private final Map<String, Integer> ports = new HashMap<>();\n+  private BytesMetricsCollector bytesMetricsCollector = new BytesMetricsCollector();\n+  private MessageMetricsCollector metricsCollector = new MessageMetricsCollector();\n+  private Optional<? extends ChannelInboundHandler> metrics;\n+  private Optional<? extends ChannelInboundHandler> errorsCather;\n+\n+  private int nettySoBacklog;\n+  private boolean nettySoReuseaddr;\n+  private boolean nettyTcpNodelay;\n+  private boolean nettySoKeepalive;\n+  private int nettyChannelTimeoutSeconds;\n+  private int maxBytesInMessage;\n+\n+  private Class<? extends ServerSocketChannel> channelClass;\n+\n+  public void initialize(NewNettyMQTTHandler mqttHandler, IConfig props, ISslContextCreator sslCtxCreator) {\n+    LOG.debug(\"Initializing Netty acceptor\");\n+\n+    nettySoBacklog = props.intProp(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, 128);\n+    nettySoReuseaddr = props.boolProp(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, true);\n+    nettyTcpNodelay = props.boolProp(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, true);\n+    nettySoKeepalive = props.boolProp(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, true);\n+    nettyChannelTimeoutSeconds = props.intProp(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, 10);\n+    maxBytesInMessage = props.intProp(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME,\n+        BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE);\n+\n+    boolean epoll = props.boolProp(BrokerConstants.NETTY_EPOLL_PROPERTY_NAME, false);\n+    if (epoll) {\n+      LOG.info(\"Netty is using Epoll\");\n+      bossGroup = new EpollEventLoopGroup();\n+      workerGroup = new EpollEventLoopGroup();\n+      channelClass = EpollServerSocketChannel.class;\n+    } else {\n+      LOG.info(\"Netty is using NIO\");\n+      bossGroup = new NioEventLoopGroup();\n+      workerGroup = new NioEventLoopGroup();\n+      channelClass = NioServerSocketChannel.class;\n     }\n \n-    private void initFactory(String host, int port, String protocol, final PipelineInitializer pipelieInitializer) {\n-        LOG.debug(\"Initializing integration. Protocol={}\", protocol);\n-        ServerBootstrap b = new ServerBootstrap();\n-        b.group(bossGroup, workerGroup).channel(channelClass)\n-                .childHandler(new ChannelInitializer<SocketChannel>() {\n-\n-                    @Override\n-                    public void initChannel(SocketChannel ch) throws Exception {\n-                        pipelieInitializer.init(ch);\n-                    }\n-                })\n-                .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n-                .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n-                .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n-                .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n-        try {\n-            LOG.debug(\"Binding integration. host={}, port={}\", host, port);\n-            // Bind and start to accept incoming connections.\n-            ChannelFuture f = b.bind(host, port);\n-            LOG.info(\"Server bound to host={}, port={}, protocol={}\", host, port, protocol);\n-            f.sync()\n-                .addListener(new LocalPortReaderFutureListener(protocol))\n-                .addListener(FIRE_EXCEPTION_ON_FAILURE);\n-        } catch (InterruptedException ex) {\n-            LOG.error(\"An interruptedException was caught while initializing integration. Protocol={}\", protocol, ex);\n-        }\n+    final boolean useFineMetrics = props.boolProp(METRICS_ENABLE_PROPERTY_NAME, false);\n+    if (useFineMetrics) {\n+      DropWizardMetricsHandler metricsHandler = new DropWizardMetricsHandler();\n+      metricsHandler.init(props);\n+      this.metrics = Optional.of(metricsHandler);\n+    } else {\n+      this.metrics = Optional.empty();\n     }\n \n-    public int getPort() {\n-        return ports.computeIfAbsent(PLAIN_MQTT_PROTO, i -> 0);\n+    final boolean useBugSnag = props.boolProp(BUGSNAG_ENABLE_PROPERTY_NAME, false);\n+    if (useBugSnag) {\n+      BugSnagErrorsHandler bugSnagHandler = new BugSnagErrorsHandler();\n+      bugSnagHandler.init(props);\n+      this.errorsCather = Optional.of(bugSnagHandler);\n+    } else {\n+      this.errorsCather = Optional.empty();\n     }\n-\n-    public int getSslPort() {\n-        return ports.computeIfAbsent(SSL_MQTT_PROTO, i -> 0);\n+    initializePlainTCPTransport(mqttHandler, props);\n+    initializeWebSocketTransport(mqttHandler, props);\n+    if (securityPortsConfigured(props)) {\n+      SslContext sslContext = sslCtxCreator.initSSLContext();\n+      if (sslContext == null) {\n+        LOG.error(\"Can't initialize SSLHandler layer! Exiting, check your configuration of jks\");\n+        return;\n+      }\n+      initializeSSLTCPTransport(mqttHandler, props, sslContext);\n+      initializeWSSTransport(mqttHandler, props, sslContext);\n     }\n-\n-    private void initializePlainTCPTransport(NewNettyMQTTHandler handler, IConfig props) {\n-        LOG.debug(\"Configuring TCP MQTT transport\");\n-        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n-        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n-        String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-        if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n-            LOG.info(\"Property {} has been set to {}. TCP MQTT will be disabled\", BrokerConstants.PORT_PROPERTY_NAME,\n-                     DISABLED_PORT_BIND);\n-            return;\n-        }\n-        int port = Integer.parseInt(tcpPortProp);\n-        initFactory(host, port, PLAIN_MQTT_PROTO, new PipelineInitializer() {\n-\n-            @Override\n-            void init(SocketChannel channel) {\n-                ChannelPipeline pipeline = channel.pipeline();\n-                configureMQTTPipeline(pipeline, timeoutHandler, handler);\n-            }\n-        });\n+  }\n+\n+  private boolean securityPortsConfigured(IConfig props) {\n+    String sslTcpPortProp = props.getProperty(BrokerConstants.SSL_PORT_PROPERTY_NAME);\n+    String wssPortProp = props.getProperty(BrokerConstants.WSS_PORT_PROPERTY_NAME);\n+    return sslTcpPortProp != null || wssPortProp != null;\n+  }\n+\n+  private void initFactory(String host, int port, String protocol, final PipelineInitializer pipelieInitializer) {\n+    LOG.debug(\"Initializing integration. Protocol={}\", protocol);\n+    ServerBootstrap b = new ServerBootstrap();\n+    b.group(bossGroup, workerGroup).channel(channelClass)\n+        .childHandler(new ChannelInitializer<SocketChannel>() {\n+\n+          @Override\n+          public void initChannel(SocketChannel ch) throws Exception {\n+            pipelieInitializer.init(ch);\n+          }\n+        })\n+        .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n+        .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n+        .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n+        .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n+    try {\n+      LOG.debug(\"Binding integration. host={}, port={}\", host, port);\n+      // Bind and start to accept incoming connections.\n+      ChannelFuture f = b.bind(host, port);\n+      LOG.info(\"Server bound to host={}, port={}, protocol={}\", host, port, protocol);\n+      f.sync()\n+          .addListener(new LocalPortReaderFutureListener(protocol))\n+          .addListener(FIRE_EXCEPTION_ON_FAILURE);\n+    } catch (InterruptedException ex) {\n+      LOG.error(\"An interruptedException was caught while initializing integration. Protocol={}\", protocol, ex);\n     }\n-\n-    private void configureMQTTPipeline(ChannelPipeline pipeline, MoquetteIdleTimeoutHandler timeoutHandler,\n-                                       NewNettyMQTTHandler handler) {\n-        pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n-        pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n-        // pipeline.addLast(\"logger\", new LoggingHandler(\"Netty\", LogLevel.ERROR));\n-        if (errorsCather.isPresent()) {\n-            pipeline.addLast(\"bugsnagCatcher\", errorsCather.get());\n-        }\n-        pipeline.addFirst(\"bytemetrics\", new BytesMetricsHandler(bytesMetricsCollector));\n-        pipeline.addLast(\"autoflush\", new AutoFlushHandler(1, TimeUnit.SECONDS));\n-        pipeline.addLast(\"decoder\", new MqttDecoder(maxBytesInMessage));\n-        pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n-        pipeline.addLast(\"metrics\", new MessageMetricsHandler(metricsCollector));\n-        pipeline.addLast(\"messageLogger\", new MQTTMessageLogger());\n-        if (metrics.isPresent()) {\n-            pipeline.addLast(\"wizardMetrics\", metrics.get());\n-        }\n-        pipeline.addLast(\"handler\", handler);\n+  }\n+\n+  public int getPort() {\n+    return ports.computeIfAbsent(PLAIN_MQTT_PROTO, i -> 0);\n+  }\n+\n+  public int getSslPort() {\n+    return ports.computeIfAbsent(SSL_MQTT_PROTO, i -> 0);\n+  }\n+\n+  private void initializePlainTCPTransport(NewNettyMQTTHandler handler, IConfig props) {\n+    LOG.debug(\"Configuring TCP MQTT transport\");\n+    final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n+    String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n+    String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+    if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n+      LOG.info(\"Property {} has been set to {}. TCP MQTT will be disabled\", BrokerConstants.PORT_PROPERTY_NAME,\n+          DISABLED_PORT_BIND);\n+      return;\n     }\n-\n-    private void initializeWebSocketTransport(final NewNettyMQTTHandler handler, IConfig props) {\n-        LOG.debug(\"Configuring Websocket MQTT transport\");\n-        String webSocketPortProp = props.getProperty(WEB_SOCKET_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-        if (DISABLED_PORT_BIND.equals(webSocketPortProp)) {\n-            // Do nothing no WebSocket configured\n-            LOG.info(\"Property {} has been setted to {}. Websocket MQTT will be disabled\",\n-                     BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-            return;\n-        }\n-        int port = Integer.parseInt(webSocketPortProp);\n-\n-        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n-\n-        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n-        String path = props.getProperty(BrokerConstants.WEB_SOCKET_PATH_PROPERTY_NAME, BrokerConstants.WEBSOCKET_PATH);\n-        int maxFrameSize = props.intProp(BrokerConstants.WEB_SOCKET_MAX_FRAME_SIZE_PROPERTY_NAME, 65536);\n-        initFactory(host, port, \"Websocket MQTT\", new PipelineInitializer() {\n-\n-            @Override\n-            void init(SocketChannel channel) {\n-                ChannelPipeline pipeline = channel.pipeline();\n-                pipeline.addLast(new HttpServerCodec());\n-                pipeline.addLast(\"aggregator\", new HttpObjectAggregator(65536));\n-                pipeline.addLast(\"webSocketHandler\",\n-                        new WebSocketServerProtocolHandler(path, MQTT_SUBPROTOCOL_CSV_LIST, false, maxFrameSize));\n-                pipeline.addLast(\"ws2bytebufDecoder\", new WebSocketFrameToByteBufDecoder());\n-                pipeline.addLast(\"bytebuf2wsEncoder\", new ByteBufToWebSocketFrameEncoder());\n-                configureMQTTPipeline(pipeline, timeoutHandler, handler);\n-            }\n-        });\n+    int port = Integer.parseInt(tcpPortProp);\n+    initFactory(host, port, PLAIN_MQTT_PROTO, new PipelineInitializer() {\n+\n+      @Override\n+      void init(SocketChannel channel) {\n+        ChannelPipeline pipeline = channel.pipeline();\n+        configureMQTTPipeline(pipeline, timeoutHandler, handler);\n+      }\n+    });\n+  }\n+\n+  private void configureMQTTPipeline(ChannelPipeline pipeline, MoquetteIdleTimeoutHandler timeoutHandler,\n+                                     NewNettyMQTTHandler handler) {\n+    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n+    pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n+    // pipeline.addLast(\"logger\", new LoggingHandler(\"Netty\", LogLevel.ERROR));\n+    if (errorsCather.isPresent()) {\n+      pipeline.addLast(\"bugsnagCatcher\", errorsCather.get());\n     }\n-\n-    private void initializeSSLTCPTransport(NewNettyMQTTHandler handler, IConfig props, SslContext sslContext) {\n-        LOG.debug(\"Configuring SSL MQTT transport\");\n-        String sslPortProp = props.getProperty(SSL_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-        if (DISABLED_PORT_BIND.equals(sslPortProp)) {\n-            // Do nothing no SSL configured\n-            LOG.info(\"Property {} has been set to {}. SSL MQTT will be disabled\",\n-                     BrokerConstants.SSL_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-            return;\n-        }\n-\n-        int sslPort = Integer.parseInt(sslPortProp);\n-        LOG.debug(\"Starting SSL on port {}\", sslPort);\n-\n-        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n-        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n-        String sNeedsClientAuth = props.getProperty(BrokerConstants.NEED_CLIENT_AUTH, \"false\");\n-        final boolean needsClientAuth = Boolean.valueOf(sNeedsClientAuth);\n-        initFactory(host, sslPort, SSL_MQTT_PROTO, new PipelineInitializer() {\n-\n-            @Override\n-            void init(SocketChannel channel) throws Exception {\n-                ChannelPipeline pipeline = channel.pipeline();\n-                pipeline.addLast(\"ssl\", createSslHandler(channel, sslContext, needsClientAuth));\n-                configureMQTTPipeline(pipeline, timeoutHandler, handler);\n-            }\n-        });\n+    pipeline.addFirst(\"bytemetrics\", new BytesMetricsHandler(bytesMetricsCollector));\n+    pipeline.addLast(\"autoflush\", new AutoFlushHandler(1, TimeUnit.SECONDS));\n+    pipeline.addLast(\"decoder\", new MqttDecoder(maxBytesInMessage));\n+    pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n+    pipeline.addLast(\"metrics\", new MessageMetricsHandler(metricsCollector));\n+    pipeline.addLast(\"messageLogger\", new MQTTMessageLogger());\n+    if (metrics.isPresent()) {\n+      pipeline.addLast(\"wizardMetrics\", metrics.get());\n     }\n-\n-    private void initializeWSSTransport(NewNettyMQTTHandler handler, IConfig props, SslContext sslContext) {\n-        LOG.debug(\"Configuring secure websocket MQTT transport\");\n-        String sslPortProp = props.getProperty(WSS_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-        if (DISABLED_PORT_BIND.equals(sslPortProp)) {\n-            // Do nothing no SSL configured\n-            LOG.info(\"Property {} has been set to {}. Secure websocket MQTT will be disabled\",\n-                    BrokerConstants.WSS_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-            return;\n-        }\n-        int sslPort = Integer.parseInt(sslPortProp);\n-        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n-        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n-        String path = props.getProperty(BrokerConstants.WEB_SOCKET_PATH_PROPERTY_NAME, BrokerConstants.WEBSOCKET_PATH);\n-        int maxFrameSize = props.intProp(BrokerConstants.WEB_SOCKET_MAX_FRAME_SIZE_PROPERTY_NAME, 65536);\n-        String sNeedsClientAuth = props.getProperty(BrokerConstants.NEED_CLIENT_AUTH, \"false\");\n-        final boolean needsClientAuth = Boolean.valueOf(sNeedsClientAuth);\n-        initFactory(host, sslPort, \"Secure websocket\", new PipelineInitializer() {\n-\n-            @Override\n-            void init(SocketChannel channel) throws Exception {\n-                ChannelPipeline pipeline = channel.pipeline();\n-                pipeline.addLast(\"ssl\", createSslHandler(channel, sslContext, needsClientAuth));\n-                pipeline.addLast(\"httpEncoder\", new HttpResponseEncoder());\n-                pipeline.addLast(\"httpDecoder\", new HttpRequestDecoder());\n-                pipeline.addLast(\"aggregator\", new HttpObjectAggregator(65536));\n-                pipeline.addLast(\"webSocketHandler\",\n-                        new WebSocketServerProtocolHandler(path, MQTT_SUBPROTOCOL_CSV_LIST, false, maxFrameSize));\n-                pipeline.addLast(\"ws2bytebufDecoder\", new WebSocketFrameToByteBufDecoder());\n-                pipeline.addLast(\"bytebuf2wsEncoder\", new ByteBufToWebSocketFrameEncoder());\n-\n-                configureMQTTPipeline(pipeline, timeoutHandler, handler);\n-            }\n-        });\n+    pipeline.addLast(\"handler\", handler);\n+  }\n+\n+  private void initializeWebSocketTransport(final NewNettyMQTTHandler handler, IConfig props) {\n+    LOG.debug(\"Configuring Websocket MQTT transport\");\n+    String webSocketPortProp = props.getProperty(WEB_SOCKET_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+    if (DISABLED_PORT_BIND.equals(webSocketPortProp)) {\n+      // Do nothing no WebSocket configured\n+      LOG.info(\"Property {} has been setted to {}. Websocket MQTT will be disabled\",\n+          BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+      return;\n+    }\n+    int port = Integer.parseInt(webSocketPortProp);\n+\n+    final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n+\n+    String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n+    String path = props.getProperty(BrokerConstants.WEB_SOCKET_PATH_PROPERTY_NAME, BrokerConstants.WEBSOCKET_PATH);\n+    int maxFrameSize = props.intProp(BrokerConstants.WEB_SOCKET_MAX_FRAME_SIZE_PROPERTY_NAME, 65536);\n+    initFactory(host, port, \"Websocket MQTT\", new PipelineInitializer() {\n+\n+      @Override\n+      void init(SocketChannel channel) {\n+        ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new HttpServerCodec());\n+        pipeline.addLast(\"aggregator\", new HttpObjectAggregator(65536));\n+        pipeline.addLast(\"webSocketHandler\",\n+            new WebSocketServerProtocolHandler(path, MQTT_SUBPROTOCOL_CSV_LIST, false, maxFrameSize));\n+        pipeline.addLast(\"ws2bytebufDecoder\", new WebSocketFrameToByteBufDecoder());\n+        pipeline.addLast(\"bytebuf2wsEncoder\", new ByteBufToWebSocketFrameEncoder());\n+        configureMQTTPipeline(pipeline, timeoutHandler, handler);\n+      }\n+    });\n+  }\n+\n+  private void initializeSSLTCPTransport(NewNettyMQTTHandler handler, IConfig props, SslContext sslContext) {\n+    LOG.debug(\"Configuring SSL MQTT transport\");\n+    String sslPortProp = props.getProperty(SSL_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+    if (DISABLED_PORT_BIND.equals(sslPortProp)) {\n+      // Do nothing no SSL configured\n+      LOG.info(\"Property {} has been set to {}. SSL MQTT will be disabled\",\n+          BrokerConstants.SSL_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+      return;\n     }\n \n-    @SuppressWarnings(\"FutureReturnValueIgnored\")\n-    public void close() {\n-        LOG.debug(\"Closing Netty acceptor...\");\n-        if (workerGroup == null || bossGroup == null) {\n-            LOG.error(\"Netty acceptor is not initialized\");\n-            throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n-        }\n-        Future<?> workerWaiter = workerGroup.shutdownGracefully();\n-        Future<?> bossWaiter = bossGroup.shutdownGracefully();\n-\n-        /*\n-         * We shouldn't raise an IllegalStateException if we are interrupted. If we did so, the\n-         * broker is not shut down properly.\n-         */\n-        LOG.info(\"Waiting for worker and boss event loop groups to terminate...\");\n-        try {\n-            workerWaiter.await(10, TimeUnit.SECONDS);\n-            bossWaiter.await(10, TimeUnit.SECONDS);\n-        } catch (InterruptedException iex) {\n-            LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n-        }\n-\n-        if (!workerGroup.isTerminated()) {\n-            LOG.warn(\"Forcing shutdown of worker event loop...\");\n-            workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n-        }\n+    int sslPort = Integer.parseInt(sslPortProp);\n+    LOG.debug(\"Starting SSL on port {}\", sslPort);\n+\n+    final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n+    String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n+    String sNeedsClientAuth = props.getProperty(BrokerConstants.NEED_CLIENT_AUTH, \"false\");\n+    final boolean needsClientAuth = Boolean.valueOf(sNeedsClientAuth);\n+    initFactory(host, sslPort, SSL_MQTT_PROTO, new PipelineInitializer() {\n+\n+      @Override\n+      void init(SocketChannel channel) throws Exception {\n+        ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(\"ssl\", createSslHandler(channel, sslContext, needsClientAuth));\n+        configureMQTTPipeline(pipeline, timeoutHandler, handler);\n+      }\n+    });\n+  }\n+\n+  private void initializeWSSTransport(NewNettyMQTTHandler handler, IConfig props, SslContext sslContext) {\n+    LOG.debug(\"Configuring secure websocket MQTT transport\");\n+    String sslPortProp = props.getProperty(WSS_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+    if (DISABLED_PORT_BIND.equals(sslPortProp)) {\n+      // Do nothing no SSL configured\n+      LOG.info(\"Property {} has been set to {}. Secure websocket MQTT will be disabled\",\n+          BrokerConstants.WSS_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+      return;\n+    }\n+    int sslPort = Integer.parseInt(sslPortProp);\n+    final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n+    String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n+    String path = props.getProperty(BrokerConstants.WEB_SOCKET_PATH_PROPERTY_NAME, BrokerConstants.WEBSOCKET_PATH);\n+    int maxFrameSize = props.intProp(BrokerConstants.WEB_SOCKET_MAX_FRAME_SIZE_PROPERTY_NAME, 65536);\n+    String sNeedsClientAuth = props.getProperty(BrokerConstants.NEED_CLIENT_AUTH, \"false\");\n+    final boolean needsClientAuth = Boolean.valueOf(sNeedsClientAuth);\n+    initFactory(host, sslPort, \"Secure websocket\", new PipelineInitializer() {\n+\n+      @Override\n+      void init(SocketChannel channel) throws Exception {\n+        ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(\"ssl\", createSslHandler(channel, sslContext, needsClientAuth));\n+        pipeline.addLast(\"httpEncoder\", new HttpResponseEncoder());\n+        pipeline.addLast(\"httpDecoder\", new HttpRequestDecoder());\n+        pipeline.addLast(\"aggregator\", new HttpObjectAggregator(65536));\n+        pipeline.addLast(\"webSocketHandler\",\n+            new WebSocketServerProtocolHandler(path, MQTT_SUBPROTOCOL_CSV_LIST, false, maxFrameSize));\n+        pipeline.addLast(\"ws2bytebufDecoder\", new WebSocketFrameToByteBufDecoder());\n+        pipeline.addLast(\"bytebuf2wsEncoder\", new ByteBufToWebSocketFrameEncoder());\n+\n+        configureMQTTPipeline(pipeline, timeoutHandler, handler);\n+      }\n+    });\n+  }\n+\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  public void close() {\n+    LOG.debug(\"Closing Netty acceptor...\");\n+    if (workerGroup == null || bossGroup == null) {\n+      LOG.error(\"Netty acceptor is not initialized\");\n+      throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n+    }\n+    Future<?> workerWaiter = workerGroup.shutdownGracefully();\n+    Future<?> bossWaiter = bossGroup.shutdownGracefully();\n+\n+    /*\n+     * We shouldn't raise an IllegalStateException if we are interrupted. If we did so, the\n+     * broker is not shut down properly.\n+     */\n+    LOG.info(\"Waiting for worker and boss event loop groups to terminate...\");\n+    try {\n+      workerWaiter.await(10, TimeUnit.SECONDS);\n+      bossWaiter.await(10, TimeUnit.SECONDS);\n+    } catch (InterruptedException iex) {\n+      LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n+    }\n \n-        if (!bossGroup.isTerminated()) {\n-            LOG.warn(\"Forcing shutdown of boss event loop...\");\n-            bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n-        }\n+    if (!workerGroup.isTerminated()) {\n+      LOG.warn(\"Forcing shutdown of worker event loop...\");\n+      workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n+    }\n \n-        MessageMetrics metrics = metricsCollector.computeMetrics();\n-        BytesMetrics bytesMetrics = bytesMetricsCollector.computeMetrics();\n-        LOG.info(\"Metrics messages[read={}, write={}] bytes[read={}, write={}]\", metrics.messagesRead(),\n-                 metrics.messagesWrote(), bytesMetrics.readBytes(), bytesMetrics.wroteBytes());\n+    if (!bossGroup.isTerminated()) {\n+      LOG.warn(\"Forcing shutdown of boss event loop...\");\n+      bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n     }\n \n-    private ChannelHandler createSslHandler(SocketChannel channel, SslContext sslContext, boolean needsClientAuth) {\n-        SSLEngine sslEngine = sslContext.newEngine(\n-                channel.alloc(),\n-                channel.remoteAddress().getHostString(),\n-                channel.remoteAddress().getPort());\n-        sslEngine.setUseClientMode(false);\n-        if (needsClientAuth) {\n-            sslEngine.setNeedClientAuth(true);\n-        }\n-        return new SslHandler(sslEngine);\n+    MessageMetrics metrics = metricsCollector.computeMetrics();\n+    BytesMetrics bytesMetrics = bytesMetricsCollector.computeMetrics();\n+    LOG.info(\"Metrics messages[read={}, write={}] bytes[read={}, write={}]\", metrics.messagesRead(),\n+        metrics.messagesWrote(), bytesMetrics.readBytes(), bytesMetrics.wroteBytes());\n+  }\n+\n+  private ChannelHandler createSslHandler(SocketChannel channel, SslContext sslContext, boolean needsClientAuth) {\n+    SSLEngine sslEngine = sslContext.newEngine(\n+        channel.alloc(),\n+        channel.remoteAddress().getHostString(),\n+        channel.remoteAddress().getPort());\n+    sslEngine.setUseClientMode(false);\n+    if (needsClientAuth) {\n+      sslEngine.setNeedClientAuth(true);\n     }\n+    return new SslHandler(sslEngine);\n+  }\n }\n",
            "diff_size": 460
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "240",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 138).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "254",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 138).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/0/NewNettyAcceptor.java\nindex 30c3fa03d4c..bea0cb18e57 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/0/NewNettyAcceptor.java\n@@ -95,8 +95,7 @@ class NewNettyAcceptor {\n         abstract void init(SocketChannel channel) throws Exception;\n     }\n \n-\n-    private class LocalPortReaderFutureListener implements ChannelFutureListener {\n+private class LocalPortReaderFutureListener implements ChannelFutureListener {\n         private String transportName;\n \n         LocalPortReaderFutureListener(String transportName) {\n@@ -238,9 +237,8 @@ class NewNettyAcceptor {\n         String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n         String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n         if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n-            LOG.info(\"Property {} has been set to {}. TCP MQTT will be disabled\", BrokerConstants.PORT_PROPERTY_NAME,\n-                     DISABLED_PORT_BIND);\n-            return;\n+            LOG.info(\"Property {} has been set to {}. TCP MQTT will be disabled\", BrokerConstants.PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+return;\n         }\n         int port = Integer.parseInt(tcpPortProp);\n         initFactory(host, port, PLAIN_MQTT_PROTO, new PipelineInitializer() {\n@@ -253,9 +251,8 @@ class NewNettyAcceptor {\n         });\n     }\n \n-    private void configureMQTTPipeline(ChannelPipeline pipeline, MoquetteIdleTimeoutHandler timeoutHandler,\n-                                       NewNettyMQTTHandler handler) {\n-        pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n+    private void configureMQTTPipeline(ChannelPipeline pipeline, MoquetteIdleTimeoutHandler timeoutHandler, NewNettyMQTTHandler handler) {\n+    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n         pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n         // pipeline.addLast(\"logger\", new LoggingHandler(\"Netty\", LogLevel.ERROR));\n         if (errorsCather.isPresent()) {\n@@ -280,7 +277,7 @@ class NewNettyAcceptor {\n             // Do nothing no WebSocket configured\n             LOG.info(\"Property {} has been setted to {}. Websocket MQTT will be disabled\",\n                      BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-            return;\n+return;\n         }\n         int port = Integer.parseInt(webSocketPortProp);\n \n@@ -312,7 +309,7 @@ class NewNettyAcceptor {\n             // Do nothing no SSL configured\n             LOG.info(\"Property {} has been set to {}. SSL MQTT will be disabled\",\n                      BrokerConstants.SSL_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-            return;\n+return;\n         }\n \n         int sslPort = Integer.parseInt(sslPortProp);\n@@ -340,7 +337,7 @@ class NewNettyAcceptor {\n             // Do nothing no SSL configured\n             LOG.info(\"Property {} has been set to {}. Secure websocket MQTT will be disabled\",\n                     BrokerConstants.WSS_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n-            return;\n+return;\n         }\n         int sslPort = Integer.parseInt(sslPortProp);\n         final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n@@ -417,4 +414,4 @@ class NewNettyAcceptor {\n         }\n         return new SslHandler(sslEngine);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 12
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "69",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "142",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "203",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 154).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "245",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 138).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "392",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 183).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "396",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 144).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/0/NewNettyAcceptor.java\nindex 30c3fa03d4c..015f0e9cec6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/0/NewNettyAcceptor.java\n@@ -44,7 +44,6 @@ import io.netty.handler.timeout.IdleStateHandler;\n import io.netty.util.concurrent.Future;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import javax.net.ssl.SSLEngine;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n@@ -53,21 +52,21 @@ import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n import java.util.concurrent.TimeUnit;\n-\n import static io.moquette.BrokerConstants.*;\n import static io.netty.channel.ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE;\n \n class NewNettyAcceptor {\n \n     private static final String MQTT_SUBPROTOCOL_CSV_LIST = \"mqtt, mqttv3.1, mqttv3.1.1\";\n+\n     public static final String PLAIN_MQTT_PROTO = \"TCP MQTT\";\n+\n     public static final String SSL_MQTT_PROTO = \"SSL MQTT\";\n \n     static class WebSocketFrameToByteBufDecoder extends MessageToMessageDecoder<BinaryWebSocketFrame> {\n \n         @Override\n-        protected void decode(ChannelHandlerContext chc, BinaryWebSocketFrame frame, List<Object> out)\n-                throws Exception {\n+        protected void decode(ChannelHandlerContext chc, BinaryWebSocketFrame frame, List<Object> out) throws Exception {\n             // convert the frame to a ByteBuf\n             ByteBuf bb = frame.content();\n             // System.out.println(\"WebSocketFrameToByteBufDecoder decode - \" +\n@@ -95,8 +94,8 @@ class NewNettyAcceptor {\n         abstract void init(SocketChannel channel) throws Exception;\n     }\n \n-\n     private class LocalPortReaderFutureListener implements ChannelFutureListener {\n+\n         private String transportName;\n \n         LocalPortReaderFutureListener(String transportName) {\n@@ -118,7 +117,6 @@ class NewNettyAcceptor {\n     }\n \n     private static final Logger LOG = LoggerFactory.getLogger(NewNettyAcceptor.class);\n-\n     private EventLoopGroup bossGroup;\n     private EventLoopGroup workerGroup;\n     private final Map<String, Integer> ports = new HashMap<>();\n@@ -126,27 +124,22 @@ class NewNettyAcceptor {\n     private MessageMetricsCollector metricsCollector = new MessageMetricsCollector();\n     private Optional<? extends ChannelInboundHandler> metrics;\n     private Optional<? extends ChannelInboundHandler> errorsCather;\n-\n     private int nettySoBacklog;\n     private boolean nettySoReuseaddr;\n     private boolean nettyTcpNodelay;\n     private boolean nettySoKeepalive;\n     private int nettyChannelTimeoutSeconds;\n     private int maxBytesInMessage;\n-\n     private Class<? extends ServerSocketChannel> channelClass;\n \n     public void initialize(NewNettyMQTTHandler mqttHandler, IConfig props, ISslContextCreator sslCtxCreator) {\n         LOG.debug(\"Initializing Netty acceptor\");\n-\n         nettySoBacklog = props.intProp(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, 128);\n         nettySoReuseaddr = props.boolProp(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, true);\n         nettyTcpNodelay = props.boolProp(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, true);\n         nettySoKeepalive = props.boolProp(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, true);\n         nettyChannelTimeoutSeconds = props.intProp(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, 10);\n-        maxBytesInMessage = props.intProp(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME,\n-                BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE);\n-\n+        maxBytesInMessage = props.intProp(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME, BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE);\n         boolean epoll = props.boolProp(BrokerConstants.NETTY_EPOLL_PROPERTY_NAME, false);\n         if (epoll) {\n             LOG.info(\"Netty is using Epoll\");\n@@ -159,7 +152,6 @@ class NewNettyAcceptor {\n             workerGroup = new NioEventLoopGroup();\n             channelClass = NioServerSocketChannel.class;\n         }\n-\n         final boolean useFineMetrics = props.boolProp(METRICS_ENABLE_PROPERTY_NAME, false);\n         if (useFineMetrics) {\n             DropWizardMetricsHandler metricsHandler = new DropWizardMetricsHandler();\n@@ -168,7 +160,6 @@ class NewNettyAcceptor {\n         } else {\n             this.metrics = Optional.empty();\n         }\n-\n         final boolean useBugSnag = props.boolProp(BUGSNAG_ENABLE_PROPERTY_NAME, false);\n         if (useBugSnag) {\n             BugSnagErrorsHandler bugSnagHandler = new BugSnagErrorsHandler();\n@@ -200,25 +191,22 @@ class NewNettyAcceptor {\n         LOG.debug(\"Initializing integration. Protocol={}\", protocol);\n         ServerBootstrap b = new ServerBootstrap();\n         b.group(bossGroup, workerGroup).channel(channelClass)\n-                .childHandler(new ChannelInitializer<SocketChannel>() {\n-\n-                    @Override\n-                    public void initChannel(SocketChannel ch) throws Exception {\n-                        pipelieInitializer.init(ch);\n-                    }\n-                })\n-                .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n-                .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n-                .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n-                .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n+                                       .childHandler(new ChannelInitializer<SocketChannel>() {\n+\n+                                           @Override\n+                                           public void initChannel(SocketChannel ch) throws Exception {\n+                                               pipelieInitializer.init(ch);\n+                                           }\n+                                       })\n+                                       .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n+                                       .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n+                                       .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay).childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n         try {\n             LOG.debug(\"Binding integration. host={}, port={}\", host, port);\n             // Bind and start to accept incoming connections.\n             ChannelFuture f = b.bind(host, port);\n             LOG.info(\"Server bound to host={}, port={}, protocol={}\", host, port, protocol);\n-            f.sync()\n-                .addListener(new LocalPortReaderFutureListener(protocol))\n-                .addListener(FIRE_EXCEPTION_ON_FAILURE);\n+            f.sync().addListener(new LocalPortReaderFutureListener(protocol)).addListener(FIRE_EXCEPTION_ON_FAILURE);\n         } catch (InterruptedException ex) {\n             LOG.error(\"An interruptedException was caught while initializing integration. Protocol={}\", protocol, ex);\n         }\n@@ -238,8 +226,9 @@ class NewNettyAcceptor {\n         String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n         String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n         if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n-            LOG.info(\"Property {} has been set to {}. TCP MQTT will be disabled\", BrokerConstants.PORT_PROPERTY_NAME,\n-                     DISABLED_PORT_BIND);\n+            LOG.info(\"Property {} has been set to {}. TCP MQTT will be disabled\",\n+                BrokerConstants.PORT_PROPERTY_NAME,\n+                DISABLED_PORT_BIND);\n             return;\n         }\n         int port = Integer.parseInt(tcpPortProp);\n@@ -253,8 +242,7 @@ class NewNettyAcceptor {\n         });\n     }\n \n-    private void configureMQTTPipeline(ChannelPipeline pipeline, MoquetteIdleTimeoutHandler timeoutHandler,\n-                                       NewNettyMQTTHandler handler) {\n+    private void configureMQTTPipeline(ChannelPipeline pipeline, MoquetteIdleTimeoutHandler timeoutHandler, NewNettyMQTTHandler handler) {\n         pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n         pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n         // pipeline.addLast(\"logger\", new LoggingHandler(\"Netty\", LogLevel.ERROR));\n@@ -279,13 +267,12 @@ class NewNettyAcceptor {\n         if (DISABLED_PORT_BIND.equals(webSocketPortProp)) {\n             // Do nothing no WebSocket configured\n             LOG.info(\"Property {} has been setted to {}. Websocket MQTT will be disabled\",\n-                     BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+                BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME,\n+                DISABLED_PORT_BIND);\n             return;\n         }\n         int port = Integer.parseInt(webSocketPortProp);\n-\n         final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n-\n         String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n         String path = props.getProperty(BrokerConstants.WEB_SOCKET_PATH_PROPERTY_NAME, BrokerConstants.WEBSOCKET_PATH);\n         int maxFrameSize = props.intProp(BrokerConstants.WEB_SOCKET_MAX_FRAME_SIZE_PROPERTY_NAME, 65536);\n@@ -297,7 +284,7 @@ class NewNettyAcceptor {\n                 pipeline.addLast(new HttpServerCodec());\n                 pipeline.addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                 pipeline.addLast(\"webSocketHandler\",\n-                        new WebSocketServerProtocolHandler(path, MQTT_SUBPROTOCOL_CSV_LIST, false, maxFrameSize));\n+                    new WebSocketServerProtocolHandler(path, MQTT_SUBPROTOCOL_CSV_LIST, false, maxFrameSize));\n                 pipeline.addLast(\"ws2bytebufDecoder\", new WebSocketFrameToByteBufDecoder());\n                 pipeline.addLast(\"bytebuf2wsEncoder\", new ByteBufToWebSocketFrameEncoder());\n                 configureMQTTPipeline(pipeline, timeoutHandler, handler);\n@@ -311,13 +298,12 @@ class NewNettyAcceptor {\n         if (DISABLED_PORT_BIND.equals(sslPortProp)) {\n             // Do nothing no SSL configured\n             LOG.info(\"Property {} has been set to {}. SSL MQTT will be disabled\",\n-                     BrokerConstants.SSL_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+                BrokerConstants.SSL_PORT_PROPERTY_NAME,\n+                DISABLED_PORT_BIND);\n             return;\n         }\n-\n         int sslPort = Integer.parseInt(sslPortProp);\n         LOG.debug(\"Starting SSL on port {}\", sslPort);\n-\n         final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n         String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);\n         String sNeedsClientAuth = props.getProperty(BrokerConstants.NEED_CLIENT_AUTH, \"false\");\n@@ -339,7 +325,8 @@ class NewNettyAcceptor {\n         if (DISABLED_PORT_BIND.equals(sslPortProp)) {\n             // Do nothing no SSL configured\n             LOG.info(\"Property {} has been set to {}. Secure websocket MQTT will be disabled\",\n-                    BrokerConstants.WSS_PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n+                BrokerConstants.WSS_PORT_PROPERTY_NAME,\n+                DISABLED_PORT_BIND);\n             return;\n         }\n         int sslPort = Integer.parseInt(sslPortProp);\n@@ -359,10 +346,9 @@ class NewNettyAcceptor {\n                 pipeline.addLast(\"httpDecoder\", new HttpRequestDecoder());\n                 pipeline.addLast(\"aggregator\", new HttpObjectAggregator(65536));\n                 pipeline.addLast(\"webSocketHandler\",\n-                        new WebSocketServerProtocolHandler(path, MQTT_SUBPROTOCOL_CSV_LIST, false, maxFrameSize));\n+                    new WebSocketServerProtocolHandler(path, MQTT_SUBPROTOCOL_CSV_LIST, false, maxFrameSize));\n                 pipeline.addLast(\"ws2bytebufDecoder\", new WebSocketFrameToByteBufDecoder());\n                 pipeline.addLast(\"bytebuf2wsEncoder\", new ByteBufToWebSocketFrameEncoder());\n-\n                 configureMQTTPipeline(pipeline, timeoutHandler, handler);\n             }\n         });\n@@ -375,6 +361,7 @@ class NewNettyAcceptor {\n             LOG.error(\"Netty acceptor is not initialized\");\n             throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n         }\n+\n         Future<?> workerWaiter = workerGroup.shutdownGracefully();\n         Future<?> bossWaiter = bossGroup.shutdownGracefully();\n \n@@ -402,19 +389,15 @@ class NewNettyAcceptor {\n \n         MessageMetrics metrics = metricsCollector.computeMetrics();\n         BytesMetrics bytesMetrics = bytesMetricsCollector.computeMetrics();\n-        LOG.info(\"Metrics messages[read={}, write={}] bytes[read={}, write={}]\", metrics.messagesRead(),\n-                 metrics.messagesWrote(), bytesMetrics.readBytes(), bytesMetrics.wroteBytes());\n+        LOG.info(\"Metrics messages[read={}, write={}] bytes[read={}, write={}]\", metrics.messagesRead(), metrics.messagesWrote(), bytesMetrics.readBytes(), bytesMetrics.wroteBytes());\n     }\n \n     private ChannelHandler createSslHandler(SocketChannel channel, SslContext sslContext, boolean needsClientAuth) {\n-        SSLEngine sslEngine = sslContext.newEngine(\n-                channel.alloc(),\n-                channel.remoteAddress().getHostString(),\n-                channel.remoteAddress().getPort());\n+        SSLEngine sslEngine = sslContext.newEngine(channel.alloc(), channel.remoteAddress().getHostString(), channel.remoteAddress().getPort());\n         sslEngine.setUseClientMode(false);\n         if (needsClientAuth) {\n             sslEngine.setNeedClientAuth(true);\n         }\n         return new SslHandler(sslEngine);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 57
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_random/0/NewNettyAcceptor.java\nindex 30c3fa03d4c..aa7f2decf57 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_random/0/NewNettyAcceptor.java\n@@ -95,7 +95,6 @@ class NewNettyAcceptor {\n         abstract void init(SocketChannel channel) throws Exception;\n     }\n \n-\n     private class LocalPortReaderFutureListener implements ChannelFutureListener {\n         private String transportName;\n \n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "95",
                    "severity": "warning",
                    "message": "two or more consecutive empty lines",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpMultilineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_three_grams/0/NewNettyAcceptor.java\nindex 30c3fa03d4c..c5ff41a6ef8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/0/NewNettyAcceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_three_grams/0/NewNettyAcceptor.java\n@@ -90,13 +90,13 @@ class NewNettyAcceptor {\n         }\n     }\n \n-    private abstract static class PipelineInitializer {\n+    private abstract static class PipelineInitializer { abstract\n \n-        abstract void init(SocketChannel channel) throws Exception;\n-    }\n+        void init(SocketChannel channel) throws Exception;\n+ }\n \n \n-    private class LocalPortReaderFutureListener implements ChannelFutureListener {\n+ private class LocalPortReaderFutureListener implements ChannelFutureListener {\n         private String transportName;\n \n         LocalPortReaderFutureListener(String transportName) {\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_three_grams"
    ]
}