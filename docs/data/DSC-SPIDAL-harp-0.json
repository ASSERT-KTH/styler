{
    "project_name": "DSC-SPIDAL-harp",
    "error_id": "0",
    "information": {
        "errors": [
            {
                "line": "3",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright 2013-2017 Indiana University\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "3",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/0/BenchmarkMapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/intellij/0/BenchmarkMapper.java\nindex 84855d80665..8d4969eba22 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/0/BenchmarkMapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/intellij/0/BenchmarkMapper.java\n@@ -1,6 +1,6 @@\n /*\r\n  * Copyright 2013-2017 Indiana University\r\n- * \r\n+ *\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n@@ -27,127 +27,127 @@ import java.io.IOException;\n import java.util.Random;\r\n \r\n public class BenchmarkMapper extends\r\n-  CollectiveMapper<String, String, Object, Object> {\r\n-\r\n-  private String cmd;\r\n-  private int bytesPerPartition;\r\n-  private int numPartitions;\r\n-  private int numMappers;\r\n-  private int numIterations;\r\n+    CollectiveMapper<String, String, Object, Object> {\r\n \r\n-  /**\r\n-   * Mapper configuration.\r\n-   */\r\n-  @Override\r\n-  protected void setup(Context context)\r\n-    throws IOException, InterruptedException {\r\n-    Configuration configuration =\r\n-      context.getConfiguration();\r\n-    cmd = configuration\r\n-      .get(Constants.BENCHMARK_CMD, \"bcast\");\r\n-    numMappers = configuration\r\n-      .getInt(Constants.NUM_MAPPERS, 1);\r\n-    numPartitions = configuration\r\n-      .getInt(Constants.NUM_PARTITIONS, 1);\r\n-    bytesPerPartition = configuration\r\n-      .getInt(Constants.BYTES_PER_PARTITION, 1);\r\n-    numIterations = configuration\r\n-      .getInt(Constants.NUM_ITERATIONS, 1);\r\n-    LOG.info(\"Benchmark CMD \" + cmd);\r\n-    LOG.info(\"Num Mappers \" + numMappers);\r\n-    LOG.info(\"Num Partitions \" + numPartitions);\r\n-    LOG.info(\r\n-      \"Bytes per Partition \" + bytesPerPartition);\r\n-    LOG.info(\"Num Iterations \" + numIterations);\r\n-  }\r\n+    private String cmd;\r\n+    private int bytesPerPartition;\r\n+    private int numPartitions;\r\n+    private int numMappers;\r\n+    private int numIterations;\r\n \r\n-  protected void mapCollective(\r\n-    KeyValReader reader, Context context)\r\n-    throws IOException, InterruptedException {\r\n-    // Read key-value pairs\r\n-    while (reader.nextKeyValue()) {\r\n-      String key = reader.getCurrentKey();\r\n-      String value = reader.getCurrentValue();\r\n-      LOG.info(\r\n-        \"Key: \" + key + \", Value: \" + value);\r\n+    /**\r\n+     * Mapper configuration.\r\n+     */\r\n+    @Override\r\n+    protected void setup(Context context)\r\n+        throws IOException, InterruptedException {\r\n+        Configuration configuration =\r\n+            context.getConfiguration();\r\n+        cmd = configuration\r\n+            .get(Constants.BENCHMARK_CMD, \"bcast\");\r\n+        numMappers = configuration\r\n+            .getInt(Constants.NUM_MAPPERS, 1);\r\n+        numPartitions = configuration\r\n+            .getInt(Constants.NUM_PARTITIONS, 1);\r\n+        bytesPerPartition = configuration\r\n+            .getInt(Constants.BYTES_PER_PARTITION, 1);\r\n+        numIterations = configuration\r\n+            .getInt(Constants.NUM_ITERATIONS, 1);\r\n+        LOG.info(\"Benchmark CMD \" + cmd);\r\n+        LOG.info(\"Num Mappers \" + numMappers);\r\n+        LOG.info(\"Num Partitions \" + numPartitions);\r\n+        LOG.info(\r\n+            \"Bytes per Partition \" + bytesPerPartition);\r\n+        LOG.info(\"Num Iterations \" + numIterations);\r\n     }\r\n-    int workerID = this.getSelfID();\r\n-    int numWorkers = this.getNumWorkers();\r\n-    Random rand = new Random(workerID);\r\n-    if (cmd.equals(\"allreduce\")) {\r\n-      long startTime = System.currentTimeMillis();\r\n-      for (int i = 0; i < numIterations; i++) {\r\n-        Table<DoubleArray> arrTable =\r\n-          new Table<>(i, new DoubleArrPlus());\r\n-        // Create DoubleArray\r\n-        int size = bytesPerPartition / 8;\r\n-        for (int j = 0; j < numPartitions; j++) {\r\n-          DoubleArray array =\r\n-            DoubleArray.create(size, false);\r\n-          array.get()[0] = rand.nextInt(1000);\r\n-          array.get()[array.size() - 1] =\r\n-            rand.nextInt(1000);\r\n-          LOG.info(\"before allreduce: \" + j + \" \"\r\n-            + array.get()[0] + \" \"\r\n-            + array.get()[array.size() - 1]);\r\n-          arrTable.addPartition(\r\n-            new Partition<>(j, array));\r\n-        }\r\n-        allreduce(\"main\", \"allreduce-\" + i,\r\n-          arrTable);\r\n-        for (Partition<DoubleArray> partition : arrTable\r\n-          .getPartitions()) {\r\n-          DoubleArray array = partition.get();\r\n-          LOG.info(\r\n-            \"after allreduce: \" + partition.id()\r\n-              + \" \" + array.get()[0] + \" \"\r\n-              + array.get()[array.size() - 1]);\r\n-        }\r\n-        arrTable.release();\r\n-      }\r\n-      long endTime = System.currentTimeMillis();\r\n-      LOG.info(\"Total allreduce time: \"\r\n-        + (endTime - startTime)\r\n-        + \" number of iterations: \"\r\n-        + numIterations);\r\n-    } else if (cmd.equals(\"allgather\")) {\r\n-      long startTime = System.currentTimeMillis();\r\n-      for (int i = 0; i < numIterations; i++) {\r\n-        Table<DoubleArray> arrTable =\r\n-          new Table<>(i, new DoubleArrPlus());\r\n-        int size = bytesPerPartition / 8;\r\n-        // Generate data\r\n-        for (int j = 0; j < numPartitions; j++) {\r\n-          int partitionID =\r\n-            workerID + numWorkers * j;\r\n-          DoubleArray array =\r\n-            DoubleArray.create(size, false);\r\n-          array.get()[0] = rand.nextDouble();\r\n-          array.get()[array.size() - 1] =\r\n-            rand.nextDouble();\r\n-          LOG.info(\r\n-            \"before allgather: \" + partitionID\r\n-              + \" \" + array.get()[0] + \" \"\r\n-              + array.get()[array.size() - 1]);\r\n-          arrTable.addPartition(\r\n-            new Partition<DoubleArray>(\r\n-              partitionID, array));\r\n+\r\n+    protected void mapCollective(\r\n+        KeyValReader reader, Context context)\r\n+        throws IOException, InterruptedException {\r\n+        // Read key-value pairs\r\n+        while (reader.nextKeyValue()) {\r\n+            String key = reader.getCurrentKey();\r\n+            String value = reader.getCurrentValue();\r\n+            LOG.info(\r\n+                \"Key: \" + key + \", Value: \" + value);\r\n         }\r\n-        allgather(\"main\", \"allgather-\" + i,\r\n-          arrTable);\r\n-        for (Partition<DoubleArray> partition : arrTable\r\n-          .getPartitions()) {\r\n-          DoubleArray array = partition.get();\r\n-          LOG.info(\r\n-            \"after allgather: \" + partition.id()\r\n-              + \" \" + array.get()[0] + \" \"\r\n-              + array.get()[array.size() - 1]);\r\n+        int workerID = this.getSelfID();\r\n+        int numWorkers = this.getNumWorkers();\r\n+        Random rand = new Random(workerID);\r\n+        if (cmd.equals(\"allreduce\")) {\r\n+            long startTime = System.currentTimeMillis();\r\n+            for (int i = 0; i < numIterations; i++) {\r\n+                Table<DoubleArray> arrTable =\r\n+                    new Table<>(i, new DoubleArrPlus());\r\n+                // Create DoubleArray\r\n+                int size = bytesPerPartition / 8;\r\n+                for (int j = 0; j < numPartitions; j++) {\r\n+                    DoubleArray array =\r\n+                        DoubleArray.create(size, false);\r\n+                    array.get()[0] = rand.nextInt(1000);\r\n+                    array.get()[array.size() - 1] =\r\n+                        rand.nextInt(1000);\r\n+                    LOG.info(\"before allreduce: \" + j + \" \"\r\n+                        + array.get()[0] + \" \"\r\n+                        + array.get()[array.size() - 1]);\r\n+                    arrTable.addPartition(\r\n+                        new Partition<>(j, array));\r\n+                }\r\n+                allreduce(\"main\", \"allreduce-\" + i,\r\n+                    arrTable);\r\n+                for (Partition<DoubleArray> partition : arrTable\r\n+                    .getPartitions()) {\r\n+                    DoubleArray array = partition.get();\r\n+                    LOG.info(\r\n+                        \"after allreduce: \" + partition.id()\r\n+                            + \" \" + array.get()[0] + \" \"\r\n+                            + array.get()[array.size() - 1]);\r\n+                }\r\n+                arrTable.release();\r\n+            }\r\n+            long endTime = System.currentTimeMillis();\r\n+            LOG.info(\"Total allreduce time: \"\r\n+                + (endTime - startTime)\r\n+                + \" number of iterations: \"\r\n+                + numIterations);\r\n+        } else if (cmd.equals(\"allgather\")) {\r\n+            long startTime = System.currentTimeMillis();\r\n+            for (int i = 0; i < numIterations; i++) {\r\n+                Table<DoubleArray> arrTable =\r\n+                    new Table<>(i, new DoubleArrPlus());\r\n+                int size = bytesPerPartition / 8;\r\n+                // Generate data\r\n+                for (int j = 0; j < numPartitions; j++) {\r\n+                    int partitionID =\r\n+                        workerID + numWorkers * j;\r\n+                    DoubleArray array =\r\n+                        DoubleArray.create(size, false);\r\n+                    array.get()[0] = rand.nextDouble();\r\n+                    array.get()[array.size() - 1] =\r\n+                        rand.nextDouble();\r\n+                    LOG.info(\r\n+                        \"before allgather: \" + partitionID\r\n+                            + \" \" + array.get()[0] + \" \"\r\n+                            + array.get()[array.size() - 1]);\r\n+                    arrTable.addPartition(\r\n+                        new Partition<DoubleArray>(\r\n+                            partitionID, array));\r\n+                }\r\n+                allgather(\"main\", \"allgather-\" + i,\r\n+                    arrTable);\r\n+                for (Partition<DoubleArray> partition : arrTable\r\n+                    .getPartitions()) {\r\n+                    DoubleArray array = partition.get();\r\n+                    LOG.info(\r\n+                        \"after allgather: \" + partition.id()\r\n+                            + \" \" + array.get()[0] + \" \"\r\n+                            + array.get()[array.size() - 1]);\r\n+                }\r\n+                arrTable.release();\r\n+            }\r\n+            long endTime = System.currentTimeMillis();\r\n+            LOG.info(\"Total allgather time: \"\r\n+                + (endTime - startTime));\r\n         }\r\n-        arrTable.release();\r\n-      }\r\n-      long endTime = System.currentTimeMillis();\r\n-      LOG.info(\"Total allgather time: \"\r\n-        + (endTime - startTime));\r\n     }\r\n-  }\r\n }\r\n",
            "diff_size": 201
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "3",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/0/BenchmarkMapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/codebuff/0/BenchmarkMapper.java\nindex 84855d80665..cefd4a040a3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/errored/1/0/BenchmarkMapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DSC-SPIDAL-harp/codebuff/0/BenchmarkMapper.java\n@@ -14,140 +14,111 @@\n  * limitations under the License.\r\n  */\r\n \r\n-package edu.iu.benchmark;\r\n-\r\n-import edu.iu.harp.example.DoubleArrPlus;\r\n-import edu.iu.harp.partition.Partition;\r\n-import edu.iu.harp.partition.Table;\r\n-import edu.iu.harp.resource.DoubleArray;\r\n-import org.apache.hadoop.conf.Configuration;\r\n-import org.apache.hadoop.mapred.CollectiveMapper;\r\n-\r\n-import java.io.IOException;\r\n-import java.util.Random;\r\n-\r\n-public class BenchmarkMapper extends\r\n-  CollectiveMapper<String, String, Object, Object> {\r\n-\r\n-  private String cmd;\r\n-  private int bytesPerPartition;\r\n-  private int numPartitions;\r\n-  private int numMappers;\r\n+package edu.iu.benchmark;\n+\n+import edu.iu.harp.example.DoubleArrPlus;\n+import edu.iu.harp.partition.Partition;\n+import edu.iu.harp.partition.Table;\n+import edu.iu.harp.resource.DoubleArray;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.mapred.CollectiveMapper;\n+import java.io.IOException;\n+import java.util.Random;\n+\n+\n+public class BenchmarkMapper extends\n+  CollectiveMapper<String, String, Object, Object> {\n+  private String cmd;\n+  private int bytesPerPartition;\n+  private int numPartitions;\n+  private int numMappers;\n   private int numIterations;\r\n \r\n   /**\r\n    * Mapper configuration.\r\n-   */\r\n-  @Override\r\n-  protected void setup(Context context)\r\n-    throws IOException, InterruptedException {\r\n-    Configuration configuration =\r\n-      context.getConfiguration();\r\n-    cmd = configuration\r\n-      .get(Constants.BENCHMARK_CMD, \"bcast\");\r\n-    numMappers = configuration\r\n-      .getInt(Constants.NUM_MAPPERS, 1);\r\n-    numPartitions = configuration\r\n-      .getInt(Constants.NUM_PARTITIONS, 1);\r\n-    bytesPerPartition = configuration\r\n-      .getInt(Constants.BYTES_PER_PARTITION, 1);\r\n-    numIterations = configuration\r\n-      .getInt(Constants.NUM_ITERATIONS, 1);\r\n-    LOG.info(\"Benchmark CMD \" + cmd);\r\n-    LOG.info(\"Num Mappers \" + numMappers);\r\n-    LOG.info(\"Num Partitions \" + numPartitions);\r\n-    LOG.info(\r\n-      \"Bytes per Partition \" + bytesPerPartition);\r\n-    LOG.info(\"Num Iterations \" + numIterations);\r\n-  }\r\n-\r\n-  protected void mapCollective(\r\n-    KeyValReader reader, Context context)\r\n-    throws IOException, InterruptedException {\r\n-    // Read key-value pairs\r\n-    while (reader.nextKeyValue()) {\r\n-      String key = reader.getCurrentKey();\r\n-      String value = reader.getCurrentValue();\r\n-      LOG.info(\r\n-        \"Key: \" + key + \", Value: \" + value);\r\n-    }\r\n-    int workerID = this.getSelfID();\r\n-    int numWorkers = this.getNumWorkers();\r\n-    Random rand = new Random(workerID);\r\n-    if (cmd.equals(\"allreduce\")) {\r\n-      long startTime = System.currentTimeMillis();\r\n-      for (int i = 0; i < numIterations; i++) {\r\n-        Table<DoubleArray> arrTable =\r\n-          new Table<>(i, new DoubleArrPlus());\r\n-        // Create DoubleArray\r\n-        int size = bytesPerPartition / 8;\r\n-        for (int j = 0; j < numPartitions; j++) {\r\n-          DoubleArray array =\r\n-            DoubleArray.create(size, false);\r\n-          array.get()[0] = rand.nextInt(1000);\r\n-          array.get()[array.size() - 1] =\r\n-            rand.nextInt(1000);\r\n-          LOG.info(\"before allreduce: \" + j + \" \"\r\n-            + array.get()[0] + \" \"\r\n-            + array.get()[array.size() - 1]);\r\n-          arrTable.addPartition(\r\n-            new Partition<>(j, array));\r\n-        }\r\n-        allreduce(\"main\", \"allreduce-\" + i,\r\n-          arrTable);\r\n-        for (Partition<DoubleArray> partition : arrTable\r\n-          .getPartitions()) {\r\n-          DoubleArray array = partition.get();\r\n-          LOG.info(\r\n-            \"after allreduce: \" + partition.id()\r\n-              + \" \" + array.get()[0] + \" \"\r\n-              + array.get()[array.size() - 1]);\r\n-        }\r\n-        arrTable.release();\r\n-      }\r\n-      long endTime = System.currentTimeMillis();\r\n-      LOG.info(\"Total allreduce time: \"\r\n-        + (endTime - startTime)\r\n-        + \" number of iterations: \"\r\n-        + numIterations);\r\n-    } else if (cmd.equals(\"allgather\")) {\r\n-      long startTime = System.currentTimeMillis();\r\n-      for (int i = 0; i < numIterations; i++) {\r\n-        Table<DoubleArray> arrTable =\r\n-          new Table<>(i, new DoubleArrPlus());\r\n+   */\n+\n+  @Override\n+  protected void setup(Context context)\n+    throws IOException, InterruptedException {\n+    Configuration configuration = context.getConfiguration();\n+    cmd = configuration.get(Constants.BENCHMARK_CMD, \"bcast\");\n+    numMappers = configuration.getInt(Constants.NUM_MAPPERS, 1);\n+    numPartitions = configuration.getInt(Constants.NUM_PARTITIONS, 1);\n+    bytesPerPartition = configuration.getInt(Constants.BYTES_PER_PARTITION, 1);\n+    numIterations = configuration.getInt(Constants.NUM_ITERATIONS, 1);\n+    LOG.info(\"Benchmark CMD \" + cmd);\n+    LOG.info(\"Num Mappers \" + numMappers);\n+    LOG.info(\"Num Partitions \" + numPartitions);\n+    LOG.info(\"Bytes per Partition \" + bytesPerPartition);\n+    LOG.info(\"Num Iterations \" + numIterations);\n+  }\n+\n+\n+  protected void mapCollective(KeyValReader reader,\n+                               Context context)\n+                               throws IOException, InterruptedException {\r\n+    // Read key-value pairs\n+\n+    while (reader.nextKeyValue()) {\n+      String key = reader.getCurrentKey();\n+      String value = reader.getCurrentValue();\n+      LOG.info(\"Key: \" + key + \", Value: \" + value);\n+    }\n+    int workerID = this.getSelfID();\n+    int numWorkers = this.getNumWorkers();\n+    Random rand = new Random(workerID);\n+    if (cmd.equals(\"allreduce\")) {\n+      long startTime = System.currentTimeMillis();\n+      for (int i = 0; i < numIterations; i++) {\n+        Table<DoubleArray> arrTable = new Table<>(i, new DoubleArrPlus());\r\n+        // Create DoubleArray\n+        int size = bytesPerPartition / 8;\n+        for (int j = 0; j < numPartitions; j++) {\n+          DoubleArray array = DoubleArray.create(size, false);\n+          array.get()[0] = rand.nextInt(1000);\n+          array.get()[array.size() - 1] = rand.nextInt(1000);\n+          LOG.info(\"before allreduce: \" + j + \" \" + array.get()[0]\n+              + \" \" + array.get()[array.size() - 1]);\n+          arrTable.addPartition(new Partition<>(j, array));\n+        }\n+        allreduce(\"main\", \"allreduce-\" + i, arrTable);\n+        for (Partition<DoubleArray> partition : arrTable.getPartitions()) {\n+          DoubleArray array = partition.get();\n+          LOG.info(\"after allreduce: \" + partition.id() + \" \" + array.get()[0]\n+              + \" \" + array.get()[array.size() - 1]);\n+        }\n+        arrTable.release();\n+      }\n+\n+      long endTime = System.currentTimeMillis();\n+      LOG.info(\"Total allreduce time: \" + (endTime - startTime) + \" number of iterations: \" + numIterations);\n+    } else if (cmd.equals(\"allgather\")) {\n+      long startTime = System.currentTimeMillis();\n+      for (int i = 0; i < numIterations; i++) {\n+        Table<DoubleArray> arrTable = new Table<>(i, new DoubleArrPlus());\n         int size = bytesPerPartition / 8;\r\n-        // Generate data\r\n-        for (int j = 0; j < numPartitions; j++) {\r\n-          int partitionID =\r\n-            workerID + numWorkers * j;\r\n-          DoubleArray array =\r\n-            DoubleArray.create(size, false);\r\n-          array.get()[0] = rand.nextDouble();\r\n-          array.get()[array.size() - 1] =\r\n-            rand.nextDouble();\r\n-          LOG.info(\r\n-            \"before allgather: \" + partitionID\r\n-              + \" \" + array.get()[0] + \" \"\r\n-              + array.get()[array.size() - 1]);\r\n-          arrTable.addPartition(\r\n-            new Partition<DoubleArray>(\r\n-              partitionID, array));\r\n-        }\r\n-        allgather(\"main\", \"allgather-\" + i,\r\n-          arrTable);\r\n-        for (Partition<DoubleArray> partition : arrTable\r\n-          .getPartitions()) {\r\n-          DoubleArray array = partition.get();\r\n-          LOG.info(\r\n-            \"after allgather: \" + partition.id()\r\n-              + \" \" + array.get()[0] + \" \"\r\n-              + array.get()[array.size() - 1]);\r\n-        }\r\n-        arrTable.release();\r\n-      }\r\n-      long endTime = System.currentTimeMillis();\r\n-      LOG.info(\"Total allgather time: \"\r\n-        + (endTime - startTime));\r\n-    }\r\n-  }\r\n-}\r\n+        // Generate data\n+        for (int j = 0; j < numPartitions; j++) {\n+          int partitionID = workerID + numWorkers * j;\n+          DoubleArray array = DoubleArray.create(size, false);\n+          array.get()[0] = rand.nextDouble();\n+          array.get()[array.size() - 1] = rand.nextDouble();\n+          LOG.info(\"before allgather: \" + partitionID + \" \" + array.get()[0]\n+              + \" \" + array.get()[array.size() - 1]);\n+          arrTable.addPartition(new Partition<DoubleArray>(partitionID, array));\n+        }\n+        allgather(\"main\", \"allgather-\" + i, arrTable);\n+        for (Partition<DoubleArray> partition : arrTable.getPartitions()) {\n+          DoubleArray array = partition.get();\n+          LOG.info(\"after allgather: \" + partition.id() + \" \" + array.get()[0]\n+              + \" \" + array.get()[array.size() - 1]);\n+        }\n+        arrTable.release();\n+      }\n+\n+      long endTime = System.currentTimeMillis();\n+      LOG.info(\"Total allgather time: \" + (endTime - startTime));\n+    }\n+  }\n+}\n\\ No newline at end of file\n",
            "diff_size": 132
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "3",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "3",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}