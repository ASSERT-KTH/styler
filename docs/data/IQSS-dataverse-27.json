{
    "project_name": "IQSS-dataverse",
    "error_id": "27",
    "information": {
        "errors": [
            {
                "line": "158",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "    // It must be called before we attempt to permanently save the files in \n    // the database by calling the Save command on the dataset and/or version. \n\tpublic List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n\t\tList<DataFile> ret = new ArrayList<>();\n\n\t\tif (newFiles != null && newFiles.size() > 0) {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "159",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/27/IngestServiceBean.java\nindex cf3c62ef584..a4e011fea11 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/27/IngestServiceBean.java\n@@ -155,7 +155,7 @@ public class IngestServiceBean {\n     // DataFileCategory objects, if any were already assigned to the files). \n     // It must be called before we attempt to permanently save the files in \n     // the database by calling the Save command on the dataset and/or version. \n-\tpublic List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n+public List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n \t\tList<DataFile> ret = new ArrayList<>();\n \n \t\tif (newFiles != null && newFiles.size() > 0) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/27/IngestServiceBean.java\nindex cf3c62ef584..397ca7d7670 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/27/IngestServiceBean.java\n@@ -115,468 +115,474 @@ import javax.jms.Message;\n import javax.faces.application.FacesMessage;\n \n /**\n- *\n  * @author Leonid Andreev\n  * dataverse 4.0\n  * New service for handling ingest tasks\n- * \n  */\n @Stateless\n @Named\n public class IngestServiceBean {\n-    private static final Logger logger = Logger.getLogger(IngestServiceBean.class.getCanonicalName());\n-    @EJB\n-    VariableServiceBean variableService;\n-    @EJB \n-    DatasetServiceBean datasetService;\n-    @EJB\n-    DatasetFieldServiceBean fieldService;\n-    @EJB\n-    DataFileServiceBean fileService; \n-    @EJB\n-    SystemConfig systemConfig;\n-\n-    @Resource(lookup = \"java:app/jms/queue/ingest\")\n-    Queue queue;\n-    @Resource(lookup = \"java:app/jms/factory/ingest\")\n-    QueueConnectionFactory factory;\n-    \n+  private static final Logger logger = Logger.getLogger(IngestServiceBean.class.getCanonicalName());\n+  @EJB\n+  VariableServiceBean variableService;\n+  @EJB\n+  DatasetServiceBean datasetService;\n+  @EJB\n+  DatasetFieldServiceBean fieldService;\n+  @EJB\n+  DataFileServiceBean fileService;\n+  @EJB\n+  SystemConfig systemConfig;\n+\n+  @Resource(lookup = \"java:app/jms/queue/ingest\")\n+  Queue queue;\n+  @Resource(lookup = \"java:app/jms/factory/ingest\")\n+  QueueConnectionFactory factory;\n+\n+\n+  private static String timeFormat_hmsS = \"HH:mm:ss.SSS\";\n+  private static String dateTimeFormat_ymdhmsS = \"yyyy-MM-dd HH:mm:ss.SSS\";\n+  private static String dateFormat_ymd = \"yyyy-MM-dd\";\n+\n+  // This method tries to permanently store new files on the filesystem.\n+  // Then it adds the files that *have been successfully saved* to the\n+  // dataset (by attaching the DataFiles to the Dataset, and the corresponding\n+  // FileMetadatas to the DatasetVersion). It also tries to ensure that none\n+  // of the parts of the DataFiles that failed to be saved (if any) are still\n+  // attached to the Dataset via some cascade path (for example, via\n+  // DataFileCategory objects, if any were already assigned to the files).\n+  // It must be called before we attempt to permanently save the files in\n+  // the database by calling the Save command on the dataset and/or version.\n+  public List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles,\n+                                                 DataFile fileToReplace) {\n+    List<DataFile> ret = new ArrayList<>();\n+\n+    if (newFiles != null && newFiles.size() > 0) {\n+      // ret = new ArrayList<>();\n+      // final check for duplicate file names;\n+      // we tried to make the file names unique on upload, but then\n+      // the user may have edited them on the \"add files\" page, and\n+      // renamed FOOBAR-1.txt back to FOOBAR.txt...\n+      IngestUtil.checkForDuplicateFileNamesFinal(version, newFiles, fileToReplace);\n+      Dataset dataset = version.getDataset();\n+\n+      for (DataFile dataFile : newFiles) {\n+        boolean unattached = false;\n+        boolean savedSuccess = false;\n+        if (dataFile.getOwner() == null) {\n+          unattached = true;\n+          dataFile.setOwner(dataset);\n+        }\n \n-    private static String timeFormat_hmsS = \"HH:mm:ss.SSS\";\n-    private static String dateTimeFormat_ymdhmsS = \"yyyy-MM-dd HH:mm:ss.SSS\";\n-    private static String dateFormat_ymd = \"yyyy-MM-dd\";\n-    \n-    // This method tries to permanently store new files on the filesystem. \n-    // Then it adds the files that *have been successfully saved* to the \n-    // dataset (by attaching the DataFiles to the Dataset, and the corresponding\n-    // FileMetadatas to the DatasetVersion). It also tries to ensure that none \n-    // of the parts of the DataFiles that failed to be saved (if any) are still\n-    // attached to the Dataset via some cascade path (for example, via \n-    // DataFileCategory objects, if any were already assigned to the files). \n-    // It must be called before we attempt to permanently save the files in \n-    // the database by calling the Save command on the dataset and/or version. \n-\tpublic List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n-\t\tList<DataFile> ret = new ArrayList<>();\n-\n-\t\tif (newFiles != null && newFiles.size() > 0) {\n-\t\t\t// ret = new ArrayList<>();\n-\t\t\t// final check for duplicate file names;\n-\t\t\t// we tried to make the file names unique on upload, but then\n-\t\t\t// the user may have edited them on the \"add files\" page, and\n-\t\t\t// renamed FOOBAR-1.txt back to FOOBAR.txt...\n-            IngestUtil.checkForDuplicateFileNamesFinal(version, newFiles, fileToReplace);\n-\t\t\tDataset dataset = version.getDataset();\n-\n-\t\t\tfor (DataFile dataFile : newFiles) {\n-\t\t\t\tboolean unattached = false;\n-\t\t\t\tboolean savedSuccess = false;\n-\t\t\t\tif (dataFile.getOwner() == null) {\n-\t\t\t\t\tunattached = true;\n-\t\t\t\t\tdataFile.setOwner(dataset);\n-\t\t\t\t}\n-\n-\t\t\t\tString[] storageInfo = DataAccess.getDriverIdAndStorageLocation(dataFile.getStorageIdentifier());\n-\t\t\t\tString driverType = DataAccess.getDriverType(storageInfo[0]);\n-\t\t\t\tString storageLocation = storageInfo[1];\n-\t\t\t\tString tempFileLocation = null;\n-\t\t\t\tPath tempLocationPath = null;\n-\t\t\t\tif (driverType.equals(\"tmp\")) {  //\"tmp\" is the default if no prefix or the \"tmp://\" driver\n-\t\t\t\t\ttempFileLocation = FileUtil.getFilesTempDirectory() + \"/\" + storageLocation;\n-\n-\t\t\t\t\t// Try to save the file in its permanent location:\n-\t\t\t\t\ttempLocationPath = Paths.get(tempFileLocation);\n-\t\t\t\t\tWritableByteChannel writeChannel = null;\n-\t\t\t\t\tFileChannel readChannel = null;\n-\n-\t\t\t\t\tStorageIO<DataFile> dataAccess = null;\n-\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tlogger.fine(\"Attempting to create a new storageIO object for \" + storageLocation);\n-\t\t\t\t\t\tdataAccess = DataAccess.createNewStorageIO(dataFile, storageLocation);\n-\n-\t\t\t\t\t\tlogger.fine(\"Successfully created a new storageIO object.\");\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * This commented-out code demonstrates how to copy bytes from a local\n-\t\t\t\t\t\t * InputStream (or a readChannel) into the writable byte channel of a Dataverse\n-\t\t\t\t\t\t * DataAccessIO object:\n-\t\t\t\t\t\t */\n-\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * storageIO.open(DataAccessOption.WRITE_ACCESS);\n-\t\t\t\t\t\t * \n-\t\t\t\t\t\t * writeChannel = storageIO.getWriteChannel(); readChannel = new\n-\t\t\t\t\t\t * FileInputStream(tempLocationPath.toFile()).getChannel();\n-\t\t\t\t\t\t * \n-\t\t\t\t\t\t * long bytesPerIteration = 16 * 1024; // 16K bytes long start = 0; while (\n-\t\t\t\t\t\t * start < readChannel.size() ) { readChannel.transferTo(start,\n-\t\t\t\t\t\t * bytesPerIteration, writeChannel); start += bytesPerIteration; }\n-\t\t\t\t\t\t */\n-\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * But it's easier to use this convenience method from the DataAccessIO:\n-\t\t\t\t\t\t * \n-\t\t\t\t\t\t * (if the underlying storage method for this file is local filesystem, the\n-\t\t\t\t\t\t * DataAccessIO will simply copy the file using Files.copy, like this:\n-\t\t\t\t\t\t * \n-\t\t\t\t\t\t * Files.copy(tempLocationPath, storageIO.getFileSystemLocation(),\n-\t\t\t\t\t\t * StandardCopyOption.REPLACE_EXISTING);\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tdataAccess.savePath(tempLocationPath);\n-\n-\t\t\t\t\t\t// Set filesize in bytes\n-\t\t\t\t\t\t//\n-\t\t\t\t\t\tdataFile.setFilesize(dataAccess.getSize());\n-\t\t\t\t\t\tsavedSuccess = true;\n-\t\t\t\t\t\tlogger.fine(\"Success: permanently saved file \" + dataFile.getFileMetadata().getLabel());\n-\n-\t\t\t\t\t} catch (IOException ioex) {\n-                    logger.warning(\"Failed to save the file, storage id \" + dataFile.getStorageIdentifier() + \" (\" + ioex.getMessage() + \")\");\n-\t\t\t\t\t} finally {\n-\t\t\t\t\t\tif (readChannel != null) {\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\treadChannel.close();\n-\t\t\t\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (writeChannel != null) {\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\twriteChannel.close();\n-\t\t\t\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-                    // Since we may have already spent some CPU cycles scaling down image thumbnails, \n-\t\t\t\t\t// we may as well save them, by moving these generated images to the permanent\n-\t\t\t\t\t// dataset directory. We should also remember to delete any such files in the\n-\t\t\t\t\t// temp directory:\n-\t\t\t\t\tList<Path> generatedTempFiles = listGeneratedTempFiles(Paths.get(FileUtil.getFilesTempDirectory()),\n-\t\t\t\t\t\t\tstorageLocation);\n-\t\t\t\t\tif (generatedTempFiles != null) {\n-\t\t\t\t\t\tfor (Path generated : generatedTempFiles) {\n-\t\t\t\t\t\t\tif (savedSuccess) { // no need to try to save this aux file permanently, if we've failed to\n-\t\t\t\t\t\t\t\t\t\t\t\t// save the main file!\n-\t\t\t\t\t\t\t\tlogger.fine(\"(Will also try to permanently save generated thumbnail file \"\n-\t\t\t\t\t\t\t\t\t\t+ generated.toString() + \")\");\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t// Files.copy(generated, Paths.get(dataset.getFileSystemDirectory().toString(),\n-\t\t\t\t\t\t\t\t\t// generated.getFileName().toString()));\n-\t\t\t\t\t\t\t\t\tint i = generated.toString().lastIndexOf(\"thumb\");\n-\t\t\t\t\t\t\t\t\tif (i > 1) {\n-\t\t\t\t\t\t\t\t\t\tString extensionTag = generated.toString().substring(i);\n-\t\t\t\t\t\t\t\t\t\tdataAccess.savePathAsAux(generated, extensionTag);\n-\t\t\t\t\t\t\t\t\t\tlogger.fine(\n-\t\t\t\t\t\t\t\t\t\t\t\t\"Saved generated thumbnail as aux object. \\\"preview available\\\" status: \"\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ dataFile.isPreviewImageAvailable());\n-\t\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t\tlogger.warning(\n-\t\t\t\t\t\t\t\t\t\t\t\t\"Generated thumbnail file name does not match the expected pattern: \"\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ generated.toString());\n-\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t} catch (IOException ioex) {\n-\t\t\t\t\t\t\t\t\tlogger.warning(\"Failed to save generated file \" + generated.toString());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t// ... but we definitely want to delete it:\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tFiles.delete(generated);\n-\t\t\t\t\t\t\t} catch (IOException ioex) {\n-\t\t\t\t\t\t\t\tlogger.warning(\"Failed to delete generated file \" + generated.toString());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif (unattached) {\n-\t\t\t\t\t\tdataFile.setOwner(null);\n-\t\t\t\t\t}\n-\t\t\t\t\t// Any necessary post-processing:\n-\t\t\t\t\t// performPostProcessingTasks(dataFile);\n-\t\t\t\t} else {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tStorageIO<DvObject> dataAccess = DataAccess.getStorageIO(dataFile);\n-\t\t\t\t\t\t//Populate metadata\n-\t\t\t\t\t\tdataAccess.open(DataAccessOption.READ_ACCESS);\n-\t\t\t\t\t\t//set file size\n-\t\t\t\t\t\tdataFile.setFilesize(dataAccess.getSize());\n-\t\t\t\t\t\tif(dataAccess instanceof S3AccessIO) {\n-\t\t\t\t\t\t\t  ((S3AccessIO<DvObject>)dataAccess).removeTempTag();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (IOException ioex) {\n-\t\t\t\t\t\tlogger.warning(\"Failed to get file size, storage id \" + dataFile.getStorageIdentifier() + \" (\"\n-\t\t\t\t\t\t\t\t+ ioex.getMessage() + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\tsavedSuccess = true;\n-\t\t\t\t\tdataFile.setOwner(null);\n-\t\t\t\t}\n-\n-\t\t\t\tlogger.fine(\"Done! Finished saving new files in permanent storage and adding them to the dataset.\");\n-\t\t\t\tboolean belowLimit = false;\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tbelowLimit = dataFile.getStorageIO().isBelowIngestSizeLimit();\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tlogger.warning(\"Error getting ingest limit for file: \" + dataFile.getIdentifier() + \" : \" + e.getMessage());\n-\t\t\t\t} \n-\n-\t\t\t\tif (savedSuccess && belowLimit) {\n-\t\t\t\t\t// These are all brand new files, so they should all have\n-\t\t\t\t\t// one filemetadata total. -- L.A.\n-\t\t\t\t\tFileMetadata fileMetadata = dataFile.getFileMetadatas().get(0);\n-\t\t\t\t\tString fileName = fileMetadata.getLabel();\n-\n-\t\t\t\t\tboolean metadataExtracted = false;\n-\t\t\t\t\tif (FileUtil.canIngestAsTabular(dataFile)) {\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * Note that we don't try to ingest the file right away - instead we mark it as\n-\t\t\t\t\t\t * \"scheduled for ingest\", then at the end of the save process it will be queued\n-\t\t\t\t\t\t * for async. ingest in the background. In the meantime, the file will be\n-\t\t\t\t\t\t * ingested as a regular, non-tabular file, and appear as such to the user,\n-\t\t\t\t\t\t * until the ingest job is finished with the Ingest Service.\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tdataFile.SetIngestScheduled();\n-\t\t\t\t\t} else if (fileMetadataExtractable(dataFile)) {\n-\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// FITS is the only type supported for metadata\n-\t\t\t\t\t\t\t// extraction, as of now. -- L.A. 4.0\n-\t\t\t\t\t\t\tdataFile.setContentType(\"application/fits\");\n-\t\t\t\t\t\t\tmetadataExtracted = extractMetadata(tempFileLocation, dataFile, version);\n-\t\t\t\t\t\t} catch (IOException mex) {\n-\t\t\t\t\t\t\tlogger.severe(\"Caught exception trying to extract indexable metadata from file \"\n-\t\t\t\t\t\t\t\t\t+ fileName + \",  \" + mex.getMessage());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (metadataExtracted) {\n-\t\t\t\t\t\t\tlogger.fine(\"Successfully extracted indexable metadata from file \" + fileName);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tlogger.fine(\"Failed to extract indexable metadata from file \" + fileName);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else if (FileUtil.MIME_TYPE_INGESTED_FILE.equals(dataFile.getContentType())) {\n-                        // Make sure no *uningested* tab-delimited files are saved with the type \"text/tab-separated-values\"!\n-                        // \"text/tsv\" should be used instead: \n-                        dataFile.setContentType(FileUtil.MIME_TYPE_TSV);\n-                    }\n-\t\t\t\t}\n-\t\t\t\t// ... and let's delete the main temp file if it exists:\n-\t\t\t\tif(tempLocationPath!=null) {\n-    \t\t\t\ttry {\n-\t    \t\t\t\tlogger.fine(\"Will attempt to delete the temp file \" + tempLocationPath.toString());\n-\t\t\t    \t\tFiles.delete(tempLocationPath);\n-\t\t\t\t    } catch (IOException ex) {\n-\t\t\t\t\t    // (non-fatal - it's just a temp file.)\n-    \t\t\t\t\tlogger.warning(\"Failed to delete temp file \" + tempLocationPath.toString());\n-\t    \t\t\t}\t\t\t\t\n-\t\t\t\t}\n-\t\t\t\tif (savedSuccess) {\n-\t\t\t\t\t// temp dbug line\n-\t\t\t\t\t// System.out.println(\"ADDING FILE: \" + fileName + \"; for dataset: \" +\n-\t\t\t\t\t// dataset.getGlobalId());\n-\t\t\t\t\t// Make sure the file is attached to the dataset and to the version, if this\n-\t\t\t\t\t// hasn't been done yet:\n-\t\t\t\t\tif (dataFile.getOwner() == null) {\n-\t\t\t\t\t\tdataFile.setOwner(dataset);\n-\n-\t\t\t\t\t\tversion.getFileMetadatas().add(dataFile.getFileMetadata());\n-\t\t\t\t\t\tdataFile.getFileMetadata().setDatasetVersion(version);\n-\t\t\t\t\t\tdataset.getFiles().add(dataFile);\n-\n-\t\t\t\t\t\tif (dataFile.getFileMetadata().getCategories() != null) {\n-\t\t\t\t\t\t\tListIterator<DataFileCategory> dfcIt = dataFile.getFileMetadata().getCategories()\n-\t\t\t\t\t\t\t\t\t.listIterator();\n-\n-\t\t\t\t\t\t\twhile (dfcIt.hasNext()) {\n-\t\t\t\t\t\t\t\tDataFileCategory dataFileCategory = dfcIt.next();\n-\n-\t\t\t\t\t\t\t\tif (dataFileCategory.getDataset() == null) {\n-\t\t\t\t\t\t\t\t\tDataFileCategory newCategory = dataset\n-\t\t\t\t\t\t\t\t\t\t\t.getCategoryByName(dataFileCategory.getName());\n-\t\t\t\t\t\t\t\t\tif (newCategory != null) {\n-\t\t\t\t\t\t\t\t\t\tnewCategory.addFileMetadata(dataFile.getFileMetadata());\n-\t\t\t\t\t\t\t\t\t\t// dataFileCategory = newCategory;\n-\t\t\t\t\t\t\t\t\t\tdfcIt.set(newCategory);\n-\t\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t\tdfcIt.remove();\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tret.add(dataFile);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn ret;\n-\t}\n-    \n-    public List<Path> listGeneratedTempFiles(Path tempDirectory, String baseName) {\n-        List<Path> generatedFiles = new ArrayList<>();\n+        String[] storageInfo = DataAccess.getDriverIdAndStorageLocation(dataFile.getStorageIdentifier());\n+        String driverType = DataAccess.getDriverType(storageInfo[0]);\n+        String storageLocation = storageInfo[1];\n+        String tempFileLocation = null;\n+        Path tempLocationPath = null;\n+        if (driverType.equals(\"tmp\")) {  //\"tmp\" is the default if no prefix or the \"tmp://\" driver\n+          tempFileLocation = FileUtil.getFilesTempDirectory() + \"/\" + storageLocation;\n+\n+          // Try to save the file in its permanent location:\n+          tempLocationPath = Paths.get(tempFileLocation);\n+          WritableByteChannel writeChannel = null;\n+          FileChannel readChannel = null;\n+\n+          StorageIO<DataFile> dataAccess = null;\n+\n+          try {\n+            logger.fine(\"Attempting to create a new storageIO object for \" + storageLocation);\n+            dataAccess = DataAccess.createNewStorageIO(dataFile, storageLocation);\n+\n+            logger.fine(\"Successfully created a new storageIO object.\");\n+            /*\n+             * This commented-out code demonstrates how to copy bytes from a local\n+             * InputStream (or a readChannel) into the writable byte channel of a Dataverse\n+             * DataAccessIO object:\n+             */\n \n-        // for example, <filename>.thumb64 or <filename>.thumb400.\n+            /*\n+             * storageIO.open(DataAccessOption.WRITE_ACCESS);\n+             *\n+             * writeChannel = storageIO.getWriteChannel(); readChannel = new\n+             * FileInputStream(tempLocationPath.toFile()).getChannel();\n+             *\n+             * long bytesPerIteration = 16 * 1024; // 16K bytes long start = 0; while (\n+             * start < readChannel.size() ) { readChannel.transferTo(start,\n+             * bytesPerIteration, writeChannel); start += bytesPerIteration; }\n+             */\n \n-        if (baseName == null || baseName.equals(\"\")) {\n-            return null;\n-        }\n+            /*\n+             * But it's easier to use this convenience method from the DataAccessIO:\n+             *\n+             * (if the underlying storage method for this file is local filesystem, the\n+             * DataAccessIO will simply copy the file using Files.copy, like this:\n+             *\n+             * Files.copy(tempLocationPath, storageIO.getFileSystemLocation(),\n+             * StandardCopyOption.REPLACE_EXISTING);\n+             */\n+            dataAccess.savePath(tempLocationPath);\n+\n+            // Set filesize in bytes\n+            //\n+            dataFile.setFilesize(dataAccess.getSize());\n+            savedSuccess = true;\n+            logger.fine(\"Success: permanently saved file \" + dataFile.getFileMetadata().getLabel());\n+\n+          } catch (IOException ioex) {\n+            logger.warning(\n+              \"Failed to save the file, storage id \" + dataFile.getStorageIdentifier() + \" (\" + ioex.getMessage() +\n+                \")\");\n+          } finally {\n+            if (readChannel != null) {\n+              try {\n+                readChannel.close();\n+              } catch (IOException e) {\n+              }\n+            }\n+            if (writeChannel != null) {\n+              try {\n+                writeChannel.close();\n+              } catch (IOException e) {\n+              }\n+            }\n+          }\n+\n+          // Since we may have already spent some CPU cycles scaling down image thumbnails,\n+          // we may as well save them, by moving these generated images to the permanent\n+          // dataset directory. We should also remember to delete any such files in the\n+          // temp directory:\n+          List<Path> generatedTempFiles = listGeneratedTempFiles(Paths.get(FileUtil.getFilesTempDirectory()),\n+            storageLocation);\n+          if (generatedTempFiles != null) {\n+            for (Path generated : generatedTempFiles) {\n+              if (savedSuccess) { // no need to try to save this aux file permanently, if we've failed to\n+                // save the main file!\n+                logger.fine(\"(Will also try to permanently save generated thumbnail file \"\n+                  + generated.toString() + \")\");\n+                try {\n+                  // Files.copy(generated, Paths.get(dataset.getFileSystemDirectory().toString(),\n+                  // generated.getFileName().toString()));\n+                  int i = generated.toString().lastIndexOf(\"thumb\");\n+                  if (i > 1) {\n+                    String extensionTag = generated.toString().substring(i);\n+                    dataAccess.savePathAsAux(generated, extensionTag);\n+                    logger.fine(\n+                      \"Saved generated thumbnail as aux object. \\\"preview available\\\" status: \"\n+                        + dataFile.isPreviewImageAvailable());\n+                  } else {\n+                    logger.warning(\n+                      \"Generated thumbnail file name does not match the expected pattern: \"\n+                        + generated.toString());\n+                  }\n \n-        DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() {\n-            @Override\n-            public boolean accept(Path file) throws IOException {\n-                return (file.getFileName() != null\n-                        && file.getFileName().toString().startsWith(baseName + \".thumb\"));\n+                } catch (IOException ioex) {\n+                  logger.warning(\"Failed to save generated file \" + generated.toString());\n+                }\n+              }\n+\n+              // ... but we definitely want to delete it:\n+              try {\n+                Files.delete(generated);\n+              } catch (IOException ioex) {\n+                logger.warning(\"Failed to delete generated file \" + generated.toString());\n+              }\n             }\n-        };\n+          }\n \n-        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(tempDirectory, filter)) {\n-            for (Path filePath : dirStream) {\n-                generatedFiles.add(filePath);\n+          if (unattached) {\n+            dataFile.setOwner(null);\n+          }\n+          // Any necessary post-processing:\n+          // performPostProcessingTasks(dataFile);\n+        } else {\n+          try {\n+            StorageIO<DvObject> dataAccess = DataAccess.getStorageIO(dataFile);\n+            //Populate metadata\n+            dataAccess.open(DataAccessOption.READ_ACCESS);\n+            //set file size\n+            dataFile.setFilesize(dataAccess.getSize());\n+            if (dataAccess instanceof S3AccessIO) {\n+              ((S3AccessIO<DvObject>) dataAccess).removeTempTag();\n             }\n-        } catch (IOException ex) {\n+          } catch (IOException ioex) {\n+            logger.warning(\"Failed to get file size, storage id \" + dataFile.getStorageIdentifier() + \" (\"\n+              + ioex.getMessage() + \")\");\n+          }\n+          savedSuccess = true;\n+          dataFile.setOwner(null);\n         }\n \n-        return generatedFiles;\n-    }\n-    \n-    \n-   \n-    \n-    // TODO: consider creating a version of this method that would take \n-    // datasetversion as the argument. \n-    // -- L.A. 4.6\n-    public void startIngestJobsForDataset(Dataset dataset, AuthenticatedUser user) {\n-        List<DataFile> scheduledFiles = new ArrayList<>();\n-                \n-        for (DataFile dataFile : dataset.getFiles()) {\n-            if (dataFile.isIngestScheduled()) {\n-                // todo: investigate why when calling save with the file object\n-                // gotten from the loop, the roles assignment added at create is removed\n-                // (switching to refinding via id resolves that)                \n-                dataFile = fileService.find(dataFile.getId());\n-                scheduledFiles.add(dataFile);\n+        logger.fine(\"Done! Finished saving new files in permanent storage and adding them to the dataset.\");\n+        boolean belowLimit = false;\n+\n+        try {\n+          belowLimit = dataFile.getStorageIO().isBelowIngestSizeLimit();\n+        } catch (IOException e) {\n+          logger.warning(\"Error getting ingest limit for file: \" + dataFile.getIdentifier() + \" : \" + e.getMessage());\n+        }\n+\n+        if (savedSuccess && belowLimit) {\n+          // These are all brand new files, so they should all have\n+          // one filemetadata total. -- L.A.\n+          FileMetadata fileMetadata = dataFile.getFileMetadatas().get(0);\n+          String fileName = fileMetadata.getLabel();\n+\n+          boolean metadataExtracted = false;\n+          if (FileUtil.canIngestAsTabular(dataFile)) {\n+            /*\n+             * Note that we don't try to ingest the file right away - instead we mark it as\n+             * \"scheduled for ingest\", then at the end of the save process it will be queued\n+             * for async. ingest in the background. In the meantime, the file will be\n+             * ingested as a regular, non-tabular file, and appear as such to the user,\n+             * until the ingest job is finished with the Ingest Service.\n+             */\n+            dataFile.SetIngestScheduled();\n+          } else if (fileMetadataExtractable(dataFile)) {\n+\n+            try {\n+              // FITS is the only type supported for metadata\n+              // extraction, as of now. -- L.A. 4.0\n+              dataFile.setContentType(\"application/fits\");\n+              metadataExtracted = extractMetadata(tempFileLocation, dataFile, version);\n+            } catch (IOException mex) {\n+              logger.severe(\"Caught exception trying to extract indexable metadata from file \"\n+                + fileName + \",  \" + mex.getMessage());\n+            }\n+            if (metadataExtracted) {\n+              logger.fine(\"Successfully extracted indexable metadata from file \" + fileName);\n+            } else {\n+              logger.fine(\"Failed to extract indexable metadata from file \" + fileName);\n+            }\n+          } else if (FileUtil.MIME_TYPE_INGESTED_FILE.equals(dataFile.getContentType())) {\n+            // Make sure no *uningested* tab-delimited files are saved with the type \"text/tab-separated-values\"!\n+            // \"text/tsv\" should be used instead:\n+            dataFile.setContentType(FileUtil.MIME_TYPE_TSV);\n+          }\n+        }\n+        // ... and let's delete the main temp file if it exists:\n+        if (tempLocationPath != null) {\n+          try {\n+            logger.fine(\"Will attempt to delete the temp file \" + tempLocationPath.toString());\n+            Files.delete(tempLocationPath);\n+          } catch (IOException ex) {\n+            // (non-fatal - it's just a temp file.)\n+            logger.warning(\"Failed to delete temp file \" + tempLocationPath.toString());\n+          }\n+        }\n+        if (savedSuccess) {\n+          // temp dbug line\n+          // System.out.println(\"ADDING FILE: \" + fileName + \"; for dataset: \" +\n+          // dataset.getGlobalId());\n+          // Make sure the file is attached to the dataset and to the version, if this\n+          // hasn't been done yet:\n+          if (dataFile.getOwner() == null) {\n+            dataFile.setOwner(dataset);\n+\n+            version.getFileMetadatas().add(dataFile.getFileMetadata());\n+            dataFile.getFileMetadata().setDatasetVersion(version);\n+            dataset.getFiles().add(dataFile);\n+\n+            if (dataFile.getFileMetadata().getCategories() != null) {\n+              ListIterator<DataFileCategory> dfcIt = dataFile.getFileMetadata().getCategories()\n+                .listIterator();\n+\n+              while (dfcIt.hasNext()) {\n+                DataFileCategory dataFileCategory = dfcIt.next();\n+\n+                if (dataFileCategory.getDataset() == null) {\n+                  DataFileCategory newCategory = dataset\n+                    .getCategoryByName(dataFileCategory.getName());\n+                  if (newCategory != null) {\n+                    newCategory.addFileMetadata(dataFile.getFileMetadata());\n+                    // dataFileCategory = newCategory;\n+                    dfcIt.set(newCategory);\n+                  } else {\n+                    dfcIt.remove();\n+                  }\n+                }\n+              }\n             }\n+          }\n         }\n \n-        startIngestJobs(scheduledFiles, user);\n+        ret.add(dataFile);\n+      }\n     }\n-    \n-    public String startIngestJobs(List<DataFile> dataFiles, AuthenticatedUser user) {\n \n-        IngestMessage ingestMessage = null;\n-        StringBuilder sb = new StringBuilder();\n+    return ret;\n+  }\n \n-        List<DataFile> scheduledFiles = new ArrayList<>();\n-        for (DataFile dataFile : dataFiles) {\n-            // refresh the copy of the DataFile:\n-            dataFile = fileService.find(dataFile.getId());\n-            \n-            if (dataFile.isIngestScheduled()) {\n+  public List<Path> listGeneratedTempFiles(Path tempDirectory, String baseName) {\n+    List<Path> generatedFiles = new ArrayList<>();\n \n-                long ingestSizeLimit = 0;\n-                try {\n-                    ingestSizeLimit = systemConfig.getTabularIngestSizeLimit(getTabDataReaderByMimeType(dataFile.getContentType()).getFormatName());\n-                } catch (IOException ioex) {\n-                    logger.warning(\"IO Exception trying to retrieve the ingestable format identifier from the plugin for type \" + dataFile.getContentType() + \" (non-fatal);\");\n-                }\n+    // for example, <filename>.thumb64 or <filename>.thumb400.\n \n-                if (ingestSizeLimit == -1 || dataFile.getFilesize() < ingestSizeLimit) {\n-                    dataFile.SetIngestInProgress();\n-                    scheduledFiles.add(dataFile);\n-                } else {\n-                    dataFile.setIngestDone();\n-                    String message = \"Skipping tabular ingest of the file \" + dataFile.getFileMetadata().getLabel() + \", because of the size limit (set to \" + ingestSizeLimit + \" bytes); \";\n-                    logger.info(message);\n-                    sb.append(message);\n-                }\n-                dataFile = fileService.save(dataFile);\n-            } else {\n-                String message = \"(Re)ingest queueing request submitted on a file not scheduled for ingest! (\" + dataFile.getFileMetadata().getLabel() + \"); \";\n-                logger.warning(message);\n-                sb.append(message);\n-            }\n+    if (baseName == null || baseName.equals(\"\")) {\n+      return null;\n+    }\n+\n+    DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() {\n+      @Override\n+      public boolean accept(Path file) throws IOException {\n+        return (file.getFileName() != null\n+          && file.getFileName().toString().startsWith(baseName + \".thumb\"));\n+      }\n+    };\n+\n+    try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(tempDirectory, filter)) {\n+      for (Path filePath : dirStream) {\n+        generatedFiles.add(filePath);\n+      }\n+    } catch (IOException ex) {\n+    }\n+\n+    return generatedFiles;\n+  }\n+\n+\n+  // TODO: consider creating a version of this method that would take\n+  // datasetversion as the argument.\n+  // -- L.A. 4.6\n+  public void startIngestJobsForDataset(Dataset dataset, AuthenticatedUser user) {\n+    List<DataFile> scheduledFiles = new ArrayList<>();\n+\n+    for (DataFile dataFile : dataset.getFiles()) {\n+      if (dataFile.isIngestScheduled()) {\n+        // todo: investigate why when calling save with the file object\n+        // gotten from the loop, the roles assignment added at create is removed\n+        // (switching to refinding via id resolves that)\n+        dataFile = fileService.find(dataFile.getId());\n+        scheduledFiles.add(dataFile);\n+      }\n+    }\n+\n+    startIngestJobs(scheduledFiles, user);\n+  }\n+\n+  public String startIngestJobs(List<DataFile> dataFiles, AuthenticatedUser user) {\n+\n+    IngestMessage ingestMessage = null;\n+    StringBuilder sb = new StringBuilder();\n+\n+    List<DataFile> scheduledFiles = new ArrayList<>();\n+    for (DataFile dataFile : dataFiles) {\n+      // refresh the copy of the DataFile:\n+      dataFile = fileService.find(dataFile.getId());\n+\n+      if (dataFile.isIngestScheduled()) {\n+\n+        long ingestSizeLimit = 0;\n+        try {\n+          ingestSizeLimit = systemConfig\n+            .getTabularIngestSizeLimit(getTabDataReaderByMimeType(dataFile.getContentType()).getFormatName());\n+        } catch (IOException ioex) {\n+          logger.warning(\"IO Exception trying to retrieve the ingestable format identifier from the plugin for type \" +\n+            dataFile.getContentType() + \" (non-fatal);\");\n         }\n \n-        int count = scheduledFiles.size();\n-        \n-        if (count > 0) {\n-            String info = \"Ingest of \" + count + \" tabular data file(s) is in progress.\";\n-            logger.info(info);\n-            datasetService.addDatasetLock(scheduledFiles.get(0).getOwner().getId(),\n-                    DatasetLock.Reason.Ingest,\n-                    (user != null) ? user.getId() : null,\n-                    info);\n-            \n-            // Sort ingest jobs by file size: \n-            DataFile[] scheduledFilesArray = (DataFile[])scheduledFiles.toArray(new DataFile[count]);\n-            scheduledFiles = null; \n-            \n-            Arrays.sort(scheduledFilesArray, new Comparator<DataFile>() {\n-                @Override\n-                public int compare(DataFile d1, DataFile d2) {\n-                    long a = d1.getFilesize();\n-                    long b = d2.getFilesize();\n-                    return Long.valueOf(a).compareTo(b);\n-                }\n-            });\n+        if (ingestSizeLimit == -1 || dataFile.getFilesize() < ingestSizeLimit) {\n+          dataFile.SetIngestInProgress();\n+          scheduledFiles.add(dataFile);\n+        } else {\n+          dataFile.setIngestDone();\n+          String message = \"Skipping tabular ingest of the file \" + dataFile.getFileMetadata().getLabel() +\n+            \", because of the size limit (set to \" + ingestSizeLimit + \" bytes); \";\n+          logger.info(message);\n+          sb.append(message);\n+        }\n+        dataFile = fileService.save(dataFile);\n+      } else {\n+        String message = \"(Re)ingest queueing request submitted on a file not scheduled for ingest! (\" +\n+          dataFile.getFileMetadata().getLabel() + \"); \";\n+        logger.warning(message);\n+        sb.append(message);\n+      }\n+    }\n \n-            ingestMessage = new IngestMessage(IngestMessage.INGEST_MESAGE_LEVEL_INFO, user.getId());\n-            for (int i = 0; i < count; i++) {\n-                ingestMessage.addFileId(scheduledFilesArray[i].getId());\n-            }\n+    int count = scheduledFiles.size();\n+\n+    if (count > 0) {\n+      String info = \"Ingest of \" + count + \" tabular data file(s) is in progress.\";\n+      logger.info(info);\n+      datasetService.addDatasetLock(scheduledFiles.get(0).getOwner().getId(),\n+        DatasetLock.Reason.Ingest,\n+        (user != null) ? user.getId() : null,\n+        info);\n+\n+      // Sort ingest jobs by file size:\n+      DataFile[] scheduledFilesArray = (DataFile[]) scheduledFiles.toArray(new DataFile[count]);\n+      scheduledFiles = null;\n+\n+      Arrays.sort(scheduledFilesArray, new Comparator<DataFile>() {\n+        @Override\n+        public int compare(DataFile d1, DataFile d2) {\n+          long a = d1.getFilesize();\n+          long b = d2.getFilesize();\n+          return Long.valueOf(a).compareTo(b);\n+        }\n+      });\n \n-            QueueConnection conn = null;\n-            QueueSession session = null;\n-            QueueSender sender = null;\n+      ingestMessage = new IngestMessage(IngestMessage.INGEST_MESAGE_LEVEL_INFO, user.getId());\n+      for (int i = 0; i < count; i++) {\n+        ingestMessage.addFileId(scheduledFilesArray[i].getId());\n+      }\n \n-            try {\n-                conn = factory.createQueueConnection();\n-                session = conn.createQueueSession(false, 0);\n-                sender = session.createSender(queue);\n+      QueueConnection conn = null;\n+      QueueSession session = null;\n+      QueueSender sender = null;\n \n-                Message queueMessage = session.createObjectMessage(ingestMessage);\n+      try {\n+        conn = factory.createQueueConnection();\n+        session = conn.createQueueSession(false, 0);\n+        sender = session.createSender(queue);\n \n-                sender.send(queueMessage);\n+        Message queueMessage = session.createObjectMessage(ingestMessage);\n \n-            } catch (JMSException ex) {\n-                ex.printStackTrace();\n-                logger.warning(\"Caught exception trying to close connections after starting a (re)ingest job in the JMS queue! Stack trace below.\");\n-                sb.append(\"Failed to queue the (re)ingest job for DataFile (JMS Exception)\" + (ex.getMessage() != null ? ex.getMessage() : \"\"));\n-            } finally {\n-                try {\n+        sender.send(queueMessage);\n \n-                    if (sender != null) {\n-                        sender.close();\n-                    }\n-                    if (session != null) {\n-                        session.close();\n-                    }\n-                    if (conn != null) {\n-                        conn.close();\n-                    }\n-                } catch (Exception ex) {\n-                    logger.warning(\"Caught exception trying to close connections after starting a (re)ingest job in the JMS queue! Stack trace below.\");\n-                    ex.printStackTrace();\n-                }\n-            }\n+      } catch (JMSException ex) {\n+        ex.printStackTrace();\n+        logger.warning(\n+          \"Caught exception trying to close connections after starting a (re)ingest job in the JMS queue! Stack trace below.\");\n+        sb.append(\"Failed to queue the (re)ingest job for DataFile (JMS Exception)\" +\n+          (ex.getMessage() != null ? ex.getMessage() : \"\"));\n+      } finally {\n+        try {\n+\n+          if (sender != null) {\n+            sender.close();\n+          }\n+          if (session != null) {\n+            session.close();\n+          }\n+          if (conn != null) {\n+            conn.close();\n+          }\n+        } catch (Exception ex) {\n+          logger.warning(\n+            \"Caught exception trying to close connections after starting a (re)ingest job in the JMS queue! Stack trace below.\");\n+          ex.printStackTrace();\n         }\n-        \n-        return sb.toString();\n+      }\n     }\n \n-    \n-    public void produceSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n+    return sb.toString();\n+  }\n+\n+\n+  public void produceSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n         /*\n         logger.info(\"Skipping summary statistics and UNF.\");\n          */\n-        produceDiscreteNumericSummaryStatistics(dataFile, generatedTabularFile); \n-        produceContinuousSummaryStatistics(dataFile, generatedTabularFile);\n-        produceCharacterSummaryStatistics(dataFile, generatedTabularFile);\n-        \n-        recalculateDataFileUNF(dataFile);\n-        recalculateDatasetVersionUNF(dataFile.getFileMetadata().getDatasetVersion());\n-    }\n-    \n-    public void produceContinuousSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n+    produceDiscreteNumericSummaryStatistics(dataFile, generatedTabularFile);\n+    produceContinuousSummaryStatistics(dataFile, generatedTabularFile);\n+    produceCharacterSummaryStatistics(dataFile, generatedTabularFile);\n+\n+    recalculateDataFileUNF(dataFile);\n+    recalculateDatasetVersionUNF(dataFile.getFileMetadata().getDatasetVersion());\n+  }\n+\n+  public void produceContinuousSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n \n         /* \n         // quick, but memory-inefficient way:\n@@ -591,57 +597,62 @@ public class IngestServiceBean {\n         \n         TabularSubsetGenerator subsetGenerator = new TabularSubsetGenerator();\n         */\n-        \n-        for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n-            if (dataFile.getDataTable().getDataVariables().get(i).isIntervalContinuous()) {\n-                logger.fine(\"subsetting continuous vector\");\n-\n-                if (\"float\".equals(dataFile.getDataTable().getDataVariables().get(i).getFormat())) {\n-                    Float[] variableVector = TabularSubsetGenerator.subsetFloatVector(new FileInputStream(generatedTabularFile), i, dataFile.getDataTable().getCaseQuantity().intValue());\n-                    logger.fine(\"Calculating summary statistics on a Float vector;\");\n-                    calculateContinuousSummaryStatistics(dataFile, i, variableVector);\n-                    // calculate the UNF while we are at it:\n-                    logger.fine(\"Calculating UNF on a Float vector;\");\n-                    calculateUNF(dataFile, i, variableVector);\n-                    variableVector = null; \n-                } else {\n-                    Double[] variableVector = TabularSubsetGenerator.subsetDoubleVector(new FileInputStream(generatedTabularFile), i, dataFile.getDataTable().getCaseQuantity().intValue());\n-                    logger.fine(\"Calculating summary statistics on a Double vector;\");\n-                    calculateContinuousSummaryStatistics(dataFile, i, variableVector);\n-                    // calculate the UNF while we are at it:\n-                    logger.fine(\"Calculating UNF on a Double vector;\");\n-                    calculateUNF(dataFile, i, variableVector);\n-                    variableVector = null; \n-                }\n-                logger.fine(\"Done! (continuous);\");\n-            }\n+\n+    for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n+      if (dataFile.getDataTable().getDataVariables().get(i).isIntervalContinuous()) {\n+        logger.fine(\"subsetting continuous vector\");\n+\n+        if (\"float\".equals(dataFile.getDataTable().getDataVariables().get(i).getFormat())) {\n+          Float[] variableVector = TabularSubsetGenerator\n+            .subsetFloatVector(new FileInputStream(generatedTabularFile), i,\n+              dataFile.getDataTable().getCaseQuantity().intValue());\n+          logger.fine(\"Calculating summary statistics on a Float vector;\");\n+          calculateContinuousSummaryStatistics(dataFile, i, variableVector);\n+          // calculate the UNF while we are at it:\n+          logger.fine(\"Calculating UNF on a Float vector;\");\n+          calculateUNF(dataFile, i, variableVector);\n+          variableVector = null;\n+        } else {\n+          Double[] variableVector = TabularSubsetGenerator\n+            .subsetDoubleVector(new FileInputStream(generatedTabularFile), i,\n+              dataFile.getDataTable().getCaseQuantity().intValue());\n+          logger.fine(\"Calculating summary statistics on a Double vector;\");\n+          calculateContinuousSummaryStatistics(dataFile, i, variableVector);\n+          // calculate the UNF while we are at it:\n+          logger.fine(\"Calculating UNF on a Double vector;\");\n+          calculateUNF(dataFile, i, variableVector);\n+          variableVector = null;\n         }\n+        logger.fine(\"Done! (continuous);\");\n+      }\n     }\n-    \n-    public void produceDiscreteNumericSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n-        \n-        //TabularSubsetGenerator subsetGenerator = new TabularSubsetGenerator();\n-        \n-        for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n-            if (dataFile.getDataTable().getDataVariables().get(i).isIntervalDiscrete()\n-                    && dataFile.getDataTable().getDataVariables().get(i).isTypeNumeric()) {\n-                logger.fine(\"subsetting discrete-numeric vector\");\n-\n-                Long[] variableVector = TabularSubsetGenerator.subsetLongVector(new FileInputStream(generatedTabularFile), i, dataFile.getDataTable().getCaseQuantity().intValue());\n-                // We are discussing calculating the same summary stats for \n-                // all numerics (the same kind of sumstats that we've been calculating\n-                // for numeric continuous type)  -- L.A. Jul. 2014\n-                calculateContinuousSummaryStatistics(dataFile, i, variableVector);\n-                // calculate the UNF while we are at it:\n-                logger.fine(\"Calculating UNF on a Long vector\");\n-                calculateUNF(dataFile, i, variableVector);\n-                logger.fine(\"Done! (discrete numeric)\");\n-                variableVector = null; \n-            }\n-        }\n+  }\n+\n+  public void produceDiscreteNumericSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n+\n+    //TabularSubsetGenerator subsetGenerator = new TabularSubsetGenerator();\n+\n+    for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n+      if (dataFile.getDataTable().getDataVariables().get(i).isIntervalDiscrete()\n+        && dataFile.getDataTable().getDataVariables().get(i).isTypeNumeric()) {\n+        logger.fine(\"subsetting discrete-numeric vector\");\n+\n+        Long[] variableVector = TabularSubsetGenerator.subsetLongVector(new FileInputStream(generatedTabularFile), i,\n+          dataFile.getDataTable().getCaseQuantity().intValue());\n+        // We are discussing calculating the same summary stats for\n+        // all numerics (the same kind of sumstats that we've been calculating\n+        // for numeric continuous type)  -- L.A. Jul. 2014\n+        calculateContinuousSummaryStatistics(dataFile, i, variableVector);\n+        // calculate the UNF while we are at it:\n+        logger.fine(\"Calculating UNF on a Long vector\");\n+        calculateUNF(dataFile, i, variableVector);\n+        logger.fine(\"Done! (discrete numeric)\");\n+        variableVector = null;\n+      }\n     }\n-    \n-    public void produceCharacterSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n+  }\n+\n+  public void produceCharacterSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n \n         /* \n             At this point it's still not clear what kinds of summary stats we\n@@ -656,311 +667,318 @@ public class IngestServiceBean {\n         \n         TabularSubsetGenerator subsetGenerator = new TabularSubsetGenerator();\n         */\n-        \n-        for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n-            if (dataFile.getDataTable().getDataVariables().get(i).isTypeCharacter()) {\n-\n-                logger.fine(\"subsetting character vector\");\n-                String[] variableVector = TabularSubsetGenerator.subsetStringVector(new FileInputStream(generatedTabularFile), i, dataFile.getDataTable().getCaseQuantity().intValue());\n-                //calculateCharacterSummaryStatistics(dataFile, i, variableVector);\n-                // calculate the UNF while we are at it:\n-                logger.fine(\"Calculating UNF on a String vector\");\n-                calculateUNF(dataFile, i, variableVector);\n-                logger.fine(\"Done! (character)\");\n-                variableVector = null; \n-            }\n-        }\n+\n+    for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n+      if (dataFile.getDataTable().getDataVariables().get(i).isTypeCharacter()) {\n+\n+        logger.fine(\"subsetting character vector\");\n+        String[] variableVector = TabularSubsetGenerator\n+          .subsetStringVector(new FileInputStream(generatedTabularFile), i,\n+            dataFile.getDataTable().getCaseQuantity().intValue());\n+        //calculateCharacterSummaryStatistics(dataFile, i, variableVector);\n+        // calculate the UNF while we are at it:\n+        logger.fine(\"Calculating UNF on a String vector\");\n+        calculateUNF(dataFile, i, variableVector);\n+        logger.fine(\"Done! (character)\");\n+        variableVector = null;\n+      }\n     }\n+  }\n \n-    public static void produceFrequencyStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n+  public static void produceFrequencyStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n \n-        List<DataVariable> vars = dataFile.getDataTable().getDataVariables();\n+    List<DataVariable> vars = dataFile.getDataTable().getDataVariables();\n \n-        produceFrequencies(generatedTabularFile, vars);\n-    }\n+    produceFrequencies(generatedTabularFile, vars);\n+  }\n \n-    public static void produceFrequencies( File generatedTabularFile, List<DataVariable> vars) throws IOException {\n+  public static void produceFrequencies(File generatedTabularFile, List<DataVariable> vars) throws IOException {\n \n-        for (int i = 0; i < vars.size(); i++) {\n+    for (int i = 0; i < vars.size(); i++) {\n \n-            Collection<VariableCategory> cats = vars.get(i).getCategories();\n-            int caseQuantity = vars.get(i).getDataTable().getCaseQuantity().intValue();\n-            boolean isNumeric = vars.get(i).isTypeNumeric();\n-            Object[] variableVector = null;\n-            if (cats.size() > 0) {\n-                if (isNumeric) {\n-                    variableVector = TabularSubsetGenerator.subsetFloatVector(new FileInputStream(generatedTabularFile), i, caseQuantity);\n-                }\n-                else {\n-                    variableVector = TabularSubsetGenerator.subsetStringVector(new FileInputStream(generatedTabularFile), i, caseQuantity);\n-                }\n-                if (variableVector != null) {\n-                    Hashtable<Object, Double> freq = calculateFrequency(variableVector);\n-                    for (VariableCategory cat : cats) {\n-                        Object catValue;\n-                        if (isNumeric) {\n-                            catValue = new Float(cat.getValue());\n-                        } else {\n-                            catValue = cat.getValue();\n-                        }\n-                        Double numberFreq = freq.get(catValue);\n-                        if (numberFreq != null) {\n-                            cat.setFrequency(numberFreq);\n-                        } else {\n-                            cat.setFrequency(0D);\n-                        }\n-                    }\n-                } else {\n-                    logger.fine(\"variableVector is null for variable \" + vars.get(i).getName());\n-                }\n+      Collection<VariableCategory> cats = vars.get(i).getCategories();\n+      int caseQuantity = vars.get(i).getDataTable().getCaseQuantity().intValue();\n+      boolean isNumeric = vars.get(i).isTypeNumeric();\n+      Object[] variableVector = null;\n+      if (cats.size() > 0) {\n+        if (isNumeric) {\n+          variableVector =\n+            TabularSubsetGenerator.subsetFloatVector(new FileInputStream(generatedTabularFile), i, caseQuantity);\n+        } else {\n+          variableVector =\n+            TabularSubsetGenerator.subsetStringVector(new FileInputStream(generatedTabularFile), i, caseQuantity);\n+        }\n+        if (variableVector != null) {\n+          Hashtable<Object, Double> freq = calculateFrequency(variableVector);\n+          for (VariableCategory cat : cats) {\n+            Object catValue;\n+            if (isNumeric) {\n+              catValue = new Float(cat.getValue());\n+            } else {\n+              catValue = cat.getValue();\n+            }\n+            Double numberFreq = freq.get(catValue);\n+            if (numberFreq != null) {\n+              cat.setFrequency(numberFreq);\n+            } else {\n+              cat.setFrequency(0D);\n             }\n+          }\n+        } else {\n+          logger.fine(\"variableVector is null for variable \" + vars.get(i).getName());\n         }\n+      }\n     }\n+  }\n \n-    public static Hashtable<Object, Double> calculateFrequency( Object[] variableVector) {\n-        Hashtable<Object, Double> freq = new Hashtable<Object, Double>();\n+  public static Hashtable<Object, Double> calculateFrequency(Object[] variableVector) {\n+    Hashtable<Object, Double> freq = new Hashtable<Object, Double>();\n \n-        for (int j = 0; j < variableVector.length; j++) {\n-            if (variableVector[j] != null) {\n-                Double freqNum = freq.get(variableVector[j]);\n-                if (freqNum != null) {\n-                    freq.put(variableVector[j], freqNum + 1);\n-                } else {\n-                    freq.put(variableVector[j], 1D);\n-                }\n-            }\n+    for (int j = 0; j < variableVector.length; j++) {\n+      if (variableVector[j] != null) {\n+        Double freqNum = freq.get(variableVector[j]);\n+        if (freqNum != null) {\n+          freq.put(variableVector[j], freqNum + 1);\n+        } else {\n+          freq.put(variableVector[j], 1D);\n         }\n+      }\n+    }\n+\n+    return freq;\n+\n+  }\n \n-        return freq;\n+  public void recalculateDataFileUNF(DataFile dataFile) {\n+    String[] unfValues = new String[dataFile.getDataTable().getVarQuantity().intValue()];\n+    String fileUnfValue = null;\n \n+    for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n+      String varunf = dataFile.getDataTable().getDataVariables().get(i).getUnf();\n+      unfValues[i] = varunf;\n     }\n-    \n-    public void recalculateDataFileUNF(DataFile dataFile) {\n-        String[] unfValues = new String[dataFile.getDataTable().getVarQuantity().intValue()];\n-        String fileUnfValue = null; \n-        \n-        for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n-            String varunf = dataFile.getDataTable().getDataVariables().get(i).getUnf();\n-            unfValues[i] = varunf; \n-        }\n-        \n-        try {\n-            fileUnfValue = UNFUtil.calculateUNF(unfValues);\n-        } catch (IOException ex) {\n-            logger.warning(\"Failed to recalculate the UNF for the datafile id=\"+dataFile.getId());\n-        } catch (UnfException uex) {\n-                logger.warning(\"UNF Exception: Failed to recalculate the UNF for the dataset version id=\"+dataFile.getId());\n-        }\n-        \n-        if (fileUnfValue != null) {\n-            dataFile.getDataTable().setUnf(fileUnfValue);\n-        }\n+\n+    try {\n+      fileUnfValue = UNFUtil.calculateUNF(unfValues);\n+    } catch (IOException ex) {\n+      logger.warning(\"Failed to recalculate the UNF for the datafile id=\" + dataFile.getId());\n+    } catch (UnfException uex) {\n+      logger.warning(\"UNF Exception: Failed to recalculate the UNF for the dataset version id=\" + dataFile.getId());\n     }\n \n-    public void recalculateDatasetVersionUNF(DatasetVersion version) {\n-        IngestUtil.recalculateDatasetVersionUNF(version);\n+    if (fileUnfValue != null) {\n+      dataFile.getDataTable().setUnf(fileUnfValue);\n     }\n+  }\n+\n+  public void recalculateDatasetVersionUNF(DatasetVersion version) {\n+    IngestUtil.recalculateDatasetVersionUNF(version);\n+  }\n \n-    public void sendFailNotification(Long dataset_id) {\n-        FacesMessage facesMessage = new FacesMessage(BundleUtil.getStringFromBundle(\"ingest.failed\"));\n+  public void sendFailNotification(Long dataset_id) {\n+    FacesMessage facesMessage = new FacesMessage(BundleUtil.getStringFromBundle(\"ingest.failed\"));\n         /* commented out push channel message:\n             PushContext pushContext = PushContextFactory.getDefault().getPushContext();\n             pushContext.push(\"/ingest\" + dataset_id, facesMessage);\n         */\n+  }\n+\n+\n+  public boolean ingestAsTabular(Long datafile_id) {\n+    DataFile dataFile = fileService.find(datafile_id);\n+    boolean ingestSuccessful = false;\n+    boolean forceTypeCheck = false;\n+\n+    // Never attempt to ingest a file that's already ingested!\n+    if (dataFile.isTabularData()) {\n+      FileUtil.createIngestFailureReport(dataFile,\n+        \"Repeated ingest attempted on a tabular data file! (status flag was: \" + dataFile.getIngestStatus());\n+      dataFile.setIngestDone();\n+      dataFile = fileService.save(dataFile);\n+      logger.warning(\"Repeated ingest attempted on a tabular data file (datafile id \" + datafile_id + \"); exiting.\");\n+      return false;\n     }\n-    \n-    \n-    public boolean ingestAsTabular(Long datafile_id) {\n-        DataFile dataFile = fileService.find(datafile_id);\n-        boolean ingestSuccessful = false;\n-        boolean forceTypeCheck = false;\n-        \n-        // Never attempt to ingest a file that's already ingested!\n-        if (dataFile.isTabularData()) {\n-            FileUtil.createIngestFailureReport(dataFile, \"Repeated ingest attempted on a tabular data file! (status flag was: \"+dataFile.getIngestStatus());\n-            dataFile.setIngestDone();\n-            dataFile = fileService.save(dataFile);\n-            logger.warning(\"Repeated ingest attempted on a tabular data file (datafile id \"+datafile_id+\"); exiting.\");\n-            return false;\n-        }\n-        \n-        IngestRequest ingestRequest = dataFile.getIngestRequest();\n-        if (ingestRequest != null) {\n-            forceTypeCheck = ingestRequest.isForceTypeCheck();\n-        }\n \n-        // Locate ingest plugin for the file format by looking\n-        // it up with the Ingest Service Provider Registry:\n-        String fileName = dataFile.getFileMetadata().getLabel();\n-        TabularDataFileReader ingestPlugin = getTabDataReaderByMimeType(dataFile.getContentType());\n-        logger.fine(\"Found ingest plugin \" + ingestPlugin.getClass());\n-        \n-        if (!forceTypeCheck && ingestPlugin == null) {\n-            // If this is a reingest request, we'll still have a chance\n-            // to find an ingest plugin for this file, once we try\n-            // to identify the file type again.\n-            // Otherwise, we can give up - there is no point in proceeding to \n-            // the next step if no ingest plugin is available. \n-            \n-            dataFile.SetIngestProblem();\n-            FileUtil.createIngestFailureReport(dataFile, \"No ingest plugin found for file type \"+dataFile.getContentType());\n-            dataFile = fileService.save(dataFile);\n-            logger.warning(\"Ingest failure.\");\n-            return false; \n-        }\n+    IngestRequest ingestRequest = dataFile.getIngestRequest();\n+    if (ingestRequest != null) {\n+      forceTypeCheck = ingestRequest.isForceTypeCheck();\n+    }\n \n-        BufferedInputStream inputStream = null; \n-        File additionalData = null;\n-        File localFile = null;\n-        StorageIO<DataFile> storageIO = null;\n-                \n-        try {\n-            storageIO = dataFile.getStorageIO();\n-            storageIO.open();\n-             \n-            if (storageIO.isLocalFile()) {\n-                localFile = storageIO.getFileSystemPath().toFile();\n-                inputStream = new BufferedInputStream(storageIO.getInputStream());\n-            } else {\n-                \n-                localFile = File.createTempFile(\"tempIngestSourceFile\", \".tmp\");\n-\t\t\t\ttry (ReadableByteChannel dataFileChannel = storageIO.getReadChannel();\n-\t\t\t\t\t\tFileChannel tempIngestSourceChannel = new FileOutputStream(localFile).getChannel();) {\n-\n-\t\t\t\t\ttempIngestSourceChannel.transferFrom(dataFileChannel, 0, storageIO.getSize());\n-\t\t\t\t}\n-                inputStream = new BufferedInputStream(new FileInputStream(localFile));\n-                logger.fine(\"Saved \"+storageIO.getSize()+\" bytes in a local temp file.\");\n-            }\n-        } catch (IOException ioEx) {\n-            dataFile.SetIngestProblem();\n-            \n-            FileUtil.createIngestFailureReport(dataFile, \"IO Exception occured while trying to open the file for reading.\");\n-            dataFile = fileService.save(dataFile);\n-            \n-            logger.warning(\"Ingest failure (No file produced).\");\n-            return false; \n-        }\n-        \n-        if (ingestRequest != null) {\n-            if (ingestRequest.getTextEncoding() != null \n-                    && !ingestRequest.getTextEncoding().equals(\"\") ) {\n-                logger.fine(\"Setting language encoding to \"+ingestRequest.getTextEncoding());\n-                ingestPlugin.setDataLanguageEncoding(ingestRequest.getTextEncoding());\n-            }\n-            if (ingestRequest.getLabelsFile() != null) {\n-                additionalData = new File(ingestRequest.getLabelsFile());\n-            }\n-        }\n-        \n-        if (forceTypeCheck) {\n-            String newType = FileUtil.retestIngestableFileType(localFile, dataFile.getContentType());\n-            \n-            ingestPlugin = getTabDataReaderByMimeType(newType);\n-            logger.fine(\"Re-tested file type: \" + newType + \"; Using ingest plugin \" + ingestPlugin.getClass());\n-\n-            // check again:\n-            if (ingestPlugin == null) {\n-                // If it's still null - give up!\n-            \n-                dataFile.SetIngestProblem();\n-                FileUtil.createIngestFailureReport(dataFile, \"No ingest plugin found for file type \"+dataFile.getContentType());\n-                dataFile = fileService.save(dataFile);\n-                logger.warning(\"Ingest failure: failed to detect ingest plugin (file type check forced)\");\n-                return false; \n-            }\n-            \n-            dataFile.setContentType(newType);\n+    // Locate ingest plugin for the file format by looking\n+    // it up with the Ingest Service Provider Registry:\n+    String fileName = dataFile.getFileMetadata().getLabel();\n+    TabularDataFileReader ingestPlugin = getTabDataReaderByMimeType(dataFile.getContentType());\n+    logger.fine(\"Found ingest plugin \" + ingestPlugin.getClass());\n+\n+    if (!forceTypeCheck && ingestPlugin == null) {\n+      // If this is a reingest request, we'll still have a chance\n+      // to find an ingest plugin for this file, once we try\n+      // to identify the file type again.\n+      // Otherwise, we can give up - there is no point in proceeding to\n+      // the next step if no ingest plugin is available.\n+\n+      dataFile.SetIngestProblem();\n+      FileUtil.createIngestFailureReport(dataFile, \"No ingest plugin found for file type \" + dataFile.getContentType());\n+      dataFile = fileService.save(dataFile);\n+      logger.warning(\"Ingest failure.\");\n+      return false;\n+    }\n+\n+    BufferedInputStream inputStream = null;\n+    File additionalData = null;\n+    File localFile = null;\n+    StorageIO<DataFile> storageIO = null;\n+\n+    try {\n+      storageIO = dataFile.getStorageIO();\n+      storageIO.open();\n+\n+      if (storageIO.isLocalFile()) {\n+        localFile = storageIO.getFileSystemPath().toFile();\n+        inputStream = new BufferedInputStream(storageIO.getInputStream());\n+      } else {\n+\n+        localFile = File.createTempFile(\"tempIngestSourceFile\", \".tmp\");\n+        try (ReadableByteChannel dataFileChannel = storageIO.getReadChannel();\n+             FileChannel tempIngestSourceChannel = new FileOutputStream(localFile).getChannel();) {\n+\n+          tempIngestSourceChannel.transferFrom(dataFileChannel, 0, storageIO.getSize());\n         }\n-        \n-        TabularDataIngest tabDataIngest = null; \n-        try {\n-            if (additionalData != null) {\n-                tabDataIngest = ingestPlugin.read(inputStream, additionalData);\n-            } else {\n-                tabDataIngest = ingestPlugin.read(inputStream, null);\n-            }\n-        } catch (IOException ingestEx) {\n-            dataFile.SetIngestProblem();\n-            FileUtil.createIngestFailureReport(dataFile, ingestEx.getMessage());\n-            dataFile = fileService.save(dataFile);\n-            \n-            logger.warning(\"Ingest failure (IO Exception): \" + ingestEx.getMessage() + \".\");\n-            return false;\n-        } catch (Exception unknownEx) {\n-            dataFile.SetIngestProblem();\n-            FileUtil.createIngestFailureReport(dataFile, unknownEx.getMessage());\n-            dataFile = fileService.save(dataFile);\n-            \n-            logger.warning(\"Ingest failure (Exception \" + unknownEx.getClass() + \"): \"+unknownEx.getMessage()+\".\");\n-            return false;\n-            \n-        } finally {\n-        \tIOUtils.closeQuietly(inputStream);\n+        inputStream = new BufferedInputStream(new FileInputStream(localFile));\n+        logger.fine(\"Saved \" + storageIO.getSize() + \" bytes in a local temp file.\");\n+      }\n+    } catch (IOException ioEx) {\n+      dataFile.SetIngestProblem();\n+\n+      FileUtil.createIngestFailureReport(dataFile, \"IO Exception occured while trying to open the file for reading.\");\n+      dataFile = fileService.save(dataFile);\n+\n+      logger.warning(\"Ingest failure (No file produced).\");\n+      return false;\n+    }\n+\n+    if (ingestRequest != null) {\n+      if (ingestRequest.getTextEncoding() != null\n+        && !ingestRequest.getTextEncoding().equals(\"\")) {\n+        logger.fine(\"Setting language encoding to \" + ingestRequest.getTextEncoding());\n+        ingestPlugin.setDataLanguageEncoding(ingestRequest.getTextEncoding());\n+      }\n+      if (ingestRequest.getLabelsFile() != null) {\n+        additionalData = new File(ingestRequest.getLabelsFile());\n+      }\n+    }\n+\n+    if (forceTypeCheck) {\n+      String newType = FileUtil.retestIngestableFileType(localFile, dataFile.getContentType());\n+\n+      ingestPlugin = getTabDataReaderByMimeType(newType);\n+      logger.fine(\"Re-tested file type: \" + newType + \"; Using ingest plugin \" + ingestPlugin.getClass());\n+\n+      // check again:\n+      if (ingestPlugin == null) {\n+        // If it's still null - give up!\n+\n+        dataFile.SetIngestProblem();\n+        FileUtil\n+          .createIngestFailureReport(dataFile, \"No ingest plugin found for file type \" + dataFile.getContentType());\n+        dataFile = fileService.save(dataFile);\n+        logger.warning(\"Ingest failure: failed to detect ingest plugin (file type check forced)\");\n+        return false;\n+      }\n+\n+      dataFile.setContentType(newType);\n+    }\n+\n+    TabularDataIngest tabDataIngest = null;\n+    try {\n+      if (additionalData != null) {\n+        tabDataIngest = ingestPlugin.read(inputStream, additionalData);\n+      } else {\n+        tabDataIngest = ingestPlugin.read(inputStream, null);\n+      }\n+    } catch (IOException ingestEx) {\n+      dataFile.SetIngestProblem();\n+      FileUtil.createIngestFailureReport(dataFile, ingestEx.getMessage());\n+      dataFile = fileService.save(dataFile);\n+\n+      logger.warning(\"Ingest failure (IO Exception): \" + ingestEx.getMessage() + \".\");\n+      return false;\n+    } catch (Exception unknownEx) {\n+      dataFile.SetIngestProblem();\n+      FileUtil.createIngestFailureReport(dataFile, unknownEx.getMessage());\n+      dataFile = fileService.save(dataFile);\n+\n+      logger.warning(\"Ingest failure (Exception \" + unknownEx.getClass() + \"): \" + unknownEx.getMessage() + \".\");\n+      return false;\n+\n+    } finally {\n+      IOUtils.closeQuietly(inputStream);\n+    }\n+\n+    String originalContentType = dataFile.getContentType();\n+    String originalFileName = dataFile.getFileMetadata().getLabel();\n+    long originalFileSize = dataFile.getFilesize();\n+    boolean postIngestTasksSuccessful = false;\n+    boolean databaseSaveSuccessful = false;\n+\n+    if (tabDataIngest != null) {\n+      File tabFile = tabDataIngest.getTabDelimitedFile();\n+\n+      if (tabDataIngest.getDataTable() != null\n+        && tabFile != null\n+        && tabFile.exists()) {\n+        logger.info(\"Tabular data successfully ingested; DataTable with \"\n+          + tabDataIngest.getDataTable().getVarQuantity() + \" variables produced.\");\n+        logger.info(\"Tab-delimited file produced: \" + tabFile.getAbsolutePath());\n+\n+        dataFile.setFilesize(tabFile.length());\n+\n+        // and change the mime type to \"Tabular Data\" on the final datafile,\n+        // and replace (or add) the extension \".tab\" to the filename:\n+        dataFile.setContentType(FileUtil.MIME_TYPE_INGESTED_FILE);\n+        IngestUtil.modifyExistingFilename(dataFile.getOwner().getLatestVersion(), dataFile.getFileMetadata(),\n+          FileUtil.replaceExtension(fileName, \"tab\"));\n+\n+        if (FileUtil.MIME_TYPE_CSV_ALT.equals(dataFile.getContentType())) {\n+          tabDataIngest.getDataTable().setOriginalFileFormat(FileUtil.MIME_TYPE_CSV);\n+        } else {\n+          tabDataIngest.getDataTable().setOriginalFileFormat(originalContentType);\n         }\n+        tabDataIngest.getDataTable().setOriginalFileSize(originalFileSize);\n \n-        String originalContentType = dataFile.getContentType();\n-        String originalFileName = dataFile.getFileMetadata().getLabel();\n-        long originalFileSize = dataFile.getFilesize();\n-        boolean postIngestTasksSuccessful = false;\n-        boolean databaseSaveSuccessful = false;\n-\n-        if (tabDataIngest != null) {\n-            File tabFile = tabDataIngest.getTabDelimitedFile();\n-\n-            if (tabDataIngest.getDataTable() != null\n-                    && tabFile != null\n-                    && tabFile.exists()) {\n-                logger.info(\"Tabular data successfully ingested; DataTable with \"\n-                        + tabDataIngest.getDataTable().getVarQuantity() + \" variables produced.\");\n-                logger.info(\"Tab-delimited file produced: \" + tabFile.getAbsolutePath());\n-\n-                dataFile.setFilesize(tabFile.length());\n-\n-                // and change the mime type to \"Tabular Data\" on the final datafile, \n-                // and replace (or add) the extension \".tab\" to the filename: \n-                dataFile.setContentType(FileUtil.MIME_TYPE_INGESTED_FILE);\n-                IngestUtil.modifyExistingFilename(dataFile.getOwner().getLatestVersion(), dataFile.getFileMetadata(), FileUtil.replaceExtension(fileName, \"tab\"));\n-\n-                if (FileUtil.MIME_TYPE_CSV_ALT.equals(dataFile.getContentType())) {\n-                    tabDataIngest.getDataTable().setOriginalFileFormat(FileUtil.MIME_TYPE_CSV);\n-                } else {\n-                    tabDataIngest.getDataTable().setOriginalFileFormat(originalContentType);\n-                }\n-                tabDataIngest.getDataTable().setOriginalFileSize(originalFileSize);\n+        dataFile.setDataTable(tabDataIngest.getDataTable());\n+        tabDataIngest.getDataTable().setDataFile(dataFile);\n+        tabDataIngest.getDataTable().setOriginalFileName(originalFileName);\n \n-                dataFile.setDataTable(tabDataIngest.getDataTable());\n-                tabDataIngest.getDataTable().setDataFile(dataFile);\n-                tabDataIngest.getDataTable().setOriginalFileName(originalFileName);\n-                \n-                try {\n-                    produceSummaryStatistics(dataFile, tabFile);\n-                    produceFrequencyStatistics(dataFile, tabFile);\n-                    postIngestTasksSuccessful = true;\n-                } catch (IOException postIngestEx) {\n+        try {\n+          produceSummaryStatistics(dataFile, tabFile);\n+          produceFrequencyStatistics(dataFile, tabFile);\n+          postIngestTasksSuccessful = true;\n+        } catch (IOException postIngestEx) {\n \n-                    dataFile.SetIngestProblem();\n-                    FileUtil.createIngestFailureReport(dataFile, \"Ingest failed to produce Summary Statistics and/or UNF signatures; \" + postIngestEx.getMessage());\n+          dataFile.SetIngestProblem();\n+          FileUtil.createIngestFailureReport(dataFile,\n+            \"Ingest failed to produce Summary Statistics and/or UNF signatures; \" + postIngestEx.getMessage());\n \n-                    restoreIngestedDataFile(dataFile, tabDataIngest, originalFileSize, originalFileName, originalContentType);\n-                    dataFile = fileService.save(dataFile);\n+          restoreIngestedDataFile(dataFile, tabDataIngest, originalFileSize, originalFileName, originalContentType);\n+          dataFile = fileService.save(dataFile);\n \n-                    logger.warning(\"Ingest failure: post-ingest tasks.\");\n-                }\n+          logger.warning(\"Ingest failure: post-ingest tasks.\");\n+        }\n \n-                if (!postIngestTasksSuccessful) {\n-                    logger.warning(\"Ingest failure (!postIngestTasksSuccessful).\");\n-                    return false;\n-                }\n+        if (!postIngestTasksSuccessful) {\n+          logger.warning(\"Ingest failure (!postIngestTasksSuccessful).\");\n+          return false;\n+        }\n \n-                dataFile.setIngestDone();\n-                // delete the ingest request, if exists:\n-                if (dataFile.getIngestRequest() != null) {\n-                    dataFile.getIngestRequest().setDataFile(null);\n-                    dataFile.setIngestRequest(null);\n-                }\n+        dataFile.setIngestDone();\n+        // delete the ingest request, if exists:\n+        if (dataFile.getIngestRequest() != null) {\n+          dataFile.getIngestRequest().setDataFile(null);\n+          dataFile.setIngestRequest(null);\n+        }\n \n-                try {\n+        try {\n                     /* \n                          In order to test a database save failure, uncomment this:\n                         \n@@ -968,121 +986,128 @@ public class IngestServiceBean {\n                             throw new EJBException(\"Deliberate database save failure\");\n                         }\n                      */\n-                    dataFile = fileService.saveInTransaction(dataFile);\n-                    databaseSaveSuccessful = true;\n+          dataFile = fileService.saveInTransaction(dataFile);\n+          databaseSaveSuccessful = true;\n \n-                    logger.fine(\"Ingest (\" + dataFile.getFileMetadata().getLabel() + \".\");\n+          logger.fine(\"Ingest (\" + dataFile.getFileMetadata().getLabel() + \".\");\n \n-                    if (additionalData != null) {\n-                        // remove the extra tempfile, if there was one:\n-                        additionalData.delete();\n-                    }\n-                } catch (Exception unknownEx) {\n-                    // this means that an error occurred while saving the datafile\n-                    // in the database. \n-                    logger.warning(\"Ingest failure: Failed to save tabular metadata (datatable, datavariables, etc.) in the database. Clearing the datafile object.\");\n+          if (additionalData != null) {\n+            // remove the extra tempfile, if there was one:\n+            additionalData.delete();\n+          }\n+        } catch (Exception unknownEx) {\n+          // this means that an error occurred while saving the datafile\n+          // in the database.\n+          logger.warning(\n+            \"Ingest failure: Failed to save tabular metadata (datatable, datavariables, etc.) in the database. Clearing the datafile object.\");\n \n-                    dataFile = fileService.find(datafile_id);\n+          dataFile = fileService.find(datafile_id);\n \n-                    if (dataFile != null) {\n-                        dataFile.SetIngestProblem();\n-                        FileUtil.createIngestFailureReport(dataFile, \"Ingest produced tabular data, but failed to save it in the database; \" + unknownEx.getMessage() + \" No further information is available.\");\n+          if (dataFile != null) {\n+            dataFile.SetIngestProblem();\n+            FileUtil.createIngestFailureReport(dataFile,\n+              \"Ingest produced tabular data, but failed to save it in the database; \" + unknownEx.getMessage() +\n+                \" No further information is available.\");\n \n-                        restoreIngestedDataFile(dataFile, tabDataIngest, originalFileSize, originalFileName, originalContentType);\n+            restoreIngestedDataFile(dataFile, tabDataIngest, originalFileSize, originalFileName, originalContentType);\n \n-                        dataFile = fileService.save(dataFile);\n-                    }\n-                }\n+            dataFile = fileService.save(dataFile);\n+          }\n+        }\n \n-                if (!databaseSaveSuccessful) {\n-                    logger.warning(\"Ingest failure (failed to save the tabular data in the database; file left intact as uploaded).\");\n-                    return false;\n-                }\n+        if (!databaseSaveSuccessful) {\n+          logger\n+            .warning(\"Ingest failure (failed to save the tabular data in the database; file left intact as uploaded).\");\n+          return false;\n+        }\n \n-                // Finally, let's swap the original and the tabular files: \n-                try {\n-                    /* Start of save as backup */\n+        // Finally, let's swap the original and the tabular files:\n+        try {\n+          /* Start of save as backup */\n \n-                    StorageIO<DataFile> dataAccess = dataFile.getStorageIO();\n-                    dataAccess.open();\n+          StorageIO<DataFile> dataAccess = dataFile.getStorageIO();\n+          dataAccess.open();\n \n-                    // and we want to save the original of the ingested file: \n-                    try {\n-                        dataAccess.backupAsAux(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-                        logger.fine(\"Saved the ingested original as a backup aux file \"+FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-                    } catch (IOException iox) {\n-                        logger.warning(\"Failed to save the ingested original! \" + iox.getMessage());\n-                    }\n+          // and we want to save the original of the ingested file:\n+          try {\n+            dataAccess.backupAsAux(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+            logger\n+              .fine(\"Saved the ingested original as a backup aux file \" + FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+          } catch (IOException iox) {\n+            logger.warning(\"Failed to save the ingested original! \" + iox.getMessage());\n+          }\n \n-                    // Replace contents of the file with the tab-delimited data produced:\n-                    dataAccess.savePath(Paths.get(tabFile.getAbsolutePath()));\n-                    // Reset the file size: \n-                    dataFile.setFilesize(dataAccess.getSize());\n-                    \n-                    dataFile = fileService.save(dataFile);\n-                    logger.fine(\"saved data file after updating the size\");\n+          // Replace contents of the file with the tab-delimited data produced:\n+          dataAccess.savePath(Paths.get(tabFile.getAbsolutePath()));\n+          // Reset the file size:\n+          dataFile.setFilesize(dataAccess.getSize());\n \n-                    // delete the temp tab-file:\n-                    tabFile.delete();\n-                    /*end of save as backup */\n+          dataFile = fileService.save(dataFile);\n+          logger.fine(\"saved data file after updating the size\");\n \n-                } catch (Exception e) {\n-                    // this probably means that an error occurred while saving the file to the file system\n-                    logger.warning(\"Failed to save the tabular file produced by the ingest (resetting the ingested DataFile back to its original state)\");\n+          // delete the temp tab-file:\n+          tabFile.delete();\n+          /*end of save as backup */\n \n-                    dataFile = fileService.find(datafile_id);\n+        } catch (Exception e) {\n+          // this probably means that an error occurred while saving the file to the file system\n+          logger.warning(\n+            \"Failed to save the tabular file produced by the ingest (resetting the ingested DataFile back to its original state)\");\n \n-                    if (dataFile != null) {\n-                        dataFile.SetIngestProblem();\n-                        FileUtil.createIngestFailureReport(dataFile, \"Failed to save the tabular file produced by the ingest.\");\n+          dataFile = fileService.find(datafile_id);\n \n-                        restoreIngestedDataFile(dataFile, tabDataIngest, originalFileSize, originalFileName, originalContentType);\n+          if (dataFile != null) {\n+            dataFile.SetIngestProblem();\n+            FileUtil.createIngestFailureReport(dataFile, \"Failed to save the tabular file produced by the ingest.\");\n \n-                        dataFile = fileService.save(dataFile);\n-                    }\n-                }\n+            restoreIngestedDataFile(dataFile, tabDataIngest, originalFileSize, originalFileName, originalContentType);\n \n-                ingestSuccessful = true;\n-            }\n-        } else {\n-            logger.warning(\"Ingest failed to produce data obect.\");\n+            dataFile = fileService.save(dataFile);\n+          }\n         }\n \n-        return ingestSuccessful;\n+        ingestSuccessful = true;\n+      }\n+    } else {\n+      logger.warning(\"Ingest failed to produce data obect.\");\n     }\n \n-    private BufferedInputStream openFile(DataFile dataFile) throws IOException {\n-        BufferedInputStream inputStream;\n-        StorageIO<DataFile> storageIO = dataFile.getStorageIO();\n-        storageIO.open();\n-        if (storageIO.isLocalFile()) {\n-            inputStream = new BufferedInputStream(storageIO.getInputStream());\n-        } else {\n-        \tFile tempFile = File.createTempFile(\"tempIngestSourceFile\", \".tmp\");\n-\t\t\ttry (ReadableByteChannel dataFileChannel = storageIO.getReadChannel();\n-\t\t\t\t\tFileChannel tempIngestSourceChannel = new FileOutputStream(tempFile).getChannel();) {\n-\t\t\t\ttempIngestSourceChannel.transferFrom(dataFileChannel, 0, storageIO.getSize());\n-\t\t\t}\n-            inputStream = new BufferedInputStream(new FileInputStream(tempFile));\n-            logger.fine(\"Saved \"+storageIO.getSize()+\" bytes in a local temp file.\");\n-        }\n-        return inputStream;\n+    return ingestSuccessful;\n+  }\n+\n+  private BufferedInputStream openFile(DataFile dataFile) throws IOException {\n+    BufferedInputStream inputStream;\n+    StorageIO<DataFile> storageIO = dataFile.getStorageIO();\n+    storageIO.open();\n+    if (storageIO.isLocalFile()) {\n+      inputStream = new BufferedInputStream(storageIO.getInputStream());\n+    } else {\n+      File tempFile = File.createTempFile(\"tempIngestSourceFile\", \".tmp\");\n+      try (ReadableByteChannel dataFileChannel = storageIO.getReadChannel();\n+           FileChannel tempIngestSourceChannel = new FileOutputStream(tempFile).getChannel();) {\n+        tempIngestSourceChannel.transferFrom(dataFileChannel, 0, storageIO.getSize());\n+      }\n+      inputStream = new BufferedInputStream(new FileInputStream(tempFile));\n+      logger.fine(\"Saved \" + storageIO.getSize() + \" bytes in a local temp file.\");\n     }\n-\n-    private void restoreIngestedDataFile(DataFile dataFile, TabularDataIngest tabDataIngest, long originalSize, String originalFileName, String originalContentType) {\n-        dataFile.setDataTables(null);\n-        if (tabDataIngest != null && tabDataIngest.getDataTable() != null) {\n-            tabDataIngest.getDataTable().setDataFile(null);\n-        }\n-        dataFile.getFileMetadata().setLabel(originalFileName);\n-        dataFile.setContentType(originalContentType);\n-        dataFile.setFilesize(originalSize);\n+    return inputStream;\n+  }\n+\n+  private void restoreIngestedDataFile(DataFile dataFile, TabularDataIngest tabDataIngest, long originalSize,\n+                                       String originalFileName, String originalContentType) {\n+    dataFile.setDataTables(null);\n+    if (tabDataIngest != null && tabDataIngest.getDataTable() != null) {\n+      tabDataIngest.getDataTable().setDataFile(null);\n     }\n-    \n-    // TODO: Further move the code that doesn't really need to be in an EJB bean\n-    // (i.e., the code that doesn't need to persist anything in the database) into\n-    // outside static utilities and/or helpers; so that unit tests could be written\n-    // easily. -- L.A. 4.6\n+    dataFile.getFileMetadata().setLabel(originalFileName);\n+    dataFile.setContentType(originalContentType);\n+    dataFile.setFilesize(originalSize);\n+  }\n+\n+  // TODO: Further move the code that doesn't really need to be in an EJB bean\n+  // (i.e., the code that doesn't need to persist anything in the database) into\n+  // outside static utilities and/or helpers; so that unit tests could be written\n+  // easily. -- L.A. 4.6\n     \n     /* not needed anymore, but keeping it around, as a demo of how Push \n        notifications work\n@@ -1098,907 +1123,945 @@ public class IngestServiceBean {\n         // add more diagnostics here! 4.2.3 -- L.A. \n         eventBus.publish(\"/ingest/dataset/\" + datasetId, message);\n         */\n-   /* }*/\n-    \n-    public static TabularDataFileReader getTabDataReaderByMimeType(String mimeType) { //DataFile dataFile) {\n-        /* \n-         * Same as the comment above; since we don't have any ingest plugins loadable \n-         * in real times yet, we can select them by a fixed list of mime types. \n-         * -- L.A. 4.0 beta.\n-         */\n+  /* }*/\n \n-        //String mimeType = dataFile.getContentType();\n-        \n-        if (mimeType == null) {\n-            return null;\n-        }\n+  public static TabularDataFileReader getTabDataReaderByMimeType(String mimeType) { //DataFile dataFile) {\n+    /*\n+     * Same as the comment above; since we don't have any ingest plugins loadable\n+     * in real times yet, we can select them by a fixed list of mime types.\n+     * -- L.A. 4.0 beta.\n+     */\n \n-        TabularDataFileReader ingestPlugin = null;\n-\n-        if (mimeType.equals(FileUtil.MIME_TYPE_STATA)) {\n-            ingestPlugin = new DTAFileReader(new DTAFileReaderSpi());\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA13)) {\n-            ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 117);\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA14)) {\n-            ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 118);\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA15)) {\n-            ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 119);\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_RDATA)) {\n-            ingestPlugin = new RDATAFileReader(new RDATAFileReaderSpi());\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_CSV) || mimeType.equals(FileUtil.MIME_TYPE_CSV_ALT)) {\n-            ingestPlugin = new CSVFileReader(new CSVFileReaderSpi(), ',');\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_TSV) /*|| mimeType.equals(FileUtil.MIME_TYPE_TSV_ALT)*/) {\n-            ingestPlugin = new CSVFileReader(new CSVFileReaderSpi(), '\\t');\n-        }  else if (mimeType.equals(FileUtil.MIME_TYPE_XLSX)) {\n-            ingestPlugin = new XLSXFileReader(new XLSXFileReaderSpi());\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_SPSS_SAV)) {\n-            ingestPlugin = new SAVFileReader(new SAVFileReaderSpi());\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_SPSS_POR)) {\n-            ingestPlugin = new PORFileReader(new PORFileReaderSpi());\n-        }\n+    //String mimeType = dataFile.getContentType();\n \n-        return ingestPlugin;\n+    if (mimeType == null) {\n+      return null;\n     }\n-    \n-    public boolean fileMetadataExtractable(DataFile dataFile) {\n-        /* \n-         * Eventually we'll be consulting the Ingest Service Provider Registry\n-         * to see if there is a plugin for this type of file;\n-         * for now - just a hardcoded list of mime types:\n-         *  -- L.A. 4.0 beta\n-         */\n-        if (dataFile.getContentType() != null && dataFile.getContentType().equals(FileUtil.MIME_TYPE_FITS)) {\n-            return true;\n-        }\n-        return false;\n+\n+    TabularDataFileReader ingestPlugin = null;\n+\n+    if (mimeType.equals(FileUtil.MIME_TYPE_STATA)) {\n+      ingestPlugin = new DTAFileReader(new DTAFileReaderSpi());\n+    } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA13)) {\n+      ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 117);\n+    } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA14)) {\n+      ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 118);\n+    } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA15)) {\n+      ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 119);\n+    } else if (mimeType.equals(FileUtil.MIME_TYPE_RDATA)) {\n+      ingestPlugin = new RDATAFileReader(new RDATAFileReaderSpi());\n+    } else if (mimeType.equals(FileUtil.MIME_TYPE_CSV) || mimeType.equals(FileUtil.MIME_TYPE_CSV_ALT)) {\n+      ingestPlugin = new CSVFileReader(new CSVFileReaderSpi(), ',');\n+    } else if (mimeType.equals(FileUtil.MIME_TYPE_TSV) /*|| mimeType.equals(FileUtil.MIME_TYPE_TSV_ALT)*/) {\n+      ingestPlugin = new CSVFileReader(new CSVFileReaderSpi(), '\\t');\n+    } else if (mimeType.equals(FileUtil.MIME_TYPE_XLSX)) {\n+      ingestPlugin = new XLSXFileReader(new XLSXFileReaderSpi());\n+    } else if (mimeType.equals(FileUtil.MIME_TYPE_SPSS_SAV)) {\n+      ingestPlugin = new SAVFileReader(new SAVFileReaderSpi());\n+    } else if (mimeType.equals(FileUtil.MIME_TYPE_SPSS_POR)) {\n+      ingestPlugin = new PORFileReader(new PORFileReaderSpi());\n     }\n-    \n-    /* \n-     * extractMetadata: \n-     * framework for extracting metadata from uploaded files. The results will \n-     * be used to populate the metadata of the Dataset to which the file belongs. \n-    */\n-    public boolean extractMetadata(String tempFileLocation, DataFile dataFile, DatasetVersion editVersion) throws IOException {\n-        boolean ingestSuccessful = false;\n-\n-        InputStream tempFileInputStream = null; \n-        if(tempFileLocation == null) {\n-        \tStorageIO<DataFile> sio = dataFile.getStorageIO();\n-        \tsio.open(DataAccessOption.READ_ACCESS);\n-        \ttempFileInputStream = sio.getInputStream();\n-        } else {\n-        \ttry {\n-        \t\ttempFileInputStream = new FileInputStream(new File(tempFileLocation));\n-        \t} catch (FileNotFoundException notfoundEx) {\n-        \t\tthrow new IOException(\"Could not open temp file \"+tempFileLocation);\n-        \t}\n-        }\n-        \n-        // Locate metadata extraction plugin for the file format by looking\n-        // it up with the Ingest Service Provider Registry:\n-        //FileMetadataExtractor extractorPlugin = IngestSP.getMetadataExtractorByMIMEType(dfile.getContentType());\n-        FileMetadataExtractor extractorPlugin = new FITSFileMetadataExtractor();\n-\n-        FileMetadataIngest extractedMetadata = extractorPlugin.ingest(new BufferedInputStream(tempFileInputStream));\n-        Map<String, Set<String>> extractedMetadataMap = extractedMetadata.getMetadataMap();\n-\n-        // Store the fields and values we've gathered for safe-keeping:\n-        // from 3.6:\n-        // attempt to ingest the extracted metadata into the database; \n-        // TODO: this should throw an exception if anything goes wrong.\n-        FileMetadata fileMetadata = dataFile.getFileMetadata();\n-\n-        if (extractedMetadataMap != null) {\n-            logger.fine(\"Ingest Service: Processing extracted metadata;\");\n-            if (extractedMetadata.getMetadataBlockName() != null) {\n-                logger.fine(\"Ingest Service: This metadata belongs to the \"+extractedMetadata.getMetadataBlockName()+\" metadata block.\"); \n-                processDatasetMetadata(extractedMetadata, editVersion);\n-            }\n-            \n-            processFileLevelMetadata(extractedMetadata, fileMetadata);\n \n-        }\n+    return ingestPlugin;\n+  }\n \n-        ingestSuccessful = true;\n+  public boolean fileMetadataExtractable(DataFile dataFile) {\n+    /*\n+     * Eventually we'll be consulting the Ingest Service Provider Registry\n+     * to see if there is a plugin for this type of file;\n+     * for now - just a hardcoded list of mime types:\n+     *  -- L.A. 4.0 beta\n+     */\n+    if (dataFile.getContentType() != null && dataFile.getContentType().equals(FileUtil.MIME_TYPE_FITS)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /*\n+   * extractMetadata:\n+   * framework for extracting metadata from uploaded files. The results will\n+   * be used to populate the metadata of the Dataset to which the file belongs.\n+   */\n+  public boolean extractMetadata(String tempFileLocation, DataFile dataFile, DatasetVersion editVersion)\n+    throws IOException {\n+    boolean ingestSuccessful = false;\n+\n+    InputStream tempFileInputStream = null;\n+    if (tempFileLocation == null) {\n+      StorageIO<DataFile> sio = dataFile.getStorageIO();\n+      sio.open(DataAccessOption.READ_ACCESS);\n+      tempFileInputStream = sio.getInputStream();\n+    } else {\n+      try {\n+        tempFileInputStream = new FileInputStream(new File(tempFileLocation));\n+      } catch (FileNotFoundException notfoundEx) {\n+        throw new IOException(\"Could not open temp file \" + tempFileLocation);\n+      }\n+    }\n+\n+    // Locate metadata extraction plugin for the file format by looking\n+    // it up with the Ingest Service Provider Registry:\n+    //FileMetadataExtractor extractorPlugin = IngestSP.getMetadataExtractorByMIMEType(dfile.getContentType());\n+    FileMetadataExtractor extractorPlugin = new FITSFileMetadataExtractor();\n+\n+    FileMetadataIngest extractedMetadata = extractorPlugin.ingest(new BufferedInputStream(tempFileInputStream));\n+    Map<String, Set<String>> extractedMetadataMap = extractedMetadata.getMetadataMap();\n+\n+    // Store the fields and values we've gathered for safe-keeping:\n+    // from 3.6:\n+    // attempt to ingest the extracted metadata into the database;\n+    // TODO: this should throw an exception if anything goes wrong.\n+    FileMetadata fileMetadata = dataFile.getFileMetadata();\n+\n+    if (extractedMetadataMap != null) {\n+      logger.fine(\"Ingest Service: Processing extracted metadata;\");\n+      if (extractedMetadata.getMetadataBlockName() != null) {\n+        logger.fine(\"Ingest Service: This metadata belongs to the \" + extractedMetadata.getMetadataBlockName() +\n+          \" metadata block.\");\n+        processDatasetMetadata(extractedMetadata, editVersion);\n+      }\n+\n+      processFileLevelMetadata(extractedMetadata, fileMetadata);\n \n-        return ingestSuccessful;\n     }\n \n-    \n-    private void processDatasetMetadata(FileMetadataIngest fileMetadataIngest, DatasetVersion editVersion) throws IOException {\n-        \n-        \n-        for (MetadataBlock mdb : editVersion.getDataset().getOwner().getMetadataBlocks()) {  \n-            if (mdb.getName().equals(fileMetadataIngest.getMetadataBlockName())) {\n-                logger.fine(\"Ingest Service: dataset version has \"+mdb.getName()+\" metadata block enabled.\");\n-                \n-                editVersion.setDatasetFields(editVersion.initDatasetFields());\n-                \n-                Map<String, Set<String>> fileMetadataMap = fileMetadataIngest.getMetadataMap();\n-                for (DatasetFieldType dsft : mdb.getDatasetFieldTypes()) {\n-                    if (dsft.isPrimitive()) {\n-                        if (!dsft.isHasParent()) {\n-                            String dsfName = dsft.getName();\n-                            // See if the plugin has found anything for this field: \n-                            if (fileMetadataMap.get(dsfName) != null && !fileMetadataMap.get(dsfName).isEmpty()) {\n-\n-                                logger.fine(\"Ingest Service: found extracted metadata for field \" + dsfName);\n-                                // go through the existing fields:\n-                                for (DatasetField dsf : editVersion.getFlatDatasetFields()) {\n-                                    if (dsf.getDatasetFieldType().equals(dsft)) {\n-                                        // yep, this is our field!\n-                                        // let's go through the values that the ingest \n-                                        // plugin found in the file for this field: \n-\n-                                        Set<String> mValues = fileMetadataMap.get(dsfName);\n-\n-                                        // Special rules apply to aggregation of values for \n-                                        // some specific fields - namely, the resolution.* \n-                                        // fields from the Astronomy Metadata block. \n-                                        // TODO: rather than hard-coded, this needs to be\n-                                        // programmatically defined. -- L.A. 4.0\n-                                        if (dsfName.equals(\"resolution.Temporal\")\n-                                                || dsfName.equals(\"resolution.Spatial\")\n-                                                || dsfName.equals(\"resolution.Spectral\")) {\n-                                            // For these values, we aggregate the minimum-maximum \n-                                            // pair, for the entire set. \n-                                            // So first, we need to go through the values found by \n-                                            // the plugin and select the min. and max. values of \n-                                            // these: \n-                                            // (note that we are assuming that they all must\n-                                            // validate as doubles!)\n-\n-                                            Double minValue = null;\n-                                            Double maxValue = null;\n-\n-                                            for (String fValue : mValues) {\n-\n-                                                try {\n-                                                    double thisValue = Double.parseDouble(fValue);\n-\n-                                                    if (minValue == null || Double.compare(thisValue, minValue) < 0) {\n-                                                        minValue = thisValue;\n-                                                    }\n-                                                    if (maxValue == null || Double.compare(thisValue, maxValue) > 0) {\n-                                                        maxValue = thisValue;\n-                                                    }\n-                                                } catch (NumberFormatException e) {\n-                                                }\n-                                            }\n-\n-                                            // Now let's see what aggregated values we \n-                                            // have stored already: \n-                                            \n-                                            // (all of these resolution.* fields have allowedMultiple set to FALSE, \n-                                            // so there can be only one!)\n-                                            //logger.fine(\"Min value: \"+minValue+\", Max value: \"+maxValue);\n-                                            if (minValue != null && maxValue != null) {\n-                                                Double storedMinValue = null; \n-                                                Double storedMaxValue = null;\n-                                            \n-                                                String storedValue = \"\";\n-                                                \n-                                                if (dsf.getDatasetFieldValues() != null && dsf.getDatasetFieldValues().get(0) != null) {\n-                                                    storedValue = dsf.getDatasetFieldValues().get(0).getValue();\n-                                                \n-                                                    if (storedValue != null && !storedValue.equals(\"\")) {\n-                                                        try {\n-\n-                                                            if (storedValue.indexOf(\" - \") > -1) {\n-                                                                storedMinValue = Double.parseDouble(storedValue.substring(0, storedValue.indexOf(\" - \")));\n-                                                                storedMaxValue = Double.parseDouble(storedValue.substring(storedValue.indexOf(\" - \") + 3));\n-                                                            } else {\n-                                                                storedMinValue = Double.parseDouble(storedValue);\n-                                                                storedMaxValue = storedMinValue;\n-                                                            }\n-                                                            if (storedMinValue != null && storedMinValue.compareTo(minValue) < 0) {\n-                                                                minValue = storedMinValue;\n-                                                            }\n-                                                            if (storedMaxValue != null && storedMaxValue.compareTo(maxValue) > 0) {\n-                                                                maxValue = storedMaxValue;\n-                                                            }\n-                                                        } catch (NumberFormatException e) {}\n-                                                    } else {\n-                                                        storedValue = \"\";\n-                                                    }\n-                                                }\n-                                            \n-                                                //logger.fine(\"Stored min value: \"+storedMinValue+\", Stored max value: \"+storedMaxValue);\n-                                                \n-                                                String newAggregateValue = \"\";\n-                                                \n-                                                if (minValue.equals(maxValue)) {\n-                                                    newAggregateValue = minValue.toString();\n-                                                } else {\n-                                                    newAggregateValue = minValue.toString() + \" - \" + maxValue.toString();\n-                                                }\n-                                                \n-                                                // finally, compare it to the value we have now:\n-                                                if (!storedValue.equals(newAggregateValue)) {\n-                                                    if (dsf.getDatasetFieldValues() == null) {\n-                                                        dsf.setDatasetFieldValues(new ArrayList<DatasetFieldValue>());\n-                                                    }\n-                                                    if (dsf.getDatasetFieldValues().get(0) == null) {\n-                                                        DatasetFieldValue newDsfv = new DatasetFieldValue(dsf);\n-                                                        dsf.getDatasetFieldValues().add(newDsfv);\n-                                                    }\n-                                                    dsf.getDatasetFieldValues().get(0).setValue(newAggregateValue);\n-                                                }\n-                                            }\n-                                            // Ouch. \n-                                        } else {\n-                                            // Other fields are aggregated simply by \n-                                            // collecting a list of *unique* values encountered \n-                                            // for this Field throughout the dataset. \n-                                            // This means we need to only add the values *not yet present*.\n-                                            // (the implementation below may be inefficient - ?)\n-\n-                                            for (String fValue : mValues) {\n-                                                if (!dsft.isControlledVocabulary()) {\n-                                                    Iterator<DatasetFieldValue> dsfvIt = dsf.getDatasetFieldValues().iterator();\n-\n-                                                    boolean valueExists = false;\n-\n-                                                    while (dsfvIt.hasNext()) {\n-                                                        DatasetFieldValue dsfv = dsfvIt.next();\n-                                                        if (fValue.equals(dsfv.getValue())) {\n-                                                            logger.fine(\"Value \" + fValue + \" already exists for field \" + dsfName);\n-                                                            valueExists = true;\n-                                                            break;\n-                                                        }\n-                                                    }\n-\n-                                                    if (!valueExists) {\n-                                                        logger.fine(\"Creating a new value for field \" + dsfName + \": \" + fValue);\n-                                                        DatasetFieldValue newDsfv = new DatasetFieldValue(dsf);\n-                                                        newDsfv.setValue(fValue);\n-                                                        dsf.getDatasetFieldValues().add(newDsfv);\n-                                                    }\n-\n-                                                } else {\n-                                                    // A controlled vocabulary entry: \n-                                                    // first, let's see if it's a legit control vocab. entry: \n-                                                    ControlledVocabularyValue legitControlledVocabularyValue = null;\n-                                                    Collection<ControlledVocabularyValue> definedVocabularyValues = dsft.getControlledVocabularyValues();\n-                                                    if (definedVocabularyValues != null) {\n-                                                        for (ControlledVocabularyValue definedVocabValue : definedVocabularyValues) {\n-                                                            if (fValue.equals(definedVocabValue.getStrValue())) {\n-                                                                logger.fine(\"Yes, \" + fValue + \" is a valid controlled vocabulary value for the field \" + dsfName);\n-                                                                legitControlledVocabularyValue = definedVocabValue;\n-                                                                break;\n-                                                            }\n-                                                        }\n-                                                    }\n-                                                    if (legitControlledVocabularyValue != null) {\n-                                                        // Only need to add the value if it is new, \n-                                                        // i.e. if it does not exist yet: \n-                                                        boolean valueExists = false;\n-\n-                                                        List<ControlledVocabularyValue> existingControlledVocabValues = dsf.getControlledVocabularyValues();\n-                                                        if (existingControlledVocabValues != null) {\n-                                                            Iterator<ControlledVocabularyValue> cvvIt = existingControlledVocabValues.iterator();\n-                                                            while (cvvIt.hasNext()) {\n-                                                                ControlledVocabularyValue cvv = cvvIt.next();\n-                                                                if (fValue.equals(cvv.getStrValue())) {\n-                                                                    // or should I use if (legitControlledVocabularyValue.equals(cvv)) ?\n-                                                                    logger.fine(\"Controlled vocab. value \" + fValue + \" already exists for field \" + dsfName);\n-                                                                    valueExists = true;\n-                                                                    break;\n-                                                                }\n-                                                            }\n-                                                        }\n-\n-                                                        if (!valueExists) {\n-                                                            logger.fine(\"Adding controlled vocabulary value \" + fValue + \" to field \" + dsfName);\n-                                                            dsf.getControlledVocabularyValues().add(legitControlledVocabularyValue);\n-                                                        }\n-                                                    }\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                }\n+    ingestSuccessful = true;\n+\n+    return ingestSuccessful;\n+  }\n+\n+\n+  private void processDatasetMetadata(FileMetadataIngest fileMetadataIngest, DatasetVersion editVersion)\n+    throws IOException {\n+\n+\n+    for (MetadataBlock mdb : editVersion.getDataset().getOwner().getMetadataBlocks()) {\n+      if (mdb.getName().equals(fileMetadataIngest.getMetadataBlockName())) {\n+        logger.fine(\"Ingest Service: dataset version has \" + mdb.getName() + \" metadata block enabled.\");\n+\n+        editVersion.setDatasetFields(editVersion.initDatasetFields());\n+\n+        Map<String, Set<String>> fileMetadataMap = fileMetadataIngest.getMetadataMap();\n+        for (DatasetFieldType dsft : mdb.getDatasetFieldTypes()) {\n+          if (dsft.isPrimitive()) {\n+            if (!dsft.isHasParent()) {\n+              String dsfName = dsft.getName();\n+              // See if the plugin has found anything for this field:\n+              if (fileMetadataMap.get(dsfName) != null && !fileMetadataMap.get(dsfName).isEmpty()) {\n+\n+                logger.fine(\"Ingest Service: found extracted metadata for field \" + dsfName);\n+                // go through the existing fields:\n+                for (DatasetField dsf : editVersion.getFlatDatasetFields()) {\n+                  if (dsf.getDatasetFieldType().equals(dsft)) {\n+                    // yep, this is our field!\n+                    // let's go through the values that the ingest\n+                    // plugin found in the file for this field:\n+\n+                    Set<String> mValues = fileMetadataMap.get(dsfName);\n+\n+                    // Special rules apply to aggregation of values for\n+                    // some specific fields - namely, the resolution.*\n+                    // fields from the Astronomy Metadata block.\n+                    // TODO: rather than hard-coded, this needs to be\n+                    // programmatically defined. -- L.A. 4.0\n+                    if (dsfName.equals(\"resolution.Temporal\")\n+                      || dsfName.equals(\"resolution.Spatial\")\n+                      || dsfName.equals(\"resolution.Spectral\")) {\n+                      // For these values, we aggregate the minimum-maximum\n+                      // pair, for the entire set.\n+                      // So first, we need to go through the values found by\n+                      // the plugin and select the min. and max. values of\n+                      // these:\n+                      // (note that we are assuming that they all must\n+                      // validate as doubles!)\n+\n+                      Double minValue = null;\n+                      Double maxValue = null;\n+\n+                      for (String fValue : mValues) {\n+\n+                        try {\n+                          double thisValue = Double.parseDouble(fValue);\n+\n+                          if (minValue == null || Double.compare(thisValue, minValue) < 0) {\n+                            minValue = thisValue;\n+                          }\n+                          if (maxValue == null || Double.compare(thisValue, maxValue) > 0) {\n+                            maxValue = thisValue;\n+                          }\n+                        } catch (NumberFormatException e) {\n+                        }\n+                      }\n+\n+                      // Now let's see what aggregated values we\n+                      // have stored already:\n+\n+                      // (all of these resolution.* fields have allowedMultiple set to FALSE,\n+                      // so there can be only one!)\n+                      //logger.fine(\"Min value: \"+minValue+\", Max value: \"+maxValue);\n+                      if (minValue != null && maxValue != null) {\n+                        Double storedMinValue = null;\n+                        Double storedMaxValue = null;\n+\n+                        String storedValue = \"\";\n+\n+                        if (dsf.getDatasetFieldValues() != null && dsf.getDatasetFieldValues().get(0) != null) {\n+                          storedValue = dsf.getDatasetFieldValues().get(0).getValue();\n+\n+                          if (storedValue != null && !storedValue.equals(\"\")) {\n+                            try {\n+\n+                              if (storedValue.indexOf(\" - \") > -1) {\n+                                storedMinValue =\n+                                  Double.parseDouble(storedValue.substring(0, storedValue.indexOf(\" - \")));\n+                                storedMaxValue =\n+                                  Double.parseDouble(storedValue.substring(storedValue.indexOf(\" - \") + 3));\n+                              } else {\n+                                storedMinValue = Double.parseDouble(storedValue);\n+                                storedMaxValue = storedMinValue;\n+                              }\n+                              if (storedMinValue != null && storedMinValue.compareTo(minValue) < 0) {\n+                                minValue = storedMinValue;\n+                              }\n+                              if (storedMaxValue != null && storedMaxValue.compareTo(maxValue) > 0) {\n+                                maxValue = storedMaxValue;\n+                              }\n+                            } catch (NumberFormatException e) {\n                             }\n+                          } else {\n+                            storedValue = \"\";\n+                          }\n                         }\n+\n+                        //logger.fine(\"Stored min value: \"+storedMinValue+\", Stored max value: \"+storedMaxValue);\n+\n+                        String newAggregateValue = \"\";\n+\n+                        if (minValue.equals(maxValue)) {\n+                          newAggregateValue = minValue.toString();\n+                        } else {\n+                          newAggregateValue = minValue.toString() + \" - \" + maxValue.toString();\n+                        }\n+\n+                        // finally, compare it to the value we have now:\n+                        if (!storedValue.equals(newAggregateValue)) {\n+                          if (dsf.getDatasetFieldValues() == null) {\n+                            dsf.setDatasetFieldValues(new ArrayList<DatasetFieldValue>());\n+                          }\n+                          if (dsf.getDatasetFieldValues().get(0) == null) {\n+                            DatasetFieldValue newDsfv = new DatasetFieldValue(dsf);\n+                            dsf.getDatasetFieldValues().add(newDsfv);\n+                          }\n+                          dsf.getDatasetFieldValues().get(0).setValue(newAggregateValue);\n+                        }\n+                      }\n+                      // Ouch.\n                     } else {\n-                        // A compound field: \n-                        // See if the plugin has found anything for the fields that \n-                        // make up this compound field; if we find at least one \n-                        // of the child values in the map of extracted values, we'll \n-                        // create a new compound field value and its child \n-                        // \n-                        DatasetFieldCompoundValue compoundDsfv = new DatasetFieldCompoundValue();\n-                        int nonEmptyFields = 0; \n-                        for (DatasetFieldType cdsft : dsft.getChildDatasetFieldTypes()) {\n-                            String dsfName = cdsft.getName();\n-                            if (fileMetadataMap.get(dsfName) != null && !fileMetadataMap.get(dsfName).isEmpty()) {  \n-                                logger.fine(\"Ingest Service: found extracted metadata for field \" + dsfName + \", part of the compound field \"+dsft.getName());\n-                                \n-                                if (cdsft.isPrimitive()) {\n-                                    // probably an unnecessary check - child fields\n-                                    // of compound fields are always primitive... \n-                                    // but maybe it'll change in the future. \n-                                    if (!cdsft.isControlledVocabulary()) {\n-                                        // TODO: can we have controlled vocabulary\n-                                        // sub-fields inside compound fields?\n-                                        \n-                                        DatasetField childDsf = new DatasetField();\n-                                        childDsf.setDatasetFieldType(cdsft);\n-                                        \n-                                        DatasetFieldValue newDsfv = new DatasetFieldValue(childDsf);\n-                                        newDsfv.setValue((String)fileMetadataMap.get(dsfName).toArray()[0]);\n-                                        childDsf.getDatasetFieldValues().add(newDsfv);\n-                                        \n-                                        childDsf.setParentDatasetFieldCompoundValue(compoundDsfv);\n-                                        compoundDsfv.getChildDatasetFields().add(childDsf);\n-                                        \n-                                        nonEmptyFields++;\n-                                    }\n-                                } \n+                      // Other fields are aggregated simply by\n+                      // collecting a list of *unique* values encountered\n+                      // for this Field throughout the dataset.\n+                      // This means we need to only add the values *not yet present*.\n+                      // (the implementation below may be inefficient - ?)\n+\n+                      for (String fValue : mValues) {\n+                        if (!dsft.isControlledVocabulary()) {\n+                          Iterator<DatasetFieldValue> dsfvIt = dsf.getDatasetFieldValues().iterator();\n+\n+                          boolean valueExists = false;\n+\n+                          while (dsfvIt.hasNext()) {\n+                            DatasetFieldValue dsfv = dsfvIt.next();\n+                            if (fValue.equals(dsfv.getValue())) {\n+                              logger.fine(\"Value \" + fValue + \" already exists for field \" + dsfName);\n+                              valueExists = true;\n+                              break;\n                             }\n-                        }\n-                        \n-                        if (nonEmptyFields > 0) {\n-                            // let's go through this dataset's fields and find the \n-                            // actual parent for this sub-field: \n-                            for (DatasetField dsf : editVersion.getFlatDatasetFields()) {\n-                                if (dsf.getDatasetFieldType().equals(dsft)) {\n-                                    \n-                                    // Now let's check that the dataset version doesn't already have\n-                                    // this compound value - we are only interested in aggregating \n-                                    // unique values. Note that we need to compare compound values \n-                                    // as sets! -- i.e. all the sub fields in 2 compound fields \n-                                    // must match in order for these 2 compounds to be recognized \n-                                    // as \"the same\":\n-                                    \n-                                    boolean alreadyExists = false; \n-                                    for (DatasetFieldCompoundValue dsfcv : dsf.getDatasetFieldCompoundValues()) {\n-                                        int matches = 0; \n-\n-                                        for (DatasetField cdsf : dsfcv.getChildDatasetFields()) {\n-                                            String cdsfName = cdsf.getDatasetFieldType().getName();\n-                                            String cdsfValue = cdsf.getDatasetFieldValues().get(0).getValue();\n-                                            if (cdsfValue != null && !cdsfValue.equals(\"\")) {\n-                                                String extractedValue = (String)fileMetadataMap.get(cdsfName).toArray()[0];\n-                                                logger.fine(\"values: existing: \"+cdsfValue+\", extracted: \"+extractedValue);\n-                                                if (cdsfValue.equals(extractedValue)) {\n-                                                    matches++;\n-                                                }\n-                                            }\n-                                        }\n-                                        if (matches == nonEmptyFields) {\n-                                            alreadyExists = true; \n-                                            break;\n-                                        }\n-                                    }\n-                                                                        \n-                                    if (!alreadyExists) {\n-                                        // save this compound value, by attaching it to the \n-                                        // version for proper cascading:\n-                                        compoundDsfv.setParentDatasetField(dsf);\n-                                        dsf.getDatasetFieldCompoundValues().add(compoundDsfv);\n-                                    }\n+                          }\n+\n+                          if (!valueExists) {\n+                            logger.fine(\"Creating a new value for field \" + dsfName + \": \" + fValue);\n+                            DatasetFieldValue newDsfv = new DatasetFieldValue(dsf);\n+                            newDsfv.setValue(fValue);\n+                            dsf.getDatasetFieldValues().add(newDsfv);\n+                          }\n+\n+                        } else {\n+                          // A controlled vocabulary entry:\n+                          // first, let's see if it's a legit control vocab. entry:\n+                          ControlledVocabularyValue legitControlledVocabularyValue = null;\n+                          Collection<ControlledVocabularyValue> definedVocabularyValues =\n+                            dsft.getControlledVocabularyValues();\n+                          if (definedVocabularyValues != null) {\n+                            for (ControlledVocabularyValue definedVocabValue : definedVocabularyValues) {\n+                              if (fValue.equals(definedVocabValue.getStrValue())) {\n+                                logger.fine(\n+                                  \"Yes, \" + fValue + \" is a valid controlled vocabulary value for the field \" +\n+                                    dsfName);\n+                                legitControlledVocabularyValue = definedVocabValue;\n+                                break;\n+                              }\n+                            }\n+                          }\n+                          if (legitControlledVocabularyValue != null) {\n+                            // Only need to add the value if it is new,\n+                            // i.e. if it does not exist yet:\n+                            boolean valueExists = false;\n+\n+                            List<ControlledVocabularyValue> existingControlledVocabValues =\n+                              dsf.getControlledVocabularyValues();\n+                            if (existingControlledVocabValues != null) {\n+                              Iterator<ControlledVocabularyValue> cvvIt = existingControlledVocabValues.iterator();\n+                              while (cvvIt.hasNext()) {\n+                                ControlledVocabularyValue cvv = cvvIt.next();\n+                                if (fValue.equals(cvv.getStrValue())) {\n+                                  // or should I use if (legitControlledVocabularyValue.equals(cvv)) ?\n+                                  logger\n+                                    .fine(\"Controlled vocab. value \" + fValue + \" already exists for field \" + dsfName);\n+                                  valueExists = true;\n+                                  break;\n                                 }\n+                              }\n+                            }\n+\n+                            if (!valueExists) {\n+                              logger.fine(\"Adding controlled vocabulary value \" + fValue + \" to field \" + dsfName);\n+                              dsf.getControlledVocabularyValues().add(legitControlledVocabularyValue);\n                             }\n+                          }\n                         }\n+                      }\n                     }\n-                } \n+                  }\n+                }\n+              }\n             }\n-        }  \n-    }\n-    \n-    \n-    private void processFileLevelMetadata(FileMetadataIngest fileLevelMetadata, FileMetadata fileMetadata) {\n-        // The only type of metadata that ingest plugins can extract from ingested\n-        // files (as of 4.0 beta) that *stay* on the file-level is the automatically\n-        // generated \"metadata summary\" note. We attach it to the \"description\" \n-        // field of the fileMetadata object. -- L.A. \n-        \n-        String metadataSummary = fileLevelMetadata.getMetadataSummary();\n-        if (metadataSummary != null) {\n-            if (!metadataSummary.equals(\"\")) {\n-                // The file upload page allows a user to enter file description \n-                // on ingest. We don't want to overwrite whatever they may \n-                // have entered. Rather, we'll append this generated metadata summary \n-                // to the existing value. \n-                String userEnteredFileDescription = fileMetadata.getDescription();\n-                if (userEnteredFileDescription != null\n-                        && !(userEnteredFileDescription.equals(\"\"))) {\n-\n-                    metadataSummary = userEnteredFileDescription.concat(\";\\n\" + metadataSummary);\n+          } else {\n+            // A compound field:\n+            // See if the plugin has found anything for the fields that\n+            // make up this compound field; if we find at least one\n+            // of the child values in the map of extracted values, we'll\n+            // create a new compound field value and its child\n+            //\n+            DatasetFieldCompoundValue compoundDsfv = new DatasetFieldCompoundValue();\n+            int nonEmptyFields = 0;\n+            for (DatasetFieldType cdsft : dsft.getChildDatasetFieldTypes()) {\n+              String dsfName = cdsft.getName();\n+              if (fileMetadataMap.get(dsfName) != null && !fileMetadataMap.get(dsfName).isEmpty()) {\n+                logger.fine(\n+                  \"Ingest Service: found extracted metadata for field \" + dsfName + \", part of the compound field \" +\n+                    dsft.getName());\n+\n+                if (cdsft.isPrimitive()) {\n+                  // probably an unnecessary check - child fields\n+                  // of compound fields are always primitive...\n+                  // but maybe it'll change in the future.\n+                  if (!cdsft.isControlledVocabulary()) {\n+                    // TODO: can we have controlled vocabulary\n+                    // sub-fields inside compound fields?\n+\n+                    DatasetField childDsf = new DatasetField();\n+                    childDsf.setDatasetFieldType(cdsft);\n+\n+                    DatasetFieldValue newDsfv = new DatasetFieldValue(childDsf);\n+                    newDsfv.setValue((String) fileMetadataMap.get(dsfName).toArray()[0]);\n+                    childDsf.getDatasetFieldValues().add(newDsfv);\n+\n+                    childDsf.setParentDatasetFieldCompoundValue(compoundDsfv);\n+                    compoundDsfv.getChildDatasetFields().add(childDsf);\n+\n+                    nonEmptyFields++;\n+                  }\n                 }\n-                fileMetadata.setDescription(metadataSummary);\n+              }\n             }\n-        }\n-    }\n-    \n-    public void performPostProcessingTasks(DataFile dataFile) {\n-        /*\n-         * At this point (4.0 beta) the only ingest \"post-processing task\" performed \n-         * is pre-generation of image thumbnails in a couple of popular sizes. \n-         * -- L.A. \n-         */\n-        if (dataFile != null && dataFile.isImage()) {\n-            try {\n-                StorageIO<DataFile> dataAccess = dataFile.getStorageIO();\n-                if (dataAccess != null) { // && storageIO.isLocalFile()) {\n \n-                    if (ImageThumbConverter.isThumbnailAvailable(dataFile, ImageThumbConverter.DEFAULT_PREVIEW_SIZE)) {\n-                        dataFile.setPreviewImageAvailable(true);\n+            if (nonEmptyFields > 0) {\n+              // let's go through this dataset's fields and find the\n+              // actual parent for this sub-field:\n+              for (DatasetField dsf : editVersion.getFlatDatasetFields()) {\n+                if (dsf.getDatasetFieldType().equals(dsft)) {\n+\n+                  // Now let's check that the dataset version doesn't already have\n+                  // this compound value - we are only interested in aggregating\n+                  // unique values. Note that we need to compare compound values\n+                  // as sets! -- i.e. all the sub fields in 2 compound fields\n+                  // must match in order for these 2 compounds to be recognized\n+                  // as \"the same\":\n+\n+                  boolean alreadyExists = false;\n+                  for (DatasetFieldCompoundValue dsfcv : dsf.getDatasetFieldCompoundValues()) {\n+                    int matches = 0;\n+\n+                    for (DatasetField cdsf : dsfcv.getChildDatasetFields()) {\n+                      String cdsfName = cdsf.getDatasetFieldType().getName();\n+                      String cdsfValue = cdsf.getDatasetFieldValues().get(0).getValue();\n+                      if (cdsfValue != null && !cdsfValue.equals(\"\")) {\n+                        String extractedValue = (String) fileMetadataMap.get(cdsfName).toArray()[0];\n+                        logger.fine(\"values: existing: \" + cdsfValue + \", extracted: \" + extractedValue);\n+                        if (cdsfValue.equals(extractedValue)) {\n+                          matches++;\n+                        }\n+                      }\n+                    }\n+                    if (matches == nonEmptyFields) {\n+                      alreadyExists = true;\n+                      break;\n                     }\n+                  }\n+\n+                  if (!alreadyExists) {\n+                    // save this compound value, by attaching it to the\n+                    // version for proper cascading:\n+                    compoundDsfv.setParentDatasetField(dsf);\n+                    dsf.getDatasetFieldCompoundValues().add(compoundDsfv);\n+                  }\n                 }\n-            } catch (IOException ioEx) {\n+              }\n             }\n+          }\n         }\n+      }\n     }\n- \n-    private Set<Integer> selectContinuousVariableColumns(DataFile dataFile) {\n-        Set<Integer> contVarFields = new LinkedHashSet<Integer>();\n+  }\n+\n+\n+  private void processFileLevelMetadata(FileMetadataIngest fileLevelMetadata, FileMetadata fileMetadata) {\n+    // The only type of metadata that ingest plugins can extract from ingested\n+    // files (as of 4.0 beta) that *stay* on the file-level is the automatically\n+    // generated \"metadata summary\" note. We attach it to the \"description\"\n+    // field of the fileMetadata object. -- L.A.\n+\n+    String metadataSummary = fileLevelMetadata.getMetadataSummary();\n+    if (metadataSummary != null) {\n+      if (!metadataSummary.equals(\"\")) {\n+        // The file upload page allows a user to enter file description\n+        // on ingest. We don't want to overwrite whatever they may\n+        // have entered. Rather, we'll append this generated metadata summary\n+        // to the existing value.\n+        String userEnteredFileDescription = fileMetadata.getDescription();\n+        if (userEnteredFileDescription != null\n+          && !(userEnteredFileDescription.equals(\"\"))) {\n+\n+          metadataSummary = userEnteredFileDescription.concat(\";\\n\" + metadataSummary);\n+        }\n+        fileMetadata.setDescription(metadataSummary);\n+      }\n+    }\n+  }\n \n-        for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n-            if (dataFile.getDataTable().getDataVariables().get(i).isIntervalContinuous()) {\n-                contVarFields.add(i);\n-            }\n+  public void performPostProcessingTasks(DataFile dataFile) {\n+    /*\n+     * At this point (4.0 beta) the only ingest \"post-processing task\" performed\n+     * is pre-generation of image thumbnails in a couple of popular sizes.\n+     * -- L.A.\n+     */\n+    if (dataFile != null && dataFile.isImage()) {\n+      try {\n+        StorageIO<DataFile> dataAccess = dataFile.getStorageIO();\n+        if (dataAccess != null) { // && storageIO.isLocalFile()) {\n+\n+          if (ImageThumbConverter.isThumbnailAvailable(dataFile, ImageThumbConverter.DEFAULT_PREVIEW_SIZE)) {\n+            dataFile.setPreviewImageAvailable(true);\n+          }\n         }\n+      } catch (IOException ioEx) {\n+      }\n+    }\n+  }\n \n-        return contVarFields;\n+  private Set<Integer> selectContinuousVariableColumns(DataFile dataFile) {\n+    Set<Integer> contVarFields = new LinkedHashSet<Integer>();\n+\n+    for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n+      if (dataFile.getDataTable().getDataVariables().get(i).isIntervalContinuous()) {\n+        contVarFields.add(i);\n+      }\n     }\n-    \n-    private void calculateContinuousSummaryStatistics(DataFile dataFile, int varnum, Number[] dataVector) throws IOException {\n-        double[] sumStats = SumStatCalculator.calculateSummaryStatistics(dataVector);\n-        assignContinuousSummaryStatistics(dataFile.getDataTable().getDataVariables().get(varnum), sumStats);\n+\n+    return contVarFields;\n+  }\n+\n+  private void calculateContinuousSummaryStatistics(DataFile dataFile, int varnum, Number[] dataVector)\n+    throws IOException {\n+    double[] sumStats = SumStatCalculator.calculateSummaryStatistics(dataVector);\n+    assignContinuousSummaryStatistics(dataFile.getDataTable().getDataVariables().get(varnum), sumStats);\n+  }\n+\n+  private void assignContinuousSummaryStatistics(DataVariable variable, double[] sumStats) throws IOException {\n+    if (sumStats == null || sumStats.length != variableService.summaryStatisticTypes.length) {\n+      throw new IOException(\"Wrong number of summary statistics types calculated! (\" + sumStats.length + \")\");\n     }\n-    \n-    private void assignContinuousSummaryStatistics(DataVariable variable, double[] sumStats) throws IOException {\n-        if (sumStats == null || sumStats.length != variableService.summaryStatisticTypes.length) {\n-            throw new IOException (\"Wrong number of summary statistics types calculated! (\"+sumStats.length+\")\");\n-        }\n-        \n-        for (int j = 0; j < variableService.summaryStatisticTypes.length; j++) {\n-            SummaryStatistic ss = new SummaryStatistic();\n-            ss.setTypeByLabel(variableService.summaryStatisticTypes[j]);\n-            if (!ss.isTypeMode()) {\n-                ss.setValue((new Double(sumStats[j])).toString());\n-            } else {\n-                ss.setValue(\".\");\n+\n+    for (int j = 0; j < variableService.summaryStatisticTypes.length; j++) {\n+      SummaryStatistic ss = new SummaryStatistic();\n+      ss.setTypeByLabel(variableService.summaryStatisticTypes[j]);\n+      if (!ss.isTypeMode()) {\n+        ss.setValue((new Double(sumStats[j])).toString());\n+      } else {\n+        ss.setValue(\".\");\n+      }\n+      ss.setDataVariable(variable);\n+      variable.getSummaryStatistics().add(ss);\n+    }\n+\n+  }\n+\n+  private void calculateUNF(DataFile dataFile, int varnum, Double[] dataVector) {\n+    String unf = null;\n+    try {\n+      unf = UNFUtil.calculateUNF(dataVector);\n+    } catch (IOException iex) {\n+      logger.warning(\n+        \"exception thrown when attempted to calculate UNF signature for (numeric, continuous) variable \" + varnum);\n+    } catch (UnfException uex) {\n+      logger.warning(\n+        \"UNF Exception: thrown when attempted to calculate UNF signature for (numeric, continuous) variable \" + varnum);\n+    }\n+\n+    if (unf != null) {\n+      dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n+    } else {\n+      logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n+    }\n+  }\n+\n+  private void calculateUNF(DataFile dataFile, int varnum, Long[] dataVector) {\n+    String unf = null;\n+    try {\n+      unf = UNFUtil.calculateUNF(dataVector);\n+    } catch (IOException iex) {\n+      logger.warning(\n+        \"exception thrown when attempted to calculate UNF signature for (numeric, discrete) variable \" + varnum);\n+    } catch (UnfException uex) {\n+      logger.warning(\n+        \"UNF Exception: thrown when attempted to calculate UNF signature for (numeric, discrete) variable \" + varnum);\n+    }\n+\n+    if (unf != null) {\n+      dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n+    } else {\n+      logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n+    }\n+  }\n+\n+  private void calculateUNF(DataFile dataFile, int varnum, String[] dataVector) throws IOException {\n+    String unf = null;\n+\n+    String[] dateFormats = null;\n+\n+    // Special handling for Character strings that encode dates and times:\n+\n+    if (\"time\".equals(dataFile.getDataTable().getDataVariables().get(varnum).getFormatCategory())) {\n+      dateFormats = new String[dataVector.length];\n+      String savedDateTimeFormat = dataFile.getDataTable().getDataVariables().get(varnum).getFormat();\n+      String timeFormat = null;\n+      if (savedDateTimeFormat != null && !savedDateTimeFormat.equals(\"\")) {\n+        timeFormat = savedDateTimeFormat;\n+      } else {\n+        timeFormat = dateTimeFormat_ymdhmsS;\n+      }\n+\n+      /* What follows is special handling of a special case of time values\n+       * non-uniform precision; specifically, when some have if some have\n+       * milliseconds, and some don't. (and that in turn is only\n+       * n issue when the timezone is present... without the timezone\n+       * the time string would still evaluate to the end, even if the\n+       * format has the .SSS part and the string does not.\n+       * This case will be properly handled internally, once we permanently\n+       * switch to UNF6.\n+       * -- L.A. 4.0 beta 8\n+       */\n+      String simplifiedFormat = null;\n+      SimpleDateFormat fullFormatParser = null;\n+      SimpleDateFormat simplifiedFormatParser = null;\n+\n+      if (timeFormat.matches(\".*\\\\.SSS z$\")) {\n+        simplifiedFormat = timeFormat.replace(\".SSS\", \"\");\n+\n+        fullFormatParser = new SimpleDateFormat(timeFormat);\n+        simplifiedFormatParser = new SimpleDateFormat(simplifiedFormat);\n+      }\n+\n+      for (int i = 0; i < dataVector.length; i++) {\n+        if (dataVector[i] != null) {\n+\n+          if (simplifiedFormatParser != null) {\n+            // first, try to parse the value against the \"full\"\n+            // format (with the milliseconds part):\n+            fullFormatParser.setLenient(false);\n+\n+            try {\n+              logger.fine(\"trying the \\\"full\\\" time format, with milliseconds: \" + timeFormat + \", \" + dataVector[i]);\n+              fullFormatParser.parse(dataVector[i]);\n+            } catch (ParseException ex) {\n+              // try the simplified (no time zone) format instead:\n+              logger.fine(\"trying the simplified format: \" + simplifiedFormat + \", \" + dataVector[i]);\n+              simplifiedFormatParser.setLenient(false);\n+              try {\n+                simplifiedFormatParser.parse(dataVector[i]);\n+                timeFormat = simplifiedFormat;\n+              } catch (ParseException ex1) {\n+                logger.warning(\"no parseable format found for time value \" + i + \" - \" + dataVector[i]);\n+                throw new IOException(\"no parseable format found for time value \" + i + \" - \" + dataVector[i]);\n+              }\n             }\n-            ss.setDataVariable(variable);\n-            variable.getSummaryStatistics().add(ss);\n+\n+          }\n+          dateFormats[i] = timeFormat;\n+        }\n+      }\n+    } else if (\"date\".equals(dataFile.getDataTable().getDataVariables().get(varnum).getFormatCategory())) {\n+      dateFormats = new String[dataVector.length];\n+      String savedDateFormat = dataFile.getDataTable().getDataVariables().get(varnum).getFormat();\n+      for (int i = 0; i < dataVector.length; i++) {\n+        if (dataVector[i] != null) {\n+          if (savedDateFormat != null && !savedDateFormat.equals(\"\")) {\n+            dateFormats[i] = savedDateFormat;\n+          } else {\n+            dateFormats[i] = dateFormat_ymd;\n+          }\n         }\n+      }\n+    }\n \n+    try {\n+      if (dateFormats == null) {\n+        logger.fine(\"calculating the UNF value for string vector; first value: \" + dataVector[0]);\n+        unf = UNFUtil.calculateUNF(dataVector);\n+      } else {\n+        unf = UNFUtil.calculateUNF(dataVector, dateFormats);\n+      }\n+    } catch (IOException iex) {\n+      logger\n+        .warning(\"IO exception thrown when attempted to calculate UNF signature for (character) variable \" + varnum);\n+    } catch (UnfException uex) {\n+      logger\n+        .warning(\"UNF Exception: thrown when attempted to calculate UNF signature for (character) variable \" + varnum);\n     }\n-    \n-    private void calculateUNF(DataFile dataFile, int varnum, Double[] dataVector) {\n-        String unf = null;\n+\n+    if (unf != null) {\n+      dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n+    } else {\n+      logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n+    }\n+  }\n+\n+  // Calculating UNFs from *floats*, not *doubles* - this is to test dataverse\n+  // 4.0 Ingest against DVN 3.*; because of the nature of the UNF bug, reading\n+  // the tab file entry with 7+ digits of precision as a Double will result\n+  // in a UNF signature *different* from what was produced by the v. 3.* ingest,\n+  // from a STATA float value directly.\n+  // TODO: remove this from the final production 4.0!\n+  // -- L.A., Jul 2014\n+\n+  private void calculateUNF(DataFile dataFile, int varnum, Float[] dataVector) {\n+    String unf = null;\n+    try {\n+      unf = UNFUtil.calculateUNF(dataVector);\n+    } catch (IOException iex) {\n+      logger.warning(\n+        \"exception thrown when attempted to calculate UNF signature for numeric, \\\"continuous\\\" (float) variable \" +\n+          varnum);\n+    } catch (UnfException uex) {\n+      logger.warning(\n+        \"UNF Exception: thrown when attempted to calculate UNF signature for numeric, \\\"continuous\\\" (float) variable\" +\n+          varnum);\n+    }\n+\n+    if (unf != null) {\n+      dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n+    } else {\n+      logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n+    }\n+  }\n+\n+  // This method takes a list of file ids, checks the format type of the ingested\n+  // original, and attempts to fix it if it's missing.\n+  // Note the @Asynchronous attribute - this allows us to just kick off and run this\n+  // (potentially large) job in the background.\n+  // The method is called by the \"fixmissingoriginaltypes\" /admin api call.\n+  @Asynchronous\n+  public void fixMissingOriginalTypes(List<Long> datafileIds) {\n+    for (Long fileId : datafileIds) {\n+      fixMissingOriginalType(fileId);\n+    }\n+    logger.info(\"Finished repairing tabular data files that were missing the original file format labels.\");\n+  }\n+\n+  // This method takes a list of file ids and tries to fix the size of the saved\n+  // original, if present\n+  // Note the @Asynchronous attribute - this allows us to just kick off and run this\n+  // (potentially large) job in the background.\n+  // The method is called by the \"fixmissingoriginalsizes\" /admin api call.\n+  @Asynchronous\n+  public void fixMissingOriginalSizes(List<Long> datafileIds) {\n+    for (Long fileId : datafileIds) {\n+      fixMissingOriginalSize(fileId);\n+      try {\n+        Thread.sleep(1000);\n+      } catch (Exception ex) {\n+      }\n+    }\n+    logger.info(\"Finished repairing tabular data files that were missing the original file sizes.\");\n+  }\n+\n+  // This method fixes a datatable object that's missing the format type of\n+  // the ingested original. It will check the saved original file to\n+  // determine the type.\n+  private void fixMissingOriginalType(long fileId) {\n+    DataFile dataFile = fileService.find(fileId);\n+\n+    if (dataFile != null && dataFile.isTabularData()) {\n+      String originalFormat = dataFile.getDataTable().getOriginalFileFormat();\n+      Long datatableId = dataFile.getDataTable().getId();\n+      if (StringUtil.isEmpty(originalFormat) || originalFormat.equals(FileUtil.MIME_TYPE_INGESTED_FILE)) {\n+\n+        // We need to determine the mime type of the saved original\n+        // and save it in the database.\n+        //\n+        // First, we need access to the file. Note that the code below\n+        // works with any supported StorageIO driver (although, as of now\n+        // all the production installations out there are only using filesystem\n+        // access; but just in case)\n+        // The FileUtil method that determines the type takes java.io.File\n+        // as an argument. So for StorageIO drivers that provide local\n+        // file access, we'll just go directly to the stored file. For\n+        // swift and similar implementations, we'll read the saved aux\n+        // channel and save it as a local temp file.\n+\n+        StorageIO<DataFile> storageIO;\n+\n+        File savedOriginalFile = null;\n+        boolean tempFileRequired = false;\n+\n         try {\n-            unf = UNFUtil.calculateUNF(dataVector);\n-        } catch (IOException iex) {\n-            logger.warning(\"exception thrown when attempted to calculate UNF signature for (numeric, continuous) variable \" + varnum);\n-        } catch (UnfException uex) {\n-            logger.warning(\"UNF Exception: thrown when attempted to calculate UNF signature for (numeric, continuous) variable \" + varnum);\n+          storageIO = dataFile.getStorageIO();\n+          storageIO.open();\n+\n+\n+          if (storageIO.isLocalFile()) {\n+            try {\n+              savedOriginalFile = storageIO.getAuxObjectAsPath(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION).toFile();\n+            } catch (IOException ioex) {\n+              // do nothing, just make sure savedOriginalFile is still null:\n+              savedOriginalFile = null;\n+            }\n+          }\n+\n+          if (savedOriginalFile == null) {\n+            tempFileRequired = true;\n+\n+            savedOriginalFile = File.createTempFile(\"tempSavedOriginal\", \".tmp\");\n+            try (ReadableByteChannel savedOriginalChannel = (ReadableByteChannel) storageIO\n+              .openAuxChannel(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+                 FileChannel tempSavedOriginalChannel = new FileOutputStream(savedOriginalFile)\n+                   .getChannel();) {\n+              tempSavedOriginalChannel.transferFrom(savedOriginalChannel, 0,\n+                storageIO.getAuxObjectSize(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION));\n+            }\n+\n+          }\n+        } catch (Exception ex) {\n+          logger.warning(\"Exception \" + ex.getClass() +\n+            \" caught trying to open StorageIO channel for the saved original; (datafile id=\" + fileId +\n+            \", datatable id=\" + datatableId + \"): \" + ex.getMessage());\n+          savedOriginalFile = null;\n         }\n-        \n-        if (unf != null) {\n-            dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n-        } else {\n-            logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n+\n+        if (savedOriginalFile == null) {\n+          logger.warning(\n+            \"Could not obtain the saved original file as a java.io.File! (datafile id=\" + fileId + \", datatable id=\" +\n+              datatableId + \")\");\n+          return;\n         }\n-    }\n-    \n-    private void calculateUNF(DataFile dataFile, int varnum, Long[] dataVector) {\n-        String unf = null;\n+\n+        String fileTypeDetermined = null;\n+\n         try {\n-            unf = UNFUtil.calculateUNF(dataVector);\n-        } catch (IOException iex) {\n-            logger.warning(\"exception thrown when attempted to calculate UNF signature for (numeric, discrete) variable \" + varnum);\n-        }  catch (UnfException uex) {\n-            logger.warning(\"UNF Exception: thrown when attempted to calculate UNF signature for (numeric, discrete) variable \" + varnum);\n+          fileTypeDetermined = FileUtil.determineFileType(savedOriginalFile, \"\");\n+        } catch (IOException ioex) {\n+          logger.warning(\n+            \"Caught exception trying to determine original file type (datafile id=\" + fileId + \", datatable id=\" +\n+              datatableId + \"): \" + ioex.getMessage());\n         }\n-        \n-        if (unf != null) {\n-            dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n-        } else {\n-            logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n+\n+        Long savedOriginalFileSize = savedOriginalFile.length();\n+\n+        // If we had to create a temp file, delete it now:\n+        if (tempFileRequired) {\n+          savedOriginalFile.delete();\n         }\n-    }\n-    \n-    private void calculateUNF(DataFile dataFile, int varnum, String[] dataVector) throws IOException {\n-        String unf = null;\n-        \n-        String[] dateFormats = null; \n-        \n-        // Special handling for Character strings that encode dates and times:\n-        \n-        if (\"time\".equals(dataFile.getDataTable().getDataVariables().get(varnum).getFormatCategory())) {\n-            dateFormats = new String[dataVector.length];\n-            String savedDateTimeFormat = dataFile.getDataTable().getDataVariables().get(varnum).getFormat();\n-            String timeFormat = null;\n-            if (savedDateTimeFormat != null && !savedDateTimeFormat.equals(\"\")) {\n-                timeFormat = savedDateTimeFormat;\n-            } else {\n-                timeFormat = dateTimeFormat_ymdhmsS;\n-            }\n-            \n-            /* What follows is special handling of a special case of time values\n-             * non-uniform precision; specifically, when some have if some have \n-             * milliseconds, and some don't. (and that in turn is only \n-             * n issue when the timezone is present... without the timezone\n-             * the time string would still evaluate to the end, even if the \n-             * format has the .SSS part and the string does not.\n-             * This case will be properly handled internally, once we permanently\n-             * switch to UNF6.\n-             * -- L.A. 4.0 beta 8\n-             */\n-            String simplifiedFormat = null;\n-            SimpleDateFormat fullFormatParser = null;\n-            SimpleDateFormat simplifiedFormatParser = null;\n-            \n-            if (timeFormat.matches(\".*\\\\.SSS z$\")) {\n-                simplifiedFormat = timeFormat.replace(\".SSS\", \"\");\n-                \n-                fullFormatParser = new SimpleDateFormat(timeFormat);\n-                simplifiedFormatParser = new SimpleDateFormat(simplifiedFormat);\n-            } \n-            \n-            for (int i = 0; i < dataVector.length; i++) {\n-                if (dataVector[i] != null) {\n-                    \n-                    if (simplifiedFormatParser != null) {\n-                        // first, try to parse the value against the \"full\" \n-                        // format (with the milliseconds part):\n-                        fullFormatParser.setLenient(false);\n-                    \n-                        try {\n-                            logger.fine(\"trying the \\\"full\\\" time format, with milliseconds: \"+timeFormat+\", \"+dataVector[i]);\n-                            fullFormatParser.parse(dataVector[i]);\n-                         } catch (ParseException ex) {\n-                            // try the simplified (no time zone) format instead:\n-                            logger.fine(\"trying the simplified format: \"+simplifiedFormat+\", \"+dataVector[i]);\n-                            simplifiedFormatParser.setLenient(false);\n-                            try {\n-                                simplifiedFormatParser.parse(dataVector[i]);\n-                                timeFormat = simplifiedFormat;\n-                            } catch (ParseException ex1) {\n-                                logger.warning(\"no parseable format found for time value \"+i+\" - \"+dataVector[i]);\n-                                throw new IOException(\"no parseable format found for time value \"+i+\" - \"+dataVector[i]);\n-                            }\n-                        }\n \n-                    } \n-                    dateFormats[i] = timeFormat;\n-                }\n-            }\n-        } else if (\"date\".equals(dataFile.getDataTable().getDataVariables().get(varnum).getFormatCategory())) {\n-            dateFormats = new String[dataVector.length];\n-            String savedDateFormat = dataFile.getDataTable().getDataVariables().get(varnum).getFormat();\n-            for (int i = 0; i < dataVector.length; i++) {\n-                if (dataVector[i] != null) {\n-                    if (savedDateFormat != null && !savedDateFormat.equals(\"\")) {\n-                        dateFormats[i] = savedDateFormat;\n-                    } else {\n-                        dateFormats[i] = dateFormat_ymd;\n-                    }\n-                }\n-            }\n+        if (fileTypeDetermined == null) {\n+          logger.warning(\n+            \"Failed to determine preserved original file type. (datafile id=\" + fileId + \", datatable id=\" +\n+              datatableId + \")\");\n+          return;\n         }\n-                \n-        try {\n-            if (dateFormats == null) {\n-                logger.fine(\"calculating the UNF value for string vector; first value: \"+dataVector[0]);\n-                unf = UNFUtil.calculateUNF(dataVector);\n-            } else {\n-                unf = UNFUtil.calculateUNF(dataVector, dateFormats);\n-            }\n-        } catch (IOException iex) {\n-            logger.warning(\"IO exception thrown when attempted to calculate UNF signature for (character) variable \" + varnum);\n-        } catch (UnfException uex) {\n-            logger.warning(\"UNF Exception: thrown when attempted to calculate UNF signature for (character) variable \" + varnum);\n+        // adjust the final result:\n+        // we know that this file has been successfully ingested;\n+        // so if the FileUtil is telling us it's a \"plain text\" file at this point,\n+        // it really means it must be a CSV file.\n+        if (fileTypeDetermined.startsWith(\"text/plain\")) {\n+          fileTypeDetermined = FileUtil.MIME_TYPE_CSV;\n         }\n-        \n-        if (unf != null) {\n-            dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n-        } else {\n-            logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n+        // and, finally, if it is still \"application/octet-stream\", it must be Excel:\n+        if (FileUtil.MIME_TYPE_UNDETERMINED_DEFAULT.equals(fileTypeDetermined)) {\n+          fileTypeDetermined = FileUtil.MIME_TYPE_XLSX;\n         }\n+        logger.info(\"Original file type determined: \" + fileTypeDetermined + \" (file id=\" + fileId + \", datatable id=\" +\n+          datatableId + \"; file path: \" + savedOriginalFile.getAbsolutePath() + \")\");\n+\n+        // save permanently in the database:\n+        dataFile.getDataTable().setOriginalFileFormat(fileTypeDetermined);\n+        dataFile.getDataTable().setOriginalFileSize(savedOriginalFileSize);\n+        fileService.saveDataTable(dataFile.getDataTable());\n+\n+      } else {\n+        logger.info(\"DataFile id=\" + fileId + \"; original type already present: \" + originalFormat);\n+      }\n+    } else {\n+      logger.warning(\"DataFile id=\" + fileId + \": No such DataFile!\");\n     }\n-    \n-    // Calculating UNFs from *floats*, not *doubles* - this is to test dataverse\n-    // 4.0 Ingest against DVN 3.*; because of the nature of the UNF bug, reading\n-    // the tab file entry with 7+ digits of precision as a Double will result\n-    // in a UNF signature *different* from what was produced by the v. 3.* ingest,\n-    // from a STATA float value directly. \n-    // TODO: remove this from the final production 4.0!\n-    // -- L.A., Jul 2014\n-    \n-    private void calculateUNF(DataFile dataFile, int varnum, Float[] dataVector) {\n-        String unf = null;\n+  }\n+\n+  // This method fixes a datatable object that's missing the size of the\n+  // ingested original.\n+  private void fixMissingOriginalSize(long fileId) {\n+    DataFile dataFile = fileService.find(fileId);\n+\n+    if (dataFile != null && dataFile.isTabularData()) {\n+      Long savedOriginalFileSize = dataFile.getDataTable().getOriginalFileSize();\n+      Long datatableId = dataFile.getDataTable().getId();\n+\n+      if (savedOriginalFileSize == null) {\n+\n+        StorageIO<DataFile> storageIO;\n+\n         try {\n-            unf = UNFUtil.calculateUNF(dataVector);\n-        } catch (IOException iex) {\n-            logger.warning(\"exception thrown when attempted to calculate UNF signature for numeric, \\\"continuous\\\" (float) variable \" + varnum);\n-        } catch (UnfException uex) {\n-            logger.warning(\"UNF Exception: thrown when attempted to calculate UNF signature for numeric, \\\"continuous\\\" (float) variable\" + varnum);\n+          storageIO = dataFile.getStorageIO();\n+          storageIO.open();\n+          savedOriginalFileSize = storageIO.getAuxObjectSize(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+\n+        } catch (Exception ex) {\n+          logger.warning(\n+            \"Exception \" + ex.getClass() + \" caught trying to look up the size of the saved original; (datafile id=\" +\n+              fileId + \", datatable id=\" + datatableId + \"): \" + ex.getMessage());\n+          return;\n         }\n-        \n-        if (unf != null) {\n-            dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n-        } else {\n-            logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n-        }\n-    }\n-    \n-    // This method takes a list of file ids, checks the format type of the ingested \n-    // original, and attempts to fix it if it's missing. \n-    // Note the @Asynchronous attribute - this allows us to just kick off and run this \n-    // (potentially large) job in the background. \n-    // The method is called by the \"fixmissingoriginaltypes\" /admin api call. \n-    @Asynchronous\n-    public void fixMissingOriginalTypes(List<Long> datafileIds) {\n-        for (Long fileId : datafileIds) {\n-            fixMissingOriginalType(fileId);\n+\n+        if (savedOriginalFileSize == null) {\n+          logger.warning(\n+            \"Failed to look up the size of the saved original file! (datafile id=\" + fileId + \", datatable id=\" +\n+              datatableId + \")\");\n+          return;\n         }\n-        logger.info(\"Finished repairing tabular data files that were missing the original file format labels.\");\n+\n+        // save permanently in the database:\n+        dataFile.getDataTable().setOriginalFileSize(savedOriginalFileSize);\n+        fileService.saveDataTable(dataFile.getDataTable());\n+\n+      } else {\n+        logger.info(\"DataFile id=\" + fileId + \"; original file size already present: \" + savedOriginalFileSize);\n+      }\n+    } else {\n+      logger.warning(\"DataFile id=\" + fileId + \": No such DataFile!\");\n     }\n-    \n-    // This method takes a list of file ids and tries to fix the size of the saved \n-    // original, if present\n-    // Note the @Asynchronous attribute - this allows us to just kick off and run this \n-    // (potentially large) job in the background. \n-    // The method is called by the \"fixmissingoriginalsizes\" /admin api call. \n-    @Asynchronous\n-    public void fixMissingOriginalSizes(List<Long> datafileIds) {\n-        for (Long fileId : datafileIds) {\n-            fixMissingOriginalSize(fileId);\n-            try {\n-                Thread.sleep(1000);\n-            } catch (Exception ex) {}\n-        }\n-        logger.info(\"Finished repairing tabular data files that were missing the original file sizes.\");\n+  }\n+\n+  public static void main(String[] args) {\n+\n+    String file = args[0];\n+    String type = args[1];\n+\n+    if (file == null || type == null || \"\".equals(file) || \"\".equals(type)) {\n+      System.err.println(\"Usage: java edu.harvard.iq.dataverse.ingest.IngestServiceBean <file> <type>.\");\n+      System.exit(1);\n     }\n-    \n-    // This method fixes a datatable object that's missing the format type of \n-    // the ingested original. It will check the saved original file to \n-    // determine the type. \n-    private void fixMissingOriginalType(long fileId) {\n-        DataFile dataFile = fileService.find(fileId);\n-\n-        if (dataFile != null && dataFile.isTabularData()) {\n-            String originalFormat = dataFile.getDataTable().getOriginalFileFormat();\n-            Long datatableId = dataFile.getDataTable().getId();\n-            if (StringUtil.isEmpty(originalFormat) || originalFormat.equals(FileUtil.MIME_TYPE_INGESTED_FILE)) {\n-\n-                // We need to determine the mime type of the saved original\n-                // and save it in the database. \n-                // \n-                // First, we need access to the file. Note that the code below \n-                // works with any supported StorageIO driver (although, as of now\n-                // all the production installations out there are only using filesystem\n-                // access; but just in case)\n-                // The FileUtil method that determines the type takes java.io.File \n-                // as an argument. So for StorageIO drivers that provide local \n-                // file access, we'll just go directly to the stored file. For \n-                // swift and similar implementations, we'll read the saved aux \n-                // channel and save it as a local temp file. \n-                \n-                StorageIO<DataFile> storageIO;\n-\n-                File savedOriginalFile = null;\n-                boolean tempFileRequired = false;\n-                \n-                try {\n-                    storageIO = dataFile.getStorageIO();\n-                    storageIO.open();\n \n+    BufferedInputStream fileInputStream = null;\n \n-                    if (storageIO.isLocalFile()) {\n-                        try {\n-                            savedOriginalFile = storageIO.getAuxObjectAsPath(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION).toFile();\n-                        } catch (IOException ioex) {\n-                            // do nothing, just make sure savedOriginalFile is still null:\n-                            savedOriginalFile = null;\n-                        }\n-                    }\n+    try {\n+      fileInputStream = new BufferedInputStream(new FileInputStream(new File(file)));\n+    } catch (FileNotFoundException notfoundEx) {\n+      fileInputStream = null;\n+    }\n \n-                    if (savedOriginalFile == null) {\n-                        tempFileRequired = true;\n+    if (fileInputStream == null) {\n+      System.err.println(\"Could not open file \" + file + \".\");\n+      System.exit(1);\n+    }\n \n-\t\t\t\t\t\tsavedOriginalFile = File.createTempFile(\"tempSavedOriginal\", \".tmp\");\n-\t\t\t\t\t\ttry (ReadableByteChannel savedOriginalChannel = (ReadableByteChannel) storageIO\n-\t\t\t\t\t\t\t\t.openAuxChannel(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-\t\t\t\t\t\t\t\tFileChannel tempSavedOriginalChannel = new FileOutputStream(savedOriginalFile)\n-\t\t\t\t\t\t\t\t\t\t.getChannel();) {\n-\t\t\t\t\t\t\ttempSavedOriginalChannel.transferFrom(savedOriginalChannel, 0,\n-\t\t\t\t\t\t\t\t\tstorageIO.getAuxObjectSize(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION));\n-\t\t\t\t\t\t}\n+    TabularDataFileReader ingestPlugin = getTabDataReaderByMimeType(type);\n \n-                    }\n-                } catch (Exception ex) {\n-                    logger.warning(\"Exception \"+ex.getClass()+\" caught trying to open StorageIO channel for the saved original; (datafile id=\" + fileId + \", datatable id=\" + datatableId + \"): \" + ex.getMessage());\n-                    savedOriginalFile = null;\n-                }\n+    if (ingestPlugin == null) {\n+      System.err.println(\"Could not locate an ingest plugin for type \" + type + \".\");\n+      System.exit(1);\n+    }\n \n-                if (savedOriginalFile == null) {\n-                    logger.warning(\"Could not obtain the saved original file as a java.io.File! (datafile id=\" + fileId + \", datatable id=\" + datatableId + \")\");\n-                    return;\n-                }\n+    TabularDataIngest tabDataIngest = null;\n \n-                String fileTypeDetermined = null;\n+    try {\n+      tabDataIngest = ingestPlugin.read(fileInputStream, null);\n+    } catch (IOException ingestEx) {\n+      System.err.println(\"Caught an exception trying to ingest file \" + file + \".\");\n+      System.exit(1);\n+    }\n \n-                try {\n-                    fileTypeDetermined = FileUtil.determineFileType(savedOriginalFile, \"\");\n-                } catch (IOException ioex) {\n-                    logger.warning(\"Caught exception trying to determine original file type (datafile id=\" + fileId + \", datatable id=\" + datatableId + \"): \" + ioex.getMessage());\n-                }\n-                \n-                Long savedOriginalFileSize = savedOriginalFile.length(); \n-                \n-                // If we had to create a temp file, delete it now: \n-                if (tempFileRequired) {\n-                    savedOriginalFile.delete();\n-                }\n+    try {\n+      if (tabDataIngest != null) {\n+        File tabFile = tabDataIngest.getTabDelimitedFile();\n \n-                if (fileTypeDetermined == null) {\n-                    logger.warning(\"Failed to determine preserved original file type. (datafile id=\" + fileId + \", datatable id=\" + datatableId + \")\");\n-                    return;\n-                }\n-                // adjust the final result:\n-                // we know that this file has been successfully ingested; \n-                // so if the FileUtil is telling us it's a \"plain text\" file at this point,\n-                // it really means it must be a CSV file. \n-                if (fileTypeDetermined.startsWith(\"text/plain\")) {\n-                    fileTypeDetermined = FileUtil.MIME_TYPE_CSV;\n-                }\n-                // and, finally, if it is still \"application/octet-stream\", it must be Excel:\n-                if (FileUtil.MIME_TYPE_UNDETERMINED_DEFAULT.equals(fileTypeDetermined)) {\n-                    fileTypeDetermined = FileUtil.MIME_TYPE_XLSX;\n-                }\n-                logger.info(\"Original file type determined: \" + fileTypeDetermined + \" (file id=\" + fileId + \", datatable id=\" + datatableId + \"; file path: \" + savedOriginalFile.getAbsolutePath() + \")\");\n+        if (tabDataIngest.getDataTable() != null\n+          && tabFile != null\n+          && tabFile.exists()) {\n \n-                // save permanently in the database:\n-                dataFile.getDataTable().setOriginalFileFormat(fileTypeDetermined);\n-                dataFile.getDataTable().setOriginalFileSize(savedOriginalFileSize);\n-                fileService.saveDataTable(dataFile.getDataTable());\n+          String tabFilename = FileUtil.replaceExtension(file, \"tab\");\n \n-            } else {\n-                logger.info(\"DataFile id=\" + fileId + \"; original type already present: \" + originalFormat);\n-            }\n-        } else {\n-            logger.warning(\"DataFile id=\" + fileId + \": No such DataFile!\");\n-        }\n-    }\n-    \n-    // This method fixes a datatable object that's missing the size of the \n-    // ingested original. \n-    private void fixMissingOriginalSize(long fileId) {\n-        DataFile dataFile = fileService.find(fileId);\n-\n-        if (dataFile != null && dataFile.isTabularData()) {\n-            Long savedOriginalFileSize = dataFile.getDataTable().getOriginalFileSize();\n-            Long datatableId = dataFile.getDataTable().getId();\n-            \n-            if (savedOriginalFileSize == null) {\n-                \n-                StorageIO<DataFile> storageIO;\n-                \n-                try {\n-                    storageIO = dataFile.getStorageIO();\n-                    storageIO.open();\n-                    savedOriginalFileSize = storageIO.getAuxObjectSize(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+          Files.copy(Paths.get(tabFile.getAbsolutePath()), Paths.get(tabFilename), StandardCopyOption.REPLACE_EXISTING);\n \n-                } catch (Exception ex) {\n-                    logger.warning(\"Exception \"+ex.getClass()+\" caught trying to look up the size of the saved original; (datafile id=\" + fileId + \", datatable id=\" + datatableId + \"): \" + ex.getMessage());\n-                    return;\n-                }\n+          DataTable dataTable = tabDataIngest.getDataTable();\n \n-                if (savedOriginalFileSize == null) {\n-                    logger.warning(\"Failed to look up the size of the saved original file! (datafile id=\" + fileId + \", datatable id=\" + datatableId + \")\");\n-                    return;\n-                }\n+          System.out.println(\"NVARS: \" + dataTable.getVarQuantity());\n+          System.out.println(\"NOBS: \" + dataTable.getCaseQuantity());\n+          System.out.println(\"UNF: \" + dataTable.getUnf());\n \n-                // save permanently in the database:\n-                dataFile.getDataTable().setOriginalFileSize(savedOriginalFileSize);\n-                fileService.saveDataTable(dataFile.getDataTable());\n+          for (int i = 0; i < dataTable.getVarQuantity(); i++) {\n+            String vartype = \"\";\n \n+            if (dataTable.getDataVariables().get(i).isIntervalContinuous()) {\n+              vartype = \"numeric-continuous\";\n             } else {\n-                logger.info(\"DataFile id=\" + fileId + \"; original file size already present: \" + savedOriginalFileSize);\n+              if (dataTable.getDataVariables().get(i).isTypeNumeric()) {\n+                vartype = \"numeric-discrete\";\n+              } else {\n+                vartype = \"character\";\n+              }\n             }\n+\n+            System.out.print(\"VAR\" + i + \" \");\n+            System.out.print(dataTable.getDataVariables().get(i).getName() + \" \");\n+            System.out.print(vartype + \" \");\n+            System.out.print(dataTable.getDataVariables().get(i).getUnf());\n+            System.out.println();\n+\n+          }\n+\n         } else {\n-            logger.warning(\"DataFile id=\" + fileId + \": No such DataFile!\");\n+          System.err.println(\"Ingest failed to produce tab file or data table for file \" + file + \".\");\n+          System.exit(1);\n         }\n+      } else {\n+        System.err.println(\"Ingest resulted in a null tabDataIngest object for file \" + file + \".\");\n+        System.exit(1);\n+      }\n+    } catch (IOException ex) {\n+      System.err.println(\"Caught an exception trying to save ingested data for file \" + file + \".\");\n+      System.exit(1);\n     }\n-    \n-    public static void main(String[] args) {\n-        \n-        String file = args[0];\n-        String type = args[1]; \n-        \n-        if (file == null || type == null || \"\".equals(file) || \"\".equals(type)) {\n-            System.err.println(\"Usage: java edu.harvard.iq.dataverse.ingest.IngestServiceBean <file> <type>.\");\n-            System.exit(1);\n-        }\n-        \n-        BufferedInputStream fileInputStream = null; \n-        \n-        try {\n-            fileInputStream = new BufferedInputStream(new FileInputStream(new File(file)));\n-        } catch (FileNotFoundException notfoundEx) {\n-            fileInputStream = null; \n-        }\n-        \n-        if (fileInputStream == null) {\n-            System.err.println(\"Could not open file \"+file+\".\");\n-            System.exit(1);\n-        }\n-        \n-        TabularDataFileReader ingestPlugin = getTabDataReaderByMimeType(type);\n \n-        if (ingestPlugin == null) {\n-            System.err.println(\"Could not locate an ingest plugin for type \"+type+\".\");\n-            System.exit(1);\n-        }\n-        \n-        TabularDataIngest tabDataIngest = null;\n-        \n-        try {\n-            tabDataIngest = ingestPlugin.read(fileInputStream, null);\n-        } catch (IOException ingestEx) {\n-            System.err.println(\"Caught an exception trying to ingest file \"+file+\".\");\n-            System.exit(1);\n-        }\n-        \n-        try {\n-            if (tabDataIngest != null) {\n-                File tabFile = tabDataIngest.getTabDelimitedFile();\n-\n-                if (tabDataIngest.getDataTable() != null\n-                        && tabFile != null\n-                        && tabFile.exists()) {\n-\n-                    String tabFilename = FileUtil.replaceExtension(file, \"tab\");\n-                    \n-                    Files.copy(Paths.get(tabFile.getAbsolutePath()), Paths.get(tabFilename), StandardCopyOption.REPLACE_EXISTING);\n-                    \n-                    DataTable dataTable = tabDataIngest.getDataTable();\n-                    \n-                    System.out.println (\"NVARS: \"+dataTable.getVarQuantity());\n-                    System.out.println (\"NOBS: \"+dataTable.getCaseQuantity());\n-                    System.out.println (\"UNF: \"+dataTable.getUnf());\n-                    \n-                    for (int i = 0; i < dataTable.getVarQuantity(); i++) {\n-                        String vartype = \"\";\n-                        \n-                        if (dataTable.getDataVariables().get(i).isIntervalContinuous()) {\n-                            vartype = \"numeric-continuous\";\n-                        } else {\n-                            if (dataTable.getDataVariables().get(i).isTypeNumeric()) {\n-                                vartype = \"numeric-discrete\";\n-                            } else {\n-                                vartype = \"character\";\n-                            }\n-                        }\n-                        \n-                        System.out.print (\"VAR\"+i+\" \");\n-                        System.out.print (dataTable.getDataVariables().get(i).getName()+\" \");\n-                        System.out.print (vartype+\" \");\n-                        System.out.print (dataTable.getDataVariables().get(i).getUnf());\n-                        System.out.println(); \n-                        \n-                    }\n-                \n-                } else {\n-                    System.err.println(\"Ingest failed to produce tab file or data table for file \"+file+\".\");\n-                    System.exit(1);\n-                }\n-            } else {\n-                System.err.println(\"Ingest resulted in a null tabDataIngest object for file \"+file+\".\");\n-                System.exit(1);\n-            }\n-        } catch (IOException ex) {\n-            System.err.println(\"Caught an exception trying to save ingested data for file \"+file+\".\");\n-            System.exit(1);\n-        }\n-        \n-    }\n+  }\n     /*\n     private class InternalIngestException extends Exception {\n         \n",
            "diff_size": 2596
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/27/IngestServiceBean.java\nindex cf3c62ef584..96e95c4587b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/27/IngestServiceBean.java\n@@ -67,7 +67,6 @@ import edu.harvard.iq.dataverse.ingest.tabulardata.impl.plugins.sav.SAVFileReade\n import edu.harvard.iq.dataverse.ingest.tabulardata.impl.plugins.por.PORFileReader;\n import edu.harvard.iq.dataverse.ingest.tabulardata.impl.plugins.por.PORFileReaderSpi;\n import edu.harvard.iq.dataverse.util.*;\n-\n import org.apache.commons.io.IOUtils;\n //import edu.harvard.iq.dvn.unf.*;\n import org.dataverse.unf.*;\n@@ -121,27 +120,34 @@ import javax.faces.application.FacesMessage;\n  * New service for handling ingest tasks\n  * \n  */\n+\n+\n @Stateless\n @Named\n public class IngestServiceBean {\n+\n     private static final Logger logger = Logger.getLogger(IngestServiceBean.class.getCanonicalName());\n+\n     @EJB\n     VariableServiceBean variableService;\n-    @EJB \n+\n+    @EJB\n     DatasetServiceBean datasetService;\n+\n     @EJB\n     DatasetFieldServiceBean fieldService;\n+\n     @EJB\n-    DataFileServiceBean fileService; \n+    DataFileServiceBean fileService;\n+\n     @EJB\n     SystemConfig systemConfig;\n \n     @Resource(lookup = \"java:app/jms/queue/ingest\")\n     Queue queue;\n+\n     @Resource(lookup = \"java:app/jms/factory/ingest\")\n     QueueConnectionFactory factory;\n-    \n-\n     private static String timeFormat_hmsS = \"HH:mm:ss.SSS\";\n     private static String dateTimeFormat_ymdhmsS = \"yyyy-MM-dd HH:mm:ss.SSS\";\n     private static String dateFormat_ymd = \"yyyy-MM-dd\";\n@@ -155,286 +161,259 @@ public class IngestServiceBean {\n     // DataFileCategory objects, if any were already assigned to the files). \n     // It must be called before we attempt to permanently save the files in \n     // the database by calling the Save command on the dataset and/or version. \n-\tpublic List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n-\t\tList<DataFile> ret = new ArrayList<>();\n-\n-\t\tif (newFiles != null && newFiles.size() > 0) {\n-\t\t\t// ret = new ArrayList<>();\n-\t\t\t// final check for duplicate file names;\n-\t\t\t// we tried to make the file names unique on upload, but then\n-\t\t\t// the user may have edited them on the \"add files\" page, and\n-\t\t\t// renamed FOOBAR-1.txt back to FOOBAR.txt...\n+\n+    public List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n+        List<DataFile> ret = new ArrayList<>();\n+        if (newFiles != null && newFiles.size() > 0) {\n+            // ret = new ArrayList<>();\n+            // final check for duplicate file names;\n+            // we tried to make the file names unique on upload, but then\n+            // the user may have edited them on the \"add files\" page, and\n+            // renamed FOOBAR-1.txt back to FOOBAR.txt...\n             IngestUtil.checkForDuplicateFileNamesFinal(version, newFiles, fileToReplace);\n-\t\t\tDataset dataset = version.getDataset();\n-\n-\t\t\tfor (DataFile dataFile : newFiles) {\n-\t\t\t\tboolean unattached = false;\n-\t\t\t\tboolean savedSuccess = false;\n-\t\t\t\tif (dataFile.getOwner() == null) {\n-\t\t\t\t\tunattached = true;\n-\t\t\t\t\tdataFile.setOwner(dataset);\n-\t\t\t\t}\n-\n-\t\t\t\tString[] storageInfo = DataAccess.getDriverIdAndStorageLocation(dataFile.getStorageIdentifier());\n-\t\t\t\tString driverType = DataAccess.getDriverType(storageInfo[0]);\n-\t\t\t\tString storageLocation = storageInfo[1];\n-\t\t\t\tString tempFileLocation = null;\n-\t\t\t\tPath tempLocationPath = null;\n-\t\t\t\tif (driverType.equals(\"tmp\")) {  //\"tmp\" is the default if no prefix or the \"tmp://\" driver\n-\t\t\t\t\ttempFileLocation = FileUtil.getFilesTempDirectory() + \"/\" + storageLocation;\n-\n-\t\t\t\t\t// Try to save the file in its permanent location:\n-\t\t\t\t\ttempLocationPath = Paths.get(tempFileLocation);\n-\t\t\t\t\tWritableByteChannel writeChannel = null;\n-\t\t\t\t\tFileChannel readChannel = null;\n-\n-\t\t\t\t\tStorageIO<DataFile> dataAccess = null;\n-\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tlogger.fine(\"Attempting to create a new storageIO object for \" + storageLocation);\n-\t\t\t\t\t\tdataAccess = DataAccess.createNewStorageIO(dataFile, storageLocation);\n-\n-\t\t\t\t\t\tlogger.fine(\"Successfully created a new storageIO object.\");\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * This commented-out code demonstrates how to copy bytes from a local\n-\t\t\t\t\t\t * InputStream (or a readChannel) into the writable byte channel of a Dataverse\n-\t\t\t\t\t\t * DataAccessIO object:\n-\t\t\t\t\t\t */\n-\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * storageIO.open(DataAccessOption.WRITE_ACCESS);\n-\t\t\t\t\t\t * \n-\t\t\t\t\t\t * writeChannel = storageIO.getWriteChannel(); readChannel = new\n-\t\t\t\t\t\t * FileInputStream(tempLocationPath.toFile()).getChannel();\n-\t\t\t\t\t\t * \n-\t\t\t\t\t\t * long bytesPerIteration = 16 * 1024; // 16K bytes long start = 0; while (\n-\t\t\t\t\t\t * start < readChannel.size() ) { readChannel.transferTo(start,\n-\t\t\t\t\t\t * bytesPerIteration, writeChannel); start += bytesPerIteration; }\n-\t\t\t\t\t\t */\n-\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * But it's easier to use this convenience method from the DataAccessIO:\n-\t\t\t\t\t\t * \n-\t\t\t\t\t\t * (if the underlying storage method for this file is local filesystem, the\n-\t\t\t\t\t\t * DataAccessIO will simply copy the file using Files.copy, like this:\n-\t\t\t\t\t\t * \n-\t\t\t\t\t\t * Files.copy(tempLocationPath, storageIO.getFileSystemLocation(),\n-\t\t\t\t\t\t * StandardCopyOption.REPLACE_EXISTING);\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tdataAccess.savePath(tempLocationPath);\n-\n-\t\t\t\t\t\t// Set filesize in bytes\n-\t\t\t\t\t\t//\n-\t\t\t\t\t\tdataFile.setFilesize(dataAccess.getSize());\n-\t\t\t\t\t\tsavedSuccess = true;\n-\t\t\t\t\t\tlogger.fine(\"Success: permanently saved file \" + dataFile.getFileMetadata().getLabel());\n-\n-\t\t\t\t\t} catch (IOException ioex) {\n-                    logger.warning(\"Failed to save the file, storage id \" + dataFile.getStorageIdentifier() + \" (\" + ioex.getMessage() + \")\");\n-\t\t\t\t\t} finally {\n-\t\t\t\t\t\tif (readChannel != null) {\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\treadChannel.close();\n-\t\t\t\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (writeChannel != null) {\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\twriteChannel.close();\n-\t\t\t\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+            Dataset dataset = version.getDataset();\n+            for (DataFile dataFile : newFiles) {\n+                boolean unattached = false;\n+                boolean savedSuccess = false;\n+                if (dataFile.getOwner() == null) {\n+                    unattached = true;\n+                    dataFile.setOwner(dataset);\n+                }\n+\n+                String[] storageInfo = DataAccess.getDriverIdAndStorageLocation(dataFile.getStorageIdentifier());\n+                String driverType = DataAccess.getDriverType(storageInfo[0]);\n+                String storageLocation = storageInfo[1];\n+                String tempFileLocation = null;\n+                Path tempLocationPath = null;\n+                if (driverType.equals(\"tmp\")) {  //\"tmp\" is the default if no prefix or the \"tmp://\" driver\n+                    tempFileLocation = FileUtil.getFilesTempDirectory() + \"/\" + storageLocation;\n+\n+                    // Try to save the file in its permanent location:\n+                    tempLocationPath = Paths.get(tempFileLocation);\n+                    WritableByteChannel writeChannel = null;\n+                    FileChannel readChannel = null;\n+                    StorageIO<DataFile> dataAccess = null;\n+                    try {\n+                        logger.fine(\"Attempting to create a new storageIO object for \" + storageLocation);\n+                        dataAccess = DataAccess.createNewStorageIO(dataFile, storageLocation);\n+                        logger.fine(\"Successfully created a new storageIO object.\");\n+                        /*\n+                         * This commented-out code demonstrates how to copy bytes from a local\n+                         * InputStream (or a readChannel) into the writable byte channel of a Dataverse\n+                         * DataAccessIO object:\n+                         */\n+\n+                        /*\n+                         * storageIO.open(DataAccessOption.WRITE_ACCESS);\n+                         * \n+                         * writeChannel = storageIO.getWriteChannel(); readChannel = new\n+                         * FileInputStream(tempLocationPath.toFile()).getChannel();\n+                         * \n+                         * long bytesPerIteration = 16 * 1024; // 16K bytes long start = 0; while (\n+                         * start < readChannel.size() ) { readChannel.transferTo(start,\n+                         * bytesPerIteration, writeChannel); start += bytesPerIteration; }\n+                         */\n+\n+                        /*\n+                         * But it's easier to use this convenience method from the DataAccessIO:\n+                         * \n+                         * (if the underlying storage method for this file is local filesystem, the\n+                         * DataAccessIO will simply copy the file using Files.copy, like this:\n+                         * \n+                         * Files.copy(tempLocationPath, storageIO.getFileSystemLocation(),\n+                         * StandardCopyOption.REPLACE_EXISTING);\n+                         */\n+                        dataAccess.savePath(tempLocationPath);\n+\n+                        // Set filesize in bytes\n+                        //\n+                        dataFile.setFilesize(dataAccess.getSize());\n+                        savedSuccess = true;\n+                        logger.fine(\"Success: permanently saved file \" + dataFile.getFileMetadata().getLabel());\n+                    } catch (IOException ioex) {\n+                        logger.warning(\"Failed to save the file, storage id \" + dataFile.getStorageIdentifier() + \" (\" + ioex.getMessage() + \")\");\n+                    } finally {\n+                        if (readChannel != null) {\n+                            try {\n+                                readChannel.close();\n+                            } catch (IOException e) {}\n+                        }\n+\n+                        if (writeChannel != null) {\n+                            try {\n+                                writeChannel.close();\n+                            } catch (IOException e) {}\n+                        }\n+                    }\n \n                     // Since we may have already spent some CPU cycles scaling down image thumbnails, \n-\t\t\t\t\t// we may as well save them, by moving these generated images to the permanent\n-\t\t\t\t\t// dataset directory. We should also remember to delete any such files in the\n-\t\t\t\t\t// temp directory:\n-\t\t\t\t\tList<Path> generatedTempFiles = listGeneratedTempFiles(Paths.get(FileUtil.getFilesTempDirectory()),\n-\t\t\t\t\t\t\tstorageLocation);\n-\t\t\t\t\tif (generatedTempFiles != null) {\n-\t\t\t\t\t\tfor (Path generated : generatedTempFiles) {\n-\t\t\t\t\t\t\tif (savedSuccess) { // no need to try to save this aux file permanently, if we've failed to\n-\t\t\t\t\t\t\t\t\t\t\t\t// save the main file!\n-\t\t\t\t\t\t\t\tlogger.fine(\"(Will also try to permanently save generated thumbnail file \"\n-\t\t\t\t\t\t\t\t\t\t+ generated.toString() + \")\");\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t// Files.copy(generated, Paths.get(dataset.getFileSystemDirectory().toString(),\n-\t\t\t\t\t\t\t\t\t// generated.getFileName().toString()));\n-\t\t\t\t\t\t\t\t\tint i = generated.toString().lastIndexOf(\"thumb\");\n-\t\t\t\t\t\t\t\t\tif (i > 1) {\n-\t\t\t\t\t\t\t\t\t\tString extensionTag = generated.toString().substring(i);\n-\t\t\t\t\t\t\t\t\t\tdataAccess.savePathAsAux(generated, extensionTag);\n-\t\t\t\t\t\t\t\t\t\tlogger.fine(\n-\t\t\t\t\t\t\t\t\t\t\t\t\"Saved generated thumbnail as aux object. \\\"preview available\\\" status: \"\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ dataFile.isPreviewImageAvailable());\n-\t\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t\tlogger.warning(\n-\t\t\t\t\t\t\t\t\t\t\t\t\"Generated thumbnail file name does not match the expected pattern: \"\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ generated.toString());\n-\t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t} catch (IOException ioex) {\n-\t\t\t\t\t\t\t\t\tlogger.warning(\"Failed to save generated file \" + generated.toString());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t// ... but we definitely want to delete it:\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tFiles.delete(generated);\n-\t\t\t\t\t\t\t} catch (IOException ioex) {\n-\t\t\t\t\t\t\t\tlogger.warning(\"Failed to delete generated file \" + generated.toString());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif (unattached) {\n-\t\t\t\t\t\tdataFile.setOwner(null);\n-\t\t\t\t\t}\n-\t\t\t\t\t// Any necessary post-processing:\n-\t\t\t\t\t// performPostProcessingTasks(dataFile);\n-\t\t\t\t} else {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tStorageIO<DvObject> dataAccess = DataAccess.getStorageIO(dataFile);\n-\t\t\t\t\t\t//Populate metadata\n-\t\t\t\t\t\tdataAccess.open(DataAccessOption.READ_ACCESS);\n-\t\t\t\t\t\t//set file size\n-\t\t\t\t\t\tdataFile.setFilesize(dataAccess.getSize());\n-\t\t\t\t\t\tif(dataAccess instanceof S3AccessIO) {\n-\t\t\t\t\t\t\t  ((S3AccessIO<DvObject>)dataAccess).removeTempTag();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (IOException ioex) {\n-\t\t\t\t\t\tlogger.warning(\"Failed to get file size, storage id \" + dataFile.getStorageIdentifier() + \" (\"\n-\t\t\t\t\t\t\t\t+ ioex.getMessage() + \")\");\n-\t\t\t\t\t}\n-\t\t\t\t\tsavedSuccess = true;\n-\t\t\t\t\tdataFile.setOwner(null);\n-\t\t\t\t}\n-\n-\t\t\t\tlogger.fine(\"Done! Finished saving new files in permanent storage and adding them to the dataset.\");\n-\t\t\t\tboolean belowLimit = false;\n-\n-\t\t\t\ttry {\n-\t\t\t\t\tbelowLimit = dataFile.getStorageIO().isBelowIngestSizeLimit();\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tlogger.warning(\"Error getting ingest limit for file: \" + dataFile.getIdentifier() + \" : \" + e.getMessage());\n-\t\t\t\t} \n-\n-\t\t\t\tif (savedSuccess && belowLimit) {\n-\t\t\t\t\t// These are all brand new files, so they should all have\n-\t\t\t\t\t// one filemetadata total. -- L.A.\n-\t\t\t\t\tFileMetadata fileMetadata = dataFile.getFileMetadatas().get(0);\n-\t\t\t\t\tString fileName = fileMetadata.getLabel();\n-\n-\t\t\t\t\tboolean metadataExtracted = false;\n-\t\t\t\t\tif (FileUtil.canIngestAsTabular(dataFile)) {\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * Note that we don't try to ingest the file right away - instead we mark it as\n-\t\t\t\t\t\t * \"scheduled for ingest\", then at the end of the save process it will be queued\n-\t\t\t\t\t\t * for async. ingest in the background. In the meantime, the file will be\n-\t\t\t\t\t\t * ingested as a regular, non-tabular file, and appear as such to the user,\n-\t\t\t\t\t\t * until the ingest job is finished with the Ingest Service.\n-\t\t\t\t\t\t */\n-\t\t\t\t\t\tdataFile.SetIngestScheduled();\n-\t\t\t\t\t} else if (fileMetadataExtractable(dataFile)) {\n-\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// FITS is the only type supported for metadata\n-\t\t\t\t\t\t\t// extraction, as of now. -- L.A. 4.0\n-\t\t\t\t\t\t\tdataFile.setContentType(\"application/fits\");\n-\t\t\t\t\t\t\tmetadataExtracted = extractMetadata(tempFileLocation, dataFile, version);\n-\t\t\t\t\t\t} catch (IOException mex) {\n-\t\t\t\t\t\t\tlogger.severe(\"Caught exception trying to extract indexable metadata from file \"\n-\t\t\t\t\t\t\t\t\t+ fileName + \",  \" + mex.getMessage());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (metadataExtracted) {\n-\t\t\t\t\t\t\tlogger.fine(\"Successfully extracted indexable metadata from file \" + fileName);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tlogger.fine(\"Failed to extract indexable metadata from file \" + fileName);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else if (FileUtil.MIME_TYPE_INGESTED_FILE.equals(dataFile.getContentType())) {\n+                    // we may as well save them, by moving these generated images to the permanent\n+                    // dataset directory. We should also remember to delete any such files in the\n+                    // temp directory:\n+\n+                    List<Path> generatedTempFiles = listGeneratedTempFiles(Paths.get(FileUtil.getFilesTempDirectory()), storageLocation);\n+                    if (generatedTempFiles != null) {\n+                        for (Path generated : generatedTempFiles) {\n+                            if (savedSuccess) { // no need to try to save this aux file permanently, if we've failed to\n+                                                // save the main file!\n+                                logger.fine(\"(Will also try to permanently save generated thumbnail file \" + generated.toString() + \")\");\n+                                try {\n+                                    // Files.copy(generated, Paths.get(dataset.getFileSystemDirectory().toString(),\n+                                    // generated.getFileName().toString()));\n+                                    int i = generated.toString().lastIndexOf(\"thumb\");\n+                                    if (i > 1) {\n+                                        String extensionTag = generated.toString().substring(i);\n+                                        dataAccess.savePathAsAux(generated, extensionTag);\n+                                        logger.fine(\"Saved generated thumbnail as aux object. \\\"preview available\\\" status: \" + dataFile.isPreviewImageAvailable());\n+                                    } else {\n+                                        logger.warning(\"Generated thumbnail file name does not match the expected pattern: \" + generated.toString());\n+                                    }\n+                                } catch (IOException ioex) {\n+                                    logger.warning(\"Failed to save generated file \" + generated.toString());\n+                                }\n+                            }\n+\n+                            // ... but we definitely want to delete it:\n+                            try {\n+                                Files.delete(generated);\n+                            } catch (IOException ioex) {\n+                                logger.warning(\"Failed to delete generated file \" + generated.toString());\n+                            }\n+                        }\n+                    }\n+\n+                    if (unattached) {\n+                        dataFile.setOwner(null);\n+                    }\n+                    // Any necessary post-processing:\n+                    // performPostProcessingTasks(dataFile);\n+                } else {\n+                    try {\n+                        StorageIO<DvObject> dataAccess = DataAccess.getStorageIO(dataFile);\n+                        //Populate metadata\n+                        dataAccess.open(DataAccessOption.READ_ACCESS);\n+                        //set file size\n+                        dataFile.setFilesize(dataAccess.getSize());\n+                        if (dataAccess instanceof S3AccessIO) {\n+                            ((S3AccessIO<DvObject>) dataAccess).removeTempTag();\n+                        }\n+                    } catch (IOException ioex) {\n+                        logger.warning(\"Failed to get file size, storage id \" + dataFile.getStorageIdentifier() + \" (\" + ioex.getMessage() + \")\");\n+                    }\n+                    savedSuccess = true;\n+                    dataFile.setOwner(null);\n+                }\n+                logger.fine(\"Done! Finished saving new files in permanent storage and adding them to the dataset.\");\n+                boolean belowLimit = false;\n+                try {\n+                    belowLimit = dataFile.getStorageIO().isBelowIngestSizeLimit();\n+                } catch (IOException e) {\n+                    logger.warning(\"Error getting ingest limit for file: \" + dataFile.getIdentifier() + \" : \" + e.getMessage());\n+                }\n+\n+                if (savedSuccess && belowLimit) {\n+                    // These are all brand new files, so they should all have\n+                    // one filemetadata total. -- L.A.\n+                    FileMetadata fileMetadata = dataFile.getFileMetadatas().get(0);\n+                    String fileName = fileMetadata.getLabel();\n+                    boolean metadataExtracted = false;\n+                    if (FileUtil.canIngestAsTabular(dataFile)) {\n+                        /*\n+                         * Note that we don't try to ingest the file right away - instead we mark it as\n+                         * \"scheduled for ingest\", then at the end of the save process it will be queued\n+                         * for async. ingest in the background. In the meantime, the file will be\n+                         * ingested as a regular, non-tabular file, and appear as such to the user,\n+                         * until the ingest job is finished with the Ingest Service.\n+                         */\n+                        dataFile.SetIngestScheduled();\n+                    } else if (fileMetadataExtractable(dataFile)) {\n+                        try {\n+                            // FITS is the only type supported for metadata\n+                            // extraction, as of now. -- L.A. 4.0\n+                            dataFile.setContentType(\"application/fits\");\n+                            metadataExtracted = extractMetadata(tempFileLocation, dataFile, version);\n+                        } catch (IOException mex) {\n+                            logger.severe(\"Caught exception trying to extract indexable metadata from file \" + fileName + \",  \" + mex.getMessage());\n+                        }\n+\n+                        if (metadataExtracted) {\n+                            logger.fine(\"Successfully extracted indexable metadata from file \" + fileName);\n+                        } else {\n+                            logger.fine(\"Failed to extract indexable metadata from file \" + fileName);\n+                        }\n+                    } else if (FileUtil.MIME_TYPE_INGESTED_FILE.equals(dataFile.getContentType())) {\n                         // Make sure no *uningested* tab-delimited files are saved with the type \"text/tab-separated-values\"!\n                         // \"text/tsv\" should be used instead: \n-                        dataFile.setContentType(FileUtil.MIME_TYPE_TSV);\n+                               dataFile.setContentType(FileUtil.MIME_TYPE_TSV);\n+                           }\n+                }\n+                // ... and let's delete the main temp file if it exists:\n+\n+                if (tempLocationPath != null) {\n+                    try {\n+                        logger.fine(\"Will attempt to delete the temp file \" + tempLocationPath.toString());\n+                        Files.delete(tempLocationPath);\n+                    } catch (IOException ex) {\n+                        // (non-fatal - it's just a temp file.)\n+                        logger.warning(\"Failed to delete temp file \" + tempLocationPath.toString());\n                     }\n-\t\t\t\t}\n-\t\t\t\t// ... and let's delete the main temp file if it exists:\n-\t\t\t\tif(tempLocationPath!=null) {\n-    \t\t\t\ttry {\n-\t    \t\t\t\tlogger.fine(\"Will attempt to delete the temp file \" + tempLocationPath.toString());\n-\t\t\t    \t\tFiles.delete(tempLocationPath);\n-\t\t\t\t    } catch (IOException ex) {\n-\t\t\t\t\t    // (non-fatal - it's just a temp file.)\n-    \t\t\t\t\tlogger.warning(\"Failed to delete temp file \" + tempLocationPath.toString());\n-\t    \t\t\t}\t\t\t\t\n-\t\t\t\t}\n-\t\t\t\tif (savedSuccess) {\n-\t\t\t\t\t// temp dbug line\n-\t\t\t\t\t// System.out.println(\"ADDING FILE: \" + fileName + \"; for dataset: \" +\n-\t\t\t\t\t// dataset.getGlobalId());\n-\t\t\t\t\t// Make sure the file is attached to the dataset and to the version, if this\n-\t\t\t\t\t// hasn't been done yet:\n-\t\t\t\t\tif (dataFile.getOwner() == null) {\n-\t\t\t\t\t\tdataFile.setOwner(dataset);\n-\n-\t\t\t\t\t\tversion.getFileMetadatas().add(dataFile.getFileMetadata());\n-\t\t\t\t\t\tdataFile.getFileMetadata().setDatasetVersion(version);\n-\t\t\t\t\t\tdataset.getFiles().add(dataFile);\n-\n-\t\t\t\t\t\tif (dataFile.getFileMetadata().getCategories() != null) {\n-\t\t\t\t\t\t\tListIterator<DataFileCategory> dfcIt = dataFile.getFileMetadata().getCategories()\n-\t\t\t\t\t\t\t\t\t.listIterator();\n-\n-\t\t\t\t\t\t\twhile (dfcIt.hasNext()) {\n-\t\t\t\t\t\t\t\tDataFileCategory dataFileCategory = dfcIt.next();\n-\n-\t\t\t\t\t\t\t\tif (dataFileCategory.getDataset() == null) {\n-\t\t\t\t\t\t\t\t\tDataFileCategory newCategory = dataset\n-\t\t\t\t\t\t\t\t\t\t\t.getCategoryByName(dataFileCategory.getName());\n-\t\t\t\t\t\t\t\t\tif (newCategory != null) {\n-\t\t\t\t\t\t\t\t\t\tnewCategory.addFileMetadata(dataFile.getFileMetadata());\n-\t\t\t\t\t\t\t\t\t\t// dataFileCategory = newCategory;\n-\t\t\t\t\t\t\t\t\t\tdfcIt.set(newCategory);\n-\t\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t\tdfcIt.remove();\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tret.add(dataFile);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn ret;\n-\t}\n-    \n+                }\n+\n+                if (savedSuccess) {\n+                    // temp dbug line\n+                    // System.out.println(\"ADDING FILE: \" + fileName + \"; for dataset: \" +\n+                    // dataset.getGlobalId());\n+                    // Make sure the file is attached to the dataset and to the version, if this\n+                    // hasn't been done yet:\n+                    if (dataFile.getOwner() == null) {\n+                        dataFile.setOwner(dataset);\n+                        version.getFileMetadatas().add(dataFile.getFileMetadata());\n+                        dataFile.getFileMetadata().setDatasetVersion(version);\n+                        dataset.getFiles().add(dataFile);\n+                        if (dataFile.getFileMetadata().getCategories() != null) {\n+                            ListIterator<DataFileCategory> dfcIt = dataFile.getFileMetadata().getCategories().listIterator();\n+                            while (dfcIt.hasNext()) {\n+                                DataFileCategory dataFileCategory = dfcIt.next();\n+                                if (dataFileCategory.getDataset() == null) {\n+                                    DataFileCategory newCategory = dataset.getCategoryByName(dataFileCategory.getName());\n+                                    if (newCategory != null) {\n+                                        newCategory.addFileMetadata(dataFile.getFileMetadata());\n+                                        // dataFileCategory = newCategory;\n+                                        dfcIt.set(newCategory);\n+                                    } else {\n+                                        dfcIt.remove();\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                ret.add(dataFile);\n+            }\n+        }\n+        return ret;\n+    }\n+\n     public List<Path> listGeneratedTempFiles(Path tempDirectory, String baseName) {\n         List<Path> generatedFiles = new ArrayList<>();\n \n         // for example, <filename>.thumb64 or <filename>.thumb400.\n-\n         if (baseName == null || baseName.equals(\"\")) {\n             return null;\n         }\n \n         DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() {\n+\n             @Override\n             public boolean accept(Path file) throws IOException {\n-                return (file.getFileName() != null\n-                        && file.getFileName().toString().startsWith(baseName + \".thumb\"));\n+                return (file.getFileName() != null && file.getFileName().toString().startsWith(baseName + \".thumb\"));\n             }\n         };\n-\n         try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(tempDirectory, filter)) {\n             for (Path filePath : dirStream) {\n                 generatedFiles.add(filePath);\n             }\n-        } catch (IOException ex) {\n-        }\n-\n+        } catch (IOException ex) {}\n         return generatedFiles;\n     }\n     \n@@ -444,9 +423,9 @@ public class IngestServiceBean {\n     // TODO: consider creating a version of this method that would take \n     // datasetversion as the argument. \n     // -- L.A. 4.6\n+\n     public void startIngestJobsForDataset(Dataset dataset, AuthenticatedUser user) {\n         List<DataFile> scheduledFiles = new ArrayList<>();\n-                \n         for (DataFile dataFile : dataset.getFiles()) {\n             if (dataFile.isIngestScheduled()) {\n                 // todo: investigate why when calling save with the file object\n@@ -456,22 +435,17 @@ public class IngestServiceBean {\n                 scheduledFiles.add(dataFile);\n             }\n         }\n-\n         startIngestJobs(scheduledFiles, user);\n     }\n-    \n-    public String startIngestJobs(List<DataFile> dataFiles, AuthenticatedUser user) {\n \n+    public String startIngestJobs(List<DataFile> dataFiles, AuthenticatedUser user) {\n         IngestMessage ingestMessage = null;\n         StringBuilder sb = new StringBuilder();\n-\n         List<DataFile> scheduledFiles = new ArrayList<>();\n         for (DataFile dataFile : dataFiles) {\n             // refresh the copy of the DataFile:\n             dataFile = fileService.find(dataFile.getId());\n-            \n             if (dataFile.isIngestScheduled()) {\n-\n                 long ingestSizeLimit = 0;\n                 try {\n                     ingestSizeLimit = systemConfig.getTabularIngestSizeLimit(getTabDataReaderByMimeType(dataFile.getContentType()).getFormatName());\n@@ -497,20 +471,19 @@ public class IngestServiceBean {\n         }\n \n         int count = scheduledFiles.size();\n-        \n         if (count > 0) {\n             String info = \"Ingest of \" + count + \" tabular data file(s) is in progress.\";\n             logger.info(info);\n             datasetService.addDatasetLock(scheduledFiles.get(0).getOwner().getId(),\n-                    DatasetLock.Reason.Ingest,\n-                    (user != null) ? user.getId() : null,\n-                    info);\n+DatasetLock.Reason.Ingest,\n+(user != null) ? user.getId() : null,\n+info);\n             \n             // Sort ingest jobs by file size: \n-            DataFile[] scheduledFilesArray = (DataFile[])scheduledFiles.toArray(new DataFile[count]);\n-            scheduledFiles = null; \n-            \n+            DataFile[] scheduledFilesArray = (DataFile[]) scheduledFiles.toArray(new DataFile[count]);\n+            scheduledFiles = null;\n             Arrays.sort(scheduledFilesArray, new Comparator<DataFile>() {\n+\n                 @Override\n                 public int compare(DataFile d1, DataFile d2) {\n                     long a = d1.getFilesize();\n@@ -518,8 +491,8 @@ public class IngestServiceBean {\n                     return Long.valueOf(a).compareTo(b);\n                 }\n             });\n-\n             ingestMessage = new IngestMessage(IngestMessage.INGEST_MESAGE_LEVEL_INFO, user.getId());\n+\n             for (int i = 0; i < count; i++) {\n                 ingestMessage.addFileId(scheduledFilesArray[i].getId());\n             }\n@@ -527,29 +500,26 @@ public class IngestServiceBean {\n             QueueConnection conn = null;\n             QueueSession session = null;\n             QueueSender sender = null;\n-\n             try {\n                 conn = factory.createQueueConnection();\n                 session = conn.createQueueSession(false, 0);\n                 sender = session.createSender(queue);\n-\n                 Message queueMessage = session.createObjectMessage(ingestMessage);\n-\n                 sender.send(queueMessage);\n-\n             } catch (JMSException ex) {\n                 ex.printStackTrace();\n                 logger.warning(\"Caught exception trying to close connections after starting a (re)ingest job in the JMS queue! Stack trace below.\");\n                 sb.append(\"Failed to queue the (re)ingest job for DataFile (JMS Exception)\" + (ex.getMessage() != null ? ex.getMessage() : \"\"));\n             } finally {\n                 try {\n-\n                     if (sender != null) {\n                         sender.close();\n                     }\n+\n                     if (session != null) {\n                         session.close();\n                     }\n+\n                     if (conn != null) {\n                         conn.close();\n                     }\n@@ -559,23 +529,20 @@ public class IngestServiceBean {\n                 }\n             }\n         }\n-        \n         return sb.toString();\n     }\n \n-    \n     public void produceSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n         /*\n         logger.info(\"Skipping summary statistics and UNF.\");\n          */\n-        produceDiscreteNumericSummaryStatistics(dataFile, generatedTabularFile); \n+        produceDiscreteNumericSummaryStatistics(dataFile, generatedTabularFile);\n         produceContinuousSummaryStatistics(dataFile, generatedTabularFile);\n         produceCharacterSummaryStatistics(dataFile, generatedTabularFile);\n-        \n         recalculateDataFileUNF(dataFile);\n         recalculateDatasetVersionUNF(dataFile.getFileMetadata().getDatasetVersion());\n     }\n-    \n+\n     public void produceContinuousSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n \n         /* \n@@ -591,11 +558,9 @@ public class IngestServiceBean {\n         \n         TabularSubsetGenerator subsetGenerator = new TabularSubsetGenerator();\n         */\n-        \n         for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n             if (dataFile.getDataTable().getDataVariables().get(i).isIntervalContinuous()) {\n                 logger.fine(\"subsetting continuous vector\");\n-\n                 if (\"float\".equals(dataFile.getDataTable().getDataVariables().get(i).getFormat())) {\n                     Float[] variableVector = TabularSubsetGenerator.subsetFloatVector(new FileInputStream(generatedTabularFile), i, dataFile.getDataTable().getCaseQuantity().intValue());\n                     logger.fine(\"Calculating summary statistics on a Float vector;\");\n@@ -603,7 +568,7 @@ public class IngestServiceBean {\n                     // calculate the UNF while we are at it:\n                     logger.fine(\"Calculating UNF on a Float vector;\");\n                     calculateUNF(dataFile, i, variableVector);\n-                    variableVector = null; \n+                    variableVector = null;\n                 } else {\n                     Double[] variableVector = TabularSubsetGenerator.subsetDoubleVector(new FileInputStream(generatedTabularFile), i, dataFile.getDataTable().getCaseQuantity().intValue());\n                     logger.fine(\"Calculating summary statistics on a Double vector;\");\n@@ -611,22 +576,19 @@ public class IngestServiceBean {\n                     // calculate the UNF while we are at it:\n                     logger.fine(\"Calculating UNF on a Double vector;\");\n                     calculateUNF(dataFile, i, variableVector);\n-                    variableVector = null; \n+                    variableVector = null;\n                 }\n                 logger.fine(\"Done! (continuous);\");\n             }\n         }\n     }\n-    \n+\n     public void produceDiscreteNumericSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n         \n         //TabularSubsetGenerator subsetGenerator = new TabularSubsetGenerator();\n-        \n         for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n-            if (dataFile.getDataTable().getDataVariables().get(i).isIntervalDiscrete()\n-                    && dataFile.getDataTable().getDataVariables().get(i).isTypeNumeric()) {\n+            if (dataFile.getDataTable().getDataVariables().get(i).isIntervalDiscrete() && dataFile.getDataTable().getDataVariables().get(i).isTypeNumeric()) {\n                 logger.fine(\"subsetting discrete-numeric vector\");\n-\n                 Long[] variableVector = TabularSubsetGenerator.subsetLongVector(new FileInputStream(generatedTabularFile), i, dataFile.getDataTable().getCaseQuantity().intValue());\n                 // We are discussing calculating the same summary stats for \n                 // all numerics (the same kind of sumstats that we've been calculating\n@@ -636,11 +598,11 @@ public class IngestServiceBean {\n                 logger.fine(\"Calculating UNF on a Long vector\");\n                 calculateUNF(dataFile, i, variableVector);\n                 logger.fine(\"Done! (discrete numeric)\");\n-                variableVector = null; \n+                variableVector = null;\n             }\n         }\n     }\n-    \n+\n     public void produceCharacterSummaryStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n \n         /* \n@@ -656,10 +618,8 @@ public class IngestServiceBean {\n         \n         TabularSubsetGenerator subsetGenerator = new TabularSubsetGenerator();\n         */\n-        \n         for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n             if (dataFile.getDataTable().getDataVariables().get(i).isTypeCharacter()) {\n-\n                 logger.fine(\"subsetting character vector\");\n                 String[] variableVector = TabularSubsetGenerator.subsetStringVector(new FileInputStream(generatedTabularFile), i, dataFile.getDataTable().getCaseQuantity().intValue());\n                 //calculateCharacterSummaryStatistics(dataFile, i, variableVector);\n@@ -667,22 +627,18 @@ public class IngestServiceBean {\n                 logger.fine(\"Calculating UNF on a String vector\");\n                 calculateUNF(dataFile, i, variableVector);\n                 logger.fine(\"Done! (character)\");\n-                variableVector = null; \n+                variableVector = null;\n             }\n         }\n     }\n \n     public static void produceFrequencyStatistics(DataFile dataFile, File generatedTabularFile) throws IOException {\n-\n         List<DataVariable> vars = dataFile.getDataTable().getDataVariables();\n-\n         produceFrequencies(generatedTabularFile, vars);\n     }\n \n-    public static void produceFrequencies( File generatedTabularFile, List<DataVariable> vars) throws IOException {\n-\n+    public static void produceFrequencies(File generatedTabularFile, List<DataVariable> vars) throws IOException {\n         for (int i = 0; i < vars.size(); i++) {\n-\n             Collection<VariableCategory> cats = vars.get(i).getCategories();\n             int caseQuantity = vars.get(i).getDataTable().getCaseQuantity().intValue();\n             boolean isNumeric = vars.get(i).isTypeNumeric();\n@@ -690,10 +646,10 @@ public class IngestServiceBean {\n             if (cats.size() > 0) {\n                 if (isNumeric) {\n                     variableVector = TabularSubsetGenerator.subsetFloatVector(new FileInputStream(generatedTabularFile), i, caseQuantity);\n-                }\n-                else {\n+                } else {\n                     variableVector = TabularSubsetGenerator.subsetStringVector(new FileInputStream(generatedTabularFile), i, caseQuantity);\n                 }\n+\n                 if (variableVector != null) {\n                     Hashtable<Object, Double> freq = calculateFrequency(variableVector);\n                     for (VariableCategory cat : cats) {\n@@ -703,6 +659,7 @@ public class IngestServiceBean {\n                         } else {\n                             catValue = cat.getValue();\n                         }\n+\n                         Double numberFreq = freq.get(catValue);\n                         if (numberFreq != null) {\n                             cat.setFrequency(numberFreq);\n@@ -717,9 +674,8 @@ public class IngestServiceBean {\n         }\n     }\n \n-    public static Hashtable<Object, Double> calculateFrequency( Object[] variableVector) {\n+    public static Hashtable<Object, Double> calculateFrequency(Object[] variableVector) {\n         Hashtable<Object, Double> freq = new Hashtable<Object, Double>();\n-\n         for (int j = 0; j < variableVector.length; j++) {\n             if (variableVector[j] != null) {\n                 Double freqNum = freq.get(variableVector[j]);\n@@ -730,28 +686,24 @@ public class IngestServiceBean {\n                 }\n             }\n         }\n-\n         return freq;\n-\n     }\n-    \n+\n     public void recalculateDataFileUNF(DataFile dataFile) {\n         String[] unfValues = new String[dataFile.getDataTable().getVarQuantity().intValue()];\n-        String fileUnfValue = null; \n-        \n+        String fileUnfValue = null;\n         for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n             String varunf = dataFile.getDataTable().getDataVariables().get(i).getUnf();\n-            unfValues[i] = varunf; \n+            unfValues[i] = varunf;\n         }\n-        \n         try {\n             fileUnfValue = UNFUtil.calculateUNF(unfValues);\n         } catch (IOException ex) {\n-            logger.warning(\"Failed to recalculate the UNF for the datafile id=\"+dataFile.getId());\n+            logger.warning(\"Failed to recalculate the UNF for the datafile id=\" + dataFile.getId());\n         } catch (UnfException uex) {\n-                logger.warning(\"UNF Exception: Failed to recalculate the UNF for the dataset version id=\"+dataFile.getId());\n+            logger.warning(\"UNF Exception: Failed to recalculate the UNF for the dataset version id=\" + dataFile.getId());\n         }\n-        \n+\n         if (fileUnfValue != null) {\n             dataFile.getDataTable().setUnf(fileUnfValue);\n         }\n@@ -768,8 +720,7 @@ public class IngestServiceBean {\n             pushContext.push(\"/ingest\" + dataset_id, facesMessage);\n         */\n     }\n-    \n-    \n+\n     public boolean ingestAsTabular(Long datafile_id) {\n         DataFile dataFile = fileService.find(datafile_id);\n         boolean ingestSuccessful = false;\n@@ -777,13 +728,14 @@ public class IngestServiceBean {\n         \n         // Never attempt to ingest a file that's already ingested!\n         if (dataFile.isTabularData()) {\n-            FileUtil.createIngestFailureReport(dataFile, \"Repeated ingest attempted on a tabular data file! (status flag was: \"+dataFile.getIngestStatus());\n+            FileUtil.createIngestFailureReport(dataFile,\n+                                               \"Repeated ingest attempted on a tabular data file! (status flag was: \" + dataFile.getIngestStatus());\n             dataFile.setIngestDone();\n             dataFile = fileService.save(dataFile);\n-            logger.warning(\"Repeated ingest attempted on a tabular data file (datafile id \"+datafile_id+\"); exiting.\");\n+            logger.warning(\"Repeated ingest attempted on a tabular data file (datafile id \" + datafile_id + \"); exiting.\");\n             return false;\n         }\n-        \n+\n         IngestRequest ingestRequest = dataFile.getIngestRequest();\n         if (ingestRequest != null) {\n             forceTypeCheck = ingestRequest.isForceTypeCheck();\n@@ -791,89 +743,78 @@ public class IngestServiceBean {\n \n         // Locate ingest plugin for the file format by looking\n         // it up with the Ingest Service Provider Registry:\n+\n         String fileName = dataFile.getFileMetadata().getLabel();\n         TabularDataFileReader ingestPlugin = getTabDataReaderByMimeType(dataFile.getContentType());\n         logger.fine(\"Found ingest plugin \" + ingestPlugin.getClass());\n-        \n         if (!forceTypeCheck && ingestPlugin == null) {\n             // If this is a reingest request, we'll still have a chance\n             // to find an ingest plugin for this file, once we try\n             // to identify the file type again.\n             // Otherwise, we can give up - there is no point in proceeding to \n             // the next step if no ingest plugin is available. \n-            \n             dataFile.SetIngestProblem();\n-            FileUtil.createIngestFailureReport(dataFile, \"No ingest plugin found for file type \"+dataFile.getContentType());\n+            FileUtil.createIngestFailureReport(dataFile, \"No ingest plugin found for file type \" + dataFile.getContentType());\n             dataFile = fileService.save(dataFile);\n             logger.warning(\"Ingest failure.\");\n-            return false; \n+            return false;\n         }\n \n-        BufferedInputStream inputStream = null; \n+        BufferedInputStream inputStream = null;\n         File additionalData = null;\n         File localFile = null;\n         StorageIO<DataFile> storageIO = null;\n-                \n         try {\n             storageIO = dataFile.getStorageIO();\n             storageIO.open();\n-             \n             if (storageIO.isLocalFile()) {\n                 localFile = storageIO.getFileSystemPath().toFile();\n                 inputStream = new BufferedInputStream(storageIO.getInputStream());\n             } else {\n-                \n                 localFile = File.createTempFile(\"tempIngestSourceFile\", \".tmp\");\n-\t\t\t\ttry (ReadableByteChannel dataFileChannel = storageIO.getReadChannel();\n-\t\t\t\t\t\tFileChannel tempIngestSourceChannel = new FileOutputStream(localFile).getChannel();) {\n-\n-\t\t\t\t\ttempIngestSourceChannel.transferFrom(dataFileChannel, 0, storageIO.getSize());\n-\t\t\t\t}\n+                try (ReadableByteChannel dataFileChannel = storageIO.getReadChannel(); FileChannel tempIngestSourceChannel = new FileOutputStream(localFile).getChannel();) {\n+                    tempIngestSourceChannel.transferFrom(dataFileChannel, 0, storageIO.getSize());\n+                }\n                 inputStream = new BufferedInputStream(new FileInputStream(localFile));\n-                logger.fine(\"Saved \"+storageIO.getSize()+\" bytes in a local temp file.\");\n+                logger.fine(\"Saved \" + storageIO.getSize() + \" bytes in a local temp file.\");\n             }\n         } catch (IOException ioEx) {\n             dataFile.SetIngestProblem();\n-            \n             FileUtil.createIngestFailureReport(dataFile, \"IO Exception occured while trying to open the file for reading.\");\n             dataFile = fileService.save(dataFile);\n-            \n             logger.warning(\"Ingest failure (No file produced).\");\n-            return false; \n+            return false;\n         }\n-        \n+\n         if (ingestRequest != null) {\n-            if (ingestRequest.getTextEncoding() != null \n-                    && !ingestRequest.getTextEncoding().equals(\"\") ) {\n-                logger.fine(\"Setting language encoding to \"+ingestRequest.getTextEncoding());\n+            if (ingestRequest.getTextEncoding() != null && !ingestRequest.getTextEncoding().equals(\"\")) {\n+                logger.fine(\"Setting language encoding to \" + ingestRequest.getTextEncoding());\n                 ingestPlugin.setDataLanguageEncoding(ingestRequest.getTextEncoding());\n             }\n+\n             if (ingestRequest.getLabelsFile() != null) {\n                 additionalData = new File(ingestRequest.getLabelsFile());\n             }\n         }\n-        \n+\n         if (forceTypeCheck) {\n             String newType = FileUtil.retestIngestableFileType(localFile, dataFile.getContentType());\n-            \n             ingestPlugin = getTabDataReaderByMimeType(newType);\n             logger.fine(\"Re-tested file type: \" + newType + \"; Using ingest plugin \" + ingestPlugin.getClass());\n \n             // check again:\n             if (ingestPlugin == null) {\n                 // If it's still null - give up!\n-            \n                 dataFile.SetIngestProblem();\n-                FileUtil.createIngestFailureReport(dataFile, \"No ingest plugin found for file type \"+dataFile.getContentType());\n+                FileUtil.createIngestFailureReport(dataFile, \"No ingest plugin found for file type \" + dataFile.getContentType());\n                 dataFile = fileService.save(dataFile);\n                 logger.warning(\"Ingest failure: failed to detect ingest plugin (file type check forced)\");\n-                return false; \n+                return false;\n             }\n-            \n             dataFile.setContentType(newType);\n         }\n-        \n-        TabularDataIngest tabDataIngest = null; \n+\n+        TabularDataIngest tabDataIngest = null;\n         try {\n             if (additionalData != null) {\n                 tabDataIngest = ingestPlugin.read(inputStream, additionalData);\n@@ -884,19 +825,16 @@ public class IngestServiceBean {\n             dataFile.SetIngestProblem();\n             FileUtil.createIngestFailureReport(dataFile, ingestEx.getMessage());\n             dataFile = fileService.save(dataFile);\n-            \n             logger.warning(\"Ingest failure (IO Exception): \" + ingestEx.getMessage() + \".\");\n             return false;\n         } catch (Exception unknownEx) {\n             dataFile.SetIngestProblem();\n             FileUtil.createIngestFailureReport(dataFile, unknownEx.getMessage());\n             dataFile = fileService.save(dataFile);\n-            \n-            logger.warning(\"Ingest failure (Exception \" + unknownEx.getClass() + \"): \"+unknownEx.getMessage()+\".\");\n+            logger.warning(\"Ingest failure (Exception \" + unknownEx.getClass() + \"): \" + unknownEx.getMessage() + \".\");\n             return false;\n-            \n         } finally {\n-        \tIOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(inputStream);\n         }\n \n         String originalContentType = dataFile.getContentType();\n@@ -904,47 +842,38 @@ public class IngestServiceBean {\n         long originalFileSize = dataFile.getFilesize();\n         boolean postIngestTasksSuccessful = false;\n         boolean databaseSaveSuccessful = false;\n-\n         if (tabDataIngest != null) {\n             File tabFile = tabDataIngest.getTabDelimitedFile();\n-\n-            if (tabDataIngest.getDataTable() != null\n-                    && tabFile != null\n-                    && tabFile.exists()) {\n-                logger.info(\"Tabular data successfully ingested; DataTable with \"\n-                        + tabDataIngest.getDataTable().getVarQuantity() + \" variables produced.\");\n+            if (tabDataIngest.getDataTable() != null && tabFile != null && tabFile.exists()) {\n+                logger.info(\"Tabular data successfully ingested; DataTable with \" + tabDataIngest.getDataTable().getVarQuantity() + \" variables produced.\");\n                 logger.info(\"Tab-delimited file produced: \" + tabFile.getAbsolutePath());\n-\n                 dataFile.setFilesize(tabFile.length());\n \n                 // and change the mime type to \"Tabular Data\" on the final datafile, \n                 // and replace (or add) the extension \".tab\" to the filename: \n                 dataFile.setContentType(FileUtil.MIME_TYPE_INGESTED_FILE);\n-                IngestUtil.modifyExistingFilename(dataFile.getOwner().getLatestVersion(), dataFile.getFileMetadata(), FileUtil.replaceExtension(fileName, \"tab\"));\n-\n+                IngestUtil.modifyExistingFilename(dataFile.getOwner().getLatestVersion(),\n+dataFile.getFileMetadata(),\n+FileUtil.replaceExtension(fileName, \"tab\"));\n                 if (FileUtil.MIME_TYPE_CSV_ALT.equals(dataFile.getContentType())) {\n                     tabDataIngest.getDataTable().setOriginalFileFormat(FileUtil.MIME_TYPE_CSV);\n                 } else {\n                     tabDataIngest.getDataTable().setOriginalFileFormat(originalContentType);\n                 }\n                 tabDataIngest.getDataTable().setOriginalFileSize(originalFileSize);\n-\n                 dataFile.setDataTable(tabDataIngest.getDataTable());\n                 tabDataIngest.getDataTable().setDataFile(dataFile);\n                 tabDataIngest.getDataTable().setOriginalFileName(originalFileName);\n-                \n                 try {\n                     produceSummaryStatistics(dataFile, tabFile);\n                     produceFrequencyStatistics(dataFile, tabFile);\n                     postIngestTasksSuccessful = true;\n                 } catch (IOException postIngestEx) {\n-\n                     dataFile.SetIngestProblem();\n-                    FileUtil.createIngestFailureReport(dataFile, \"Ingest failed to produce Summary Statistics and/or UNF signatures; \" + postIngestEx.getMessage());\n-\n+                    FileUtil.createIngestFailureReport(dataFile,\n+                                                       \"Ingest failed to produce Summary Statistics and/or UNF signatures; \" + postIngestEx.getMessage());\n                     restoreIngestedDataFile(dataFile, tabDataIngest, originalFileSize, originalFileName, originalContentType);\n                     dataFile = fileService.save(dataFile);\n-\n                     logger.warning(\"Ingest failure: post-ingest tasks.\");\n                 }\n \n@@ -952,14 +881,12 @@ public class IngestServiceBean {\n                     logger.warning(\"Ingest failure (!postIngestTasksSuccessful).\");\n                     return false;\n                 }\n-\n                 dataFile.setIngestDone();\n                 // delete the ingest request, if exists:\n                 if (dataFile.getIngestRequest() != null) {\n                     dataFile.getIngestRequest().setDataFile(null);\n                     dataFile.setIngestRequest(null);\n                 }\n-\n                 try {\n                     /* \n                          In order to test a database save failure, uncomment this:\n@@ -970,9 +897,7 @@ public class IngestServiceBean {\n                      */\n                     dataFile = fileService.saveInTransaction(dataFile);\n                     databaseSaveSuccessful = true;\n-\n                     logger.fine(\"Ingest (\" + dataFile.getFileMetadata().getLabel() + \".\");\n-\n                     if (additionalData != null) {\n                         // remove the extra tempfile, if there was one:\n                         additionalData.delete();\n@@ -981,15 +906,11 @@ public class IngestServiceBean {\n                     // this means that an error occurred while saving the datafile\n                     // in the database. \n                     logger.warning(\"Ingest failure: Failed to save tabular metadata (datatable, datavariables, etc.) in the database. Clearing the datafile object.\");\n-\n                     dataFile = fileService.find(datafile_id);\n-\n                     if (dataFile != null) {\n                         dataFile.SetIngestProblem();\n                         FileUtil.createIngestFailureReport(dataFile, \"Ingest produced tabular data, but failed to save it in the database; \" + unknownEx.getMessage() + \" No further information is available.\");\n-\n                         restoreIngestedDataFile(dataFile, tabDataIngest, originalFileSize, originalFileName, originalContentType);\n-\n                         dataFile = fileService.save(dataFile);\n                     }\n                 }\n@@ -1002,14 +923,13 @@ public class IngestServiceBean {\n                 // Finally, let's swap the original and the tabular files: \n                 try {\n                     /* Start of save as backup */\n-\n                     StorageIO<DataFile> dataAccess = dataFile.getStorageIO();\n                     dataAccess.open();\n \n                     // and we want to save the original of the ingested file: \n                     try {\n                         dataAccess.backupAsAux(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-                        logger.fine(\"Saved the ingested original as a backup aux file \"+FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n+                        logger.fine(\"Saved the ingested original as a backup aux file \" + FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n                     } catch (IOException iox) {\n                         logger.warning(\"Failed to save the ingested original! \" + iox.getMessage());\n                     }\n@@ -1018,36 +938,28 @@ public class IngestServiceBean {\n                     dataAccess.savePath(Paths.get(tabFile.getAbsolutePath()));\n                     // Reset the file size: \n                     dataFile.setFilesize(dataAccess.getSize());\n-                    \n                     dataFile = fileService.save(dataFile);\n                     logger.fine(\"saved data file after updating the size\");\n \n                     // delete the temp tab-file:\n                     tabFile.delete();\n                     /*end of save as backup */\n-\n                 } catch (Exception e) {\n                     // this probably means that an error occurred while saving the file to the file system\n                     logger.warning(\"Failed to save the tabular file produced by the ingest (resetting the ingested DataFile back to its original state)\");\n-\n                     dataFile = fileService.find(datafile_id);\n-\n                     if (dataFile != null) {\n                         dataFile.SetIngestProblem();\n                         FileUtil.createIngestFailureReport(dataFile, \"Failed to save the tabular file produced by the ingest.\");\n-\n                         restoreIngestedDataFile(dataFile, tabDataIngest, originalFileSize, originalFileName, originalContentType);\n-\n                         dataFile = fileService.save(dataFile);\n                     }\n                 }\n-\n                 ingestSuccessful = true;\n             }\n         } else {\n             logger.warning(\"Ingest failed to produce data obect.\");\n         }\n-\n         return ingestSuccessful;\n     }\n \n@@ -1058,18 +970,20 @@ public class IngestServiceBean {\n         if (storageIO.isLocalFile()) {\n             inputStream = new BufferedInputStream(storageIO.getInputStream());\n         } else {\n-        \tFile tempFile = File.createTempFile(\"tempIngestSourceFile\", \".tmp\");\n-\t\t\ttry (ReadableByteChannel dataFileChannel = storageIO.getReadChannel();\n-\t\t\t\t\tFileChannel tempIngestSourceChannel = new FileOutputStream(tempFile).getChannel();) {\n-\t\t\t\ttempIngestSourceChannel.transferFrom(dataFileChannel, 0, storageIO.getSize());\n-\t\t\t}\n+            File tempFile = File.createTempFile(\"tempIngestSourceFile\", \".tmp\");\n+            try (ReadableByteChannel dataFileChannel = storageIO.getReadChannel(); FileChannel tempIngestSourceChannel = new FileOutputStream(tempFile).getChannel();) {\n+                tempIngestSourceChannel.transferFrom(dataFileChannel, 0, storageIO.getSize());\n+            }\n             inputStream = new BufferedInputStream(new FileInputStream(tempFile));\n-            logger.fine(\"Saved \"+storageIO.getSize()+\" bytes in a local temp file.\");\n+            logger.fine(\"Saved \" + storageIO.getSize() + \" bytes in a local temp file.\");\n         }\n         return inputStream;\n     }\n \n-    private void restoreIngestedDataFile(DataFile dataFile, TabularDataIngest tabDataIngest, long originalSize, String originalFileName, String originalContentType) {\n+    private void restoreIngestedDataFile(DataFile dataFile,\n+                                         TabularDataIngest tabDataIngest,\n+                                         long originalSize,\n+                                         String originalFileName, String originalContentType) {\n         dataFile.setDataTables(null);\n         if (tabDataIngest != null && tabDataIngest.getDataTable() != null) {\n             tabDataIngest.getDataTable().setDataFile(null);\n@@ -1099,7 +1013,7 @@ public class IngestServiceBean {\n         eventBus.publish(\"/ingest/dataset/\" + datasetId, message);\n         */\n    /* }*/\n-    \n+\n     public static TabularDataFileReader getTabDataReaderByMimeType(String mimeType) { //DataFile dataFile) {\n         /* \n          * Same as the comment above; since we don't have any ingest plugins loadable \n@@ -1108,38 +1022,35 @@ public class IngestServiceBean {\n          */\n \n         //String mimeType = dataFile.getContentType();\n-        \n         if (mimeType == null) {\n             return null;\n         }\n \n         TabularDataFileReader ingestPlugin = null;\n-\n         if (mimeType.equals(FileUtil.MIME_TYPE_STATA)) {\n             ingestPlugin = new DTAFileReader(new DTAFileReaderSpi());\n         } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA13)) {\n             ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 117);\n         } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA14)) {\n-            ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 118);\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA15)) {\n-            ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 119);\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_RDATA)) {\n-            ingestPlugin = new RDATAFileReader(new RDATAFileReaderSpi());\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_CSV) || mimeType.equals(FileUtil.MIME_TYPE_CSV_ALT)) {\n-            ingestPlugin = new CSVFileReader(new CSVFileReaderSpi(), ',');\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_TSV) /*|| mimeType.equals(FileUtil.MIME_TYPE_TSV_ALT)*/) {\n-            ingestPlugin = new CSVFileReader(new CSVFileReaderSpi(), '\\t');\n-        }  else if (mimeType.equals(FileUtil.MIME_TYPE_XLSX)) {\n-            ingestPlugin = new XLSXFileReader(new XLSXFileReaderSpi());\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_SPSS_SAV)) {\n-            ingestPlugin = new SAVFileReader(new SAVFileReaderSpi());\n-        } else if (mimeType.equals(FileUtil.MIME_TYPE_SPSS_POR)) {\n-            ingestPlugin = new PORFileReader(new PORFileReaderSpi());\n-        }\n-\n+                   ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 118);\n+               } else if (mimeType.equals(FileUtil.MIME_TYPE_STATA15)) {\n+                   ingestPlugin = new NewDTAFileReader(new DTAFileReaderSpi(), 119);\n+               } else if (mimeType.equals(FileUtil.MIME_TYPE_RDATA)) {\n+                          ingestPlugin = new RDATAFileReader(new RDATAFileReaderSpi());\n+                      } else if (mimeType.equals(FileUtil.MIME_TYPE_CSV) || mimeType.equals(FileUtil.MIME_TYPE_CSV_ALT)) {\n+                          ingestPlugin = new CSVFileReader(new CSVFileReaderSpi(), ',');\n+                      } else if (mimeType.equals(FileUtil.MIME_TYPE_TSV) /*|| mimeType.equals(FileUtil.MIME_TYPE_TSV_ALT)*/) {\n+                                 ingestPlugin = new CSVFileReader(new CSVFileReaderSpi(), '\\t');\n+                             } else if (mimeType.equals(FileUtil.MIME_TYPE_XLSX)) {\n+                                 ingestPlugin = new XLSXFileReader(new XLSXFileReaderSpi());\n+                             } else if (mimeType.equals(FileUtil.MIME_TYPE_SPSS_SAV)) {\n+                                        ingestPlugin = new SAVFileReader(new SAVFileReaderSpi());\n+                                    } else if (mimeType.equals(FileUtil.MIME_TYPE_SPSS_POR)) {\n+                                        ingestPlugin = new PORFileReader(new PORFileReaderSpi());\n+                                    }\n         return ingestPlugin;\n     }\n-    \n+\n     public boolean fileMetadataExtractable(DataFile dataFile) {\n         /* \n          * Eventually we'll be consulting the Ingest Service Provider Registry\n@@ -1158,27 +1069,27 @@ public class IngestServiceBean {\n      * framework for extracting metadata from uploaded files. The results will \n      * be used to populate the metadata of the Dataset to which the file belongs. \n     */\n+\n     public boolean extractMetadata(String tempFileLocation, DataFile dataFile, DatasetVersion editVersion) throws IOException {\n         boolean ingestSuccessful = false;\n-\n-        InputStream tempFileInputStream = null; \n-        if(tempFileLocation == null) {\n-        \tStorageIO<DataFile> sio = dataFile.getStorageIO();\n-        \tsio.open(DataAccessOption.READ_ACCESS);\n-        \ttempFileInputStream = sio.getInputStream();\n+        InputStream tempFileInputStream = null;\n+        if (tempFileLocation == null) {\n+            StorageIO<DataFile> sio = dataFile.getStorageIO();\n+            sio.open(DataAccessOption.READ_ACCESS);\n+            tempFileInputStream = sio.getInputStream();\n         } else {\n-        \ttry {\n-        \t\ttempFileInputStream = new FileInputStream(new File(tempFileLocation));\n-        \t} catch (FileNotFoundException notfoundEx) {\n-        \t\tthrow new IOException(\"Could not open temp file \"+tempFileLocation);\n-        \t}\n+            try {\n+                tempFileInputStream = new FileInputStream(new File(tempFileLocation));\n+            } catch (FileNotFoundException notfoundEx) {\n+                throw new IOException(\"Could not open temp file \" + tempFileLocation);\n+            }\n         }\n         \n         // Locate metadata extraction plugin for the file format by looking\n         // it up with the Ingest Service Provider Registry:\n         //FileMetadataExtractor extractorPlugin = IngestSP.getMetadataExtractorByMIMEType(dfile.getContentType());\n-        FileMetadataExtractor extractorPlugin = new FITSFileMetadataExtractor();\n \n+        FileMetadataExtractor extractorPlugin = new FITSFileMetadataExtractor();\n         FileMetadataIngest extractedMetadata = extractorPlugin.ingest(new BufferedInputStream(tempFileInputStream));\n         Map<String, Set<String>> extractedMetadataMap = extractedMetadata.getMetadataMap();\n \n@@ -1187,33 +1098,23 @@ public class IngestServiceBean {\n         // attempt to ingest the extracted metadata into the database; \n         // TODO: this should throw an exception if anything goes wrong.\n         FileMetadata fileMetadata = dataFile.getFileMetadata();\n-\n         if (extractedMetadataMap != null) {\n             logger.fine(\"Ingest Service: Processing extracted metadata;\");\n             if (extractedMetadata.getMetadataBlockName() != null) {\n-                logger.fine(\"Ingest Service: This metadata belongs to the \"+extractedMetadata.getMetadataBlockName()+\" metadata block.\"); \n+                logger.fine(\"Ingest Service: This metadata belongs to the \" + extractedMetadata.getMetadataBlockName() + \" metadata block.\");\n                 processDatasetMetadata(extractedMetadata, editVersion);\n             }\n-            \n             processFileLevelMetadata(extractedMetadata, fileMetadata);\n-\n         }\n-\n         ingestSuccessful = true;\n-\n         return ingestSuccessful;\n     }\n \n-    \n     private void processDatasetMetadata(FileMetadataIngest fileMetadataIngest, DatasetVersion editVersion) throws IOException {\n-        \n-        \n-        for (MetadataBlock mdb : editVersion.getDataset().getOwner().getMetadataBlocks()) {  \n+        for (MetadataBlock mdb : editVersion.getDataset().getOwner().getMetadataBlocks()) {\n             if (mdb.getName().equals(fileMetadataIngest.getMetadataBlockName())) {\n-                logger.fine(\"Ingest Service: dataset version has \"+mdb.getName()+\" metadata block enabled.\");\n-                \n+                logger.fine(\"Ingest Service: dataset version has \" + mdb.getName() + \" metadata block enabled.\");\n                 editVersion.setDatasetFields(editVersion.initDatasetFields());\n-                \n                 Map<String, Set<String>> fileMetadataMap = fileMetadataIngest.getMetadataMap();\n                 for (DatasetFieldType dsft : mdb.getDatasetFieldTypes()) {\n                     if (dsft.isPrimitive()) {\n@@ -1221,15 +1122,14 @@ public class IngestServiceBean {\n                             String dsfName = dsft.getName();\n                             // See if the plugin has found anything for this field: \n                             if (fileMetadataMap.get(dsfName) != null && !fileMetadataMap.get(dsfName).isEmpty()) {\n-\n                                 logger.fine(\"Ingest Service: found extracted metadata for field \" + dsfName);\n                                 // go through the existing fields:\n+\n                                 for (DatasetField dsf : editVersion.getFlatDatasetFields()) {\n                                     if (dsf.getDatasetFieldType().equals(dsft)) {\n                                         // yep, this is our field!\n                                         // let's go through the values that the ingest \n                                         // plugin found in the file for this field: \n-\n                                         Set<String> mValues = fileMetadataMap.get(dsfName);\n \n                                         // Special rules apply to aggregation of values for \n@@ -1237,9 +1137,7 @@ public class IngestServiceBean {\n                                         // fields from the Astronomy Metadata block. \n                                         // TODO: rather than hard-coded, this needs to be\n                                         // programmatically defined. -- L.A. 4.0\n-                                        if (dsfName.equals(\"resolution.Temporal\")\n-                                                || dsfName.equals(\"resolution.Spatial\")\n-                                                || dsfName.equals(\"resolution.Spectral\")) {\n+                                        if (dsfName.equals(\"resolution.Temporal\") || dsfName.equals(\"resolution.Spatial\") || dsfName.equals(\"resolution.Spectral\")) {\n                                             // For these values, we aggregate the minimum-maximum \n                                             // pair, for the entire set. \n                                             // So first, we need to go through the values found by \n@@ -1247,23 +1145,19 @@ public class IngestServiceBean {\n                                             // these: \n                                             // (note that we are assuming that they all must\n                                             // validate as doubles!)\n-\n                                             Double minValue = null;\n                                             Double maxValue = null;\n-\n                                             for (String fValue : mValues) {\n-\n                                                 try {\n                                                     double thisValue = Double.parseDouble(fValue);\n-\n                                                     if (minValue == null || Double.compare(thisValue, minValue) < 0) {\n                                                         minValue = thisValue;\n                                                     }\n+\n                                                     if (maxValue == null || Double.compare(thisValue, maxValue) > 0) {\n                                                         maxValue = thisValue;\n                                                     }\n-                                                } catch (NumberFormatException e) {\n-                                                }\n+                                                } catch (NumberFormatException e) {}\n                                             }\n \n                                             // Now let's see what aggregated values we \n@@ -1272,18 +1166,15 @@ public class IngestServiceBean {\n                                             // (all of these resolution.* fields have allowedMultiple set to FALSE, \n                                             // so there can be only one!)\n                                             //logger.fine(\"Min value: \"+minValue+\", Max value: \"+maxValue);\n+\n                                             if (minValue != null && maxValue != null) {\n-                                                Double storedMinValue = null; \n+                                                Double storedMinValue = null;\n                                                 Double storedMaxValue = null;\n-                                            \n                                                 String storedValue = \"\";\n-                                                \n                                                 if (dsf.getDatasetFieldValues() != null && dsf.getDatasetFieldValues().get(0) != null) {\n                                                     storedValue = dsf.getDatasetFieldValues().get(0).getValue();\n-                                                \n                                                     if (storedValue != null && !storedValue.equals(\"\")) {\n                                                         try {\n-\n                                                             if (storedValue.indexOf(\" - \") > -1) {\n                                                                 storedMinValue = Double.parseDouble(storedValue.substring(0, storedValue.indexOf(\" - \")));\n                                                                 storedMaxValue = Double.parseDouble(storedValue.substring(storedValue.indexOf(\" - \") + 3));\n@@ -1291,9 +1182,11 @@ public class IngestServiceBean {\n                                                                 storedMinValue = Double.parseDouble(storedValue);\n                                                                 storedMaxValue = storedMinValue;\n                                                             }\n+\n                                                             if (storedMinValue != null && storedMinValue.compareTo(minValue) < 0) {\n                                                                 minValue = storedMinValue;\n                                                             }\n+\n                                                             if (storedMaxValue != null && storedMaxValue.compareTo(maxValue) > 0) {\n                                                                 maxValue = storedMaxValue;\n                                                             }\n@@ -1304,9 +1197,8 @@ public class IngestServiceBean {\n                                                 }\n                                             \n                                                 //logger.fine(\"Stored min value: \"+storedMinValue+\", Stored max value: \"+storedMaxValue);\n-                                                \n+\n                                                 String newAggregateValue = \"\";\n-                                                \n                                                 if (minValue.equals(maxValue)) {\n                                                     newAggregateValue = minValue.toString();\n                                                 } else {\n@@ -1314,10 +1206,12 @@ public class IngestServiceBean {\n                                                 }\n                                                 \n                                                 // finally, compare it to the value we have now:\n+\n                                                 if (!storedValue.equals(newAggregateValue)) {\n                                                     if (dsf.getDatasetFieldValues() == null) {\n                                                         dsf.setDatasetFieldValues(new ArrayList<DatasetFieldValue>());\n                                                     }\n+\n                                                     if (dsf.getDatasetFieldValues().get(0) == null) {\n                                                         DatasetFieldValue newDsfv = new DatasetFieldValue(dsf);\n                                                         dsf.getDatasetFieldValues().add(newDsfv);\n@@ -1332,13 +1226,10 @@ public class IngestServiceBean {\n                                             // for this Field throughout the dataset. \n                                             // This means we need to only add the values *not yet present*.\n                                             // (the implementation below may be inefficient - ?)\n-\n                                             for (String fValue : mValues) {\n                                                 if (!dsft.isControlledVocabulary()) {\n                                                     Iterator<DatasetFieldValue> dsfvIt = dsf.getDatasetFieldValues().iterator();\n-\n                                                     boolean valueExists = false;\n-\n                                                     while (dsfvIt.hasNext()) {\n                                                         DatasetFieldValue dsfv = dsfvIt.next();\n                                                         if (fValue.equals(dsfv.getValue())) {\n@@ -1354,7 +1245,6 @@ public class IngestServiceBean {\n                                                         newDsfv.setValue(fValue);\n                                                         dsf.getDatasetFieldValues().add(newDsfv);\n                                                     }\n-\n                                                 } else {\n                                                     // A controlled vocabulary entry: \n                                                     // first, let's see if it's a legit control vocab. entry: \n@@ -1369,11 +1259,11 @@ public class IngestServiceBean {\n                                                             }\n                                                         }\n                                                     }\n+\n                                                     if (legitControlledVocabularyValue != null) {\n                                                         // Only need to add the value if it is new, \n                                                         // i.e. if it does not exist yet: \n                                                         boolean valueExists = false;\n-\n                                                         List<ControlledVocabularyValue> existingControlledVocabValues = dsf.getControlledVocabularyValues();\n                                                         if (existingControlledVocabValues != null) {\n                                                             Iterator<ControlledVocabularyValue> cvvIt = existingControlledVocabValues.iterator();\n@@ -1408,12 +1298,11 @@ public class IngestServiceBean {\n                         // create a new compound field value and its child \n                         // \n                         DatasetFieldCompoundValue compoundDsfv = new DatasetFieldCompoundValue();\n-                        int nonEmptyFields = 0; \n+                        int nonEmptyFields = 0;\n                         for (DatasetFieldType cdsft : dsft.getChildDatasetFieldTypes()) {\n                             String dsfName = cdsft.getName();\n-                            if (fileMetadataMap.get(dsfName) != null && !fileMetadataMap.get(dsfName).isEmpty()) {  \n-                                logger.fine(\"Ingest Service: found extracted metadata for field \" + dsfName + \", part of the compound field \"+dsft.getName());\n-                                \n+                            if (fileMetadataMap.get(dsfName) != null && !fileMetadataMap.get(dsfName).isEmpty()) {\n+                                logger.fine(\"Ingest Service: found extracted metadata for field \" + dsfName + \", part of the compound field \" + dsft.getName());\n                                 if (cdsft.isPrimitive()) {\n                                     // probably an unnecessary check - child fields\n                                     // of compound fields are always primitive... \n@@ -1421,23 +1310,19 @@ public class IngestServiceBean {\n                                     if (!cdsft.isControlledVocabulary()) {\n                                         // TODO: can we have controlled vocabulary\n                                         // sub-fields inside compound fields?\n-                                        \n                                         DatasetField childDsf = new DatasetField();\n                                         childDsf.setDatasetFieldType(cdsft);\n-                                        \n                                         DatasetFieldValue newDsfv = new DatasetFieldValue(childDsf);\n-                                        newDsfv.setValue((String)fileMetadataMap.get(dsfName).toArray()[0]);\n+                                        newDsfv.setValue((String) fileMetadataMap.get(dsfName).toArray()[0]);\n                                         childDsf.getDatasetFieldValues().add(newDsfv);\n-                                        \n                                         childDsf.setParentDatasetFieldCompoundValue(compoundDsfv);\n                                         compoundDsfv.getChildDatasetFields().add(childDsf);\n-                                        \n                                         nonEmptyFields++;\n                                     }\n-                                } \n+                                }\n                             }\n                         }\n-                        \n+\n                         if (nonEmptyFields > 0) {\n                             // let's go through this dataset's fields and find the \n                             // actual parent for this sub-field: \n@@ -1450,28 +1335,27 @@ public class IngestServiceBean {\n                                     // as sets! -- i.e. all the sub fields in 2 compound fields \n                                     // must match in order for these 2 compounds to be recognized \n                                     // as \"the same\":\n-                                    \n-                                    boolean alreadyExists = false; \n+                                    boolean alreadyExists = false;\n                                     for (DatasetFieldCompoundValue dsfcv : dsf.getDatasetFieldCompoundValues()) {\n-                                        int matches = 0; \n-\n+                                        int matches = 0;\n                                         for (DatasetField cdsf : dsfcv.getChildDatasetFields()) {\n                                             String cdsfName = cdsf.getDatasetFieldType().getName();\n                                             String cdsfValue = cdsf.getDatasetFieldValues().get(0).getValue();\n                                             if (cdsfValue != null && !cdsfValue.equals(\"\")) {\n-                                                String extractedValue = (String)fileMetadataMap.get(cdsfName).toArray()[0];\n-                                                logger.fine(\"values: existing: \"+cdsfValue+\", extracted: \"+extractedValue);\n+                                                String extractedValue = (String) fileMetadataMap.get(cdsfName).toArray()[0];\n+                                                logger.fine(\"values: existing: \" + cdsfValue + \", extracted: \" + extractedValue);\n                                                 if (cdsfValue.equals(extractedValue)) {\n                                                     matches++;\n                                                 }\n                                             }\n                                         }\n+\n                                         if (matches == nonEmptyFields) {\n-                                            alreadyExists = true; \n+                                            alreadyExists = true;\n                                             break;\n                                         }\n                                     }\n-                                                                        \n+\n                                     if (!alreadyExists) {\n                                         // save this compound value, by attaching it to the \n                                         // version for proper cascading:\n@@ -1482,18 +1366,16 @@ public class IngestServiceBean {\n                             }\n                         }\n                     }\n-                } \n+                }\n             }\n-        }  \n+        }\n     }\n-    \n-    \n+\n     private void processFileLevelMetadata(FileMetadataIngest fileLevelMetadata, FileMetadata fileMetadata) {\n         // The only type of metadata that ingest plugins can extract from ingested\n         // files (as of 4.0 beta) that *stay* on the file-level is the automatically\n         // generated \"metadata summary\" note. We attach it to the \"description\" \n         // field of the fileMetadata object. -- L.A. \n-        \n         String metadataSummary = fileLevelMetadata.getMetadataSummary();\n         if (metadataSummary != null) {\n             if (!metadataSummary.equals(\"\")) {\n@@ -1502,16 +1384,14 @@ public class IngestServiceBean {\n                 // have entered. Rather, we'll append this generated metadata summary \n                 // to the existing value. \n                 String userEnteredFileDescription = fileMetadata.getDescription();\n-                if (userEnteredFileDescription != null\n-                        && !(userEnteredFileDescription.equals(\"\"))) {\n-\n+                if (userEnteredFileDescription != null && !(userEnteredFileDescription.equals(\"\"))) {\n                     metadataSummary = userEnteredFileDescription.concat(\";\\n\" + metadataSummary);\n                 }\n                 fileMetadata.setDescription(metadataSummary);\n             }\n         }\n     }\n-    \n+\n     public void performPostProcessingTasks(DataFile dataFile) {\n         /*\n          * At this point (4.0 beta) the only ingest \"post-processing task\" performed \n@@ -1522,38 +1402,34 @@ public class IngestServiceBean {\n             try {\n                 StorageIO<DataFile> dataAccess = dataFile.getStorageIO();\n                 if (dataAccess != null) { // && storageIO.isLocalFile()) {\n-\n                     if (ImageThumbConverter.isThumbnailAvailable(dataFile, ImageThumbConverter.DEFAULT_PREVIEW_SIZE)) {\n                         dataFile.setPreviewImageAvailable(true);\n                     }\n                 }\n-            } catch (IOException ioEx) {\n-            }\n+            } catch (IOException ioEx) {}\n         }\n     }\n- \n+\n     private Set<Integer> selectContinuousVariableColumns(DataFile dataFile) {\n         Set<Integer> contVarFields = new LinkedHashSet<Integer>();\n-\n         for (int i = 0; i < dataFile.getDataTable().getVarQuantity(); i++) {\n             if (dataFile.getDataTable().getDataVariables().get(i).isIntervalContinuous()) {\n                 contVarFields.add(i);\n             }\n         }\n-\n         return contVarFields;\n     }\n-    \n+\n     private void calculateContinuousSummaryStatistics(DataFile dataFile, int varnum, Number[] dataVector) throws IOException {\n         double[] sumStats = SumStatCalculator.calculateSummaryStatistics(dataVector);\n         assignContinuousSummaryStatistics(dataFile.getDataTable().getDataVariables().get(varnum), sumStats);\n     }\n-    \n+\n     private void assignContinuousSummaryStatistics(DataVariable variable, double[] sumStats) throws IOException {\n         if (sumStats == null || sumStats.length != variableService.summaryStatisticTypes.length) {\n-            throw new IOException (\"Wrong number of summary statistics types calculated! (\"+sumStats.length+\")\");\n+            throw new IOException(\"Wrong number of summary statistics types calculated! (\" + sumStats.length + \")\");\n         }\n-        \n+\n         for (int j = 0; j < variableService.summaryStatisticTypes.length; j++) {\n             SummaryStatistic ss = new SummaryStatistic();\n             ss.setTypeByLabel(variableService.summaryStatisticTypes[j]);\n@@ -1565,9 +1441,8 @@ public class IngestServiceBean {\n             ss.setDataVariable(variable);\n             variable.getSummaryStatistics().add(ss);\n         }\n-\n     }\n-    \n+\n     private void calculateUNF(DataFile dataFile, int varnum, Double[] dataVector) {\n         String unf = null;\n         try {\n@@ -1577,38 +1452,36 @@ public class IngestServiceBean {\n         } catch (UnfException uex) {\n             logger.warning(\"UNF Exception: thrown when attempted to calculate UNF signature for (numeric, continuous) variable \" + varnum);\n         }\n-        \n+\n         if (unf != null) {\n             dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n         } else {\n             logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n         }\n     }\n-    \n+\n     private void calculateUNF(DataFile dataFile, int varnum, Long[] dataVector) {\n         String unf = null;\n         try {\n             unf = UNFUtil.calculateUNF(dataVector);\n         } catch (IOException iex) {\n             logger.warning(\"exception thrown when attempted to calculate UNF signature for (numeric, discrete) variable \" + varnum);\n-        }  catch (UnfException uex) {\n+        } catch (UnfException uex) {\n             logger.warning(\"UNF Exception: thrown when attempted to calculate UNF signature for (numeric, discrete) variable \" + varnum);\n         }\n-        \n+\n         if (unf != null) {\n             dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n         } else {\n             logger.warning(\"failed to calculate UNF signature for variable \" + varnum);\n         }\n     }\n-    \n+\n     private void calculateUNF(DataFile dataFile, int varnum, String[] dataVector) throws IOException {\n         String unf = null;\n-        \n         String[] dateFormats = null; \n         \n         // Special handling for Character strings that encode dates and times:\n-        \n         if (\"time\".equals(dataFile.getDataTable().getDataVariables().get(varnum).getFormatCategory())) {\n             dateFormats = new String[dataVector.length];\n             String savedDateTimeFormat = dataFile.getDataTable().getDataVariables().get(varnum).getFormat();\n@@ -1629,42 +1502,38 @@ public class IngestServiceBean {\n              * switch to UNF6.\n              * -- L.A. 4.0 beta 8\n              */\n+\n             String simplifiedFormat = null;\n             SimpleDateFormat fullFormatParser = null;\n             SimpleDateFormat simplifiedFormatParser = null;\n-            \n             if (timeFormat.matches(\".*\\\\.SSS z$\")) {\n                 simplifiedFormat = timeFormat.replace(\".SSS\", \"\");\n-                \n                 fullFormatParser = new SimpleDateFormat(timeFormat);\n                 simplifiedFormatParser = new SimpleDateFormat(simplifiedFormat);\n-            } \n-            \n+            }\n+\n             for (int i = 0; i < dataVector.length; i++) {\n                 if (dataVector[i] != null) {\n-                    \n                     if (simplifiedFormatParser != null) {\n                         // first, try to parse the value against the \"full\" \n                         // format (with the milliseconds part):\n                         fullFormatParser.setLenient(false);\n-                    \n                         try {\n-                            logger.fine(\"trying the \\\"full\\\" time format, with milliseconds: \"+timeFormat+\", \"+dataVector[i]);\n+                            logger.fine(\"trying the \\\"full\\\" time format, with milliseconds: \" + timeFormat + \", \" + dataVector[i]);\n                             fullFormatParser.parse(dataVector[i]);\n-                         } catch (ParseException ex) {\n+                        } catch (ParseException ex) {\n                             // try the simplified (no time zone) format instead:\n-                            logger.fine(\"trying the simplified format: \"+simplifiedFormat+\", \"+dataVector[i]);\n+                            logger.fine(\"trying the simplified format: \" + simplifiedFormat + \", \" + dataVector[i]);\n                             simplifiedFormatParser.setLenient(false);\n                             try {\n                                 simplifiedFormatParser.parse(dataVector[i]);\n                                 timeFormat = simplifiedFormat;\n                             } catch (ParseException ex1) {\n-                                logger.warning(\"no parseable format found for time value \"+i+\" - \"+dataVector[i]);\n-                                throw new IOException(\"no parseable format found for time value \"+i+\" - \"+dataVector[i]);\n+                                logger.warning(\"no parseable format found for time value \" + i + \" - \" + dataVector[i]);\n+                                throw new IOException(\"no parseable format found for time value \" + i + \" - \" + dataVector[i]);\n                             }\n                         }\n-\n-                    } \n+                    }\n                     dateFormats[i] = timeFormat;\n                 }\n             }\n@@ -1681,10 +1550,9 @@ public class IngestServiceBean {\n                 }\n             }\n         }\n-                \n         try {\n             if (dateFormats == null) {\n-                logger.fine(\"calculating the UNF value for string vector; first value: \"+dataVector[0]);\n+                logger.fine(\"calculating the UNF value for string vector; first value: \" + dataVector[0]);\n                 unf = UNFUtil.calculateUNF(dataVector);\n             } else {\n                 unf = UNFUtil.calculateUNF(dataVector, dateFormats);\n@@ -1694,7 +1562,7 @@ public class IngestServiceBean {\n         } catch (UnfException uex) {\n             logger.warning(\"UNF Exception: thrown when attempted to calculate UNF signature for (character) variable \" + varnum);\n         }\n-        \n+\n         if (unf != null) {\n             dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n         } else {\n@@ -1709,7 +1577,7 @@ public class IngestServiceBean {\n     // from a STATA float value directly. \n     // TODO: remove this from the final production 4.0!\n     // -- L.A., Jul 2014\n-    \n+\n     private void calculateUNF(DataFile dataFile, int varnum, Float[] dataVector) {\n         String unf = null;\n         try {\n@@ -1719,7 +1587,7 @@ public class IngestServiceBean {\n         } catch (UnfException uex) {\n             logger.warning(\"UNF Exception: thrown when attempted to calculate UNF signature for numeric, \\\"continuous\\\" (float) variable\" + varnum);\n         }\n-        \n+\n         if (unf != null) {\n             dataFile.getDataTable().getDataVariables().get(varnum).setUnf(unf);\n         } else {\n@@ -1732,6 +1600,7 @@ public class IngestServiceBean {\n     // Note the @Asynchronous attribute - this allows us to just kick off and run this \n     // (potentially large) job in the background. \n     // The method is called by the \"fixmissingoriginaltypes\" /admin api call. \n+\n     @Asynchronous\n     public void fixMissingOriginalTypes(List<Long> datafileIds) {\n         for (Long fileId : datafileIds) {\n@@ -1745,6 +1614,7 @@ public class IngestServiceBean {\n     // Note the @Asynchronous attribute - this allows us to just kick off and run this \n     // (potentially large) job in the background. \n     // The method is called by the \"fixmissingoriginalsizes\" /admin api call. \n+\n     @Asynchronous\n     public void fixMissingOriginalSizes(List<Long> datafileIds) {\n         for (Long fileId : datafileIds) {\n@@ -1759,9 +1629,9 @@ public class IngestServiceBean {\n     // This method fixes a datatable object that's missing the format type of \n     // the ingested original. It will check the saved original file to \n     // determine the type. \n+\n     private void fixMissingOriginalType(long fileId) {\n         DataFile dataFile = fileService.find(fileId);\n-\n         if (dataFile != null && dataFile.isTabularData()) {\n             String originalFormat = dataFile.getDataTable().getOriginalFileFormat();\n             Long datatableId = dataFile.getDataTable().getId();\n@@ -1779,17 +1649,12 @@ public class IngestServiceBean {\n                 // file access, we'll just go directly to the stored file. For \n                 // swift and similar implementations, we'll read the saved aux \n                 // channel and save it as a local temp file. \n-                \n                 StorageIO<DataFile> storageIO;\n-\n                 File savedOriginalFile = null;\n                 boolean tempFileRequired = false;\n-                \n                 try {\n                     storageIO = dataFile.getStorageIO();\n                     storageIO.open();\n-\n-\n                     if (storageIO.isLocalFile()) {\n                         try {\n                             savedOriginalFile = storageIO.getAuxObjectAsPath(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION).toFile();\n@@ -1801,19 +1666,13 @@ public class IngestServiceBean {\n \n                     if (savedOriginalFile == null) {\n                         tempFileRequired = true;\n-\n-\t\t\t\t\t\tsavedOriginalFile = File.createTempFile(\"tempSavedOriginal\", \".tmp\");\n-\t\t\t\t\t\ttry (ReadableByteChannel savedOriginalChannel = (ReadableByteChannel) storageIO\n-\t\t\t\t\t\t\t\t.openAuxChannel(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-\t\t\t\t\t\t\t\tFileChannel tempSavedOriginalChannel = new FileOutputStream(savedOriginalFile)\n-\t\t\t\t\t\t\t\t\t\t.getChannel();) {\n-\t\t\t\t\t\t\ttempSavedOriginalChannel.transferFrom(savedOriginalChannel, 0,\n-\t\t\t\t\t\t\t\t\tstorageIO.getAuxObjectSize(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION));\n-\t\t\t\t\t\t}\n-\n+                        savedOriginalFile = File.createTempFile(\"tempSavedOriginal\", \".tmp\");\n+                        try (ReadableByteChannel savedOriginalChannel = (ReadableByteChannel) storageIO.openAuxChannel(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION); FileChannel tempSavedOriginalChannel = new FileOutputStream(savedOriginalFile).getChannel();) {\n+                            tempSavedOriginalChannel.transferFrom(savedOriginalChannel, 0, storageIO.getAuxObjectSize(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION));\n+                        }\n                     }\n                 } catch (Exception ex) {\n-                    logger.warning(\"Exception \"+ex.getClass()+\" caught trying to open StorageIO channel for the saved original; (datafile id=\" + fileId + \", datatable id=\" + datatableId + \"): \" + ex.getMessage());\n+                    logger.warning(\"Exception \" + ex.getClass() + \" caught trying to open StorageIO channel for the saved original; (datafile id=\" + fileId + \", datatable id=\" + datatableId + \"): \" + ex.getMessage());\n                     savedOriginalFile = null;\n                 }\n \n@@ -1823,13 +1682,12 @@ public class IngestServiceBean {\n                 }\n \n                 String fileTypeDetermined = null;\n-\n                 try {\n                     fileTypeDetermined = FileUtil.determineFileType(savedOriginalFile, \"\");\n                 } catch (IOException ioex) {\n                     logger.warning(\"Caught exception trying to determine original file type (datafile id=\" + fileId + \", datatable id=\" + datatableId + \"): \" + ioex.getMessage());\n                 }\n-                \n+\n                 Long savedOriginalFileSize = savedOriginalFile.length(); \n                 \n                 // If we had to create a temp file, delete it now: \n@@ -1845,10 +1703,12 @@ public class IngestServiceBean {\n                 // we know that this file has been successfully ingested; \n                 // so if the FileUtil is telling us it's a \"plain text\" file at this point,\n                 // it really means it must be a CSV file. \n+\n                 if (fileTypeDetermined.startsWith(\"text/plain\")) {\n                     fileTypeDetermined = FileUtil.MIME_TYPE_CSV;\n                 }\n                 // and, finally, if it is still \"application/octet-stream\", it must be Excel:\n+\n                 if (FileUtil.MIME_TYPE_UNDETERMINED_DEFAULT.equals(fileTypeDetermined)) {\n                     fileTypeDetermined = FileUtil.MIME_TYPE_XLSX;\n                 }\n@@ -1858,7 +1718,6 @@ public class IngestServiceBean {\n                 dataFile.getDataTable().setOriginalFileFormat(fileTypeDetermined);\n                 dataFile.getDataTable().setOriginalFileSize(savedOriginalFileSize);\n                 fileService.saveDataTable(dataFile.getDataTable());\n-\n             } else {\n                 logger.info(\"DataFile id=\" + fileId + \"; original type already present: \" + originalFormat);\n             }\n@@ -1869,24 +1728,20 @@ public class IngestServiceBean {\n     \n     // This method fixes a datatable object that's missing the size of the \n     // ingested original. \n+\n     private void fixMissingOriginalSize(long fileId) {\n         DataFile dataFile = fileService.find(fileId);\n-\n         if (dataFile != null && dataFile.isTabularData()) {\n             Long savedOriginalFileSize = dataFile.getDataTable().getOriginalFileSize();\n             Long datatableId = dataFile.getDataTable().getId();\n-            \n             if (savedOriginalFileSize == null) {\n-                \n                 StorageIO<DataFile> storageIO;\n-                \n                 try {\n                     storageIO = dataFile.getStorageIO();\n                     storageIO.open();\n                     savedOriginalFileSize = storageIO.getAuxObjectSize(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION);\n-\n                 } catch (Exception ex) {\n-                    logger.warning(\"Exception \"+ex.getClass()+\" caught trying to look up the size of the saved original; (datafile id=\" + fileId + \", datatable id=\" + datatableId + \"): \" + ex.getMessage());\n+                    logger.warning(\"Exception \" + ex.getClass() + \" caught trying to look up the size of the saved original; (datafile id=\" + fileId + \", datatable id=\" + datatableId + \"): \" + ex.getMessage());\n                     return;\n                 }\n \n@@ -1898,7 +1753,6 @@ public class IngestServiceBean {\n                 // save permanently in the database:\n                 dataFile.getDataTable().setOriginalFileSize(savedOriginalFileSize);\n                 fileService.saveDataTable(dataFile.getDataTable());\n-\n             } else {\n                 logger.info(\"DataFile id=\" + fileId + \"; original file size already present: \" + savedOriginalFileSize);\n             }\n@@ -1906,67 +1760,54 @@ public class IngestServiceBean {\n             logger.warning(\"DataFile id=\" + fileId + \": No such DataFile!\");\n         }\n     }\n-    \n+\n     public static void main(String[] args) {\n-        \n         String file = args[0];\n-        String type = args[1]; \n-        \n-        if (file == null || type == null || \"\".equals(file) || \"\".equals(type)) {\n+        String type = args[1];\n+        if (file == null || type == null\n+        || \"\".equals(file) || \"\".equals(type)) {\n             System.err.println(\"Usage: java edu.harvard.iq.dataverse.ingest.IngestServiceBean <file> <type>.\");\n             System.exit(1);\n         }\n-        \n-        BufferedInputStream fileInputStream = null; \n-        \n+\n+        BufferedInputStream fileInputStream = null;\n         try {\n             fileInputStream = new BufferedInputStream(new FileInputStream(new File(file)));\n         } catch (FileNotFoundException notfoundEx) {\n-            fileInputStream = null; \n+            fileInputStream = null;\n         }\n-        \n+\n         if (fileInputStream == null) {\n-            System.err.println(\"Could not open file \"+file+\".\");\n+            System.err.println(\"Could not open file \" + file + \".\");\n             System.exit(1);\n         }\n-        \n-        TabularDataFileReader ingestPlugin = getTabDataReaderByMimeType(type);\n \n+        TabularDataFileReader ingestPlugin = getTabDataReaderByMimeType(type);\n         if (ingestPlugin == null) {\n-            System.err.println(\"Could not locate an ingest plugin for type \"+type+\".\");\n+            System.err.println(\"Could not locate an ingest plugin for type \" + type + \".\");\n             System.exit(1);\n         }\n-        \n+\n         TabularDataIngest tabDataIngest = null;\n-        \n         try {\n             tabDataIngest = ingestPlugin.read(fileInputStream, null);\n         } catch (IOException ingestEx) {\n-            System.err.println(\"Caught an exception trying to ingest file \"+file+\".\");\n+            System.err.println(\"Caught an exception trying to ingest file \" + file + \".\");\n             System.exit(1);\n         }\n-        \n         try {\n             if (tabDataIngest != null) {\n                 File tabFile = tabDataIngest.getTabDelimitedFile();\n-\n-                if (tabDataIngest.getDataTable() != null\n-                        && tabFile != null\n-                        && tabFile.exists()) {\n-\n+                if (tabDataIngest.getDataTable() != null && tabFile != null && tabFile.exists()) {\n                     String tabFilename = FileUtil.replaceExtension(file, \"tab\");\n-                    \n                     Files.copy(Paths.get(tabFile.getAbsolutePath()), Paths.get(tabFilename), StandardCopyOption.REPLACE_EXISTING);\n-                    \n                     DataTable dataTable = tabDataIngest.getDataTable();\n-                    \n-                    System.out.println (\"NVARS: \"+dataTable.getVarQuantity());\n-                    System.out.println (\"NOBS: \"+dataTable.getCaseQuantity());\n-                    System.out.println (\"UNF: \"+dataTable.getUnf());\n-                    \n+                    System.out.println(\"NVARS: \" + dataTable.getVarQuantity());\n+                    System.out.println(\"NOBS: \" + dataTable.getCaseQuantity());\n+                    System.out.println(\"UNF: \" + dataTable.getUnf());\n+\n                     for (int i = 0; i < dataTable.getVarQuantity(); i++) {\n                         String vartype = \"\";\n-                        \n                         if (dataTable.getDataVariables().get(i).isIntervalContinuous()) {\n                             vartype = \"numeric-continuous\";\n                         } else {\n@@ -1976,28 +1817,24 @@ public class IngestServiceBean {\n                                 vartype = \"character\";\n                             }\n                         }\n-                        \n-                        System.out.print (\"VAR\"+i+\" \");\n-                        System.out.print (dataTable.getDataVariables().get(i).getName()+\" \");\n-                        System.out.print (vartype+\" \");\n-                        System.out.print (dataTable.getDataVariables().get(i).getUnf());\n-                        System.out.println(); \n-                        \n+                        System.out.print(\"VAR\" + i + \" \");\n+                        System.out.print(dataTable.getDataVariables().get(i).getName() + \" \");\n+                        System.out.print(vartype + \" \");\n+                        System.out.print(dataTable.getDataVariables().get(i).getUnf());\n+                        System.out.println();\n                     }\n-                \n                 } else {\n-                    System.err.println(\"Ingest failed to produce tab file or data table for file \"+file+\".\");\n+                    System.err.println(\"Ingest failed to produce tab file or data table for file \" + file + \".\");\n                     System.exit(1);\n                 }\n             } else {\n-                System.err.println(\"Ingest resulted in a null tabDataIngest object for file \"+file+\".\");\n+                System.err.println(\"Ingest resulted in a null tabDataIngest object for file \" + file + \".\");\n                 System.exit(1);\n             }\n         } catch (IOException ex) {\n-            System.err.println(\"Caught an exception trying to save ingested data for file \"+file+\".\");\n+            System.err.println(\"Caught an exception trying to save ingested data for file \" + file + \".\");\n             System.exit(1);\n         }\n-        \n     }\n     /*\n     private class InternalIngestException extends Exception {\n@@ -2008,4 +1845,5 @@ public class IngestServiceBean {\n         \n     }\n     */\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 661
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "159",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/27/IngestServiceBean.java\nindex cf3c62ef584..a4e011fea11 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/27/IngestServiceBean.java\n@@ -155,7 +155,7 @@ public class IngestServiceBean {\n     // DataFileCategory objects, if any were already assigned to the files). \n     // It must be called before we attempt to permanently save the files in \n     // the database by calling the Save command on the dataset and/or version. \n-\tpublic List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n+public List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n \t\tList<DataFile> ret = new ArrayList<>();\n \n \t\tif (newFiles != null && newFiles.size() > 0) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "160",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/27/IngestServiceBean.java\nindex cf3c62ef584..02ee82474df 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/27/IngestServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/27/IngestServiceBean.java\n@@ -155,7 +155,8 @@ public class IngestServiceBean {\n     // DataFileCategory objects, if any were already assigned to the files). \n     // It must be called before we attempt to permanently save the files in \n     // the database by calling the Save command on the dataset and/or version. \n-\tpublic List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n+    public\n+    List<DataFile> saveAndAddFilesToDataset(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace) {\n \t\tList<DataFile> ret = new ArrayList<>();\n \n \t\tif (newFiles != null && newFiles.size() > 0) {\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}