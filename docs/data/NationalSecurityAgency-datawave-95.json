{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "95",
    "information": {
        "errors": [
            {
                "line": "5",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import com.github.benmanes.caffeine.cache.Cache;\nimport com.github.benmanes.caffeine.cache.Caffeine;\nimport org.apache.accumulo.core.conf.AccumuloConfiguration;\nimport org.apache.accumulo.core.data.Range;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.log4j.Logger;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "5",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "5",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/95/ActiveQueryLog.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/95/ActiveQueryLog.java\nindex 9f31cb09dc4..423cd56dc6d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/95/ActiveQueryLog.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/95/ActiveQueryLog.java\n@@ -18,312 +18,313 @@ import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n public class ActiveQueryLog {\n-    \n-    public static final String DEFAULT_NAME = \"default_log\";\n-    private static final String DEFAULT_EMPTY_QUERY_ID = new UUID(0, 0).toString();\n-    private static final Logger log = Logger.getLogger(ActiveQueryLog.class);\n-    private static Cache<String,ActiveQueryLog> logCache = null;\n-    private static final Object logCacheLock = new Object();\n-    private static AccumuloConfiguration conf = null;\n-    \n-    // Accumulo properties\n-    public static final String MAX_IDLE = \"datawave.query.active.maxIdleMs\";\n-    public static final String LOG_PERIOD = \"datawave.query.active.logPeriodMs\";\n-    public static final String LOG_MAX_QUERIES = \"datawave.query.active.logMaxQueries\";\n-    public static final String WINDOW_SIZE = \"datawave.query.active.windowSize\";\n-    private static final long HOURS_24_MS = TimeUnit.MILLISECONDS.convert(24, TimeUnit.HOURS);\n-    private static final long MINUTES_15_MS = TimeUnit.MILLISECONDS.convert(15, TimeUnit.MINUTES);\n-    private static final long MINUTES_1_MS = TimeUnit.MILLISECONDS.convert(1, TimeUnit.MINUTES);\n-    \n-    // Changeable via Accumulo properties\n-    volatile private long maxIdle = MINUTES_15_MS;\n-    volatile private long logPeriod = MINUTES_1_MS;\n-    volatile private int logMaxQueries = 5;\n-    volatile private int windowSize = 10;\n-    private final AtomicLong lastAccess = new AtomicLong(System.currentTimeMillis());\n-    \n-    private Cache<String,ActiveQuery> CACHE = null;\n-    private final ReentrantReadWriteLock cacheLock = new ReentrantReadWriteLock();\n-    private Timer timer = null;\n-    private TimerTask timerTask = null;\n-    \n-    private final String name;\n-    \n-    synchronized public static void setConfig(final AccumuloConfiguration conf) {\n-        if (conf != null) {\n-            if (ActiveQueryLog.conf == null || conf.getUpdateCount() > ActiveQueryLog.conf.getUpdateCount()) {\n-                ActiveQueryLog.conf = conf;\n-            }\n-            // Do not allow access to the cache while updating each log's settings.\n-            if (logCache != null) {\n-                synchronized (ActiveQueryLog.logCacheLock) {\n-                    ConcurrentMap<String,ActiveQueryLog> logMap = logCache.asMap();\n-                    logMap.values().forEach(log -> log.checkSettings(conf, false));\n-                }\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * Return the default {@link ActiveQueryLog} instance. The time the instance was last accessed will be updated to the current time in milliseconds, and if\n-     * the instance's timer was cancelled, it will be restarted.\n-     * \n-     * @return the default {@link ActiveQueryLog} instance\n-     */\n-    public static ActiveQueryLog getInstance() {\n-        return getInstance(DEFAULT_NAME);\n-    }\n-    \n-    /**\n-     * Return the {@link ActiveQueryLog} instance associated with the specified name. If one does not exist, it will be created.\n-     *\n-     * If the specified name is null or blank, the default instance with the name '{@value #DEFAULT_NAME}' will be returned. Additionally, the time the log was\n-     * last accessed will be updated to the current time in milliseconds, and if the log's timer was cancelled, it will be restarted.\n-     * \n-     * @param name\n-     *            the associated name by which to look up the desired {@link ActiveQueryLog}. This will typically be the name of a table or query logic.\n-     * @return the existing or new {@link ActiveQueryLog} for the name\n-     */\n-    public static ActiveQueryLog getInstance(String name) {\n-        // Return the default instance if the name is blank.\n-        if (StringUtils.isBlank(name)) {\n-            name = DEFAULT_NAME;\n-        }\n-        \n-        // Initialize the log cache if necessary.\n-        if (ActiveQueryLog.logCache == null) {\n-            synchronized (ActiveQueryLog.logCacheLock) {\n-                if (ActiveQueryLog.logCache == null) {\n-                    ActiveQueryLog.logCache = Caffeine.newBuilder().build();\n-                }\n-            }\n-        }\n-        \n-        // If no log currently exists for the name, create one.\n-        ActiveQueryLog log;\n+\n+  public static final String DEFAULT_NAME = \"default_log\";\n+  private static final String DEFAULT_EMPTY_QUERY_ID = new UUID(0, 0).toString();\n+  private static final Logger log = Logger.getLogger(ActiveQueryLog.class);\n+  private static Cache<String, ActiveQueryLog> logCache = null;\n+  private static final Object logCacheLock = new Object();\n+  private static AccumuloConfiguration conf = null;\n+\n+  // Accumulo properties\n+  public static final String MAX_IDLE = \"datawave.query.active.maxIdleMs\";\n+  public static final String LOG_PERIOD = \"datawave.query.active.logPeriodMs\";\n+  public static final String LOG_MAX_QUERIES = \"datawave.query.active.logMaxQueries\";\n+  public static final String WINDOW_SIZE = \"datawave.query.active.windowSize\";\n+  private static final long HOURS_24_MS = TimeUnit.MILLISECONDS.convert(24, TimeUnit.HOURS);\n+  private static final long MINUTES_15_MS = TimeUnit.MILLISECONDS.convert(15, TimeUnit.MINUTES);\n+  private static final long MINUTES_1_MS = TimeUnit.MILLISECONDS.convert(1, TimeUnit.MINUTES);\n+\n+  // Changeable via Accumulo properties\n+  volatile private long maxIdle = MINUTES_15_MS;\n+  volatile private long logPeriod = MINUTES_1_MS;\n+  volatile private int logMaxQueries = 5;\n+  volatile private int windowSize = 10;\n+  private final AtomicLong lastAccess = new AtomicLong(System.currentTimeMillis());\n+\n+  private Cache<String, ActiveQuery> CACHE = null;\n+  private final ReentrantReadWriteLock cacheLock = new ReentrantReadWriteLock();\n+  private Timer timer = null;\n+  private TimerTask timerTask = null;\n+\n+  private final String name;\n+\n+  synchronized public static void setConfig(final AccumuloConfiguration conf) {\n+    if (conf != null) {\n+      if (ActiveQueryLog.conf == null || conf.getUpdateCount() > ActiveQueryLog.conf.getUpdateCount()) {\n+        ActiveQueryLog.conf = conf;\n+      }\n+      // Do not allow access to the cache while updating each log's settings.\n+      if (logCache != null) {\n         synchronized (ActiveQueryLog.logCacheLock) {\n-            log = ActiveQueryLog.logCache.getIfPresent(name);\n-            if (log == null) {\n-                log = new ActiveQueryLog(conf, name);\n-                ActiveQueryLog.logCache.put(name, log);\n-            }\n-        }\n-        \n-        updateLastAccessedAndRestartCancelledTimer(log);\n-        \n-        return log;\n-    }\n-    \n-    private static void updateLastAccessedAndRestartCancelledTimer(ActiveQueryLog log) {\n-        log.touch();\n-        if (log.timer == null) {\n-            log.setLogPeriod(log.logPeriod);\n+          ConcurrentMap<String, ActiveQueryLog> logMap = logCache.asMap();\n+          logMap.values().forEach(log -> log.checkSettings(conf, false));\n         }\n+      }\n     }\n-    \n-    private ActiveQueryLog() {\n-        this(null, null);\n+  }\n+\n+  /**\n+   * Return the default {@link ActiveQueryLog} instance. The time the instance was last accessed will be updated to the current time in milliseconds, and if\n+   * the instance's timer was cancelled, it will be restarted.\n+   *\n+   * @return the default {@link ActiveQueryLog} instance\n+   */\n+  public static ActiveQueryLog getInstance() {\n+    return getInstance(DEFAULT_NAME);\n+  }\n+\n+  /**\n+   * Return the {@link ActiveQueryLog} instance associated with the specified name. If one does not exist, it will be created.\n+   * <p>\n+   * If the specified name is null or blank, the default instance with the name '{@value #DEFAULT_NAME}' will be returned. Additionally, the time the log was\n+   * last accessed will be updated to the current time in milliseconds, and if the log's timer was cancelled, it will be restarted.\n+   *\n+   * @param name the associated name by which to look up the desired {@link ActiveQueryLog}. This will typically be the name of a table or query logic.\n+   * @return the existing or new {@link ActiveQueryLog} for the name\n+   */\n+  public static ActiveQueryLog getInstance(String name) {\n+    // Return the default instance if the name is blank.\n+    if (StringUtils.isBlank(name)) {\n+      name = DEFAULT_NAME;\n     }\n-    \n-    private ActiveQueryLog(AccumuloConfiguration conf, String name) {\n-        if (conf != null) {\n-            checkSettings(conf, true);\n-        } else {\n-            // use the default values\n-            setLogPeriod(this.logPeriod);\n-            setMaxIdle(this.maxIdle);\n+\n+    // Initialize the log cache if necessary.\n+    if (ActiveQueryLog.logCache == null) {\n+      synchronized (ActiveQueryLog.logCacheLock) {\n+        if (ActiveQueryLog.logCache == null) {\n+          ActiveQueryLog.logCache = Caffeine.newBuilder().build();\n         }\n-        this.name = name;\n+      }\n     }\n-    \n-    private void touch() {\n-        this.lastAccess.set(System.currentTimeMillis());\n+\n+    // If no log currently exists for the name, create one.\n+    ActiveQueryLog log;\n+    synchronized (ActiveQueryLog.logCacheLock) {\n+      log = ActiveQueryLog.logCache.getIfPresent(name);\n+      if (log == null) {\n+        log = new ActiveQueryLog(conf, name);\n+        ActiveQueryLog.logCache.put(name, log);\n+      }\n     }\n-    \n-    long getLastAccess() {\n-        return this.lastAccess.get();\n+\n+    updateLastAccessedAndRestartCancelledTimer(log);\n+\n+    return log;\n+  }\n+\n+  private static void updateLastAccessedAndRestartCancelledTimer(ActiveQueryLog log) {\n+    log.touch();\n+    if (log.timer == null) {\n+      log.setLogPeriod(log.logPeriod);\n     }\n-    \n-    synchronized private void cancelTimer() {\n-        this.timer.cancel();\n-        this.timer = null;\n+  }\n+\n+  private ActiveQueryLog() {\n+    this(null, null);\n+  }\n+\n+  private ActiveQueryLog(AccumuloConfiguration conf, String name) {\n+    if (conf != null) {\n+      checkSettings(conf, true);\n+    } else {\n+      // use the default values\n+      setLogPeriod(this.logPeriod);\n+      setMaxIdle(this.maxIdle);\n     }\n-    \n-    synchronized public void setLogPeriod(long logPeriod) {\n-        if (logPeriod > 0) {\n-            if (logPeriod != this.logPeriod || this.timer == null) {\n-                // this.timer will be null on initial call within a classloader\n-                // this.timer will be null if it was shut down due to inactivity\n-                // create timer and schedule a periodic check for inactivity\n-                if (this.timer == null) {\n-                    this.timer = new Timer(\"ActiveQueryLog\");\n-                    this.timer.schedule(new TimerTask() {\n-                        @Override\n-                        public void run() {\n-                            long elapsed = System.currentTimeMillis() - ActiveQueryLog.this.getLastAccess();\n-                            // if no queries have been logged in a\n-                            // long time then inactivate the timer\n-                            if (elapsed > HOURS_24_MS) {\n-                                ActiveQueryLog.this.cancelTimer();\n-                            }\n-                        }\n-                    }, MINUTES_15_MS, MINUTES_15_MS);\n-                }\n-                if (this.timerTask != null) {\n-                    this.timerTask.cancel();\n-                }\n-                this.timerTask = new ActiveQueryTimerTask();\n-                this.logPeriod = logPeriod;\n-                this.timer.schedule(this.timerTask, this.logPeriod, this.logPeriod);\n+    this.name = name;\n+  }\n+\n+  private void touch() {\n+    this.lastAccess.set(System.currentTimeMillis());\n+  }\n+\n+  long getLastAccess() {\n+    return this.lastAccess.get();\n+  }\n+\n+  synchronized private void cancelTimer() {\n+    this.timer.cancel();\n+    this.timer = null;\n+  }\n+\n+  synchronized public void setLogPeriod(long logPeriod) {\n+    if (logPeriod > 0) {\n+      if (logPeriod != this.logPeriod || this.timer == null) {\n+        // this.timer will be null on initial call within a classloader\n+        // this.timer will be null if it was shut down due to inactivity\n+        // create timer and schedule a periodic check for inactivity\n+        if (this.timer == null) {\n+          this.timer = new Timer(\"ActiveQueryLog\");\n+          this.timer.schedule(new TimerTask() {\n+            @Override\n+            public void run() {\n+              long elapsed = System.currentTimeMillis() - ActiveQueryLog.this.getLastAccess();\n+              // if no queries have been logged in a\n+              // long time then inactivate the timer\n+              if (elapsed > HOURS_24_MS) {\n+                ActiveQueryLog.this.cancelTimer();\n+              }\n             }\n-        } else {\n-            log.error(\"Bad value: (\" + logPeriod + \") for logPeriod\");\n+          }, MINUTES_15_MS, MINUTES_15_MS);\n+        }\n+        if (this.timerTask != null) {\n+          this.timerTask.cancel();\n         }\n+        this.timerTask = new ActiveQueryTimerTask();\n+        this.logPeriod = logPeriod;\n+        this.timer.schedule(this.timerTask, this.logPeriod, this.logPeriod);\n+      }\n+    } else {\n+      log.error(\"Bad value: (\" + logPeriod + \") for logPeriod\");\n     }\n-    \n-    synchronized public void setLogMaxQueries(int logMaxQueries) {\n-        this.logMaxQueries = logMaxQueries;\n+  }\n+\n+  synchronized public void setLogMaxQueries(int logMaxQueries) {\n+    this.logMaxQueries = logMaxQueries;\n+  }\n+\n+  synchronized public void setWindowSize(int windowSize) {\n+    if (windowSize > 0) {\n+      this.windowSize = windowSize;\n+    } else {\n+      log.error(\"Bad value: (\" + windowSize + \") for windowSize\");\n     }\n-    \n-    synchronized public void setWindowSize(int windowSize) {\n-        if (windowSize > 0) {\n-            this.windowSize = windowSize;\n-        } else {\n-            log.error(\"Bad value: (\" + windowSize + \") for windowSize\");\n+  }\n+\n+  public void setMaxIdle(long maxIdle) {\n+    if (this.maxIdle != maxIdle || this.CACHE == null) {\n+      if (maxIdle > 0) {\n+        cacheLock.writeLock().lock();\n+        try {\n+          Cache<String, ActiveQuery> newCache = setupCache(maxIdle);\n+          if (this.CACHE == null) {\n+            this.CACHE = newCache;\n+          } else {\n+            Cache<String, ActiveQuery> oldCache = this.CACHE;\n+            this.CACHE = newCache;\n+            this.CACHE.putAll(oldCache.asMap());\n+          }\n+        } finally {\n+          cacheLock.writeLock().unlock();\n         }\n+        this.maxIdle = maxIdle;\n+      } else {\n+        log.error(\"Bad value: (\" + maxIdle + \") for maxIdle\");\n+      }\n     }\n-    \n-    public void setMaxIdle(long maxIdle) {\n-        if (this.maxIdle != maxIdle || this.CACHE == null) {\n-            if (maxIdle > 0) {\n-                cacheLock.writeLock().lock();\n-                try {\n-                    Cache<String,ActiveQuery> newCache = setupCache(maxIdle);\n-                    if (this.CACHE == null) {\n-                        this.CACHE = newCache;\n-                    } else {\n-                        Cache<String,ActiveQuery> oldCache = this.CACHE;\n-                        this.CACHE = newCache;\n-                        this.CACHE.putAll(oldCache.asMap());\n-                    }\n-                } finally {\n-                    cacheLock.writeLock().unlock();\n-                }\n-                this.maxIdle = maxIdle;\n-            } else {\n-                log.error(\"Bad value: (\" + maxIdle + \") for maxIdle\");\n-            }\n-        }\n+  }\n+\n+  private void checkSettings(AccumuloConfiguration conf, boolean useDefaults) {\n+\n+    String maxIdleStr = conf.get(MAX_IDLE);\n+    if (maxIdleStr != null) {\n+      try {\n+        setMaxIdle(Long.parseLong(maxIdleStr));\n+      } catch (NumberFormatException e) {\n+        log.error(\"Bad value: (\" + maxIdleStr + \") in \" + MAX_IDLE + \" : \" + e.getMessage());\n+      }\n+    } else if (useDefaults) {\n+      setMaxIdle(this.maxIdle);\n     }\n-    \n-    private void checkSettings(AccumuloConfiguration conf, boolean useDefaults) {\n-        \n-        String maxIdleStr = conf.get(MAX_IDLE);\n-        if (maxIdleStr != null) {\n-            try {\n-                setMaxIdle(Long.parseLong(maxIdleStr));\n-            } catch (NumberFormatException e) {\n-                log.error(\"Bad value: (\" + maxIdleStr + \") in \" + MAX_IDLE + \" : \" + e.getMessage());\n-            }\n-        } else if (useDefaults) {\n-            setMaxIdle(this.maxIdle);\n-        }\n-        \n-        String logPeriodStr = conf.get(LOG_PERIOD);\n-        if (logPeriodStr != null) {\n-            try {\n-                setLogPeriod(Long.parseLong(logPeriodStr));\n-            } catch (NumberFormatException e) {\n-                log.error(\"Bad value: (\" + logPeriodStr + \") in \" + LOG_PERIOD + \" : \" + e.getMessage());\n-            }\n-        } else if (useDefaults) {\n-            setLogPeriod(this.logPeriod);\n-        }\n-        \n-        String logMaxQueriesStr = conf.get(LOG_MAX_QUERIES);\n-        if (logMaxQueriesStr != null) {\n-            try {\n-                setLogMaxQueries(Integer.parseInt(logMaxQueriesStr));\n-            } catch (NumberFormatException e) {\n-                log.error(\"Bad value: (\" + logMaxQueriesStr + \") in \" + LOG_MAX_QUERIES + \" : \" + e.getMessage());\n-            }\n-        }\n-        \n-        String windowSizeStr = conf.get(WINDOW_SIZE);\n-        if (windowSizeStr != null) {\n-            try {\n-                setWindowSize(Integer.parseInt(windowSizeStr));\n-            } catch (NumberFormatException e) {\n-                log.error(\"Bad value: (\" + windowSizeStr + \") in \" + WINDOW_SIZE + \" : \" + e.getMessage());\n-            }\n-        }\n+\n+    String logPeriodStr = conf.get(LOG_PERIOD);\n+    if (logPeriodStr != null) {\n+      try {\n+        setLogPeriod(Long.parseLong(logPeriodStr));\n+      } catch (NumberFormatException e) {\n+        log.error(\"Bad value: (\" + logPeriodStr + \") in \" + LOG_PERIOD + \" : \" + e.getMessage());\n+      }\n+    } else if (useDefaults) {\n+      setLogPeriod(this.logPeriod);\n     }\n-    \n-    private Cache<String,ActiveQuery> setupCache(long maxIdle) {\n-        Caffeine<Object,Object> caffeine = Caffeine.newBuilder();\n-        caffeine.expireAfterAccess(maxIdle, TimeUnit.MILLISECONDS);\n-        return caffeine.build();\n+\n+    String logMaxQueriesStr = conf.get(LOG_MAX_QUERIES);\n+    if (logMaxQueriesStr != null) {\n+      try {\n+        setLogMaxQueries(Integer.parseInt(logMaxQueriesStr));\n+      } catch (NumberFormatException e) {\n+        log.error(\"Bad value: (\" + logMaxQueriesStr + \") in \" + LOG_MAX_QUERIES + \" : \" + e.getMessage());\n+      }\n     }\n-    \n-    public void remove(String queryId, Range range) {\n-        ActiveQuery activeQuery = get(queryId);\n-        int numActiveRanges = activeQuery.removeRange(range);\n-        if (numActiveRanges == 0) {\n-            cacheLock.readLock().lock();\n-            try {\n-                this.CACHE.invalidate(queryIdFor(queryId));\n-            } finally {\n-                cacheLock.readLock().unlock();\n-            }\n-        }\n+\n+    String windowSizeStr = conf.get(WINDOW_SIZE);\n+    if (windowSizeStr != null) {\n+      try {\n+        setWindowSize(Integer.parseInt(windowSizeStr));\n+      } catch (NumberFormatException e) {\n+        log.error(\"Bad value: (\" + windowSizeStr + \") in \" + WINDOW_SIZE + \" : \" + e.getMessage());\n+      }\n     }\n-    \n-    private String queryIdFor(String queryId) {\n-        return (queryId == null ? DEFAULT_EMPTY_QUERY_ID : queryId);\n+  }\n+\n+  private Cache<String, ActiveQuery> setupCache(long maxIdle) {\n+    Caffeine<Object, Object> caffeine = Caffeine.newBuilder();\n+    caffeine.expireAfterAccess(maxIdle, TimeUnit.MILLISECONDS);\n+    return caffeine.build();\n+  }\n+\n+  public void remove(String queryId, Range range) {\n+    ActiveQuery activeQuery = get(queryId);\n+    int numActiveRanges = activeQuery.removeRange(range);\n+    if (numActiveRanges == 0) {\n+      cacheLock.readLock().lock();\n+      try {\n+        this.CACHE.invalidate(queryIdFor(queryId));\n+      } finally {\n+        cacheLock.readLock().unlock();\n+      }\n     }\n-    \n-    public ActiveQuery get(String queryId) {\n-        ActiveQuery activeQuery;\n-        cacheLock.readLock().lock();\n-        try {\n-            activeQuery = this.CACHE.get(queryIdFor(queryId), s -> new ActiveQuery(queryIdFor(queryId), this.windowSize, name));\n-        } finally {\n-            cacheLock.readLock().unlock();\n-        }\n-        return activeQuery;\n+  }\n+\n+  private String queryIdFor(String queryId) {\n+    return (queryId == null ? DEFAULT_EMPTY_QUERY_ID : queryId);\n+  }\n+\n+  public ActiveQuery get(String queryId) {\n+    ActiveQuery activeQuery;\n+    cacheLock.readLock().lock();\n+    try {\n+      activeQuery =\n+          this.CACHE.get(queryIdFor(queryId), s -> new ActiveQuery(queryIdFor(queryId), this.windowSize, name));\n+    } finally {\n+      cacheLock.readLock().unlock();\n     }\n-    \n-    class ActiveQueryTimerTask extends TimerTask {\n-        \n-        public ActiveQueryTimerTask() {}\n-        \n-        @Override\n-        public void run() {\n-            List<ActiveQuerySnapshot> activeQueryList = new ArrayList<>();\n-            cacheLock.readLock().lock();\n-            try {\n-                for (ActiveQuery q : ActiveQueryLog.this.CACHE.asMap().values()) {\n-                    activeQueryList.add(q.snapshot());\n-                }\n-            } finally {\n-                cacheLock.readLock().unlock();\n-            }\n-            \n-            activeQueryList.sort(ActiveQuerySnapshot.greatestElapsedTime);\n-            \n-            List<ActiveQuerySnapshot> sublist = activeQueryList;\n-            if (ActiveQueryLog.this.logMaxQueries > 0) {\n-                sublist = activeQueryList.subList(0, Math.min(ActiveQueryLog.this.logMaxQueries, activeQueryList.size()));\n-            }\n-            \n-            // ensure that the timer doesn't get cancelled if we have queries being logged\n-            if (sublist.size() > 0) {\n-                ActiveQueryLog.this.touch();\n-            }\n-            \n-            for (ActiveQuerySnapshot q : sublist) {\n-                log.debug(q.toString());\n-            }\n+    return activeQuery;\n+  }\n+\n+  class ActiveQueryTimerTask extends TimerTask {\n+\n+    public ActiveQueryTimerTask() {\n+    }\n+\n+    @Override\n+    public void run() {\n+      List<ActiveQuerySnapshot> activeQueryList = new ArrayList<>();\n+      cacheLock.readLock().lock();\n+      try {\n+        for (ActiveQuery q : ActiveQueryLog.this.CACHE.asMap().values()) {\n+          activeQueryList.add(q.snapshot());\n         }\n+      } finally {\n+        cacheLock.readLock().unlock();\n+      }\n+\n+      activeQueryList.sort(ActiveQuerySnapshot.greatestElapsedTime);\n+\n+      List<ActiveQuerySnapshot> sublist = activeQueryList;\n+      if (ActiveQueryLog.this.logMaxQueries > 0) {\n+        sublist = activeQueryList.subList(0, Math.min(ActiveQueryLog.this.logMaxQueries, activeQueryList.size()));\n+      }\n+\n+      // ensure that the timer doesn't get cancelled if we have queries being logged\n+      if (sublist.size() > 0) {\n+        ActiveQueryLog.this.touch();\n+      }\n+\n+      for (ActiveQuerySnapshot q : sublist) {\n+        log.debug(q.toString());\n+      }\n     }\n+  }\n }\n",
            "diff_size": 409
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "5",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/95/ActiveQueryLog.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/95/ActiveQueryLog.java\nindex 9f31cb09dc4..d1bb9ee39d6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/95/ActiveQueryLog.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/95/ActiveQueryLog.java\n@@ -143,13 +143,13 @@ public class ActiveQueryLog {\n     long getLastAccess() {\n         return this.lastAccess.get();\n     }\n-    \n-    synchronized private void cancelTimer() {\n+\n+        synchronized private void cancelTimer() {\n         this.timer.cancel();\n         this.timer = null;\n     }\n-    \n-    synchronized public void setLogPeriod(long logPeriod) {\n+\n+        synchronized public void setLogPeriod(long logPeriod) {\n         if (logPeriod > 0) {\n             if (logPeriod != this.logPeriod || this.timer == null) {\n                 // this.timer will be null on initial call within a classloader\n@@ -180,12 +180,12 @@ public class ActiveQueryLog {\n             log.error(\"Bad value: (\" + logPeriod + \") for logPeriod\");\n         }\n     }\n-    \n-    synchronized public void setLogMaxQueries(int logMaxQueries) {\n+\n+        synchronized public void setLogMaxQueries(int logMaxQueries) {\n         this.logMaxQueries = logMaxQueries;\n     }\n-    \n-    synchronized public void setWindowSize(int windowSize) {\n+\n+        synchronized public void setWindowSize(int windowSize) {\n         if (windowSize > 0) {\n             this.windowSize = windowSize;\n         } else {\n@@ -326,4 +326,4 @@ public class ActiveQueryLog {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "5",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/95/ActiveQueryLog.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/95/ActiveQueryLog.java\nindex 9f31cb09dc4..e60c0698444 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/95/ActiveQueryLog.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/95/ActiveQueryLog.java\n@@ -6,7 +6,6 @@ import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.data.Range;\n import org.apache.commons.lang.StringUtils;\n import org.apache.log4j.Logger;\n-\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Timer;\n@@ -17,8 +16,8 @@ import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+\n public class ActiveQueryLog {\n-    \n     public static final String DEFAULT_NAME = \"default_log\";\n     private static final String DEFAULT_EMPTY_QUERY_ID = new UUID(0, 0).toString();\n     private static final Logger log = Logger.getLogger(ActiveQueryLog.class);\n@@ -27,9 +26,13 @@ public class ActiveQueryLog {\n     private static AccumuloConfiguration conf = null;\n     \n     // Accumulo properties\n+\n     public static final String MAX_IDLE = \"datawave.query.active.maxIdleMs\";\n+\n     public static final String LOG_PERIOD = \"datawave.query.active.logPeriodMs\";\n+\n     public static final String LOG_MAX_QUERIES = \"datawave.query.active.logMaxQueries\";\n+\n     public static final String WINDOW_SIZE = \"datawave.query.active.windowSize\";\n     private static final long HOURS_24_MS = TimeUnit.MILLISECONDS.convert(24, TimeUnit.HOURS);\n     private static final long MINUTES_15_MS = TimeUnit.MILLISECONDS.convert(15, TimeUnit.MINUTES);\n@@ -41,20 +44,19 @@ public class ActiveQueryLog {\n     volatile private int logMaxQueries = 5;\n     volatile private int windowSize = 10;\n     private final AtomicLong lastAccess = new AtomicLong(System.currentTimeMillis());\n-    \n     private Cache<String,ActiveQuery> CACHE = null;\n     private final ReentrantReadWriteLock cacheLock = new ReentrantReadWriteLock();\n     private Timer timer = null;\n     private TimerTask timerTask = null;\n-    \n     private final String name;\n-    \n     synchronized public static void setConfig(final AccumuloConfiguration conf) {\n         if (conf != null) {\n             if (ActiveQueryLog.conf == null || conf.getUpdateCount() > ActiveQueryLog.conf.getUpdateCount()) {\n                 ActiveQueryLog.conf = conf;\n             }\n             // Do not allow access to the cache while updating each log's settings.\n+\n+\n             if (logCache != null) {\n                 synchronized (ActiveQueryLog.logCacheLock) {\n                     ConcurrentMap<String,ActiveQueryLog> logMap = logCache.asMap();\n@@ -70,6 +72,7 @@ public class ActiveQueryLog {\n      * \n      * @return the default {@link ActiveQueryLog} instance\n      */\n+\n     public static ActiveQueryLog getInstance() {\n         return getInstance(DEFAULT_NAME);\n     }\n@@ -84,6 +87,7 @@ public class ActiveQueryLog {\n      *            the associated name by which to look up the desired {@link ActiveQueryLog}. This will typically be the name of a table or query logic.\n      * @return the existing or new {@link ActiveQueryLog} for the name\n      */\n+\n     public static ActiveQueryLog getInstance(String name) {\n         // Return the default instance if the name is blank.\n         if (StringUtils.isBlank(name)) {\n@@ -91,6 +95,8 @@ public class ActiveQueryLog {\n         }\n         \n         // Initialize the log cache if necessary.\n+\n+\n         if (ActiveQueryLog.logCache == null) {\n             synchronized (ActiveQueryLog.logCacheLock) {\n                 if (ActiveQueryLog.logCache == null) {\n@@ -100,6 +106,7 @@ public class ActiveQueryLog {\n         }\n         \n         // If no log currently exists for the name, create one.\n+\n         ActiveQueryLog log;\n         synchronized (ActiveQueryLog.logCacheLock) {\n             log = ActiveQueryLog.logCache.getIfPresent(name);\n@@ -108,23 +115,21 @@ public class ActiveQueryLog {\n                 ActiveQueryLog.logCache.put(name, log);\n             }\n         }\n-        \n         updateLastAccessedAndRestartCancelledTimer(log);\n-        \n         return log;\n     }\n-    \n+\n     private static void updateLastAccessedAndRestartCancelledTimer(ActiveQueryLog log) {\n         log.touch();\n         if (log.timer == null) {\n             log.setLogPeriod(log.logPeriod);\n         }\n     }\n-    \n+\n     private ActiveQueryLog() {\n         this(null, null);\n     }\n-    \n+\n     private ActiveQueryLog(AccumuloConfiguration conf, String name) {\n         if (conf != null) {\n             checkSettings(conf, true);\n@@ -135,20 +140,20 @@ public class ActiveQueryLog {\n         }\n         this.name = name;\n     }\n-    \n+\n     private void touch() {\n         this.lastAccess.set(System.currentTimeMillis());\n     }\n-    \n+\n     long getLastAccess() {\n         return this.lastAccess.get();\n     }\n-    \n+\n     synchronized private void cancelTimer() {\n         this.timer.cancel();\n         this.timer = null;\n     }\n-    \n+\n     synchronized public void setLogPeriod(long logPeriod) {\n         if (logPeriod > 0) {\n             if (logPeriod != this.logPeriod || this.timer == null) {\n@@ -158,17 +163,19 @@ public class ActiveQueryLog {\n                 if (this.timer == null) {\n                     this.timer = new Timer(\"ActiveQueryLog\");\n                     this.timer.schedule(new TimerTask() {\n-                        @Override\n-                        public void run() {\n-                            long elapsed = System.currentTimeMillis() - ActiveQueryLog.this.getLastAccess();\n+                                            @Override\n+                                            public void run() {\n+                                                long elapsed = System.currentTimeMillis() - ActiveQueryLog.this.getLastAccess();\n                             // if no queries have been logged in a\n                             // long time then inactivate the timer\n-                            if (elapsed > HOURS_24_MS) {\n-                                ActiveQueryLog.this.cancelTimer();\n-                            }\n-                        }\n-                    }, MINUTES_15_MS, MINUTES_15_MS);\n+                                                if (elapsed > HOURS_24_MS) {\n+                                                    ActiveQueryLog.this.cancelTimer();\n+                                                }\n+                                            }\n+                                        }, MINUTES_15_MS, MINUTES_15_MS);\n                 }\n+\n+\n                 if (this.timerTask != null) {\n                     this.timerTask.cancel();\n                 }\n@@ -180,11 +187,11 @@ public class ActiveQueryLog {\n             log.error(\"Bad value: (\" + logPeriod + \") for logPeriod\");\n         }\n     }\n-    \n+\n     synchronized public void setLogMaxQueries(int logMaxQueries) {\n         this.logMaxQueries = logMaxQueries;\n     }\n-    \n+\n     synchronized public void setWindowSize(int windowSize) {\n         if (windowSize > 0) {\n             this.windowSize = windowSize;\n@@ -192,7 +199,7 @@ public class ActiveQueryLog {\n             log.error(\"Bad value: (\" + windowSize + \") for windowSize\");\n         }\n     }\n-    \n+\n     public void setMaxIdle(long maxIdle) {\n         if (this.maxIdle != maxIdle || this.CACHE == null) {\n             if (maxIdle > 0) {\n@@ -215,9 +222,8 @@ public class ActiveQueryLog {\n             }\n         }\n     }\n-    \n+\n     private void checkSettings(AccumuloConfiguration conf, boolean useDefaults) {\n-        \n         String maxIdleStr = conf.get(MAX_IDLE);\n         if (maxIdleStr != null) {\n             try {\n@@ -228,7 +234,7 @@ public class ActiveQueryLog {\n         } else if (useDefaults) {\n             setMaxIdle(this.maxIdle);\n         }\n-        \n+\n         String logPeriodStr = conf.get(LOG_PERIOD);\n         if (logPeriodStr != null) {\n             try {\n@@ -239,7 +245,7 @@ public class ActiveQueryLog {\n         } else if (useDefaults) {\n             setLogPeriod(this.logPeriod);\n         }\n-        \n+\n         String logMaxQueriesStr = conf.get(LOG_MAX_QUERIES);\n         if (logMaxQueriesStr != null) {\n             try {\n@@ -248,7 +254,7 @@ public class ActiveQueryLog {\n                 log.error(\"Bad value: (\" + logMaxQueriesStr + \") in \" + LOG_MAX_QUERIES + \" : \" + e.getMessage());\n             }\n         }\n-        \n+\n         String windowSizeStr = conf.get(WINDOW_SIZE);\n         if (windowSizeStr != null) {\n             try {\n@@ -258,13 +264,13 @@ public class ActiveQueryLog {\n             }\n         }\n     }\n-    \n+\n     private Cache<String,ActiveQuery> setupCache(long maxIdle) {\n         Caffeine<Object,Object> caffeine = Caffeine.newBuilder();\n         caffeine.expireAfterAccess(maxIdle, TimeUnit.MILLISECONDS);\n         return caffeine.build();\n     }\n-    \n+\n     public void remove(String queryId, Range range) {\n         ActiveQuery activeQuery = get(queryId);\n         int numActiveRanges = activeQuery.removeRange(range);\n@@ -277,11 +283,11 @@ public class ActiveQueryLog {\n             }\n         }\n     }\n-    \n+\n     private String queryIdFor(String queryId) {\n         return (queryId == null ? DEFAULT_EMPTY_QUERY_ID : queryId);\n     }\n-    \n+\n     public ActiveQuery get(String queryId) {\n         ActiveQuery activeQuery;\n         cacheLock.readLock().lock();\n@@ -292,11 +298,11 @@ public class ActiveQueryLog {\n         }\n         return activeQuery;\n     }\n-    \n+\n+\n     class ActiveQueryTimerTask extends TimerTask {\n-        \n         public ActiveQueryTimerTask() {}\n-        \n+\n         @Override\n         public void run() {\n             List<ActiveQuerySnapshot> activeQueryList = new ArrayList<>();\n@@ -308,22 +314,22 @@ public class ActiveQueryLog {\n             } finally {\n                 cacheLock.readLock().unlock();\n             }\n-            \n             activeQueryList.sort(ActiveQuerySnapshot.greatestElapsedTime);\n-            \n+\n             List<ActiveQuerySnapshot> sublist = activeQueryList;\n             if (ActiveQueryLog.this.logMaxQueries > 0) {\n                 sublist = activeQueryList.subList(0, Math.min(ActiveQueryLog.this.logMaxQueries, activeQueryList.size()));\n             }\n             \n             // ensure that the timer doesn't get cancelled if we have queries being logged\n+\n+\n             if (sublist.size() > 0) {\n                 ActiveQueryLog.this.touch();\n             }\n-            \n             for (ActiveQuerySnapshot q : sublist) {\n                 log.debug(q.toString());\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 58
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "5",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "5",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}