{
    "project_name": "codefollower-H2-Research",
    "error_id": "125",
    "information": {
        "errors": [
            {
                "line": "219",
                "column": "23",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "//                } else {\n//                    if ((mask & IndexCondition.START) != 0) {\n//                    \t//\u4f8b\u5982:sql = \"select * from my_view where f2 > 'b1'\";\n//                    \t//\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n//                    \t//\u5728org.h2.index.IndexCondition.getMask(ArrayList<IndexCondition>)\u90a3\u91cc\u628a\n//                    \t//BIGGER_EQUAL\u3001BIGGER\u90fd\u5f53\u6210\u4e86START\uff0c\u800c\u8fd9\u91cc\u7edf\u4e00\u8f6c\u6210BIGGER_EQUAL\uff0c\u5f53view\u8981\u8fc7\u6ee4\u8bb0\u5f55\u65f6\u518d\u6309\u5927\u4e8e\u8fc7\u6ee4",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "219",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "220",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                },
                {
                    "line": "458",
                    "column": "30",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/125/ViewIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/125/ViewIndex.java\nindex 0b5b036217e..b0e87669482 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/125/ViewIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/125/ViewIndex.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import java.util.ArrayList;\n@@ -39,117 +40,117 @@ import org.h2.value.Value;\n  */\n public class ViewIndex extends BaseIndex implements SpatialIndex {\n \n-    private static final long MAX_AGE_NANOS =\n-            TimeUnit.MILLISECONDS.toNanos(Constants.VIEW_COST_CACHE_MAX_AGE);\n-\n-    private final TableView view;\n-    private final String querySQL;\n-    private final ArrayList<Parameter> originalParameters;\n-    private boolean recursive;\n-    private final int[] indexMasks;\n-    private Query query;\n-    private final Session createSession;\n-\n-    /**\n-     * The time in nanoseconds when this index (and its cost) was calculated.\n-     */\n-    private final long evaluatedAt;\n-\n-    /**\n-     * Constructor for the original index in {@link TableView}.\n-     *\n-     * @param view the table view\n-     * @param querySQL the query SQL\n-     * @param originalParameters the original parameters\n-     * @param recursive if the view is recursive\n-     */\n-    public ViewIndex(TableView view, String querySQL,\n-            ArrayList<Parameter> originalParameters, boolean recursive) {\n-        initBaseIndex(view, 0, null, null, IndexType.createNonUnique(false));\n-        this.view = view;\n-        this.querySQL = querySQL;\n-        this.originalParameters = originalParameters;\n-        this.recursive = recursive;\n-        columns = new Column[0];\n-        this.createSession = null;\n-        this.indexMasks = null;\n-        // this is a main index of TableView, it does not need eviction time\n-        // stamp\n-        evaluatedAt = Long.MIN_VALUE;\n-    }\n-\n-    /**\n-     * Constructor for plan item generation. Over this index the query will be\n-     * executed.\n-     *\n-     * @param view the table view\n-     * @param index the view index\n-     * @param session the session\n-     * @param masks the masks\n-     * @param filters table filters\n-     * @param filter current filter\n-     * @param sortOrder sort order\n-     */\n-    public ViewIndex(TableView view, ViewIndex index, Session session,\n-            int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n-        initBaseIndex(view, 0, null, null, IndexType.createNonUnique(false));\n-        this.view = view;\n-        this.querySQL = index.querySQL;\n-        this.originalParameters = index.originalParameters;\n-        this.recursive = index.recursive;\n-        this.indexMasks = masks;\n-        this.createSession = session;\n-        columns = new Column[0];\n-        if (!recursive) {\n-            query = getQuery(session, masks, filters, filter, sortOrder);\n-        }\n-        // we don't need eviction for recursive views since we can't calculate\n-        // their cost if it is a sub-query we don't need eviction as well\n-        // because the whole ViewIndex cache is getting dropped in\n-        // Session.prepareLocal\n-        evaluatedAt = recursive || view.getTopQuery() != null ? Long.MAX_VALUE : System.nanoTime();\n-    }\n-\n-    @Override\n-    public IndexLookupBatch createLookupBatch(TableFilter[] filters, int filter) {\n-        if (recursive) {\n-            // we do not support batching for recursive queries\n-            return null;\n-        }\n-        return JoinBatch.createViewIndexLookupBatch(this);\n-    }\n-\n-    public Session getSession() {\n-        return createSession;\n+  private static final long MAX_AGE_NANOS =\n+      TimeUnit.MILLISECONDS.toNanos(Constants.VIEW_COST_CACHE_MAX_AGE);\n+\n+  private final TableView view;\n+  private final String querySQL;\n+  private final ArrayList<Parameter> originalParameters;\n+  private boolean recursive;\n+  private final int[] indexMasks;\n+  private Query query;\n+  private final Session createSession;\n+\n+  /**\n+   * The time in nanoseconds when this index (and its cost) was calculated.\n+   */\n+  private final long evaluatedAt;\n+\n+  /**\n+   * Constructor for the original index in {@link TableView}.\n+   *\n+   * @param view               the table view\n+   * @param querySQL           the query SQL\n+   * @param originalParameters the original parameters\n+   * @param recursive          if the view is recursive\n+   */\n+  public ViewIndex(TableView view, String querySQL,\n+                   ArrayList<Parameter> originalParameters, boolean recursive) {\n+    initBaseIndex(view, 0, null, null, IndexType.createNonUnique(false));\n+    this.view = view;\n+    this.querySQL = querySQL;\n+    this.originalParameters = originalParameters;\n+    this.recursive = recursive;\n+    columns = new Column[0];\n+    this.createSession = null;\n+    this.indexMasks = null;\n+    // this is a main index of TableView, it does not need eviction time\n+    // stamp\n+    evaluatedAt = Long.MIN_VALUE;\n+  }\n+\n+  /**\n+   * Constructor for plan item generation. Over this index the query will be\n+   * executed.\n+   *\n+   * @param view      the table view\n+   * @param index     the view index\n+   * @param session   the session\n+   * @param masks     the masks\n+   * @param filters   table filters\n+   * @param filter    current filter\n+   * @param sortOrder sort order\n+   */\n+  public ViewIndex(TableView view, ViewIndex index, Session session,\n+                   int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n+    initBaseIndex(view, 0, null, null, IndexType.createNonUnique(false));\n+    this.view = view;\n+    this.querySQL = index.querySQL;\n+    this.originalParameters = index.originalParameters;\n+    this.recursive = index.recursive;\n+    this.indexMasks = masks;\n+    this.createSession = session;\n+    columns = new Column[0];\n+    if (!recursive) {\n+      query = getQuery(session, masks, filters, filter, sortOrder);\n     }\n-\n-    public boolean isExpired() {\n-        assert evaluatedAt != Long.MIN_VALUE : \"must not be called for main index of TableView\";\n-        return !recursive && view.getTopQuery() == null &&\n-                System.nanoTime() - evaluatedAt > MAX_AGE_NANOS;\n-    }\n-\n-    @Override\n-    public String getPlanSQL() {\n-        return query == null ? null : query.getPlanSQL();\n-    }\n-\n-    @Override\n-    public void close(Session session) {\n-        // nothing to do\n-    }\n-\n-    @Override\n-    public void add(Session session, Row row) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public void remove(Session session, Row row) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n+    // we don't need eviction for recursive views since we can't calculate\n+    // their cost if it is a sub-query we don't need eviction as well\n+    // because the whole ViewIndex cache is getting dropped in\n+    // Session.prepareLocal\n+    evaluatedAt = recursive || view.getTopQuery() != null ? Long.MAX_VALUE : System.nanoTime();\n+  }\n+\n+  @Override\n+  public IndexLookupBatch createLookupBatch(TableFilter[] filters, int filter) {\n+    if (recursive) {\n+      // we do not support batching for recursive queries\n+      return null;\n     }\n-\n-//<<<<<<< HEAD\n+    return JoinBatch.createViewIndexLookupBatch(this);\n+  }\n+\n+  public Session getSession() {\n+    return createSession;\n+  }\n+\n+  public boolean isExpired() {\n+    assert evaluatedAt != Long.MIN_VALUE : \"must not be called for main index of TableView\";\n+    return !recursive && view.getTopQuery() == null &&\n+        System.nanoTime() - evaluatedAt > MAX_AGE_NANOS;\n+  }\n+\n+  @Override\n+  public String getPlanSQL() {\n+    return query == null ? null : query.getPlanSQL();\n+  }\n+\n+  @Override\n+  public void close(Session session) {\n+    // nothing to do\n+  }\n+\n+  @Override\n+  public void add(Session session, Row row) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void remove(Session session, Row row) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  //<<<<<<< HEAD\n //    /**\n //     * A calculated cost value.\n //     */\n@@ -240,198 +241,198 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //        costCache.put(masksArray, cachedCost);\n //        return cost;\n //=======\n-    @Override\n-    public double getCost(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            HashSet<Column> allColumnsSet) {\n-        return recursive ? 1000 : query.getCost();\n+  @Override\n+  public double getCost(Session session, int[] masks,\n+                        TableFilter[] filters, int filter, SortOrder sortOrder,\n+                        HashSet<Column> allColumnsSet) {\n+    return recursive ? 1000 : query.getCost();\n+  }\n+\n+  @Override\n+  public Cursor find(Session session, SearchRow first, SearchRow last) {\n+    return find(session, first, last, null);\n+  }\n+\n+  @Override\n+  public Cursor findByGeometry(TableFilter filter, SearchRow first,\n+                               SearchRow last, SearchRow intersection) {\n+    return find(filter.getSession(), first, last, intersection);\n+  }\n+\n+  private static Query prepareSubQuery(String sql, Session session, int[] masks,\n+                                       TableFilter[] filters, int filter, SortOrder sortOrder) {\n+    assert filters != null;\n+    Prepared p;\n+    session.pushSubQueryInfo(masks, filters, filter, sortOrder);\n+    try {\n+      p = session.prepare(sql, true);\n+    } finally {\n+      session.popSubQueryInfo();\n     }\n-\n-    @Override\n-    public Cursor find(Session session, SearchRow first, SearchRow last) {\n-        return find(session, first, last, null);\n+    return (Query) p;\n+  }\n+\n+  private Cursor findRecursive(SearchRow first, SearchRow last) {\n+    assert recursive;\n+    // \u5982 WITH RECURSIVE my_tmp_table(f1,f2)\n+    // AS(select id,name from CreateViewTest UNION ALL select 1, 2) select f1, f2 from my_tmp_table\n+    // \u4e0d\u8fc7\u6709bug\n+    ResultInterface recResult = view.getRecursiveResult();\n+    if (recResult != null) {\n+      recResult.reset();\n+      return new ViewCursor(this, recResult, first, last);\n     }\n-\n-    @Override\n-    public Cursor findByGeometry(TableFilter filter, SearchRow first,\n-            SearchRow last, SearchRow intersection) {\n-        return find(filter.getSession(), first, last, intersection);\n+    if (query == null) {\n+      Parser parser = new Parser(createSession);\n+      parser.setRightsChecked(true);\n+      parser.setSuppliedParameterList(originalParameters);\n+      query = (Query) parser.prepare(querySQL);\n+      query.setNeverLazy(true);\n     }\n-\n-    private static Query prepareSubQuery(String sql, Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder) {\n-        assert filters != null;\n-        Prepared p;\n-        session.pushSubQueryInfo(masks, filters, filter, sortOrder);\n-        try {\n-            p = session.prepare(sql, true);\n-        } finally {\n-            session.popSubQueryInfo();\n-        }\n-        return (Query) p;\n+    if (!query.isUnion()) {\n+      throw DbException.get(ErrorCode.SYNTAX_ERROR_2,\n+          \"recursive queries without UNION\");\n     }\n-\n-    private Cursor findRecursive(SearchRow first, SearchRow last) {\n-        assert recursive;\n-        // \u5982 WITH RECURSIVE my_tmp_table(f1,f2)\n-        // AS(select id,name from CreateViewTest UNION ALL select 1, 2) select f1, f2 from my_tmp_table\n-        // \u4e0d\u8fc7\u6709bug\n-        ResultInterface recResult = view.getRecursiveResult();\n-        if (recResult != null) {\n-            recResult.reset();\n-            return new ViewCursor(this, recResult, first, last);\n-        }\n-        if (query == null) {\n-            Parser parser = new Parser(createSession);\n-            parser.setRightsChecked(true);\n-            parser.setSuppliedParameterList(originalParameters);\n-            query = (Query) parser.prepare(querySQL);\n-            query.setNeverLazy(true);\n-        }\n-        if (!query.isUnion()) {\n-            throw DbException.get(ErrorCode.SYNTAX_ERROR_2,\n-                    \"recursive queries without UNION\");\n-        }\n-        SelectUnion union = (SelectUnion) query;\n-        Query left = union.getLeft();\n-        // to ensure the last result is not closed\n-        left.disableCache();\n-        ResultInterface r = left.query(0);\n-        LocalResult result = union.getEmptyResult();\n-        // ensure it is not written to disk,\n-        // because it is not closed normally\n-        result.setMaxMemoryRows(Integer.MAX_VALUE);\n-        while (r.next()) {\n-            result.addRow(r.currentRow());\n-        }\n-        Query right = union.getRight();\n-        r.reset();\n-        view.setRecursiveResult(r);\n-        // to ensure the last result is not closed\n-        right.disableCache();\n-        while (true) {\n-            // \u5982 WITH RECURSIVE my_tmp_table(f1,f2)\n-            // AS(select id,name from CreateViewTest UNION ALL select 1, 2) select f1, f2 from my_tmp_table\n-            // \u4e0d\u8fc7\u6709bug\n-            // \u8fd9\u91cc\u4f1a\u4e00\u76f4\u662f\u6b7b\u5faa\u73af\uff0c\u56e0\u4e3aright.query(0)\u4e0d\u4f1a\u8fd4\u56de\u4e00\u4e2a\u7a7a\u7ed3\u679c\u96c6\n-            r = right.query(0);\n-            if (!r.hasNext()) {\n-                break;\n-            }\n-            while (r.next()) {\n-                result.addRow(r.currentRow());\n-            }\n-            r.reset();\n-            view.setRecursiveResult(r);\n-            // \u6211\u52a0\u4e0a\u7684\n-            // \u907f\u514d\u6b7b\u5faa\u73af\uff0c\u56e0\u4e3a\u6b64\u65f6union all\u7684\u53f3\u8fb9\u5b50\u53e5\u4e0d\u662f\u5f53\u524dview\n-            if (!right.getTables().contains(view)) {\n-                break;\n-            }\n-        }\n-        view.setRecursiveResult(null);\n-        result.done();\n-        return new ViewCursor(this, result, first, last);\n+    SelectUnion union = (SelectUnion) query;\n+    Query left = union.getLeft();\n+    // to ensure the last result is not closed\n+    left.disableCache();\n+    ResultInterface r = left.query(0);\n+    LocalResult result = union.getEmptyResult();\n+    // ensure it is not written to disk,\n+    // because it is not closed normally\n+    result.setMaxMemoryRows(Integer.MAX_VALUE);\n+    while (r.next()) {\n+      result.addRow(r.currentRow());\n     }\n-\n-    /**\n-     * Set the query parameters.\n-     *\n-     * @param session the session\n-     * @param first the lower bound\n-     * @param last the upper bound\n-     * @param intersection the intersection\n-     */\n-    public void setupQueryParameters(Session session, SearchRow first, SearchRow last,\n-            SearchRow intersection) {\n-        ArrayList<Parameter> paramList = query.getParameters();\n-        if (originalParameters != null) {\n-            for (int i = 0, size = originalParameters.size(); i < size; i++) {\n-                Parameter orig = originalParameters.get(i);\n-                int idx = orig.getIndex();\n-                Value value = orig.getValue(session);\n-                setParameter(paramList, idx, value);\n-            }\n-        }\n-        int len;\n-        if (first != null) {\n-            len = first.getColumnCount();\n-        } else if (last != null) {\n-            len = last.getColumnCount();\n-        } else if (intersection != null) {\n-            len = intersection.getColumnCount();\n-        } else {\n-            len = 0;\n-        }\n-        //view\u4e2d\u5df2\u7ed9select\u52a0\u4e86\u5916\u90e8\u6761\u4ef6\uff0c\u6240\u4ee5\u591a\u4e86Parameter\uff0c\u8fd9\u91cc\u5c31\u662f\u7ed9\u8fd9\u4e9bParameter\u8d4b\u503c\n-        int idx = view.getParameterOffset(originalParameters);\n-        for (int i = 0; i < len; i++) {\n-            int mask = indexMasks[i];\n-            if ((mask & IndexCondition.EQUALITY) != 0) {\n-                setParameter(paramList, idx++, first.getValue(i));\n-            }\n-            if ((mask & IndexCondition.START) != 0) {\n-                setParameter(paramList, idx++, first.getValue(i));\n-            }\n-            if ((mask & IndexCondition.END) != 0) {\n-                setParameter(paramList, idx++, last.getValue(i));\n-            }\n-            if ((mask & IndexCondition.SPATIAL_INTERSECTS) != 0) {\n-                setParameter(paramList, idx++, intersection.getValue(i));\n-            }\n-        }\n+    Query right = union.getRight();\n+    r.reset();\n+    view.setRecursiveResult(r);\n+    // to ensure the last result is not closed\n+    right.disableCache();\n+    while (true) {\n+      // \u5982 WITH RECURSIVE my_tmp_table(f1,f2)\n+      // AS(select id,name from CreateViewTest UNION ALL select 1, 2) select f1, f2 from my_tmp_table\n+      // \u4e0d\u8fc7\u6709bug\n+      // \u8fd9\u91cc\u4f1a\u4e00\u76f4\u662f\u6b7b\u5faa\u73af\uff0c\u56e0\u4e3aright.query(0)\u4e0d\u4f1a\u8fd4\u56de\u4e00\u4e2a\u7a7a\u7ed3\u679c\u96c6\n+      r = right.query(0);\n+      if (!r.hasNext()) {\n+        break;\n+      }\n+      while (r.next()) {\n+        result.addRow(r.currentRow());\n+      }\n+      r.reset();\n+      view.setRecursiveResult(r);\n+      // \u6211\u52a0\u4e0a\u7684\n+      // \u907f\u514d\u6b7b\u5faa\u73af\uff0c\u56e0\u4e3a\u6b64\u65f6union all\u7684\u53f3\u8fb9\u5b50\u53e5\u4e0d\u662f\u5f53\u524dview\n+      if (!right.getTables().contains(view)) {\n+        break;\n+      }\n     }\n-\n-    private Cursor find(Session session, SearchRow first, SearchRow last,\n-            SearchRow intersection) {\n-        if (recursive) {\n-            return findRecursive(first, last);\n-        }\n-        setupQueryParameters(session, first, last, intersection);\n-        ResultInterface result = query.query(0);\n-        return new ViewCursor(this, result, first, last);\n+    view.setRecursiveResult(null);\n+    result.done();\n+    return new ViewCursor(this, result, first, last);\n+  }\n+\n+  /**\n+   * Set the query parameters.\n+   *\n+   * @param session      the session\n+   * @param first        the lower bound\n+   * @param last         the upper bound\n+   * @param intersection the intersection\n+   */\n+  public void setupQueryParameters(Session session, SearchRow first, SearchRow last,\n+                                   SearchRow intersection) {\n+    ArrayList<Parameter> paramList = query.getParameters();\n+    if (originalParameters != null) {\n+      for (int i = 0, size = originalParameters.size(); i < size; i++) {\n+        Parameter orig = originalParameters.get(i);\n+        int idx = orig.getIndex();\n+        Value value = orig.getValue(session);\n+        setParameter(paramList, idx, value);\n+      }\n     }\n-\n-    private static void setParameter(ArrayList<Parameter> paramList, int x,\n-            Value v) {\n-        if (x >= paramList.size()) {\n-            // the parameter may be optimized away as in\n-            // select * from (select null as x) where x=1;\n-            return;\n-        }\n-        Parameter param = paramList.get(x);\n-        param.setValue(v);\n+    int len;\n+    if (first != null) {\n+      len = first.getColumnCount();\n+    } else if (last != null) {\n+      len = last.getColumnCount();\n+    } else if (intersection != null) {\n+      len = intersection.getColumnCount();\n+    } else {\n+      len = 0;\n     }\n-\n-    public Query getQuery() {\n-        return query;\n+    //view\u4e2d\u5df2\u7ed9select\u52a0\u4e86\u5916\u90e8\u6761\u4ef6\uff0c\u6240\u4ee5\u591a\u4e86Parameter\uff0c\u8fd9\u91cc\u5c31\u662f\u7ed9\u8fd9\u4e9bParameter\u8d4b\u503c\n+    int idx = view.getParameterOffset(originalParameters);\n+    for (int i = 0; i < len; i++) {\n+      int mask = indexMasks[i];\n+      if ((mask & IndexCondition.EQUALITY) != 0) {\n+        setParameter(paramList, idx++, first.getValue(i));\n+      }\n+      if ((mask & IndexCondition.START) != 0) {\n+        setParameter(paramList, idx++, first.getValue(i));\n+      }\n+      if ((mask & IndexCondition.END) != 0) {\n+        setParameter(paramList, idx++, last.getValue(i));\n+      }\n+      if ((mask & IndexCondition.SPATIAL_INTERSECTS) != 0) {\n+        setParameter(paramList, idx++, intersection.getValue(i));\n+      }\n     }\n+  }\n \n-    // \u76ee\u7684\u662f\u4e3a\u4e86\u5bf9indexColumns\u8d4b\u503c\uff0cindexColumns\u53e6\u6709\u5b83\u7528\n-    // \u6bd4\u5982\u5728org.h2.command.dml.Select.prepare()\u4e2d\u5c31\u6709\u5e94\u7528(cost = preparePlan\u90a3\u884c\u4ee3\u7801\u4e4b\u540e)\n-    private Query getQuery(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder) {\n-        Query q = prepareSubQuery(querySQL, session, masks, filters, filter, sortOrder);\n-        if (masks == null) {\n-            return q;\n-        }\n-        //\u6bd4\u5982AS SELECT top 2 id,name FROM CreateViewTest order by id\n-        //limitExpr\u548csort\u90fd\u4e0d\u4e3a\u7a7a\uff0c\u6b64\u65f6\u4e0d\u5141\u8bb8\u52a0\u5168\u5c40\u6761\u4ef6\u5230select\u4e2d\n-        if (!q.allowGlobalConditions()) {\n-            return q;\n-        }\n-        int firstIndexParam = view.getParameterOffset(originalParameters);\n-        // the column index of each parameter\n-        // (for example: paramColumnIndex {0, 0} mean\n-        // param[0] is column 0, and param[1] is also column 0)\n-        IntArray paramColumnIndex = new IntArray();\n-        int indexColumnCount = 0;\n-        for (int i = 0; i < masks.length; i++) {\n-            int mask = masks[i];\n-            if (mask == 0) {\n-                continue;\n-            }\n-            indexColumnCount++;\n+  private Cursor find(Session session, SearchRow first, SearchRow last,\n+                      SearchRow intersection) {\n+    if (recursive) {\n+      return findRecursive(first, last);\n+    }\n+    setupQueryParameters(session, first, last, intersection);\n+    ResultInterface result = query.query(0);\n+    return new ViewCursor(this, result, first, last);\n+  }\n+\n+  private static void setParameter(ArrayList<Parameter> paramList, int x,\n+                                   Value v) {\n+    if (x >= paramList.size()) {\n+      // the parameter may be optimized away as in\n+      // select * from (select null as x) where x=1;\n+      return;\n+    }\n+    Parameter param = paramList.get(x);\n+    param.setValue(v);\n+  }\n+\n+  public Query getQuery() {\n+    return query;\n+  }\n+\n+  // \u76ee\u7684\u662f\u4e3a\u4e86\u5bf9indexColumns\u8d4b\u503c\uff0cindexColumns\u53e6\u6709\u5b83\u7528\n+  // \u6bd4\u5982\u5728org.h2.command.dml.Select.prepare()\u4e2d\u5c31\u6709\u5e94\u7528(cost = preparePlan\u90a3\u884c\u4ee3\u7801\u4e4b\u540e)\n+  private Query getQuery(Session session, int[] masks,\n+                         TableFilter[] filters, int filter, SortOrder sortOrder) {\n+    Query q = prepareSubQuery(querySQL, session, masks, filters, filter, sortOrder);\n+    if (masks == null) {\n+      return q;\n+    }\n+    //\u6bd4\u5982AS SELECT top 2 id,name FROM CreateViewTest order by id\n+    //limitExpr\u548csort\u90fd\u4e0d\u4e3a\u7a7a\uff0c\u6b64\u65f6\u4e0d\u5141\u8bb8\u52a0\u5168\u5c40\u6761\u4ef6\u5230select\u4e2d\n+    if (!q.allowGlobalConditions()) {\n+      return q;\n+    }\n+    int firstIndexParam = view.getParameterOffset(originalParameters);\n+    // the column index of each parameter\n+    // (for example: paramColumnIndex {0, 0} mean\n+    // param[0] is column 0, and param[1] is also column 0)\n+    IntArray paramColumnIndex = new IntArray();\n+    int indexColumnCount = 0;\n+    for (int i = 0; i < masks.length; i++) {\n+      int mask = masks[i];\n+      if (mask == 0) {\n+        continue;\n+      }\n+      indexColumnCount++;\n //<<<<<<< HEAD\n //            paramIndex.add(i);\n //            //\u4e3a1\u7684bit\u4e2a\u6570\uff0c\u6bd4\u5982mask=3\u65f6\uff0c\u5c31\u662f0011\uff0c\u6240\u4ee5bitCount=2\n@@ -444,133 +445,133 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //        }\n //        int len = paramIndex.size(); //paramIndex\u4e2d\u653e\u7684\u662f\u5217id\n //=======\n-            // the number of parameters depends on the mask;\n-            // for range queries it is 2: >= x AND <= y\n-            // but bitMask could also be 7 (=, and <=, and >=)\n-            int bitCount = Integer.bitCount(mask);\n-            for (int j = 0; j < bitCount; j++) {\n-                paramColumnIndex.add(i);\n-            }\n-        }\n-        int len = paramColumnIndex.size();\n-        ArrayList<Column> columnList = New.arrayList();\n-        for (int i = 0; i < len;) {\n-            int idx = paramColumnIndex.get(i);\n-            columnList.add(table.getColumn(idx));\n-            int mask = masks[idx];\n-            if ((mask & IndexCondition.EQUALITY) != 0) {\n-                Parameter param = new Parameter(firstIndexParam + i);\n-                q.addGlobalCondition(param, idx, Comparison.EQUAL_NULL_SAFE);\n-                i++;\n-            }\n-            if ((mask & IndexCondition.START) != 0) {\n-                Parameter param = new Parameter(firstIndexParam + i);\n-                q.addGlobalCondition(param, idx, Comparison.BIGGER_EQUAL);\n-                i++;\n-            }\n-            if ((mask & IndexCondition.END) != 0) {\n-                Parameter param = new Parameter(firstIndexParam + i);\n-                q.addGlobalCondition(param, idx, Comparison.SMALLER_EQUAL);\n-                i++;\n-            }\n-            if ((mask & IndexCondition.SPATIAL_INTERSECTS) != 0) {\n-                Parameter param = new Parameter(firstIndexParam + i);\n-                q.addGlobalCondition(param, idx, Comparison.SPATIAL_INTERSECTS);\n-                i++;\n-            }\n-        }\n-        columns = new Column[columnList.size()];\n-        columnList.toArray(columns);\n-\n-        // reconstruct the index columns from the masks\n-        this.indexColumns = new IndexColumn[indexColumnCount];\n-        this.columnIds = new int[indexColumnCount];\n-        //type\u4ece0\u52301\uff0c\u4e5f\u5c31\u662f\u5faa\u73af\u4e24\u6b21\u8fd0\u884c\u5b50\u5faa\u73af\n-        //\u5f53type\u4e3a0\u65f6\uff0c\u53ea\u53d6where\u6761\u4ef6\u4e2d\u7684\"\u7b49\u4e8e\"\u5173\u7cfb\u8868\u8fbe\u5f0f\n-        //\u5f53type\u4e3a1\u65f6\uff0c\u53ea\u53d6where\u6761\u4ef6\u4e2d\u7684\u9664\"\u7b49\u4e8e\"\u5173\u7cfb\u8868\u8fbe\u5f0f\u4e4b\u4e0a\u7684\u8868\u8fbe\u5f0f\n-        //\u5982select * from my_view where f1=2 and f2 between 'b1' and 'b2'\n-        //\u5f53type\u4e3a0\u65f6\uff0c\u53ea\u53d6f1=2\n-        //\u5f53type\u4e3a1\u65f6\uff0c\u53ea\u53d6f2 between 'b1' and 'b2'\n-        for (int type = 0, indexColumnId = 0; type < 2; type++) {\n-            for (int i = 0; i < masks.length; i++) {\n-                int mask = masks[i];\n-                if (mask == 0) {\n-                    continue;\n-                }\n-                if (type == 0) {\n-                    if ((mask & IndexCondition.EQUALITY) == 0) {\n-                        // the first columns need to be equality conditions\n-                        continue;\n-                    }\n-                } else {\n-                    if ((mask & IndexCondition.EQUALITY) != 0) {\n-                        // after that only range conditions\n-                        continue;\n-                    }\n-                }\n-                IndexColumn c = new IndexColumn();\n-                c.column = table.getColumn(i);\n-                indexColumns[indexColumnId] = c;\n-                columnIds[indexColumnId] = c.column.getColumnId();\n-                indexColumnId++;\n-            }\n-        }\n-\n-        String sql = q.getPlanSQL();\n-        q = prepareSubQuery(sql, session, masks, filters, filter, sortOrder);\n-        return q;\n-    }\n-\n-    @Override\n-    public void remove(Session session) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public void truncate(Session session) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n+      // the number of parameters depends on the mask;\n+      // for range queries it is 2: >= x AND <= y\n+      // but bitMask could also be 7 (=, and <=, and >=)\n+      int bitCount = Integer.bitCount(mask);\n+      for (int j = 0; j < bitCount; j++) {\n+        paramColumnIndex.add(i);\n+      }\n     }\n-\n-    @Override\n-    public void checkRename() {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public boolean needRebuild() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean canGetFirstOrLast() {\n-        return false;\n-    }\n-\n-    @Override\n-    public Cursor findFirstOrLast(Session session, boolean first) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    public void setRecursive(boolean value) {\n-        this.recursive = value;\n+    int len = paramColumnIndex.size();\n+    ArrayList<Column> columnList = New.arrayList();\n+    for (int i = 0; i < len; ) {\n+      int idx = paramColumnIndex.get(i);\n+      columnList.add(table.getColumn(idx));\n+      int mask = masks[idx];\n+      if ((mask & IndexCondition.EQUALITY) != 0) {\n+        Parameter param = new Parameter(firstIndexParam + i);\n+        q.addGlobalCondition(param, idx, Comparison.EQUAL_NULL_SAFE);\n+        i++;\n+      }\n+      if ((mask & IndexCondition.START) != 0) {\n+        Parameter param = new Parameter(firstIndexParam + i);\n+        q.addGlobalCondition(param, idx, Comparison.BIGGER_EQUAL);\n+        i++;\n+      }\n+      if ((mask & IndexCondition.END) != 0) {\n+        Parameter param = new Parameter(firstIndexParam + i);\n+        q.addGlobalCondition(param, idx, Comparison.SMALLER_EQUAL);\n+        i++;\n+      }\n+      if ((mask & IndexCondition.SPATIAL_INTERSECTS) != 0) {\n+        Parameter param = new Parameter(firstIndexParam + i);\n+        q.addGlobalCondition(param, idx, Comparison.SPATIAL_INTERSECTS);\n+        i++;\n+      }\n     }\n-\n-    @Override\n-    public long getRowCount(Session session) {\n-        return 0;\n-    }\n-\n-    @Override\n-    public long getRowCountApproximation() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public long getDiskSpaceUsed() {\n-        return 0;\n+    columns = new Column[columnList.size()];\n+    columnList.toArray(columns);\n+\n+    // reconstruct the index columns from the masks\n+    this.indexColumns = new IndexColumn[indexColumnCount];\n+    this.columnIds = new int[indexColumnCount];\n+    //type\u4ece0\u52301\uff0c\u4e5f\u5c31\u662f\u5faa\u73af\u4e24\u6b21\u8fd0\u884c\u5b50\u5faa\u73af\n+    //\u5f53type\u4e3a0\u65f6\uff0c\u53ea\u53d6where\u6761\u4ef6\u4e2d\u7684\"\u7b49\u4e8e\"\u5173\u7cfb\u8868\u8fbe\u5f0f\n+    //\u5f53type\u4e3a1\u65f6\uff0c\u53ea\u53d6where\u6761\u4ef6\u4e2d\u7684\u9664\"\u7b49\u4e8e\"\u5173\u7cfb\u8868\u8fbe\u5f0f\u4e4b\u4e0a\u7684\u8868\u8fbe\u5f0f\n+    //\u5982select * from my_view where f1=2 and f2 between 'b1' and 'b2'\n+    //\u5f53type\u4e3a0\u65f6\uff0c\u53ea\u53d6f1=2\n+    //\u5f53type\u4e3a1\u65f6\uff0c\u53ea\u53d6f2 between 'b1' and 'b2'\n+    for (int type = 0, indexColumnId = 0; type < 2; type++) {\n+      for (int i = 0; i < masks.length; i++) {\n+        int mask = masks[i];\n+        if (mask == 0) {\n+          continue;\n+        }\n+        if (type == 0) {\n+          if ((mask & IndexCondition.EQUALITY) == 0) {\n+            // the first columns need to be equality conditions\n+            continue;\n+          }\n+        } else {\n+          if ((mask & IndexCondition.EQUALITY) != 0) {\n+            // after that only range conditions\n+            continue;\n+          }\n+        }\n+        IndexColumn c = new IndexColumn();\n+        c.column = table.getColumn(i);\n+        indexColumns[indexColumnId] = c;\n+        columnIds[indexColumnId] = c.column.getColumnId();\n+        indexColumnId++;\n+      }\n     }\n \n-    public boolean isRecursive() {\n-        return recursive;\n-    }\n+    String sql = q.getPlanSQL();\n+    q = prepareSubQuery(sql, session, masks, filters, filter, sortOrder);\n+    return q;\n+  }\n+\n+  @Override\n+  public void remove(Session session) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void truncate(Session session) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void checkRename() {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public boolean needRebuild() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean canGetFirstOrLast() {\n+    return false;\n+  }\n+\n+  @Override\n+  public Cursor findFirstOrLast(Session session, boolean first) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  public void setRecursive(boolean value) {\n+    this.recursive = value;\n+  }\n+\n+  @Override\n+  public long getRowCount(Session session) {\n+    return 0;\n+  }\n+\n+  @Override\n+  public long getRowCountApproximation() {\n+    return 0;\n+  }\n+\n+  @Override\n+  public long getDiskSpaceUsed() {\n+    return 0;\n+  }\n+\n+  public boolean isRecursive() {\n+    return recursive;\n+  }\n }\n",
            "diff_size": 611
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "219",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/125/ViewIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/125/ViewIndex.java\nindex 0b5b036217e..b9942199d45 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/125/ViewIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/125/ViewIndex.java\n@@ -433,18 +433,8 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n             }\n             indexColumnCount++;\n //<<<<<<< HEAD\n-//            paramIndex.add(i);\n-//            //\u4e3a1\u7684bit\u4e2a\u6570\uff0c\u6bd4\u5982mask=3\u65f6\uff0c\u5c31\u662f0011\uff0c\u6240\u4ee5bitCount=2\n-//            //mask=6\u65f6\uff0c\u5c31\u662f0110\uff0c\u4e5f\u5c31\u662fRANGE = START | END\n-//            //\u5982select * from my_view where f2 between 'b1' and 'b2'\n-//            if (Integer.bitCount(mask) > 1) {\n-//                // two parameters for range queries: >= x AND <= y\n-//                paramIndex.add(i);\n-//            }\n-//        }\n-//        int len = paramIndex.size(); //paramIndex\u4e2d\u653e\u7684\u662f\u5217id\n-//=======\n-            // the number of parameters depends on the mask;\n+//      \n+// the number of parameters depends on the mask;\n             // for range queries it is 2: >= x AND <= y\n             // but bitMask could also be 7 (=, and <=, and >=)\n             int bitCount = Integer.bitCount(mask);\n@@ -573,4 +563,4 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n     public boolean isRecursive() {\n         return recursive;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 13
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/125/ViewIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/125/ViewIndex.java\nindex 0b5b036217e..bf6849e325c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/125/ViewIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/125/ViewIndex.java\n@@ -8,7 +8,6 @@ package org.h2.index;\n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.concurrent.TimeUnit;\n-\n import org.h2.api.ErrorCode;\n import org.h2.command.Parser;\n import org.h2.command.Prepared;\n@@ -37,11 +36,11 @@ import org.h2.value.Value;\n  * This object represents a virtual index for a query.\n  * Actually it only represents a prepared SELECT statement.\n  */\n-public class ViewIndex extends BaseIndex implements SpatialIndex {\n \n-    private static final long MAX_AGE_NANOS =\n-            TimeUnit.MILLISECONDS.toNanos(Constants.VIEW_COST_CACHE_MAX_AGE);\n \n+public class ViewIndex extends BaseIndex implements SpatialIndex {\n+\n+    private static final long MAX_AGE_NANOS = TimeUnit.MILLISECONDS.toNanos(Constants.VIEW_COST_CACHE_MAX_AGE);\n     private final TableView view;\n     private final String querySQL;\n     private final ArrayList<Parameter> originalParameters;\n@@ -63,8 +62,8 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n      * @param originalParameters the original parameters\n      * @param recursive if the view is recursive\n      */\n-    public ViewIndex(TableView view, String querySQL,\n-            ArrayList<Parameter> originalParameters, boolean recursive) {\n+\n+    public ViewIndex(TableView view, String querySQL, ArrayList<Parameter> originalParameters, boolean recursive) {\n         initBaseIndex(view, 0, null, null, IndexType.createNonUnique(false));\n         this.view = view;\n         this.querySQL = querySQL;\n@@ -90,8 +89,8 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n      * @param filter current filter\n      * @param sortOrder sort order\n      */\n-    public ViewIndex(TableView view, ViewIndex index, Session session,\n-            int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n+\n+    public ViewIndex(TableView view, ViewIndex index, Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n         initBaseIndex(view, 0, null, null, IndexType.createNonUnique(false));\n         this.view = view;\n         this.querySQL = index.querySQL;\n@@ -119,14 +118,15 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         return JoinBatch.createViewIndexLookupBatch(this);\n     }\n \n+\n     public Session getSession() {\n         return createSession;\n     }\n \n+\n     public boolean isExpired() {\n         assert evaluatedAt != Long.MIN_VALUE : \"must not be called for main index of TableView\";\n-        return !recursive && view.getTopQuery() == null &&\n-                System.nanoTime() - evaluatedAt > MAX_AGE_NANOS;\n+        return !recursive && view.getTopQuery() == null && System.nanoTime() - evaluatedAt > MAX_AGE_NANOS;\n     }\n \n     @Override\n@@ -137,6 +137,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n     @Override\n     public void close(Session session) {\n         // nothing to do\n+\n     }\n \n     @Override\n@@ -216,10 +217,10 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //                    q.addGlobalCondition(param, idx, Comparison.SPATIAL_INTERSECTS);\n //                } else {\n //                    if ((mask & IndexCondition.START) != 0) {\n-//                    \t//\u4f8b\u5982:sql = \"select * from my_view where f2 > 'b1'\";\n-//                    \t//\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n-//                    \t//\u5728org.h2.index.IndexCondition.getMask(ArrayList<IndexCondition>)\u90a3\u91cc\u628a\n-//                    \t//BIGGER_EQUAL\u3001BIGGER\u90fd\u5f53\u6210\u4e86START\uff0c\u800c\u8fd9\u91cc\u7edf\u4e00\u8f6c\u6210BIGGER_EQUAL\uff0c\u5f53view\u8981\u8fc7\u6ee4\u8bb0\u5f55\u65f6\u518d\u6309\u5927\u4e8e\u8fc7\u6ee4\n+//                      //\u4f8b\u5982:sql = \"select * from my_view where f2 > 'b1'\";\n+//                      //\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n+//                      //\u5728org.h2.index.IndexCondition.getMask(ArrayList<IndexCondition>)\u90a3\u91cc\u628a\n+//                      //BIGGER_EQUAL\u3001BIGGER\u90fd\u5f53\u6210\u4e86START\uff0c\u800c\u8fd9\u91cc\u7edf\u4e00\u8f6c\u6210BIGGER_EQUAL\uff0c\u5f53view\u8981\u8fc7\u6ee4\u8bb0\u5f55\u65f6\u518d\u6309\u5927\u4e8e\u8fc7\u6ee4\n //                        Parameter param = new Parameter(nextParamIndex);\n //                        q.addGlobalCondition(param, idx, Comparison.BIGGER_EQUAL);\n //                    }\n@@ -240,10 +241,9 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //        costCache.put(masksArray, cachedCost);\n //        return cost;\n //=======\n+\n     @Override\n-    public double getCost(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            HashSet<Column> allColumnsSet) {\n+    public double getCost(Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder, HashSet<Column> allColumnsSet) {\n         return recursive ? 1000 : query.getCost();\n     }\n \n@@ -253,13 +253,11 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n     }\n \n     @Override\n-    public Cursor findByGeometry(TableFilter filter, SearchRow first,\n-            SearchRow last, SearchRow intersection) {\n+    public Cursor findByGeometry(TableFilter filter, SearchRow first, SearchRow last, SearchRow intersection) {\n         return find(filter.getSession(), first, last, intersection);\n     }\n \n-    private static Query prepareSubQuery(String sql, Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder) {\n+    private static Query prepareSubQuery(String sql, Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n         assert filters != null;\n         Prepared p;\n         session.pushSubQueryInfo(masks, filters, filter, sortOrder);\n@@ -290,7 +288,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         }\n         if (!query.isUnion()) {\n             throw DbException.get(ErrorCode.SYNTAX_ERROR_2,\n-                    \"recursive queries without UNION\");\n+                                  \"recursive queries without UNION\");\n         }\n         SelectUnion union = (SelectUnion) query;\n         Query left = union.getLeft();\n@@ -342,8 +340,11 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n      * @param last the upper bound\n      * @param intersection the intersection\n      */\n-    public void setupQueryParameters(Session session, SearchRow first, SearchRow last,\n-            SearchRow intersection) {\n+\n+\n+    public void setupQueryParameters(Session session,\n+           SearchRow first,\n+           SearchRow last, SearchRow intersection) {\n         ArrayList<Parameter> paramList = query.getParameters();\n         if (originalParameters != null) {\n             for (int i = 0, size = originalParameters.size(); i < size; i++) {\n@@ -358,11 +359,11 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n             len = first.getColumnCount();\n         } else if (last != null) {\n             len = last.getColumnCount();\n-        } else if (intersection != null) {\n-            len = intersection.getColumnCount();\n+                                                   } else if (intersection != null) {\n+                   len = intersection.getColumnCount();\n         } else {\n-            len = 0;\n-        }\n+                   len = 0;\n+               }\n         //view\u4e2d\u5df2\u7ed9select\u52a0\u4e86\u5916\u90e8\u6761\u4ef6\uff0c\u6240\u4ee5\u591a\u4e86Parameter\uff0c\u8fd9\u91cc\u5c31\u662f\u7ed9\u8fd9\u4e9bParameter\u8d4b\u503c\n         int idx = view.getParameterOffset(originalParameters);\n         for (int i = 0; i < len; i++) {\n@@ -382,8 +383,9 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         }\n     }\n \n-    private Cursor find(Session session, SearchRow first, SearchRow last,\n-            SearchRow intersection) {\n+    private Cursor find(Session session,\n+            SearchRow first,\n+            SearchRow last, SearchRow intersection) {\n         if (recursive) {\n             return findRecursive(first, last);\n         }\n@@ -392,8 +394,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         return new ViewCursor(this, result, first, last);\n     }\n \n-    private static void setParameter(ArrayList<Parameter> paramList, int x,\n-            Value v) {\n+    private static void setParameter(ArrayList<Parameter> paramList, int x, Value v) {\n         if (x >= paramList.size()) {\n             // the parameter may be optimized away as in\n             // select * from (select null as x) where x=1;\n@@ -403,14 +404,15 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         param.setValue(v);\n     }\n \n+\n     public Query getQuery() {\n         return query;\n     }\n \n     // \u76ee\u7684\u662f\u4e3a\u4e86\u5bf9indexColumns\u8d4b\u503c\uff0cindexColumns\u53e6\u6709\u5b83\u7528\n     // \u6bd4\u5982\u5728org.h2.command.dml.Select.prepare()\u4e2d\u5c31\u6709\u5e94\u7528(cost = preparePlan\u90a3\u884c\u4ee3\u7801\u4e4b\u540e)\n-    private Query getQuery(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder) {\n+\n+    private Query getQuery(Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder) {\n         Query q = prepareSubQuery(querySQL, session, masks, filters, filter, sortOrder);\n         if (masks == null) {\n             return q;\n@@ -515,7 +517,6 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n                 indexColumnId++;\n             }\n         }\n-\n         String sql = q.getPlanSQL();\n         q = prepareSubQuery(sql, session, masks, filters, filter, sortOrder);\n         return q;\n@@ -551,6 +552,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         throw DbException.getUnsupportedException(\"VIEW\");\n     }\n \n+\n     public void setRecursive(boolean value) {\n         this.recursive = value;\n     }\n@@ -570,7 +572,9 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n         return 0;\n     }\n \n+\n     public boolean isRecursive() {\n         return recursive;\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 51
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "219",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "219",
                    "column": "23",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/125/ViewIndex.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/125/ViewIndex.java\nindex 0b5b036217e..d5a7244ddb2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/125/ViewIndex.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/125/ViewIndex.java\n@@ -216,7 +216,7 @@ public class ViewIndex extends BaseIndex implements SpatialIndex {\n //                    q.addGlobalCondition(param, idx, Comparison.SPATIAL_INTERSECTS);\n //                } else {\n //                    if ((mask & IndexCondition.START) != 0) {\n-//                    \t//\u4f8b\u5982:sql = \"select * from my_view where f2 > 'b1'\";\n+//                    \t//\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n //                    \t//\u5b9e\u9645\u662fSELECT ID, NAME FROM CreateViewTest WHERE NAME >= ?1\n //                    \t//\u5728org.h2.index.IndexCondition.getMask(ArrayList<IndexCondition>)\u90a3\u91cc\u628a\n //                    \t//BIGGER_EQUAL\u3001BIGGER\u90fd\u5f53\u6210\u4e86START\uff0c\u800c\u8fd9\u91cc\u7edf\u4e00\u8f6c\u6210BIGGER_EQUAL\uff0c\u5f53view\u8981\u8fc7\u6ee4\u8bb0\u5f55\u65f6\u518d\u6309\u5927\u4e8e\u8fc7\u6ee4\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}