{
    "project_name": "codefollower-H2-Research",
    "error_id": "333",
    "information": {
        "errors": [
            {
                "line": "27",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": " */\npublic class PageStreamTrunk extends Page {\n\t/*\n\t\t\u5934\u90e8\u536017\u5b57\u8282\n\t\tdata.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n\t    data.writeShortInt(0);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "28",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/333/PageStreamTrunk.java\nindex 0ab55e527f6..ffb939c012e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/333/PageStreamTrunk.java\n@@ -24,7 +24,7 @@ import org.h2.store.Data;\n  * </ul>\n  */\n public class PageStreamTrunk extends Page {\n-\t/*\n+/*\n \t\t\u5934\u90e8\u536017\u5b57\u8282\n \t\tdata.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n \t    data.writeShortInt(0);\n@@ -33,7 +33,7 @@ public class PageStreamTrunk extends Page {\n \t    data.writeInt(nextTrunk);\n \t    data.writeShortInt(pageCount);\n     */\n-    private static final int DATA_START = 17;\n+private static final int DATA_START = 17;\n \n     /**\n      * The previous stream trunk.\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/333/PageStreamTrunk.java\nindex 0ab55e527f6..6ac6a5307ff 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/333/PageStreamTrunk.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.pagestore;\n \n import org.h2.api.ErrorCode;\n@@ -24,291 +25,291 @@ import org.h2.store.Data;\n  * </ul>\n  */\n public class PageStreamTrunk extends Page {\n-\t/*\n-\t\t\u5934\u90e8\u536017\u5b57\u8282\n-\t\tdata.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n-\t    data.writeShortInt(0);\n-\t    data.writeInt(parent);\n-\t    data.writeInt(logKey);\n-\t    data.writeInt(nextTrunk);\n-\t    data.writeShortInt(pageCount);\n-    */\n-    private static final int DATA_START = 17;\n+  /*\n+      \u5934\u90e8\u536017\u5b57\u8282\n+      data.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n+      data.writeShortInt(0);\n+      data.writeInt(parent);\n+      data.writeInt(logKey);\n+      data.writeInt(nextTrunk);\n+      data.writeShortInt(pageCount);\n+  */\n+  private static final int DATA_START = 17;\n \n-    /**\n-     * The previous stream trunk.\n-     */\n-    int parent;\n+  /**\n+   * The previous stream trunk.\n+   */\n+  int parent;\n \n-    /**\n-     * The next stream trunk.\n-     */\n-    int nextTrunk;\n+  /**\n+   * The next stream trunk.\n+   */\n+  int nextTrunk;\n \n-    private final PageStore store;\n-    private int logKey;\n-    private int[] pageIds;\n-    private int pageCount;\n-    private Data data;\n+  private final PageStore store;\n+  private int logKey;\n+  private int[] pageIds;\n+  private int pageCount;\n+  private Data data;\n \n-    private PageStreamTrunk(PageStore store, int parent, int pageId, int next,\n-            int logKey, int[] pageIds) {\n-        setPos(pageId);\n-        this.parent = parent;\n-        this.store = store;\n-        this.nextTrunk = next;\n-        this.logKey = logKey;\n-        this.pageCount = pageIds.length;\n-        this.pageIds = pageIds;\n-    }\n+  private PageStreamTrunk(PageStore store, int parent, int pageId, int next,\n+                          int logKey, int[] pageIds) {\n+    setPos(pageId);\n+    this.parent = parent;\n+    this.store = store;\n+    this.nextTrunk = next;\n+    this.logKey = logKey;\n+    this.pageCount = pageIds.length;\n+    this.pageIds = pageIds;\n+  }\n \n-    private PageStreamTrunk(PageStore store, Data data, int pageId) {\n-        setPos(pageId);\n-        this.data = data;\n-        this.store = store;\n-    }\n+  private PageStreamTrunk(PageStore store, Data data, int pageId) {\n+    setPos(pageId);\n+    this.data = data;\n+    this.store = store;\n+  }\n \n-    /**\n-     * Read a stream trunk page.\n-     *\n-     * @param store the page store\n-     * @param data the data\n-     * @param pageId the page id\n-     * @return the page\n-     */\n-    static PageStreamTrunk read(PageStore store, Data data, int pageId) {\n-        PageStreamTrunk p = new PageStreamTrunk(store, data, pageId);\n-        p.read();\n-        return p;\n+  /**\n+   * Read a stream trunk page.\n+   *\n+   * @param store  the page store\n+   * @param data   the data\n+   * @param pageId the page id\n+   * @return the page\n+   */\n+  static PageStreamTrunk read(PageStore store, Data data, int pageId) {\n+    PageStreamTrunk p = new PageStreamTrunk(store, data, pageId);\n+    p.read();\n+    return p;\n+  }\n+\n+  /**\n+   * Create a new stream trunk page.\n+   *\n+   * @param store   the page store\n+   * @param parent  the parent page\n+   * @param pageId  the page id\n+   * @param next    the next trunk page\n+   * @param logKey  the log key\n+   * @param pageIds the stream data page ids\n+   * @return the page\n+   */\n+  static PageStreamTrunk create(PageStore store, int parent, int pageId,\n+                                int next, int logKey, int[] pageIds) {\n+    return new PageStreamTrunk(store, parent, pageId, next, logKey, pageIds);\n+  }\n+\n+  /**\n+   * Read the page from the disk.\n+   */\n+  private void read() {\n+    data.reset();\n+    data.readByte();\n+    data.readShortInt();\n+    parent = data.readInt();\n+    logKey = data.readInt();\n+    nextTrunk = data.readInt();\n+    pageCount = data.readShortInt();\n+    pageIds = new int[pageCount];\n+    for (int i = 0; i < pageCount; i++) {\n+      pageIds[i] = data.readInt();\n     }\n+  }\n \n-    /**\n-     * Create a new stream trunk page.\n-     *\n-     * @param store the page store\n-     * @param parent the parent page\n-     * @param pageId the page id\n-     * @param next the next trunk page\n-     * @param logKey the log key\n-     * @param pageIds the stream data page ids\n-     * @return the page\n-     */\n-    static PageStreamTrunk create(PageStore store, int parent, int pageId,\n-            int next, int logKey, int[] pageIds) {\n-        return new PageStreamTrunk(store, parent, pageId, next, logKey, pageIds);\n+  /**\n+   * Get the data page id at the given position.\n+   *\n+   * @param index the index (0, 1, ...)\n+   * @return the value, or -1 if the index is too large\n+   */\n+  int getPageData(int index) {\n+    if (index >= pageIds.length) {\n+      return -1;\n     }\n+    return pageIds[index];\n+  }\n \n-    /**\n-     * Read the page from the disk.\n-     */\n-    private void read() {\n-        data.reset();\n-        data.readByte();\n-        data.readShortInt();\n-        parent = data.readInt();\n-        logKey = data.readInt();\n-        nextTrunk = data.readInt();\n-        pageCount = data.readShortInt();\n-        pageIds = new int[pageCount];\n-        for (int i = 0; i < pageCount; i++) {\n-            pageIds[i] = data.readInt();\n-        }\n+  @Override\n+  public void write() {\n+    data = store.createData();\n+    data.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n+    data.writeShortInt(0);\n+    data.writeInt(parent);\n+    data.writeInt(logKey);\n+    data.writeInt(nextTrunk);\n+    data.writeShortInt(pageCount);\n+    for (int i = 0; i < pageCount; i++) {\n+      data.writeInt(pageIds[i]);\n     }\n+    store.writePage(getPos(), data);\n+  }\n \n-    /**\n-     * Get the data page id at the given position.\n-     *\n-     * @param index the index (0, 1, ...)\n-     * @return the value, or -1 if the index is too large\n-     */\n-    int getPageData(int index) {\n-        if (index >= pageIds.length) {\n-            return -1;\n-        }\n-        return pageIds[index];\n+  /**\n+   * Get the number of pages that can be addressed in a stream trunk page.\n+   *\n+   * @param pageSize the page size\n+   * @return the number of pages\n+   */\n+  //\u4e00\u4e2aPageStreamTrunk\u80fd\u653e\u591a\u5c11\u4e2aPageStreamData\u7684pageId(\u75284\u5b57\u8282\u8868\u793a)\n+  //(pageSize-17)/4 (\u4e00\u4e2aPageStreamTrunk\u5934\u5c31\u5360\u4e8617\u5b57\u8282)\n+  static int getPagesAddressed(int pageSize) {\n+    return (pageSize - DATA_START) / 4;\n+  }\n+\n+  /**\n+   * Check if the given data page is in this trunk page.\n+   *\n+   * @param dataPageId the page id\n+   * @return true if it is\n+   */\n+  boolean contains(int dataPageId) {\n+    for (int i = 0; i < pageCount; i++) {\n+      if (pageIds[i] == dataPageId) {\n+        return true;\n+      }\n     }\n+    return false;\n+  }\n \n-    @Override\n-    public void write() {\n-        data = store.createData();\n-        data.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n-        data.writeShortInt(0);\n-        data.writeInt(parent);\n-        data.writeInt(logKey);\n-        data.writeInt(nextTrunk);\n-        data.writeShortInt(pageCount);\n-        for (int i = 0; i < pageCount; i++) {\n-            data.writeInt(pageIds[i]);\n-        }\n-        store.writePage(getPos(), data);\n+  /**\n+   * Free this page and all data pages. Pages after the last used data page\n+   * (if within this list) are empty and therefore not just freed, but marked\n+   * as not used.\n+   *\n+   * @param lastUsedPage the last used data page\n+   * @return the number of pages freed\n+   */\n+  int free(int lastUsedPage) {\n+    store.free(getPos(), false);\n+    int freed = 1;\n+    boolean notUsed = false;\n+    for (int i = 0; i < pageCount; i++) {\n+      int page = pageIds[i];\n+      if (notUsed) {\n+        store.freeUnused(page);\n+      } else {\n+        store.free(page, false);\n+      }\n+      freed++;\n+      if (page == lastUsedPage) {\n+        notUsed = true;\n+      }\n     }\n+    return freed;\n+  }\n \n-    /**\n-     * Get the number of pages that can be addressed in a stream trunk page.\n-     *\n-     * @param pageSize the page size\n-     * @return the number of pages\n-     */\n-    //\u4e00\u4e2aPageStreamTrunk\u80fd\u653e\u591a\u5c11\u4e2aPageStreamData\u7684pageId(\u75284\u5b57\u8282\u8868\u793a)\n-    //(pageSize-17)/4 (\u4e00\u4e2aPageStreamTrunk\u5934\u5c31\u5360\u4e8617\u5b57\u8282)\n-    static int getPagesAddressed(int pageSize) {\n-        return (pageSize - DATA_START) / 4;\n+  /**\n+   * Get the estimated memory size.\n+   *\n+   * @return number of double words (4 bytes)\n+   */\n+  @Override\n+  public int getMemory() {\n+    return store.getPageSize() >> 2;\n+  }\n+\n+  @Override\n+  public void moveTo(Session session, int newPos) {\n+    // not required\n+  }\n+\n+  int getLogKey() {\n+    return logKey;\n+  }\n+\n+  public int getNextTrunk() {\n+    return nextTrunk;\n+  }\n+\n+  /**\n+   * An iterator over page stream trunk pages.\n+   */\n+  static class Iterator {\n+\n+    private final PageStore store;\n+    private int first;\n+    private int next;\n+    private int previous;\n+    private boolean canDelete;\n+    private int current;\n+\n+    Iterator(PageStore store, int first) {\n+      this.store = store;\n+      this.next = first;\n     }\n \n-    /**\n-     * Check if the given data page is in this trunk page.\n-     *\n-     * @param dataPageId the page id\n-     * @return true if it is\n-     */\n-    boolean contains(int dataPageId) {\n-        for (int i = 0; i < pageCount; i++) {\n-            if (pageIds[i] == dataPageId) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    int getCurrentPageId() {\n+      return current;\n     }\n \n     /**\n-     * Free this page and all data pages. Pages after the last used data page\n-     * (if within this list) are empty and therefore not just freed, but marked\n-     * as not used.\n+     * Get the next trunk page or null if no next trunk page.\n      *\n-     * @param lastUsedPage the last used data page\n-     * @return the number of pages freed\n+     * @return the next trunk page or null\n      */\n-    int free(int lastUsedPage) {\n-        store.free(getPos(), false);\n-        int freed = 1;\n-        boolean notUsed = false;\n-        for (int i = 0; i < pageCount; i++) {\n-            int page = pageIds[i];\n-            if (notUsed) {\n-                store.freeUnused(page);\n-            } else {\n-                store.free(page, false);\n-            }\n-            freed++;\n-            if (page == lastUsedPage) {\n-                notUsed = true;\n-            }\n+    PageStreamTrunk next() {\n+      canDelete = false;\n+      if (first == 0) {\n+        first = next;\n+      } else if (first == next) {\n+        return null;\n+      }\n+      if (next == 0 || next >= store.getPageCount()) {\n+        return null;\n+      }\n+      Page p;\n+      current = next;\n+      try {\n+        p = store.getPage(next);\n+      } catch (DbException e) {\n+        if (e.getErrorCode() == ErrorCode.FILE_CORRUPTED_1) {\n+          // wrong checksum means end of stream\n+          return null;\n         }\n-        return freed;\n+        throw e;\n+      }\n+      if (p == null || p instanceof PageStreamTrunk ||\n+          p instanceof PageStreamData) {\n+        canDelete = true;\n+      }\n+      if (!(p instanceof PageStreamTrunk)) {\n+        return null;\n+      }\n+      PageStreamTrunk t = (PageStreamTrunk) p;\n+      if (previous > 0 && t.parent != previous) {\n+        return null;\n+      }\n+      previous = next;\n+      next = t.nextTrunk;\n+      return t;\n     }\n \n     /**\n-     * Get the estimated memory size.\n+     * Check if the current page can be deleted. It can if it's empty, a\n+     * stream trunk, or a stream data page.\n      *\n-     * @return number of double words (4 bytes)\n+     * @return true if it can be deleted\n      */\n-    @Override\n-    public int getMemory() {\n-        return store.getPageSize() >> 2;\n+    boolean canDelete() {\n+      return canDelete;\n     }\n \n-    @Override\n-    public void moveTo(Session session, int newPos) {\n-        // not required\n-    }\n-\n-    int getLogKey() {\n-        return logKey;\n-    }\n-\n-    public int getNextTrunk() {\n-        return nextTrunk;\n-    }\n+  }\n \n-    /**\n-     * An iterator over page stream trunk pages.\n-     */\n-    static class Iterator {\n+  @Override\n+  public boolean canRemove() {\n+    return true;\n+  }\n \n-        private final PageStore store;\n-        private int first;\n-        private int next;\n-        private int previous;\n-        private boolean canDelete;\n-        private int current;\n+  @Override\n+  public String toString() {\n+    return \"page[\" + getPos() + \"] stream trunk key:\" + logKey +\n+        \" next:\" + nextTrunk;\n+  }\n \n-        Iterator(PageStore store, int first) {\n-            this.store = store;\n-            this.next = first;\n-        }\n-\n-        int getCurrentPageId() {\n-            return current;\n-        }\n-\n-        /**\n-         * Get the next trunk page or null if no next trunk page.\n-         *\n-         * @return the next trunk page or null\n-         */\n-        PageStreamTrunk next() {\n-            canDelete = false;\n-            if (first == 0) {\n-                first = next;\n-            } else if (first == next) {\n-                return null;\n-            }\n-            if (next == 0 || next >= store.getPageCount()) {\n-                return null;\n-            }\n-            Page p;\n-            current = next;\n-            try {\n-                p = store.getPage(next);\n-            } catch (DbException e) {\n-                if (e.getErrorCode() == ErrorCode.FILE_CORRUPTED_1) {\n-                    // wrong checksum means end of stream\n-                    return null;\n-                }\n-                throw e;\n-            }\n-            if (p == null || p instanceof PageStreamTrunk ||\n-                    p instanceof PageStreamData) {\n-                canDelete = true;\n-            }\n-            if (!(p instanceof PageStreamTrunk)) {\n-                return null;\n-            }\n-            PageStreamTrunk t = (PageStreamTrunk) p;\n-            if (previous > 0 && t.parent != previous) {\n-                return null;\n-            }\n-            previous = next;\n-            next = t.nextTrunk;\n-            return t;\n-        }\n-\n-        /**\n-         * Check if the current page can be deleted. It can if it's empty, a\n-         * stream trunk, or a stream data page.\n-         *\n-         * @return true if it can be deleted\n-         */\n-        boolean canDelete() {\n-            return canDelete;\n-        }\n-\n-    }\n-\n-    @Override\n-    public boolean canRemove() {\n-        return true;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"page[\" + getPos() + \"] stream trunk key:\" + logKey +\n-                \" next:\" + nextTrunk;\n-    }\n-\n-    @Override\n-    public boolean canMove() {\n-        return false;\n-    }\n+  @Override\n+  public boolean canMove() {\n+    return false;\n+  }\n \n }\n",
            "diff_size": 363
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "29",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/333/PageStreamTrunk.java\nindex 0ab55e527f6..ce61d76848e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/333/PageStreamTrunk.java\n@@ -24,7 +24,8 @@ import org.h2.store.Data;\n  * </ul>\n  */\n public class PageStreamTrunk extends Page {\n-\t/*\n+\n+/*\n \t\t\u5934\u90e8\u536017\u5b57\u8282\n \t\tdata.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n \t    data.writeShortInt(0);\n@@ -33,7 +34,7 @@ public class PageStreamTrunk extends Page {\n \t    data.writeInt(nextTrunk);\n \t    data.writeShortInt(pageCount);\n     */\n-    private static final int DATA_START = 17;\n+private static final int DATA_START = 17;\n \n     /**\n      * The previous stream trunk.\n@@ -311,4 +312,4 @@ public class PageStreamTrunk extends Page {\n         return false;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/333/PageStreamTrunk.java\nindex 0ab55e527f6..c47a1a62729 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/333/PageStreamTrunk.java\n@@ -23,36 +23,41 @@ import org.h2.store.Data;\n  * <li>page ids (17-)</li>\n  * </ul>\n  */\n+\n+\n public class PageStreamTrunk extends Page {\n-\t/*\n-\t\t\u5934\u90e8\u536017\u5b57\u8282\n-\t\tdata.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n-\t    data.writeShortInt(0);\n-\t    data.writeInt(parent);\n-\t    data.writeInt(logKey);\n-\t    data.writeInt(nextTrunk);\n-\t    data.writeShortInt(pageCount);\n+    /*\n+        \u5934\u90e8\u536017\u5b57\u8282\n+        data.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n+        data.writeShortInt(0);\n+        data.writeInt(parent);\n+        data.writeInt(logKey);\n+        data.writeInt(nextTrunk);\n+        data.writeShortInt(pageCount);\n     */\n+\n     private static final int DATA_START = 17;\n \n     /**\n      * The previous stream trunk.\n      */\n+\n+\n     int parent;\n \n     /**\n      * The next stream trunk.\n      */\n-    int nextTrunk;\n \n+\n+    int nextTrunk;\n     private final PageStore store;\n     private int logKey;\n     private int[] pageIds;\n     private int pageCount;\n     private Data data;\n \n-    private PageStreamTrunk(PageStore store, int parent, int pageId, int next,\n-            int logKey, int[] pageIds) {\n+    private PageStreamTrunk(PageStore store, int parent, int pageId, int next, int logKey, int[] pageIds) {\n         setPos(pageId);\n         this.parent = parent;\n         this.store = store;\n@@ -76,6 +81,8 @@ public class PageStreamTrunk extends Page {\n      * @param pageId the page id\n      * @return the page\n      */\n+\n+\n     static PageStreamTrunk read(PageStore store, Data data, int pageId) {\n         PageStreamTrunk p = new PageStreamTrunk(store, data, pageId);\n         p.read();\n@@ -93,14 +100,16 @@ public class PageStreamTrunk extends Page {\n      * @param pageIds the stream data page ids\n      * @return the page\n      */\n-    static PageStreamTrunk create(PageStore store, int parent, int pageId,\n-            int next, int logKey, int[] pageIds) {\n+\n+\n+    static PageStreamTrunk create(PageStore store, int parent, int pageId, int next, int logKey, int[] pageIds) {\n         return new PageStreamTrunk(store, parent, pageId, next, logKey, pageIds);\n     }\n \n     /**\n      * Read the page from the disk.\n      */\n+\n     private void read() {\n         data.reset();\n         data.readByte();\n@@ -121,6 +130,8 @@ public class PageStreamTrunk extends Page {\n      * @param index the index (0, 1, ...)\n      * @return the value, or -1 if the index is too large\n      */\n+\n+\n     int getPageData(int index) {\n         if (index >= pageIds.length) {\n             return -1;\n@@ -151,6 +162,8 @@ public class PageStreamTrunk extends Page {\n      */\n     //\u4e00\u4e2aPageStreamTrunk\u80fd\u653e\u591a\u5c11\u4e2aPageStreamData\u7684pageId(\u75284\u5b57\u8282\u8868\u793a)\n     //(pageSize-17)/4 (\u4e00\u4e2aPageStreamTrunk\u5934\u5c31\u5360\u4e8617\u5b57\u8282)\n+\n+\n     static int getPagesAddressed(int pageSize) {\n         return (pageSize - DATA_START) / 4;\n     }\n@@ -161,6 +174,8 @@ public class PageStreamTrunk extends Page {\n      * @param dataPageId the page id\n      * @return true if it is\n      */\n+\n+\n     boolean contains(int dataPageId) {\n         for (int i = 0; i < pageCount; i++) {\n             if (pageIds[i] == dataPageId) {\n@@ -178,6 +193,8 @@ public class PageStreamTrunk extends Page {\n      * @param lastUsedPage the last used data page\n      * @return the number of pages freed\n      */\n+\n+\n     int free(int lastUsedPage) {\n         store.free(getPos(), false);\n         int freed = 1;\n@@ -202,6 +219,7 @@ public class PageStreamTrunk extends Page {\n      *\n      * @return number of double words (4 bytes)\n      */\n+\n     @Override\n     public int getMemory() {\n         return store.getPageSize() >> 2;\n@@ -210,12 +228,15 @@ public class PageStreamTrunk extends Page {\n     @Override\n     public void moveTo(Session session, int newPos) {\n         // not required\n+\n     }\n \n+\n     int getLogKey() {\n         return logKey;\n     }\n \n+\n     public int getNextTrunk() {\n         return nextTrunk;\n     }\n@@ -223,6 +244,8 @@ public class PageStreamTrunk extends Page {\n     /**\n      * An iterator over page stream trunk pages.\n      */\n+\n+\n     static class Iterator {\n \n         private final PageStore store;\n@@ -237,6 +260,7 @@ public class PageStreamTrunk extends Page {\n             this.next = first;\n         }\n \n+\n         int getCurrentPageId() {\n             return current;\n         }\n@@ -246,6 +270,8 @@ public class PageStreamTrunk extends Page {\n          *\n          * @return the next trunk page or null\n          */\n+\n+\n         PageStreamTrunk next() {\n             canDelete = false;\n             if (first == 0) {\n@@ -267,8 +293,7 @@ public class PageStreamTrunk extends Page {\n                 }\n                 throw e;\n             }\n-            if (p == null || p instanceof PageStreamTrunk ||\n-                    p instanceof PageStreamData) {\n+            if (p == null || p instanceof PageStreamTrunk || p instanceof PageStreamData) {\n                 canDelete = true;\n             }\n             if (!(p instanceof PageStreamTrunk)) {\n@@ -289,6 +314,8 @@ public class PageStreamTrunk extends Page {\n          *\n          * @return true if it can be deleted\n          */\n+\n+\n         boolean canDelete() {\n             return canDelete;\n         }\n@@ -302,8 +329,8 @@ public class PageStreamTrunk extends Page {\n \n     @Override\n     public String toString() {\n-        return \"page[\" + getPos() + \"] stream trunk key:\" + logKey +\n-                \" next:\" + nextTrunk;\n+        return \"page[\" + getPos() + \"] stream trunk key:\"\n+        + logKey + \" next:\" + nextTrunk;\n     }\n \n     @Override\n@@ -311,4 +338,4 @@ public class PageStreamTrunk extends Page {\n         return false;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 48
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "28",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/333/PageStreamTrunk.java\nindex 0ab55e527f6..ffb939c012e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/333/PageStreamTrunk.java\n@@ -24,7 +24,7 @@ import org.h2.store.Data;\n  * </ul>\n  */\n public class PageStreamTrunk extends Page {\n-\t/*\n+/*\n \t\t\u5934\u90e8\u536017\u5b57\u8282\n \t\tdata.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n \t    data.writeShortInt(0);\n@@ -33,7 +33,7 @@ public class PageStreamTrunk extends Page {\n \t    data.writeInt(nextTrunk);\n \t    data.writeShortInt(pageCount);\n     */\n-    private static final int DATA_START = 17;\n+private static final int DATA_START = 17;\n \n     /**\n      * The previous stream trunk.\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "29",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/333/PageStreamTrunk.java\nindex 0ab55e527f6..f428ae46f4c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/333/PageStreamTrunk.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/333/PageStreamTrunk.java\n@@ -24,7 +24,8 @@ import org.h2.store.Data;\n  * </ul>\n  */\n public class PageStreamTrunk extends Page {\n-\t/*\n+\n+/*\n \t\t\u5934\u90e8\u536017\u5b57\u8282\n \t\tdata.writeByte((byte) Page.TYPE_STREAM_TRUNK);\n \t    data.writeShortInt(0);\n@@ -33,7 +34,7 @@ public class PageStreamTrunk extends Page {\n \t    data.writeInt(nextTrunk);\n \t    data.writeShortInt(pageCount);\n     */\n-    private static final int DATA_START = 17;\n+private static final int DATA_START = 17;\n \n     /**\n      * The previous stream trunk.\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}