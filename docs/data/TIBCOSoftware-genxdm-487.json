{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "487",
    "information": {
        "errors": [
            {
                "line": "575",
                "column": "13",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            if(m_existingCache.hasAttribute(name))\n            {\n            \tif(!m_lastInWins)\n            \t{\n            \t\t// We are not allowing this schema parse to create new elements.  \n                    m_inCache.m_attributesUnresolved.remove(name);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "576",
                    "column": "13",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/487/XMLSchemaConverter.java\nindex 71e16fd0e7e..f3202725df8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/487/XMLSchemaConverter.java\n@@ -572,7 +572,7 @@ public final class XMLSchemaConverter\n             }\n             if(m_existingCache.hasAttribute(name))\n             {\n-            \tif(!m_lastInWins)\n+            if(!m_lastInWins)\n             \t{\n             \t\t// We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributesUnresolved.remove(name);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/487/XMLSchemaConverter.java\nindex 71e16fd0e7e..611003c010f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/487/XMLSchemaConverter.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.impl;\n \n import java.math.BigInteger;\n@@ -155,10 +156,11 @@ import org.genxdm.xs.types.UnionSimpleType;\n  * distracting arguments to methods. The use of a static entry point and a private initializer protects against multiple\n  * invocations.\n  */\n-public final class XMLSchemaConverter\n-{\n-    private XMLSchemaConverter(final SchemaRegExCompiler regexc, final ComponentProvider outCache, final XMLSchemaCache inCache, final ComponentBagImpl schema, final XMLComponentLocator locations, final SchemaExceptionHandler errors, final boolean lastInWins)\n-    {\n+public final class XMLSchemaConverter {\n+    private XMLSchemaConverter(final SchemaRegExCompiler regexc, final ComponentProvider outCache,\n+                               final XMLSchemaCache inCache, final ComponentBagImpl schema,\n+                               final XMLComponentLocator locations,\n+                               final SchemaExceptionHandler errors, final boolean lastInWins) {\n         this.regexc = regexc;\n         this.m_existingCache = outCache;\n         this.m_atoms = new CanonicalAtomBridge(outCache);\n@@ -170,132 +172,106 @@ public final class XMLSchemaConverter\n         this.m_lastInWins = lastInWins;\n     }\n \n-    private SchemaWildcard attributeWildcard(final Type baseType)\n-    {\n-        if (baseType instanceof ComplexType)\n-        {\n-            final ComplexType complexBase = (ComplexType)baseType;\n+    private SchemaWildcard attributeWildcard(final Type baseType) {\n+        if (baseType instanceof ComplexType) {\n+            final ComplexType complexBase = (ComplexType) baseType;\n             final SchemaWildcard attributeWildcard = complexBase.getAttributeWildcard();\n-            if (null != attributeWildcard)\n-            {\n+            if (null != attributeWildcard) {\n                 return attributeWildcard;\n-            }\n-            else\n-            {\n+            } else {\n                 return null;\n             }\n-        }\n-        else if (baseType instanceof SimpleType)\n-        {\n+        } else if (baseType instanceof SimpleType) {\n             return null;\n-        }\n-        else\n-        {\n+        } else {\n             throw new AssertionError(baseType);\n         }\n     }\n \n-    private SchemaWildcard attributeWildcard(final XMLType complexType) throws AbortException, SchemaException\n-    {\n+    private SchemaWildcard attributeWildcard(final XMLType complexType)\n+        throws AbortException, SchemaException {\n         final XMLWildcard localWildcard = complexType.attributeWildcard;\n \n         final DerivationMethod derivation = complexType.getDerivationMethod();\n-        switch (derivation)\n-        {\n-            case Restriction:\n-            {\n+        switch (derivation) {\n+            case Restriction: {\n                 return completeWildcard(complexType.getAttributeGroups(), localWildcard);\n             }\n-            case Extension:\n-            {\n+            case Extension: {\n                 final SchemaWildcard baseWildcard = attributeWildcard(complexType.getBaseRef());\n-                if (null != baseWildcard)\n-                {\n-                    final SchemaWildcard completeWildcard = completeWildcard(complexType.getAttributeGroups(), localWildcard);\n-                    if (null == completeWildcard)\n-                    {\n+                if (null != baseWildcard) {\n+                    final SchemaWildcard completeWildcard =\n+                        completeWildcard(complexType.getAttributeGroups(), localWildcard);\n+                    if (null == completeWildcard) {\n                         return baseWildcard;\n-                    }\n-                    else\n-                    {\n+                    } else {\n                         // {process contents} and {annotation} from complete\n                         // wildcard.\n                         // {namespace constraint} is union of the complete and\n                         // base wildcard.\n-                        return new WildcardImpl(completeWildcard.getProcessContents(), completeWildcard.getNamespaceConstraint().union(baseWildcard.getNamespaceConstraint()));\n+                        return new WildcardImpl(completeWildcard.getProcessContents(),\n+                            completeWildcard.getNamespaceConstraint()\n+                                .union(baseWildcard.getNamespaceConstraint()));\n                     }\n-                }\n-                else\n-                {\n+                } else {\n                     return completeWildcard(complexType.getAttributeGroups(), localWildcard);\n                 }\n             }\n-            default:\n-            {\n+            default: {\n                 // Complex type must be derived by restriction or extension.\n                 throw new AssertionError(derivation);\n             }\n         }\n     }\n \n-    private SchemaWildcard attributeWildcard(final XMLTypeRef typeRef) throws AbortException, SchemaException\n-    {\n+    private SchemaWildcard attributeWildcard(final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException {\n         final Type type = convertType(typeRef);\n         return attributeWildcard(type);\n     }\n \n-    private SchemaWildcard completeWildcard(final Iterable<XMLAttributeGroup> attributeGroups, final XMLWildcard localWildcard) throws AbortException, SchemaException\n-    {\n+    private SchemaWildcard completeWildcard(final Iterable<XMLAttributeGroup> attributeGroups,\n+                                            final XMLWildcard localWildcard)\n+        throws AbortException, SchemaException {\n         NamespaceConstraint constraint = null;\n \n         // Remember the first {process contents} within the\n         // <attributeGroup>[children].\n         ProcessContentsMode processContents = null;\n-        if (null != attributeGroups)\n-        {\n-            for (final XMLAttributeGroup xmlAttributeGroup : attributeGroups)\n-            {\n-                final AttributeGroupDefinition attributeGroup = convertAttributeGroup(xmlAttributeGroup);\n+        if (null != attributeGroups) {\n+            for (final XMLAttributeGroup xmlAttributeGroup : attributeGroups) {\n+                final AttributeGroupDefinition attributeGroup =\n+                    convertAttributeGroup(xmlAttributeGroup);\n                 final SchemaWildcard groupWildcard = attributeGroup.getWildcard();\n-                if (null != groupWildcard)\n-                {\n-                    if (null == constraint)\n-                    {\n+                if (null != groupWildcard) {\n+                    if (null == constraint) {\n                         constraint = groupWildcard.getNamespaceConstraint();\n                         processContents = groupWildcard.getProcessContents();\n-                    }\n-                    else\n-                    {\n-                        constraint = constraint.intersection(groupWildcard.getNamespaceConstraint());\n+                    } else {\n+                        constraint =\n+                            constraint.intersection(groupWildcard.getNamespaceConstraint());\n                     }\n                 }\n             }\n         }\n \n-        if (null == constraint)\n-        {\n+        if (null == constraint) {\n             // If nothing is found in the <attributeGroup>[children]...\n-            if (null != localWildcard)\n-            {\n-                return new WildcardImpl(localWildcard.getProcessContents(), convert(localWildcard.getNamespaceConstraint()));\n-            }\n-            else\n-            {\n+            if (null != localWildcard) {\n+                return new WildcardImpl(localWildcard.getProcessContents(),\n+                    convert(localWildcard.getNamespaceConstraint()));\n+            } else {\n                 return null;\n             }\n-        }\n-        else\n-        {\n-            if (null != localWildcard)\n-            {\n+        } else {\n+            if (null != localWildcard) {\n                 // {process contents} and {annotation} are those of the local\n                 // wildcard.\n                 // {namespace constraint} defined by Attribute Wildcard\n                 // Intersection.\n-                return new WildcardImpl(localWildcard.getProcessContents(), convert(localWildcard.getNamespaceConstraint()).intersection(constraint));\n-            }\n-            else\n-            {\n+                return new WildcardImpl(localWildcard.getProcessContents(),\n+                    convert(localWildcard.getNamespaceConstraint()).intersection(constraint));\n+            } else {\n                 // {process contents} from first <attributeGroup>[children]\n                 // {namespace constraint} from the <attributeGroup>[children]\n                 // {annotation} is absent.\n@@ -307,73 +283,54 @@ public final class XMLSchemaConverter\n     /**\n      * Expand temporary variables used to hold syntactic constructs for attribute uses and wildcards.\n      */\n-    private Map<QName, AttributeUse> computeAttributeUses(final XMLType complexType) throws AbortException, SchemaException\n-    {\n+    private Map<QName, AttributeUse> computeAttributeUses(final XMLType complexType)\n+        throws AbortException, SchemaException {\n         final HashMap<QName, AttributeUse> attributeUses = new HashMap<QName, AttributeUse>();\n \n-        for (final XMLAttributeUse attributeUse : complexType.getAttributeUses())\n-        {\n+        for (final XMLAttributeUse attributeUse : complexType.getAttributeUses()) {\n             final QName attributeName = attributeUse.getDeclaration().getName();\n-            try\n-            {\n-                if (!attributeUses.containsKey(attributeName))\n-                {\n+            try {\n+                if (!attributeUses.containsKey(attributeName)) {\n                     attributeUses.put(attributeName, convertAttributeUse(attributeUse));\n-                }\n-                else\n-                {\n+                } else {\n                     m_errors.error(new SccAttributeGroupMemberNamesException());\n                 }\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n \n-        for (final XMLAttributeGroup xmlAttributeGroup : complexType.getAttributeGroups())\n-        {\n-            final AttributeGroupDefinition attributeGroup = convertAttributeGroup(xmlAttributeGroup);\n-            if (attributeGroup.hasAttributeUses())\n-            {\n-                for (final AttributeUse attributeUse : attributeGroup.getAttributeUses())\n-                {\n+        for (final XMLAttributeGroup xmlAttributeGroup : complexType.getAttributeGroups()) {\n+            final AttributeGroupDefinition attributeGroup =\n+                convertAttributeGroup(xmlAttributeGroup);\n+            if (attributeGroup.hasAttributeUses()) {\n+                for (final AttributeUse attributeUse : attributeGroup.getAttributeUses()) {\n                     final AttributeDefinition attribute = attributeUse.getAttribute();\n                     final QName attributeName = attribute.getName();\n-                    if (!attributeUses.containsKey(attributeName))\n-                    {\n+                    if (!attributeUses.containsKey(attributeName)) {\n                         attributeUses.put(attributeName, attributeUse);\n-                    }\n-                    else\n-                    {\n+                    } else {\n                         m_errors.error(new SccAttributeGroupMemberNamesException());\n                     }\n                 }\n             }\n         }\n \n-        switch (complexType.getDerivationMethod())\n-        {\n-            case Restriction:\n-            {\n+        switch (complexType.getDerivationMethod()) {\n+            case Restriction: {\n                 final Type typeB = convertType(complexType.getBaseRef());\n-                if (typeB instanceof ComplexType)\n-                {\n-                    final ComplexType complexTypeB = (ComplexType)typeB;\n-                    for (final AttributeUse attributeUse : complexTypeB.getAttributeUses().values())\n-                    {\n+                if (typeB instanceof ComplexType) {\n+                    final ComplexType complexTypeB = (ComplexType) typeB;\n+                    for (final AttributeUse attributeUse : complexTypeB.getAttributeUses()\n+                        .values()) {\n                         final QName attributeName = attributeUse.getAttribute().getName();\n-                        if (!complexType.prohibited.contains(attributeName))\n-                        {\n-                            if (attributeUses.containsKey(attributeName))\n-                            {\n+                        if (!complexType.prohibited.contains(attributeName)) {\n+                            if (attributeUses.containsKey(attributeName)) {\n                                 // Obviously can't add it because that would\n                                 // cause a non-unique name.\n                                 // This collision will be analyzed during\n                                 // schema constraint checking.\n-                            }\n-                            else\n-                            {\n+                            } else {\n                                 attributeUses.put(attributeName, attributeUse);\n                             }\n                         }\n@@ -381,22 +338,19 @@ public final class XMLSchemaConverter\n                 }\n             }\n             break;\n-            case Extension:\n-            {\n+            case Extension: {\n                 final Type typeB = convertType(complexType.getBaseRef());\n-                if (typeB instanceof ComplexType)\n-                {\n-                    final ComplexType complexTypeB = (ComplexType)typeB;\n-                    for (final AttributeUse attributeUse : complexTypeB.getAttributeUses().values())\n-                    {\n+                if (typeB instanceof ComplexType) {\n+                    final ComplexType complexTypeB = (ComplexType) typeB;\n+                    for (final AttributeUse attributeUse : complexTypeB.getAttributeUses()\n+                        .values()) {\n                         final QName attributeName = attributeUse.getAttribute().getName();\n                         attributeUses.put(attributeName, attributeUse);\n                     }\n                 }\n             }\n             break;\n-            default:\n-            {\n+            default: {\n                 throw new RuntimeException(complexType.getDerivationMethod().name());\n             }\n         }\n@@ -408,88 +362,66 @@ public final class XMLSchemaConverter\n      * Compile the enumeration facets for this type. <br/>\n      * Enumeration facets are not inherited during compilation, but must be subsets of base types.\n      */\n-    private void computeEnumerations(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target) throws AbortException\n-    {\n-        if (type.getEnumerations().size() > 0)\n-        {\n-            for (final XMLEnumeration pattern : type.getEnumerations())\n-            {\n-                try\n-                {\n+    private void computeEnumerations(final SimpleType baseType, final XMLType type,\n+                                     final SimpleTypeImpl target) throws AbortException {\n+        if (type.getEnumerations().size() > 0) {\n+            for (final XMLEnumeration pattern : type.getEnumerations()) {\n+                try {\n                     target.addEnumeration(enumeration(target, baseType, pattern));\n-                }\n-                catch (final SmAttributeUseException e)\n-                {\n+                } catch (final SmAttributeUseException e) {\n                     m_errors.error(e);\n                 }\n             }\n         }\n     }\n \n-    private void computeFacets(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target) throws AbortException, SchemaException\n-    {\n-        for (final XMLTotalDigitsFacet xmlFacet : type.getTotalDigitsFacets())\n-        {\n+    private void computeFacets(final SimpleType baseType, final XMLType type,\n+                               final SimpleTypeImpl target) throws AbortException, SchemaException {\n+        for (final XMLTotalDigitsFacet xmlFacet : type.getTotalDigitsFacets()) {\n             target.addFacet(totalDigits(xmlFacet));\n         }\n-        for (final XMLFractionDigitsFacet xmlFacet : type.getFractionDigitsFacets())\n-        {\n+        for (final XMLFractionDigitsFacet xmlFacet : type.getFractionDigitsFacets()) {\n             target.addFacet(fractionDigits(xmlFacet));\n         }\n         // Note that the length, minLength and maxLength facets are deprecated\n         // for types derived from QName or NOTATION.\n-        if (!subtype(target, m_existingCache.getAtomicType(NativeType.QNAME)) && !subtype(target, m_existingCache.getAtomicType(NativeType.NOTATION)))\n-        {\n-            for (final XMLLength xmlFacet : type.getLengthFacets())\n-            {\n+        if (!subtype(target, m_existingCache.getAtomicType(NativeType.QNAME)) &&\n+            !subtype(target, m_existingCache.getAtomicType(NativeType.NOTATION))) {\n+            for (final XMLLength xmlFacet : type.getLengthFacets()) {\n                 target.addFacet(length(xmlFacet));\n             }\n         }\n-        for (final XMLMinMaxFacet xmlFacet : type.getMinMaxFacets())\n-        {\n-            if (baseType.isAtomicType())\n-            {\n-                try\n-                {\n-                    target.addFacet(minmax(xmlFacet, (SimpleType)baseType));\n-                }\n-                catch (final SchemaException e)\n-                {\n+        for (final XMLMinMaxFacet xmlFacet : type.getMinMaxFacets()) {\n+            if (baseType.isAtomicType()) {\n+                try {\n+                    target.addFacet(minmax(xmlFacet, (SimpleType) baseType));\n+                } catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n             }\n         }\n     }\n \n-    private ContentType computeLocallyEmptyContent(final XMLType complexType) throws SchemaException, AbortException\n-    {\n+    private ContentType computeLocallyEmptyContent(final XMLType complexType)\n+        throws SchemaException, AbortException {\n         final DerivationMethod derivation = complexType.getDerivationMethod();\n-        switch (derivation)\n-        {\n-            case Restriction:\n-            {\n+        switch (derivation) {\n+            case Restriction: {\n                 return EMPTY_CONTENT;\n             }\n-            case Extension:\n-            {\n+            case Extension: {\n                 final Type baseType = convertType(complexType.getBaseRef());\n-                if (baseType instanceof ComplexType)\n-                {\n-                    final ComplexType complexBase = (ComplexType)baseType;\n+                if (baseType instanceof ComplexType) {\n+                    final ComplexType complexBase = (ComplexType) baseType;\n                     return complexBase.getContentType();\n-                }\n-                else if (baseType instanceof SimpleType)\n-                {\n-                    final SimpleType simpleBase = (SimpleType)baseType;\n+                } else if (baseType instanceof SimpleType) {\n+                    final SimpleType simpleBase = (SimpleType) baseType;\n                     return new ContentTypeImpl(simpleBase);\n-                }\n-                else\n-                {\n+                } else {\n                     throw new AssertionError(derivation);\n                 }\n             }\n-            default:\n-            {\n+            default: {\n                 throw new AssertionError(derivation);\n             }\n         }\n@@ -499,140 +431,105 @@ public final class XMLSchemaConverter\n      * Compile the pattern facets for this type. <br/>\n      * Pattern facets are not inherited during compilation.\n      */\n-    private void computePatterns(final LinkedList<XMLPatternFacet> xmlFacets, final SimpleTypeImpl target) throws AbortException\n-    {\n-        if (xmlFacets.size() > 0)\n-        {\n-            for (final XMLPatternFacet pattern : xmlFacets)\n-            {\n-                try\n-                {\n+    private void computePatterns(final LinkedList<XMLPatternFacet> xmlFacets,\n+                                 final SimpleTypeImpl target) throws AbortException {\n+        if (xmlFacets.size() > 0) {\n+            for (final XMLPatternFacet pattern : xmlFacets) {\n+                try {\n                     target.addPattern(pattern(pattern));\n-                }\n-                catch (final SmAttributeUseException e)\n-                {\n+                } catch (final SmAttributeUseException e) {\n                     m_errors.error(e);\n                 }\n             }\n         }\n     }\n \n-    private Set<String> convert(final Iterable<String> strings)\n-    {\n+    private Set<String> convert(final Iterable<String> strings) {\n         final Set<String> result = new HashSet<String>();\n-        for (final String member : strings)\n-        {\n+        for (final String member : strings) {\n             result.add(member);\n         }\n         return result;\n     }\n \n-    private NamespaceConstraint convert(final NamespaceConstraint input)\n-    {\n-        switch (input.getMode())\n-        {\n-            case Any:\n-            {\n+    private NamespaceConstraint convert(final NamespaceConstraint input) {\n+        switch (input.getMode()) {\n+            case Any: {\n                 return NamespaceConstraint.Any();\n             }\n-            case Include:\n-            {\n+            case Include: {\n                 return NamespaceConstraint.include(convert(input.getNamespaces()));\n             }\n-            case Exclude:\n-            {\n+            case Exclude: {\n                 // This approach is a bit long-winded but it generalizes better\n                 // to multiple exclusions.\n                 final Iterator<String> namespaces = convert(input.getNamespaces()).iterator();\n-                if (namespaces.hasNext())\n-                {\n+                if (namespaces.hasNext()) {\n                     return NamespaceConstraint.exclude(namespaces.next());\n-                }\n-                else\n-                {\n+                } else {\n                     throw new AssertionError();\n                 }\n             }\n-            default:\n-            {\n+            default: {\n                 throw new AssertionError(input.getMode());\n             }\n         }\n     }\n \n-    private AttributeDefinition convertAttribute(final XMLAttribute xmlAttribute) throws AbortException, SchemaException\n-    {\n+    private AttributeDefinition convertAttribute(final XMLAttribute xmlAttribute)\n+        throws AbortException, SchemaException {\n         final QName name = xmlAttribute.getName();\n         final ScopeExtent scope = convertScope(xmlAttribute.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasAttribute(name))\n-            {\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasAttribute(name)) {\n                 return m_outBag.getAttribute(name);\n             }\n-            if(m_existingCache.hasAttribute(name))\n-            {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            if (m_existingCache.hasAttribute(name)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_attributesUnresolved.remove(name);\n                     return m_existingCache.getAttributeDeclaration(name);\n-            \t}\n-            \telse if(m_inCache.m_attributesUnresolved.containsKey(name) || m_attributesResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_attributesUnresolved.containsKey(name) ||\n+                    m_attributesResolvedFromExistingCache.containsKey(name)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_attributesUnresolved.remove(name);\n-            \t\tAttributeDefinition existing = m_existingCache.getAttributeDeclaration(name);\n-            \t\tm_attributesResolvedFromExistingCache.put(name, existing);\n+                    AttributeDefinition existing = m_existingCache.getAttributeDeclaration(name);\n+                    m_attributesResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.attributes.contains(xmlAttribute))\n-            {\n+            if (m_cycles.attributes.contains(xmlAttribute)) {\n                 throw new SccCyclicAttributeException(name);\n-            }\n-            else\n-            {\n+            } else {\n                 m_cycles.attributes.push(xmlAttribute);\n             }\n         }\n         final AttributeDeclTypeImpl attribute;\n-        try\n-        {\n+        try {\n             attribute = new AttributeDeclTypeImpl(name, scope, m_existingCache.getSimpleUrType());\n-            if (scope == ScopeExtent.Global)\n-            {\n+            if (scope == ScopeExtent.Global) {\n                 m_outBag.add(attribute);\n             }\n             m_locations.m_attributeLocations.put(attribute, xmlAttribute.getLocation());\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n-            {\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.attributes.pop();\n             }\n         }\n         final Type attributeType = convertType(xmlAttribute.typeRef);\n-        if (attributeType instanceof SimpleType)\n-        {\n-            attribute.setType((SimpleType)attributeType);\n-        }\n-        else\n-        {\n+        if (attributeType instanceof SimpleType) {\n+            attribute.setType((SimpleType) attributeType);\n+        } else {\n             m_errors.error(new SccAttributeDeclarationSimpleTypeException(name));\n         }\n-        if (null != xmlAttribute.m_valueConstraint)\n-        {\n-            try\n-            {\n-                attribute.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ATTRIBUTE, xmlAttribute.m_valueConstraint, (SimpleType)attribute.getType()));\n-            }\n-            catch (final SchemaException e)\n-            {\n+        if (null != xmlAttribute.m_valueConstraint) {\n+            try {\n+                attribute.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ATTRIBUTE,\n+                    xmlAttribute.m_valueConstraint, (SimpleType) attribute.getType()));\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n@@ -640,202 +537,163 @@ public final class XMLSchemaConverter\n         return attribute;\n     }\n \n-    private AttributeGroupDefinition convertAttributeGroup(final XMLAttributeGroup xmlAttributeGroup) throws AbortException, SchemaException\n-    {\n-        final QName agName = PreCondition.assertArgumentNotNull(xmlAttributeGroup.getName(), \"name\");\n+    private AttributeGroupDefinition convertAttributeGroup(\n+        final XMLAttributeGroup xmlAttributeGroup) throws AbortException, SchemaException {\n+        final QName agName =\n+            PreCondition.assertArgumentNotNull(xmlAttributeGroup.getName(), \"name\");\n         final ScopeExtent scope = convertScope(xmlAttributeGroup.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasAttributeGroup(agName))\n-            {\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasAttributeGroup(agName)) {\n                 return m_outBag.getAttributeGroup(agName);\n             }\n-            if(m_existingCache.hasAttributeGroup(agName))\n-            {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            if (m_existingCache.hasAttributeGroup(agName)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_attributeGroupsUnresolved.remove(agName);\n                     return m_existingCache.getAttributeGroup(agName);\n-            \t}\n-            \telse if(m_inCache.m_attributeGroupsUnresolved.containsKey(agName) || m_attributeGroupsResolvedFromExistingCache.containsKey(agName))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_attributeGroupsUnresolved.containsKey(agName) ||\n+                    m_attributeGroupsResolvedFromExistingCache.containsKey(agName)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_attributeGroupsUnresolved.remove(agName);\n-            \t\tAttributeGroupDefinition existing = m_existingCache.getAttributeGroup(agName);\n-            \t\tm_attributeGroupsResolvedFromExistingCache.put(agName, existing);\n+                    AttributeGroupDefinition existing = m_existingCache.getAttributeGroup(agName);\n+                    m_attributeGroupsResolvedFromExistingCache.put(agName, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.attributeGroups.contains(xmlAttributeGroup))\n-            {\n+            if (m_cycles.attributeGroups.contains(xmlAttributeGroup)) {\n                 throw new SccCyclicAttributeGroupException(xmlAttributeGroup.getName());\n-            }\n-            else\n-            {\n+            } else {\n                 m_cycles.attributeGroups.push(xmlAttributeGroup);\n             }\n         }\n-        try\n-        {\n+        try {\n             final HashMap<QName, AttributeUse> attributeUses = new HashMap<QName, AttributeUse>();\n-            for (final XMLAttributeGroup group : xmlAttributeGroup.getGroups())\n-            {\n+            for (final XMLAttributeGroup group : xmlAttributeGroup.getGroups()) {\n                 final AttributeGroupDefinition attributeGroup = convertAttributeGroup(group);\n-                if (attributeGroup.hasAttributeUses())\n-                {\n-                    for (final AttributeUse attributeUse : attributeGroup.getAttributeUses())\n-                    {\n+                if (attributeGroup.hasAttributeUses()) {\n+                    for (final AttributeUse attributeUse : attributeGroup.getAttributeUses()) {\n                         attributeUses.put(attributeUse.getAttribute().getName(), attributeUse);\n                     }\n                 }\n             }\n-            for (final XMLAttributeUse attributeUse : xmlAttributeGroup.getAttributeUses())\n-            {\n+            for (final XMLAttributeUse attributeUse : xmlAttributeGroup.getAttributeUses()) {\n                 final QName name = attributeUse.getDeclaration().getName();\n-                try\n-                {\n+                try {\n                     attributeUses.put(name, convertAttributeUse(attributeUse));\n-                }\n-                catch (final SchemaException e)\n-                {\n+                } catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n             }\n-            final SchemaWildcard completeWildcard = completeWildcard(xmlAttributeGroup.getGroups(), xmlAttributeGroup.wildcard);\n+            final SchemaWildcard completeWildcard =\n+                completeWildcard(xmlAttributeGroup.getGroups(), xmlAttributeGroup.wildcard);\n             final AttributeGroupDefinition attributeGroup;\n-            attributeGroup = new AttributeGroupImpl(agName, scope, attributeUses.values(), completeWildcard);\n+            attributeGroup =\n+                new AttributeGroupImpl(agName, scope, attributeUses.values(), completeWildcard);\n \n-            if (attributeGroup.getScopeExtent() == ScopeExtent.Global)\n-            {\n+            if (attributeGroup.getScopeExtent() == ScopeExtent.Global) {\n                 m_outBag.add(attributeGroup);\n             }\n-            m_locations.m_attributeGroupLocations.put(attributeGroup, xmlAttributeGroup.getLocation());\n-            copyForeignAttributes(xmlAttributeGroup.foreignAttributes, (AttributeGroupImpl)attributeGroup);\n+            m_locations.m_attributeGroupLocations\n+                .put(attributeGroup, xmlAttributeGroup.getLocation());\n+            copyForeignAttributes(xmlAttributeGroup.foreignAttributes,\n+                (AttributeGroupImpl) attributeGroup);\n             return attributeGroup;\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n-            {\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.attributeGroups.pop();\n             }\n         }\n     }\n \n-    private void convertAttributeGroups() throws AbortException\n-    {\n-        for (final XMLAttributeGroup source : m_inCache.m_attributeGroups.values())\n-        {\n-            try\n-            {\n+    private void convertAttributeGroups() throws AbortException {\n+        for (final XMLAttributeGroup source : m_inCache.m_attributeGroups.values()) {\n+            try {\n                 QName name = source.getName();\n-                if(!m_lastInWins && m_existingCache.getAttributeGroup(name) != null)\n-                {\n+                if (!m_lastInWins && m_existingCache.getAttributeGroup(name) != null) {\n                     m_inCache.m_attributeGroupsUnresolved.remove(name);\n                 }\n                 convertAttributeGroup(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private void convertAttributes() throws AbortException\n-    {\n-        for (final XMLAttribute source : m_inCache.m_attributes.values())\n-        {\n-            try\n-            {\n+    private void convertAttributes() throws AbortException {\n+        for (final XMLAttribute source : m_inCache.m_attributes.values()) {\n+            try {\n                 QName name = source.getName();\n-                \n-                if(!m_lastInWins && m_existingCache.hasAttribute(name))\n-                {\n+\n+                if (!m_lastInWins && m_existingCache.hasAttribute(name)) {\n                     m_inCache.m_attributesUnresolved.remove(name);\n                 }\n                 convertAttribute(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private AttributeUse convertAttributeUse(final XMLAttributeUse xmlAttributeUse) throws AbortException, SchemaException\n-    {\n+    private AttributeUse convertAttributeUse(final XMLAttributeUse xmlAttributeUse)\n+        throws AbortException, SchemaException {\n         final AttributeDefinition attribute = convertAttribute(xmlAttributeUse.getDeclaration());\n-        final AttributeUseImpl attributeUse = new AttributeUseImpl(xmlAttributeUse.isRequired(), attribute);\n-        if (null != xmlAttributeUse.getValueConstraint())\n-        {\n+        final AttributeUseImpl attributeUse =\n+            new AttributeUseImpl(xmlAttributeUse.isRequired(), attribute);\n+        if (null != xmlAttributeUse.getValueConstraint()) {\n             final Type attributeType = attribute.getType();\n-            if (attributeType instanceof SimpleType)\n-            {\n-                final SimpleType simpleType = (SimpleType)attributeType;\n-                try\n-                {\n-                    attributeUse.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ATTRIBUTE, xmlAttributeUse.getValueConstraint(), simpleType));\n-                }\n-                catch (final SchemaException e)\n-                {\n+            if (attributeType instanceof SimpleType) {\n+                final SimpleType simpleType = (SimpleType) attributeType;\n+                try {\n+                    attributeUse.setValueConstraint(\n+                        convertValueConstraint(XMLRepresentation.LN_ATTRIBUTE,\n+                            xmlAttributeUse.getValueConstraint(), simpleType));\n+                } catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n-            }\n-            else if (attributeType instanceof SimpleUrType)\n-            {\n+            } else if (attributeType instanceof SimpleUrType) {\n                 // TODO: Do we set the value constraint with xs:untypedAtomic?\n-            }\n-            else\n-            {\n+            } else {\n                 throw new AssertionError(attributeType);\n             }\n         }\n         return attributeUse;\n     }\n \n-    private ComplexType convertComplexType(final QName outName, final boolean isAnonymous, final XMLType xmlComplexType) throws AbortException, SchemaException\n-    {\n+    private ComplexType convertComplexType(final QName outName, final boolean isAnonymous,\n+                                           final XMLType xmlComplexType)\n+        throws AbortException, SchemaException {\n         final ScopeExtent scope = convertScope(xmlComplexType.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasComplexType(outName))\n-            {\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasComplexType(outName)) {\n                 return m_outBag.getComplexType(outName);\n             }\n-            if(m_existingCache.hasComplexType(outName))\n-            {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            if (m_existingCache.hasComplexType(outName)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_typesUnresolved.remove(outName);\n                     return m_existingCache.getComplexType(outName);\n-            \t}\n-            \telse if(m_inCache.m_typesUnresolved.containsKey(outName) || m_typesResolvedFromExistingCache.containsKey(outName))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_typesUnresolved.containsKey(outName) ||\n+                    m_typesResolvedFromExistingCache.containsKey(outName)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_typesUnresolved.remove(outName);\n-            \t\tComplexType existing = m_existingCache.getComplexType(outName);\n-            \t\tm_typesResolvedFromExistingCache.put(outName, existing);\n+                    ComplexType existing = m_existingCache.getComplexType(outName);\n+                    m_typesResolvedFromExistingCache.put(outName, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.types.contains(xmlComplexType))\n-            {\n+            if (m_cycles.types.contains(xmlComplexType)) {\n                 throw new SmCyclicTypeException(outName);\n             }\n \n             m_cycles.types.push(xmlComplexType);\n         }\n-        try\n-        {\n+        try {\n \n             final Map<QName, AttributeUse> attributeUses = computeAttributeUses(xmlComplexType);\n             final Type baseType = convertType(xmlComplexType.getBaseRef());\n@@ -843,13 +701,16 @@ public final class XMLSchemaConverter\n             // Constructing and registering the complex type allows it to be\n             // referenced in the {content type} property.\n             final ComplexTypeImpl complexType;\n-            if (null != attributeUses)\n-            {\n-                complexType = new ComplexTypeImpl(outName, false, isAnonymous, scope, baseType, xmlComplexType.getDerivationMethod(), attributeUses, EMPTY_CONTENT, xmlComplexType.getBlock(), m_existingCache.getAtomicType(NativeType.UNTYPED_ATOMIC));\n-            }\n-            else\n-            {\n-                complexType = new ComplexTypeImpl(outName, false, isAnonymous, scope, baseType, xmlComplexType.getDerivationMethod(), null, EMPTY_CONTENT, xmlComplexType.getBlock(), m_existingCache.getAtomicType(NativeType.UNTYPED_ATOMIC));\n+            if (null != attributeUses) {\n+                complexType = new ComplexTypeImpl(outName, false, isAnonymous, scope, baseType,\n+                    xmlComplexType.getDerivationMethod(), attributeUses, EMPTY_CONTENT,\n+                    xmlComplexType.getBlock(),\n+                    m_existingCache.getAtomicType(NativeType.UNTYPED_ATOMIC));\n+            } else {\n+                complexType = new ComplexTypeImpl(outName, false, isAnonymous, scope, baseType,\n+                    xmlComplexType.getDerivationMethod(), null, EMPTY_CONTENT,\n+                    xmlComplexType.getBlock(),\n+                    m_existingCache.getAtomicType(NativeType.UNTYPED_ATOMIC));\n             }\n             m_outBag.add(complexType);\n             m_locations.m_complexTypeLocations.put(complexType, xmlComplexType.getLocation());\n@@ -859,241 +720,174 @@ public final class XMLSchemaConverter\n             complexType.setAbstract(xmlComplexType.isAbstract());\n             complexType.setAttributeWildcard(attributeWildcard(xmlComplexType));\n \n-            for (final DerivationMethod derivation : xmlComplexType.getBlock())\n-            {\n+            for (final DerivationMethod derivation : xmlComplexType.getBlock()) {\n                 complexType.setBlock(derivation, true);\n             }\n \n-            for (final DerivationMethod derivation : xmlComplexType.getFinal())\n-            {\n-                if (derivation.isExtension() || derivation.isRestriction())\n-                {\n+            for (final DerivationMethod derivation : xmlComplexType.getFinal()) {\n+                if (derivation.isExtension() || derivation.isRestriction()) {\n                     complexType.setFinal(derivation, true);\n-                }\n-                else\n-                {\n+                } else {\n                     throw new AssertionError(derivation);\n                 }\n             }\n             copyForeignAttributes(xmlComplexType.foreignAttributes, complexType);\n             return complexType;\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n-            {\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.types.pop();\n             }\n         }\n     }\n \n-    private ContentType convertContentType(final XMLType xmlComplexType) throws AbortException, SchemaException\n-    {\n+    private ContentType convertContentType(final XMLType xmlComplexType)\n+        throws AbortException, SchemaException {\n         final DerivationMethod derivation = xmlComplexType.getDerivationMethod();\n \n-        if (xmlComplexType.m_contentKind.isComplex())\n-        {\n+        if (xmlComplexType.m_contentKind.isComplex()) {\n             final boolean mixed = xmlComplexType.m_contentKind.isMixed();\n-            final ModelGroupUse effectiveContent = effectiveContent(mixed, xmlComplexType.m_contentModel);\n-            if (derivation.isRestriction())\n-            {\n-                if (null == effectiveContent)\n-                {\n+            final ModelGroupUse effectiveContent =\n+                effectiveContent(mixed, xmlComplexType.m_contentModel);\n+            if (derivation.isRestriction()) {\n+                if (null == effectiveContent) {\n                     return EMPTY_CONTENT;\n-                }\n-                else\n-                {\n-                    if (mixed)\n-                    {\n+                } else {\n+                    if (mixed) {\n                         return new ContentTypeImpl(mixed, effectiveContent);\n-                    }\n-                    else\n-                    {\n-                        if (effectiveContent.getTerm() == null || effectiveContent.getTerm().getParticles().isEmpty())\n-                        {\n+                    } else {\n+                        if (effectiveContent.getTerm() == null ||\n+                            effectiveContent.getTerm().getParticles().isEmpty()) {\n                             return EMPTY_CONTENT;\n-                        }\n-                        else\n-                        {\n+                        } else {\n                             return new ContentTypeImpl(mixed, effectiveContent);\n                         }\n                     }\n                 }\n-            }\n-            else if (derivation.isExtension())\n-            {\n+            } else if (derivation.isExtension()) {\n                 final Type typeB = convertType(xmlComplexType.getBaseRef());\n-                if (typeB instanceof ComplexType)\n-                {\n-                    final ComplexType complexTypeB = (ComplexType)typeB;\n+                if (typeB instanceof ComplexType) {\n+                    final ComplexType complexTypeB = (ComplexType) typeB;\n                     final ContentType contentTypeB = complexTypeB.getContentType();\n-                    if (null == effectiveContent)\n-                    {\n+                    if (null == effectiveContent) {\n                         return contentTypeB;\n-                    }\n-                    else if (contentTypeB.isEmpty())\n-                    {\n+                    } else if (contentTypeB.isEmpty()) {\n                         return new ContentTypeImpl(mixed, effectiveContent);\n-                    }\n-                    else if (contentTypeB.isSimple())\n-                    {\n-                        throw new SrcBaseContentTypeCannotBeSimpleException(xmlComplexType.getName(), complexTypeB.getName(), xmlComplexType.getLocation());\n-                    }\n-                    else if (contentTypeB.isComplex())\n-                    {\n+                    } else if (contentTypeB.isSimple()) {\n+                        throw new SrcBaseContentTypeCannotBeSimpleException(\n+                            xmlComplexType.getName(), complexTypeB.getName(),\n+                            xmlComplexType.getLocation());\n+                    } else if (contentTypeB.isComplex()) {\n                         final LinkedList<ModelGroupUse> particles = new LinkedList<ModelGroupUse>();\n                         particles.add(contentTypeB.getContentModel());\n                         particles.add(effectiveContent);\n-                        final ModelGroup modelGroup = new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null, true, ScopeExtent.Local);\n-                        final ModelGroupUse particle = new ParticleWithModelGroupTerm(1, 1, modelGroup);\n+                        final ModelGroup modelGroup =\n+                            new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null,\n+                                true, ScopeExtent.Local);\n+                        final ModelGroupUse particle =\n+                            new ParticleWithModelGroupTerm(1, 1, modelGroup);\n                         return new ContentTypeImpl(mixed, particle);\n-                    }\n-                    else\n-                    {\n+                    } else {\n                         throw new AssertionError(contentTypeB.getKind());\n                     }\n-                }\n-                else\n-                {\n+                } else {\n                     throw new SrcBaseTypeMustBeComplexTypeException(xmlComplexType.getLocation());\n                 }\n-            }\n-            else\n-            {\n+            } else {\n                 throw new AssertionError(derivation);\n             }\n-        }\n-        else if (xmlComplexType.m_contentKind.isSimple())\n-        {\n+        } else if (xmlComplexType.m_contentKind.isSimple()) {\n             final Type typeB = convertType(xmlComplexType.getBaseRef());\n-            if (typeB instanceof ComplexType)\n-            {\n-                final ComplexType complexTypeB = (ComplexType)typeB;\n+            if (typeB instanceof ComplexType) {\n+                final ComplexType complexTypeB = (ComplexType) typeB;\n                 final ContentType contentTypeB = complexTypeB.getContentType();\n-                if (contentTypeB.isSimple())\n-                {\n-                    if (derivation.isRestriction())\n-                    {\n-                        return simpleContent(xmlComplexType.simpleType, contentTypeB.getSimpleType());\n-                    }\n-                    else if (derivation.isExtension())\n-                    {\n+                if (contentTypeB.isSimple()) {\n+                    if (derivation.isRestriction()) {\n+                        return simpleContent(xmlComplexType.simpleType,\n+                            contentTypeB.getSimpleType());\n+                    } else if (derivation.isExtension()) {\n                         return contentTypeB;\n-                    }\n-                    else\n-                    {\n+                    } else {\n                         throw new AssertionError(derivation);\n                     }\n-                }\n-                else\n-                {\n-                    if (derivation.isRestriction())\n-                    {\n-                        if (contentTypeB.isMixed())\n-                        {\n+                } else {\n+                    if (derivation.isRestriction()) {\n+                        if (contentTypeB.isMixed()) {\n                             final ModelGroupUse contentModelB = contentTypeB.getContentModel();\n-                            if (contentModelB.isEmptiable())\n-                            {\n-                                final XMLTypeRef simpleType = xmlComplexType.simpleType.getBaseRef();\n-                                if (null != simpleType)\n-                                {\n+                            if (contentModelB.isEmptiable()) {\n+                                final XMLTypeRef simpleType =\n+                                    xmlComplexType.simpleType.getBaseRef();\n+                                if (null != simpleType) {\n                                     final SimpleType simpleBaseType = extractSimpleType(simpleType);\n                                     return simpleContent(xmlComplexType.simpleType, simpleBaseType);\n+                                } else {\n+                                    throw new SrcSimpleTypeAmongChildrenOfRestrictionException(\n+                                        xmlComplexType.getLocation());\n                                 }\n-                                else\n-                                {\n-                                    throw new SrcSimpleTypeAmongChildrenOfRestrictionException(xmlComplexType.getLocation());\n-                                }\n+                            } else {\n+                                throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(\n+                                    xmlComplexType.getLocation());\n                             }\n-                            else\n-                            {\n-                                throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n-                            }\n-                        }\n-                        else\n-                        {\n-                            throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n+                        } else {\n+                            throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(\n+                                xmlComplexType.getLocation());\n                         }\n-                    }\n-                    else if (derivation.isExtension())\n-                    {\n-                        throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(xmlComplexType.getLocation());\n-                    }\n-                    else\n-                    {\n+                    } else if (derivation.isExtension()) {\n+                        throw new SrcBaseMustHaveSimpleOrMixedContentTypeComplexTypeException(\n+                            xmlComplexType.getLocation());\n+                    } else {\n                         throw new AssertionError(derivation);\n                     }\n                 }\n-            }\n-            else if (typeB instanceof SimpleType)\n-            {\n-                final SimpleType simpleTypeB = (SimpleType)typeB;\n-                if (derivation.isExtension())\n-                {\n+            } else if (typeB instanceof SimpleType) {\n+                final SimpleType simpleTypeB = (SimpleType) typeB;\n+                if (derivation.isExtension()) {\n                     return new ContentTypeImpl(simpleTypeB);\n-                }\n-                else if (derivation.isRestriction())\n-                {\n+                } else if (derivation.isRestriction()) {\n                     return new ContentTypeImpl(simpleTypeB);\n-                }\n-                else\n-                {\n+                } else {\n                     throw new AssertionError(derivation);\n                 }\n-            }\n-            else\n-            {\n+            } else {\n                 throw new AssertionError(typeB);\n             }\n-        }\n-        else\n-        {\n+        } else {\n             return computeLocallyEmptyContent(xmlComplexType);\n         }\n     }\n \n-    private ElementDefinition convertElement(final XMLElement xmlElement) throws SchemaException, AbortException\n-    {\n+    private ElementDefinition convertElement(final XMLElement xmlElement)\n+        throws SchemaException, AbortException {\n         final QName name = PreCondition.assertArgumentNotNull(xmlElement.getName(), \"name\");\n         final ScopeExtent scope = convertScope(xmlElement.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasElement(name))\n-            {\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasElement(name)) {\n                 return m_outBag.getElement(name);\n             }\n-            if(m_existingCache.hasElement(name))\n-            {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            if (m_existingCache.hasElement(name)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_elementsUnresolved.remove(name);\n                     return m_existingCache.getElementDeclaration(name);\n-            \t}\n-            \telse if(m_inCache.m_elementsUnresolved.containsKey(name) || m_elementsResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This element is a reference which refers to an imported element; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_elementsUnresolved.  When XMLSchemaCache.registerELement is called, it removes name from m_elementsUnresolved,\n-            \t\t// and registerElement is called when XMLSchemaParser encounters a global element, the only elements that can be referenced.\n-            \t\t// So, we're going to remove its name from the list and NOT convert it -- it's just a reference\n+                } else if (m_inCache.m_elementsUnresolved.containsKey(name) ||\n+                    m_elementsResolvedFromExistingCache.containsKey(name)) {\n+                    // This element is a reference which refers to an imported element; otherwise, its name would not be\n+                    // in the m_inCache.m_elementsUnresolved.  When XMLSchemaCache.registerELement is called, it removes name from m_elementsUnresolved,\n+                    // and registerElement is called when XMLSchemaParser encounters a global element, the only elements that can be referenced.\n+                    // So, we're going to remove its name from the list and NOT convert it -- it's just a reference\n                     m_inCache.m_elementsUnresolved.remove(name);\n-            \t\tElementDefinition existing = m_existingCache.getElementDeclaration(name);\n-            \t\tm_elementsResolvedFromExistingCache.put(name, existing);\n+                    ElementDefinition existing = m_existingCache.getElementDeclaration(name);\n+                    m_elementsResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.elements.contains(xmlElement))\n-            {\n+            if (m_cycles.elements.contains(xmlElement)) {\n                 throw new SccCyclicElementException(name);\n-            }\n-            else\n-            {\n+            } else {\n                 m_cycles.elements.push(xmlElement);\n             }\n         }\n         final ElementDeclTypeImpl element;\n-        try\n-        {\n+        try {\n             PreCondition.assertArgumentNotNull(xmlElement.typeRef, \"{type definition} of \" + name);\n \n             // The element {type definition} defaults to xs:anyType because\n@@ -1105,30 +899,25 @@ public final class XMLSchemaConverter\n             element = new ElementDeclTypeImpl(name, scope, anyType);\n \n             // {substitution group affiliation}\n-            if (null != xmlElement.substitutionGroup)\n-            {\n+            if (null != xmlElement.substitutionGroup) {\n                 // TODO: Would be nice to avoid this downcast. Maybe by using name for group head?\n-                final ElementDeclTypeImpl substitutionGroupHead = (ElementDeclTypeImpl)convertElement(xmlElement.substitutionGroup);\n+                final ElementDeclTypeImpl substitutionGroupHead =\n+                    (ElementDeclTypeImpl) convertElement(xmlElement.substitutionGroup);\n                 element.setSubstitutionGroup(substitutionGroupHead);\n                 substitutionGroupHead.addSubstitutionGroupMember(element);\n             }\n \n             // {identity-constraint definitions}\n-            for (final XMLIdentityConstraint constraint : xmlElement.getIdentityConstraints())\n-            {\n+            for (final XMLIdentityConstraint constraint : xmlElement.getIdentityConstraints()) {\n                 element.addIdentityConstraint(convertIdentityConstraint(constraint));\n             }\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n-            {\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.elements.pop();\n             }\n         }\n \n-        if (element.getScopeExtent() == ScopeExtent.Global)\n-        {\n+        if (element.getScopeExtent() == ScopeExtent.Global) {\n             m_outBag.add(element);\n         }\n         m_locations.m_elementLocations.put(element, xmlElement.getLocation());\n@@ -1140,58 +929,47 @@ public final class XMLSchemaConverter\n         element.setNillable(xmlElement.isNillable());\n \n         // {value constraint}\n-        if (null != xmlElement.m_valueConstraint)\n-        {\n-            if (element.getType() instanceof SimpleType)\n-            {\n-                final SimpleType elementType = (SimpleType)element.getType();\n-                try\n-                {\n-                    element.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlElement.m_valueConstraint, elementType));\n-                }\n-                catch (final SchemaException e)\n-                {\n+        if (null != xmlElement.m_valueConstraint) {\n+            if (element.getType() instanceof SimpleType) {\n+                final SimpleType elementType = (SimpleType) element.getType();\n+                try {\n+                    element.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ELEMENT,\n+                        xmlElement.m_valueConstraint, elementType));\n+                } catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n-            }\n-            else if (element.getType() instanceof ComplexType)\n-            {\n-                final ComplexType elementType = (ComplexType)element.getType();\n+            } else if (element.getType() instanceof ComplexType) {\n+                final ComplexType elementType = (ComplexType) element.getType();\n                 final ContentType contentType = elementType.getContentType();\n-                if (contentType.isSimple())\n-                {\n+                if (contentType.isSimple()) {\n                     final SimpleType simpleType = contentType.getSimpleType();\n-                    try\n-                    {\n-                        element.setValueConstraint(convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlElement.m_valueConstraint, simpleType));\n-                    }\n-                    catch (final SchemaException e)\n-                    {\n+                    try {\n+                        element.setValueConstraint(\n+                            convertValueConstraint(XMLRepresentation.LN_ELEMENT,\n+                                xmlElement.m_valueConstraint, simpleType));\n+                    } catch (final SchemaException e) {\n                         m_errors.error(e);\n                     }\n+                } else {\n+                    final String initialValue = xmlElement.m_valueConstraint.getValue();\n+                    final SimpleType simpleType =\n+                        m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC);\n+                    element.setValueConstraint(\n+                        new ValueConstraint(xmlElement.m_valueConstraint.kind, simpleType,\n+                            initialValue));\n                 }\n-                else\n-                {\n-                  final String initialValue = xmlElement.m_valueConstraint.getValue();\n-                  final SimpleType simpleType = m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC);\n-                  element.setValueConstraint(new ValueConstraint(xmlElement.m_valueConstraint.kind, simpleType, initialValue));\n-                }\n-            }\n-            else\n-            {\n+            } else {\n                 throw new AssertionError(element.getType());\n             }\n         }\n \n         // {disallowed substitutions}\n-        for (final DerivationMethod derivation : xmlElement.getBlock())\n-        {\n+        for (final DerivationMethod derivation : xmlElement.getBlock()) {\n             element.setBlock(derivation, true);\n         }\n \n         // {substitution group exclusions}\n-        for (final DerivationMethod derivation : xmlElement.getFinal())\n-        {\n+        for (final DerivationMethod derivation : xmlElement.getFinal()) {\n             element.setFinal(derivation, true);\n         }\n \n@@ -1206,71 +984,58 @@ public final class XMLSchemaConverter\n         return element;\n     }\n \n-    private void convertElements() throws AbortException\n-    {\n-        for (final XMLElement source : m_inCache.m_elements.values())\n-        {\n-            try\n-            {\n+    private void convertElements() throws AbortException {\n+        for (final XMLElement source : m_inCache.m_elements.values()) {\n+            try {\n                 QName name = source.getName();\n-                if(!m_lastInWins && m_existingCache.getElementDeclaration(name) != null)\n-                {\n+                if (!m_lastInWins && m_existingCache.getElementDeclaration(name) != null) {\n                     m_inCache.m_elementsUnresolved.remove(name);\n                 }\n                 convertElement(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private SchemaParticle convertElementUse(final XMLParticleWithElementTerm particle) throws SchemaException, AbortException\n-    {\n+    private SchemaParticle convertElementUse(final XMLParticleWithElementTerm particle)\n+        throws SchemaException, AbortException {\n         final XMLElement xmlElement = particle.getTerm();\n         final ElementDefinition element = convertElement(xmlElement);\n \n         final ParticleWithElementTerm elementUse;\n-        if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n-        {\n+        if (isMaxOccursUnbounded(particle.getMaxOccurs())) {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             elementUse = new ParticleWithElementTerm(minOccurs, element);\n-        }\n-        else\n-        {\n+        } else {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             final int maxOccurs = maxOccurs(particle.getMaxOccurs());\n             elementUse = new ParticleWithElementTerm(minOccurs, maxOccurs, element);\n         }\n         m_locations.m_particleLocations.put(elementUse, particle.getLocation());\n-        if (null != particle.valueConstraint)\n-        {\n-            final ValueConstraint valueConstraint = convertElementValueConstraint(particle.valueConstraint, element.getType());\n+        if (null != particle.valueConstraint) {\n+            final ValueConstraint valueConstraint =\n+                convertElementValueConstraint(particle.valueConstraint, element.getType());\n             elementUse.setValueConstraint(valueConstraint);\n         }\n         return elementUse;\n     }\n \n-    private ValueConstraint convertElementValueConstraint(final XMLValueConstraint xmlValueConstraint, final Type type) throws SchemaException\n-    {\n-        if (xmlValueConstraint != null)\n-        {\n-            if (type instanceof SimpleType)\n-            {\n-                return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint, (SimpleType)type);\n-            }\n-            else if (type instanceof ComplexType)\n-            {\n-                final ContentType contentType = ((ComplexType)type).getContentType();\n-                if (contentType.isSimple())\n-                {\n-                    return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint, contentType.getSimpleType());\n-                }\n-                else\n-                {\n+    private ValueConstraint convertElementValueConstraint(\n+        final XMLValueConstraint xmlValueConstraint, final Type type) throws SchemaException {\n+        if (xmlValueConstraint != null) {\n+            if (type instanceof SimpleType) {\n+                return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint,\n+                    (SimpleType) type);\n+            } else if (type instanceof ComplexType) {\n+                final ContentType contentType = ((ComplexType) type).getContentType();\n+                if (contentType.isSimple()) {\n+                    return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint,\n+                        contentType.getSimpleType());\n+                } else {\n                     final String initialValue = xmlValueConstraint.getValue();\n-                    return new ValueConstraint(xmlValueConstraint.kind, m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC), initialValue);\n+                    return new ValueConstraint(xmlValueConstraint.kind,\n+                        m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC), initialValue);\n                 }\n             }\n             throw new AssertionError(type); // neither simple nor complex; should not happen\n@@ -1278,253 +1043,196 @@ public final class XMLSchemaConverter\n         return null;\n     }\n \n-    private IdentityConstraint convertIdentityConstraint(final XMLIdentityConstraint xmlConstraint) throws SchemaException\n-    {\n+    private IdentityConstraint convertIdentityConstraint(final XMLIdentityConstraint xmlConstraint)\n+        throws SchemaException {\n         final QName name = xmlConstraint.getName();\n-        if (m_outBag.hasIdentityConstraint(name))\n-        {\n+        if (m_outBag.hasIdentityConstraint(name)) {\n             return m_outBag.getIdentityConstraint(name);\n         }\n-        if(m_existingCache.hasIdentityConstraint(name))\n-        {\n-        \tif(!m_lastInWins)\n-        \t{\n-        \t\t// We are not allowing this schema parse to create new elements.  \n+        if (m_existingCache.hasIdentityConstraint(name)) {\n+            if (!m_lastInWins) {\n+                // We are not allowing this schema parse to create new elements.\n                 m_inCache.m_constraintsUnresolved.remove(name);\n                 return m_existingCache.getIdentityConstraint(name);\n-        \t}\n-        \telse if(m_inCache.m_constraintsUnresolved.containsKey(name) || m_constraintsResolvedFromExistingCache.containsKey(name))\n-        \t{\n-        \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-        \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-        \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-        \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+            } else if (m_inCache.m_constraintsUnresolved.containsKey(name) ||\n+                m_constraintsResolvedFromExistingCache.containsKey(name)) {\n+                // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                 m_inCache.m_constraintsUnresolved.remove(name);\n-        \t\tIdentityConstraint existing = m_existingCache.getIdentityConstraint(name);\n-        \t\tm_constraintsResolvedFromExistingCache.put(name, existing);\n+                IdentityConstraint existing = m_existingCache.getIdentityConstraint(name);\n+                m_constraintsResolvedFromExistingCache.put(name, existing);\n                 return existing;\n-        \t}\n+            }\n         }\n-        if (m_cycles.constraints.contains(xmlConstraint))\n-        {\n+        if (m_cycles.constraints.contains(xmlConstraint)) {\n             throw new SccCyclicIdentityConstraintException(name);\n         }\n         m_cycles.constraints.push(xmlConstraint);\n-        try\n-        {\n-            if (null == xmlConstraint.keyConstraint)\n-            {\n-                final IdentityConstraint constraint = new IdentityConstraintImpl(name, xmlConstraint.category, xmlConstraint.selector, xmlConstraint.fields, null);\n+        try {\n+            if (null == xmlConstraint.keyConstraint) {\n+                final IdentityConstraint constraint =\n+                    new IdentityConstraintImpl(name, xmlConstraint.category, xmlConstraint.selector,\n+                        xmlConstraint.fields, null);\n                 m_outBag.add(constraint);\n                 m_locations.m_constraintLocations.put(constraint, xmlConstraint.getLocation());\n                 return constraint;\n-            }\n-            else\n-            {\n-                final IdentityConstraint keyConstraint = convertIdentityConstraint(xmlConstraint.keyConstraint);\n-                final IdentityConstraint constraint = new IdentityConstraintImpl(name, xmlConstraint.category, xmlConstraint.selector, xmlConstraint.fields, keyConstraint);\n+            } else {\n+                final IdentityConstraint keyConstraint =\n+                    convertIdentityConstraint(xmlConstraint.keyConstraint);\n+                final IdentityConstraint constraint =\n+                    new IdentityConstraintImpl(name, xmlConstraint.category, xmlConstraint.selector,\n+                        xmlConstraint.fields, keyConstraint);\n                 m_outBag.add(constraint);\n                 m_locations.m_constraintLocations.put(constraint, xmlConstraint.getLocation());\n                 return constraint;\n             }\n-        }\n-        finally\n-        {\n+        } finally {\n             m_cycles.constraints.pop();\n         }\n     }\n \n-    private void convertIdentityConstraints() throws AbortException\n-    {\n-        for (final XMLIdentityConstraint source : m_inCache.m_constraints.values())\n-        {\n-            try\n-            {\n+    private void convertIdentityConstraints() throws AbortException {\n+        for (final XMLIdentityConstraint source : m_inCache.m_constraints.values()) {\n+            try {\n                 QName name = source.getName();\n-                if(!m_lastInWins && m_existingCache.getIdentityConstraint(name) != null)\n-                {\n+                if (!m_lastInWins && m_existingCache.getIdentityConstraint(name) != null) {\n                     m_inCache.m_constraintsUnresolved.remove(name);\n                 }\n                 convertIdentityConstraint(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private SimpleType convertItemType(final QName simpleType, final XMLTypeRef typeRef) throws AbortException, SchemaException\n-    {\n+    private SimpleType convertItemType(final QName simpleType, final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException {\n         final Type itemType = convertType(typeRef);\n-        if (itemType.isAtomicType())\n-        {\n-            return (SimpleType)itemType;\n-        }\n-        else if (itemType instanceof UnionSimpleType)\n-        {\n-            return (UnionSimpleType)itemType;\n-        }\n-        else\n-        {\n+        if (itemType.isAtomicType()) {\n+            return (SimpleType) itemType;\n+        } else if (itemType instanceof UnionSimpleType) {\n+            return (UnionSimpleType) itemType;\n+        } else {\n             throw new SccItemTypeMustBeAtomicOrUnionException(simpleType);\n         }\n     }\n \n-    private SimpleType convertMemberType(final QName simpleType, final XMLTypeRef typeRef) throws AbortException, SchemaException\n-    {\n+    private SimpleType convertMemberType(final QName simpleType, final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException {\n         final Type memberType = convertType(typeRef);\n-        if (memberType.isAtomicType())\n-        {\n-            return (SimpleType)memberType;\n-        }\n-        else if (memberType instanceof ListSimpleType)\n-        {\n-            return (ListSimpleType)memberType;\n-        }\n-        else if (memberType instanceof UnionSimpleType)\n-        {\n-        \treturn (UnionSimpleType)memberType;\n-        }\n-        else if (memberType instanceof SimpleType)\n-        {\n-            if (memberType.isSimpleUrType())\n-            {\n-                return (SimpleType)memberType;\n+        if (memberType.isAtomicType()) {\n+            return (SimpleType) memberType;\n+        } else if (memberType instanceof ListSimpleType) {\n+            return (ListSimpleType) memberType;\n+        } else if (memberType instanceof UnionSimpleType) {\n+            return (UnionSimpleType) memberType;\n+        } else if (memberType instanceof SimpleType) {\n+            if (memberType.isSimpleUrType()) {\n+                return (SimpleType) memberType;\n             }\n         }\n         throw new SccMemberTypeMustBeAtomicOrListException(simpleType);\n     }\n \n-    private ModelGroup convertModelGroup(final XMLModelGroup xmlModelGroup) throws AbortException, SchemaException\n-    {\n+    private ModelGroup convertModelGroup(final XMLModelGroup xmlModelGroup)\n+        throws AbortException, SchemaException {\n         final ScopeExtent scope = convertScope(xmlModelGroup.getScope());\n         final QName name;\n         final boolean isAnonymous;\n-        if (scope == ScopeExtent.Global)\n-        {\n+        if (scope == ScopeExtent.Global) {\n             name = xmlModelGroup.getName();\n             isAnonymous = false;\n-            if (m_outBag.hasModelGroup(name))\n-            {\n+            if (m_outBag.hasModelGroup(name)) {\n                 return m_outBag.getModelGroup(name);\n             }\n-            if(m_existingCache.hasModelGroup(name))\n-            {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            if (m_existingCache.hasModelGroup(name)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n                     return m_existingCache.getModelGroup(name);\n-            \t}\n-            \telse if(m_inCache.m_modelGroupsUnresolved.containsKey(name) || m_modelGroupsResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_modelGroupsUnresolved.containsKey(name) ||\n+                    m_modelGroupsResolvedFromExistingCache.containsKey(name)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n-            \t\tModelGroup existing = m_existingCache.getModelGroup(name);\n-            \t\tm_modelGroupsResolvedFromExistingCache.put(name, existing);\n+                    ModelGroup existing = m_existingCache.getModelGroup(name);\n+                    m_modelGroupsResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.groups.contains(xmlModelGroup))\n-            {\n+            if (m_cycles.groups.contains(xmlModelGroup)) {\n                 throw new SccCyclicModelGroupException(name, xmlModelGroup.getLocation());\n-            }\n-            else\n-            {\n+            } else {\n                 m_cycles.groups.push(xmlModelGroup);\n             }\n-        }\n-        else\n-        {\n+        } else {\n             name = null;\n             isAnonymous = true;\n         }\n \n-        try\n-        {\n+        try {\n             final ModelGroup.SmCompositor compositor = xmlModelGroup.getCompositor();\n             final LinkedList<SchemaParticle> particles = new LinkedList<SchemaParticle>();\n-            for (final XMLParticle xmlParticle : xmlModelGroup.getParticles())\n-            {\n-                try\n-                {\n-                    if (xmlParticle instanceof XMLParticleWithModelGroupTerm)\n-                    {\n-                        particles.add(convertModelGroupUse((XMLParticleWithModelGroupTerm)xmlParticle));\n-                    }\n-                    else if (xmlParticle instanceof XMLParticleWithElementTerm)\n-                    {\n-                        particles.add(convertElementUse((XMLParticleWithElementTerm)xmlParticle));\n-                    }\n-                    else if (xmlParticle instanceof XMLParticleWithWildcardTerm)\n-                    {\n-                        particles.add(convertWildcardUse((XMLParticleWithWildcardTerm)xmlParticle));\n-                    }\n-                    else\n-                    {\n+            for (final XMLParticle xmlParticle : xmlModelGroup.getParticles()) {\n+                try {\n+                    if (xmlParticle instanceof XMLParticleWithModelGroupTerm) {\n+                        particles\n+                            .add(convertModelGroupUse((XMLParticleWithModelGroupTerm) xmlParticle));\n+                    } else if (xmlParticle instanceof XMLParticleWithElementTerm) {\n+                        particles.add(convertElementUse((XMLParticleWithElementTerm) xmlParticle));\n+                    } else if (xmlParticle instanceof XMLParticleWithWildcardTerm) {\n+                        particles\n+                            .add(convertWildcardUse((XMLParticleWithWildcardTerm) xmlParticle));\n+                    } else {\n                         throw new AssertionError(xmlParticle);\n                     }\n \n-                }\n-                catch (final SchemaException e)\n-                {\n+                } catch (final SchemaException e) {\n                     m_errors.error(e);\n                 }\n             }\n-            final ModelGroup modelGroup = new ModelGroupImpl(compositor, particles, name, isAnonymous, scope);\n-            copyForeignAttributes(xmlModelGroup.foreignAttributes, (ModelGroupImpl)modelGroup);\n-            if (modelGroup.getScopeExtent() == ScopeExtent.Global)\n-            {\n+            final ModelGroup modelGroup =\n+                new ModelGroupImpl(compositor, particles, name, isAnonymous, scope);\n+            copyForeignAttributes(xmlModelGroup.foreignAttributes, (ModelGroupImpl) modelGroup);\n+            if (modelGroup.getScopeExtent() == ScopeExtent.Global) {\n                 m_outBag.add(modelGroup);\n             }\n             m_locations.m_modelGroupLocations.put(modelGroup, xmlModelGroup.getLocation());\n             return modelGroup;\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n-            {\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.groups.pop();\n             }\n         }\n     }\n \n-    private void convertModelGroups() throws AbortException\n-    {\n-        for (final XMLModelGroup source : m_inCache.m_modelGroups.values())\n-        {\n-            try\n-            {\n+    private void convertModelGroups() throws AbortException {\n+        for (final XMLModelGroup source : m_inCache.m_modelGroups.values()) {\n+            try {\n                 QName name = source.getName();\n-                if(!m_lastInWins && m_existingCache.getModelGroup(name) != null)\n-                {\n+                if (!m_lastInWins && m_existingCache.getModelGroup(name) != null) {\n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n                 }\n                 convertModelGroup(source);\n-            }\n-            catch (final SchemaException e)\n-            {\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private ModelGroupUse convertModelGroupUse(final XMLParticleWithModelGroupTerm particle) throws AbortException, SchemaException\n-    {\n+    private ModelGroupUse convertModelGroupUse(final XMLParticleWithModelGroupTerm particle)\n+        throws AbortException, SchemaException {\n         final ModelGroup modelGroup = convertModelGroup(particle.getTerm());\n \n         final ModelGroupUse modelGroupUse;\n-        if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n-        {\n+        if (isMaxOccursUnbounded(particle.getMaxOccurs())) {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             modelGroupUse = new ParticleWithModelGroupTerm(minOccurs, modelGroup);\n-        }\n-        else\n-        {\n+        } else {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             final int maxOccurs = maxOccurs(particle.getMaxOccurs());\n             modelGroupUse = new ParticleWithModelGroupTerm(minOccurs, maxOccurs, modelGroup);\n@@ -1533,30 +1241,27 @@ public final class XMLSchemaConverter\n         return modelGroupUse;\n     }\n \n-    private NotationDefinition convertNotation(final XMLNotation xmlNotation)\n-    {\n-        final NotationDefinition notation = new NotationImpl(xmlNotation.getName(), xmlNotation.getPublicId(), xmlNotation.getSystemId());\n-        copyForeignAttributes(xmlNotation.foreignAttributes, (NotationImpl)notation);\n+    private NotationDefinition convertNotation(final XMLNotation xmlNotation) {\n+        final NotationDefinition notation =\n+            new NotationImpl(xmlNotation.getName(), xmlNotation.getPublicId(),\n+                xmlNotation.getSystemId());\n+        copyForeignAttributes(xmlNotation.foreignAttributes, (NotationImpl) notation);\n         m_outBag.add(notation);\n         m_locations.m_notationLocations.put(notation, xmlNotation.getLocation());\n         return notation;\n     }\n \n-    private void convertNotations()\n-    {\n-        for (final XMLNotation source : m_inCache.m_notations.values())\n-        {\n+    private void convertNotations() {\n+        for (final XMLNotation source : m_inCache.m_notations.values()) {\n             QName name = source.getName();\n-            if(!m_lastInWins && m_existingCache.getNotationDeclaration(name) != null)\n-            {\n+            if (!m_lastInWins && m_existingCache.getNotationDeclaration(name) != null) {\n                 m_inCache.m_notationsUnresolved.remove(name);\n             }\n             convertNotation(source);\n         }\n     }\n \n-    private ScopeExtent convertScope(final XMLScope scope)\n-    {\n+    private ScopeExtent convertScope(final XMLScope scope) {\n         PreCondition.assertArgumentNotNull(scope, \"scope\");\n \n         return scope.isGlobal() ? ScopeExtent.Global : ScopeExtent.Local;\n@@ -1565,84 +1270,74 @@ public final class XMLSchemaConverter\n     /**\n      * Applies the Schema Component Constraints to this Simple Type.\n      */\n-    private SimpleType convertSimpleType(final QName name, final boolean isAnonymous, final XMLType xmlSimpleType) throws AbortException, SchemaException\n-    {\n+    private SimpleType convertSimpleType(final QName name, final boolean isAnonymous,\n+                                         final XMLType xmlSimpleType)\n+        throws AbortException, SchemaException {\n         PreCondition.assertTrue(xmlSimpleType.isSimple(), \"expecting a simple type for \" + name);\n \n         final ScopeExtent scope = convertScope(xmlSimpleType.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n-            if (m_outBag.hasSimpleType(name))\n-            {\n+        if (scope == ScopeExtent.Global) {\n+            if (m_outBag.hasSimpleType(name)) {\n                 return m_outBag.getSimpleType(name);\n             }\n-            if(m_existingCache.hasSimpleType(name))\n-            {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+            if (m_existingCache.hasSimpleType(name)) {\n+                if (!m_lastInWins) {\n+                    // We are not allowing this schema parse to create new elements.\n                     m_inCache.m_typesUnresolved.remove(name);\n                     return m_existingCache.getSimpleType(name);\n-            \t}\n-            \telse if(m_inCache.m_typesUnresolved.containsKey(name) || m_typesResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                } else if (m_inCache.m_typesUnresolved.containsKey(name) ||\n+                    m_typesResolvedFromExistingCache.containsKey(name)) {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be\n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_typesUnresolved.remove(name);\n-            \t\tSimpleType existing = m_existingCache.getSimpleType(name);\n-            \t\tm_typesResolvedFromExistingCache.put(name, existing);\n+                    SimpleType existing = m_existingCache.getSimpleType(name);\n+                    m_typesResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n-            if (m_cycles.types.contains(xmlSimpleType))\n-            {\n+            if (m_cycles.types.contains(xmlSimpleType)) {\n                 throw new SmCyclicTypeException(name);\n             }\n \n             m_cycles.types.push(xmlSimpleType);\n         }\n-        try\n-        {\n+        try {\n             final SimpleType simpleBaseType;\n-            if (null != xmlSimpleType.getBaseRef())\n-            {\n+            if (null != xmlSimpleType.getBaseRef()) {\n                 simpleBaseType = convertSimpleTypeBase(name, xmlSimpleType.getBaseRef());\n-            }\n-            else\n-            {\n-                simpleBaseType = convertSimpleTypeBase(name, xmlSimpleType.getScope().getType().getBaseRef());\n+            } else {\n+                simpleBaseType =\n+                    convertSimpleTypeBase(name, xmlSimpleType.getScope().getType().getBaseRef());\n             }\n \n             final SimpleTypeImpl simpleType;\n-            final DerivationMethod derivation = PreCondition.assertNotNull(xmlSimpleType.getDerivationMethod(), \"{type definition} with base \" + simpleBaseType.getName());\n+            final DerivationMethod derivation = PreCondition\n+                .assertNotNull(xmlSimpleType.getDerivationMethod(),\n+                    \"{type definition} with base \" + simpleBaseType.getName());\n             final WhiteSpacePolicy whiteSpace = xmlSimpleType.getWhiteSpacePolicy();\n-            if (derivation.isUnion())\n-            {\n+            if (derivation.isUnion()) {\n                 final LinkedList<SimpleType> memberTypes = new LinkedList<SimpleType>();\n-                for (final XMLTypeRef memberRef : xmlSimpleType.memberRefs)\n-                {\n+                for (final XMLTypeRef memberRef : xmlSimpleType.memberRefs) {\n                     final SimpleType memberType = convertMemberType(name, memberRef);\n                     memberTypes.add(memberType);\n                 }\n-                simpleType = new UnionTypeImpl(name, isAnonymous, scope, simpleBaseType, memberTypes, whiteSpace);\n+                simpleType =\n+                    new UnionTypeImpl(name, isAnonymous, scope, simpleBaseType, memberTypes,\n+                        whiteSpace);\n                 m_outBag.add(simpleType);\n                 m_locations.m_simpleTypeLocations.put(simpleType, xmlSimpleType.getLocation());\n-            }\n-            else if (derivation.isList())\n-            {\n+            } else if (derivation.isList()) {\n                 final SimpleType itemType = convertItemType(name, xmlSimpleType.itemRef);\n-                simpleType = new ListTypeImpl(name, isAnonymous, scope, itemType, simpleBaseType, whiteSpace);\n+                simpleType = new ListTypeImpl(name, isAnonymous, scope, itemType, simpleBaseType,\n+                    whiteSpace);\n                 m_outBag.add(simpleType);\n                 m_locations.m_simpleTypeLocations.put(simpleType, xmlSimpleType.getLocation());\n-            }\n-            else if (derivation.isRestriction())\n-            {\n-                simpleType = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace, xmlSimpleType.getLocation());\n-            }\n-            else\n-            {\n+            } else if (derivation.isRestriction()) {\n+                simpleType = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace,\n+                    xmlSimpleType.getLocation());\n+            } else {\n                 throw new AssertionError(derivation.name());\n             }\n             computePatterns(xmlSimpleType.getPatternFacets(), simpleType);\n@@ -1650,191 +1345,174 @@ public final class XMLSchemaConverter\n             computeEnumerations(simpleBaseType, xmlSimpleType, simpleType);\n             copyForeignAttributes(xmlSimpleType.foreignAttributes, simpleType);\n             return simpleType;\n-        }\n-        finally\n-        {\n-            if (scope == ScopeExtent.Global)\n-            {\n+        } finally {\n+            if (scope == ScopeExtent.Global) {\n                 m_cycles.types.pop();\n             }\n         }\n     }\n \n-    private SimpleType convertSimpleTypeBase(final QName simpleType, final XMLTypeRef baseRef) throws AbortException, SchemaException\n-    {\n+    private SimpleType convertSimpleTypeBase(final QName simpleType, final XMLTypeRef baseRef)\n+        throws AbortException, SchemaException {\n         final Type baseType = convertType(baseRef);\n-        if (baseType instanceof SimpleType)\n-        {\n-            return (SimpleType)baseType;\n-        }\n-        else\n-        {\n+        if (baseType instanceof SimpleType) {\n+            return (SimpleType) baseType;\n+        } else {\n             throw new SccBaseTypeMustBeSimpleTypeException(simpleType);\n         }\n     }\n \n-    private Type convertType(final QName name, final boolean isAnonymous) throws SchemaException, AbortException\n-    {\n+    private Type convertType(final QName name, final boolean isAnonymous)\n+        throws SchemaException, AbortException {\n         // first, check our incrementally collected results, in m_outBag.\n         // if we have something there, return it.\n         // should we insure that it's not in the unresolved list, in that case?\n-        if (m_outBag.hasSimpleType(name))\n+        if (m_outBag.hasSimpleType(name)) {\n             return m_outBag.getSimpleType(name);\n-        else if (m_outBag.hasComplexType(name))\n+        } else if (m_outBag.hasComplexType(name)) {\n             return m_outBag.getComplexType(name);\n-        else\n-        {\n+        } else {\n             // now, we look in the collection of xmlrep components. is it there?\n-            if (m_inCache.m_globalTypes.containsKey(name))\n-            {\n+            if (m_inCache.m_globalTypes.containsKey(name)) {\n                 // okay. if it's simple or complex, convert it and return\n                 final XMLType type = m_inCache.m_globalTypes.get(name);\n-                if (type.isSimple())\n+                if (type.isSimple()) {\n                     return convertSimpleType(name, isAnonymous, type);\n-                else if (type.isComplex())\n+                } else if (type.isComplex()) {\n                     return convertComplexType(name, isAnonymous, type);\n+                }\n                 // if not, then it's an unresolved reference. so ... don't ever\n                 // call this method if there's more parsing to be done, eh?\n-                throw new SmUndeclaredReferenceException(name, m_inCache.m_typesUnresolved.get(name));\n+                throw new SmUndeclaredReferenceException(name,\n+                    m_inCache.m_typesUnresolved.get(name));\n             }\n             // it's not in the collection of unresolved components\n             // is it already in our component provider?\n-            else if (m_existingCache.hasSimpleType(name))\n+            else if (m_existingCache.hasSimpleType(name)) {\n                 return m_existingCache.getSimpleType(name);\n-            else if (m_existingCache.hasComplexType(name))\n+            } else if (m_existingCache.hasComplexType(name)) {\n                 return m_existingCache.getComplexType(name);\n+            }\n             // not there, either. oops. die in flames.\n             throw new SmUndeclaredReferenceException(name, m_inCache.m_typesUnresolved.get(name));\n         }\n     }\n \n-    private Type convertType(final QName name, final boolean isAnonymous, final XMLType type) throws AbortException, SchemaException\n-    {\n-        if (type.isSimple())\n+    private Type convertType(final QName name, final boolean isAnonymous, final XMLType type)\n+        throws AbortException, SchemaException {\n+        if (type.isSimple()) {\n             return convertSimpleType(name, isAnonymous, type);\n-        else if (type.isComplex())\n+        } else if (type.isComplex()) {\n             return convertComplexType(name, isAnonymous, type);\n+        }\n         // if it's neither simple nor complex, it's a type reference without a referent\n         throw new SmUndeclaredReferenceException(name, m_inCache.m_typesUnresolved.get(name));\n     }\n \n-    private Type convertType(final XMLTypeRef typeRef) throws AbortException, SchemaException\n-    {\n-        if (typeRef.isGlobal())\n-        {\n+    private Type convertType(final XMLTypeRef typeRef) throws AbortException, SchemaException {\n+        if (typeRef.isGlobal()) {\n             QName name = typeRef.getName();\n-            if(!m_lastInWins && m_existingCache.hasComplexType(name))\n-            {\n+            if (!m_lastInWins && m_existingCache.hasComplexType(name)) {\n                 m_inCache.m_typesUnresolved.remove(name);\n                 return m_existingCache.getComplexType(name);\n             }\n-            if(!m_lastInWins && m_existingCache.hasSimpleType(name))\n-            {\n+            if (!m_lastInWins && m_existingCache.hasSimpleType(name)) {\n                 m_inCache.m_typesUnresolved.remove(name);\n                 return m_existingCache.getSimpleType(name);\n             }\n-            \n+\n             return convertType(typeRef.getName(), false);\n-        }\n-        else\n-        {\n+        } else {\n             return convertType(m_existingCache.generateUniqueName(), true, typeRef.getLocal());\n         }\n     }\n \n-    private void convertTypes() throws AbortException\n-    {\n+    private void convertTypes() throws AbortException {\n         // we're iterating over all of the global types that haven't been\n         // converted yet. local types can't ever be unresolved, of course,\n         // and should be handled in the context of whatever contains them.\n-        for (final XMLType sourceType : m_inCache.m_globalTypes.values())\n-        {\n+        for (final XMLType sourceType : m_inCache.m_globalTypes.values()) {\n             // {name} is known because the type is global.\n             final QName name = sourceType.getName();\n             // and therefore not anonymous\n             final boolean isAnonymous = false;\n-            try\n-            {\n+            try {\n                 // if this one exists already, do special processing in case lastInWins\n-            \tif (m_existingCache.getComplexType(name) != null || m_existingCache.getSimpleType(name) != null)\n-            \t{\n-            \t    if (!m_lastInWins)\n-            \t        m_inCache.m_typesUnresolved.remove(name);\n-            \t    else\n-            \t    {\n-            \t        // if it's a real type to replace the existing, replace.\n-            \t        if (sourceType.isComplex())\n-            \t            convertComplexType(name, isAnonymous, sourceType);\n-                        else if (sourceType.isSimple())\n+                if (m_existingCache.getComplexType(name) != null ||\n+                    m_existingCache.getSimpleType(name) != null) {\n+                    if (!m_lastInWins) {\n+                        m_inCache.m_typesUnresolved.remove(name);\n+                    } else {\n+                        // if it's a real type to replace the existing, replace.\n+                        if (sourceType.isComplex()) {\n+                            convertComplexType(name, isAnonymous, sourceType);\n+                        } else if (sourceType.isSimple()) {\n                             convertSimpleType(name, isAnonymous, sourceType);\n-            \t        // if neither complex nor simple, then it's a ref; remove from unresolved\n-                        else\n+                        }\n+                        // if neither complex nor simple, then it's a ref; remove from unresolved\n+                        else {\n                             m_inCache.m_typesUnresolved.remove(name);\n-            \t    }\n-            \t}\n-            \t// otherwise, it's not in the existing cache, so convert\n-                else if (sourceType.isComplex())\n+                        }\n+                    }\n+                }\n+                // otherwise, it's not in the existing cache, so convert\n+                else if (sourceType.isComplex()) {\n                     convertComplexType(name, isAnonymous, sourceType);\n-                else if (sourceType.isSimple())\n+                } else if (sourceType.isSimple()) {\n                     convertSimpleType(name, isAnonymous, sourceType);\n-                else // this isn't going to work--it's an incomplete type/type reference without a referent\n+                } else // this isn't going to work--it's an incomplete type/type reference without a referent\n+                {\n                     convertType(name, isAnonymous, sourceType); // let this method throw.\n-            }\n-            catch (final SchemaException e)\n-            {\n+                }\n+            } catch (final SchemaException e) {\n                 m_errors.error(e);\n             }\n         }\n     }\n \n-    private ValueConstraint convertValueConstraint(final String elementName, final XMLValueConstraint xmlValueConstraint, final SimpleType simpleType) \n-        throws SchemaException\n-    {\n-        if (xmlValueConstraint != null)\n-        {\n+    private ValueConstraint convertValueConstraint(final String elementName,\n+                                                   final XMLValueConstraint xmlValueConstraint,\n+                                                   final SimpleType simpleType)\n+        throws SchemaException {\n+        if (xmlValueConstraint != null) {\n             final String initialValue = xmlValueConstraint.getValue();\n-            try\n-            {\n+            try {\n                 List<XmlAtom> val = simpleType.validate(initialValue, m_atoms);\n-                if (val.size() > 0)\n-                    return new ValueConstraint(xmlValueConstraint.kind, simpleType, m_atoms.getC14NForm(val.get(0)));\n+                if (val.size() > 0) {\n+                    return new ValueConstraint(xmlValueConstraint.kind, simpleType,\n+                        m_atoms.getC14NForm(val.get(0)));\n+                }\n                 // TODO: throw a better exception\n                 throw new AssertionError(); // no value in the value constraint\n+            } catch (DatatypeException dte) {\n+                final SimpleTypeException ste =\n+                    new SimpleTypeException(initialValue, simpleType, dte);\n+                throw new SmAttributeUseException(new QName(elementName),\n+                    xmlValueConstraint.getAttributeName(), xmlValueConstraint.getLocation(), ste);\n             }\n-            catch (DatatypeException dte)\n-            {\n-                final SimpleTypeException ste = new SimpleTypeException(initialValue, simpleType, dte);\n-                throw new SmAttributeUseException(new QName(elementName), xmlValueConstraint.getAttributeName(), xmlValueConstraint.getLocation(), ste);\n-            }\n-            \n+\n         }\n         return null;\n     }\n \n-    private SchemaWildcard convertWildcard(final XMLWildcard wildcard)\n-    {\n-        if (null != wildcard)\n-        {\n-            return new WildcardImpl(wildcard.getProcessContents(), convert(wildcard.getNamespaceConstraint()));\n-        }\n-        else\n-        {\n+    private SchemaWildcard convertWildcard(final XMLWildcard wildcard) {\n+        if (null != wildcard) {\n+            return new WildcardImpl(wildcard.getProcessContents(),\n+                convert(wildcard.getNamespaceConstraint()));\n+        } else {\n             return null;\n         }\n     }\n \n-    private SchemaParticle convertWildcardUse(final XMLParticleWithWildcardTerm particle) throws SicOversizedIntegerException\n-    {\n+    private SchemaParticle convertWildcardUse(final XMLParticleWithWildcardTerm particle)\n+        throws SicOversizedIntegerException {\n         final SchemaWildcard wildcard = convertWildcard(particle.getTerm());\n \n         final WildcardUse wildcardUse;\n-        if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n-        {\n+        if (isMaxOccursUnbounded(particle.getMaxOccurs())) {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             wildcardUse = new ParticleWithWildcardTerm(minOccurs, wildcard);\n-        }\n-        else\n-        {\n+        } else {\n             final int minOccurs = minOccurs(particle.getMinOccurs());\n             final int maxOccurs = maxOccurs(particle.getMaxOccurs());\n             wildcardUse = new ParticleWithWildcardTerm(minOccurs, maxOccurs, wildcard);\n@@ -1843,76 +1521,68 @@ public final class XMLSchemaConverter\n         return wildcardUse;\n     }\n \n-    private SimpleTypeImpl deriveSimpleType(final QName name, final boolean isAnonymous, final ScopeExtent scope, final SimpleType simpleBaseType, final WhiteSpacePolicy whiteSpace, final SrcFrozenLocation location) throws SchemaException\n-    {\n+    private SimpleTypeImpl deriveSimpleType(final QName name, final boolean isAnonymous,\n+                                            final ScopeExtent scope,\n+                                            final SimpleType simpleBaseType,\n+                                            final WhiteSpacePolicy whiteSpace,\n+                                            final SrcFrozenLocation location)\n+        throws SchemaException {\n         final SimpleTypeImpl simpleType;\n-        if (simpleBaseType.isAtomicType())\n-        {\n-            final AtomicType atomicBaseType = (AtomicType)simpleBaseType;\n+        if (simpleBaseType.isAtomicType()) {\n+            final AtomicType atomicBaseType = (AtomicType) simpleBaseType;\n             simpleType = new AtomicTypeImpl(name, isAnonymous, scope, atomicBaseType, whiteSpace);\n             m_outBag.add(simpleType);\n             m_locations.m_simpleTypeLocations.put(simpleType, location);\n-        }\n-        else if (simpleBaseType instanceof ListSimpleType)\n-        {\n-            final ListSimpleType listBaseListType = (ListSimpleType)simpleBaseType;\n-            simpleType = new ListTypeImpl(name, isAnonymous, scope, listBaseListType.getItemType(), simpleBaseType, whiteSpace);\n+        } else if (simpleBaseType instanceof ListSimpleType) {\n+            final ListSimpleType listBaseListType = (ListSimpleType) simpleBaseType;\n+            simpleType = new ListTypeImpl(name, isAnonymous, scope, listBaseListType.getItemType(),\n+                simpleBaseType, whiteSpace);\n             m_outBag.add(simpleType);\n             m_locations.m_simpleTypeLocations.put(simpleType, location);\n-        }\n-        else if (simpleBaseType instanceof UnionSimpleType)\n-        {\n-            final UnionSimpleType unionBaseType = (UnionSimpleType)simpleBaseType;\n-            simpleType = new UnionTypeImpl(name, isAnonymous, scope, simpleBaseType, unionBaseType.getMemberTypes(), whiteSpace);\n+        } else if (simpleBaseType instanceof UnionSimpleType) {\n+            final UnionSimpleType unionBaseType = (UnionSimpleType) simpleBaseType;\n+            simpleType = new UnionTypeImpl(name, isAnonymous, scope, simpleBaseType,\n+                unionBaseType.getMemberTypes(), whiteSpace);\n             m_outBag.add(simpleType);\n             m_locations.m_simpleTypeLocations.put(simpleType, location);\n-        }\n-        else if (simpleBaseType.isSimpleUrType())\n-        {\n+        } else if (simpleBaseType.isSimpleUrType()) {\n             throw new SccBaseTypeMustBeSimpleTypeException(name);\n-        }\n-        else\n-        {\n+        } else {\n             throw new AssertionError(simpleBaseType.getClass());\n         }\n         return simpleType;\n     }\n \n-    private ModelGroupUse effectiveContent(final boolean mixed, final XMLParticleWithModelGroupTerm contentModel) throws AbortException, SchemaException\n-    {\n-        if (null == contentModel)\n-        {\n-            if (mixed)\n-            {\n+    private ModelGroupUse effectiveContent(final boolean mixed,\n+                                           final XMLParticleWithModelGroupTerm contentModel)\n+        throws AbortException, SchemaException {\n+        if (null == contentModel) {\n+            if (mixed) {\n                 final List<SchemaParticle> particles = Collections.emptyList();\n-                final ModelGroup modelGroup = new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null, true, ScopeExtent.Local);\n+                final ModelGroup modelGroup =\n+                    new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null, true,\n+                        ScopeExtent.Local);\n                 return new ParticleWithModelGroupTerm(1, 1, modelGroup);\n-            }\n-            else\n-            {\n+            } else {\n                 return null;\n             }\n-        }\n-        else\n-        {\n+        } else {\n             return convertModelGroupUse(contentModel);\n         }\n     }\n \n-    private EnumerationDefinition enumeration(final SimpleType type, final SimpleType baseType, final XMLEnumeration sourceEnum) throws SmAttributeUseException\n-    {\n-        try\n-        {\n+    private EnumerationDefinition enumeration(final SimpleType type, final SimpleType baseType,\n+                                              final XMLEnumeration sourceEnum)\n+        throws SmAttributeUseException {\n+        try {\n             final SimpleType notationType = m_existingCache.getAtomicType(NativeType.NOTATION);\n             final FacetEnumerationImpl impl;\n-            if (baseType.getName().equals(notationType.getName()) || baseType.derivedFromType(notationType, EnumSet.of(DerivationMethod.Restriction)))\n-            {\n+            if (baseType.getName().equals(notationType.getName()) ||\n+                baseType.derivedFromType(notationType, EnumSet.of(DerivationMethod.Restriction))) {\n                 final PrefixResolver resolver = sourceEnum.getPrefixResolver();\n                 baseType.validate(sourceEnum.getValue(), resolver, m_atoms);\n                 impl = new FacetEnumerationImpl(sourceEnum.getValue(), baseType, resolver);\n-            }\n-            else\n-            {\n+            } else {\n                 baseType.validate(sourceEnum.getValue(), m_atoms);\n                 impl = new FacetEnumerationImpl(sourceEnum.getValue(), baseType, null);\n             }\n@@ -1920,104 +1590,77 @@ public final class XMLSchemaConverter\n             // all the possible values, not just one of them. if that's wrong, restore this.\n //            copyForeignAttributes(sourceEnum.foreignAttributes, impl);\n             return impl;\n-        }\n-        catch (final DatatypeException dte)\n-        {\n-            final SimpleTypeException ste = new SimpleTypeException(sourceEnum.getValue(), baseType, dte);\n-            final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_ENUMERATION);\n+        } catch (final DatatypeException dte) {\n+            final SimpleTypeException ste =\n+                new SimpleTypeException(sourceEnum.getValue(), baseType, dte);\n+            final QName elementName =\n+                new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_ENUMERATION);\n             final QName attributeName = new QName(XMLRepresentation.LN_VALUE);\n-            throw new SmAttributeUseException(elementName, attributeName, sourceEnum.getLocation(), ste);\n+            throw new SmAttributeUseException(elementName, attributeName, sourceEnum.getLocation(),\n+                ste);\n         }\n     }\n \n-    private SimpleType extractSimpleType(final XMLTypeRef typeRef) throws AbortException, SchemaException\n-    {\n+    private SimpleType extractSimpleType(final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException {\n         final Type type = convertType(typeRef);\n-        if (type instanceof SimpleType)\n-        {\n-            return (SimpleType)type;\n-        }\n-        else if (type instanceof ComplexType)\n-        {\n-            final ComplexType complexType = (ComplexType)type;\n+        if (type instanceof SimpleType) {\n+            return (SimpleType) type;\n+        } else if (type instanceof ComplexType) {\n+            final ComplexType complexType = (ComplexType) type;\n             final ContentType contentType = complexType.getContentType();\n-            if (contentType.isSimple())\n-            {\n+            if (contentType.isSimple()) {\n                 return contentType.getSimpleType();\n-            }\n-            else if (contentType.isMixed())\n-            {\n+            } else if (contentType.isMixed()) {\n                 return contentType.getSimpleType();\n-            }\n-            else\n-            {\n+            } else {\n                 throw new AssertionError(contentType.getKind());\n             }\n-        }\n-        else\n-        {\n+        } else {\n             throw new AssertionError(type);\n         }\n     }\n \n-    private Facet fractionDigits(final XMLFractionDigitsFacet xmlFacet) throws SicOversizedIntegerException\n-    {\n-        final FacetFractionDigitsImpl impl = new FacetFractionDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n+    private Facet fractionDigits(final XMLFractionDigitsFacet xmlFacet)\n+        throws SicOversizedIntegerException {\n+        final FacetFractionDigitsImpl impl =\n+            new FacetFractionDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n         copyForeignAttributes(xmlFacet.foreignAttributes, impl);\n         return impl;\n     }\n-    \n+\n     /**\n      * Converts a BigInteger value to an int value\n-     * \n-     * @param value\n-     *            the BigInteger to convert\n+     *\n+     * @param value the BigInteger to convert\n      * @return the int value equivalent of the incoming BigInteger value\n-     * @throws SicOversizedIntegerException\n-     *             if value is larger than Integer.MAX_VALUE\n+     * @throws SicOversizedIntegerException if value is larger than Integer.MAX_VALUE\n      */\n-    private int getIntValue(final BigInteger value) throws SicOversizedIntegerException\n-    {\n+    private int getIntValue(final BigInteger value) throws SicOversizedIntegerException {\n         PreCondition.assertArgumentNotNull(value, \"value\");\n-        if (value.compareTo(MAX_INT_SIZE) <= 0)\n-        {\n+        if (value.compareTo(MAX_INT_SIZE) <= 0) {\n             return value.intValue();\n-        }\n-        else\n-        {\n+        } else {\n             throw new SicOversizedIntegerException(value);\n         }\n     }\n \n-    private Facet length(final XMLLength xmlFacet) throws SicOversizedIntegerException\n-    {\n+    private Facet length(final XMLLength xmlFacet) throws SicOversizedIntegerException {\n         final FacetImpl impl;\n-        if (xmlFacet.minLength != null)\n-        {\n-            if (xmlFacet.maxLength != null)\n-            {\n-                if (xmlFacet.minLength.equals(xmlFacet.maxLength))\n-                {\n+        if (xmlFacet.minLength != null) {\n+            if (xmlFacet.maxLength != null) {\n+                if (xmlFacet.minLength.equals(xmlFacet.maxLength)) {\n                     impl = new FacetLengthImpl(getIntValue(xmlFacet.minLength), xmlFacet.fixed);\n-                }\n-                else\n-                {\n+                } else {\n                     throw new AssertionError();\n                 }\n-            }\n-            else\n-            {\n+            } else {\n                 impl = new FacetMinLengthImpl(getIntValue(xmlFacet.minLength), xmlFacet.fixed);\n             }\n-        }\n-        else\n-        {\n-            if (xmlFacet.maxLength != null)\n-            {\n+        } else {\n+            if (xmlFacet.maxLength != null) {\n                 impl = new FacetMaxLengthImpl(getIntValue(xmlFacet.maxLength), xmlFacet.fixed);\n-            }\n-            else\n-            {\n+            } else {\n                 throw new AssertionError();\n             }\n         }\n@@ -2025,148 +1668,134 @@ public final class XMLSchemaConverter\n         return impl;\n     }\n \n-    private Limit limit(final String value, final SimpleType simpleType, final FacetKind kind, final boolean isFixed)\n-    {\n+    private Limit limit(final String value, final SimpleType simpleType, final FacetKind kind,\n+                        final boolean isFixed) {\n         PreCondition.assertArgumentNotNull(value, \"value\");\n         PreCondition.assertArgumentNotNull(simpleType, \"simpleType\");\n         PreCondition.assertArgumentNotNull(kind, \"kind\");\n \n-        if (simpleType.isAtomicType())\n-        {\n+        if (simpleType.isAtomicType()) {\n             return new FacetValueCompImpl(value, kind, simpleType, isFixed);\n-        }\n-        else if (simpleType instanceof ListSimpleType)\n-        {\n-            final ListSimpleType listType = (ListSimpleType)simpleType;\n+        } else if (simpleType instanceof ListSimpleType) {\n+            final ListSimpleType listType = (ListSimpleType) simpleType;\n             final SimpleType itemType = listType.getItemType();\n-            if (itemType.isAtomicType())\n-            {\n-                final SimpleType atomicType = (SimpleType)itemType;\n+            if (itemType.isAtomicType()) {\n+                final SimpleType atomicType = (SimpleType) itemType;\n                 return new FacetValueCompImpl(value, kind, atomicType, isFixed);\n-            }\n-            else if (itemType instanceof UnionSimpleType)\n-            {\n+            } else if (itemType instanceof UnionSimpleType) {\n                 // is this a TODO? or does the specification forbid lists of unions?\n                 throw new UnsupportedOperationException();\n-            }\n-            else\n-            {\n+            } else {\n                 // The specification forbids lists of lists.\n                 throw new UnsupportedOperationException();\n             }\n-        }\n-        else if (simpleType instanceof UnionSimpleType)\n-        {\n+        } else if (simpleType instanceof UnionSimpleType) {\n             // TODO: is a limit on a union forbidden?\n             throw new UnsupportedOperationException();\n-        }\n-        else\n-        {\n+        } else {\n             // Simple Ur-Type? TODO: no limits?\n             throw new UnsupportedOperationException();\n         }\n     }\n \n-    private Facet minmax(final XMLMinMaxFacet xmlFacet, final SimpleType baseType) throws SchemaException\n-    {\n+    private Facet minmax(final XMLMinMaxFacet xmlFacet, final SimpleType baseType)\n+        throws SchemaException {\n         // TODO\n         final List<XmlAtom> value;\n         {\n             final String initialValue = xmlFacet.value;\n-            try\n-            {\n+            try {\n                 value = baseType.validate(initialValue, m_atoms);\n-            }\n-            catch (final DatatypeException dte)\n-            {\n-                final SimpleTypeException ste = new SimpleTypeException(initialValue, baseType, dte);\n-                final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, xmlFacet.elementName);\n+            } catch (final DatatypeException dte) {\n+                final SimpleTypeException ste =\n+                    new SimpleTypeException(initialValue, baseType, dte);\n+                final QName elementName =\n+                    new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, xmlFacet.elementName);\n                 final QName attributeName = new QName(XMLRepresentation.LN_VALUE);\n                 final SrcFrozenLocation location = xmlFacet.getLocation();\n                 throw new SmAttributeUseException(elementName, attributeName, location, ste);\n             }\n         }\n-        if (value.size() > 0)\n-        {\n-            return limit(m_atoms.getC14NForm(value.get(0)), baseType, xmlFacet.getOperator(), xmlFacet.fixed);\n+        if (value.size() > 0) {\n+            return limit(m_atoms.getC14NForm(value.get(0)), baseType, xmlFacet.getOperator(),\n+                xmlFacet.fixed);\n         }\n         return null;\n     }\n \n-    private Pattern pattern(final XMLPatternFacet pattern) throws SmAttributeUseException\n-    {\n-        try\n-        {\n+    private Pattern pattern(final XMLPatternFacet pattern) throws SmAttributeUseException {\n+        try {\n             final String regex = pattern.value;\n-            try\n-            {\n+            try {\n                 final RegExPattern regexp = regexc.compile(regex);\n                 final FacetPatternImpl impl = new FacetPatternImpl(regexp, regex);\n                 copyForeignAttributes(pattern.foreignAttributes, impl);\n                 return impl;\n-            }\n-            catch (final SchemaRegExCompileException e)\n-            {\n+            } catch (final SchemaRegExCompileException e) {\n                 final DatatypeException dte = new DatatypeException(regex, null);\n                 throw new SimpleTypeException(regex, null, dte);\n             }\n-        }\n-        catch (final SimpleTypeException ste)\n-        {\n-            final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_PATTERN);\n+        } catch (final SimpleTypeException ste) {\n+            final QName elementName =\n+                new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_PATTERN);\n             final QName attributeName = new QName(XMLRepresentation.LN_VALUE);\n-            throw new SmAttributeUseException(elementName, attributeName, pattern.getLocation(), ste);\n+            throw new SmAttributeUseException(elementName, attributeName, pattern.getLocation(),\n+                ste);\n         }\n     }\n \n-    private ContentType simpleContent(final XMLType simpleType, final SimpleType simpleBaseType) throws AbortException, SchemaException\n-    {\n+    private ContentType simpleContent(final XMLType simpleType, final SimpleType simpleBaseType)\n+        throws AbortException, SchemaException {\n         final QName name;\n         final boolean isAnonymous;\n         final ScopeExtent scope = convertScope(simpleType.getScope());\n-        if (scope == ScopeExtent.Global)\n-        {\n+        if (scope == ScopeExtent.Global) {\n             name = simpleType.getName();\n             isAnonymous = false;\n-        }\n-        else\n-        {\n+        } else {\n             name = m_existingCache.generateUniqueName();\n             isAnonymous = true;\n         }\n         final WhiteSpacePolicy whiteSpace = simpleType.getWhiteSpacePolicy();\n-        final SimpleTypeImpl simpleTypeD = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace, simpleType.getLocation());\n+        final SimpleTypeImpl simpleTypeD =\n+            deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace,\n+                simpleType.getLocation());\n         computePatterns(simpleType.getPatternFacets(), simpleTypeD);\n         computeFacets(simpleBaseType, simpleType, simpleTypeD);\n         computeEnumerations(simpleBaseType, simpleType, simpleTypeD);\n         return new ContentTypeImpl(simpleTypeD);\n     }\n \n-    private Facet totalDigits(final XMLTotalDigitsFacet xmlFacet) throws SicOversizedIntegerException\n-    {\n-        final FacetTotalDigitsImpl impl = new FacetTotalDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n+    private Facet totalDigits(final XMLTotalDigitsFacet xmlFacet)\n+        throws SicOversizedIntegerException {\n+        final FacetTotalDigitsImpl impl =\n+            new FacetTotalDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n         copyForeignAttributes(xmlFacet.foreignAttributes, impl);\n         return impl;\n     }\n-    \n-    private void copyForeignAttributes(FAMap source, ForeignAttributesSink target)\n-    {\n-        for (QName name : source.keySet())\n-        {\n+\n+    private void copyForeignAttributes(FAMap source, ForeignAttributesSink target) {\n+        for (QName name : source.keySet()) {\n             target.putForeignAttribute(name, source.get(name));\n         }\n     }\n \n-    public static  Pair<ComponentBagImpl, XMLComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors) throws AbortException\n-    {\n-    \treturn convert(regexc, rtmCache, xmlCache, errors, false);\n+    public static Pair<ComponentBagImpl, XMLComponentLocator> convert(\n+        final SchemaRegExCompiler regexc, final ComponentProvider rtmCache,\n+        final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors) throws AbortException {\n+        return convert(regexc, rtmCache, xmlCache, errors, false);\n     }\n-    public static  Pair<ComponentBagImpl, XMLComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors, boolean lastInWins) throws AbortException\n-    {\n+\n+    public static Pair<ComponentBagImpl, XMLComponentLocator> convert(\n+        final SchemaRegExCompiler regexc, final ComponentProvider rtmCache,\n+        final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors, boolean lastInWins)\n+        throws AbortException {\n         final ComponentBagImpl schema = new ComponentBagImpl();\n         final XMLComponentLocator locations = new XMLComponentLocator();\n \n-        final XMLSchemaConverter converter = new XMLSchemaConverter(regexc, rtmCache, xmlCache, schema, locations, errors, lastInWins);\n+        final XMLSchemaConverter converter =\n+            new XMLSchemaConverter(regexc, rtmCache, xmlCache, schema, locations, errors,\n+                lastInWins);\n \n         xmlCache.computeSubstitutionGroups();\n \n@@ -2181,91 +1810,64 @@ public final class XMLSchemaConverter\n         return new Pair<ComponentBagImpl, XMLComponentLocator>(schema, locations);\n     }\n \n-    static boolean isMaxOccursUnbounded(final BigInteger maxOccurs) throws SicOversizedIntegerException\n-    {\n+    static boolean isMaxOccursUnbounded(final BigInteger maxOccurs)\n+        throws SicOversizedIntegerException {\n         PreCondition.assertArgumentNotNull(maxOccurs, \"maxOccurs\");\n \n-        if (XMLParticle.UNBOUNDED.equals(maxOccurs))\n-        {\n+        if (XMLParticle.UNBOUNDED.equals(maxOccurs)) {\n             return true;\n-        }\n-        else\n-        {\n-            if (MAX_INT_SIZE.compareTo(maxOccurs) < 0)\n-            {\n+        } else {\n+            if (MAX_INT_SIZE.compareTo(maxOccurs) < 0) {\n                 throw new SicOversizedIntegerException(maxOccurs);\n-            }\n-            else\n-            {\n+            } else {\n                 return false;\n             }\n         }\n     }\n \n-    static int maxOccurs(final BigInteger maxOccurs) throws SicOversizedIntegerException\n-    {\n+    static int maxOccurs(final BigInteger maxOccurs) throws SicOversizedIntegerException {\n         PreCondition.assertArgumentNotNull(maxOccurs, \"maxOccurs\");\n \n-        if (XMLParticle.UNBOUNDED.equals(maxOccurs))\n-        {\n+        if (XMLParticle.UNBOUNDED.equals(maxOccurs)) {\n             throw new IllegalStateException(\"maxOccurs is unbounded\");\n-        }\n-        else\n-        {\n-            if (MAX_INT_SIZE.compareTo(maxOccurs) < 0)\n-            {\n+        } else {\n+            if (MAX_INT_SIZE.compareTo(maxOccurs) < 0) {\n                 throw new SicOversizedIntegerException(maxOccurs);\n-            }\n-            else\n-            {\n+            } else {\n                 return maxOccurs.intValue();\n             }\n         }\n     }\n \n-    static int minOccurs(final BigInteger minOccurs) throws SicOversizedIntegerException\n-    {\n+    static int minOccurs(final BigInteger minOccurs) throws SicOversizedIntegerException {\n         PreCondition.assertArgumentNotNull(minOccurs, \"minOccurs\");\n-        if (MAX_INT_SIZE.compareTo(minOccurs) < 0)\n-        {\n+        if (MAX_INT_SIZE.compareTo(minOccurs) < 0) {\n             throw new SicOversizedIntegerException(minOccurs);\n-        }\n-        else\n-        {\n+        } else {\n             PreCondition.assertTrue(minOccurs.compareTo(BigInteger.ZERO) >= 0, \"minOccurs >= 0\");\n             return minOccurs.intValue();\n         }\n     }\n \n-    private static  boolean subtype(final Type lhs, final Type rhs)\n-    {\n+    private static boolean subtype(final Type lhs, final Type rhs) {\n         PreCondition.assertArgumentNotNull(lhs, \"lhs\");\n         PreCondition.assertArgumentNotNull(rhs, \"rhs\");\n-        if (!rhs.isComplexUrType())\n-        {\n+        if (!rhs.isComplexUrType()) {\n             Type currentType = lhs;\n-            while (true)\n-            {\n-            \tif(currentType == rhs)\n-            \t{\n-            \t\treturn true;\n-            \t}\n-            \tif(currentType.getName().equals(rhs.getName()))\n-            \t{\n-            \t\treturn true;\n-            \t}\n-            \tif (!currentType.isComplexUrType())\n-            \t{\n-            \t\tcurrentType = currentType.getBaseType();\n-            \t}\n-            \telse\n-            \t{\n-            \t\treturn false;\n-            \t}\n-            }\n-        }\n-        else\n-        {\n+            while (true) {\n+                if (currentType == rhs) {\n+                    return true;\n+                }\n+                if (currentType.getName().equals(rhs.getName())) {\n+                    return true;\n+                }\n+                if (!currentType.isComplexUrType()) {\n+                    currentType = currentType.getBaseType();\n+                } else {\n+                    return false;\n+                }\n+            }\n+        } else {\n             // All item types are derived from the Complex Ur-type.\n             return true;\n         }\n@@ -2278,13 +1880,14 @@ public final class XMLSchemaConverter\n     private static final BigInteger MAX_INT_SIZE = BigInteger.valueOf(Integer.MAX_VALUE);\n \n     private final ContentType EMPTY_CONTENT = new ContentTypeImpl();\n+\n     private final XMLCycles m_cycles;\n \n     private final SchemaExceptionHandler m_errors;\n \n     // things that have already been pushed into the component provider in this parse group\n     private final ComponentProvider m_existingCache;\n-    \n+\n     private final CanonicalAtomBridge m_atoms;\n \n     // this is the collection of components from the xmlrep package.\n@@ -2297,15 +1900,27 @@ public final class XMLSchemaConverter\n     private final ComponentBagImpl m_outBag;\n \n     private final SchemaRegExCompiler regexc;\n-    \n+\n     private final boolean m_lastInWins;\n-    \n+\n     // Used only when m_lastInWins is true\n-    public final Map<QName, ElementDefinition> m_elementsResolvedFromExistingCache = new HashMap<QName, ElementDefinition>();\n-    public final Map<QName, AttributeDefinition> m_attributesResolvedFromExistingCache = new HashMap<QName, AttributeDefinition>();\n+    public final Map<QName, ElementDefinition> m_elementsResolvedFromExistingCache =\n+        new HashMap<QName, ElementDefinition>();\n+\n+    public final Map<QName, AttributeDefinition> m_attributesResolvedFromExistingCache =\n+        new HashMap<QName, AttributeDefinition>();\n+\n     public final Map<QName, Type> m_typesResolvedFromExistingCache = new HashMap<QName, Type>();\n-    public final Map<QName, ModelGroup> m_modelGroupsResolvedFromExistingCache = new HashMap<QName, ModelGroup>();\n-    public final Map<QName, AttributeGroupDefinition> m_attributeGroupsResolvedFromExistingCache = new HashMap<QName, AttributeGroupDefinition>();\n-    public final Map<QName, IdentityConstraint> m_constraintsResolvedFromExistingCache = new HashMap<QName, IdentityConstraint>();\n-    public final Map<QName, NotationDefinition> m_notationsResolvedFromExistingCache = new HashMap<QName, NotationDefinition>();\n+\n+    public final Map<QName, ModelGroup> m_modelGroupsResolvedFromExistingCache =\n+        new HashMap<QName, ModelGroup>();\n+\n+    public final Map<QName, AttributeGroupDefinition> m_attributeGroupsResolvedFromExistingCache =\n+        new HashMap<QName, AttributeGroupDefinition>();\n+\n+    public final Map<QName, IdentityConstraint> m_constraintsResolvedFromExistingCache =\n+        new HashMap<QName, IdentityConstraint>();\n+\n+    public final Map<QName, NotationDefinition> m_notationsResolvedFromExistingCache =\n+        new HashMap<QName, NotationDefinition>();\n }\n",
            "diff_size": 1273
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/487/XMLSchemaConverter.java\nindex 71e16fd0e7e..50525a66387 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/487/XMLSchemaConverter.java\n@@ -25,10 +25,8 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n import javax.xml.XMLConstants;\n import javax.xml.namespace.QName;\n-\n import org.genxdm.bridgekit.atoms.XmlAtom;\n import org.genxdm.bridgekit.xs.ComponentBagImpl;\n import org.genxdm.bridgekit.xs.ForeignAttributesSink;\n@@ -155,6 +153,7 @@ import org.genxdm.xs.types.UnionSimpleType;\n  * distracting arguments to methods. The use of a static entry point and a private initializer protects against multiple\n  * invocations.\n  */\n+\n public final class XMLSchemaConverter\n {\n     private XMLSchemaConverter(final SchemaRegExCompiler regexc, final ComponentProvider outCache, final XMLSchemaCache inCache, final ComponentBagImpl schema, final XMLComponentLocator locations, final SchemaExceptionHandler errors, final boolean lastInWins)\n@@ -195,11 +194,12 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SchemaWildcard attributeWildcard(final XMLType complexType) throws AbortException, SchemaException\n+    private SchemaWildcard attributeWildcard(final XMLType complexType)\n+        throws AbortException, SchemaException\n     {\n         final XMLWildcard localWildcard = complexType.attributeWildcard;\n-\n         final DerivationMethod derivation = complexType.getDerivationMethod();\n+\n         switch (derivation)\n         {\n             case Restriction:\n@@ -238,13 +238,15 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SchemaWildcard attributeWildcard(final XMLTypeRef typeRef) throws AbortException, SchemaException\n+    private SchemaWildcard attributeWildcard(final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException\n     {\n         final Type type = convertType(typeRef);\n         return attributeWildcard(type);\n     }\n \n-    private SchemaWildcard completeWildcard(final Iterable<XMLAttributeGroup> attributeGroups, final XMLWildcard localWildcard) throws AbortException, SchemaException\n+    private SchemaWildcard completeWildcard(final Iterable<XMLAttributeGroup> attributeGroups, final XMLWildcard localWildcard)\n+        throws AbortException, SchemaException\n     {\n         NamespaceConstraint constraint = null;\n \n@@ -271,7 +273,6 @@ public final class XMLSchemaConverter\n                 }\n             }\n         }\n-\n         if (null == constraint)\n         {\n             // If nothing is found in the <attributeGroup>[children]...\n@@ -307,10 +308,11 @@ public final class XMLSchemaConverter\n     /**\n      * Expand temporary variables used to hold syntactic constructs for attribute uses and wildcards.\n      */\n-    private Map<QName, AttributeUse> computeAttributeUses(final XMLType complexType) throws AbortException, SchemaException\n+\n+    private Map<QName, AttributeUse> computeAttributeUses(final XMLType complexType)\n+        throws AbortException, SchemaException\n     {\n         final HashMap<QName, AttributeUse> attributeUses = new HashMap<QName, AttributeUse>();\n-\n         for (final XMLAttributeUse attributeUse : complexType.getAttributeUses())\n         {\n             final QName attributeName = attributeUse.getDeclaration().getName();\n@@ -330,7 +332,6 @@ public final class XMLSchemaConverter\n                 m_errors.error(e);\n             }\n         }\n-\n         for (final XMLAttributeGroup xmlAttributeGroup : complexType.getAttributeGroups())\n         {\n             final AttributeGroupDefinition attributeGroup = convertAttributeGroup(xmlAttributeGroup);\n@@ -351,7 +352,6 @@ public final class XMLSchemaConverter\n                 }\n             }\n         }\n-\n         switch (complexType.getDerivationMethod())\n         {\n             case Restriction:\n@@ -371,6 +371,7 @@ public final class XMLSchemaConverter\n                                 // cause a non-unique name.\n                                 // This collision will be analyzed during\n                                 // schema constraint checking.\n+\n                             }\n                             else\n                             {\n@@ -400,7 +401,6 @@ public final class XMLSchemaConverter\n                 throw new RuntimeException(complexType.getDerivationMethod().name());\n             }\n         }\n-\n         return attributeUses;\n     }\n \n@@ -408,7 +408,9 @@ public final class XMLSchemaConverter\n      * Compile the enumeration facets for this type. <br/>\n      * Enumeration facets are not inherited during compilation, but must be subsets of base types.\n      */\n-    private void computeEnumerations(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target) throws AbortException\n+\n+    private void computeEnumerations(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target)\n+        throws AbortException\n     {\n         if (type.getEnumerations().size() > 0)\n         {\n@@ -426,7 +428,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void computeFacets(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target) throws AbortException, SchemaException\n+    private void computeFacets(final SimpleType baseType, final XMLType type, final SimpleTypeImpl target)\n+        throws AbortException, SchemaException\n     {\n         for (final XMLTotalDigitsFacet xmlFacet : type.getTotalDigitsFacets())\n         {\n@@ -461,9 +464,11 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private ContentType computeLocallyEmptyContent(final XMLType complexType) throws SchemaException, AbortException\n+    private ContentType computeLocallyEmptyContent(final XMLType complexType)\n+        throws SchemaException, AbortException\n     {\n         final DerivationMethod derivation = complexType.getDerivationMethod();\n+\n         switch (derivation)\n         {\n             case Restriction:\n@@ -499,7 +504,9 @@ public final class XMLSchemaConverter\n      * Compile the pattern facets for this type. <br/>\n      * Pattern facets are not inherited during compilation.\n      */\n-    private void computePatterns(final LinkedList<XMLPatternFacet> xmlFacets, final SimpleTypeImpl target) throws AbortException\n+\n+    private void computePatterns(final LinkedList<XMLPatternFacet> xmlFacets, final SimpleTypeImpl target)\n+        throws AbortException\n     {\n         if (xmlFacets.size() > 0)\n         {\n@@ -560,7 +567,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private AttributeDefinition convertAttribute(final XMLAttribute xmlAttribute) throws AbortException, SchemaException\n+    private AttributeDefinition convertAttribute(final XMLAttribute xmlAttribute)\n+        throws AbortException, SchemaException\n     {\n         final QName name = xmlAttribute.getName();\n         final ScopeExtent scope = convertScope(xmlAttribute.getScope());\n@@ -570,25 +578,25 @@ public final class XMLSchemaConverter\n             {\n                 return m_outBag.getAttribute(name);\n             }\n-            if(m_existingCache.hasAttribute(name))\n+            if (m_existingCache.hasAttribute(name))\n             {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributesUnresolved.remove(name);\n                     return m_existingCache.getAttributeDeclaration(name);\n-            \t}\n-            \telse if(m_inCache.m_attributesUnresolved.containsKey(name) || m_attributesResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_attributesUnresolved.containsKey(name) || m_attributesResolvedFromExistingCache.containsKey(name))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_attributesUnresolved.remove(name);\n-            \t\tAttributeDefinition existing = m_existingCache.getAttributeDeclaration(name);\n-            \t\tm_attributesResolvedFromExistingCache.put(name, existing);\n+                    AttributeDefinition existing = m_existingCache.getAttributeDeclaration(name);\n+                    m_attributesResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.attributes.contains(xmlAttribute))\n             {\n@@ -599,6 +607,7 @@ public final class XMLSchemaConverter\n                 m_cycles.attributes.push(xmlAttribute);\n             }\n         }\n+\n         final AttributeDeclTypeImpl attribute;\n         try\n         {\n@@ -616,6 +625,7 @@ public final class XMLSchemaConverter\n                 m_cycles.attributes.pop();\n             }\n         }\n+\n         final Type attributeType = convertType(xmlAttribute.typeRef);\n         if (attributeType instanceof SimpleType)\n         {\n@@ -640,7 +650,8 @@ public final class XMLSchemaConverter\n         return attribute;\n     }\n \n-    private AttributeGroupDefinition convertAttributeGroup(final XMLAttributeGroup xmlAttributeGroup) throws AbortException, SchemaException\n+    private AttributeGroupDefinition convertAttributeGroup(final XMLAttributeGroup xmlAttributeGroup)\n+        throws AbortException, SchemaException\n     {\n         final QName agName = PreCondition.assertArgumentNotNull(xmlAttributeGroup.getName(), \"name\");\n         final ScopeExtent scope = convertScope(xmlAttributeGroup.getScope());\n@@ -650,25 +661,25 @@ public final class XMLSchemaConverter\n             {\n                 return m_outBag.getAttributeGroup(agName);\n             }\n-            if(m_existingCache.hasAttributeGroup(agName))\n+            if (m_existingCache.hasAttributeGroup(agName))\n             {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributeGroupsUnresolved.remove(agName);\n                     return m_existingCache.getAttributeGroup(agName);\n-            \t}\n-            \telse if(m_inCache.m_attributeGroupsUnresolved.containsKey(agName) || m_attributeGroupsResolvedFromExistingCache.containsKey(agName))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_attributeGroupsUnresolved.containsKey(agName) || m_attributeGroupsResolvedFromExistingCache.containsKey(agName))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_attributeGroupsUnresolved.remove(agName);\n-            \t\tAttributeGroupDefinition existing = m_existingCache.getAttributeGroup(agName);\n-            \t\tm_attributeGroupsResolvedFromExistingCache.put(agName, existing);\n+                    AttributeGroupDefinition existing = m_existingCache.getAttributeGroup(agName);\n+                    m_attributeGroupsResolvedFromExistingCache.put(agName, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.attributeGroups.contains(xmlAttributeGroup))\n             {\n@@ -705,10 +716,10 @@ public final class XMLSchemaConverter\n                     m_errors.error(e);\n                 }\n             }\n+\n             final SchemaWildcard completeWildcard = completeWildcard(xmlAttributeGroup.getGroups(), xmlAttributeGroup.wildcard);\n             final AttributeGroupDefinition attributeGroup;\n             attributeGroup = new AttributeGroupImpl(agName, scope, attributeUses.values(), completeWildcard);\n-\n             if (attributeGroup.getScopeExtent() == ScopeExtent.Global)\n             {\n                 m_outBag.add(attributeGroup);\n@@ -726,14 +737,15 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void convertAttributeGroups() throws AbortException\n+    private void convertAttributeGroups()\n+        throws AbortException\n     {\n         for (final XMLAttributeGroup source : m_inCache.m_attributeGroups.values())\n         {\n             try\n             {\n                 QName name = source.getName();\n-                if(!m_lastInWins && m_existingCache.getAttributeGroup(name) != null)\n+                if (!m_lastInWins && m_existingCache.getAttributeGroup(name) != null)\n                 {\n                     m_inCache.m_attributeGroupsUnresolved.remove(name);\n                 }\n@@ -746,15 +758,15 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void convertAttributes() throws AbortException\n+    private void convertAttributes()\n+        throws AbortException\n     {\n         for (final XMLAttribute source : m_inCache.m_attributes.values())\n         {\n             try\n             {\n                 QName name = source.getName();\n-                \n-                if(!m_lastInWins && m_existingCache.hasAttribute(name))\n+                if (!m_lastInWins && m_existingCache.hasAttribute(name))\n                 {\n                     m_inCache.m_attributesUnresolved.remove(name);\n                 }\n@@ -767,7 +779,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private AttributeUse convertAttributeUse(final XMLAttributeUse xmlAttributeUse) throws AbortException, SchemaException\n+    private AttributeUse convertAttributeUse(final XMLAttributeUse xmlAttributeUse)\n+        throws AbortException, SchemaException\n     {\n         final AttributeDefinition attribute = convertAttribute(xmlAttributeUse.getDeclaration());\n         final AttributeUseImpl attributeUse = new AttributeUseImpl(xmlAttributeUse.isRequired(), attribute);\n@@ -789,6 +802,7 @@ public final class XMLSchemaConverter\n             else if (attributeType instanceof SimpleUrType)\n             {\n                 // TODO: Do we set the value constraint with xs:untypedAtomic?\n+\n             }\n             else\n             {\n@@ -798,7 +812,8 @@ public final class XMLSchemaConverter\n         return attributeUse;\n     }\n \n-    private ComplexType convertComplexType(final QName outName, final boolean isAnonymous, final XMLType xmlComplexType) throws AbortException, SchemaException\n+    private ComplexType convertComplexType(final QName outName, final boolean isAnonymous, final XMLType xmlComplexType)\n+        throws AbortException, SchemaException\n     {\n         final ScopeExtent scope = convertScope(xmlComplexType.getScope());\n         if (scope == ScopeExtent.Global)\n@@ -807,36 +822,34 @@ public final class XMLSchemaConverter\n             {\n                 return m_outBag.getComplexType(outName);\n             }\n-            if(m_existingCache.hasComplexType(outName))\n+            if (m_existingCache.hasComplexType(outName))\n             {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_typesUnresolved.remove(outName);\n                     return m_existingCache.getComplexType(outName);\n-            \t}\n-            \telse if(m_inCache.m_typesUnresolved.containsKey(outName) || m_typesResolvedFromExistingCache.containsKey(outName))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_typesUnresolved.containsKey(outName) || m_typesResolvedFromExistingCache.containsKey(outName))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_typesUnresolved.remove(outName);\n-            \t\tComplexType existing = m_existingCache.getComplexType(outName);\n-            \t\tm_typesResolvedFromExistingCache.put(outName, existing);\n+                    ComplexType existing = m_existingCache.getComplexType(outName);\n+                    m_typesResolvedFromExistingCache.put(outName, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.types.contains(xmlComplexType))\n             {\n                 throw new SmCyclicTypeException(outName);\n             }\n-\n             m_cycles.types.push(xmlComplexType);\n         }\n         try\n         {\n-\n             final Map<QName, AttributeUse> attributeUses = computeAttributeUses(xmlComplexType);\n             final Type baseType = convertType(xmlComplexType.getBaseRef());\n \n@@ -853,17 +866,13 @@ public final class XMLSchemaConverter\n             }\n             m_outBag.add(complexType);\n             m_locations.m_complexTypeLocations.put(complexType, xmlComplexType.getLocation());\n-\n             complexType.setContentType(convertContentType(xmlComplexType));\n-\n             complexType.setAbstract(xmlComplexType.isAbstract());\n             complexType.setAttributeWildcard(attributeWildcard(xmlComplexType));\n-\n             for (final DerivationMethod derivation : xmlComplexType.getBlock())\n             {\n                 complexType.setBlock(derivation, true);\n             }\n-\n             for (final DerivationMethod derivation : xmlComplexType.getFinal())\n             {\n                 if (derivation.isExtension() || derivation.isRestriction())\n@@ -887,10 +896,10 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private ContentType convertContentType(final XMLType xmlComplexType) throws AbortException, SchemaException\n+    private ContentType convertContentType(final XMLType xmlComplexType)\n+        throws AbortException, SchemaException\n     {\n         final DerivationMethod derivation = xmlComplexType.getDerivationMethod();\n-\n         if (xmlComplexType.m_contentKind.isComplex())\n         {\n             final boolean mixed = xmlComplexType.m_contentKind.isMixed();\n@@ -944,6 +953,7 @@ public final class XMLSchemaConverter\n                         final LinkedList<ModelGroupUse> particles = new LinkedList<ModelGroupUse>();\n                         particles.add(contentTypeB.getContentModel());\n                         particles.add(effectiveContent);\n+\n                         final ModelGroup modelGroup = new ModelGroupImpl(ModelGroup.SmCompositor.Sequence, particles, null, true, ScopeExtent.Local);\n                         final ModelGroupUse particle = new ParticleWithModelGroupTerm(1, 1, modelGroup);\n                         return new ContentTypeImpl(mixed, particle);\n@@ -1052,7 +1062,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private ElementDefinition convertElement(final XMLElement xmlElement) throws SchemaException, AbortException\n+    private ElementDefinition convertElement(final XMLElement xmlElement)\n+        throws SchemaException, AbortException\n     {\n         final QName name = PreCondition.assertArgumentNotNull(xmlElement.getName(), \"name\");\n         final ScopeExtent scope = convertScope(xmlElement.getScope());\n@@ -1062,25 +1073,25 @@ public final class XMLSchemaConverter\n             {\n                 return m_outBag.getElement(name);\n             }\n-            if(m_existingCache.hasElement(name))\n+            if (m_existingCache.hasElement(name))\n             {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_elementsUnresolved.remove(name);\n                     return m_existingCache.getElementDeclaration(name);\n-            \t}\n-            \telse if(m_inCache.m_elementsUnresolved.containsKey(name) || m_elementsResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This element is a reference which refers to an imported element; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_elementsUnresolved.  When XMLSchemaCache.registerELement is called, it removes name from m_elementsUnresolved,\n-            \t\t// and registerElement is called when XMLSchemaParser encounters a global element, the only elements that can be referenced.\n-            \t\t// So, we're going to remove its name from the list and NOT convert it -- it's just a reference\n+                }\n+                else if (m_inCache.m_elementsUnresolved.containsKey(name) || m_elementsResolvedFromExistingCache.containsKey(name))\n+                {\n+                    // This element is a reference which refers to an imported element; otherwise, its name would not be \n+                    // in the m_inCache.m_elementsUnresolved.  When XMLSchemaCache.registerELement is called, it removes name from m_elementsUnresolved,\n+                    // and registerElement is called when XMLSchemaParser encounters a global element, the only elements that can be referenced.\n+                    // So, we're going to remove its name from the list and NOT convert it -- it's just a reference\n                     m_inCache.m_elementsUnresolved.remove(name);\n-            \t\tElementDefinition existing = m_existingCache.getElementDeclaration(name);\n-            \t\tm_elementsResolvedFromExistingCache.put(name, existing);\n+                    ElementDefinition existing = m_existingCache.getElementDeclaration(name);\n+                    m_elementsResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.elements.contains(xmlElement))\n             {\n@@ -1091,6 +1102,7 @@ public final class XMLSchemaConverter\n                 m_cycles.elements.push(xmlElement);\n             }\n         }\n+\n         final ElementDeclTypeImpl element;\n         try\n         {\n@@ -1101,6 +1113,7 @@ public final class XMLSchemaConverter\n             // {name}, {target namespace} and {scope} are set here. We set the\n             // {type definition} and other\n             // properties outside of the scope for checking cycles.\n+\n             final ComplexUrType anyType = m_existingCache.getComplexUrType();\n             element = new ElementDeclTypeImpl(name, scope, anyType);\n \n@@ -1126,7 +1139,6 @@ public final class XMLSchemaConverter\n                 m_cycles.elements.pop();\n             }\n         }\n-\n         if (element.getScopeExtent() == ScopeExtent.Global)\n         {\n             m_outBag.add(element);\n@@ -1172,9 +1184,9 @@ public final class XMLSchemaConverter\n                 }\n                 else\n                 {\n-                  final String initialValue = xmlElement.m_valueConstraint.getValue();\n-                  final SimpleType simpleType = m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC);\n-                  element.setValueConstraint(new ValueConstraint(xmlElement.m_valueConstraint.kind, simpleType, initialValue));\n+                    final String initialValue = xmlElement.m_valueConstraint.getValue();\n+                    final SimpleType simpleType = m_existingCache.getSimpleType(NativeType.UNTYPED_ATOMIC);\n+                    element.setValueConstraint(new ValueConstraint(xmlElement.m_valueConstraint.kind, simpleType, initialValue));\n                 }\n             }\n             else\n@@ -1206,14 +1218,15 @@ public final class XMLSchemaConverter\n         return element;\n     }\n \n-    private void convertElements() throws AbortException\n+    private void convertElements()\n+        throws AbortException\n     {\n         for (final XMLElement source : m_inCache.m_elements.values())\n         {\n             try\n             {\n                 QName name = source.getName();\n-                if(!m_lastInWins && m_existingCache.getElementDeclaration(name) != null)\n+                if (!m_lastInWins && m_existingCache.getElementDeclaration(name) != null)\n                 {\n                     m_inCache.m_elementsUnresolved.remove(name);\n                 }\n@@ -1226,11 +1239,11 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SchemaParticle convertElementUse(final XMLParticleWithElementTerm particle) throws SchemaException, AbortException\n+    private SchemaParticle convertElementUse(final XMLParticleWithElementTerm particle)\n+        throws SchemaException, AbortException\n     {\n         final XMLElement xmlElement = particle.getTerm();\n         final ElementDefinition element = convertElement(xmlElement);\n-\n         final ParticleWithElementTerm elementUse;\n         if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n         {\n@@ -1252,13 +1265,16 @@ public final class XMLSchemaConverter\n         return elementUse;\n     }\n \n-    private ValueConstraint convertElementValueConstraint(final XMLValueConstraint xmlValueConstraint, final Type type) throws SchemaException\n+    private ValueConstraint convertElementValueConstraint(final XMLValueConstraint xmlValueConstraint, final Type type)\n+        throws SchemaException\n     {\n         if (xmlValueConstraint != null)\n         {\n             if (type instanceof SimpleType)\n             {\n-                return convertValueConstraint(XMLRepresentation.LN_ELEMENT, xmlValueConstraint, (SimpleType)type);\n+                return convertValueConstraint(XMLRepresentation.LN_ELEMENT,\n+                    xmlValueConstraint,\n+   (SimpleType)type);\n             }\n             else if (type instanceof ComplexType)\n             {\n@@ -1278,32 +1294,33 @@ public final class XMLSchemaConverter\n         return null;\n     }\n \n-    private IdentityConstraint convertIdentityConstraint(final XMLIdentityConstraint xmlConstraint) throws SchemaException\n+    private IdentityConstraint convertIdentityConstraint(final XMLIdentityConstraint xmlConstraint)\n+        throws SchemaException\n     {\n         final QName name = xmlConstraint.getName();\n         if (m_outBag.hasIdentityConstraint(name))\n         {\n             return m_outBag.getIdentityConstraint(name);\n         }\n-        if(m_existingCache.hasIdentityConstraint(name))\n+        if (m_existingCache.hasIdentityConstraint(name))\n         {\n-        \tif(!m_lastInWins)\n-        \t{\n-        \t\t// We are not allowing this schema parse to create new elements.  \n+            if (!m_lastInWins)\n+            {\n+                // We are not allowing this schema parse to create new elements.  \n                 m_inCache.m_constraintsUnresolved.remove(name);\n                 return m_existingCache.getIdentityConstraint(name);\n-        \t}\n-        \telse if(m_inCache.m_constraintsUnresolved.containsKey(name) || m_constraintsResolvedFromExistingCache.containsKey(name))\n-        \t{\n-        \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-        \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-        \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-        \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+            }\n+            else if (m_inCache.m_constraintsUnresolved.containsKey(name) || m_constraintsResolvedFromExistingCache.containsKey(name))\n+            {\n+                // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                 m_inCache.m_constraintsUnresolved.remove(name);\n-        \t\tIdentityConstraint existing = m_existingCache.getIdentityConstraint(name);\n-        \t\tm_constraintsResolvedFromExistingCache.put(name, existing);\n+                IdentityConstraint existing = m_existingCache.getIdentityConstraint(name);\n+                m_constraintsResolvedFromExistingCache.put(name, existing);\n                 return existing;\n-        \t}\n+            }\n         }\n         if (m_cycles.constraints.contains(xmlConstraint))\n         {\n@@ -1334,14 +1351,15 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void convertIdentityConstraints() throws AbortException\n+    private void convertIdentityConstraints()\n+        throws AbortException\n     {\n         for (final XMLIdentityConstraint source : m_inCache.m_constraints.values())\n         {\n             try\n             {\n                 QName name = source.getName();\n-                if(!m_lastInWins && m_existingCache.getIdentityConstraint(name) != null)\n+                if (!m_lastInWins && m_existingCache.getIdentityConstraint(name) != null)\n                 {\n                     m_inCache.m_constraintsUnresolved.remove(name);\n                 }\n@@ -1354,7 +1372,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SimpleType convertItemType(final QName simpleType, final XMLTypeRef typeRef) throws AbortException, SchemaException\n+    private SimpleType convertItemType(final QName simpleType, final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException\n     {\n         final Type itemType = convertType(typeRef);\n         if (itemType.isAtomicType())\n@@ -1371,7 +1390,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SimpleType convertMemberType(final QName simpleType, final XMLTypeRef typeRef) throws AbortException, SchemaException\n+    private SimpleType convertMemberType(final QName simpleType, final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException\n     {\n         final Type memberType = convertType(typeRef);\n         if (memberType.isAtomicType())\n@@ -1384,7 +1404,7 @@ public final class XMLSchemaConverter\n         }\n         else if (memberType instanceof UnionSimpleType)\n         {\n-        \treturn (UnionSimpleType)memberType;\n+            return (UnionSimpleType)memberType;\n         }\n         else if (memberType instanceof SimpleType)\n         {\n@@ -1396,7 +1416,8 @@ public final class XMLSchemaConverter\n         throw new SccMemberTypeMustBeAtomicOrListException(simpleType);\n     }\n \n-    private ModelGroup convertModelGroup(final XMLModelGroup xmlModelGroup) throws AbortException, SchemaException\n+    private ModelGroup convertModelGroup(final XMLModelGroup xmlModelGroup)\n+        throws AbortException, SchemaException\n     {\n         final ScopeExtent scope = convertScope(xmlModelGroup.getScope());\n         final QName name;\n@@ -1409,25 +1430,25 @@ public final class XMLSchemaConverter\n             {\n                 return m_outBag.getModelGroup(name);\n             }\n-            if(m_existingCache.hasModelGroup(name))\n+            if (m_existingCache.hasModelGroup(name))\n             {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n                     return m_existingCache.getModelGroup(name);\n-            \t}\n-            \telse if(m_inCache.m_modelGroupsUnresolved.containsKey(name) || m_modelGroupsResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_modelGroupsUnresolved.containsKey(name) || m_modelGroupsResolvedFromExistingCache.containsKey(name))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n-            \t\tModelGroup existing = m_existingCache.getModelGroup(name);\n-            \t\tm_modelGroupsResolvedFromExistingCache.put(name, existing);\n+                    ModelGroup existing = m_existingCache.getModelGroup(name);\n+                    m_modelGroupsResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.groups.contains(xmlModelGroup))\n             {\n@@ -1443,7 +1464,6 @@ public final class XMLSchemaConverter\n             name = null;\n             isAnonymous = true;\n         }\n-\n         try\n         {\n             final ModelGroup.SmCompositor compositor = xmlModelGroup.getCompositor();\n@@ -1468,13 +1488,13 @@ public final class XMLSchemaConverter\n                     {\n                         throw new AssertionError(xmlParticle);\n                     }\n-\n                 }\n                 catch (final SchemaException e)\n                 {\n                     m_errors.error(e);\n                 }\n             }\n+\n             final ModelGroup modelGroup = new ModelGroupImpl(compositor, particles, name, isAnonymous, scope);\n             copyForeignAttributes(xmlModelGroup.foreignAttributes, (ModelGroupImpl)modelGroup);\n             if (modelGroup.getScopeExtent() == ScopeExtent.Global)\n@@ -1493,14 +1513,15 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void convertModelGroups() throws AbortException\n+    private void convertModelGroups()\n+        throws AbortException\n     {\n         for (final XMLModelGroup source : m_inCache.m_modelGroups.values())\n         {\n             try\n             {\n                 QName name = source.getName();\n-                if(!m_lastInWins && m_existingCache.getModelGroup(name) != null)\n+                if (!m_lastInWins && m_existingCache.getModelGroup(name) != null)\n                 {\n                     m_inCache.m_modelGroupsUnresolved.remove(name);\n                 }\n@@ -1513,10 +1534,10 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private ModelGroupUse convertModelGroupUse(final XMLParticleWithModelGroupTerm particle) throws AbortException, SchemaException\n+    private ModelGroupUse convertModelGroupUse(final XMLParticleWithModelGroupTerm particle)\n+        throws AbortException, SchemaException\n     {\n         final ModelGroup modelGroup = convertModelGroup(particle.getTerm());\n-\n         final ModelGroupUse modelGroupUse;\n         if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n         {\n@@ -1547,7 +1568,7 @@ public final class XMLSchemaConverter\n         for (final XMLNotation source : m_inCache.m_notations.values())\n         {\n             QName name = source.getName();\n-            if(!m_lastInWins && m_existingCache.getNotationDeclaration(name) != null)\n+            if (!m_lastInWins && m_existingCache.getNotationDeclaration(name) != null)\n             {\n                 m_inCache.m_notationsUnresolved.remove(name);\n             }\n@@ -1558,14 +1579,15 @@ public final class XMLSchemaConverter\n     private ScopeExtent convertScope(final XMLScope scope)\n     {\n         PreCondition.assertArgumentNotNull(scope, \"scope\");\n-\n         return scope.isGlobal() ? ScopeExtent.Global : ScopeExtent.Local;\n     }\n \n     /**\n      * Applies the Schema Component Constraints to this Simple Type.\n      */\n-    private SimpleType convertSimpleType(final QName name, final boolean isAnonymous, final XMLType xmlSimpleType) throws AbortException, SchemaException\n+\n+    private SimpleType convertSimpleType(final QName name, final boolean isAnonymous, final XMLType xmlSimpleType)\n+        throws AbortException, SchemaException\n     {\n         PreCondition.assertTrue(xmlSimpleType.isSimple(), \"expecting a simple type for \" + name);\n \n@@ -1576,31 +1598,30 @@ public final class XMLSchemaConverter\n             {\n                 return m_outBag.getSimpleType(name);\n             }\n-            if(m_existingCache.hasSimpleType(name))\n+            if (m_existingCache.hasSimpleType(name))\n             {\n-            \tif(!m_lastInWins)\n-            \t{\n-            \t\t// We are not allowing this schema parse to create new elements.  \n+                if (!m_lastInWins)\n+                {\n+                    // We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_typesUnresolved.remove(name);\n                     return m_existingCache.getSimpleType(name);\n-            \t}\n-            \telse if(m_inCache.m_typesUnresolved.containsKey(name) || m_typesResolvedFromExistingCache.containsKey(name))\n-            \t{\n-            \t\t// This component is a reference which refers to an imported component; otherwise, its name would not be \n-            \t\t// in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n-            \t\t// and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n-            \t\t// So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n+                }\n+                else if (m_inCache.m_typesUnresolved.containsKey(name) || m_typesResolvedFromExistingCache.containsKey(name))\n+                {\n+                    // This component is a reference which refers to an imported component; otherwise, its name would not be \n+                    // in the m_inCache.m_XxxUnresolved.  When XMLSchemaCache.registerXxx is called, it removes name from m_XxxUnresolved,\n+                    // and registerXxxt is called when XMLSchemaParser encounters a global component, the only components that can be referenced.\n+                    // So, we're going to remove its name from the list, NOT convert it, and return the existing component.\n                     m_inCache.m_typesUnresolved.remove(name);\n-            \t\tSimpleType existing = m_existingCache.getSimpleType(name);\n-            \t\tm_typesResolvedFromExistingCache.put(name, existing);\n+                    SimpleType existing = m_existingCache.getSimpleType(name);\n+                    m_typesResolvedFromExistingCache.put(name, existing);\n                     return existing;\n-            \t}\n+                }\n             }\n             if (m_cycles.types.contains(xmlSimpleType))\n             {\n                 throw new SmCyclicTypeException(name);\n             }\n-\n             m_cycles.types.push(xmlSimpleType);\n         }\n         try\n@@ -1660,7 +1681,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SimpleType convertSimpleTypeBase(final QName simpleType, final XMLTypeRef baseRef) throws AbortException, SchemaException\n+    private SimpleType convertSimpleTypeBase(final QName simpleType, final XMLTypeRef baseRef)\n+        throws AbortException, SchemaException\n     {\n         final Type baseType = convertType(baseRef);\n         if (baseType instanceof SimpleType)\n@@ -1673,7 +1695,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private Type convertType(final QName name, final boolean isAnonymous) throws SchemaException, AbortException\n+    private Type convertType(final QName name, final boolean isAnonymous)\n+        throws SchemaException, AbortException\n     {\n         // first, check our incrementally collected results, in m_outBag.\n         // if we have something there, return it.\n@@ -1681,7 +1704,7 @@ public final class XMLSchemaConverter\n         if (m_outBag.hasSimpleType(name))\n             return m_outBag.getSimpleType(name);\n         else if (m_outBag.hasComplexType(name))\n-            return m_outBag.getComplexType(name);\n+        return m_outBag.getComplexType(name);\n         else\n         {\n             // now, we look in the collection of xmlrep components. is it there?\n@@ -1690,9 +1713,9 @@ public final class XMLSchemaConverter\n                 // okay. if it's simple or complex, convert it and return\n                 final XMLType type = m_inCache.m_globalTypes.get(name);\n                 if (type.isSimple())\n-                    return convertSimpleType(name, isAnonymous, type);\n+                return convertSimpleType(name, isAnonymous, type);\n                 else if (type.isComplex())\n-                    return convertComplexType(name, isAnonymous, type);\n+                return convertComplexType(name, isAnonymous, type);\n                 // if not, then it's an unresolved reference. so ... don't ever\n                 // call this method if there's more parsing to be done, eh?\n                 throw new SmUndeclaredReferenceException(name, m_inCache.m_typesUnresolved.get(name));\n@@ -1700,40 +1723,41 @@ public final class XMLSchemaConverter\n             // it's not in the collection of unresolved components\n             // is it already in our component provider?\n             else if (m_existingCache.hasSimpleType(name))\n-                return m_existingCache.getSimpleType(name);\n+            return m_existingCache.getSimpleType(name);\n             else if (m_existingCache.hasComplexType(name))\n-                return m_existingCache.getComplexType(name);\n+            return m_existingCache.getComplexType(name);\n             // not there, either. oops. die in flames.\n             throw new SmUndeclaredReferenceException(name, m_inCache.m_typesUnresolved.get(name));\n         }\n     }\n \n-    private Type convertType(final QName name, final boolean isAnonymous, final XMLType type) throws AbortException, SchemaException\n+    private Type convertType(final QName name, final boolean isAnonymous, final XMLType type)\n+        throws AbortException, SchemaException\n     {\n         if (type.isSimple())\n             return convertSimpleType(name, isAnonymous, type);\n         else if (type.isComplex())\n-            return convertComplexType(name, isAnonymous, type);\n+        return convertComplexType(name, isAnonymous, type);\n         // if it's neither simple nor complex, it's a type reference without a referent\n         throw new SmUndeclaredReferenceException(name, m_inCache.m_typesUnresolved.get(name));\n     }\n \n-    private Type convertType(final XMLTypeRef typeRef) throws AbortException, SchemaException\n+    private Type convertType(final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException\n     {\n         if (typeRef.isGlobal())\n         {\n             QName name = typeRef.getName();\n-            if(!m_lastInWins && m_existingCache.hasComplexType(name))\n+            if (!m_lastInWins && m_existingCache.hasComplexType(name))\n             {\n                 m_inCache.m_typesUnresolved.remove(name);\n                 return m_existingCache.getComplexType(name);\n             }\n-            if(!m_lastInWins && m_existingCache.hasSimpleType(name))\n+            if (!m_lastInWins && m_existingCache.hasSimpleType(name))\n             {\n                 m_inCache.m_typesUnresolved.remove(name);\n                 return m_existingCache.getSimpleType(name);\n             }\n-            \n             return convertType(typeRef.getName(), false);\n         }\n         else\n@@ -1742,7 +1766,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private void convertTypes() throws AbortException\n+    private void convertTypes()\n+        throws AbortException\n     {\n         // we're iterating over all of the global types that haven't been\n         // converted yet. local types can't ever be unresolved, of course,\n@@ -1756,29 +1781,29 @@ public final class XMLSchemaConverter\n             try\n             {\n                 // if this one exists already, do special processing in case lastInWins\n-            \tif (m_existingCache.getComplexType(name) != null || m_existingCache.getSimpleType(name) != null)\n-            \t{\n-            \t    if (!m_lastInWins)\n-            \t        m_inCache.m_typesUnresolved.remove(name);\n-            \t    else\n-            \t    {\n-            \t        // if it's a real type to replace the existing, replace.\n-            \t        if (sourceType.isComplex())\n-            \t            convertComplexType(name, isAnonymous, sourceType);\n+                if (m_existingCache.getComplexType(name) != null || m_existingCache.getSimpleType(name) != null)\n+                {\n+                    if (!m_lastInWins)\n+                        m_inCache.m_typesUnresolved.remove(name);\n+                    else\n+                    {\n+                        // if it's a real type to replace the existing, replace.\n+                        if (sourceType.isComplex())\n+                            convertComplexType(name, isAnonymous, sourceType);\n                         else if (sourceType.isSimple())\n-                            convertSimpleType(name, isAnonymous, sourceType);\n-            \t        // if neither complex nor simple, then it's a ref; remove from unresolved\n+                        convertSimpleType(name, isAnonymous, sourceType);\n+                        // if neither complex nor simple, then it's a ref; remove from unresolved\n                         else\n-                            m_inCache.m_typesUnresolved.remove(name);\n-            \t    }\n-            \t}\n-            \t// otherwise, it's not in the existing cache, so convert\n+                        m_inCache.m_typesUnresolved.remove(name);\n+                    }\n+                }\n+                // otherwise, it's not in the existing cache, so convert\n                 else if (sourceType.isComplex())\n-                    convertComplexType(name, isAnonymous, sourceType);\n+                convertComplexType(name, isAnonymous, sourceType);\n                 else if (sourceType.isSimple())\n-                    convertSimpleType(name, isAnonymous, sourceType);\n+                convertSimpleType(name, isAnonymous, sourceType);\n                 else // this isn't going to work--it's an incomplete type/type reference without a referent\n-                    convertType(name, isAnonymous, sourceType); // let this method throw.\n+                convertType(name, isAnonymous, sourceType); // let this method throw.\n             }\n             catch (final SchemaException e)\n             {\n@@ -1787,7 +1812,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private ValueConstraint convertValueConstraint(final String elementName, final XMLValueConstraint xmlValueConstraint, final SimpleType simpleType) \n+    private ValueConstraint convertValueConstraint(final String elementName, final XMLValueConstraint xmlValueConstraint, final SimpleType simpleType)\n         throws SchemaException\n     {\n         if (xmlValueConstraint != null)\n@@ -1806,7 +1831,6 @@ public final class XMLSchemaConverter\n                 final SimpleTypeException ste = new SimpleTypeException(initialValue, simpleType, dte);\n                 throw new SmAttributeUseException(new QName(elementName), xmlValueConstraint.getAttributeName(), xmlValueConstraint.getLocation(), ste);\n             }\n-            \n         }\n         return null;\n     }\n@@ -1823,10 +1847,10 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SchemaParticle convertWildcardUse(final XMLParticleWithWildcardTerm particle) throws SicOversizedIntegerException\n+    private SchemaParticle convertWildcardUse(final XMLParticleWithWildcardTerm particle)\n+        throws SicOversizedIntegerException\n     {\n         final SchemaWildcard wildcard = convertWildcard(particle.getTerm());\n-\n         final WildcardUse wildcardUse;\n         if (isMaxOccursUnbounded(particle.getMaxOccurs()))\n         {\n@@ -1843,7 +1867,8 @@ public final class XMLSchemaConverter\n         return wildcardUse;\n     }\n \n-    private SimpleTypeImpl deriveSimpleType(final QName name, final boolean isAnonymous, final ScopeExtent scope, final SimpleType simpleBaseType, final WhiteSpacePolicy whiteSpace, final SrcFrozenLocation location) throws SchemaException\n+    private SimpleTypeImpl deriveSimpleType(final QName name, final boolean isAnonymous, final ScopeExtent scope, final SimpleType simpleBaseType, final WhiteSpacePolicy whiteSpace, final SrcFrozenLocation location)\n+        throws SchemaException\n     {\n         final SimpleTypeImpl simpleType;\n         if (simpleBaseType.isAtomicType())\n@@ -1878,7 +1903,8 @@ public final class XMLSchemaConverter\n         return simpleType;\n     }\n \n-    private ModelGroupUse effectiveContent(final boolean mixed, final XMLParticleWithModelGroupTerm contentModel) throws AbortException, SchemaException\n+    private ModelGroupUse effectiveContent(final boolean mixed, final XMLParticleWithModelGroupTerm contentModel)\n+        throws AbortException, SchemaException\n     {\n         if (null == contentModel)\n         {\n@@ -1899,7 +1925,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private EnumerationDefinition enumeration(final SimpleType type, final SimpleType baseType, final XMLEnumeration sourceEnum) throws SmAttributeUseException\n+    private EnumerationDefinition enumeration(final SimpleType type, final SimpleType baseType, final XMLEnumeration sourceEnum)\n+        throws SmAttributeUseException\n     {\n         try\n         {\n@@ -1930,7 +1957,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private SimpleType extractSimpleType(final XMLTypeRef typeRef) throws AbortException, SchemaException\n+    private SimpleType extractSimpleType(final XMLTypeRef typeRef)\n+        throws AbortException, SchemaException\n     {\n         final Type type = convertType(typeRef);\n         if (type instanceof SimpleType)\n@@ -1960,7 +1988,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private Facet fractionDigits(final XMLFractionDigitsFacet xmlFacet) throws SicOversizedIntegerException\n+    private Facet fractionDigits(final XMLFractionDigitsFacet xmlFacet)\n+        throws SicOversizedIntegerException\n     {\n         final FacetFractionDigitsImpl impl = new FacetFractionDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n         copyForeignAttributes(xmlFacet.foreignAttributes, impl);\n@@ -1976,7 +2005,9 @@ public final class XMLSchemaConverter\n      * @throws SicOversizedIntegerException\n      *             if value is larger than Integer.MAX_VALUE\n      */\n-    private int getIntValue(final BigInteger value) throws SicOversizedIntegerException\n+\n+    private int getIntValue(final BigInteger value)\n+        throws SicOversizedIntegerException\n     {\n         PreCondition.assertArgumentNotNull(value, \"value\");\n         if (value.compareTo(MAX_INT_SIZE) <= 0)\n@@ -1989,7 +2020,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private Facet length(final XMLLength xmlFacet) throws SicOversizedIntegerException\n+    private Facet length(final XMLLength xmlFacet)\n+        throws SicOversizedIntegerException\n     {\n         final FacetImpl impl;\n         if (xmlFacet.minLength != null)\n@@ -2030,7 +2062,6 @@ public final class XMLSchemaConverter\n         PreCondition.assertArgumentNotNull(value, \"value\");\n         PreCondition.assertArgumentNotNull(simpleType, \"simpleType\");\n         PreCondition.assertArgumentNotNull(kind, \"kind\");\n-\n         if (simpleType.isAtomicType())\n         {\n             return new FacetValueCompImpl(value, kind, simpleType, isFixed);\n@@ -2067,7 +2098,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private Facet minmax(final XMLMinMaxFacet xmlFacet, final SimpleType baseType) throws SchemaException\n+    private Facet minmax(final XMLMinMaxFacet xmlFacet, final SimpleType baseType)\n+        throws SchemaException\n     {\n         // TODO\n         final List<XmlAtom> value;\n@@ -2093,7 +2125,8 @@ public final class XMLSchemaConverter\n         return null;\n     }\n \n-    private Pattern pattern(final XMLPatternFacet pattern) throws SmAttributeUseException\n+    private Pattern pattern(final XMLPatternFacet pattern)\n+        throws SmAttributeUseException\n     {\n         try\n         {\n@@ -2113,13 +2146,15 @@ public final class XMLSchemaConverter\n         }\n         catch (final SimpleTypeException ste)\n         {\n-            final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI, XMLRepresentation.LN_PATTERN);\n+            final QName elementName = new QName(XMLConstants.W3C_XML_SCHEMA_NS_URI,\n+                XMLRepresentation.LN_PATTERN);\n             final QName attributeName = new QName(XMLRepresentation.LN_VALUE);\n             throw new SmAttributeUseException(elementName, attributeName, pattern.getLocation(), ste);\n         }\n     }\n \n-    private ContentType simpleContent(final XMLType simpleType, final SimpleType simpleBaseType) throws AbortException, SchemaException\n+    private ContentType simpleContent(final XMLType simpleType, final SimpleType simpleBaseType)\n+        throws AbortException, SchemaException\n     {\n         final QName name;\n         final boolean isAnonymous;\n@@ -2134,6 +2169,7 @@ public final class XMLSchemaConverter\n             name = m_existingCache.generateUniqueName();\n             isAnonymous = true;\n         }\n+\n         final WhiteSpacePolicy whiteSpace = simpleType.getWhiteSpacePolicy();\n         final SimpleTypeImpl simpleTypeD = deriveSimpleType(name, isAnonymous, scope, simpleBaseType, whiteSpace, simpleType.getLocation());\n         computePatterns(simpleType.getPatternFacets(), simpleTypeD);\n@@ -2142,13 +2178,14 @@ public final class XMLSchemaConverter\n         return new ContentTypeImpl(simpleTypeD);\n     }\n \n-    private Facet totalDigits(final XMLTotalDigitsFacet xmlFacet) throws SicOversizedIntegerException\n+    private Facet totalDigits(final XMLTotalDigitsFacet xmlFacet)\n+        throws SicOversizedIntegerException\n     {\n         final FacetTotalDigitsImpl impl = new FacetTotalDigitsImpl(getIntValue(xmlFacet.value), xmlFacet.fixed);\n         copyForeignAttributes(xmlFacet.foreignAttributes, impl);\n         return impl;\n     }\n-    \n+\n     private void copyForeignAttributes(FAMap source, ForeignAttributesSink target)\n     {\n         for (QName name : source.keySet())\n@@ -2157,19 +2194,19 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    public static  Pair<ComponentBagImpl, XMLComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors) throws AbortException\n+    public static Pair<ComponentBagImpl, XMLComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors)\n+        throws AbortException\n     {\n-    \treturn convert(regexc, rtmCache, xmlCache, errors, false);\n+        return convert(regexc, rtmCache, xmlCache, errors, false);\n     }\n-    public static  Pair<ComponentBagImpl, XMLComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors, boolean lastInWins) throws AbortException\n+\n+    public static Pair<ComponentBagImpl, XMLComponentLocator> convert(final SchemaRegExCompiler regexc, final ComponentProvider rtmCache, final XMLSchemaCache xmlCache, final SchemaExceptionHandler errors, boolean lastInWins)\n+        throws AbortException\n     {\n         final ComponentBagImpl schema = new ComponentBagImpl();\n         final XMLComponentLocator locations = new XMLComponentLocator();\n-\n         final XMLSchemaConverter converter = new XMLSchemaConverter(regexc, rtmCache, xmlCache, schema, locations, errors, lastInWins);\n-\n         xmlCache.computeSubstitutionGroups();\n-\n         converter.convertTypes();\n         converter.convertAttributes();\n         converter.convertElements();\n@@ -2177,14 +2214,13 @@ public final class XMLSchemaConverter\n         converter.convertIdentityConstraints();\n         converter.convertModelGroups();\n         converter.convertNotations();\n-\n         return new Pair<ComponentBagImpl, XMLComponentLocator>(schema, locations);\n     }\n \n-    static boolean isMaxOccursUnbounded(final BigInteger maxOccurs) throws SicOversizedIntegerException\n+    static boolean isMaxOccursUnbounded(final BigInteger maxOccurs)\n+        throws SicOversizedIntegerException\n     {\n         PreCondition.assertArgumentNotNull(maxOccurs, \"maxOccurs\");\n-\n         if (XMLParticle.UNBOUNDED.equals(maxOccurs))\n         {\n             return true;\n@@ -2202,10 +2238,10 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    static int maxOccurs(final BigInteger maxOccurs) throws SicOversizedIntegerException\n+    static int maxOccurs(final BigInteger maxOccurs)\n+        throws SicOversizedIntegerException\n     {\n         PreCondition.assertArgumentNotNull(maxOccurs, \"maxOccurs\");\n-\n         if (XMLParticle.UNBOUNDED.equals(maxOccurs))\n         {\n             throw new IllegalStateException(\"maxOccurs is unbounded\");\n@@ -2223,7 +2259,8 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    static int minOccurs(final BigInteger minOccurs) throws SicOversizedIntegerException\n+    static int minOccurs(final BigInteger minOccurs)\n+        throws SicOversizedIntegerException\n     {\n         PreCondition.assertArgumentNotNull(minOccurs, \"minOccurs\");\n         if (MAX_INT_SIZE.compareTo(minOccurs) < 0)\n@@ -2237,7 +2274,7 @@ public final class XMLSchemaConverter\n         }\n     }\n \n-    private static  boolean subtype(final Type lhs, final Type rhs)\n+    private static boolean subtype(final Type lhs, final Type rhs)\n     {\n         PreCondition.assertArgumentNotNull(lhs, \"lhs\");\n         PreCondition.assertArgumentNotNull(rhs, \"rhs\");\n@@ -2246,22 +2283,22 @@ public final class XMLSchemaConverter\n             Type currentType = lhs;\n             while (true)\n             {\n-            \tif(currentType == rhs)\n-            \t{\n-            \t\treturn true;\n-            \t}\n-            \tif(currentType.getName().equals(rhs.getName()))\n-            \t{\n-            \t\treturn true;\n-            \t}\n-            \tif (!currentType.isComplexUrType())\n-            \t{\n-            \t\tcurrentType = currentType.getBaseType();\n-            \t}\n-            \telse\n-            \t{\n-            \t\treturn false;\n-            \t}\n+                if (currentType == rhs)\n+                {\n+                    return true;\n+                }\n+                if (currentType.getName().equals(rhs.getName()))\n+                {\n+                    return true;\n+                }\n+                if (!currentType.isComplexUrType())\n+                {\n+                    currentType = currentType.getBaseType();\n+                }\n+                else\n+                {\n+                    return false;\n+                }\n             }\n         }\n         else\n@@ -2275,29 +2312,24 @@ public final class XMLSchemaConverter\n      * Integer.MAX_VALUE as a BigInteger; needed to ensure that we throw an exception rather than attempt to convert\n      * BigInteger values larger than Integer.MAX_VALUE.\n      */\n-    private static final BigInteger MAX_INT_SIZE = BigInteger.valueOf(Integer.MAX_VALUE);\n \n+    private static final BigInteger MAX_INT_SIZE = BigInteger.valueOf(Integer.MAX_VALUE);\n     private final ContentType EMPTY_CONTENT = new ContentTypeImpl();\n     private final XMLCycles m_cycles;\n-\n     private final SchemaExceptionHandler m_errors;\n \n     // things that have already been pushed into the component provider in this parse group\n     private final ComponentProvider m_existingCache;\n-    \n     private final CanonicalAtomBridge m_atoms;\n \n     // this is the collection of components from the xmlrep package.\n     // it needs to be empty when we're done.\n     private final XMLSchemaCache m_inCache;\n-\n     private final XMLComponentLocator m_locations;\n \n     // this is what we'll return\n     private final ComponentBagImpl m_outBag;\n-\n     private final SchemaRegExCompiler regexc;\n-    \n     private final boolean m_lastInWins;\n     \n     // Used only when m_lastInWins is true\n@@ -2308,4 +2340,4 @@ public final class XMLSchemaConverter\n     public final Map<QName, AttributeGroupDefinition> m_attributeGroupsResolvedFromExistingCache = new HashMap<QName, AttributeGroupDefinition>();\n     public final Map<QName, IdentityConstraint> m_constraintsResolvedFromExistingCache = new HashMap<QName, IdentityConstraint>();\n     public final Map<QName, NotationDefinition> m_notationsResolvedFromExistingCache = new HashMap<QName, NotationDefinition>();\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 318
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "576",
                    "column": "13",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/487/XMLSchemaConverter.java\nindex 71e16fd0e7e..f3202725df8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/487/XMLSchemaConverter.java\n@@ -572,7 +572,7 @@ public final class XMLSchemaConverter\n             }\n             if(m_existingCache.hasAttribute(name))\n             {\n-            \tif(!m_lastInWins)\n+            if(!m_lastInWins)\n             \t{\n             \t\t// We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributesUnresolved.remove(name);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "576",
                    "column": "13",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/487/XMLSchemaConverter.java\nindex 71e16fd0e7e..da3ca70f97e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/487/XMLSchemaConverter.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/487/XMLSchemaConverter.java\n@@ -572,7 +572,7 @@ public final class XMLSchemaConverter\n             }\n             if(m_existingCache.hasAttribute(name))\n             {\n-            \tif(!m_lastInWins)\n+                if(!m_lastInWins)\n             \t{\n             \t\t// We are not allowing this schema parse to create new elements.  \n                     m_inCache.m_attributesUnresolved.remove(name);\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}