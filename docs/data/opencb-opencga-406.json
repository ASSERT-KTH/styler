{
    "project_name": "opencb-opencga",
    "error_id": "406",
    "information": {
        "errors": [
            {
                "line": "299",
                "column": "99",
                "severity": "error",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "        for (String s : groupByField) {\n            if (s.contains(\".\")) {\n                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d->{\n                    Object o = d.remove(s.replace(\".\", GenericDocumentComplexConverter.TO_REPLACE_DOTS));\n                    d.put(s, o);\n                });",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/406/MongoDBAdaptor.java\nindex a64e27fac31..6f72e8b7fdb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/406/MongoDBAdaptor.java\n@@ -296,7 +296,7 @@ public class MongoDBAdaptor extends AbstractDBAdaptor {\n         DataResult<Document> aggregate = collection.aggregate(Arrays.asList(match, project, group), options);\n         for (String s : groupByField) {\n             if (s.contains(\".\")) {\n-                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d->{\n+                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d-> {\n                     Object o = d.remove(s.replace(\".\", GenericDocumentComplexConverter.TO_REPLACE_DOTS));\n                     d.put(s, o);\n                 });\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/406/MongoDBAdaptor.java\nindex a64e27fac31..6b47bd20cf9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/406/MongoDBAdaptor.java\n@@ -42,628 +42,630 @@ import java.util.function.Consumer;\n  */\n public class MongoDBAdaptor extends AbstractDBAdaptor {\n \n-    static final String PRIVATE_UID = \"uid\";\n-    static final String PRIVATE_UUID = \"uuid\";\n-    static final String PRIVATE_ID = \"id\";\n-    static final String PRIVATE_FQN = \"fqn\";\n-    static final String PRIVATE_PROJECT = \"_project\";\n-    static final String PRIVATE_PROJECT_ID = PRIVATE_PROJECT + '.' + PRIVATE_ID;\n-    static final String PRIVATE_PROJECT_UID = PRIVATE_PROJECT + '.' + PRIVATE_UID;\n-    static final String PRIVATE_PROJECT_UUID = PRIVATE_PROJECT + '.' + PRIVATE_UUID;\n-    static final String PRIVATE_OWNER_ID = \"_ownerId\";\n-    public static final String PRIVATE_STUDY_UID = \"studyUid\";\n-    private static final String VERSION = \"version\";\n-\n-    static final String FILTER_ROUTE_STUDIES = \"projects.studies.\";\n-    static final String FILTER_ROUTE_COHORTS = \"projects.studies.cohorts.\";\n-    static final String FILTER_ROUTE_INDIVIDUALS = \"projects.studies.individuals.\";\n-    static final String FILTER_ROUTE_SAMPLES = \"projects.studies.samples.\";\n-    static final String FILTER_ROUTE_FILES = \"projects.studies.files.\";\n-    static final String FILTER_ROUTE_JOBS = \"projects.studies.jobs.\";\n-\n-    static final String LAST_OF_VERSION = \"_lastOfVersion\";\n-    static final String RELEASE_FROM_VERSION = \"_releaseFromVersion\";\n-    static final String LAST_OF_RELEASE = \"_lastOfRelease\";\n-    static final String PRIVATE_CREATION_DATE = \"_creationDate\";\n-    static final String PRIVATE_MODIFICATION_DATE = \"_modificationDate\";\n-    static final String PERMISSION_RULES_APPLIED = \"_permissionRulesApplied\";\n-\n-    static final String INTERNAL_DELIMITER = \"__\";\n-\n-    public static final String NATIVE_QUERY = \"nativeQuery\";\n-\n-    // Possible update actions\n-    static final String SET = \"SET\";\n-\n-    protected MongoDBAdaptorFactory dbAdaptorFactory;\n-    protected Map<Long, String> variableUidIdMap;\n-\n-    public MongoDBAdaptor(Logger logger) {\n-        super(logger);\n-    }\n-\n-    public interface TransactionBodyWithException<T> {\n-        T execute(ClientSession session) throws CatalogDBException;\n-    }\n-\n-    protected <T> T runTransaction(TransactionBodyWithException<T> body) throws CatalogDBException {\n-        return runTransaction(body, null);\n-    }\n-\n-    protected <T> T runTransaction(TransactionBodyWithException<T> body, Consumer<CatalogDBException> onException)\n-            throws CatalogDBException {\n-        ClientSession session = dbAdaptorFactory.getMongoDataStore().startSession();\n+  static final String PRIVATE_UID = \"uid\";\n+  static final String PRIVATE_UUID = \"uuid\";\n+  static final String PRIVATE_ID = \"id\";\n+  static final String PRIVATE_FQN = \"fqn\";\n+  static final String PRIVATE_PROJECT = \"_project\";\n+  static final String PRIVATE_PROJECT_ID = PRIVATE_PROJECT + '.' + PRIVATE_ID;\n+  static final String PRIVATE_PROJECT_UID = PRIVATE_PROJECT + '.' + PRIVATE_UID;\n+  static final String PRIVATE_PROJECT_UUID = PRIVATE_PROJECT + '.' + PRIVATE_UUID;\n+  static final String PRIVATE_OWNER_ID = \"_ownerId\";\n+  public static final String PRIVATE_STUDY_UID = \"studyUid\";\n+  private static final String VERSION = \"version\";\n+\n+  static final String FILTER_ROUTE_STUDIES = \"projects.studies.\";\n+  static final String FILTER_ROUTE_COHORTS = \"projects.studies.cohorts.\";\n+  static final String FILTER_ROUTE_INDIVIDUALS = \"projects.studies.individuals.\";\n+  static final String FILTER_ROUTE_SAMPLES = \"projects.studies.samples.\";\n+  static final String FILTER_ROUTE_FILES = \"projects.studies.files.\";\n+  static final String FILTER_ROUTE_JOBS = \"projects.studies.jobs.\";\n+\n+  static final String LAST_OF_VERSION = \"_lastOfVersion\";\n+  static final String RELEASE_FROM_VERSION = \"_releaseFromVersion\";\n+  static final String LAST_OF_RELEASE = \"_lastOfRelease\";\n+  static final String PRIVATE_CREATION_DATE = \"_creationDate\";\n+  static final String PRIVATE_MODIFICATION_DATE = \"_modificationDate\";\n+  static final String PERMISSION_RULES_APPLIED = \"_permissionRulesApplied\";\n+\n+  static final String INTERNAL_DELIMITER = \"__\";\n+\n+  public static final String NATIVE_QUERY = \"nativeQuery\";\n+\n+  // Possible update actions\n+  static final String SET = \"SET\";\n+\n+  protected MongoDBAdaptorFactory dbAdaptorFactory;\n+  protected Map<Long, String> variableUidIdMap;\n+\n+  public MongoDBAdaptor(Logger logger) {\n+    super(logger);\n+  }\n+\n+  public interface TransactionBodyWithException<T> {\n+    T execute(ClientSession session) throws CatalogDBException;\n+  }\n+\n+  protected <T> T runTransaction(TransactionBodyWithException<T> body) throws CatalogDBException {\n+    return runTransaction(body, null);\n+  }\n+\n+  protected <T> T runTransaction(TransactionBodyWithException<T> body, Consumer<CatalogDBException> onException)\n+      throws CatalogDBException {\n+    ClientSession session = dbAdaptorFactory.getMongoDataStore().startSession();\n+    try {\n+      return session.withTransaction(() -> {\n         try {\n-            return session.withTransaction(() -> {\n-                try {\n-                    return body.execute(session);\n-                } catch (CatalogDBException e) {\n-                    throw new CatalogDBRuntimeException(e);\n-                }\n-            });\n-        } catch (CatalogDBRuntimeException e) {\n-            CatalogDBException cause = (CatalogDBException) e.getCause();\n-            if (onException != null) {\n-                onException.accept(cause);\n-            }\n-            throw cause;\n-        } finally {\n-            session.close();\n-        }\n+          return body.execute(session);\n+        } catch (CatalogDBException e) {\n+          throw new CatalogDBRuntimeException(e);\n+        }\n+      });\n+    } catch (CatalogDBRuntimeException e) {\n+      CatalogDBException cause = (CatalogDBException) e.getCause();\n+      if (onException != null) {\n+        onException.accept(cause);\n+      }\n+      throw cause;\n+    } finally {\n+      session.close();\n     }\n+  }\n \n-    protected long getNewUid() {\n+  protected long getNewUid() {\n //        return CatalogMongoDBUtils.getNewAutoIncrementId(metaCollection);\n-        return dbAdaptorFactory.getCatalogMetaDBAdaptor().getNewAutoIncrementId();\n-    }\n+    return dbAdaptorFactory.getCatalogMetaDBAdaptor().getNewAutoIncrementId();\n+  }\n \n-    protected long getNewUid(ClientSession clientSession) {\n+  protected long getNewUid(ClientSession clientSession) {\n //        return CatalogMongoDBUtils.getNewAutoIncrementId(metaCollection);\n-        return dbAdaptorFactory.getCatalogMetaDBAdaptor().getNewAutoIncrementId(clientSession);\n-    }\n-\n-    @Deprecated\n-    protected void addIntegerOrQuery(String mongoDbField, String queryParam, Query query, List<Bson> andBsonList) {\n-        addQueryFilter(mongoDbField, queryParam, query, QueryParam.Type.INTEGER, MongoDBQueryUtils.ComparisonOperator.EQUALS,\n-                MongoDBQueryUtils.LogicalOperator.OR, andBsonList);\n-    }\n-\n-    @Deprecated\n-    protected void addStringOrQuery(String mongoDbField, String queryParam, Query query, List<Bson> andBsonList) {\n-        addQueryFilter(mongoDbField, queryParam, query, QueryParam.Type.TEXT, MongoDBQueryUtils.ComparisonOperator.EQUALS,\n-                MongoDBQueryUtils.LogicalOperator.OR, andBsonList);\n-    }\n-\n-\n-    @Deprecated\n-    protected void addStringOrQuery(String mongoDbField, String queryParam, Query query, MongoDBQueryUtils.ComparisonOperator\n-            comparisonOperator, List<Bson> andBsonList) {\n-        addQueryFilter(mongoDbField, queryParam, query, QueryParam.Type.TEXT, comparisonOperator,\n-                MongoDBQueryUtils.LogicalOperator.OR, andBsonList);\n-    }\n-\n-    /**\n-     * It will add a filter to andBsonList based on the query object. The operator will always be an EQUAL.\n-     * @param mongoDbField The field used in the mongoDB.\n-     * @param queryParam The key by which the parameter is stored in the query. Normally, it will be the same as in the data model,\n-     *                   although it might be some exceptions.\n-     * @param query The object containing the key:values of the query.\n-     * @param paramType The type of the object to be looked up. See {@link QueryParam}.\n-     * @param andBsonList The list where created filter will be added to.\n-     */\n-    protected void addOrQuery(String mongoDbField, String queryParam, Query query, QueryParam.Type paramType, List<Bson> andBsonList) {\n-        addQueryFilter(mongoDbField, queryParam, query, paramType, MongoDBQueryUtils.ComparisonOperator.IN,\n-                MongoDBQueryUtils.LogicalOperator.OR, andBsonList);\n-    }\n-\n-    /**\n-     * It will check for the proper comparator based on the query value and create the correct query filter.\n-     * It could be a regular expression, >, < ... or a simple equals.\n-     * @param mongoDbField The field used in the mongoDB.\n-     * @param queryParam The key by which the parameter is stored in the query. Normally, it will be the same as in the data model,\n-     *                   although it might be some exceptions.\n-     * @param query The object containing the key:values of the query.\n-     * @param paramType The type of the object to be looked up. See {@link QueryParam}.\n-     * @param andBsonList The list where created filter will be added to.\n-     */\n-    protected void addAutoOrQuery(String mongoDbField, String queryParam, Query query, QueryParam.Type paramType, List<Bson> andBsonList) {\n-        if (query != null && query.getString(queryParam) != null) {\n-            Bson filter = MongoDBQueryUtils.createAutoFilter(mongoDbField, queryParam, query, paramType);\n-            if (filter != null) {\n-                andBsonList.add(filter);\n-            }\n-        }\n+    return dbAdaptorFactory.getCatalogMetaDBAdaptor().getNewAutoIncrementId(clientSession);\n+  }\n+\n+  @Deprecated\n+  protected void addIntegerOrQuery(String mongoDbField, String queryParam, Query query, List<Bson> andBsonList) {\n+    addQueryFilter(mongoDbField, queryParam, query, QueryParam.Type.INTEGER, MongoDBQueryUtils.ComparisonOperator.EQUALS,\n+        MongoDBQueryUtils.LogicalOperator.OR, andBsonList);\n+  }\n+\n+  @Deprecated\n+  protected void addStringOrQuery(String mongoDbField, String queryParam, Query query, List<Bson> andBsonList) {\n+    addQueryFilter(mongoDbField, queryParam, query, QueryParam.Type.TEXT, MongoDBQueryUtils.ComparisonOperator.EQUALS,\n+        MongoDBQueryUtils.LogicalOperator.OR, andBsonList);\n+  }\n+\n+\n+  @Deprecated\n+  protected void addStringOrQuery(String mongoDbField, String queryParam, Query query, MongoDBQueryUtils.ComparisonOperator\n+      comparisonOperator, List<Bson> andBsonList) {\n+    addQueryFilter(mongoDbField, queryParam, query, QueryParam.Type.TEXT, comparisonOperator,\n+        MongoDBQueryUtils.LogicalOperator.OR, andBsonList);\n+  }\n+\n+  /**\n+   * It will add a filter to andBsonList based on the query object. The operator will always be an EQUAL.\n+   *\n+   * @param mongoDbField The field used in the mongoDB.\n+   * @param queryParam   The key by which the parameter is stored in the query. Normally, it will be the same as in the data model,\n+   *                     although it might be some exceptions.\n+   * @param query        The object containing the key:values of the query.\n+   * @param paramType    The type of the object to be looked up. See {@link QueryParam}.\n+   * @param andBsonList  The list where created filter will be added to.\n+   */\n+  protected void addOrQuery(String mongoDbField, String queryParam, Query query, QueryParam.Type paramType, List<Bson> andBsonList) {\n+    addQueryFilter(mongoDbField, queryParam, query, paramType, MongoDBQueryUtils.ComparisonOperator.IN,\n+        MongoDBQueryUtils.LogicalOperator.OR, andBsonList);\n+  }\n+\n+  /**\n+   * It will check for the proper comparator based on the query value and create the correct query filter.\n+   * It could be a regular expression, >, < ... or a simple equals.\n+   *\n+   * @param mongoDbField The field used in the mongoDB.\n+   * @param queryParam   The key by which the parameter is stored in the query. Normally, it will be the same as in the data model,\n+   *                     although it might be some exceptions.\n+   * @param query        The object containing the key:values of the query.\n+   * @param paramType    The type of the object to be looked up. See {@link QueryParam}.\n+   * @param andBsonList  The list where created filter will be added to.\n+   */\n+  protected void addAutoOrQuery(String mongoDbField, String queryParam, Query query, QueryParam.Type paramType, List<Bson> andBsonList) {\n+    if (query != null && query.getString(queryParam) != null) {\n+      Bson filter = MongoDBQueryUtils.createAutoFilter(mongoDbField, queryParam, query, paramType);\n+      if (filter != null) {\n+        andBsonList.add(filter);\n+      }\n     }\n-\n-    protected void addQueryFilter(String mongoDbField, String queryParam, Query query, QueryParam.Type paramType,\n-                                  MongoDBQueryUtils.ComparisonOperator comparisonOperator, MongoDBQueryUtils.LogicalOperator operator,\n-                                  List<Bson> andBsonList) {\n-        if (query != null && query.getString(queryParam) != null) {\n-            Bson filter = MongoDBQueryUtils.createFilter(mongoDbField, queryParam, query, paramType, comparisonOperator, operator);\n-            if (filter != null) {\n-                andBsonList.add(filter);\n-            }\n-        }\n+  }\n+\n+  protected void addQueryFilter(String mongoDbField, String queryParam, Query query, QueryParam.Type paramType,\n+                                MongoDBQueryUtils.ComparisonOperator comparisonOperator, MongoDBQueryUtils.LogicalOperator operator,\n+                                List<Bson> andBsonList) {\n+    if (query != null && query.getString(queryParam) != null) {\n+      Bson filter = MongoDBQueryUtils.createFilter(mongoDbField, queryParam, query, paramType, comparisonOperator, operator);\n+      if (filter != null) {\n+        andBsonList.add(filter);\n+      }\n     }\n+  }\n \n-    protected OpenCGAResult rank(MongoDBCollection collection, Bson query, String groupByField, String idField, int numResults,\n-                                 boolean asc) {\n-        if (groupByField == null || groupByField.isEmpty()) {\n-            return new OpenCGAResult();\n-        }\n+  protected OpenCGAResult rank(MongoDBCollection collection, Bson query, String groupByField, String idField, int numResults,\n+                               boolean asc) {\n+    if (groupByField == null || groupByField.isEmpty()) {\n+      return new OpenCGAResult();\n+    }\n \n-        if (groupByField.contains(\",\")) {\n-            // call to multiple rank if commas are present\n-            return rank(collection, query, Arrays.asList(groupByField.split(\",\")), idField, numResults, asc);\n-        } else {\n-            Bson match = Aggregates.match(query);\n-            Bson project = Aggregates.project(Projections.include(groupByField, idField));\n-            Bson group = Aggregates.group(\"$\" + groupByField, Accumulators.sum(\"count\", 1));\n-            Bson sort;\n-            if (asc) {\n-                sort = Aggregates.sort(Sorts.ascending(\"count\"));\n-            } else {\n-                sort = Aggregates.sort(Sorts.descending(\"count\"));\n-            }\n-            Bson limit = Aggregates.limit(numResults);\n-\n-            return new OpenCGAResult(collection.aggregate(Arrays.asList(match, project, group, sort, limit), new QueryOptions()));\n-        }\n+    if (groupByField.contains(\",\")) {\n+      // call to multiple rank if commas are present\n+      return rank(collection, query, Arrays.asList(groupByField.split(\",\")), idField, numResults, asc);\n+    } else {\n+      Bson match = Aggregates.match(query);\n+      Bson project = Aggregates.project(Projections.include(groupByField, idField));\n+      Bson group = Aggregates.group(\"$\" + groupByField, Accumulators.sum(\"count\", 1));\n+      Bson sort;\n+      if (asc) {\n+        sort = Aggregates.sort(Sorts.ascending(\"count\"));\n+      } else {\n+        sort = Aggregates.sort(Sorts.descending(\"count\"));\n+      }\n+      Bson limit = Aggregates.limit(numResults);\n+\n+      return new OpenCGAResult(collection.aggregate(Arrays.asList(match, project, group, sort, limit), new QueryOptions()));\n     }\n+  }\n \n-    protected OpenCGAResult rank(MongoDBCollection collection, Bson query, List<String> groupByField, String idField, int numResults,\n+  protected OpenCGAResult rank(MongoDBCollection collection, Bson query, List<String> groupByField, String idField, int numResults,\n                                boolean asc) {\n \n-        if (groupByField == null || groupByField.isEmpty()) {\n-            return new OpenCGAResult();\n-        }\n+    if (groupByField == null || groupByField.isEmpty()) {\n+      return new OpenCGAResult();\n+    }\n \n-        if (groupByField.size() == 1) {\n-            // if only one field then we call to simple rank\n-            return rank(collection, query, groupByField.get(0), idField, numResults, asc);\n-        } else {\n-            Bson match = Aggregates.match(query);\n-\n-            // add all group-by fields to the projection together with the aggregation field name\n-            List<String> groupByFields = new ArrayList<>(groupByField);\n-            groupByFields.add(idField);\n-            Bson project = Aggregates.project(Projections.include(groupByFields));\n-\n-            // _id document creation to have the multiple id\n-            Document id = new Document();\n-            for (String s : groupByField) {\n-                id.append(s, \"$\" + s);\n-            }\n-            Bson group = Aggregates.group(id, Accumulators.sum(\"count\", 1));\n-            Bson sort;\n-            if (asc) {\n-                sort = Aggregates.sort(Sorts.ascending(\"count\"));\n-            } else {\n-                sort = Aggregates.sort(Sorts.descending(\"count\"));\n-            }\n-            Bson limit = Aggregates.limit(numResults);\n-\n-            return new OpenCGAResult(collection.aggregate(Arrays.asList(match, project, group, sort, limit), new QueryOptions()));\n-        }\n+    if (groupByField.size() == 1) {\n+      // if only one field then we call to simple rank\n+      return rank(collection, query, groupByField.get(0), idField, numResults, asc);\n+    } else {\n+      Bson match = Aggregates.match(query);\n+\n+      // add all group-by fields to the projection together with the aggregation field name\n+      List<String> groupByFields = new ArrayList<>(groupByField);\n+      groupByFields.add(idField);\n+      Bson project = Aggregates.project(Projections.include(groupByFields));\n+\n+      // _id document creation to have the multiple id\n+      Document id = new Document();\n+      for (String s : groupByField) {\n+        id.append(s, \"$\" + s);\n+      }\n+      Bson group = Aggregates.group(id, Accumulators.sum(\"count\", 1));\n+      Bson sort;\n+      if (asc) {\n+        sort = Aggregates.sort(Sorts.ascending(\"count\"));\n+      } else {\n+        sort = Aggregates.sort(Sorts.descending(\"count\"));\n+      }\n+      Bson limit = Aggregates.limit(numResults);\n+\n+      return new OpenCGAResult(collection.aggregate(Arrays.asList(match, project, group, sort, limit), new QueryOptions()));\n     }\n+  }\n \n-    protected OpenCGAResult groupBy(MongoDBCollection collection, Bson query, String groupByField, String idField, QueryOptions options) {\n-        if (groupByField == null || groupByField.isEmpty()) {\n-            return new OpenCGAResult();\n-        }\n+  protected OpenCGAResult groupBy(MongoDBCollection collection, Bson query, String groupByField, String idField, QueryOptions options) {\n+    if (groupByField == null || groupByField.isEmpty()) {\n+      return new OpenCGAResult();\n+    }\n \n-        if (groupByField.contains(\",\")) {\n-            // call to multiple groupBy if commas are present\n-            return groupBy(collection, query, Arrays.asList(groupByField.split(\",\")), idField, options);\n-        } else {\n-            return groupBy(collection, query, Arrays.asList(groupByField), idField, options);\n-        }\n+    if (groupByField.contains(\",\")) {\n+      // call to multiple groupBy if commas are present\n+      return groupBy(collection, query, Arrays.asList(groupByField.split(\",\")), idField, options);\n+    } else {\n+      return groupBy(collection, query, Arrays.asList(groupByField), idField, options);\n     }\n+  }\n \n-    protected OpenCGAResult groupBy(MongoDBCollection collection, Bson query, List<String> groupByField, String idField,\n+  protected OpenCGAResult groupBy(MongoDBCollection collection, Bson query, List<String> groupByField, String idField,\n                                   QueryOptions options) {\n-        if (groupByField == null || groupByField.isEmpty()) {\n-            return new OpenCGAResult();\n-        }\n-\n-        List<String> groupByFields = new ArrayList<>(groupByField);\n-        Bson match = Aggregates.match(query);\n-\n-        // add all group-by fields to the projection together with the aggregation field name\n-        List<String> includeGroupByFields = new ArrayList<>(groupByFields);\n-        includeGroupByFields.add(idField);\n-        Document projection = createDateProjection(includeGroupByFields, groupByFields);\n-        Document annotationDocument = createAnnotationProjectionForGroupBy(includeGroupByFields);\n-        projection.putAll(annotationDocument);\n-\n-        for (String field : includeGroupByFields) {\n-            // Include the parameters from the includeGroupByFields list\n-            projection.append(field, 1);\n-        }\n-        Bson project = Aggregates.project(projection);\n-\n-        // _id document creation to have the multiple id\n-        Document id = new Document();\n-        for (String s : groupByFields) {\n-            id.append(s.replace(\".\", GenericDocumentComplexConverter.TO_REPLACE_DOTS), \"$\" + s);\n-        }\n-        Bson group;\n-        if (options.getBoolean(QueryOptions.COUNT, false)) {\n-            group = Aggregates.group(id, Accumulators.sum(QueryOptions.COUNT, 1));\n-        } else {\n-            group = Aggregates.group(id, Accumulators.addToSet(\"items\", \"$\" + idField));\n-        }\n-        DataResult<Document> aggregate = collection.aggregate(Arrays.asList(match, project, group), options);\n-        for (String s : groupByField) {\n-            if (s.contains(\".\")) {\n-                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d->{\n-                    Object o = d.remove(s.replace(\".\", GenericDocumentComplexConverter.TO_REPLACE_DOTS));\n-                    d.put(s, o);\n-                });\n-            }\n-        }\n-        return new OpenCGAResult<>(aggregate);\n-    }\n-\n-    /**\n-     * Create a date projection if included in the includeGroupByFields, removes the date fields from includeGroupByFields and\n-     * add them to groupByFields if not there.\n-     * Only for groupBy methods.\n-     *\n-     * @param includeGroupByFields List containing the fields to be included in the projection.\n-     * @param groupByFields List containing the fields by which the group by will be done.\n-     */\n-    private Document createDateProjection(List<String> includeGroupByFields, List<String> groupByFields) {\n-        Document dateProjection = new Document();\n-        Document year = new Document(\"$year\", \"$\" + PRIVATE_CREATION_DATE);\n-        Document month = new Document(\"$month\", \"$\" + PRIVATE_CREATION_DATE);\n-        Document day = new Document(\"$dayOfMonth\", \"$\" + PRIVATE_CREATION_DATE);\n-\n-        if (includeGroupByFields.contains(\"day\")) {\n-            dateProjection.append(\"day\", day).append(\"month\", month).append(\"year\", year);\n-            includeGroupByFields.remove(\"day\");\n-            if (!includeGroupByFields.remove(\"month\")) {\n-                groupByFields.add(\"month\");\n-            }\n-            if (!includeGroupByFields.remove(\"year\")) {\n-                groupByFields.add(\"year\");\n-            }\n-\n-        } else if (includeGroupByFields.contains(\"month\")) {\n-            dateProjection.append(\"month\", month).append(\"year\", year);\n-            includeGroupByFields.remove(\"month\");\n-            if (!includeGroupByFields.remove(\"year\")) {\n-                groupByFields.add(\"year\");\n-            }\n-        } else if (includeGroupByFields.contains(\"year\")) {\n-            dateProjection.append(\"year\", year);\n-            includeGroupByFields.remove(\"year\");\n-        }\n-\n-        return dateProjection;\n+    if (groupByField == null || groupByField.isEmpty()) {\n+      return new OpenCGAResult();\n     }\n \n-    /**\n-     * Fixes the annotation ids provided by the user to create a proper groupBy by any annotation field provided.\n-     *\n-     * @param includeGroupByFields List containing the fields to be included in the projection.\n-     */\n-    private Document createAnnotationProjectionForGroupBy(List<String> includeGroupByFields) {\n-        Document document = new Document();\n+    List<String> groupByFields = new ArrayList<>(groupByField);\n+    Bson match = Aggregates.match(query);\n \n-        Iterator<String> iterator = includeGroupByFields.iterator();\n-        while (iterator.hasNext()) {\n-            String field = iterator.next();\n+    // add all group-by fields to the projection together with the aggregation field name\n+    List<String> includeGroupByFields = new ArrayList<>(groupByFields);\n+    includeGroupByFields.add(idField);\n+    Document projection = createDateProjection(includeGroupByFields, groupByFields);\n+    Document annotationDocument = createAnnotationProjectionForGroupBy(includeGroupByFields);\n+    projection.putAll(annotationDocument);\n \n-            if (field.startsWith(Constants.ANNOTATION)) {\n-                String replacedField = field\n-                        .replace(Constants.ANNOTATION + \":\", \"\")\n-                        .replace(\":\", INTERNAL_DELIMITER)\n-                        .replace(\".\", INTERNAL_DELIMITER);\n-                iterator.remove();\n+    for (String field : includeGroupByFields) {\n+      // Include the parameters from the includeGroupByFields list\n+      projection.append(field, 1);\n+    }\n+    Bson project = Aggregates.project(projection);\n \n-                document.put(field, \"$\" + AnnotationMongoDBAdaptor.AnnotationSetParams.ANNOTATION_SETS.key() + \".\" + replacedField);\n-            }\n-        }\n+    // _id document creation to have the multiple id\n+    Document id = new Document();\n+    for (String s : groupByFields) {\n+      id.append(s.replace(\".\", GenericDocumentComplexConverter.TO_REPLACE_DOTS), \"$\" + s);\n+    }\n+    Bson group;\n+    if (options.getBoolean(QueryOptions.COUNT, false)) {\n+      group = Aggregates.group(id, Accumulators.sum(QueryOptions.COUNT, 1));\n+    } else {\n+      group = Aggregates.group(id, Accumulators.addToSet(\"items\", \"$\" + idField));\n+    }\n+    DataResult<Document> aggregate = collection.aggregate(Arrays.asList(match, project, group), options);\n+    for (String s : groupByField) {\n+      if (s.contains(\".\")) {\n+        aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d -> {\n+          Object o = d.remove(s.replace(\".\", GenericDocumentComplexConverter.TO_REPLACE_DOTS));\n+          d.put(s, o);\n+        });\n+      }\n+    }\n+    return new OpenCGAResult<>(aggregate);\n+  }\n+\n+  /**\n+   * Create a date projection if included in the includeGroupByFields, removes the date fields from includeGroupByFields and\n+   * add them to groupByFields if not there.\n+   * Only for groupBy methods.\n+   *\n+   * @param includeGroupByFields List containing the fields to be included in the projection.\n+   * @param groupByFields        List containing the fields by which the group by will be done.\n+   */\n+  private Document createDateProjection(List<String> includeGroupByFields, List<String> groupByFields) {\n+    Document dateProjection = new Document();\n+    Document year = new Document(\"$year\", \"$\" + PRIVATE_CREATION_DATE);\n+    Document month = new Document(\"$month\", \"$\" + PRIVATE_CREATION_DATE);\n+    Document day = new Document(\"$dayOfMonth\", \"$\" + PRIVATE_CREATION_DATE);\n+\n+    if (includeGroupByFields.contains(\"day\")) {\n+      dateProjection.append(\"day\", day).append(\"month\", month).append(\"year\", year);\n+      includeGroupByFields.remove(\"day\");\n+      if (!includeGroupByFields.remove(\"month\")) {\n+        groupByFields.add(\"month\");\n+      }\n+      if (!includeGroupByFields.remove(\"year\")) {\n+        groupByFields.add(\"year\");\n+      }\n+\n+    } else if (includeGroupByFields.contains(\"month\")) {\n+      dateProjection.append(\"month\", month).append(\"year\", year);\n+      includeGroupByFields.remove(\"month\");\n+      if (!includeGroupByFields.remove(\"year\")) {\n+        groupByFields.add(\"year\");\n+      }\n+    } else if (includeGroupByFields.contains(\"year\")) {\n+      dateProjection.append(\"year\", year);\n+      includeGroupByFields.remove(\"year\");\n+    }\n \n-        return document;\n+    return dateProjection;\n+  }\n+\n+  /**\n+   * Fixes the annotation ids provided by the user to create a proper groupBy by any annotation field provided.\n+   *\n+   * @param includeGroupByFields List containing the fields to be included in the projection.\n+   */\n+  private Document createAnnotationProjectionForGroupBy(List<String> includeGroupByFields) {\n+    Document document = new Document();\n+\n+    Iterator<String> iterator = includeGroupByFields.iterator();\n+    while (iterator.hasNext()) {\n+      String field = iterator.next();\n+\n+      if (field.startsWith(Constants.ANNOTATION)) {\n+        String replacedField = field\n+            .replace(Constants.ANNOTATION + \":\", \"\")\n+            .replace(\":\", INTERNAL_DELIMITER)\n+            .replace(\".\", INTERNAL_DELIMITER);\n+        iterator.remove();\n+\n+        document.put(field, \"$\" + AnnotationMongoDBAdaptor.AnnotationSetParams.ANNOTATION_SETS.key() + \".\" + replacedField);\n+      }\n     }\n \n-    /**\n-     * Generate complex query where [{id - version}, {id2 - version2}] pairs will be queried.\n-     *\n-     * @param query Query object.\n-     * @param bsonQueryList Final bson query object.\n-     * @throws CatalogDBException If the size of the array of ids does not match the size of the array of version.\n-     * @return a boolean indicating whether the complex query was generated or not.\n-     */\n-    boolean generateUidVersionQuery(Query query, List<Bson> bsonQueryList) throws CatalogDBException {\n-        if (!query.containsKey(VERSION) || query.getAsIntegerList(VERSION).size() == 1) {\n-               return false;\n-        }\n-        if (!query.containsKey(PRIVATE_UID) && !query.containsKey(PRIVATE_ID) && !query.containsKey(PRIVATE_UUID)) {\n-            return false;\n-        }\n-        int numIds = 0;\n-        numIds += query.containsKey(PRIVATE_ID) ? 1 : 0;\n-        numIds += query.containsKey(PRIVATE_UID) ? 1 : 0;\n-        numIds += query.containsKey(PRIVATE_UUID) ? 1 : 0;\n-\n-        if (numIds > 1) {\n-            List<Integer> versionList = query.getAsIntegerList(VERSION);\n-            if (versionList.size() > 1) {\n-                throw new CatalogDBException(\"Cannot query by more than one version when more than one id type is being queried\");\n-            }\n-            return false;\n-        }\n+    return document;\n+  }\n+\n+  /**\n+   * Generate complex query where [{id - version}, {id2 - version2}] pairs will be queried.\n+   *\n+   * @param query         Query object.\n+   * @param bsonQueryList Final bson query object.\n+   * @return a boolean indicating whether the complex query was generated or not.\n+   * @throws CatalogDBException If the size of the array of ids does not match the size of the array of version.\n+   */\n+  boolean generateUidVersionQuery(Query query, List<Bson> bsonQueryList) throws CatalogDBException {\n+    if (!query.containsKey(VERSION) || query.getAsIntegerList(VERSION).size() == 1) {\n+      return false;\n+    }\n+    if (!query.containsKey(PRIVATE_UID) && !query.containsKey(PRIVATE_ID) && !query.containsKey(PRIVATE_UUID)) {\n+      return false;\n+    }\n+    int numIds = 0;\n+    numIds += query.containsKey(PRIVATE_ID) ? 1 : 0;\n+    numIds += query.containsKey(PRIVATE_UID) ? 1 : 0;\n+    numIds += query.containsKey(PRIVATE_UUID) ? 1 : 0;\n+\n+    if (numIds > 1) {\n+      List<Integer> versionList = query.getAsIntegerList(VERSION);\n+      if (versionList.size() > 1) {\n+        throw new CatalogDBException(\"Cannot query by more than one version when more than one id type is being queried\");\n+      }\n+      return false;\n+    }\n \n-        String idQueried = PRIVATE_UID;\n-        idQueried = query.containsKey(PRIVATE_ID) ? PRIVATE_ID : idQueried;\n-        idQueried = query.containsKey(PRIVATE_UUID) ? PRIVATE_UUID : idQueried;\n+    String idQueried = PRIVATE_UID;\n+    idQueried = query.containsKey(PRIVATE_ID) ? PRIVATE_ID : idQueried;\n+    idQueried = query.containsKey(PRIVATE_UUID) ? PRIVATE_UUID : idQueried;\n \n-        List idList;\n-        if (PRIVATE_UID.equals(idQueried)) {\n-            idList = query.getAsLongList(PRIVATE_UID);\n-        } else {\n-            idList = query.getAsStringList(idQueried);\n-        }\n-        List<Integer> versionList = query.getAsIntegerList(VERSION);\n+    List idList;\n+    if (PRIVATE_UID.equals(idQueried)) {\n+      idList = query.getAsLongList(PRIVATE_UID);\n+    } else {\n+      idList = query.getAsStringList(idQueried);\n+    }\n+    List<Integer> versionList = query.getAsIntegerList(VERSION);\n \n-        if (versionList.size() > 1 && versionList.size() != idList.size()) {\n-            throw new CatalogDBException(\"The size of the array of versions should match the size of the array of ids to be queried\");\n-        }\n+    if (versionList.size() > 1 && versionList.size() != idList.size()) {\n+      throw new CatalogDBException(\"The size of the array of versions should match the size of the array of ids to be queried\");\n+    }\n \n-        List<Bson> samplesQuery = new ArrayList<>();\n-        for (int i = 0; i < idList.size(); i++) {\n-            samplesQuery.add(new Document()\n-                    .append(idQueried, idList.get(i))\n-                    .append(VERSION, versionList.get(i))\n-            );\n-        }\n+    List<Bson> samplesQuery = new ArrayList<>();\n+    for (int i = 0; i < idList.size(); i++) {\n+      samplesQuery.add(new Document()\n+          .append(idQueried, idList.get(i))\n+          .append(VERSION, versionList.get(i))\n+      );\n+    }\n \n-        if (!samplesQuery.isEmpty()) {\n-            bsonQueryList.add(Filters.or(samplesQuery));\n+    if (!samplesQuery.isEmpty()) {\n+      bsonQueryList.add(Filters.or(samplesQuery));\n \n-            query.remove(idQueried);\n-            query.remove(VERSION);\n+      query.remove(idQueried);\n+      query.remove(VERSION);\n \n-            return true;\n-        }\n+      return true;\n+    }\n \n-        return false;\n-    }\n-\n-    /**\n-     * Removes any other entity projections made. This method should be called by any entity containing inner entities:\n-     * Family -> Individual; Individual -> Sample; File -> Sample; Cohort -> Sample\n-     *\n-     * @param options current query options object.\n-     * @param projectionKey Projection key to be removed from the query options.\n-     * @return new QueryOptions after removing the inner projectionKey projections.\n-     */\n-    protected QueryOptions removeInnerProjections(QueryOptions options, String projectionKey) {\n-        QueryOptions queryOptions = ParamUtils.defaultObject(options, QueryOptions::new);\n-\n-        if (queryOptions.containsKey(QueryOptions.INCLUDE)) {\n-            List<String> includeList = queryOptions.getAsStringList(QueryOptions.INCLUDE);\n-            List<String> newInclude = new ArrayList<>(includeList.size());\n-            boolean projectionKeyExcluded = false;\n-            for (String include : includeList) {\n-                if (!include.startsWith(projectionKey + \".\")) {\n-                    newInclude.add(include);\n-                } else {\n-                    projectionKeyExcluded = true;\n-                }\n-            }\n-            if (newInclude.isEmpty()) {\n-                queryOptions.put(QueryOptions.INCLUDE, Arrays.asList(PRIVATE_ID, projectionKey));\n-            } else {\n-                if (projectionKeyExcluded) {\n-                    newInclude.add(projectionKey);\n-                }\n-                queryOptions.put(QueryOptions.INCLUDE, newInclude);\n-            }\n+    return false;\n+  }\n+\n+  /**\n+   * Removes any other entity projections made. This method should be called by any entity containing inner entities:\n+   * Family -> Individual; Individual -> Sample; File -> Sample; Cohort -> Sample\n+   *\n+   * @param options       current query options object.\n+   * @param projectionKey Projection key to be removed from the query options.\n+   * @return new QueryOptions after removing the inner projectionKey projections.\n+   */\n+  protected QueryOptions removeInnerProjections(QueryOptions options, String projectionKey) {\n+    QueryOptions queryOptions = ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    if (queryOptions.containsKey(QueryOptions.INCLUDE)) {\n+      List<String> includeList = queryOptions.getAsStringList(QueryOptions.INCLUDE);\n+      List<String> newInclude = new ArrayList<>(includeList.size());\n+      boolean projectionKeyExcluded = false;\n+      for (String include : includeList) {\n+        if (!include.startsWith(projectionKey + \".\")) {\n+          newInclude.add(include);\n+        } else {\n+          projectionKeyExcluded = true;\n         }\n-        if (queryOptions.containsKey(QueryOptions.EXCLUDE)) {\n-            List<String> excludeList = queryOptions.getAsStringList(QueryOptions.EXCLUDE);\n-            List<String> newExclude = new ArrayList<>(excludeList.size());\n-            for (String exclude : excludeList) {\n-                if (!exclude.startsWith(projectionKey + \".\")) {\n-                    newExclude.add(exclude);\n-                }\n-            }\n-            if (newExclude.isEmpty()) {\n-                queryOptions.remove(QueryOptions.EXCLUDE);\n-            } else {\n-                queryOptions.put(QueryOptions.EXCLUDE, newExclude);\n-            }\n+      }\n+      if (newInclude.isEmpty()) {\n+        queryOptions.put(QueryOptions.INCLUDE, Arrays.asList(PRIVATE_ID, projectionKey));\n+      } else {\n+        if (projectionKeyExcluded) {\n+          newInclude.add(projectionKey);\n         }\n-\n-        return queryOptions;\n+        queryOptions.put(QueryOptions.INCLUDE, newInclude);\n+      }\n     }\n-\n-    protected OpenCGAResult unmarkPermissionRule(MongoDBCollection collection, long studyId, String permissionRuleId) {\n-        Bson query = new Document()\n-                .append(PRIVATE_STUDY_UID, studyId)\n-                .append(PERMISSION_RULES_APPLIED, permissionRuleId);\n-        Bson update = Updates.pull(PERMISSION_RULES_APPLIED, permissionRuleId);\n-\n-        return new OpenCGAResult(collection.update(query, update, new QueryOptions(\"multi\", true)));\n+    if (queryOptions.containsKey(QueryOptions.EXCLUDE)) {\n+      List<String> excludeList = queryOptions.getAsStringList(QueryOptions.EXCLUDE);\n+      List<String> newExclude = new ArrayList<>(excludeList.size());\n+      for (String exclude : excludeList) {\n+        if (!exclude.startsWith(projectionKey + \".\")) {\n+          newExclude.add(exclude);\n+        }\n+      }\n+      if (newExclude.isEmpty()) {\n+        queryOptions.remove(QueryOptions.EXCLUDE);\n+      } else {\n+        queryOptions.put(QueryOptions.EXCLUDE, newExclude);\n+      }\n     }\n \n-    protected void createNewVersion(ClientSession clientSession, MongoDBCollection dbCollection, Document document)\n-            throws CatalogDBException {\n-        Document updateOldVersion = new Document();\n-\n-        // Current release number\n-        int release;\n-        List<Integer> supportedReleases = (List<Integer>) document.get(RELEASE_FROM_VERSION);\n-        if (supportedReleases.size() > 1) {\n-            release = supportedReleases.get(supportedReleases.size() - 1);\n-\n-            // If it contains several releases, it means this is the first update on the current release, so we just need to take the\n-            // current release number out\n-            supportedReleases.remove(supportedReleases.size() - 1);\n-        } else {\n-            release = supportedReleases.get(0);\n-\n-            // If it is 1, it means that the previous version being checked was made on this same release as well, so it won't be the\n-            // last version of the release\n-            updateOldVersion.put(LAST_OF_RELEASE, false);\n-        }\n-        updateOldVersion.put(RELEASE_FROM_VERSION, supportedReleases);\n-        updateOldVersion.put(LAST_OF_VERSION, false);\n-\n-        // Perform the update on the previous version\n-        Document queryDocument = new Document()\n-                .append(PRIVATE_STUDY_UID, document.getLong(PRIVATE_STUDY_UID))\n-                .append(VERSION, document.getInteger(VERSION))\n-                .append(PRIVATE_UID, document.getLong(PRIVATE_UID));\n-\n-        logger.debug(\"Updating previous version: query : {}, update: {}\",\n-                queryDocument.toBsonDocument(Document.class, MongoClient.getDefaultCodecRegistry()),\n-                updateOldVersion.toBsonDocument(Document.class, MongoClient.getDefaultCodecRegistry()));\n-\n-        DataResult updateResult = dbCollection.update(clientSession, queryDocument, new Document(\"$set\", updateOldVersion), null);\n+    return queryOptions;\n+  }\n+\n+  protected OpenCGAResult unmarkPermissionRule(MongoDBCollection collection, long studyId, String permissionRuleId) {\n+    Bson query = new Document()\n+        .append(PRIVATE_STUDY_UID, studyId)\n+        .append(PERMISSION_RULES_APPLIED, permissionRuleId);\n+    Bson update = Updates.pull(PERMISSION_RULES_APPLIED, permissionRuleId);\n+\n+    return new OpenCGAResult(collection.update(query, update, new QueryOptions(\"multi\", true)));\n+  }\n+\n+  protected void createNewVersion(ClientSession clientSession, MongoDBCollection dbCollection, Document document)\n+      throws CatalogDBException {\n+    Document updateOldVersion = new Document();\n+\n+    // Current release number\n+    int release;\n+    List<Integer> supportedReleases = (List<Integer>) document.get(RELEASE_FROM_VERSION);\n+    if (supportedReleases.size() > 1) {\n+      release = supportedReleases.get(supportedReleases.size() - 1);\n+\n+      // If it contains several releases, it means this is the first update on the current release, so we just need to take the\n+      // current release number out\n+      supportedReleases.remove(supportedReleases.size() - 1);\n+    } else {\n+      release = supportedReleases.get(0);\n+\n+      // If it is 1, it means that the previous version being checked was made on this same release as well, so it won't be the\n+      // last version of the release\n+      updateOldVersion.put(LAST_OF_RELEASE, false);\n+    }\n+    updateOldVersion.put(RELEASE_FROM_VERSION, supportedReleases);\n+    updateOldVersion.put(LAST_OF_VERSION, false);\n \n-        if (updateResult.getNumUpdated() == 0) {\n-            throw new CatalogDBException(\"Internal error: Could not update previous version\");\n-        }\n+    // Perform the update on the previous version\n+    Document queryDocument = new Document()\n+        .append(PRIVATE_STUDY_UID, document.getLong(PRIVATE_STUDY_UID))\n+        .append(VERSION, document.getInteger(VERSION))\n+        .append(PRIVATE_UID, document.getLong(PRIVATE_UID));\n \n-        // We update the information for the new version of the document\n-        document.put(LAST_OF_RELEASE, true);\n-        document.put(LAST_OF_VERSION, true);\n-        document.put(RELEASE_FROM_VERSION, Arrays.asList(release));\n-        document.put(VERSION, document.getInteger(VERSION) + 1);\n+    logger.debug(\"Updating previous version: query : {}, update: {}\",\n+        queryDocument.toBsonDocument(Document.class, MongoClient.getDefaultCodecRegistry()),\n+        updateOldVersion.toBsonDocument(Document.class, MongoClient.getDefaultCodecRegistry()));\n \n-        logger.debug(\"Inserting new document version: document: {}\",\n-                document.toBsonDocument(Document.class, MongoClient.getDefaultCodecRegistry()));\n+    DataResult updateResult = dbCollection.update(clientSession, queryDocument, new Document(\"$set\", updateOldVersion), null);\n \n-        // Insert the new version document\n-        dbCollection.insert(clientSession, document, QueryOptions.empty());\n+    if (updateResult.getNumUpdated() == 0) {\n+      throw new CatalogDBException(\"Internal error: Could not update previous version\");\n     }\n \n-    protected Document getStudyDocument(ClientSession clientSession, long studyUid) throws CatalogDBException {\n-        // Get the study document\n-        Query studyQuery = new Query(StudyDBAdaptor.QueryParams.UID.key(), studyUid);\n-        DataResult<Document> dataResult = dbAdaptorFactory.getCatalogStudyDBAdaptor().nativeGet(clientSession, studyQuery,\n-                QueryOptions.empty());\n-        if (dataResult.getNumResults() == 0) {\n-            throw new CatalogDBException(\"Study \" + studyUid + \" not found\");\n-        }\n-        return dataResult.first();\n+    // We update the information for the new version of the document\n+    document.put(LAST_OF_RELEASE, true);\n+    document.put(LAST_OF_VERSION, true);\n+    document.put(RELEASE_FROM_VERSION, Arrays.asList(release));\n+    document.put(VERSION, document.getInteger(VERSION) + 1);\n+\n+    logger.debug(\"Inserting new document version: document: {}\",\n+        document.toBsonDocument(Document.class, MongoClient.getDefaultCodecRegistry()));\n+\n+    // Insert the new version document\n+    dbCollection.insert(clientSession, document, QueryOptions.empty());\n+  }\n+\n+  protected Document getStudyDocument(ClientSession clientSession, long studyUid) throws CatalogDBException {\n+    // Get the study document\n+    Query studyQuery = new Query(StudyDBAdaptor.QueryParams.UID.key(), studyUid);\n+    DataResult<Document> dataResult = dbAdaptorFactory.getCatalogStudyDBAdaptor().nativeGet(clientSession, studyQuery,\n+        QueryOptions.empty());\n+    if (dataResult.getNumResults() == 0) {\n+      throw new CatalogDBException(\"Study \" + studyUid + \" not found\");\n+    }\n+    return dataResult.first();\n+  }\n+\n+  public class UpdateDocument {\n+    private Document set;\n+    private Document addToSet;\n+    private Document push;\n+    private Document pull;\n+    private Document pullAll;\n+\n+    private ObjectMap attributes;\n+\n+    public UpdateDocument() {\n+      this.set = new Document();\n+      this.addToSet = new Document();\n+      this.push = new Document();\n+      this.pull = new Document();\n+      this.pullAll = new Document();\n+      this.attributes = new ObjectMap();\n     }\n \n-    public class UpdateDocument {\n-        private Document set;\n-        private Document addToSet;\n-        private Document push;\n-        private Document pull;\n-        private Document pullAll;\n-\n-        private ObjectMap attributes;\n-\n-        public UpdateDocument() {\n-            this.set = new Document();\n-            this.addToSet = new Document();\n-            this.push = new Document();\n-            this.pull = new Document();\n-            this.pullAll = new Document();\n-            this.attributes = new ObjectMap();\n-        }\n-\n-        public Document toFinalUpdateDocument() {\n-            Document update = new Document();\n-            if (!set.isEmpty()) {\n-                update.put(\"$set\", set);\n-            }\n-            if (!addToSet.isEmpty()) {\n-                for (Map.Entry<String, Object> entry : addToSet.entrySet()) {\n-                    if (entry.getValue() instanceof Collection) {\n-                        // We need to add all the elements of the array\n-                        entry.setValue(new Document(\"$each\", entry.getValue()));\n-                    }\n-                }\n-                update.put(\"$addToSet\", addToSet);\n-            }\n-            if (!push.isEmpty()) {\n-                for (Map.Entry<String, Object> entry : push.entrySet()) {\n-                    if (entry.getValue() instanceof Collection) {\n-                        // We need to add all the elements of the array\n-                        entry.setValue(new Document(\"$each\", entry.getValue()));\n-                    }\n-                }\n-                update.put(\"$push\", push);\n-            }\n-            if (!pull.isEmpty()) {\n-                for (Map.Entry<String, Object> entry : pull.entrySet()) {\n-                    if (entry.getValue() instanceof Collection) {\n-                        // We need to pull all the elements of the array\n-                        entry.setValue(new Document(\"$in\", entry.getValue()));\n-                    }\n-                }\n-                update.put(\"$pull\", pull);\n-            }\n-            if (!pullAll.isEmpty()) {\n-                update.put(\"$pullAll\", pullAll);\n-            }\n-\n-            return update;\n-        }\n+    public Document toFinalUpdateDocument() {\n+      Document update = new Document();\n+      if (!set.isEmpty()) {\n+        update.put(\"$set\", set);\n+      }\n+      if (!addToSet.isEmpty()) {\n+        for (Map.Entry<String, Object> entry : addToSet.entrySet()) {\n+          if (entry.getValue() instanceof Collection) {\n+            // We need to add all the elements of the array\n+            entry.setValue(new Document(\"$each\", entry.getValue()));\n+          }\n+        }\n+        update.put(\"$addToSet\", addToSet);\n+      }\n+      if (!push.isEmpty()) {\n+        for (Map.Entry<String, Object> entry : push.entrySet()) {\n+          if (entry.getValue() instanceof Collection) {\n+            // We need to add all the elements of the array\n+            entry.setValue(new Document(\"$each\", entry.getValue()));\n+          }\n+        }\n+        update.put(\"$push\", push);\n+      }\n+      if (!pull.isEmpty()) {\n+        for (Map.Entry<String, Object> entry : pull.entrySet()) {\n+          if (entry.getValue() instanceof Collection) {\n+            // We need to pull all the elements of the array\n+            entry.setValue(new Document(\"$in\", entry.getValue()));\n+          }\n+        }\n+        update.put(\"$pull\", pull);\n+      }\n+      if (!pullAll.isEmpty()) {\n+        update.put(\"$pullAll\", pullAll);\n+      }\n+\n+      return update;\n+    }\n \n-        public Document getSet() {\n-            return set;\n-        }\n+    public Document getSet() {\n+      return set;\n+    }\n \n-        public UpdateDocument setSet(Document set) {\n-            this.set = set;\n-            return this;\n-        }\n+    public UpdateDocument setSet(Document set) {\n+      this.set = set;\n+      return this;\n+    }\n \n-        public Document getAddToSet() {\n-            return addToSet;\n-        }\n+    public Document getAddToSet() {\n+      return addToSet;\n+    }\n \n-        public UpdateDocument setAddToSet(Document addToSet) {\n-            this.addToSet = addToSet;\n-            return this;\n-        }\n+    public UpdateDocument setAddToSet(Document addToSet) {\n+      this.addToSet = addToSet;\n+      return this;\n+    }\n \n-        public Document getPush() {\n-            return push;\n-        }\n+    public Document getPush() {\n+      return push;\n+    }\n \n-        public UpdateDocument setPush(Document push) {\n-            this.push = push;\n-            return this;\n-        }\n+    public UpdateDocument setPush(Document push) {\n+      this.push = push;\n+      return this;\n+    }\n \n-        public Document getPull() {\n-            return pull;\n-        }\n+    public Document getPull() {\n+      return pull;\n+    }\n \n-        public UpdateDocument setPull(Document pull) {\n-            this.pull = pull;\n-            return this;\n-        }\n+    public UpdateDocument setPull(Document pull) {\n+      this.pull = pull;\n+      return this;\n+    }\n \n-        public Document getPullAll() {\n-            return pullAll;\n-        }\n+    public Document getPullAll() {\n+      return pullAll;\n+    }\n \n-        public UpdateDocument setPullAll(Document pullAll) {\n-            this.pullAll = pullAll;\n-            return this;\n-        }\n+    public UpdateDocument setPullAll(Document pullAll) {\n+      this.pullAll = pullAll;\n+      return this;\n+    }\n \n-        public ObjectMap getAttributes() {\n-            return attributes;\n-        }\n+    public ObjectMap getAttributes() {\n+      return attributes;\n+    }\n \n-        public UpdateDocument setAttributes(ObjectMap attributes) {\n-            this.attributes = attributes;\n-            return this;\n-        }\n+    public UpdateDocument setAttributes(ObjectMap attributes) {\n+      this.attributes = attributes;\n+      return this;\n     }\n+  }\n \n }\n",
            "diff_size": 690
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "178",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 214).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/406/MongoDBAdaptor.java\nindex a64e27fac31..fc58d60be20 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/406/MongoDBAdaptor.java\n@@ -175,8 +175,7 @@ public class MongoDBAdaptor extends AbstractDBAdaptor {\n         }\n     }\n \n-    protected void addQueryFilter(String mongoDbField, String queryParam, Query query, QueryParam.Type paramType,\n-                                  MongoDBQueryUtils.ComparisonOperator comparisonOperator, MongoDBQueryUtils.LogicalOperator operator,\n+    protected void addQueryFilter(String mongoDbField, String queryParam, Query query, QueryParam.Type paramType, MongoDBQueryUtils.ComparisonOperator comparisonOperator, MongoDBQueryUtils.LogicalOperator operator,\n                                   List<Bson> andBsonList) {\n         if (query != null && query.getString(queryParam) != null) {\n             Bson filter = MongoDBQueryUtils.createFilter(mongoDbField, queryParam, query, paramType, comparisonOperator, operator);\n@@ -188,7 +187,7 @@ public class MongoDBAdaptor extends AbstractDBAdaptor {\n \n     protected OpenCGAResult rank(MongoDBCollection collection, Bson query, String groupByField, String idField, int numResults,\n                                  boolean asc) {\n-        if (groupByField == null || groupByField.isEmpty()) {\n+    if (groupByField == null || groupByField.isEmpty()) {\n             return new OpenCGAResult();\n         }\n \n@@ -213,8 +212,7 @@ public class MongoDBAdaptor extends AbstractDBAdaptor {\n \n     protected OpenCGAResult rank(MongoDBCollection collection, Bson query, List<String> groupByField, String idField, int numResults,\n                                boolean asc) {\n-\n-        if (groupByField == null || groupByField.isEmpty()) {\n+    if (groupByField == null || groupByField.isEmpty()) {\n             return new OpenCGAResult();\n         }\n \n@@ -296,7 +294,7 @@ public class MongoDBAdaptor extends AbstractDBAdaptor {\n         DataResult<Document> aggregate = collection.aggregate(Arrays.asList(match, project, group), options);\n         for (String s : groupByField) {\n             if (s.contains(\".\")) {\n-                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d->{\n+                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d-> {\n                     Object o = d.remove(s.replace(\".\", GenericDocumentComplexConverter.TO_REPLACE_DOTS));\n                     d.put(s, o);\n                 });\n@@ -666,4 +664,4 @@ public class MongoDBAdaptor extends AbstractDBAdaptor {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/406/MongoDBAdaptor.java\nindex a64e27fac31..6f72e8b7fdb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/406/MongoDBAdaptor.java\n@@ -296,7 +296,7 @@ public class MongoDBAdaptor extends AbstractDBAdaptor {\n         DataResult<Document> aggregate = collection.aggregate(Arrays.asList(match, project, group), options);\n         for (String s : groupByField) {\n             if (s.contains(\".\")) {\n-                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d->{\n+                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d-> {\n                     Object o = d.remove(s.replace(\".\", GenericDocumentComplexConverter.TO_REPLACE_DOTS));\n                     d.put(s, o);\n                 });\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/406/MongoDBAdaptor.java\nindex a64e27fac31..6f72e8b7fdb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/406/MongoDBAdaptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/406/MongoDBAdaptor.java\n@@ -296,7 +296,7 @@ public class MongoDBAdaptor extends AbstractDBAdaptor {\n         DataResult<Document> aggregate = collection.aggregate(Arrays.asList(match, project, group), options);\n         for (String s : groupByField) {\n             if (s.contains(\".\")) {\n-                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d->{\n+                aggregate.getResults().stream().map(d -> d.get(\"_id\", Document.class)).forEach(d-> {\n                     Object o = d.remove(s.replace(\".\", GenericDocumentComplexConverter.TO_REPLACE_DOTS));\n                     d.put(s, o);\n                 });\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}