{
    "project_name": "blockchain-lab-ScaleOutDistributedLedger",
    "error_id": "23",
    "information": {
        "errors": [
            {
                "line": "62",
                "column": "33",
                "severity": "warning",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "\n\t\tList<Block> currentDecodedBlockList = new ArrayList<>();\n\t\tif (senderChain != null){\n\t\t\t// Start from the last block\n\t\t\tBlockMessage lastBlockMessage = senderChain.get(senderChain.size() - 1);\n\t\t\t// Recursively decode the transaction and chainUpdates",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/23/Proof.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler/23/Proof.java\nindex 2cc2c720086..2dc8def7823 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/23/Proof.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler/23/Proof.java\n@@ -59,7 +59,7 @@ public class Proof {\n \t\tList<BlockMessage> senderChain = proofMessage.getChainUpdates().get(senderNode.getId());\n \n \t\tList<Block> currentDecodedBlockList = new ArrayList<>();\n-\t\tif (senderChain != null){\n+\t\tif (senderChain != null) {\n \t\t\t// Start from the last block\n \t\t\tBlockMessage lastBlockMessage = senderChain.get(senderChain.size() - 1);\n \t\t\t// Recursively decode the transaction and chainUpdates\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/23/Proof.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/intellij/23/Proof.java\nindex 2cc2c720086..82d4c7e714f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/23/Proof.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/intellij/23/Proof.java\n@@ -21,268 +21,285 @@ import java.util.Set;\n  */\n public class Proof {\n \n-\t@Getter\n-\tprivate final Transaction transaction;\n-\n-\t@Getter\n-\tprivate final Map<Node, List<Block>> chainUpdates;\n-\n-\t/**\n-\t * Constructor.\n-\t * @param transaction - the transaction to be proven.\n-\t */\n-\tpublic Proof(Transaction transaction) {\n-\t\tthis.transaction = transaction;\n-\t\tthis.chainUpdates = new HashMap<>();\n-\t}\n-\t\n-\t/**\n-\t * Constructor.\n-\t * @param transaction  - the transaction to be proven.\n-\t * @param chainUpdates - a map of chain updates\n-\t */\n-\tpublic Proof(Transaction transaction, Map<Node, List<Block>> chainUpdates) {\n-\t\tthis.transaction = transaction;\n-\t\tthis.chainUpdates = chainUpdates;\n-\t}\n-\t\n-\t/**\n-\t * Constructor to decode a proof message.\n-\t * @param proofMessage - proof received from the network\n-\t * @param localStore - local store\n-\t * @throws IOException - error while getting node info from tracker\n-\t */\n-\tpublic Proof(ProofMessage proofMessage, LocalStore localStore) throws IOException {\n-\t\tthis.chainUpdates = new HashMap<>();\n-\t\t// Start by decoding the chain of the sender\n-\t\tNode senderNode = localStore.getNode(proofMessage.getTransactionMessage().getSenderId());\n-\t\tList<BlockMessage> senderChain = proofMessage.getChainUpdates().get(senderNode.getId());\n-\n-\t\tList<Block> currentDecodedBlockList = new ArrayList<>();\n-\t\tif (senderChain != null){\n-\t\t\t// Start from the last block\n-\t\t\tBlockMessage lastBlockMessage = senderChain.get(senderChain.size() - 1);\n-\t\t\t// Recursively decode the transaction and chainUpdates\n-\t\t\tBlock lastBlock = new Block(lastBlockMessage, proofMessage.getChainUpdates(), this.chainUpdates, localStore);\n-\t\t\tif (this.chainUpdates.containsKey(senderNode)) {\n-\t\t\t\t// Add to already created list of blocks\n-\t\t\t\tcurrentDecodedBlockList = this.chainUpdates.get(senderNode);\n-\t\t\t\tcurrentDecodedBlockList.add(lastBlock);\n-\t\t\t} else {\n-\t\t\t\t// Create new list of blocks\n-\t\t\t\tcurrentDecodedBlockList.add(lastBlock);\n-\t\t\t\tthis.chainUpdates.put(senderNode, currentDecodedBlockList);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Set the transaction from the decoded chain\n-\t\t// TODO [possible improvement]: is the transaction always in the last block ?\n-\t\tTransaction foundTransaction = null;\n-\t\t\n-\t\tChainView cv = new ChainView(senderNode.getChain(), currentDecodedBlockList);\n-\t\tBlock block = cv.getBlock(proofMessage.getTransactionMessage().getBlockNumber());\n-\t\tfor (Transaction transactionAux : block.getTransactions()) {\n-\t\t\tif (transactionAux.getNumber() == proofMessage.getTransactionMessage().getNumber()) {\n-\t\t\t\tfoundTransaction = transactionAux;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\tthis.transaction = foundTransaction;\n-\t}\n-\t\n-\t/**\n-\t * Add a block to the proof.\n-\t * @param block - the block to be added\n-\t */\n-\tpublic void addBlock(Block block) {\n-\t\tList<Block> blocks = chainUpdates.computeIfAbsent(block.getOwner(), k -> new ArrayList<>());\n-\t\tblocks.add(block);\n-\t}\n-\t\n-\t/**\n-\t * Adds the blocks with numbers start to end of the given chain to the proof.\n-\t * @param chain - the chain\n-\t * @param start - the block to start at (inclusive)\n-\t * @param end   - the block to end at (exclusive)\n-\t */\n-\tpublic void addBlocksOfChain(Chain chain, int start, int end) {\n-\t\tif (start >= end || end > chain.getBlocks().size()) return;\n-\t\t\n-\t\tList<Block> blocks = chainUpdates.get(chain.getOwner());\n-\t\tif (blocks == null) {\n-\t\t\tblocks = new ArrayList<>();\n-\t\t\tchainUpdates.put(chain.getOwner(), blocks);\n-\t\t}\n-\t\tblocks.addAll(chain.getBlocks().subList(start, end));\n-\t}\n-\n-\t/**\n-\t * Verifies this proof.\n-\t * @param localStore - the local store\n-\t * @throws ProofValidationException - If this proof is invalid.\n-\t */\n-\tpublic void verify(LocalStore localStore) throws ProofValidationException {\n-\t\tif (this.transaction.getSender() == null) {\n-\t\t\tthrow new ProofValidationException(\"We directly received a transaction with a null sender.\");\n-\t\t}\n-\t\t\n-\t\tverify(this.transaction, localStore);\n-\t}\n-\n-\t/**\n-\t * Verifies the given transaction using this proof.\n-\t * @param transaction - the transaction to verify\n-\t * @throws ProofValidationException - If the proof is invalid.\n-\t */\n-\tprivate void verify(Transaction transaction, LocalStore localStore) throws ProofValidationException {\n-\t\tint blockNumber = transaction.getBlockNumber().orElse(-1);\n-\t\tif (blockNumber == -1) {\n-\t\t\tthrow new ProofValidationException(\"The transaction has no block number, so we cannot validate it.\");\n-\t\t}\n-\t\t\n-\t\tif (transaction.getSender() == null) {\n-\t\t\tverifyGenesisTransaction(transaction, localStore);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tint absmark = 0;\n-\t\tboolean seen = false;\n-\n-\t\t//TODO [PERFORMANCE]: We check the same chain views multiple times, even though we don't have to.\n-\t\tChainView chainView = getChainView(transaction.getSender());\n-\t\tif (!chainView.isValid()) {\n-\t\t\tthrow new ProofValidationException(\"ChainView of node \" + transaction.getSender().getId() + \" is invalid.\");\n-\t\t}\n-\n-\t\tfor (Block block : chainView) {\n-\t\t\tif (block.getTransactions().contains(transaction)) {\n-\t\t\t\tif (seen) {\n-\t\t\t\t\tthrow new ProofValidationException(\"Duplicate transaction found.\");\n-\t\t\t\t}\n-\t\t\t\tseen = true;\n-\t\t\t}\n-\t\t\tif (block.isOnMainChain(localStore)) absmark = block.getNumber();\n-\t\t}\n-\n-\t\tif (absmark < blockNumber) {\n-\t\t\tthrow new ProofValidationException(\"No suitable committed block found\");\n-\t\t}\n-\n-\t\t// Verify source transaction\n-\t\tfor (Transaction sourceTransaction : transaction.getSource()) {\n-\t\t\ttry {\n-\t\t\t\tverify(sourceTransaction, localStore);\n-\t\t\t} catch (ValidationException ex) {\n-\t\t\t\tthrow new ProofValidationException(\"Source \" + sourceTransaction + \" is not valid\", ex);\n-\t\t\t}\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Verifies a genesis transaction.\n-\t * @param transaction - the genesis transaction\n-\t * @param localStore  - the local store\n-\t * @throws ProofValidationException - If the given transaction is not a valid genesis transaction.\n-\t */\n-\tprivate void verifyGenesisTransaction(Transaction transaction, LocalStore localStore) throws ProofValidationException {\n-\t\tint blockNumber = transaction.getBlockNumber().orElse(-1);\n-\t\tif (blockNumber != 0) {\n-\t\t\tthrow new ProofValidationException(\"Genesis transaction \" + transaction + \" is invalid: block number is not 0\");\n-\t\t}\n-\t\t\n-\t\tNode receiver = transaction.getReceiver();\n-\t\tChainView chainView = getChainView(receiver);\n-\t\tBlock genesisBlock;\n-\t\ttry {\n-\t\t\tgenesisBlock = chainView.getBlock(0);\n-\t\t} catch (IndexOutOfBoundsException ex) {\n-\t\t\tthrow new ProofValidationException(\"The genesis block for node \" + receiver.getId() + \" cannot be found!\");\n-\t\t} catch (IllegalStateException ex) {\n-\t\t\tthrow new ProofValidationException(\"ChainView of node \" + receiver.getId() + \" is invalid.\");\n-\t\t}\n-\t\t\n-\t\tif (!genesisBlock.isOnMainChain(localStore)) {\n-\t\t\tthrow new ProofValidationException(\"The genesis block of node \" + receiver.getId() + \" is not on the main chain.\");\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * @param node - the node\n-\t * @return - a chainview for the specified node\n-\t */\n-\tpublic ChainView getChainView(Node node) {\n-\t\treturn new ChainView(node.getChain(), chainUpdates.get(node));\n-\t}\n-\t\n-\t/**\n-\t * Applies the updates in this proof.\n-\t * This method also updates the meta knowledge of the sender of the transaction.\n-\t */\n-\tpublic void applyUpdates() {\n-\t\tfor (Entry<Node, List<Block>> entry : chainUpdates.entrySet()) {\n-\t\t\tNode node = entry.getKey();\n-\t\t\t\n-\t\t\tList<Block> updates = entry.getValue();\n-\t\t\tnode.getChain().update(updates);\n-\t\t}\n-\t\t\n-\t\t//Update the meta knowledge of the sender\n-\t\ttransaction.getSender().updateMetaKnowledge(this);\n-\t}\n-\t\n-\t/**\n-\t * @param transaction - the transaction\n-\t * @return the proof for the given transaction\n-\t */\n-\tpublic static Proof createProof(Transaction transaction) {\n-\t\tNode receiver = transaction.getReceiver();\n-\t\tProof proof = new Proof(transaction);\n-\t\t\n-\t\t//Step 1: determine the chains that need to be sent\n-\t\t//TODO We might want to do some kind of caching?\n-\t\tSet<Chain> chains = new HashSet<>();\n-\t\tappendChains(transaction, receiver, chains);\n-\t\t\n-\t\t//Step 2: add only those blocks that are not yet known\n-\t\tMap<Node, Integer> metaKnowledge = receiver.getMetaKnowledge();\n-\t\tfor (Chain chain : chains) {\n-\t\t\tNode owner = chain.getOwner();\n-\t\t\tif (owner == receiver) continue;\n-\t\t\t\n-\t\t\tint alreadyKnown = metaKnowledge.getOrDefault(owner, -1);\n-\t\t\tint requiredKnown = chain.getLastCommittedBlock().getNumber();\n-\t\t\t\n-\t\t\tproof.addBlocksOfChain(chain, alreadyKnown + 1, requiredKnown + 1);\n-\t\t}\n-\t\t\n-\t\treturn proof;\n-\t}\n-\t\n-\t/**\n-\t * Recursively calls itself with all the sources of the given transaction. Transactions which\n-\t * are in the chain of {@code receiver} are ignored.\n-\t * @param transaction - the transaction to check the sources of\n-\t * @param receiver    - the node receiving the transaction\n-\t * @param chains      - the list of chains to append to\n-\t */\n-\tpublic static void appendChains(Transaction transaction, Node receiver, Set<Chain> chains) {\n-\t\tNode owner = transaction.getSender();\n-\t\tif (owner == null || owner == receiver) return;\n-\t\t\n-\t\tchains.add(owner.getChain());\n-\t\tfor (Transaction source : transaction.getSource()) {\n-\t\t\tappendChains(source, receiver, chains);\n-\t\t}\n-\t}\n-\t\n-\t@Override\n-\tpublic String toString() {\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\tsb.append(\"Proof: \").append(transaction);\n-\t\t\n-\t\tfor (Entry<Node, List<Block>> entry : this.chainUpdates.entrySet()) {\n-\t\t\tsb.append('\\n').append(entry.getKey().getId()).append(\": \").append(entry.getValue());\n-\t\t}\n-\t\treturn sb.toString();\n-\t}\n+    @Getter\n+    private final Transaction transaction;\n+\n+    @Getter\n+    private final Map<Node, List<Block>> chainUpdates;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param transaction - the transaction to be proven.\n+     */\n+    public Proof(Transaction transaction) {\n+        this.transaction = transaction;\n+        this.chainUpdates = new HashMap<>();\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param transaction  - the transaction to be proven.\n+     * @param chainUpdates - a map of chain updates\n+     */\n+    public Proof(Transaction transaction, Map<Node, List<Block>> chainUpdates) {\n+        this.transaction = transaction;\n+        this.chainUpdates = chainUpdates;\n+    }\n+\n+    /**\n+     * Constructor to decode a proof message.\n+     *\n+     * @param proofMessage - proof received from the network\n+     * @param localStore   - local store\n+     * @throws IOException - error while getting node info from tracker\n+     */\n+    public Proof(ProofMessage proofMessage, LocalStore localStore) throws IOException {\n+        this.chainUpdates = new HashMap<>();\n+        // Start by decoding the chain of the sender\n+        Node senderNode = localStore.getNode(proofMessage.getTransactionMessage().getSenderId());\n+        List<BlockMessage> senderChain = proofMessage.getChainUpdates().get(senderNode.getId());\n+\n+        List<Block> currentDecodedBlockList = new ArrayList<>();\n+        if (senderChain != null) {\n+            // Start from the last block\n+            BlockMessage lastBlockMessage = senderChain.get(senderChain.size() - 1);\n+            // Recursively decode the transaction and chainUpdates\n+            Block lastBlock = new Block(lastBlockMessage, proofMessage.getChainUpdates(), this.chainUpdates, localStore);\n+            if (this.chainUpdates.containsKey(senderNode)) {\n+                // Add to already created list of blocks\n+                currentDecodedBlockList = this.chainUpdates.get(senderNode);\n+                currentDecodedBlockList.add(lastBlock);\n+            } else {\n+                // Create new list of blocks\n+                currentDecodedBlockList.add(lastBlock);\n+                this.chainUpdates.put(senderNode, currentDecodedBlockList);\n+            }\n+        }\n+\n+        // Set the transaction from the decoded chain\n+        // TODO [possible improvement]: is the transaction always in the last block ?\n+        Transaction foundTransaction = null;\n+\n+        ChainView cv = new ChainView(senderNode.getChain(), currentDecodedBlockList);\n+        Block block = cv.getBlock(proofMessage.getTransactionMessage().getBlockNumber());\n+        for (Transaction transactionAux : block.getTransactions()) {\n+            if (transactionAux.getNumber() == proofMessage.getTransactionMessage().getNumber()) {\n+                foundTransaction = transactionAux;\n+                break;\n+            }\n+        }\n+        this.transaction = foundTransaction;\n+    }\n+\n+    /**\n+     * Add a block to the proof.\n+     *\n+     * @param block - the block to be added\n+     */\n+    public void addBlock(Block block) {\n+        List<Block> blocks = chainUpdates.computeIfAbsent(block.getOwner(), k -> new ArrayList<>());\n+        blocks.add(block);\n+    }\n+\n+    /**\n+     * Adds the blocks with numbers start to end of the given chain to the proof.\n+     *\n+     * @param chain - the chain\n+     * @param start - the block to start at (inclusive)\n+     * @param end   - the block to end at (exclusive)\n+     */\n+    public void addBlocksOfChain(Chain chain, int start, int end) {\n+        if (start >= end || end > chain.getBlocks().size()) {\n+            return;\n+        }\n+\n+        List<Block> blocks = chainUpdates.get(chain.getOwner());\n+        if (blocks == null) {\n+            blocks = new ArrayList<>();\n+            chainUpdates.put(chain.getOwner(), blocks);\n+        }\n+        blocks.addAll(chain.getBlocks().subList(start, end));\n+    }\n+\n+    /**\n+     * Verifies this proof.\n+     *\n+     * @param localStore - the local store\n+     * @throws ProofValidationException - If this proof is invalid.\n+     */\n+    public void verify(LocalStore localStore) throws ProofValidationException {\n+        if (this.transaction.getSender() == null) {\n+            throw new ProofValidationException(\"We directly received a transaction with a null sender.\");\n+        }\n+\n+        verify(this.transaction, localStore);\n+    }\n+\n+    /**\n+     * Verifies the given transaction using this proof.\n+     *\n+     * @param transaction - the transaction to verify\n+     * @throws ProofValidationException - If the proof is invalid.\n+     */\n+    private void verify(Transaction transaction, LocalStore localStore) throws ProofValidationException {\n+        int blockNumber = transaction.getBlockNumber().orElse(-1);\n+        if (blockNumber == -1) {\n+            throw new ProofValidationException(\"The transaction has no block number, so we cannot validate it.\");\n+        }\n+\n+        if (transaction.getSender() == null) {\n+            verifyGenesisTransaction(transaction, localStore);\n+            return;\n+        }\n+\n+        int absmark = 0;\n+        boolean seen = false;\n+\n+        //TODO [PERFORMANCE]: We check the same chain views multiple times, even though we don't have to.\n+        ChainView chainView = getChainView(transaction.getSender());\n+        if (!chainView.isValid()) {\n+            throw new ProofValidationException(\"ChainView of node \" + transaction.getSender().getId() + \" is invalid.\");\n+        }\n+\n+        for (Block block : chainView) {\n+            if (block.getTransactions().contains(transaction)) {\n+                if (seen) {\n+                    throw new ProofValidationException(\"Duplicate transaction found.\");\n+                }\n+                seen = true;\n+            }\n+            if (block.isOnMainChain(localStore)) {\n+                absmark = block.getNumber();\n+            }\n+        }\n+\n+        if (absmark < blockNumber) {\n+            throw new ProofValidationException(\"No suitable committed block found\");\n+        }\n+\n+        // Verify source transaction\n+        for (Transaction sourceTransaction : transaction.getSource()) {\n+            try {\n+                verify(sourceTransaction, localStore);\n+            } catch (ValidationException ex) {\n+                throw new ProofValidationException(\"Source \" + sourceTransaction + \" is not valid\", ex);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Verifies a genesis transaction.\n+     *\n+     * @param transaction - the genesis transaction\n+     * @param localStore  - the local store\n+     * @throws ProofValidationException - If the given transaction is not a valid genesis transaction.\n+     */\n+    private void verifyGenesisTransaction(Transaction transaction, LocalStore localStore) throws ProofValidationException {\n+        int blockNumber = transaction.getBlockNumber().orElse(-1);\n+        if (blockNumber != 0) {\n+            throw new ProofValidationException(\"Genesis transaction \" + transaction + \" is invalid: block number is not 0\");\n+        }\n+\n+        Node receiver = transaction.getReceiver();\n+        ChainView chainView = getChainView(receiver);\n+        Block genesisBlock;\n+        try {\n+            genesisBlock = chainView.getBlock(0);\n+        } catch (IndexOutOfBoundsException ex) {\n+            throw new ProofValidationException(\"The genesis block for node \" + receiver.getId() + \" cannot be found!\");\n+        } catch (IllegalStateException ex) {\n+            throw new ProofValidationException(\"ChainView of node \" + receiver.getId() + \" is invalid.\");\n+        }\n+\n+        if (!genesisBlock.isOnMainChain(localStore)) {\n+            throw new ProofValidationException(\"The genesis block of node \" + receiver.getId() + \" is not on the main chain.\");\n+        }\n+    }\n+\n+    /**\n+     * @param node - the node\n+     * @return - a chainview for the specified node\n+     */\n+    public ChainView getChainView(Node node) {\n+        return new ChainView(node.getChain(), chainUpdates.get(node));\n+    }\n+\n+    /**\n+     * Applies the updates in this proof.\n+     * This method also updates the meta knowledge of the sender of the transaction.\n+     */\n+    public void applyUpdates() {\n+        for (Entry<Node, List<Block>> entry : chainUpdates.entrySet()) {\n+            Node node = entry.getKey();\n+\n+            List<Block> updates = entry.getValue();\n+            node.getChain().update(updates);\n+        }\n+\n+        //Update the meta knowledge of the sender\n+        transaction.getSender().updateMetaKnowledge(this);\n+    }\n+\n+    /**\n+     * @param transaction - the transaction\n+     * @return the proof for the given transaction\n+     */\n+    public static Proof createProof(Transaction transaction) {\n+        Node receiver = transaction.getReceiver();\n+        Proof proof = new Proof(transaction);\n+\n+        //Step 1: determine the chains that need to be sent\n+        //TODO We might want to do some kind of caching?\n+        Set<Chain> chains = new HashSet<>();\n+        appendChains(transaction, receiver, chains);\n+\n+        //Step 2: add only those blocks that are not yet known\n+        Map<Node, Integer> metaKnowledge = receiver.getMetaKnowledge();\n+        for (Chain chain : chains) {\n+            Node owner = chain.getOwner();\n+            if (owner == receiver) {\n+                continue;\n+            }\n+\n+            int alreadyKnown = metaKnowledge.getOrDefault(owner, -1);\n+            int requiredKnown = chain.getLastCommittedBlock().getNumber();\n+\n+            proof.addBlocksOfChain(chain, alreadyKnown + 1, requiredKnown + 1);\n+        }\n+\n+        return proof;\n+    }\n+\n+    /**\n+     * Recursively calls itself with all the sources of the given transaction. Transactions which\n+     * are in the chain of {@code receiver} are ignored.\n+     *\n+     * @param transaction - the transaction to check the sources of\n+     * @param receiver    - the node receiving the transaction\n+     * @param chains      - the list of chains to append to\n+     */\n+    public static void appendChains(Transaction transaction, Node receiver, Set<Chain> chains) {\n+        Node owner = transaction.getSender();\n+        if (owner == null || owner == receiver) {\n+            return;\n+        }\n+\n+        chains.add(owner.getChain());\n+        for (Transaction source : transaction.getSource()) {\n+            appendChains(source, receiver, chains);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Proof: \").append(transaction);\n+\n+        for (Entry<Node, List<Block>> entry : this.chainUpdates.entrySet()) {\n+            sb.append('\\n').append(entry.getKey().getId()).append(\": \").append(entry.getValue());\n+        }\n+        return sb.toString();\n+    }\n }\n",
            "diff_size": 281
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/23/Proof.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_random/23/Proof.java\nindex 2cc2c720086..2dc8def7823 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/23/Proof.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_random/23/Proof.java\n@@ -59,7 +59,7 @@ public class Proof {\n \t\tList<BlockMessage> senderChain = proofMessage.getChainUpdates().get(senderNode.getId());\n \n \t\tList<Block> currentDecodedBlockList = new ArrayList<>();\n-\t\tif (senderChain != null){\n+\t\tif (senderChain != null) {\n \t\t\t// Start from the last block\n \t\t\tBlockMessage lastBlockMessage = senderChain.get(senderChain.size() - 1);\n \t\t\t// Recursively decode the transaction and chainUpdates\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/23/Proof.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_three_grams/23/Proof.java\nindex 2cc2c720086..2dc8def7823 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/errored/1/23/Proof.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/blockchain-lab-ScaleOutDistributedLedger/styler_three_grams/23/Proof.java\n@@ -59,7 +59,7 @@ public class Proof {\n \t\tList<BlockMessage> senderChain = proofMessage.getChainUpdates().get(senderNode.getId());\n \n \t\tList<Block> currentDecodedBlockList = new ArrayList<>();\n-\t\tif (senderChain != null){\n+\t\tif (senderChain != null) {\n \t\t\t// Start from the last block\n \t\t\tBlockMessage lastBlockMessage = senderChain.get(senderChain.size() - 1);\n \t\t\t// Recursively decode the transaction and chainUpdates\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}