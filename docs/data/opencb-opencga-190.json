{
    "project_name": "opencb-opencga",
    "error_id": "190",
    "information": {
        "errors": [
            {
                "line": "145",
                "severity": "error",
                "message": "Line is longer than 140 characters (found 148).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\n    @Override\n    OpenCGAResult<File> internalGet(long studyUid, String entry, @Nullable Query query, QueryOptions options, String user) throws CatalogException {\n        // We make this comparison because in File, the absence of a fileName means the user is actually looking for the / directory\n        if (StringUtils.isNotEmpty(entry) || entry == null) {\n            ParamUtils.checkIsSingleID(entry);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "145",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 148).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/190/FileManager.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/190/FileManager.java\nindex 17a04b572e7..640b9f5e13f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/190/FileManager.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/190/FileManager.java\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.opencb.opencga.catalog.managers;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n@@ -85,70 +86,71 @@ import static org.opencb.opencga.core.common.JacksonUtils.getUpdateObjectMapper;\n  */\n public class FileManager extends AnnotationSetManager<File> {\n \n-    private static final QueryOptions INCLUDE_STUDY_URI;\n-    public static final QueryOptions INCLUDE_FILE_IDS;\n-    public static final QueryOptions INCLUDE_FILE_URI;\n-    public static final QueryOptions INCLUDE_FILE_URI_PATH;\n-    public  static final QueryOptions EXCLUDE_FILE_ATTRIBUTES;\n-    private static final Comparator<File> ROOT_FIRST_COMPARATOR;\n-    private static final Comparator<File> ROOT_LAST_COMPARATOR;\n-\n-    protected static Logger logger;\n-    private FileMetadataReader fileMetadataReader;\n-    private UserManager userManager;\n-    private StudyManager studyManager;\n-    private IOManagerFactory ioManagerFactory;\n-\n-    private final String defaultFacet = \"creationYear>>creationMonth;format;bioformat;format>>bioformat;status;\"\n-            + \"size[0..214748364800]:10737418240;numSamples[0..10]:1\";\n-\n-    static {\n-        INCLUDE_FILE_IDS = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.ID.key(),\n-                FileDBAdaptor.QueryParams.NAME.key(), FileDBAdaptor.QueryParams.UID.key(), FileDBAdaptor.QueryParams.UUID.key(),\n-                FileDBAdaptor.QueryParams.STUDY_UID.key(), FileDBAdaptor.QueryParams.TYPE.key()));\n-        INCLUDE_FILE_URI = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.ID.key(),\n-                FileDBAdaptor.QueryParams.NAME.key(), FileDBAdaptor.QueryParams.UID.key(), FileDBAdaptor.QueryParams.UUID.key(),\n-                FileDBAdaptor.QueryParams.URI.key(), FileDBAdaptor.QueryParams.STUDY_UID.key(), FileDBAdaptor.QueryParams.TYPE.key()));\n-        INCLUDE_FILE_URI_PATH = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.ID.key(),\n-                FileDBAdaptor.QueryParams.NAME.key(), FileDBAdaptor.QueryParams.UID.key(), FileDBAdaptor.QueryParams.UUID.key(),\n-                FileDBAdaptor.QueryParams.INTERNAL_STATUS.key(), FileDBAdaptor.QueryParams.FORMAT.key(),\n-                FileDBAdaptor.QueryParams.URI.key(), FileDBAdaptor.QueryParams.PATH.key(), FileDBAdaptor.QueryParams.EXTERNAL.key(),\n-                FileDBAdaptor.QueryParams.STUDY_UID.key(), FileDBAdaptor.QueryParams.TYPE.key()));\n-        EXCLUDE_FILE_ATTRIBUTES = new QueryOptions(QueryOptions.EXCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.ATTRIBUTES.key(),\n-                FileDBAdaptor.QueryParams.ANNOTATION_SETS.key(), FileDBAdaptor.QueryParams.STATS.key()));\n-        INCLUDE_STUDY_URI = new QueryOptions(QueryOptions.INCLUDE, StudyDBAdaptor.QueryParams.URI.key());\n-\n-        ROOT_FIRST_COMPARATOR = (f1, f2) -> (f1.getPath() == null ? 0 : f1.getPath().length())\n-                - (f2.getPath() == null ? 0 : f2.getPath().length());\n-        ROOT_LAST_COMPARATOR = (f1, f2) -> (f2.getPath() == null ? 0 : f2.getPath().length())\n-                - (f1.getPath() == null ? 0 : f1.getPath().length());\n-\n-        logger = LoggerFactory.getLogger(FileManager.class);\n-    }\n-\n-    FileManager(AuthorizationManager authorizationManager, AuditManager auditManager, CatalogManager catalogManager,\n-                DBAdaptorFactory catalogDBAdaptorFactory, IOManagerFactory ioManagerFactory, Configuration configuration) {\n-        super(authorizationManager, auditManager, catalogManager, catalogDBAdaptorFactory, configuration);\n-\n-        this.userManager = catalogManager.getUserManager();\n-        this.studyManager = catalogManager.getStudyManager();\n-        this.ioManagerFactory = ioManagerFactory;\n-        this.fileMetadataReader = new FileMetadataReader(this.catalogManager);\n-    }\n-\n-    @Override\n-    Enums.Resource getEntity() {\n-        return Enums.Resource.FILE;\n-    }\n-\n-    @Override\n-    OpenCGAResult<File> internalGet(long studyUid, String entry, @Nullable Query query, QueryOptions options, String user) throws CatalogException {\n-        // We make this comparison because in File, the absence of a fileName means the user is actually looking for the / directory\n-        if (StringUtils.isNotEmpty(entry) || entry == null) {\n-            ParamUtils.checkIsSingleID(entry);\n-        }\n-        return internalGet(studyUid, Collections.singletonList(entry), query, options, user, false);\n-    }\n+  private static final QueryOptions INCLUDE_STUDY_URI;\n+  public static final QueryOptions INCLUDE_FILE_IDS;\n+  public static final QueryOptions INCLUDE_FILE_URI;\n+  public static final QueryOptions INCLUDE_FILE_URI_PATH;\n+  public static final QueryOptions EXCLUDE_FILE_ATTRIBUTES;\n+  private static final Comparator<File> ROOT_FIRST_COMPARATOR;\n+  private static final Comparator<File> ROOT_LAST_COMPARATOR;\n+\n+  protected static Logger logger;\n+  private FileMetadataReader fileMetadataReader;\n+  private UserManager userManager;\n+  private StudyManager studyManager;\n+  private IOManagerFactory ioManagerFactory;\n+\n+  private final String defaultFacet = \"creationYear>>creationMonth;format;bioformat;format>>bioformat;status;\"\n+      + \"size[0..214748364800]:10737418240;numSamples[0..10]:1\";\n+\n+  static {\n+    INCLUDE_FILE_IDS = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.ID.key(),\n+        FileDBAdaptor.QueryParams.NAME.key(), FileDBAdaptor.QueryParams.UID.key(), FileDBAdaptor.QueryParams.UUID.key(),\n+        FileDBAdaptor.QueryParams.STUDY_UID.key(), FileDBAdaptor.QueryParams.TYPE.key()));\n+    INCLUDE_FILE_URI = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.ID.key(),\n+        FileDBAdaptor.QueryParams.NAME.key(), FileDBAdaptor.QueryParams.UID.key(), FileDBAdaptor.QueryParams.UUID.key(),\n+        FileDBAdaptor.QueryParams.URI.key(), FileDBAdaptor.QueryParams.STUDY_UID.key(), FileDBAdaptor.QueryParams.TYPE.key()));\n+    INCLUDE_FILE_URI_PATH = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.ID.key(),\n+        FileDBAdaptor.QueryParams.NAME.key(), FileDBAdaptor.QueryParams.UID.key(), FileDBAdaptor.QueryParams.UUID.key(),\n+        FileDBAdaptor.QueryParams.INTERNAL_STATUS.key(), FileDBAdaptor.QueryParams.FORMAT.key(),\n+        FileDBAdaptor.QueryParams.URI.key(), FileDBAdaptor.QueryParams.PATH.key(), FileDBAdaptor.QueryParams.EXTERNAL.key(),\n+        FileDBAdaptor.QueryParams.STUDY_UID.key(), FileDBAdaptor.QueryParams.TYPE.key()));\n+    EXCLUDE_FILE_ATTRIBUTES = new QueryOptions(QueryOptions.EXCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.ATTRIBUTES.key(),\n+        FileDBAdaptor.QueryParams.ANNOTATION_SETS.key(), FileDBAdaptor.QueryParams.STATS.key()));\n+    INCLUDE_STUDY_URI = new QueryOptions(QueryOptions.INCLUDE, StudyDBAdaptor.QueryParams.URI.key());\n+\n+    ROOT_FIRST_COMPARATOR = (f1, f2) -> (f1.getPath() == null ? 0 : f1.getPath().length())\n+        - (f2.getPath() == null ? 0 : f2.getPath().length());\n+    ROOT_LAST_COMPARATOR = (f1, f2) -> (f2.getPath() == null ? 0 : f2.getPath().length())\n+        - (f1.getPath() == null ? 0 : f1.getPath().length());\n+\n+    logger = LoggerFactory.getLogger(FileManager.class);\n+  }\n+\n+  FileManager(AuthorizationManager authorizationManager, AuditManager auditManager, CatalogManager catalogManager,\n+              DBAdaptorFactory catalogDBAdaptorFactory, IOManagerFactory ioManagerFactory, Configuration configuration) {\n+    super(authorizationManager, auditManager, catalogManager, catalogDBAdaptorFactory, configuration);\n+\n+    this.userManager = catalogManager.getUserManager();\n+    this.studyManager = catalogManager.getStudyManager();\n+    this.ioManagerFactory = ioManagerFactory;\n+    this.fileMetadataReader = new FileMetadataReader(this.catalogManager);\n+  }\n+\n+  @Override\n+  Enums.Resource getEntity() {\n+    return Enums.Resource.FILE;\n+  }\n+\n+  @Override\n+  OpenCGAResult<File> internalGet(long studyUid, String entry, @Nullable Query query, QueryOptions options, String user)\n+      throws CatalogException {\n+    // We make this comparison because in File, the absence of a fileName means the user is actually looking for the / directory\n+    if (StringUtils.isNotEmpty(entry) || entry == null) {\n+      ParamUtils.checkIsSingleID(entry);\n+    }\n+    return internalGet(studyUid, Collections.singletonList(entry), query, options, user, false);\n+  }\n \n //    @Override\n //    OpenCGAResult<File> internalGet(long studyUid, String fileName, @Nullable Query query, QueryOptions options, String user)\n@@ -214,3612 +216,3612 @@ public class FileManager extends AnnotationSetManager<File> {\n //        throw new CatalogException(\"File \" + fileName + \" not found\");\n //    }\n \n-    @Override\n-    InternalGetDataResult<File> internalGet(long studyUid, List<String> entryList, @Nullable Query query, QueryOptions options,\n-                                            String user, boolean ignoreException) throws CatalogException {\n-        if (ListUtils.isEmpty(entryList)) {\n-            throw new CatalogException(\"Missing file entries.\");\n-        }\n-        List<String> uniqueList = ListUtils.unique(entryList);\n-\n-        QueryOptions queryOptions = options != null ? new QueryOptions(options) : new QueryOptions();\n-        Query queryCopy = query == null ? new Query() : new Query(query);\n-        queryCopy.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid);\n-\n-        Function<File, String> fileStringFunction = File::getPath;\n-        boolean canBeSearchedAsName = true;\n-        List<String> correctedFileList = new ArrayList<>(uniqueList.size());\n-        FileDBAdaptor.QueryParams idQueryParam = null;\n-        for (String entry : uniqueList) {\n-            FileDBAdaptor.QueryParams param = FileDBAdaptor.QueryParams.PATH;\n-            if (UuidUtils.isOpenCgaUuid(entry)) {\n-                correctedFileList.add(entry);\n-                param = FileDBAdaptor.QueryParams.UUID;\n-                fileStringFunction = File::getUuid;\n-            } else {\n-                String fileName = entry.replace(\":\", \"/\");\n-                if (fileName.startsWith(\"/\")) {\n-                    // Remove the starting /. Absolute paths are not supported.\n-                    fileName = fileName.substring(1);\n-                }\n-                correctedFileList.add(fileName);\n+  @Override\n+  InternalGetDataResult<File> internalGet(long studyUid, List<String> entryList, @Nullable Query query, QueryOptions options,\n+                                          String user, boolean ignoreException) throws CatalogException {\n+    if (ListUtils.isEmpty(entryList)) {\n+      throw new CatalogException(\"Missing file entries.\");\n+    }\n+    List<String> uniqueList = ListUtils.unique(entryList);\n+\n+    QueryOptions queryOptions = options != null ? new QueryOptions(options) : new QueryOptions();\n+    Query queryCopy = query == null ? new Query() : new Query(query);\n+    queryCopy.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid);\n+\n+    Function<File, String> fileStringFunction = File::getPath;\n+    boolean canBeSearchedAsName = true;\n+    List<String> correctedFileList = new ArrayList<>(uniqueList.size());\n+    FileDBAdaptor.QueryParams idQueryParam = null;\n+    for (String entry : uniqueList) {\n+      FileDBAdaptor.QueryParams param = FileDBAdaptor.QueryParams.PATH;\n+      if (UuidUtils.isOpenCgaUuid(entry)) {\n+        correctedFileList.add(entry);\n+        param = FileDBAdaptor.QueryParams.UUID;\n+        fileStringFunction = File::getUuid;\n+      } else {\n+        String fileName = entry.replace(\":\", \"/\");\n+        if (fileName.startsWith(\"/\")) {\n+          // Remove the starting /. Absolute paths are not supported.\n+          fileName = fileName.substring(1);\n+        }\n+        correctedFileList.add(fileName);\n+\n+        if (fileName.contains(\"/\")) {\n+          canBeSearchedAsName = false;\n+        }\n+      }\n+      if (idQueryParam == null) {\n+        idQueryParam = param;\n+      }\n+      if (idQueryParam != param) {\n+        throw new CatalogException(\"Found uuids and paths in the same query. Please, choose one or do two different queries.\");\n+      }\n+    }\n+    queryCopy.put(idQueryParam.key(), correctedFileList);\n+\n+    // Ensure the field by which we are querying for will be kept in the results\n+    queryOptions = keepFieldInQueryOptions(queryOptions, idQueryParam.key());\n+\n+    OpenCGAResult<File> fileDataResult = fileDBAdaptor.get(studyUid, queryCopy, queryOptions, user);\n+    if (fileDataResult.getNumResults() != correctedFileList.size() && idQueryParam == FileDBAdaptor.QueryParams.PATH\n+        && canBeSearchedAsName) {\n+      // We also search by name\n+      queryCopy = query == null ? new Query() : new Query(query);\n+      queryCopy.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n+          .append(FileDBAdaptor.QueryParams.NAME.key(), correctedFileList);\n+\n+      // Ensure the field by which we are querying for will be kept in the results\n+      queryOptions = keepFieldInQueryOptions(queryOptions, FileDBAdaptor.QueryParams.NAME.key());\n+\n+      OpenCGAResult<File> nameDataResult = fileDBAdaptor.get(studyUid, queryCopy, queryOptions, user);\n+      if (nameDataResult.getNumResults() > fileDataResult.getNumResults()) {\n+        fileDataResult = nameDataResult;\n+        fileStringFunction = File::getName;\n+      }\n+    }\n+\n+    if (fileDataResult.getNumResults() > correctedFileList.size()) {\n+      throw new CatalogException(\"Error: More than one file found for at least one of the files introduced\");\n+    } else if (ignoreException || fileDataResult.getNumResults() == correctedFileList.size()) {\n+      return keepOriginalOrder(correctedFileList, fileStringFunction, fileDataResult, ignoreException, false);\n+    } else {\n+      // The file could not be found or the user does not have permissions to see it\n+      // Check if the file can be found without adding the user restriction\n+      OpenCGAResult<File> resultsNoCheck = fileDBAdaptor.get(queryCopy, queryOptions);\n+      if (resultsNoCheck.getNumResults() == correctedFileList.size()) {\n+        throw new CatalogAuthorizationException(\"Permission denied. \" + user + \" is not allowed to see some or none of the files.\");\n+      }\n+      if (canBeSearchedAsName) {\n+        // The last query was performed by name, so we now search by path\n+        queryCopy = query == null ? new Query() : new Query(query);\n+        queryCopy.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n+            .append(FileDBAdaptor.QueryParams.PATH.key(), correctedFileList);\n+        resultsNoCheck = fileDBAdaptor.get(queryCopy, queryOptions);\n+        if (resultsNoCheck.getNumResults() == correctedFileList.size()) {\n+          throw new CatalogAuthorizationException(\"Permission denied. \" + user + \" is not allowed to see some or none of the \"\n+              + \"files.\");\n+        }\n+      }\n+\n+      throw CatalogException.notFound(\"files\", getMissingFields(uniqueList, fileDataResult.getResults(), fileStringFunction));\n+    }\n+  }\n+\n+  private OpenCGAResult<File> getFile(long studyUid, String fileUuid, QueryOptions options) throws CatalogException {\n+    Query query = new Query()\n+        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n+        .append(FileDBAdaptor.QueryParams.UUID.key(), fileUuid);\n+    return fileDBAdaptor.get(query, options);\n+  }\n+\n+  public URI getUri(File file) throws CatalogException {\n+    ParamUtils.checkObj(file, \"File\");\n+    if (file.getUri() != null) {\n+      return file.getUri();\n+    } else {\n+      OpenCGAResult<File> fileDataResult = fileDBAdaptor.get(file.getUid(), INCLUDE_STUDY_URI);\n+      if (fileDataResult.getNumResults() == 0) {\n+        throw new CatalogException(\"File \" + file.getUid() + \" not found\");\n+      }\n+      return fileDataResult.first().getUri();\n+    }\n+  }\n+\n+  public Study getStudy(File file, String sessionId) throws CatalogException {\n+    ParamUtils.checkObj(file, \"file\");\n+    ParamUtils.checkObj(sessionId, \"session id\");\n+\n+    if (file.getStudyUid() <= 0) {\n+      throw new CatalogException(\"Missing study uid field in file\");\n+    }\n+\n+    String user = userManager.getUserId(sessionId);\n+\n+    Query query = new Query(StudyDBAdaptor.QueryParams.UID.key(), file.getStudyUid());\n+    OpenCGAResult<Study> studyDataResult = studyDBAdaptor.get(query, QueryOptions.empty(), user);\n+    if (studyDataResult.getNumResults() == 1) {\n+      return studyDataResult.first();\n+    } else {\n+      authorizationManager.checkCanViewStudy(file.getStudyUid(), user);\n+      throw new CatalogException(\"Incorrect study uid\");\n+    }\n+  }\n+\n+  public void matchUpVariantFiles(String studyStr, List<File> transformedFiles, String sessionId) throws CatalogException {\n+    String userId = userManager.getUserId(sessionId);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    for (File transformedFile : transformedFiles) {\n+      authorizationManager.checkFilePermission(study.getUid(), transformedFile.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+      String variantPathName = getMainVariantFile(transformedFile.getPath());\n+      if (variantPathName == null) {\n+        // Skip the file.\n+        logger.debug(\"The file {} is not a variant transformed file\", transformedFile.getName());\n+        continue;\n+      }\n+\n+      // Search in the same path\n+      logger.info(\"Looking for vcf file in path {}\", variantPathName);\n+      Query query = new Query()\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+          .append(FileDBAdaptor.QueryParams.PATH.key(), variantPathName)\n+          .append(FileDBAdaptor.QueryParams.BIOFORMAT.key(), File.Bioformat.VARIANT);\n+\n+      List<File> fileList = fileDBAdaptor.get(query, new QueryOptions()).getResults();\n+\n+      if (fileList.isEmpty()) {\n+        // Search by name in the whole study\n+        String variantFileName = getMainVariantFile(transformedFile.getName());\n+        logger.info(\"Looking for vcf file by name {}\", variantFileName);\n+        query = new Query()\n+            .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+            .append(FileDBAdaptor.QueryParams.NAME.key(), variantFileName)\n+            .append(FileDBAdaptor.QueryParams.BIOFORMAT.key(), File.Bioformat.VARIANT);\n+        fileList = new ArrayList<>(fileDBAdaptor.get(query, new QueryOptions()).getResults());\n+\n+        // In case of finding more than one file, try to find the proper one.\n+        if (fileList.size() > 1) {\n+          // Discard files already with a transformed file.\n+          fileList.removeIf(file -> file.getInternal().getIndex() != null\n+              && file.getInternal().getIndex().getTransformedFile() != null\n+              && file.getInternal().getIndex().getTransformedFile().getId() != transformedFile.getUid());\n+        }\n+        if (fileList.size() > 1) {\n+          // Discard files not transformed or indexed.\n+          fileList.removeIf(file -> file.getInternal().getIndex() == null\n+              || file.getInternal().getIndex().getStatus() == null\n+              || file.getInternal().getIndex().getStatus().getName() == null\n+              || file.getInternal().getIndex().getStatus().getName().equals(FileIndex.IndexStatus.NONE));\n+        }\n+      }\n+\n+\n+      if (fileList.size() != 1) {\n+        // VCF file not found\n+        logger.warn(\"The vcf file corresponding to the file \" + transformedFile.getName() + \" could not be found\");\n+        continue;\n+      }\n+      File vcf = fileList.get(0);\n+\n+      // Look for the json file. It should be in the same directory where the transformed file is.\n+      String jsonPathName = getVariantMetadataFile(transformedFile.getPath());\n+      query = new Query()\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+          .append(FileDBAdaptor.QueryParams.PATH.key(), jsonPathName)\n+          .append(FileDBAdaptor.QueryParams.FORMAT.key(), File.Format.JSON);\n+      fileList = fileDBAdaptor.get(query, new QueryOptions()).getResults();\n+      if (fileList.size() != 1) {\n+        // Skip. This should not ever happen\n+        logger.warn(\"The json file corresponding to the file \" + transformedFile.getName() + \" could not be found\");\n+        continue;\n+      }\n+      File json = fileList.get(0);\n+\n+      /* Update relations */\n+      FileRelatedFile producedFromRelation = new FileRelatedFile(vcf, FileRelatedFile.Relation.PRODUCED_FROM);\n+\n+      // Update json file\n+      logger.debug(\"Updating json relation\");\n+      List<FileRelatedFile> relatedFiles = ParamUtils.defaultObject(json.getRelatedFiles(), ArrayList::new);\n+      // Do not add twice the same relation\n+      if (!relatedFiles.contains(producedFromRelation)) {\n+        relatedFiles.add(producedFromRelation);\n+        ObjectMap params = new ObjectMap(FileDBAdaptor.QueryParams.RELATED_FILES.key(), relatedFiles);\n+        fileDBAdaptor.update(json.getUid(), params, QueryOptions.empty());\n+      }\n+\n+      // Update transformed file\n+      logger.debug(\"Updating transformed relation\");\n+      relatedFiles = ParamUtils.defaultObject(transformedFile.getRelatedFiles(), ArrayList::new);\n+      // Do not add twice the same relation\n+      if (!relatedFiles.contains(producedFromRelation)) {\n+        relatedFiles.add(producedFromRelation);\n+        transformedFile.setRelatedFiles(relatedFiles);\n+        ObjectMap params = new ObjectMap(FileDBAdaptor.QueryParams.RELATED_FILES.key(), relatedFiles);\n+        fileDBAdaptor.update(transformedFile.getUid(), params, QueryOptions.empty());\n+      }\n+\n+      // Update vcf file\n+      logger.debug(\"Updating vcf relation\");\n+      FileIndex index = vcf.getInternal().getIndex();\n+      if (index.getTransformedFile() == null) {\n+        index.setTransformedFile(new FileIndex.TransformedFile(transformedFile.getUid(), json.getUid()));\n+      }\n+      String status = FileIndex.IndexStatus.NONE;\n+      if (vcf.getInternal().getIndex() != null && vcf.getInternal().getIndex().getStatus() != null\n+          && vcf.getInternal().getIndex().getStatus().getName() != null) {\n+        status = vcf.getInternal().getIndex().getStatus().getName();\n+      }\n+      if (FileIndex.IndexStatus.NONE.equals(status)) {\n+        // If TRANSFORMED, TRANSFORMING, etc, do not modify the index status\n+        index.setStatus(new FileIndex.IndexStatus(FileIndex.IndexStatus.TRANSFORMED, \"Found transformed file\"));\n+      }\n+      ObjectMap params = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), index);\n+      fileDBAdaptor.update(vcf.getUid(), params, QueryOptions.empty());\n+\n+      // Update variant stats\n+      Path statsFile = Paths.get(json.getUri().getRawPath());\n+      try (InputStream is = FileUtils.newInputStream(statsFile)) {\n+        VariantFileMetadata fileMetadata = getDefaultObjectMapper().readValue(is, VariantFileMetadata.class);\n+        VariantSetStats stats = fileMetadata.getStats();\n+\n+        AnnotationSet annotationSet = AvroToAnnotationConverter.convertToAnnotationSet(stats, FILE_VARIANT_STATS_VARIABLE_SET);\n+        catalogManager.getFileManager()\n+            .update(studyStr, vcf.getPath(), new FileUpdateParams().setAnnotationSets(Collections.singletonList(annotationSet)),\n+                new QueryOptions(Constants.ACTIONS,\n+                    Collections.singletonMap(ANNOTATION_SETS, ParamUtils.CompleteUpdateAction.SET)), sessionId);\n+\n+\n+      } catch (IOException e) {\n+        throw new CatalogException(\"Error reading file \\\"\" + statsFile + \"\\\"\", e);\n+      }\n+    }\n+  }\n+\n+  public OpenCGAResult<FileIndex> updateFileIndexStatus(File file, String newStatus, String message, String sessionId)\n+      throws CatalogException {\n+    return updateFileIndexStatus(file, newStatus, message, null, sessionId);\n+  }\n+\n+  public OpenCGAResult<FileIndex> updateFileIndexStatus(File file, String newStatus, String message, Integer release, String token)\n+      throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyDBAdaptor.get(file.getStudyUid(), StudyManager.INCLUDE_STUDY_ID).first();\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"file\", file)\n+        .append(\"newStatus\", newStatus)\n+        .append(\"message\", message)\n+        .append(\"release\", release)\n+        .append(\"token\", token);\n+\n+    authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+\n+    FileIndex index = file.getInternal().getIndex();\n+    if (index != null) {\n+      if (!FileIndex.IndexStatus.isValid(newStatus)) {\n+        throw new CatalogException(\"The status \" + newStatus + \" is not a valid status.\");\n+      } else {\n+        index.setStatus(new FileIndex.IndexStatus(newStatus, message));\n+      }\n+    } else {\n+      index = new FileIndex(userId, TimeUtils.getTime(), new FileIndex.IndexStatus(newStatus), -1, new ObjectMap());\n+    }\n+    if (release != null) {\n+      if (newStatus.equals(FileIndex.IndexStatus.READY)) {\n+        index.setRelease(release);\n+      }\n+    }\n+    ObjectMap params = null;\n+    try {\n+      params = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), new ObjectMap(getUpdateObjectMapper()\n+          .writeValueAsString(index)));\n+    } catch (JsonProcessingException e) {\n+      throw new CatalogException(\"Cannot parse index object: \" + e.getMessage(), e);\n+    }\n+    OpenCGAResult update = fileDBAdaptor.update(file.getUid(), params, QueryOptions.empty());\n+    auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n+        auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+    return new OpenCGAResult<>(update.getTime(), update.getEvents(), 1, Collections.singletonList(index), 1);\n+  }\n+\n+  @Deprecated\n+  public OpenCGAResult<File> getParents(long fileId, QueryOptions options, String sessionId) throws CatalogException {\n+    OpenCGAResult<File> fileDataResult = fileDBAdaptor.get(fileId, new QueryOptions(QueryOptions.INCLUDE,\n+        Arrays.asList(FileDBAdaptor.QueryParams.PATH.key(), FileDBAdaptor.QueryParams.STUDY_UID.key())));\n+\n+    if (fileDataResult.getNumResults() == 0) {\n+      return fileDataResult;\n+    }\n+\n+    String userId = userManager.getUserId(sessionId);\n+    authorizationManager.checkFilePermission(fileDataResult.first().getStudyUid(), fileId, userId, FileAclEntry.FilePermissions.VIEW);\n+\n+    return getParents(fileDataResult.first().getStudyUid(), fileDataResult.first().getPath(), true, options);\n+  }\n+\n+  public OpenCGAResult<File> createFolder(String studyStr, String path, boolean parents, String description, QueryOptions options,\n+                                          String token) throws CatalogException {\n+    return createFolder(studyStr, path, parents, description, \"\", options, token);\n+  }\n+\n+  public OpenCGAResult<File> createFolder(String studyStr, String path, boolean parents, String description, String jobId,\n+                                          QueryOptions options, String token) throws CatalogException {\n+    ParamUtils.checkPath(path, \"folderPath\");\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    if (path.startsWith(\"/\")) {\n+      path = path.substring(1);\n+    }\n+    if (!path.endsWith(\"/\")) {\n+      path = path + \"/\";\n+    }\n+\n+    OpenCGAResult<File> fileDataResult;\n+    switch (checkPathExists(path, study.getUid())) {\n+      case FREE_PATH:\n+        File file = new File(File.Type.DIRECTORY, File.Format.NONE, File.Bioformat.NONE, path, description,\n+            FileInternal.initialize(), 0, null, null, jobId, null, null);\n+        fileDataResult = create(studyStr, file, parents, null, options, token);\n+        break;\n+      case DIRECTORY_EXISTS:\n+        Query query = new Query()\n+            .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+            .append(FileDBAdaptor.QueryParams.PATH.key(), path);\n+        fileDataResult = fileDBAdaptor.get(study.getUid(), query, options, userId);\n+        fileDataResult.getEvents().add(new Event(Event.Type.WARNING, path, \"Folder already existed\"));\n+        break;\n+      case FILE_EXISTS:\n+      default:\n+        throw new CatalogException(\"A file with the same name of the folder already exists in Catalog\");\n+    }\n+\n+    return fileDataResult;\n+  }\n+\n+  public OpenCGAResult<File> createFile(String studyStr, String path, String description, boolean parents, String content,\n+                                        String sessionId) throws CatalogException {\n+    ParamUtils.checkPath(path, \"filePath\");\n+\n+    String userId = userManager.getUserId(sessionId);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    if (path.startsWith(\"/\")) {\n+      path = path.substring(1);\n+    }\n+\n+    switch (checkPathExists(path, study.getUid())) {\n+      case FREE_PATH:\n+        return create(studyStr, File.Type.FILE, File.Format.PLAIN, File.Bioformat.UNKNOWN, path, description,\n+            0, null, null, parents, content, new QueryOptions(),\n+            sessionId);\n+      case FILE_EXISTS:\n+      case DIRECTORY_EXISTS:\n+      default:\n+        throw new CatalogException(\"A file or folder with the same name already exists in the path of Catalog\");\n+    }\n+  }\n+\n+  public OpenCGAResult<File> create(String studyStr, File.Type type, File.Format format, File.Bioformat bioformat, String path,\n+                                    String description, long size, Map<String, Object> stats, Map<String, Object> attributes,\n+                                    boolean parents, String content, QueryOptions options, String token) throws CatalogException {\n+    File file = new File(type, format, bioformat, path, description, FileInternal.initialize(), size, Collections.emptyList(), null, \"\",\n+        stats, attributes);\n+    return create(studyStr, file, parents, content, options, token);\n+  }\n+\n+  @Override\n+  public OpenCGAResult<File> create(String studyStr, File entry, QueryOptions options, String token) throws CatalogException {\n+    throw new NotImplementedException(\"Call to create passing parents and content variables\");\n+  }\n+\n+  public OpenCGAResult<File> create(String studyStr, File file, boolean parents, String content, QueryOptions options, String token)\n+      throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"file\", file)\n+        .append(\"parents\", parents)\n+        .append(\"content\", content)\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+    try {\n+      File parentFile = getParents(study.getUid(), file.getPath(), false, INCLUDE_FILE_URI_PATH).first();\n+      authorizationManager.checkFilePermission(study.getUid(), parentFile.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+\n+      OpenCGAResult<File> result = create(study, file, parents, content, options, token);\n+      auditManager.auditCreate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      return result;\n+    } catch (CatalogException e) {\n+      auditManager.auditCreate(userId, Enums.Resource.FILE, file.getId(), \"\", study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  void validateNewFile(Study study, File file, String sessionId, boolean overwrite) throws CatalogException {\n+    /** Check and set all the params and create a File object **/\n+    ParamUtils.checkObj(file, \"File\");\n+    ParamUtils.checkPath(file.getPath(), \"path\");\n+    file.setType(ParamUtils.defaultObject(file.getType(), File.Type.FILE));\n+    file.setFormat(ParamUtils.defaultObject(file.getFormat(), File.Format.PLAIN));\n+    file.setBioformat(ParamUtils.defaultObject(file.getBioformat(), File.Bioformat.NONE));\n+    file.setDescription(ParamUtils.defaultString(file.getDescription(), \"\"));\n+    file.setRelatedFiles(ParamUtils.defaultObject(file.getRelatedFiles(), ArrayList::new));\n+    file.setSampleIds(ParamUtils.defaultObject(file.getSampleIds(), ArrayList::new));\n+    file.setCreationDate(TimeUtils.getTime());\n+    file.setJobId(ParamUtils.defaultString(file.getJobId(), \"\"));\n+    file.setModificationDate(file.getCreationDate());\n+    file.setTags(ParamUtils.defaultObject(file.getTags(), ArrayList::new));\n+    file.setInternal(ParamUtils.defaultObject(file.getInternal(), FileInternal::new));\n+    file.getInternal().setIndex(ParamUtils.defaultObject(file.getInternal().getIndex(), FileIndex.initialize()));\n+    file.getInternal().setStatus(ParamUtils.defaultObject(file.getInternal().getStatus(), new FileStatus(FileStatus.READY)));\n+    file.getInternal().setSampleMap(ParamUtils.defaultObject(file.getInternal().getSampleMap(), HashMap::new));\n+    file.setStatus(ParamUtils.defaultObject(file.getStatus(), CustomStatus::new));\n+    file.setStats(ParamUtils.defaultObject(file.getStats(), HashMap::new));\n+    file.setAttributes(ParamUtils.defaultObject(file.getAttributes(), HashMap::new));\n \n-                if (fileName.contains(\"/\")) {\n-                    canBeSearchedAsName = false;\n-                }\n-            }\n-            if (idQueryParam == null) {\n-                idQueryParam = param;\n-            }\n-            if (idQueryParam != param) {\n-                throw new CatalogException(\"Found uuids and paths in the same query. Please, choose one or do two different queries.\");\n-            }\n-        }\n-        queryCopy.put(idQueryParam.key(), correctedFileList);\n-\n-        // Ensure the field by which we are querying for will be kept in the results\n-        queryOptions = keepFieldInQueryOptions(queryOptions, idQueryParam.key());\n-\n-        OpenCGAResult<File> fileDataResult = fileDBAdaptor.get(studyUid, queryCopy, queryOptions, user);\n-        if (fileDataResult.getNumResults() != correctedFileList.size() && idQueryParam == FileDBAdaptor.QueryParams.PATH\n-                && canBeSearchedAsName) {\n-            // We also search by name\n-            queryCopy = query == null ? new Query() : new Query(query);\n-            queryCopy.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n-                    .append(FileDBAdaptor.QueryParams.NAME.key(), correctedFileList);\n-\n-            // Ensure the field by which we are querying for will be kept in the results\n-            queryOptions = keepFieldInQueryOptions(queryOptions, FileDBAdaptor.QueryParams.NAME.key());\n-\n-            OpenCGAResult<File> nameDataResult = fileDBAdaptor.get(studyUid, queryCopy, queryOptions, user);\n-            if (nameDataResult.getNumResults() > fileDataResult.getNumResults()) {\n-                fileDataResult = nameDataResult;\n-                fileStringFunction = File::getName;\n-            }\n-        }\n+//        validateNewSamples(study, file, sessionId);\n \n-        if (fileDataResult.getNumResults() > correctedFileList.size()) {\n-            throw new CatalogException(\"Error: More than one file found for at least one of the files introduced\");\n-        } else if (ignoreException || fileDataResult.getNumResults() == correctedFileList.size()) {\n-            return keepOriginalOrder(correctedFileList, fileStringFunction, fileDataResult, ignoreException, false);\n+    if (file.getSize() < 0) {\n+      throw new CatalogException(\"Error: DiskUsage can't be negative!\");\n+    }\n+\n+    // Fix path\n+    if (file.getType() == File.Type.DIRECTORY && !file.getPath().endsWith(\"/\")) {\n+      file.setPath(file.getPath() + \"/\");\n+    }\n+    if (file.getType() == File.Type.FILE && file.getPath().endsWith(\"/\")) {\n+      file.setPath(file.getPath().substring(0, file.getPath().length() - 1));\n+    }\n+    file.setName(Paths.get(file.getPath()).getFileName().toString());\n+    file.setId(file.getPath().replace(\"/\", \":\"));\n+\n+    URI uri;\n+    try {\n+      if (file.getType() == File.Type.DIRECTORY) {\n+        uri = getFileUri(study.getUid(), file.getPath(), true);\n+      } else {\n+        uri = getFileUri(study.getUid(), file.getPath(), false);\n+      }\n+    } catch (URISyntaxException e) {\n+      throw new CatalogException(e);\n+    }\n+    file.setUri(uri);\n+\n+    if (!overwrite) {\n+      // Check if it already exists\n+      Query query = new Query()\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+          .append(FileDBAdaptor.QueryParams.PATH.key(), file.getPath());\n+      if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n+        logger.warn(\"The file '{}' already exists in catalog\", file.getPath());\n+        throw new CatalogException(\"The file '\" + file.getPath() + \"' already exists in catalog\");\n+      }\n+      query = new Query()\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+          .append(FileDBAdaptor.QueryParams.URI.key(), uri);\n+      OpenCGAResult<File> fileResult = fileDBAdaptor.get(query,\n+          new QueryOptions(QueryOptions.INCLUDE, FileDBAdaptor.QueryParams.PATH.key()));\n+      if (fileResult.getNumResults() > 0) {\n+        logger.warn(\"The uri '{}' of the file is already in catalog but in path '{}'.\", uri, fileResult.first().getPath());\n+        throw new CatalogException(\"The uri '\" + uri + \"' of the file is already in catalog but in path '\"\n+            + fileResult.first().getPath() + \"'\");\n+      }\n+    }\n+\n+    boolean external = isExternal(study, file.getPath(), uri);\n+    file.setExternal(external);\n+    file.setRelease(studyManager.getCurrentRelease(study));\n+\n+    validateNewAnnotationSets(study.getVariableSets(), file.getAnnotationSets());\n+\n+    file.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n+    checkHooks(file, study.getFqn(), HookConfiguration.Stage.CREATE);\n+  }\n+\n+  private OpenCGAResult<File> register(Study study, File file, List<Sample> existingSamples, List<Sample> nonExistingSamples,\n+                                       boolean parents, QueryOptions options, String sessionId) throws CatalogException {\n+    String userId = userManager.getUserId(sessionId);\n+    long studyId = study.getUid();\n+\n+    //Find parent. If parents == true, create folders.\n+    String parentPath = getParentPath(file.getPath());\n+\n+    long parentFileId = fileDBAdaptor.getId(studyId, parentPath);\n+    boolean newParent = false;\n+    if (parentFileId < 0 && StringUtils.isNotEmpty(parentPath)) {\n+      if (parents) {\n+        newParent = true;\n+        File parentFile = new File(File.Type.DIRECTORY, File.Format.NONE, File.Bioformat.NONE, parentPath, \"\",\n+            new FileInternal(new FileStatus(FileStatus.READY), new FileIndex(), Collections.emptyMap()), 0,\n+            Collections.emptyList(), null, \"\", Collections.emptyMap(), Collections.emptyMap());\n+        validateNewFile(study, parentFile, sessionId, false);\n+        parentFileId = register(study, parentFile, existingSamples, nonExistingSamples, parents, options, sessionId)\n+            .first().getUid();\n+      } else {\n+        throw new CatalogDBException(\"Directory not found \" + parentPath);\n+      }\n+    }\n+\n+    //Check permissions\n+    if (parentFileId < 0) {\n+      throw new CatalogException(\"Unable to create file without a parent file\");\n+    } else {\n+      if (!newParent) {\n+        //If parent has been created, for sure we have permissions to create the new file.\n+        authorizationManager.checkFilePermission(studyId, parentFileId, userId, FileAclEntry.FilePermissions.WRITE);\n+      }\n+    }\n+\n+    fileDBAdaptor.insert(studyId, file, existingSamples, nonExistingSamples, study.getVariableSets(), options);\n+    OpenCGAResult<File> queryResult = getFile(studyId, file.getUuid(), options);\n+    // We obtain the permissions set in the parent folder and set them to the file or folder being created\n+    OpenCGAResult<Map<String, List<String>>> allFileAcls = authorizationManager.getAllFileAcls(studyId, parentFileId, userId, false);\n+    // Propagate ACLs\n+    if (allFileAcls.getNumResults() > 0) {\n+      authorizationManager.replicateAcls(studyId, Arrays.asList(queryResult.first().getUid()), allFileAcls.getResults().get(0),\n+          Enums.Resource.FILE);\n+    }\n+\n+    matchUpVariantFiles(study.getFqn(), queryResult.getResults(), sessionId);\n+\n+    return queryResult;\n+  }\n+\n+  private OpenCGAResult<File> create(Study study, File file, boolean parents, String content, QueryOptions options, String sessionId)\n+      throws CatalogException {\n+    validateNewFile(study, file, sessionId, false);\n+\n+    IOManager ioManager;\n+    try {\n+      ioManager = ioManagerFactory.get(file.getUri());\n+    } catch (IOException e) {\n+      throw CatalogIOException.ioManagerException(file.getUri(), e);\n+    }\n+    if (file.getType() == File.Type.FILE && StringUtils.isNotEmpty(content)) {\n+      // We set parents to true because the file has been successfully registered, which means the directories are already registered\n+      // in catalog\n+      ioManager.createDirectory(Paths.get(file.getUri()).getParent().toUri(), true);\n+      InputStream inputStream = new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8));\n+      ioManager.copy(inputStream, file.getUri());\n+    }\n+\n+    List<Sample> nonExistingSamples = new LinkedList<>();\n+    List<Sample> existingSamples = new LinkedList<>();\n+    if (file.getType() == File.Type.FILE && ioManager.exists(file.getUri())) {\n+      new FileMetadataReader(catalogManager).addMetadataInformation(study.getFqn(), file);\n+      validateNewSamples(study, file, existingSamples, nonExistingSamples, sessionId);\n+    }\n+\n+    OpenCGAResult<File> result;\n+    try {\n+      result = register(study, file, existingSamples, nonExistingSamples, parents, options, sessionId);\n+    } catch (CatalogException e) {\n+      if (file.getType() == File.Type.FILE && StringUtils.isNotEmpty(content)) {\n+        ioManager.deleteFile(file.getUri());\n+      }\n+      throw new CatalogException(\"Error registering file: \" + e.getMessage(), e);\n+    }\n+\n+    return result;\n+  }\n+\n+  private void validateNewSamples(Study study, File file, List<Sample> existingSamples, List<Sample> nonExistingSamples, String sessionId)\n+      throws CatalogException {\n+    if (file.getSampleIds() == null || file.getSampleIds().isEmpty()) {\n+      return;\n+    }\n+\n+    String userId = catalogManager.getUserManager().getUserId(sessionId);\n+\n+    InternalGetDataResult<Sample> sampleResult = catalogManager.getSampleManager().internalGet(study.getUid(), file.getSampleIds(),\n+        SampleManager.INCLUDE_SAMPLE_IDS, userId, true);\n+\n+    existingSamples.addAll(sampleResult.getResults());\n+    for (InternalGetDataResult<Sample>.Missing missing : sampleResult.getMissing()) {\n+      Sample sample = new Sample().setId(missing.getId());\n+      catalogManager.getSampleManager().validateNewSample(study, sample, userId);\n+      nonExistingSamples.add(sample);\n+    }\n+  }\n+\n+  /**\n+   * Upload a file in Catalog.\n+   *\n+   * @param studyStr          study where the file will be uploaded.\n+   * @param fileInputStream   Input stream of the file to be uploaded.\n+   * @param file              File object containing at least the basic metadata necessary for a successful upload: path\n+   * @param overwrite         Overwrite the current file if any.\n+   * @param parents           boolean indicating whether unexisting parent folders should also be created automatically.\n+   * @param calculateChecksum boolean indicating whether to calculate the checksum of the uploaded file.\n+   * @param token             session id of the user performing the upload.\n+   * @return a OpenCGAResult with the file uploaded.\n+   * @throws CatalogException if the user does not have permissions or any other unexpected issue happens.\n+   */\n+  public OpenCGAResult<File> upload(String studyStr, InputStream fileInputStream, File file, boolean overwrite, boolean parents,\n+                                    boolean calculateChecksum, String token) throws CatalogException {\n+    // Check basic parameters\n+    ParamUtils.checkObj(fileInputStream, \"fileInputStream\");\n+\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyStr\", studyStr)\n+        .append(\"file\", file)\n+        .append(\"overwrite\", overwrite)\n+        .append(\"parents\", parents)\n+        .append(\"calculateChecksum\", calculateChecksum)\n+        .append(\"token\", token);\n+    try {\n+      validateNewFile(study, file, token, overwrite);\n+\n+      File overwrittenFile = null;\n+      Query query = new Query()\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+          .append(FileDBAdaptor.QueryParams.PATH.key(), file.getPath());\n+      OpenCGAResult<File> fileDataResult = fileDBAdaptor.get(query, QueryOptions.empty());\n+      if (fileDataResult.getNumResults() > 0) {\n+        if (overwrite) {\n+          overwrittenFile = fileDataResult.first();\n         } else {\n-            // The file could not be found or the user does not have permissions to see it\n-            // Check if the file can be found without adding the user restriction\n-            OpenCGAResult<File> resultsNoCheck = fileDBAdaptor.get(queryCopy, queryOptions);\n-            if (resultsNoCheck.getNumResults() == correctedFileList.size()) {\n-                throw new CatalogAuthorizationException(\"Permission denied. \" + user + \" is not allowed to see some or none of the files.\");\n-            }\n-            if (canBeSearchedAsName) {\n-                // The last query was performed by name, so we now search by path\n-                queryCopy = query == null ? new Query() : new Query(query);\n-                queryCopy.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n-                        .append(FileDBAdaptor.QueryParams.PATH.key(), correctedFileList);\n-                resultsNoCheck = fileDBAdaptor.get(queryCopy, queryOptions);\n-                if (resultsNoCheck.getNumResults() == correctedFileList.size()) {\n-                    throw new CatalogAuthorizationException(\"Permission denied. \" + user + \" is not allowed to see some or none of the \"\n-                            + \"files.\");\n-                }\n-            }\n-\n-            throw CatalogException.notFound(\"files\", getMissingFields(uniqueList, fileDataResult.getResults(), fileStringFunction));\n+          throw new CatalogException(\"Path \" + file.getPath() + \" already in use\");\n+        }\n+      }\n+\n+      OpenCGAResult<File> parentFolders = getParents(study.getUid(), file.getPath(), false, QueryOptions.empty());\n+      if (parentFolders.getNumResults() == 0) {\n+        // There always must be at least the root folder\n+        throw new CatalogException(\"Unexpected error happened.\");\n+      }\n+\n+      // Check permissions over the most internal path\n+      authorizationManager.checkFilePermission(study.getUid(), parentFolders.first().getUid(), userId,\n+          FileAclEntry.FilePermissions.UPLOAD);\n+      authorizationManager.checkFilePermission(study.getUid(), parentFolders.first().getUid(), userId,\n+          FileAclEntry.FilePermissions.WRITE);\n+\n+      // We obtain the basic studyPath where we will upload the file temporarily\n+      java.nio.file.Path studyPath = Paths.get(study.getUri());\n+\n+      IOManager ioManager;\n+      try {\n+        ioManager = ioManagerFactory.get(file.getUri());\n+      } catch (IOException e) {\n+        throw CatalogIOException.ioManagerException(file.getUri(), e);\n+      }\n+      // We attempt to create it first because it may be that the parent directories were not created because they don't contain any\n+      // files yet\n+\n+      if (parentFolders.first().getType() == File.Type.FILE && !overwrite) {\n+        throw new CatalogException(\"Cannot upload file in '\" + file.getPath() + \"'. \" + parentFolders.first().getPath()\n+            + \"' is already an existing file path.\");\n+      } else if (parentFolders.first().getType() == File.Type.DIRECTORY) {\n+        ioManager.createDirectory(parentFolders.first().getUri(), true);\n+      }\n+      ioManager.checkWritableUri(parentFolders.first().getUri());\n+\n+      java.nio.file.Path tempFilePath = studyPath.resolve(\"tmp_\" + file.getName()).resolve(file.getName());\n+      URI tempDirectory = tempFilePath.getParent().toUri();\n+      logger.info(\"Uploading file... Temporal file path: {}\", tempFilePath.toString());\n+\n+      // Create the temporal directory and upload the file\n+      try {\n+        if (!ioManager.exists(tempFilePath.getParent().toUri())) {\n+          logger.debug(\"Creating temporal folder: {}\", tempFilePath.getParent());\n+          ioManager.createDirectory(tempDirectory, true);\n+        }\n+\n+        // Start uploading the file to the temporal directory\n+        // Upload the file to a temporary folder\n+        ioManager.copy(fileInputStream, tempFilePath.toUri());\n+      } catch (Exception e) {\n+        logger.error(\"Error uploading file {}\", file.getName(), e);\n+\n+        // Clean temporal directory\n+        ioManager.deleteDirectory(tempDirectory);\n+\n+        throw new CatalogException(\"Error uploading file \" + file.getName(), e);\n+      }\n+      URI sourceUri = tempFilePath.toUri();\n+\n+      List<Sample> existingSamples = new LinkedList<>();\n+      List<Sample> nonExistingSamples = new LinkedList<>();\n+\n+      // Move the file from the temporal directory\n+      try {\n+        // Create the directories where the file will be placed (if they weren't created before)\n+        ioManager.createDirectory(Paths.get(file.getUri()).getParent().toUri(), true);\n+\n+        String checksum = null;\n+        if (calculateChecksum) {\n+          checksum = ioManager.calculateChecksum(sourceUri);\n+        }\n+        if (overwrite) {\n+          ioManager.move(sourceUri, file.getUri(), StandardCopyOption.REPLACE_EXISTING);\n+        } else {\n+          ioManager.move(sourceUri, file.getUri());\n+        }\n+        if (calculateChecksum && !checksum.equals(ioManager.calculateChecksum(file.getUri()))) {\n+          throw new CatalogIOException(\"Error moving file from \" + sourceUri + \" to \" + file.getUri());\n         }\n-    }\n \n-    private OpenCGAResult<File> getFile(long studyUid, String fileUuid, QueryOptions options) throws CatalogException {\n-        Query query = new Query()\n-                .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n-                .append(FileDBAdaptor.QueryParams.UUID.key(), fileUuid);\n-        return fileDBAdaptor.get(query, options);\n-    }\n+        // Remove the temporal directory\n+        ioManager.deleteDirectory(tempDirectory);\n+\n+        file.setChecksum(checksum);\n \n-    public URI getUri(File file) throws CatalogException {\n-        ParamUtils.checkObj(file, \"File\");\n-        if (file.getUri() != null) {\n-            return file.getUri();\n+        // Improve metadata information and extract samples if any\n+        new FileMetadataReader(catalogManager).addMetadataInformation(study.getFqn(), file);\n+        validateNewSamples(study, file, existingSamples, nonExistingSamples, token);\n+      } catch (CatalogException e) {\n+        ioManager.deleteDirectory(tempDirectory);\n+        logger.error(\"Upload file: {}\", e.getMessage(), e);\n+        throw new CatalogException(\"Upload file failed. Could not move the content to \" + file.getUri() + \": \" + e.getMessage());\n+      }\n+\n+      // Register the file in catalog\n+      try {\n+        if (overwrittenFile != null) {\n+          // We need to update the existing file document\n+          ObjectMap params = new ObjectMap();\n+          QueryOptions queryOptions = new QueryOptions();\n+\n+          params.put(FileDBAdaptor.QueryParams.SIZE.key(), file.getSize());\n+          params.put(FileDBAdaptor.QueryParams.URI.key(), file.getUri());\n+          params.put(FileDBAdaptor.QueryParams.EXTERNAL.key(), file.isExternal());\n+          params.put(FileDBAdaptor.QueryParams.INTERNAL_STATUS_NAME.key(), FileStatus.READY);\n+          params.put(FileDBAdaptor.QueryParams.CHECKSUM.key(), file.getChecksum());\n+\n+          if (file.getSampleIds() != null && !file.getSampleIds().isEmpty()) {\n+            params.put(FileDBAdaptor.QueryParams.SAMPLE_IDS.key(), file.getSampleIds());\n+\n+            // Set new samples\n+            Map<String, Object> actionMap = new HashMap<>();\n+            actionMap.put(FileDBAdaptor.QueryParams.SAMPLE_IDS.key(), ParamUtils.UpdateAction.SET.name());\n+            queryOptions.put(Constants.ACTIONS, actionMap);\n+          }\n+          if (!file.getAttributes().isEmpty()) {\n+            Map<String, Object> attributes = overwrittenFile.getAttributes();\n+            attributes.putAll(file.getAttributes());\n+            params.put(FileDBAdaptor.QueryParams.ATTRIBUTES.key(), attributes);\n+          }\n+          if (!file.getStats().isEmpty()) {\n+            Map<String, Object> stats = overwrittenFile.getStats();\n+            stats.putAll(file.getStats());\n+            params.put(FileDBAdaptor.QueryParams.STATS.key(), stats);\n+          }\n+\n+          fileDBAdaptor.update(overwrittenFile.getUid(), params, null, queryOptions);\n         } else {\n-            OpenCGAResult<File> fileDataResult = fileDBAdaptor.get(file.getUid(), INCLUDE_STUDY_URI);\n-            if (fileDataResult.getNumResults() == 0) {\n-                throw new CatalogException(\"File \" + file.getUid() + \" not found\");\n-            }\n-            return fileDataResult.first().getUri();\n-        }\n+          // We need to register a new file\n+          register(study, file, existingSamples, nonExistingSamples, parents, QueryOptions.empty(), token);\n+        }\n+      } catch (CatalogException e) {\n+        ioManager.deleteFile(file.getUri());\n+        logger.error(\"Upload file: {}\", e.getMessage(), e);\n+        throw new CatalogException(\"Upload file failed. Could not register the file in the DB: \" + e.getMessage());\n+      }\n+\n+      auditManager.auditCreate(userId, Enums.Action.UPLOAD, Enums.Resource.FILE, file.getId(), file.getUuid(),\n+          study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return fileDBAdaptor.get(query, QueryOptions.empty());\n+    } catch (CatalogException e) {\n+      auditManager.auditCreate(userId, Enums.Action.UPLOAD, Enums.Resource.FILE, file.getId(), \"\", study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Moves a file not yet registered in OpenCGA from origin to finalDestiny in the file system and then registers it in the study.\n+   *\n+   * @param studyStr      Study to which the file will belong.\n+   * @param fileSource    Current location of the file (file system).\n+   * @param folderDestiny Directory where the file needs to be moved (file system).\n+   * @param path          Directory in catalog where the file will be registered (catalog).\n+   * @param token         Token of the user.\n+   * @return An OpenCGAResult with the file registry after moving it to the final destination.\n+   * @throws CatalogException CatalogException.\n+   */\n+  public OpenCGAResult<File> moveAndRegister(String studyStr, Path fileSource, @Nullable Path folderDestiny, @Nullable String path,\n+                                             String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyStr\", studyStr)\n+        .append(\"fileSource\", fileSource)\n+        .append(\"folderDestiny\", folderDestiny)\n+        .append(\"path\", path)\n+        .append(\"token\", token);\n+\n+    try {\n+      try {\n+        FileUtils.checkFile(fileSource);\n+      } catch (IOException e) {\n+        throw new CatalogException(\"File '\" + fileSource + \"' not found\", e);\n+      }\n+      String fileName = fileSource.toFile().getName();\n+\n+      if (folderDestiny == null && path == null) {\n+        throw new CatalogException(\"'folderDestiny' and 'path' cannot be both null.\");\n+      }\n+\n+      boolean external = false;\n+      if (folderDestiny == null) {\n+        if (path.startsWith(\"/\")) {\n+          path = path.substring(1);\n+        }\n+        File parentFolder = getParents(study.getUid(), path, false, INCLUDE_FILE_URI_PATH).first();\n+\n+        // We get the relative path\n+        String relativePath = Paths.get(parentFolder.getPath()).relativize(Paths.get(path)).toString();\n+        folderDestiny = Paths.get(parentFolder.getUri()).resolve(relativePath);\n+      }\n+\n+      if (folderDestiny.toString().startsWith(study.getUri().getPath())) {\n+        if (StringUtils.isNotEmpty(path)) {\n+          String myPath = path;\n+          if (!myPath.endsWith(\"/\")) {\n+            myPath += \"/\";\n+          }\n+          myPath += fileName;\n+\n+          String relativePath = Paths.get(study.getUri().getPath()).relativize(folderDestiny.resolve(fileName)).toString();\n+          if (!relativePath.equals(myPath)) {\n+            throw new CatalogException(\"Destination uri within the workspace and path do not match\");\n+          }\n+        } else {\n+          //Set the path to whichever path would corresponding based on the workspace uri\n+          path = Paths.get(study.getUri().getPath()).relativize(folderDestiny).toString();\n+        }\n+\n+        File parentFolder = getParents(study.getUid(), path, false, INCLUDE_FILE_URI_PATH).first();\n+        authorizationManager.checkFilePermission(study.getUid(), parentFolder.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+      } else {\n+        // It will be moved to an external folder. Only admins can move to that directory\n+        if (!authorizationManager.isOwnerOrAdmin(study.getUid(), userId)) {\n+          throw new CatalogAuthorizationException(\"Only owners or administrative users are allowed to move to folders different \"\n+              + \"than the main OpenCGA workspace\");\n+        }\n+        external = true;\n+      }\n+\n+      String filePath = path;\n+      if (!filePath.endsWith(\"/\")) {\n+        filePath += \"/\";\n+      }\n+      filePath += fileName;\n+      // Check the path is not in use\n+      Query query = new Query()\n+          .append(FileDBAdaptor.QueryParams.PATH.key(), filePath)\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+      if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n+        throw new CatalogException(\"Path '\" + filePath + \"' already in use in OpenCGA\");\n+      }\n+\n+      URI folderDestinyUri = folderDestiny.toUri();\n+      IOManager ioManager = null;\n+      try {\n+        ioManager = ioManagerFactory.get(folderDestinyUri);\n+      } catch (IOException e) {\n+        throw CatalogIOException.ioManagerException(folderDestinyUri, e);\n+      }\n+      // Check uri-path\n+      try {\n+        if (!ioManager.exists(folderDestinyUri)) {\n+          ioManager.createDirectory(folderDestinyUri, true);\n+        }\n+\n+        ioManager.move(fileSource.toUri(), folderDestiny.resolve(fileName).toUri(), StandardCopyOption.REPLACE_EXISTING);\n+      } catch (CatalogIOException e) {\n+        throw new CatalogException(\"Unexpected error. Could not move file from '\" + fileSource + \"' to '\" + folderDestiny + \"'\", e);\n+      }\n+\n+      OpenCGAResult<File> result;\n+      if (external) {\n+        result = link(study.getFqn(), folderDestiny.resolve(fileName).toUri(), path, new ObjectMap(\"parents\", true), token);\n+      } else {\n+        result = createFile(study.getFqn(), filePath, \"\", true, null, token);\n+      }\n+\n+      auditManager.audit(userId, Enums.Action.MOVE_AND_REGISTER, Enums.Resource.FILE, result.first().getId(),\n+          result.first().getUuid(), study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      return result;\n+    } catch (CatalogException e) {\n+      auditManager.audit(userId, Enums.Action.MOVE_AND_REGISTER, Enums.Resource.FILE, \"\", \"\", study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  @Deprecated\n+  public OpenCGAResult<File> get(Long fileId, QueryOptions options, String sessionId) throws CatalogException {\n+    return get(null, String.valueOf(fileId), options, sessionId);\n+  }\n+\n+  public OpenCGAResult<FileTree> getTree(@Nullable String studyId, String fileId, int maxDepth, QueryOptions options, String token)\n+      throws CatalogException {\n+    long startTime = System.currentTimeMillis();\n+\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, userId);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"fileId\", fileId)\n+        .append(\"options\", options)\n+        .append(\"maxDepth\", maxDepth)\n+        .append(\"token\", token);\n+    try {\n+      if (maxDepth < 1) {\n+        throw new CatalogException(\"Depth cannot be lower than 1\");\n+      }\n+      if (options.containsKey(QueryOptions.INCLUDE)) {\n+        // Add type and path to the queryOptions\n+        List<String> asStringListOld = options.getAsStringList(QueryOptions.INCLUDE);\n+        Set<String> newList = new HashSet<>(asStringListOld);\n+        newList.add(FileDBAdaptor.QueryParams.TYPE.key());\n+        newList.add(FileDBAdaptor.QueryParams.PATH.key());\n+        options.put(QueryOptions.INCLUDE, new ArrayList<>(newList));\n+      } else {\n+        if (options.containsKey(QueryOptions.EXCLUDE)) {\n+          // Avoid excluding type and path from queryoptions\n+          List<String> asStringListOld = options.getAsStringList(QueryOptions.EXCLUDE);\n+          Set<String> newList = new HashSet<>(asStringListOld);\n+          newList.remove(FileDBAdaptor.QueryParams.TYPE.key());\n+          newList.remove(FileDBAdaptor.QueryParams.PATH.key());\n+          if (newList.size() > 0) {\n+            options.put(QueryOptions.EXCLUDE, new ArrayList<>(newList));\n+          } else {\n+            options.remove(QueryOptions.EXCLUDE);\n+          }\n+        }\n+      }\n+\n+      File file = internalGet(study.getUid(), fileId, options, userId).first();\n+\n+      // Check if the id does not correspond to a directory\n+      if (!file.getType().equals(File.Type.DIRECTORY)) {\n+        throw new CatalogException(\"The file introduced is not a directory.\");\n+      }\n+\n+      // Build regex to obtain all the files/directories up to certain depth\n+      String baseRegex = \"([^\\\\/]+)\";\n+      StringBuilder pathRegex = new StringBuilder(baseRegex);\n+      for (int i = 1; i < maxDepth; i++) {\n+        pathRegex.append(\"[\\\\/]?\").append(baseRegex).append(\"?\");\n+      }\n+      // It can end in a directory or not\n+      pathRegex.append(\"[\\\\/]?$\");\n+      Query query = new Query(FileDBAdaptor.QueryParams.PATH.key(), \"~^\" + file.getPath() + pathRegex.toString());\n+      // We want to know beforehand the number of matches we will get to be able to abort before iterating\n+      options.put(QueryOptions.COUNT, true);\n+\n+      FileTreeBuilder treeBuilder = new FileTreeBuilder(file);\n+      int numResults;\n+      try (DBIterator<File> iterator = fileDBAdaptor.iterator(study.getUid(), query, options, userId)) {\n+        if (iterator.getNumMatches() > MAX_LIMIT) {\n+          throw new CatalogException(\"Please, decrease the maximum depth. More than \" + MAX_LIMIT + \" files found\");\n+        }\n+        numResults = (int) iterator.getNumMatches() + 1;\n+        while (iterator.hasNext()) {\n+          treeBuilder.add(iterator.next());\n+        }\n+      }\n+      FileTree fileTree = treeBuilder.toFileTree();\n+      int dbTime = (int) (System.currentTimeMillis() - startTime);\n+\n+      auditManager.audit(userId, Enums.Action.TREE, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return new OpenCGAResult<>(dbTime, Collections.emptyList(), numResults, Collections.singletonList(fileTree), numResults);\n+    } catch (CatalogException e) {\n+      auditManager.audit(userId, Enums.Action.TREE, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  public OpenCGAResult<File> getFilesFromFolder(String folderStr, String studyStr, QueryOptions options, String sessionId)\n+      throws CatalogException {\n+    ParamUtils.checkObj(folderStr, \"folder\");\n+    String userId = userManager.getUserId(sessionId);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    File file = internalGet(study.getUid(), folderStr, new QueryOptions(QueryOptions.INCLUDE,\n+        Arrays.asList(FileDBAdaptor.QueryParams.PATH.key(), FileDBAdaptor.QueryParams.TYPE.key())), userId).first();\n+\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    if (!file.getType().equals(File.Type.DIRECTORY)) {\n+      throw new CatalogDBException(\"File {path:'\" + file.getPath() + \"'} is not a folder.\");\n+    }\n+    Query query = new Query(FileDBAdaptor.QueryParams.DIRECTORY.key(), file.getPath());\n+    return search(studyStr, query, options, sessionId);\n+  }\n+\n+  @Override\n+  public DBIterator<File> iterator(String studyStr, Query query, QueryOptions options, String sessionId) throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    String userId = userManager.getUserId(sessionId);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    Query finalQuery = new Query(query);\n+    // Fix query if it contains any annotation\n+    AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n+    AnnotationUtils.fixQueryOptionAnnotation(options);\n+    fixQueryObject(study, finalQuery, userId);\n+    finalQuery.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+\n+    return fileDBAdaptor.iterator(study.getUid(), query, options, userId);\n+  }\n+\n+  @Override\n+  public OpenCGAResult<File> search(String studyId, Query query, QueryOptions options, String token) throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n+    Query finalQuery = new Query(query);\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"query\", new Query(query))\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+    try {\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n+      AnnotationUtils.fixQueryOptionAnnotation(options);\n+      fixQueryObject(study, finalQuery, userId);\n+      finalQuery.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+\n+      OpenCGAResult<File> queryResult = fileDBAdaptor.get(study.getUid(), finalQuery, options, userId);\n+      auditManager.auditSearch(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return queryResult;\n+    } catch (CatalogException e) {\n+      auditManager.auditSearch(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public OpenCGAResult<?> distinct(String studyId, String field, Query query, String token) throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n+\n+    String userId = userManager.getUserId(token);\n+    Study study = catalogManager.getStudyManager().resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"field\", new Query(query))\n+        .append(\"query\", new Query(query))\n+        .append(\"token\", token);\n+    try {\n+      FileDBAdaptor.QueryParams param = FileDBAdaptor.QueryParams.getParam(field);\n+      if (param == null) {\n+        throw new CatalogException(\"Unknown '\" + field + \"' parameter.\");\n+      }\n+      Class<?> clazz = getTypeClass(param.type());\n+\n+      fixQueryObject(study, query, userId);\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, query);\n+\n+      query.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+      OpenCGAResult<?> result = fileDBAdaptor.distinct(study.getUid(), field, query, userId, clazz);\n+\n+      auditManager.auditDistinct(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return result;\n+    } catch (CatalogException e) {\n+      auditManager.auditDistinct(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  void fixQueryObject(Study study, Query query, String user) throws CatalogException {\n+    super.fixQueryObject(query);\n+\n+    if (StringUtils.isNotEmpty(query.getString(FileDBAdaptor.QueryParams.ID.key()))) {\n+      OpenCGAResult<File> queryResult = internalGet(study.getUid(), query.getAsStringList(FileDBAdaptor.QueryParams.ID.key()),\n+          INCLUDE_FILE_IDS, user, true);\n+      query.remove(FileDBAdaptor.QueryParams.ID.key());\n+      query.put(FileDBAdaptor.QueryParams.UID.key(), queryResult.getResults().stream().map(File::getUid)\n+          .collect(Collectors.toList()));\n+    }\n+\n+    validateQueryPath(query, FileDBAdaptor.QueryParams.PATH.key());\n+    validateQueryPath(query, FileDBAdaptor.QueryParams.DIRECTORY.key());\n+\n+    // Convert jobId=NONE to jobId=\"\"\n+    if (StringUtils.isNotEmpty(query.getString(FileDBAdaptor.QueryParams.JOB_ID.key()))\n+        && \"NONE\".equalsIgnoreCase(query.getString(FileDBAdaptor.QueryParams.JOB_ID.key()))) {\n+      query.put(FileDBAdaptor.QueryParams.JOB_ID.key(), \"\");\n     }\n \n-    public Study getStudy(File file, String sessionId) throws CatalogException {\n-        ParamUtils.checkObj(file, \"file\");\n-        ParamUtils.checkObj(sessionId, \"session id\");\n+//        // The samples introduced could be either ids or names. As so, we should use the smart resolutor to do this.\n+//        if (StringUtils.isNotEmpty(query.getString(FileDBAdaptor.QueryParams.SAMPLES.key()))) {\n+//            OpenCGAResult<Sample> sampleDataResult = catalogManager.getSampleManager().internalGet(study.getUid(),\n+//                    query.getAsStringList(FileDBAdaptor.QueryParams.SAMPLES.key()), SampleManager.INCLUDE_SAMPLE_IDS, user, true);\n+//            query.put(FileDBAdaptor.QueryParams.SAMPLE_UIDS.key(), sampleDataResult.getResults().stream().map(Sample::getUid)\n+//                    .collect(Collectors.toList()));\n+//            query.remove(FileDBAdaptor.QueryParams.SAMPLES.key());\n+//        }\n+  }\n+\n+  private void validateQueryPath(Query query, String key) {\n+    if (StringUtils.isNotEmpty(query.getString(key))) {\n+      // Path never starts with /\n+      List<String> pathList = query.getAsStringList(key);\n+      List<String> finalPathList = new ArrayList<>(pathList.size());\n+\n+      for (String path : pathList) {\n+        String auxPath = path;\n+        if (auxPath.startsWith(\"/\")) {\n+          auxPath = auxPath.substring(1);\n+        }\n+        if (FileDBAdaptor.QueryParams.DIRECTORY.key().equals(key) && !auxPath.endsWith(\"/\")) {\n+          auxPath = auxPath + \"/\";\n+        }\n+        finalPathList.add(auxPath);\n+      }\n+\n+      query.put(key, StringUtils.join(finalPathList, \",\"));\n+    }\n+  }\n \n-        if (file.getStudyUid() <= 0) {\n-            throw new CatalogException(\"Missing study uid field in file\");\n-        }\n+  @Override\n+  public OpenCGAResult<File> count(String studyId, Query query, String token) throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n \n-        String user = userManager.getUserId(sessionId);\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n \n-        Query query = new Query(StudyDBAdaptor.QueryParams.UID.key(), file.getStudyUid());\n-        OpenCGAResult<Study> studyDataResult = studyDBAdaptor.get(query, QueryOptions.empty(), user);\n-        if (studyDataResult.getNumResults() == 1) {\n-            return studyDataResult.first();\n-        } else {\n-            authorizationManager.checkCanViewStudy(file.getStudyUid(), user);\n-            throw new CatalogException(\"Incorrect study uid\");\n-        }\n-    }\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"query\", new Query(query))\n+        .append(\"token\", token);\n+    try {\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, query);\n+      // The samples introduced could be either ids or names. As so, we should use the smart resolutor to do this.\n+      fixQueryObject(study, query, userId);\n \n-    public void matchUpVariantFiles(String studyStr, List<File> transformedFiles, String sessionId) throws CatalogException {\n-        String userId = userManager.getUserId(sessionId);\n-        Study study = studyManager.resolveId(studyStr, userId);\n+      query.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+      OpenCGAResult<Long> queryResultAux = fileDBAdaptor.count(query, userId);\n \n-        for (File transformedFile : transformedFiles) {\n-            authorizationManager.checkFilePermission(study.getUid(), transformedFile.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n-            String variantPathName = getMainVariantFile(transformedFile.getPath());\n-            if (variantPathName == null) {\n-                // Skip the file.\n-                logger.debug(\"The file {} is not a variant transformed file\", transformedFile.getName());\n-                continue;\n-            }\n+      auditManager.auditCount(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n \n-            // Search in the same path\n-            logger.info(\"Looking for vcf file in path {}\", variantPathName);\n-            Query query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                    .append(FileDBAdaptor.QueryParams.PATH.key(), variantPathName)\n-                    .append(FileDBAdaptor.QueryParams.BIOFORMAT.key(), File.Bioformat.VARIANT);\n-\n-            List<File> fileList = fileDBAdaptor.get(query, new QueryOptions()).getResults();\n-\n-            if (fileList.isEmpty()) {\n-                // Search by name in the whole study\n-                String variantFileName = getMainVariantFile(transformedFile.getName());\n-                logger.info(\"Looking for vcf file by name {}\", variantFileName);\n-                query = new Query()\n-                        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                        .append(FileDBAdaptor.QueryParams.NAME.key(), variantFileName)\n-                        .append(FileDBAdaptor.QueryParams.BIOFORMAT.key(), File.Bioformat.VARIANT);\n-                fileList = new ArrayList<>(fileDBAdaptor.get(query, new QueryOptions()).getResults());\n-\n-                // In case of finding more than one file, try to find the proper one.\n-                if (fileList.size() > 1) {\n-                    // Discard files already with a transformed file.\n-                    fileList.removeIf(file -> file.getInternal().getIndex() != null\n-                            && file.getInternal().getIndex().getTransformedFile() != null\n-                            && file.getInternal().getIndex().getTransformedFile().getId() != transformedFile.getUid());\n-                }\n-                if (fileList.size() > 1) {\n-                    // Discard files not transformed or indexed.\n-                    fileList.removeIf(file -> file.getInternal().getIndex() == null\n-                            || file.getInternal().getIndex().getStatus() == null\n-                            || file.getInternal().getIndex().getStatus().getName() == null\n-                            || file.getInternal().getIndex().getStatus().getName().equals(FileIndex.IndexStatus.NONE));\n-                }\n-            }\n+      return new OpenCGAResult<>(queryResultAux.getTime(), queryResultAux.getEvents(), 0, Collections.emptyList(),\n+          queryResultAux.getNumMatches());\n+    } catch (CatalogException e) {\n+      auditManager.auditCount(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public OpenCGAResult delete(String studyStr, List<String> fileIds, ObjectMap params, String token) throws CatalogException {\n+    return delete(studyStr, fileIds, params, false, token);\n+  }\n+\n+  public OpenCGAResult delete(String studyStr, List<String> fileIds, ObjectMap params, boolean ignoreException, String token)\n+      throws CatalogException {\n+    String userId = catalogManager.getUserManager().getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n+\n+    String operationUuid = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"fileIds\", fileIds)\n+        .append(\"params\", params)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"token\", token);\n+\n+    // We need to avoid processing subfolders or subfiles of an already processed folder independently\n+    Set<String> processedPaths = new HashSet<>();\n+    boolean physicalDelete = params.getBoolean(Constants.SKIP_TRASH, false);\n+\n+    auditManager.initAuditBatch(operationUuid);\n+    OpenCGAResult<File> result = OpenCGAResult.empty();\n+    for (String id : fileIds) {\n+      String fileId = id;\n+      String fileUuid = \"\";\n+\n+      try {\n+        OpenCGAResult<File> internalResult = internalGet(study.getUid(), id, INCLUDE_FILE_URI_PATH, userId);\n+        if (internalResult.getNumResults() == 0) {\n+          throw new CatalogException(\"File '\" + id + \"' not found\");\n+        }\n+        File file = internalResult.first();\n+        // We set the proper values for the audit\n+        fileId = file.getId();\n+        fileUuid = file.getUuid();\n \n+        if (subpathInPath(file.getPath(), processedPaths)) {\n+          // We skip this folder because it is a subfolder or subfile within an already processed folder\n+          continue;\n+        }\n \n-            if (fileList.size() != 1) {\n-                // VCF file not found\n-                logger.warn(\"The vcf file corresponding to the file \" + transformedFile.getName() + \" could not be found\");\n-                continue;\n-            }\n-            File vcf = fileList.get(0);\n-\n-            // Look for the json file. It should be in the same directory where the transformed file is.\n-            String jsonPathName = getVariantMetadataFile(transformedFile.getPath());\n-            query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                    .append(FileDBAdaptor.QueryParams.PATH.key(), jsonPathName)\n-                    .append(FileDBAdaptor.QueryParams.FORMAT.key(), File.Format.JSON);\n-            fileList = fileDBAdaptor.get(query, new QueryOptions()).getResults();\n-            if (fileList.size() != 1) {\n-                // Skip. This should not ever happen\n-                logger.warn(\"The json file corresponding to the file \" + transformedFile.getName() + \" could not be found\");\n-                continue;\n-            }\n-            File json = fileList.get(0);\n-\n-            /* Update relations */\n-            FileRelatedFile producedFromRelation = new FileRelatedFile(vcf, FileRelatedFile.Relation.PRODUCED_FROM);\n-\n-            // Update json file\n-            logger.debug(\"Updating json relation\");\n-            List<FileRelatedFile> relatedFiles = ParamUtils.defaultObject(json.getRelatedFiles(), ArrayList::new);\n-            // Do not add twice the same relation\n-            if (!relatedFiles.contains(producedFromRelation)) {\n-                relatedFiles.add(producedFromRelation);\n-                ObjectMap params = new ObjectMap(FileDBAdaptor.QueryParams.RELATED_FILES.key(), relatedFiles);\n-                fileDBAdaptor.update(json.getUid(), params, QueryOptions.empty());\n-            }\n+        OpenCGAResult updateResult = delete(study, file, physicalDelete, userId);\n+        result.append(updateResult);\n+\n+        // We store the processed path as is\n+        if (file.getType() == File.Type.DIRECTORY) {\n+          processedPaths.add(file.getPath());\n+        }\n \n-            // Update transformed file\n-            logger.debug(\"Updating transformed relation\");\n-            relatedFiles = ParamUtils.defaultObject(transformedFile.getRelatedFiles(), ArrayList::new);\n-            // Do not add twice the same relation\n-            if (!relatedFiles.contains(producedFromRelation)) {\n-                relatedFiles.add(producedFromRelation);\n-                transformedFile.setRelatedFiles(relatedFiles);\n-                ObjectMap params = new ObjectMap(FileDBAdaptor.QueryParams.RELATED_FILES.key(), relatedFiles);\n-                fileDBAdaptor.update(transformedFile.getUid(), params, QueryOptions.empty());\n-            }\n+        auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      } catch (CatalogException e) {\n+        Event event = new Event(Event.Type.ERROR, fileId, e.getMessage());\n+        result.getEvents().add(event);\n \n-            // Update vcf file\n-            logger.debug(\"Updating vcf relation\");\n-            FileIndex index = vcf.getInternal().getIndex();\n-            if (index.getTransformedFile() == null) {\n-                index.setTransformedFile(new FileIndex.TransformedFile(transformedFile.getUid(), json.getUid()));\n-            }\n-            String status = FileIndex.IndexStatus.NONE;\n-            if (vcf.getInternal().getIndex() != null && vcf.getInternal().getIndex().getStatus() != null\n-                    && vcf.getInternal().getIndex().getStatus().getName() != null) {\n-                status = vcf.getInternal().getIndex().getStatus().getName();\n-            }\n-            if (FileIndex.IndexStatus.NONE.equals(status)) {\n-                // If TRANSFORMED, TRANSFORMING, etc, do not modify the index status\n-                index.setStatus(new FileIndex.IndexStatus(FileIndex.IndexStatus.TRANSFORMED, \"Found transformed file\"));\n-            }\n-            ObjectMap params = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), index);\n-            fileDBAdaptor.update(vcf.getUid(), params, QueryOptions.empty());\n+        logger.error(\"Could not delete file {}: {}\", fileId, e.getMessage(), e);\n+        auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, fileId, fileUuid, study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      }\n+    }\n+    auditManager.finishAuditBatch(operationUuid);\n+\n+    return endResult(result, ignoreException);\n+  }\n+\n+  @Override\n+  public OpenCGAResult delete(String studyStr, Query query, ObjectMap params, String token) throws CatalogException {\n+    return delete(studyStr, query, params, false, token);\n+  }\n+\n+  public OpenCGAResult delete(String studyStr, Query query, ObjectMap params, boolean ignoreException, String token)\n+      throws CatalogException {\n+    Query finalQuery = new Query(ParamUtils.defaultObject(query, Query::new));\n+    params = ParamUtils.defaultObject(params, ObjectMap::new);\n+\n+    OpenCGAResult dataResult = OpenCGAResult.empty();\n \n-            // Update variant stats\n-            Path statsFile = Paths.get(json.getUri().getRawPath());\n-            try (InputStream is = FileUtils.newInputStream(statsFile)) {\n-                VariantFileMetadata fileMetadata = getDefaultObjectMapper().readValue(is, VariantFileMetadata.class);\n-                VariantSetStats stats = fileMetadata.getStats();\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n \n-                AnnotationSet annotationSet = AvroToAnnotationConverter.convertToAnnotationSet(stats, FILE_VARIANT_STATS_VARIABLE_SET);\n-                catalogManager.getFileManager()\n-                        .update(studyStr, vcf.getPath(), new FileUpdateParams().setAnnotationSets(Collections.singletonList(annotationSet)),\n-                                new QueryOptions(Constants.ACTIONS,\n-                                        Collections.singletonMap(ANNOTATION_SETS, ParamUtils.CompleteUpdateAction.SET)), sessionId);\n+    StopWatch watch = StopWatch.createStarted();\n+    String operationUuid = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n \n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"query\", new Query(query))\n+        .append(\"params\", params)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"token\", token);\n \n-            } catch (IOException e) {\n-                throw new CatalogException(\"Error reading file \\\"\" + statsFile + \"\\\"\", e);\n-            }\n-        }\n-    }\n+    // We try to get an iterator containing all the files to be deleted\n+    DBIterator<File> fileIterator;\n+    try {\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n+      fixQueryObject(study, finalQuery, userId);\n+      finalQuery.append(SampleDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n \n-    public OpenCGAResult<FileIndex> updateFileIndexStatus(File file, String newStatus, String message, String sessionId)\n-            throws CatalogException {\n-        return updateFileIndexStatus(file, newStatus, message, null, sessionId);\n+      fileIterator = fileDBAdaptor.iterator(study.getUid(), finalQuery, INCLUDE_FILE_URI_PATH, userId);\n+    } catch (CatalogException e) {\n+      auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, \"\", \"\", study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      throw e;\n     }\n \n-    public OpenCGAResult<FileIndex> updateFileIndexStatus(File file, String newStatus, String message, Integer release, String token)\n-            throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyDBAdaptor.get(file.getStudyUid(), StudyManager.INCLUDE_STUDY_ID).first();\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"file\", file)\n-                .append(\"newStatus\", newStatus)\n-                .append(\"message\", message)\n-                .append(\"release\", release)\n-                .append(\"token\", token);\n+    // We need to avoid processing subfolders or subfiles of an already processed folder independently\n+    Set<String> processedPaths = new HashSet<>();\n+    boolean physicalDelete = params.getBoolean(Constants.SKIP_TRASH, false);\n \n-        authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+    long numMatches = 0;\n \n-        FileIndex index = file.getInternal().getIndex();\n-        if (index != null) {\n-            if (!FileIndex.IndexStatus.isValid(newStatus)) {\n-                throw new CatalogException(\"The status \" + newStatus + \" is not a valid status.\");\n-            } else {\n-                index.setStatus(new FileIndex.IndexStatus(newStatus, message));\n-            }\n-        } else {\n-            index = new FileIndex(userId, TimeUtils.getTime(), new FileIndex.IndexStatus(newStatus), -1, new ObjectMap());\n-        }\n-        if (release != null) {\n-            if (newStatus.equals(FileIndex.IndexStatus.READY)) {\n-                index.setRelease(release);\n-            }\n-        }\n-        ObjectMap params = null;\n-        try {\n-            params = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), new ObjectMap(getUpdateObjectMapper()\n-                    .writeValueAsString(index)));\n-        } catch (JsonProcessingException e) {\n-            throw new CatalogException(\"Cannot parse index object: \" + e.getMessage(), e);\n-        }\n-        OpenCGAResult update = fileDBAdaptor.update(file.getUid(), params, QueryOptions.empty());\n-        auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n-                auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+    auditManager.initAuditBatch(operationUuid);\n+    while (fileIterator.hasNext()) {\n+      File file = fileIterator.next();\n \n-        return new OpenCGAResult<>(update.getTime(), update.getEvents(), 1, Collections.singletonList(index), 1);\n-    }\n+      if (subpathInPath(file.getPath(), processedPaths)) {\n+        // We skip this folder because it is a subfolder or subfile within an already processed folder\n+        continue;\n+      }\n \n-    @Deprecated\n-    public OpenCGAResult<File> getParents(long fileId, QueryOptions options, String sessionId) throws CatalogException {\n-        OpenCGAResult<File> fileDataResult = fileDBAdaptor.get(fileId, new QueryOptions(QueryOptions.INCLUDE,\n-                Arrays.asList(FileDBAdaptor.QueryParams.PATH.key(), FileDBAdaptor.QueryParams.STUDY_UID.key())));\n+      try {\n+        OpenCGAResult result = delete(study, file, physicalDelete, userId);\n+        dataResult.append(result);\n \n-        if (fileDataResult.getNumResults() == 0) {\n-            return fileDataResult;\n+        // We store the processed path as is\n+        if (file.getType() == File.Type.DIRECTORY) {\n+          processedPaths.add(file.getPath());\n         }\n \n-        String userId = userManager.getUserId(sessionId);\n-        authorizationManager.checkFilePermission(fileDataResult.first().getStudyUid(), fileId, userId, FileAclEntry.FilePermissions.VIEW);\n+        auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      } catch (CatalogException e) {\n+        String errorMsg;\n \n-        return getParents(fileDataResult.first().getStudyUid(), fileDataResult.first().getPath(), true, options);\n-    }\n+        if (file.getType() == File.Type.FILE) {\n+          errorMsg = \"Cannot delete file \" + file.getPath() + \": \" + e.getMessage();\n+        } else {\n+          errorMsg = \"Cannot delete folder \" + file.getPath() + \": \" + e.getMessage();\n+        }\n+        dataResult.getEvents().add(new Event(Event.Type.ERROR, file.getPath(), e.getMessage()));\n \n-    public OpenCGAResult<File> createFolder(String studyStr, String path, boolean parents, String description, QueryOptions options,\n-                                            String token) throws CatalogException {\n-        return createFolder(studyStr, path, parents, description, \"\", options, token);\n+        logger.error(errorMsg, e);\n+        auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      }\n     }\n+    auditManager.finishAuditBatch(operationUuid);\n \n-    public OpenCGAResult<File> createFolder(String studyStr, String path, boolean parents, String description, String jobId,\n-                                            QueryOptions options, String token) throws CatalogException {\n-        ParamUtils.checkPath(path, \"folderPath\");\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    dataResult.setTime((int) watch.getTime(TimeUnit.MILLISECONDS));\n+    dataResult.setNumMatches(dataResult.getNumMatches() + numMatches);\n \n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId);\n+    return endResult(dataResult, ignoreException);\n+  }\n \n-        if (path.startsWith(\"/\")) {\n-            path = path.substring(1);\n-        }\n-        if (!path.endsWith(\"/\")) {\n-            path = path + \"/\";\n-        }\n+  private OpenCGAResult delete(Study study, File file, boolean physicalDelete, String userId)\n+      throws CatalogException {\n+    // Check if the file or the folder plus any nested files/folders can be deleted\n+    checkCanDeleteFile(study, file.getPath(), false, Collections.singletonList(FileStatus.PENDING_DELETE), userId);\n \n-        OpenCGAResult<File> fileDataResult;\n-        switch (checkPathExists(path, study.getUid())) {\n-            case FREE_PATH:\n-                File file = new File(File.Type.DIRECTORY, File.Format.NONE, File.Bioformat.NONE, path, description,\n-                        FileInternal.initialize(), 0, null, null, jobId, null, null);\n-                fileDataResult = create(studyStr, file, parents, null, options, token);\n-                break;\n-            case DIRECTORY_EXISTS:\n-                Query query = new Query()\n-                        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                        .append(FileDBAdaptor.QueryParams.PATH.key(), path);\n-                fileDataResult = fileDBAdaptor.get(study.getUid(), query, options, userId);\n-                fileDataResult.getEvents().add(new Event(Event.Type.WARNING, path, \"Folder already existed\"));\n-                break;\n-            case FILE_EXISTS:\n-            default:\n-                throw new CatalogException(\"A file with the same name of the folder already exists in Catalog\");\n-        }\n+    String currentStatus = file.getInternal().getStatus().getName();\n+    if (FileStatus.DELETED.equals(currentStatus)) {\n+      throw new CatalogException(\"The file was already deleted\");\n+    }\n+    if (FileStatus.DELETING.equals(currentStatus)) {\n+      throw new CatalogException(\"The file is already being deleted\");\n+    }\n+    if (!FileStatus.PENDING_DELETE.equals(currentStatus)) {\n+      throw new CatalogException(\"The status of file should be \" + FileStatus.PENDING_DELETE);\n+    }\n \n-        return fileDataResult;\n+    if (physicalDelete) {\n+      return physicalDelete(study, file);\n+    } else {\n+      return sendToTrash(file);\n     }\n+  }\n \n-    public OpenCGAResult<File> createFile(String studyStr, String path, String description, boolean parents, String content,\n-                                          String sessionId) throws CatalogException {\n-        ParamUtils.checkPath(path, \"filePath\");\n+  /**\n+   * Given a registered folder in OpenCGA, it will scan its contents to register any nested file/folder that might not be registered.\n+   *\n+   * @param studyId  Study id.\n+   * @param folderId Folder id, path or uuid.\n+   * @param token    Token of the user. The user will need to have read and write access to the folderId.\n+   * @return An OpenCGAResult containing the number of files that have been added and the full list of files registered (old and new).\n+   * @throws CatalogException If there is any of the following errors:\n+   *                          Study not found, folderId does not exist or user does not have permissions.\n+   */\n+  public OpenCGAResult<File> syncUntrackedFiles(String studyId, String folderId, String token) throws CatalogException {\n+    return syncUntrackedFiles(studyId, folderId, uri -> true, \"\", token);\n+  }\n \n-        String userId = userManager.getUserId(sessionId);\n-        Study study = studyManager.resolveId(studyStr, userId);\n+  public OpenCGAResult<File> syncUntrackedFiles(String studyId, String folderId, Predicate<URI> filter, String token)\n+      throws CatalogException {\n+    return syncUntrackedFiles(studyId, folderId, filter, \"\", token);\n+  }\n \n-        if (path.startsWith(\"/\")) {\n-            path = path.substring(1);\n-        }\n+  public OpenCGAResult<File> syncUntrackedFiles(String studyId, String folderId, Predicate<URI> filter, String jobId, String token)\n+      throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, userId);\n \n-        switch (checkPathExists(path, study.getUid())) {\n-            case FREE_PATH:\n-                return create(studyStr, File.Type.FILE, File.Format.PLAIN, File.Bioformat.UNKNOWN, path, description,\n-                        0, null, null, parents, content, new QueryOptions(),\n-                        sessionId);\n-            case FILE_EXISTS:\n-            case DIRECTORY_EXISTS:\n-            default:\n-                throw new CatalogException(\"A file or folder with the same name already exists in the path of Catalog\");\n-        }\n+    File folder = internalGet(study.getUid(), folderId, INCLUDE_FILE_URI_PATH, userId).first();\n+\n+    if (folder.getType() == File.Type.FILE) {\n+      throw new CatalogException(\"Provided folder '\" + folderId + \"' is actually a file\");\n     }\n \n-    public OpenCGAResult<File> create(String studyStr, File.Type type, File.Format format, File.Bioformat bioformat, String path,\n-                                      String description, long size, Map<String, Object> stats, Map<String, Object> attributes,\n-                                      boolean parents, String content, QueryOptions options, String token) throws CatalogException {\n-        File file = new File(type, format, bioformat, path, description, FileInternal.initialize(), size, Collections.emptyList(), null, \"\",\n-                stats, attributes);\n-        return create(studyStr, file, parents, content, options, token);\n+    authorizationManager.checkFilePermission(study.getUid(), folder.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+\n+    IOManager ioManager;\n+    try {\n+      ioManager = ioManagerFactory.get(folder.getUri());\n+    } catch (IOException e) {\n+      throw CatalogIOException.ioManagerException(folder.getUri(), e);\n     }\n+    Iterator<URI> iterator = ioManager.listFilesStream(folder.getUri()).iterator();\n \n-    @Override\n-    public OpenCGAResult<File> create(String studyStr, File entry, QueryOptions options, String token) throws CatalogException {\n-        throw new NotImplementedException(\"Call to create passing parents and content variables\");\n+    if (filter == null) {\n+      filter = uri -> true;\n     }\n \n-    public OpenCGAResult<File> create(String studyStr, File file, boolean parents, String content, QueryOptions options, String token)\n-            throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+    long numMatches = 0;\n \n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"file\", file)\n-                .append(\"parents\", parents)\n-                .append(\"content\", content)\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-        try {\n-            File parentFile = getParents(study.getUid(), file.getPath(), false, INCLUDE_FILE_URI_PATH).first();\n-            authorizationManager.checkFilePermission(study.getUid(), parentFile.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+    OpenCGAResult<File> result = OpenCGAResult.empty();\n+    List<File> fileList = new ArrayList<>();\n+    List<Event> eventList = new ArrayList<>();\n+    while (iterator.hasNext()) {\n+      URI fileUri = iterator.next().normalize();\n \n-            OpenCGAResult<File> result = create(study, file, parents, content, options, token);\n-            auditManager.auditCreate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            return result;\n-        } catch (CatalogException e) {\n-            auditManager.auditCreate(userId, Enums.Resource.FILE, file.getId(), \"\", study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n+      numMatches++;\n \n-    void validateNewFile(Study study, File file, String sessionId, boolean overwrite) throws CatalogException {\n-        /** Check and set all the params and create a File object **/\n-        ParamUtils.checkObj(file, \"File\");\n-        ParamUtils.checkPath(file.getPath(), \"path\");\n-        file.setType(ParamUtils.defaultObject(file.getType(), File.Type.FILE));\n-        file.setFormat(ParamUtils.defaultObject(file.getFormat(), File.Format.PLAIN));\n-        file.setBioformat(ParamUtils.defaultObject(file.getBioformat(), File.Bioformat.NONE));\n-        file.setDescription(ParamUtils.defaultString(file.getDescription(), \"\"));\n-        file.setRelatedFiles(ParamUtils.defaultObject(file.getRelatedFiles(), ArrayList::new));\n-        file.setSampleIds(ParamUtils.defaultObject(file.getSampleIds(), ArrayList::new));\n-        file.setCreationDate(TimeUtils.getTime());\n-        file.setJobId(ParamUtils.defaultString(file.getJobId(), \"\"));\n-        file.setModificationDate(file.getCreationDate());\n-        file.setTags(ParamUtils.defaultObject(file.getTags(), ArrayList::new));\n-        file.setInternal(ParamUtils.defaultObject(file.getInternal(), FileInternal::new));\n-        file.getInternal().setIndex(ParamUtils.defaultObject(file.getInternal().getIndex(), FileIndex.initialize()));\n-        file.getInternal().setStatus(ParamUtils.defaultObject(file.getInternal().getStatus(), new FileStatus(FileStatus.READY)));\n-        file.getInternal().setSampleMap(ParamUtils.defaultObject(file.getInternal().getSampleMap(), HashMap::new));\n-        file.setStatus(ParamUtils.defaultObject(file.getStatus(), CustomStatus::new));\n-        file.setStats(ParamUtils.defaultObject(file.getStats(), HashMap::new));\n-        file.setAttributes(ParamUtils.defaultObject(file.getAttributes(), HashMap::new));\n+      if (!filter.test(fileUri)) {\n+        continue;\n+      }\n \n-//        validateNewSamples(study, file, sessionId);\n+      String relativeFilePath = folder.getUri().relativize(fileUri).getPath();\n+      String finalCatalogPath = Paths.get(folder.getPath()).resolve(relativeFilePath).toString();\n+      if (relativeFilePath.endsWith(\"/\") && !finalCatalogPath.endsWith(\"/\")) {\n+        finalCatalogPath += \"/\";\n+      }\n \n-        if (file.getSize() < 0) {\n-            throw new CatalogException(\"Error: DiskUsage can't be negative!\");\n+      try {\n+        File registeredFile = internalGet(study.getUid(), finalCatalogPath, INCLUDE_FILE_URI_PATH, userId).first();\n+        if (!registeredFile.getUri().equals(fileUri)) {\n+          eventList.add(new Event(Event.Type.WARNING, registeredFile.getPath(), \"The uri registered in Catalog '\"\n+              + registeredFile.getUri().getPath() + \"' for the path does not match the uri that would have been synced '\"\n+              + fileUri.getPath() + \"'\"));\n         }\n+        fileList.add(registeredFile);\n+      } catch (CatalogException e) {\n+        File file = registerFile(study, finalCatalogPath, fileUri, jobId, token).first();\n+\n+        result.setNumInserted(result.getNumInserted() + 1);\n+        fileList.add(file);\n+      }\n+    }\n+    result.setNumMatches(numMatches);\n+    result.setEvents(eventList);\n+    result.setResults(fileList);\n+    result.setNumResults(fileList.size());\n+\n+    return result;\n+  }\n+\n+  public OpenCGAResult<File> unlink(@Nullable String studyId, String fileId, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, userId);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyId)\n+        .append(\"file\", fileId)\n+        .append(\"token\", token);\n+\n+    try {\n+      ParamUtils.checkParameter(fileId, \"File\");\n+\n+      File file = internalGet(study.getUid(), fileId, QueryOptions.empty(), userId).first();\n+\n+      if (!file.isExternal()) {\n+        throw new CatalogException(\"Only previously linked files can be unlinked. Please, use delete instead.\");\n+      }\n+\n+      // Check if the file or the folder plus any nested files/folders can be deleted\n+      checkCanDeleteFile(study, file.getPath(), true, Collections.singletonList(FileStatus.PENDING_DELETE), userId);\n+\n+      OpenCGAResult result = unlink(file);\n+      auditManager.audit(userId, Enums.Action.UNLINK, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n \n-        // Fix path\n-        if (file.getType() == File.Type.DIRECTORY && !file.getPath().endsWith(\"/\")) {\n-            file.setPath(file.getPath() + \"/\");\n-        }\n-        if (file.getType() == File.Type.FILE && file.getPath().endsWith(\"/\")) {\n-            file.setPath(file.getPath().substring(0, file.getPath().length() - 1));\n-        }\n-        file.setName(Paths.get(file.getPath()).getFileName().toString());\n-        file.setId(file.getPath().replace(\"/\", \":\"));\n+      return result;\n+    } catch (CatalogException e) {\n+      auditManager.audit(userId, Enums.Action.UNLINK, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n \n-        URI uri;\n+  /**\n+   * Delete the file from the file system and from OpenCGA.\n+   *\n+   * @param study Study object.\n+   * @param file  File or folder.\n+   * @return a OpenCGAResult object.\n+   */\n+  private OpenCGAResult physicalDelete(Study study, File file) throws CatalogException {\n+    URI fileUri = getUri(file);\n+    IOManager ioManager = null;\n+    try {\n+      ioManager = ioManagerFactory.get(fileUri);\n+    } catch (IOException e) {\n+      throw CatalogIOException.ioManagerException(fileUri, e);\n+    }\n+\n+    OpenCGAResult result = OpenCGAResult.empty();\n+    if (file.getType() == File.Type.FILE) {\n+      // 1. Set the file status to deleting\n+      ObjectMap update = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_STATUS_NAME.key(), FileStatus.DELETING);\n+      fileDBAdaptor.update(file.getUid(), update, QueryOptions.empty());\n+\n+      // 2. Delete file from the file system\n+      logger.debug(\"Deleting file '{} ({})' with uri '{}' from the file system\", file.getPath(), file.getUid(), fileUri);\n+      if (ioManager.exists(fileUri)) {\n         try {\n-            if (file.getType() == File.Type.DIRECTORY) {\n-                uri = getFileUri(study.getUid(), file.getPath(), true);\n-            } else {\n-                uri = getFileUri(study.getUid(), file.getPath(), false);\n-            }\n-        } catch (URISyntaxException e) {\n-            throw new CatalogException(e);\n-        }\n-        file.setUri(uri);\n-\n-        if (!overwrite) {\n-            // Check if it already exists\n-            Query query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                    .append(FileDBAdaptor.QueryParams.PATH.key(), file.getPath());\n-            if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n-                logger.warn(\"The file '{}' already exists in catalog\", file.getPath());\n-                throw new CatalogException(\"The file '\" + file.getPath() + \"' already exists in catalog\");\n-            }\n-            query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                    .append(FileDBAdaptor.QueryParams.URI.key(), uri);\n-            OpenCGAResult<File> fileResult = fileDBAdaptor.get(query,\n-                    new QueryOptions(QueryOptions.INCLUDE, FileDBAdaptor.QueryParams.PATH.key()));\n-            if (fileResult.getNumResults() > 0) {\n-                logger.warn(\"The uri '{}' of the file is already in catalog but in path '{}'.\", uri, fileResult.first().getPath());\n-                throw new CatalogException(\"The uri '\" + uri + \"' of the file is already in catalog but in path '\"\n-                        + fileResult.first().getPath() + \"'\");\n-            }\n-        }\n-\n-        boolean external = isExternal(study, file.getPath(), uri);\n-        file.setExternal(external);\n-        file.setRelease(studyManager.getCurrentRelease(study));\n+          ioManager.deleteFile(fileUri);\n+        } catch (CatalogIOException e) {\n+          logger.error(\"Could not delete physically the file '{} ({})'. File deletion aborted.\", file.getPath(), file.getUid());\n+          // FIXME: Do we restore the status to READY\n+          throw new CatalogException(\"Error deleting file \" + file.getPath() + \" physically: \" + e.getMessage(), e.getCause());\n+        }\n+      } else {\n+        // FIXME: What do we do if the file does not exist in the file system\n+        logger.warn(\"Could not delete file '{}'. The file is not accessible or does not exist.\", fileUri);\n+      }\n+\n+      // 3. Delete file from the database\n+      result = fileDBAdaptor.delete(file, FileStatus.DELETED);\n+    } else {\n+      // 1. Set the folder and all nested files/folders to DELETING\n+      Query query = new Query()\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+          .append(FileDBAdaptor.QueryParams.PATH.key(), \"~^\" + file.getPath() + \"*\");\n+      ObjectMap update = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_STATUS_NAME.key(), FileStatus.DELETING);\n+      fileDBAdaptor.update(query, update, QueryOptions.empty());\n+\n+      // 2. Delete files to be deleted from the file system\n+      QueryOptions options = new QueryOptions(INCLUDE_FILE_URI_PATH)\n+          .append(QueryOptions.SORT, FileDBAdaptor.QueryParams.PATH.key())\n+          .append(QueryOptions.ORDER, QueryOptions.DESCENDING);\n+      DBIterator<File> iterator = fileDBAdaptor.iterator(query, options);\n+      while (iterator.hasNext()) {\n+        File tmpFile = iterator.next();\n+        if (ioManager.isDirectory(tmpFile.getUri())) {\n+          // If the directory is not empty, it might be that there are other files/folders not registered in OpenCGA, so we only\n+          // delete the directory if the directory is empty\n+          if (ioManager.listFiles(tmpFile.getUri()).isEmpty()) {\n+            ioManager.deleteDirectory(tmpFile.getUri());\n+          }\n+        } else {\n+          ioManager.deleteFile(tmpFile.getUri());\n+        }\n+      }\n+\n+      // 3. Delete the folder and all nested files/folders to DELETED\n+      result = fileDBAdaptor.delete(file, FileStatus.DELETED);\n+    }\n+\n+    return result;\n+  }\n+\n+  private OpenCGAResult sendToTrash(File file) throws CatalogException {\n+    return fileDBAdaptor.delete(file, FileStatus.TRASHED);\n+  }\n+\n+  private OpenCGAResult unlink(File file) throws CatalogException {\n+    return fileDBAdaptor.delete(file, FileStatus.REMOVED);\n+  }\n+\n+  private boolean subpathInPath(String subpath, Set<String> pathSet) {\n+    String[] split = StringUtils.split(subpath, \"/\");\n+    String auxPath = \"\";\n+    for (String s : split) {\n+      auxPath += s + \"/\";\n+      if (pathSet.contains(auxPath)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public OpenCGAResult<File> updateAnnotations(String studyStr, String fileStr, String annotationSetId,\n+                                               Map<String, Object> annotations, ParamUtils.CompleteUpdateAction action,\n+                                               QueryOptions options, String token) throws CatalogException {\n+    if (annotations == null || annotations.isEmpty()) {\n+      throw new CatalogException(\"Missing array of annotations.\");\n+    }\n+    FileUpdateParams updateParams = new FileUpdateParams()\n+        .setAnnotationSets(Collections.singletonList(new AnnotationSet(annotationSetId, \"\", annotations)));\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    options.put(Constants.ACTIONS, new ObjectMap(AnnotationSetManager.ANNOTATIONS, action));\n+\n+    return update(studyStr, fileStr, updateParams, options, token);\n+  }\n+\n+  public OpenCGAResult<File> removeAnnotations(String studyStr, String fileStr, String annotationSetId,\n+                                               List<String> annotations, QueryOptions options, String token) throws CatalogException {\n+    return updateAnnotations(studyStr, fileStr, annotationSetId, new ObjectMap(\"remove\", StringUtils.join(annotations, \",\")),\n+        ParamUtils.CompleteUpdateAction.REMOVE, options, token);\n+  }\n+\n+  public OpenCGAResult<File> resetAnnotations(String studyStr, String fileStr, String annotationSetId, List<String> annotations,\n+                                              QueryOptions options, String token) throws CatalogException {\n+    return updateAnnotations(studyStr, fileStr, annotationSetId, new ObjectMap(\"reset\", StringUtils.join(annotations, \",\")),\n+        ParamUtils.CompleteUpdateAction.RESET, options, token);\n+  }\n+\n+  public OpenCGAResult<File> update(String studyStr, Query query, FileUpdateParams updateParams, QueryOptions options, String token)\n+      throws CatalogException {\n+    return update(studyStr, query, updateParams, false, options, token);\n+  }\n+\n+  public OpenCGAResult<File> update(String studyStr, Query query, FileUpdateParams updateParams, boolean ignoreException,\n+                                    QueryOptions options, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    ObjectMap updateMap;\n+    try {\n+      updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n+    } catch (JsonProcessingException e) {\n+      throw new CatalogException(\"Could not parse FileUpdateParams object: \" + e.getMessage(), e);\n+    }\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"query\", query)\n+        .append(\"updateParams\", updateMap)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+\n+    Query finalQuery = new Query(ParamUtils.defaultObject(query, Query::new));\n+\n+    DBIterator<File> iterator;\n+    try {\n+      // Fix query if it contains any annotation\n+      AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n+      fixQueryObject(study, finalQuery, userId);\n+      finalQuery.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+\n+      iterator = fileDBAdaptor.iterator(study.getUid(), finalQuery, EXCLUDE_FILE_ATTRIBUTES, userId);\n+    } catch (CatalogException e) {\n+      auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, \"\", \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+\n+    auditManager.initAuditBatch(operationId);\n+    OpenCGAResult<File> result = OpenCGAResult.empty();\n+    while (iterator.hasNext()) {\n+      File file = iterator.next();\n+      try {\n+        OpenCGAResult<File> updateResult = update(study, file, updateParams, options, userId, token);\n+        result.append(updateResult);\n+\n+        auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      } catch (CatalogException e) {\n+        Event event = new Event(Event.Type.ERROR, file.getId(), e.getMessage());\n+        result.getEvents().add(event);\n+\n+        logger.error(\"Cannot update file {}: {}\", file.getId(), e.getMessage());\n+        auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      }\n+    }\n+    auditManager.finishAuditBatch(operationId);\n+    return endResult(result, ignoreException);\n+  }\n+\n+  public OpenCGAResult<File> update(String studyStr, String fileId, FileUpdateParams updateParams, QueryOptions options, String token)\n+      throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    ObjectMap updateMap;\n+    try {\n+      updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n+    } catch (JsonProcessingException e) {\n+      throw new CatalogException(\"Could not parse FileUpdateParams object: \" + e.getMessage(), e);\n+    }\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"fileId\", fileId)\n+        .append(\"updateParams\", updateMap)\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+\n+    OpenCGAResult<File> result = OpenCGAResult.empty();\n+    String fileUuid = \"\";\n+    try {\n+      OpenCGAResult<File> internalResult = internalGet(study.getUid(), fileId, EXCLUDE_FILE_ATTRIBUTES, userId);\n+      if (internalResult.getNumResults() == 0) {\n+        throw new CatalogException(\"File '\" + fileId + \"' not found\");\n+      }\n+      File file = internalResult.first();\n+\n+      // We set the proper values for the audit\n+      fileId = file.getId();\n+      fileUuid = file.getUuid();\n+\n+      OpenCGAResult<File> updateResult = update(study, file, updateParams, options, userId, token);\n+      result.append(updateResult);\n+\n+      auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+    } catch (CatalogException e) {\n+      Event event = new Event(Event.Type.ERROR, fileId, e.getMessage());\n+      result.getEvents().add(event);\n+\n+      logger.error(\"Cannot update file {}: {}\", fileId, e.getMessage());\n+      auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, fileId, fileUuid, study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Update a File from catalog.\n+   *\n+   * @param studyStr     Study id in string format. Could be one of [id|user@aliasProject:aliasStudy|aliasProject:aliasStudy|aliasStudy].\n+   * @param fileIds      List of file ids. Could be either the id, path or uuid.\n+   * @param updateParams Data model filled only with the parameters to be updated.\n+   * @param options      QueryOptions object.\n+   * @param token        Session id of the user logged in.\n+   * @return A OpenCGAResult.\n+   * @throws CatalogException if there is any internal error, the user does not have proper permissions or a parameter passed does not\n+   *                          exist or is not allowed to be updated.\n+   */\n+  public OpenCGAResult<File> update(String studyStr, List<String> fileIds, FileUpdateParams updateParams, QueryOptions options,\n+                                    String token) throws CatalogException {\n+    return update(studyStr, fileIds, updateParams, false, options, token);\n+  }\n+\n+  public OpenCGAResult<File> update(String studyStr, List<String> fileIds, FileUpdateParams updateParams, boolean ignoreException,\n+                                    QueryOptions options, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    ObjectMap updateMap;\n+    try {\n+      updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n+    } catch (JsonProcessingException e) {\n+      throw new CatalogException(\"Could not parse FileUpdateParams object: \" + e.getMessage(), e);\n+    }\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"fileIds\", fileIds)\n+        .append(\"updateParams\", updateMap)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+\n+    auditManager.initAuditBatch(operationId);\n+    OpenCGAResult<File> result = OpenCGAResult.empty();\n+    for (String id : fileIds) {\n+      String fileId = id;\n+      String fileUuid = \"\";\n+\n+      try {\n+        OpenCGAResult<File> internalResult = internalGet(study.getUid(), fileId, EXCLUDE_FILE_ATTRIBUTES, userId);\n+        if (internalResult.getNumResults() == 0) {\n+          throw new CatalogException(\"File '\" + id + \"' not found\");\n+        }\n+        File file = internalResult.first();\n+\n+        // We set the proper values for the audit\n+        fileId = file.getId();\n+        fileUuid = file.getUuid();\n+\n+        OpenCGAResult<File> updateResult = update(study, file, updateParams, options, userId, token);\n+        result.append(updateResult);\n \n-        validateNewAnnotationSets(study.getVariableSets(), file.getAnnotationSets());\n+        auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n+            auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      } catch (CatalogException e) {\n+        Event event = new Event(Event.Type.ERROR, id, e.getMessage());\n+        result.getEvents().add(event);\n \n-        file.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n-        checkHooks(file, study.getFqn(), HookConfiguration.Stage.CREATE);\n+        logger.error(\"Cannot update file {}: {}\", fileId, e.getMessage());\n+        auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, fileId, fileUuid, study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      }\n+    }\n+    auditManager.finishAuditBatch(operationId);\n+    return endResult(result, ignoreException);\n+  }\n+\n+  private OpenCGAResult<File> update(Study study, File file, FileUpdateParams updateParams, QueryOptions options, String userId,\n+                                     String token) throws CatalogException {\n+    ObjectMap parameters = new ObjectMap();\n+    if (updateParams != null) {\n+      try {\n+        parameters = updateParams.getUpdateMap();\n+      } catch (JsonProcessingException e) {\n+        throw new CatalogException(\"Could not parse FileUpdateParams object: \" + e.getMessage(), e);\n+      }\n+    }\n+    ParamUtils.checkUpdateParametersMap(parameters);\n+\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    if (parameters.containsKey(FileDBAdaptor.QueryParams.ANNOTATION_SETS.key())) {\n+      Map<String, Object> actionMap = new HashMap<>(options.getMap(Constants.ACTIONS, Collections.emptyMap()));\n+      if (!actionMap.containsKey(AnnotationSetManager.ANNOTATION_SETS)\n+          && !actionMap.containsKey(AnnotationSetManager.ANNOTATIONS)) {\n+        logger.warn(\"Assuming the user wants to add the list of annotation sets provided\");\n+        actionMap.put(AnnotationSetManager.ANNOTATION_SETS, ParamUtils.UpdateAction.ADD);\n+        options.put(Constants.ACTIONS, actionMap);\n+      }\n+    }\n+\n+    if (parameters.containsKey(FileDBAdaptor.QueryParams.RELATED_FILES.key())) {\n+      List<FileRelatedFile> relatedFileList = new ArrayList<>();\n+      for (SmallRelatedFileParams relatedFile : updateParams.getRelatedFiles()) {\n+        if (StringUtils.isEmpty(relatedFile.getFile()) || relatedFile.getRelation() == null) {\n+          throw new CatalogException(\"Missing file or relation in relatedFiles list\");\n+        }\n+        File relatedFileFile = internalGet(study.getUid(), relatedFile.getFile(), null, INCLUDE_FILE_URI_PATH, userId).first();\n+        relatedFileList.add(new FileRelatedFile(relatedFileFile, relatedFile.getRelation()));\n+      }\n+      parameters.put(FileDBAdaptor.QueryParams.RELATED_FILES.key(), relatedFileList);\n+\n+      Map<String, Object> actionMap = options.getMap(Constants.ACTIONS, new HashMap<>());\n+      if (!actionMap.containsKey(FileDBAdaptor.QueryParams.RELATED_FILES.key())) {\n+        logger.warn(\"Assuming the user wants to add the list of related files provided\");\n+        actionMap.put(FileDBAdaptor.QueryParams.RELATED_FILES.key(), ParamUtils.UpdateAction.ADD.name());\n+        options.put(Constants.ACTIONS, actionMap);\n+      }\n+    }\n+\n+    // Check permissions...\n+    // Only check write annotation permissions if the user wants to update the annotation sets\n+    if (updateParams != null && updateParams.getAnnotationSets() != null) {\n+      authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId,\n+          FileAclEntry.FilePermissions.WRITE_ANNOTATIONS);\n+    }\n+    // Only check update permissions if the user wants to update anything apart from the annotation sets\n+    if ((parameters.size() == 1 && !parameters.containsKey(FileDBAdaptor.QueryParams.ANNOTATION_SETS.key()))\n+        || parameters.size() > 1) {\n+      authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+    }\n+\n+    if (isRootFolder(file)) {\n+      throw new CatalogException(\"Cannot modify root folder\");\n+    }\n+\n+    // We make a query to check both if the samples exists and if the user has permissions to see them\n+    if (updateParams != null && ListUtils.isNotEmpty(updateParams.getSampleIds())) {\n+      catalogManager.getSampleManager().internalGet(study.getUid(), updateParams.getSampleIds(), SampleManager.INCLUDE_SAMPLE_IDS,\n+          userId, false);\n+    }\n+\n+    //Name must be changed with \"rename\".\n+    if (updateParams != null && StringUtils.isNotEmpty(updateParams.getName())) {\n+      logger.info(\"Rename file using update method!\");\n+      rename(study.getFqn(), file.getPath(), updateParams.getName(), token);\n+      parameters.remove(FileDBAdaptor.QueryParams.NAME.key());\n+    }\n+\n+    checkUpdateAnnotations(study, file, parameters, options, VariableSet.AnnotableDataModels.FILE, fileDBAdaptor, userId);\n+\n+    return fileDBAdaptor.update(file.getUid(), parameters, study.getVariableSets(), options);\n+  }\n+\n+  @Deprecated\n+  public OpenCGAResult<File> update(String studyStr, String entryStr, ObjectMap parameters, QueryOptions options, String token)\n+      throws CatalogException {\n+    ParamUtils.checkObj(parameters, \"Parameters\");\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n+\n+    File file = internalGet(study.getUid(), entryStr, QueryOptions.empty(), userId).first();\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"fileId\", entryStr)\n+        .append(\"updateParams\", parameters)\n+        .append(\"options\", options)\n+        .append(\"token\", token);\n+    try {\n+      // Check permissions...\n+      // Only check write annotation permissions if the user wants to update the annotation sets\n+      if (parameters.containsKey(FileDBAdaptor.QueryParams.ANNOTATION_SETS.key())) {\n+        authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId,\n+            FileAclEntry.FilePermissions.WRITE_ANNOTATIONS);\n+      }\n+      // Only check update permissions if the user wants to update anything apart from the annotation sets\n+      if ((parameters.size() == 1 && !parameters.containsKey(FileDBAdaptor.QueryParams.ANNOTATION_SETS.key()))\n+          || parameters.size() > 1) {\n+        authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+      }\n+\n+      try {\n+        ParamUtils.checkAllParametersExist(parameters.keySet().iterator(), (a) -> FileDBAdaptor.UpdateParams.getParam(a) != null);\n+      } catch (CatalogParameterException e) {\n+        throw new CatalogException(\"Could not update: \" + e.getMessage(), e);\n+      }\n+\n+      // We make a query to check both if the samples exists and if the user has permissions to see them\n+      if (parameters.get(FileDBAdaptor.QueryParams.SAMPLE_IDS.key()) != null\n+          && ListUtils.isNotEmpty(parameters.getAsStringList(FileDBAdaptor.QueryParams.SAMPLE_IDS.key()))) {\n+        List<String> sampleIds = parameters.getAsStringList(FileDBAdaptor.QueryParams.SAMPLE_IDS.key());\n+        catalogManager.getSampleManager().internalGet(study.getUid(), sampleIds, SampleManager.INCLUDE_SAMPLE_IDS, userId, false);\n+      }\n+\n+      //Name must be changed with \"rename\".\n+      if (parameters.containsKey(FileDBAdaptor.QueryParams.NAME.key())) {\n+        logger.info(\"Rename file using update method!\");\n+        rename(studyStr, file.getPath(), parameters.getString(FileDBAdaptor.QueryParams.NAME.key()), token);\n+      }\n+\n+      OpenCGAResult<File> queryResult = unsafeUpdate(study, file, parameters, options, userId);\n+      auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      return queryResult;\n+    } catch (CatalogException e) {\n+      auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  OpenCGAResult<File> unsafeUpdate(Study study, File file, ObjectMap parameters, QueryOptions options, String userId)\n+      throws CatalogException {\n+    if (isRootFolder(file)) {\n+      throw new CatalogException(\"Cannot modify root folder\");\n+    }\n+\n+    try {\n+      ParamUtils.checkAllParametersExist(parameters.keySet().iterator(), (a) -> FileDBAdaptor.UpdateParams.getParam(a) != null);\n+    } catch (CatalogParameterException e) {\n+      throw new CatalogException(\"Could not update: \" + e.getMessage(), e);\n+    }\n+\n+    checkUpdateAnnotations(study, file, parameters, options, VariableSet.AnnotableDataModels.FILE, fileDBAdaptor, userId);\n+\n+    fileDBAdaptor.update(file.getUid(), parameters, study.getVariableSets(), options);\n+    return fileDBAdaptor.get(file.getUid(), options);\n+  }\n+\n+  public OpenCGAResult<File> link(String studyStr, FileLinkParams params, boolean parents, String token) throws CatalogException {\n+    // We make two attempts to link to ensure the behaviour remains even if it is being called at the same time link from different\n+    // threads\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"params\", params)\n+        .append(\"parents\", parents)\n+        .append(\"token\", token);\n+    try {\n+      OpenCGAResult<File> result = privateLink(study, params, parents, token);\n+      auditManager.auditCreate(userId, Enums.Action.LINK, Enums.Resource.FILE, result.first().getId(),\n+          result.first().getUuid(), study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      return result;\n+    } catch (CatalogException e) {\n+      try {\n+        OpenCGAResult<File> result = privateLink(study, params, parents, token);\n+        auditManager.auditCreate(userId, Enums.Action.LINK, Enums.Resource.FILE, result.first().getId(),\n+            result.first().getUuid(), study.getId(), study.getUuid(), auditParams,\n+            new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+        return result;\n+      } catch (CatalogException e2) {\n+        auditManager.auditCreate(userId, Enums.Action.LINK, Enums.Resource.FILE, params.getUri(), \"\",\n+            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n+                new Error(0, \"\", e2.getMessage())));\n+        throw new CatalogException(e2.getMessage(), e2);\n+      }\n     }\n+  }\n \n-    private OpenCGAResult<File> register(Study study, File file, List<Sample> existingSamples, List<Sample> nonExistingSamples,\n-                                         boolean parents, QueryOptions options, String sessionId) throws CatalogException {\n-        String userId = userManager.getUserId(sessionId);\n-        long studyId = study.getUid();\n+  @Deprecated\n+  public OpenCGAResult<File> link(String studyStr, URI uriOrigin, String pathDestiny, ObjectMap params, String token)\n+      throws CatalogException {\n+    params = ParamUtils.defaultObject(params, ObjectMap::new);\n+    FileLinkParams linkParams = new FileLinkParams()\n+        .setDescription(params.getString(\"description\", \"\"))\n+        .setPath(pathDestiny)\n+        .setUri(uriOrigin.toString())\n+        .setRelatedFiles(params.getAsList(\"relatedFiles\", SmallRelatedFileParams.class));\n+    return link(studyStr, linkParams, params.getBoolean(\"parents\", false), token);\n+  }\n \n-        //Find parent. If parents == true, create folders.\n-        String parentPath = getParentPath(file.getPath());\n+  @Override\n+  public OpenCGAResult rank(String studyStr, Query query, String field, int numResults, boolean asc, String sessionId)\n+      throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n+    ParamUtils.checkObj(field, \"field\");\n+    ParamUtils.checkObj(sessionId, \"sessionId\");\n \n-        long parentFileId = fileDBAdaptor.getId(studyId, parentPath);\n-        boolean newParent = false;\n-        if (parentFileId < 0 && StringUtils.isNotEmpty(parentPath)) {\n-            if (parents) {\n-                newParent = true;\n-                File parentFile = new File(File.Type.DIRECTORY, File.Format.NONE, File.Bioformat.NONE, parentPath, \"\",\n-                        new FileInternal(new FileStatus(FileStatus.READY), new FileIndex(), Collections.emptyMap()), 0,\n-                        Collections.emptyList(), null, \"\", Collections.emptyMap(), Collections.emptyMap());\n-                validateNewFile(study, parentFile, sessionId, false);\n-                parentFileId = register(study, parentFile, existingSamples, nonExistingSamples, parents, options, sessionId)\n-                        .first().getUid();\n-            } else {\n-                throw new CatalogDBException(\"Directory not found \" + parentPath);\n-            }\n-        }\n+    String userId = userManager.getUserId(sessionId);\n+    Study study = studyManager.resolveId(studyStr, userId);\n \n-        //Check permissions\n-        if (parentFileId < 0) {\n-            throw new CatalogException(\"Unable to create file without a parent file\");\n-        } else {\n-            if (!newParent) {\n-                //If parent has been created, for sure we have permissions to create the new file.\n-                authorizationManager.checkFilePermission(studyId, parentFileId, userId, FileAclEntry.FilePermissions.WRITE);\n-            }\n-        }\n+    authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.VIEW_FILES);\n \n-        fileDBAdaptor.insert(studyId, file, existingSamples, nonExistingSamples, study.getVariableSets(), options);\n-        OpenCGAResult<File> queryResult = getFile(studyId, file.getUuid(), options);\n-        // We obtain the permissions set in the parent folder and set them to the file or folder being created\n-        OpenCGAResult<Map<String, List<String>>> allFileAcls = authorizationManager.getAllFileAcls(studyId, parentFileId, userId, false);\n-        // Propagate ACLs\n-        if (allFileAcls.getNumResults() > 0) {\n-            authorizationManager.replicateAcls(studyId, Arrays.asList(queryResult.first().getUid()), allFileAcls.getResults().get(0),\n-                    Enums.Resource.FILE);\n-        }\n+    // TODO: In next release, we will have to check the count parameter from the queryOptions object.\n+    boolean count = true;\n+    query.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+    OpenCGAResult queryResult = null;\n+    if (count) {\n+      // We do not need to check for permissions when we show the count of files\n+      queryResult = fileDBAdaptor.rank(query, field, numResults, asc);\n+    }\n \n-        matchUpVariantFiles(study.getFqn(), queryResult.getResults(), sessionId);\n+    return ParamUtils.defaultObject(queryResult, OpenCGAResult::new);\n+  }\n \n-        return queryResult;\n+  @Override\n+  public OpenCGAResult groupBy(@Nullable String studyStr, Query query, List<String> fields, QueryOptions options, String sessionId)\n+      throws CatalogException {\n+    query = ParamUtils.defaultObject(query, Query::new);\n+    options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    if (fields == null || fields.size() == 0) {\n+      throw new CatalogException(\"Empty fields parameter.\");\n     }\n \n-    private OpenCGAResult<File> create(Study study, File file, boolean parents, String content, QueryOptions options, String sessionId)\n-            throws CatalogException {\n-        validateNewFile(study, file, sessionId, false);\n+    String userId = userManager.getUserId(sessionId);\n+    Study study = studyManager.resolveId(studyStr, userId);\n \n-        IOManager ioManager;\n-        try {\n-            ioManager = ioManagerFactory.get(file.getUri());\n-        } catch (IOException e) {\n-            throw CatalogIOException.ioManagerException(file.getUri(), e);\n-        }\n-        if (file.getType() == File.Type.FILE && StringUtils.isNotEmpty(content)) {\n-            // We set parents to true because the file has been successfully registered, which means the directories are already registered\n-            // in catalog\n-            ioManager.createDirectory(Paths.get(file.getUri()).getParent().toUri(), true);\n-            InputStream inputStream = new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8));\n-            ioManager.copy(inputStream, file.getUri());\n-        }\n+    fixQueryObject(study, query, userId);\n \n-        List<Sample> nonExistingSamples = new LinkedList<>();\n-        List<Sample> existingSamples = new LinkedList<>();\n-        if (file.getType() == File.Type.FILE && ioManager.exists(file.getUri())) {\n-            new FileMetadataReader(catalogManager).addMetadataInformation(study.getFqn(), file);\n-            validateNewSamples(study, file, existingSamples, nonExistingSamples, sessionId);\n-        }\n+    // Add study id to the query\n+    query.put(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n \n-        OpenCGAResult<File> result;\n-        try {\n-            result = register(study, file, existingSamples, nonExistingSamples, parents, options, sessionId);\n-        } catch (CatalogException e) {\n-            if (file.getType() == File.Type.FILE && StringUtils.isNotEmpty(content)) {\n-                ioManager.deleteFile(file.getUri());\n-            }\n-            throw new CatalogException(\"Error registering file: \" + e.getMessage(), e);\n-        }\n+    // We do not need to check for permissions when we show the count of files\n+    OpenCGAResult queryResult = fileDBAdaptor.groupBy(query, fields, options, userId);\n \n-        return result;\n-    }\n+    return ParamUtils.defaultObject(queryResult, OpenCGAResult::new);\n+  }\n \n-    private void validateNewSamples(Study study, File file, List<Sample> existingSamples, List<Sample> nonExistingSamples, String sessionId)\n-            throws CatalogException {\n-        if (file.getSampleIds() == null || file.getSampleIds().isEmpty()) {\n-            return;\n-        }\n+  OpenCGAResult<File> rename(String studyStr, String fileStr, String newName, String sessionId) throws CatalogException {\n+    ParamUtils.checkFileName(newName, \"name\");\n \n-        String userId = catalogManager.getUserManager().getUserId(sessionId);\n+    String userId = userManager.getUserId(sessionId);\n+    Study study = studyManager.resolveId(studyStr, userId);\n \n-        InternalGetDataResult<Sample> sampleResult = catalogManager.getSampleManager().internalGet(study.getUid(), file.getSampleIds(),\n-                SampleManager.INCLUDE_SAMPLE_IDS, userId, true);\n+    File file = internalGet(study.getUid(), fileStr, EXCLUDE_FILE_ATTRIBUTES, userId).first();\n+    authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n \n-        existingSamples.addAll(sampleResult.getResults());\n-        for (InternalGetDataResult<Sample>.Missing missing : sampleResult.getMissing()) {\n-            Sample sample = new Sample().setId(missing.getId());\n-            catalogManager.getSampleManager().validateNewSample(study, sample, userId);\n-            nonExistingSamples.add(sample);\n-        }\n+    if (file.getName().equals(newName)) {\n+      OpenCGAResult result = OpenCGAResult.empty();\n+      result.setEvents(Collections.singletonList(new Event(Event.Type.WARNING, newName, \"File already had that name.\")));\n+      return result;\n     }\n \n-    /**\n-     * Upload a file in Catalog.\n-     *\n-     * @param studyStr        study where the file will be uploaded.\n-     * @param fileInputStream Input stream of the file to be uploaded.\n-     * @param file            File object containing at least the basic metadata necessary for a successful upload: path\n-     * @param overwrite       Overwrite the current file if any.\n-     * @param parents         boolean indicating whether unexisting parent folders should also be created automatically.\n-     * @param calculateChecksum boolean indicating whether to calculate the checksum of the uploaded file.\n-     * @param token       session id of the user performing the upload.\n-     * @return a OpenCGAResult with the file uploaded.\n-     * @throws CatalogException if the user does not have permissions or any other unexpected issue happens.\n-     */\n-    public OpenCGAResult<File> upload(String studyStr, InputStream fileInputStream, File file, boolean overwrite, boolean parents,\n-                                      boolean calculateChecksum, String token) throws CatalogException {\n-        // Check basic parameters\n-        ParamUtils.checkObj(fileInputStream, \"fileInputStream\");\n-\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyStr\", studyStr)\n-                .append(\"file\", file)\n-                .append(\"overwrite\", overwrite)\n-                .append(\"parents\", parents)\n-                .append(\"calculateChecksum\", calculateChecksum)\n-                .append(\"token\", token);\n-        try {\n-            validateNewFile(study, file, token, overwrite);\n-\n-            File overwrittenFile = null;\n-            Query query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                    .append(FileDBAdaptor.QueryParams.PATH.key(), file.getPath());\n-            OpenCGAResult<File> fileDataResult = fileDBAdaptor.get(query, QueryOptions.empty());\n-            if (fileDataResult.getNumResults() > 0) {\n-                if (overwrite) {\n-                    overwrittenFile = fileDataResult.first();\n-                } else {\n-                    throw new CatalogException(\"Path \" + file.getPath() + \" already in use\");\n-                }\n-            }\n-\n-            OpenCGAResult<File> parentFolders = getParents(study.getUid(), file.getPath(), false, QueryOptions.empty());\n-            if (parentFolders.getNumResults() == 0) {\n-                // There always must be at least the root folder\n-                throw new CatalogException(\"Unexpected error happened.\");\n-            }\n-\n-            // Check permissions over the most internal path\n-            authorizationManager.checkFilePermission(study.getUid(), parentFolders.first().getUid(), userId,\n-                    FileAclEntry.FilePermissions.UPLOAD);\n-            authorizationManager.checkFilePermission(study.getUid(), parentFolders.first().getUid(), userId,\n-                    FileAclEntry.FilePermissions.WRITE);\n+    if (isRootFolder(file)) {\n+      throw new CatalogException(\"Can not rename root folder\");\n+    }\n \n-            // We obtain the basic studyPath where we will upload the file temporarily\n-            java.nio.file.Path studyPath = Paths.get(study.getUri());\n+    String oldPath = file.getPath();\n+    Path parent = Paths.get(oldPath).getParent();\n+    String newPath;\n+    if (parent == null) {\n+      newPath = newName;\n+    } else {\n+      newPath = parent.resolve(newName).toString();\n+    }\n \n-            IOManager ioManager;\n-            try {\n-                ioManager = ioManagerFactory.get(file.getUri());\n-            } catch (IOException e) {\n-                throw CatalogIOException.ioManagerException(file.getUri(), e);\n-            }\n-            // We attempt to create it first because it may be that the parent directories were not created because they don't contain any\n-            // files yet\n-\n-            if (parentFolders.first().getType() == File.Type.FILE && !overwrite) {\n-                throw new CatalogException(\"Cannot upload file in '\" + file.getPath() + \"'. \" + parentFolders.first().getPath()\n-                        + \"' is already an existing file path.\");\n-            } else if (parentFolders.first().getType() == File.Type.DIRECTORY) {\n-                ioManager.createDirectory(parentFolders.first().getUri(), true);\n+    IOManager ioManager = null;\n+    try {\n+      ioManager = ioManagerFactory.get(file.getUri());\n+    } catch (IOException e) {\n+      throw CatalogIOException.ioManagerException(file.getUri(), e);\n+    }\n+    URI oldUri = file.getUri();\n+    URI newUri = Paths.get(oldUri).getParent().resolve(newName).toUri();\n+//        URI studyUri = file.getUri();\n+    boolean isExternal = file.isExternal(); //If the file URI is not null, the file is external located.\n+\n+    switch (file.getType()) {\n+      case DIRECTORY:\n+        if (!isExternal) {  //Only rename non external files\n+          // TODO? check if something in the subtree is not READY?\n+          if (ioManager.exists(oldUri)) {\n+            ioManager.rename(oldUri, newUri);   // io.move() 1\n+          }\n+        }\n+        fileDBAdaptor.rename(file.getUid(), newPath, newUri.toString(), null);\n+        break;\n+      case FILE:\n+        if (!isExternal) {  //Only rename non external files\n+          ioManager.rename(oldUri, newUri);\n+        }\n+        fileDBAdaptor.rename(file.getUid(), newPath, newUri.toString(), null);\n+        break;\n+      default:\n+        throw new CatalogException(\"Unknown file type \" + file.getType());\n+    }\n+\n+    return fileDBAdaptor.get(file.getUid(), QueryOptions.empty());\n+  }\n+\n+  public OpenCGAResult<FileContent> grep(String studyId, String fileId, String pattern, boolean ignoreCase, int numLines, String token)\n+      throws CatalogException {\n+    long startTime = System.currentTimeMillis();\n+\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, userId);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"fileId\", fileId)\n+        .append(\"pattern\", pattern)\n+        .append(\"ignoreCase\", ignoreCase)\n+        .append(\"numLines\", numLines)\n+        .append(\"token\", token);\n+    try {\n+      File file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI, userId).first();\n+      authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.VIEW_CONTENT);\n+\n+      URI fileUri = getUri(file);\n+      FileContent fileContent;\n+      try {\n+        fileContent = ioManagerFactory.get(fileUri).grep(Paths.get(fileUri), pattern, numLines, ignoreCase);\n+      } catch (IOException e) {\n+        throw CatalogIOException.ioManagerException(fileUri, e);\n+      }\n+\n+      auditManager.audit(userId, Enums.Action.GREP, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return new OpenCGAResult<>((int) (System.currentTimeMillis() - startTime), Collections.emptyList(), 1,\n+          Collections.singletonList(fileContent), 1);\n+    } catch (CatalogException e) {\n+      auditManager.audit(userId, Enums.Action.GREP, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  public OpenCGAResult<FileContent> image(String studyStr, String fileId, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    long startTime = System.currentTimeMillis();\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"fileId\", fileId)\n+        .append(\"token\", token);\n+    File file;\n+    try {\n+      file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI_PATH, userId).first();\n+      authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.VIEW_CONTENT);\n+\n+      if (file.getFormat() != File.Format.IMAGE) {\n+        throw new CatalogException(\"File '\" + fileId + \"' is not an image. Format of file is '\" + file.getFormat() + \"'.\");\n+      }\n+\n+      URI fileUri = getUri(file);\n+      FileContent fileContent;\n+\n+      try {\n+        fileContent = ioManagerFactory.get(fileUri).base64Image(Paths.get(fileUri));\n+      } catch (IOException e) {\n+        throw CatalogIOException.ioManagerException(fileUri, e);\n+      }\n+      auditManager.audit(userId, Enums.Action.IMAGE_CONTENT, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return new OpenCGAResult<>((int) (System.currentTimeMillis() - startTime), Collections.emptyList(), 1,\n+          Collections.singletonList(fileContent), 1);\n+    } catch (CatalogException e) {\n+      auditManager.audit(userId, Enums.Action.IMAGE_CONTENT, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  public OpenCGAResult<FileContent> head(String studyStr, String fileId, long offset, int lines, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    long startTime = System.currentTimeMillis();\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"fileId\", fileId)\n+        .append(\"offset\", offset)\n+        .append(\"lines\", lines)\n+        .append(\"token\", token);\n+    File file;\n+    try {\n+      file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI, userId).first();\n+      authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.VIEW_CONTENT);\n+      URI fileUri = getUri(file);\n+      FileContent fileContent;\n+      try {\n+        fileContent = ioManagerFactory.get(fileUri).head(Paths.get(fileUri), offset, lines);\n+      } catch (IOException e) {\n+        throw CatalogIOException.ioManagerException(fileUri, e);\n+      }\n+      auditManager.audit(userId, Enums.Action.HEAD_CONTENT, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return new OpenCGAResult<>((int) (System.currentTimeMillis() - startTime), Collections.emptyList(), 1,\n+          Collections.singletonList(fileContent), 1);\n+    } catch (CatalogException e) {\n+      auditManager.audit(userId, Enums.Action.HEAD_CONTENT, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  public OpenCGAResult<FileContent> tail(String studyStr, String fileId, int lines, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    long startTime = System.currentTimeMillis();\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"fileId\", fileId)\n+        .append(\"lines\", lines)\n+        .append(\"token\", token);\n+    File file;\n+    try {\n+      file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI, userId).first();\n+      authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.VIEW_CONTENT);\n+      URI fileUri = getUri(file);\n+      FileContent fileContent;\n+      try {\n+        fileContent = ioManagerFactory.get(fileUri).tail(Paths.get(fileUri), lines);\n+      } catch (IOException e) {\n+        throw CatalogIOException.ioManagerException(fileUri, e);\n+      }\n+      auditManager.audit(userId, Enums.Action.TAIL_CONTENT, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+\n+      return new OpenCGAResult<>((int) (System.currentTimeMillis() - startTime), Collections.emptyList(), 1,\n+          Collections.singletonList(fileContent), 1);\n+    } catch (CatalogException e) {\n+      auditManager.audit(userId, Enums.Action.TAIL_CONTENT, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  public DataInputStream download(String studyStr, String fileId, String token) throws CatalogException {\n+    return download(studyStr, fileId, -1, -1, token);\n+  }\n+\n+  public DataInputStream download(String studyStr, String fileId, int start, int limit, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"study\", studyStr)\n+        .append(\"fileId\", fileId)\n+        .append(\"start\", start)\n+        .append(\"limit\", limit)\n+        .append(\"token\", token);\n+    File file;\n+    try {\n+      file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI, userId).first();\n+      authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.DOWNLOAD);\n+      URI fileUri = getUri(file);\n+      DataInputStream dataInputStream;\n+      try {\n+        dataInputStream = ioManagerFactory.get(fileUri).getFileObject(fileUri, start, limit);\n+      } catch (IOException e) {\n+        throw CatalogIOException.ioManagerException(fileUri, e);\n+      }\n+\n+      auditManager.audit(userId, Enums.Action.DOWNLOAD, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n+          study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      return dataInputStream;\n+    } catch (CatalogException e) {\n+      auditManager.audit(userId, Enums.Action.DOWNLOAD, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n+          auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n+      throw e;\n+    }\n+  }\n+\n+  public void setFileIndex(String studyStr, String fileId, FileIndex index, String sessionId) throws CatalogException {\n+    String userId = userManager.getUserId(sessionId);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+    long fileUid = internalGet(study.getUid(), fileId, INCLUDE_FILE_IDS, userId).first().getUid();\n+\n+    authorizationManager.checkFilePermission(study.getUid(), fileUid, userId, FileAclEntry.FilePermissions.WRITE);\n+\n+    ObjectMap parameters = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), index);\n+    fileDBAdaptor.update(fileUid, parameters, QueryOptions.empty());\n+  }\n+\n+  // **************************   ACLs  ******************************** //\n+  public OpenCGAResult<Map<String, List<String>>> getAcls(String studyId, List<String> fileList, String member, boolean ignoreException,\n+                                                          String token) throws CatalogException {\n+    String user = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, user);\n+\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"fileList\", fileList)\n+        .append(\"member\", member)\n+        .append(\"ignoreException\", ignoreException)\n+        .append(\"token\", token);\n+    try {\n+      OpenCGAResult<Map<String, List<String>>> fileAclList = OpenCGAResult.empty();\n+      InternalGetDataResult<File> fileDataResult = internalGet(study.getUid(), fileList, INCLUDE_FILE_IDS, user, ignoreException);\n+\n+      Map<String, InternalGetDataResult.Missing> missingMap = new HashMap<>();\n+      if (fileDataResult.getMissing() != null) {\n+        missingMap = fileDataResult.getMissing().stream()\n+            .collect(Collectors.toMap(InternalGetDataResult.Missing::getId, Function.identity()));\n+      }\n+      int counter = 0;\n+      for (String fileId : fileList) {\n+        if (!missingMap.containsKey(fileId)) {\n+          File file = fileDataResult.getResults().get(counter);\n+          try {\n+            OpenCGAResult<Map<String, List<String>>> allFileAcls;\n+            if (StringUtils.isNotEmpty(member)) {\n+              allFileAcls = authorizationManager.getFileAcl(study.getUid(), file.getUid(), user, member);\n+            } else {\n+              allFileAcls = authorizationManager.getAllFileAcls(study.getUid(), file.getUid(), user, true);\n             }\n-            ioManager.checkWritableUri(parentFolders.first().getUri());\n-\n-            java.nio.file.Path tempFilePath = studyPath.resolve(\"tmp_\" + file.getName()).resolve(file.getName());\n-            URI tempDirectory = tempFilePath.getParent().toUri();\n-            logger.info(\"Uploading file... Temporal file path: {}\", tempFilePath.toString());\n-\n-            // Create the temporal directory and upload the file\n-            try {\n-                if (!ioManager.exists(tempFilePath.getParent().toUri())) {\n-                    logger.debug(\"Creating temporal folder: {}\", tempFilePath.getParent());\n-                    ioManager.createDirectory(tempDirectory, true);\n-                }\n+            fileAclList.append(allFileAcls);\n \n-                // Start uploading the file to the temporal directory\n-                // Upload the file to a temporary folder\n-                ioManager.copy(fileInputStream, tempFilePath.toUri());\n-            } catch (Exception e) {\n-                logger.error(\"Error uploading file {}\", file.getName(), e);\n+            auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FILE, file.getId(),\n+                file.getUuid(), study.getId(), study.getUuid(), auditParams,\n+                new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS), new ObjectMap());\n+          } catch (CatalogException e) {\n+            auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FILE, file.getId(),\n+                file.getUuid(), study.getId(), study.getUuid(), auditParams,\n+                new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()), new ObjectMap());\n \n-                // Clean temporal directory\n-                ioManager.deleteDirectory(tempDirectory);\n-\n-                throw new CatalogException(\"Error uploading file \" + file.getName(), e);\n+            if (!ignoreException) {\n+              throw e;\n+            } else {\n+              Event event = new Event(Event.Type.ERROR, fileId, missingMap.get(fileId).getErrorMsg());\n+              fileAclList.append(new OpenCGAResult<>(0, Collections.singletonList(event), 0,\n+                  Collections.singletonList(Collections.emptyMap()), 0));\n             }\n-            URI sourceUri = tempFilePath.toUri();\n+          }\n+          counter += 1;\n+        } else {\n+          Event event = new Event(Event.Type.ERROR, fileId, missingMap.get(fileId).getErrorMsg());\n+          fileAclList.append(new OpenCGAResult<>(0, Collections.singletonList(event), 0,\n+              Collections.singletonList(Collections.emptyMap()), 0));\n+\n+          auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FILE, fileId, \"\",\n+              study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n+                  new Error(0, \"\", missingMap.get(fileId).getErrorMsg())), new ObjectMap());\n+        }\n+      }\n+      return fileAclList;\n+    } catch (CatalogException e) {\n+      for (String fileId : fileList) {\n+        auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FILE, fileId, \"\", study.getId(),\n+            study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()),\n+            new ObjectMap());\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  public OpenCGAResult<Map<String, List<String>>> updateAcl(String studyId, List<String> fileStrList, String memberList,\n+                                                            FileAclParams aclParams, ParamUtils.AclAction action, String token)\n+      throws CatalogException {\n+    String user = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyId, user);\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"fileStrList\", fileStrList)\n+        .append(\"memberList\", memberList)\n+        .append(\"aclParams\", aclParams)\n+        .append(\"action\", action)\n+        .append(\"token\", token);\n+    String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n+\n+    try {\n+      int count = 0;\n+      count += fileStrList != null && !fileStrList.isEmpty() ? 1 : 0;\n+      count += StringUtils.isNotEmpty(aclParams.getSample()) ? 1 : 0;\n+\n+      if (count > 1) {\n+        throw new CatalogException(\"Update ACL: Only one of these parameters are allowed: file or sample per query.\");\n+      } else if (count == 0) {\n+        throw new CatalogException(\"Update ACL: At least one of these parameters should be provided: file or sample\");\n+      }\n+\n+      if (action == null) {\n+        throw new CatalogException(\"Invalid action found. Please choose a valid action to be performed.\");\n+      }\n+\n+      List<String> permissions = Collections.emptyList();\n+      if (StringUtils.isNotEmpty(aclParams.getPermissions())) {\n+        permissions = Arrays.asList(aclParams.getPermissions().trim().replaceAll(\"\\\\s\", \"\").split(\",\"));\n+        checkPermissions(permissions, FileAclEntry.FilePermissions::valueOf);\n+      }\n+\n+\n+      List<File> extendedFileList;\n+      if (StringUtils.isNotEmpty(aclParams.getSample())) {\n+        // Obtain the sample ids\n+        OpenCGAResult<Sample> sampleDataResult = catalogManager.getSampleManager().internalGet(study.getUid(),\n+            Arrays.asList(StringUtils.split(aclParams.getSample(), \",\")), SampleManager.INCLUDE_SAMPLE_IDS, user, false);\n+        Query query = new Query(FileDBAdaptor.QueryParams.SAMPLE_IDS.key(),\n+            sampleDataResult.getResults().stream().map(Sample::getId).collect(Collectors.toList()));\n+\n+        extendedFileList = catalogManager.getFileManager().search(studyId, query, EXCLUDE_FILE_ATTRIBUTES, token).getResults();\n+      } else {\n+        extendedFileList = internalGet(study.getUid(), fileStrList, EXCLUDE_FILE_ATTRIBUTES, user, false).getResults();\n+      }\n+\n+      authorizationManager.checkCanAssignOrSeePermissions(study.getUid(), user);\n+\n+      // Increase the list with the files/folders within the list of ids that correspond with folders\n+      extendedFileList = getRecursiveFilesAndFolders(study.getUid(), extendedFileList);\n+\n+      // Validate that the members are actually valid members\n+      List<String> members;\n+      if (memberList != null && !memberList.isEmpty()) {\n+        members = Arrays.asList(memberList.split(\",\"));\n+      } else {\n+        members = Collections.emptyList();\n+      }\n+      authorizationManager.checkNotAssigningPermissionsToAdminsGroup(members);\n+      checkMembers(study.getUid(), members);\n+\n+      List<Long> fileUids = extendedFileList.stream().map(File::getUid).collect(Collectors.toList());\n+      AuthorizationManager.CatalogAclParams catalogAclParams = new AuthorizationManager.CatalogAclParams(fileUids, permissions,\n+          Enums.Resource.FILE);\n+//        studyManager.membersHavePermissionsInStudy(resourceIds.getStudyId(), members);\n \n-            List<Sample> existingSamples = new LinkedList<>();\n-            List<Sample> nonExistingSamples = new LinkedList<>();\n+      OpenCGAResult<Map<String, List<String>>> queryResultList;\n+      switch (action) {\n+        case SET:\n+          queryResultList = authorizationManager.setAcls(study.getUid(), members, catalogAclParams);\n+          break;\n+        case ADD:\n+          queryResultList = authorizationManager.addAcls(study.getUid(), members, catalogAclParams);\n+          break;\n+        case REMOVE:\n+          queryResultList = authorizationManager.removeAcls(members, catalogAclParams);\n+          break;\n+        case RESET:\n+          catalogAclParams.setPermissions(null);\n+          queryResultList = authorizationManager.removeAcls(members, catalogAclParams);\n+          break;\n+        default:\n+          throw new CatalogException(\"Unexpected error occurred. No valid action found.\");\n+      }\n+      for (File file : extendedFileList) {\n+        auditManager.audit(operationId, user, Enums.Action.UPDATE_ACLS, Enums.Resource.FILE, file.getId(),\n+            file.getUuid(), study.getId(), study.getUuid(), auditParams,\n+            new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS), new ObjectMap());\n+      }\n+      return queryResultList;\n+    } catch (CatalogException e) {\n+      if (fileStrList != null) {\n+        for (String fileId : fileStrList) {\n+          auditManager.audit(operationId, user, Enums.Action.UPDATE_ACLS, Enums.Resource.FILE, fileId, \"\",\n+              study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n+                  e.getError()), new ObjectMap());\n+        }\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  public OpenCGAResult<File> getParents(String studyStr, String path, boolean rootFirst, QueryOptions options, String token)\n+      throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+\n+    List<String> paths = calculateAllPossiblePaths(path);\n+\n+    Query query = new Query(FileDBAdaptor.QueryParams.PATH.key(), paths);\n+    query.put(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+    OpenCGAResult<File> result = fileDBAdaptor.get(study.getUid(), query, options, userId);\n+    result.getResults().sort(rootFirst ? ROOT_FIRST_COMPARATOR : ROOT_LAST_COMPARATOR);\n+    return result;\n+  }\n+\n+\n+  // **************************   Private methods   ******************************** //\n+  private boolean isRootFolder(File file) throws CatalogException {\n+    ParamUtils.checkObj(file, \"File\");\n+    return file.getPath().isEmpty();\n+  }\n+\n+  /**\n+   * Fetch all the recursive files and folders within the list of file ids given.\n+   *\n+   * @param studyUid Study uid.\n+   * @param fileList List of files\n+   * @return a more complete file list containing all the nested files\n+   */\n+  private List<File> getRecursiveFilesAndFolders(long studyUid, List<File> fileList) throws CatalogException {\n+    List<File> fileListCopy = new LinkedList<>();\n+    fileListCopy.addAll(fileList);\n+\n+    Set<Long> uidFileSet = new HashSet<>();\n+    uidFileSet.addAll(fileList.stream().map(File::getUid).collect(Collectors.toSet()));\n+\n+    List<String> pathList = new ArrayList<>();\n+    for (File file : fileList) {\n+      if (file.getType().equals(File.Type.DIRECTORY)) {\n+        pathList.add(\"~^\" + file.getPath());\n+      }\n+    }\n+\n+    if (CollectionUtils.isNotEmpty(pathList)) {\n+      // Search for all the files within the list of paths\n+      Query query = new Query()\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n+          .append(FileDBAdaptor.QueryParams.PATH.key(), pathList);\n+      OpenCGAResult<File> fileDataResult1 = fileDBAdaptor.get(query, INCLUDE_FILE_URI_PATH);\n+      for (File file1 : fileDataResult1.getResults()) {\n+        if (!uidFileSet.contains(file1.getUid())) {\n+          uidFileSet.add(file1.getUid());\n+          fileListCopy.add(file1);\n+        }\n+      }\n+    }\n+\n+    return fileListCopy;\n+  }\n+\n+  private List<String> calculateAllPossiblePaths(String filePath) {\n+    String path = \"\";\n+    String[] split = filePath.split(\"/\");\n+    List<String> paths = new ArrayList<>(split.length + 1);\n+    paths.add(\"\");  //Add study root folder\n+    //Add intermediate folders\n+    //Do not add the last split, could be a file or a folder..\n+    //Depending on this, it could end with '/' or not.\n+    for (int i = 0; i < split.length - 1; i++) {\n+      String f = split[i];\n+      path = path + f + \"/\";\n+      paths.add(path);\n+    }\n+    paths.add(filePath); //Add the file path\n+    return paths;\n+  }\n+\n+  //FIXME: This should use org.opencb.opencga.storage.core.variant.io.VariantReaderUtils\n+  private String getMainVariantFile(String name) {\n+    if (name.endsWith(\".variants.avro.gz\") || name.endsWith(\".variants.proto.gz\") || name.endsWith(\".variants.json.gz\")) {\n+      int idx = name.lastIndexOf(\".variants.\");\n+      return name.substring(0, idx);\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private boolean isTransformedFile(String name) {\n+    return getMainVariantFile(name) != null;\n+  }\n+\n+  private String getVariantMetadataFile(String path) {\n+    String file = getMainVariantFile(path);\n+    if (file != null) {\n+      return file + \".file.json.gz\";\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private OpenCGAResult<File> getParents(long studyUid, String filePath, boolean rootFirst, QueryOptions options)\n+      throws CatalogException {\n+    List<String> paths = calculateAllPossiblePaths(filePath);\n+\n+    Query query = new Query(FileDBAdaptor.QueryParams.PATH.key(), paths);\n+    query.put(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid);\n+    OpenCGAResult<File> result = fileDBAdaptor.get(query, options);\n+    result.getResults().sort(rootFirst ? ROOT_FIRST_COMPARATOR : ROOT_LAST_COMPARATOR);\n+    return result;\n+  }\n+\n+  private String getParentPath(String path) {\n+    Path parent = Paths.get(path).getParent();\n+    String parentPath;\n+    if (parent == null) {   //If parent == null, the file is in the root of the study\n+      parentPath = \"\";\n+    } else {\n+      parentPath = parent.toString() + \"/\";\n+    }\n+    return parentPath;\n+  }\n+\n+  /**\n+   * Get the URI where a file should be in Catalog, given a study and a path.\n+   *\n+   * @param studyId   Study identifier\n+   * @param path      Path to locate\n+   * @param directory Boolean indicating if the file is a directory\n+   * @return URI where the file should be placed\n+   * @throws CatalogException CatalogException\n+   */\n+  private URI getFileUri(long studyId, String path, boolean directory) throws CatalogException, URISyntaxException {\n+    // Get the closest existing parent. If parents == true, may happen that the parent is not registered in catalog yet.\n+    File existingParent = getParents(studyId, path, false, null).first();\n+\n+    //Relative path to the existing parent\n+    String relativePath = Paths.get(existingParent.getPath()).relativize(Paths.get(path)).toString();\n+    if (path.endsWith(\"/\") && !relativePath.endsWith(\"/\")) {\n+      relativePath += \"/\";\n+    }\n+\n+    String uriStr = Paths.get(existingParent.getUri().getPath()).resolve(relativePath).toString();\n+\n+    if (directory) {\n+      return UriUtils.createDirectoryUri(uriStr);\n+    } else {\n+      return UriUtils.createUri(uriStr);\n+    }\n+  }\n+\n+  private boolean isExternal(Study study, String catalogFilePath, URI fileUri) throws CatalogException {\n+    URI studyUri = study.getUri();\n+\n+    String studyFilePath = Paths.get(studyUri).resolve(catalogFilePath).toString();\n+    String originalFilePath = Paths.get(fileUri).toString();\n+\n+    logger.debug(\"Study file path: {}\", studyFilePath);\n+    logger.debug(\"File path: {}\", originalFilePath);\n+    return !studyFilePath.equals(originalFilePath);\n+  }\n+\n+  /**\n+   * Method to check if a file or folder can be deleted. It will check for indexation, status, permissions and file system availability.\n+   *\n+   * @param studyStr Study.\n+   * @param fileId   File or folder id.\n+   * @param unlink   Boolean indicating whether the operation only expects to remove the entry from the database or also remove\n+   *                 the file from disk.\n+   * @param token    Token of the user for which DELETE permissions will be checked.\n+   * @throws CatalogException if any of the files cannot be deleted.\n+   */\n+  public void checkCanDeleteFile(String studyStr, String fileId, boolean unlink, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    Study study = studyManager.resolveId(studyStr, userId);\n+    checkCanDeleteFile(study, fileId, unlink, Arrays.asList(FileStatus.READY, FileStatus.TRASHED), userId);\n+  }\n+\n+  /**\n+   * Method to check if a file or folder can be deleted. It will check for indexation, status, permissions and file system availability.\n+   *\n+   * @param study          Study.\n+   * @param fileId         File or folder id.\n+   * @param unlink         Boolean indicating whether the operation only expects to remove the entry from the database or also remove\n+   *                       the file from disk.\n+   * @param acceptedStatus List of valid statuses the file should have. For the public, the file should be in READY or TRASHED status.\n+   *                       However, if someone calls to the delete/unlink methods, the status of those files should already be in\n+   *                       PENDING_DELETE.\n+   * @param userId         user for which DELETE permissions will be checked.\n+   * @throws CatalogException if any of the files cannot be deleted.\n+   */\n+  private void checkCanDeleteFile(Study study, String fileId, boolean unlink, List<String> acceptedStatus, String userId)\n+      throws CatalogException {\n+\n+    QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.UID.key(),\n+        FileDBAdaptor.QueryParams.NAME.key(), FileDBAdaptor.QueryParams.TYPE.key(), FileDBAdaptor.QueryParams.RELATED_FILES.key(),\n+        FileDBAdaptor.QueryParams.SIZE.key(), FileDBAdaptor.QueryParams.URI.key(), FileDBAdaptor.QueryParams.PATH.key(),\n+        FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), FileDBAdaptor.QueryParams.INTERNAL_STATUS.key(),\n+        FileDBAdaptor.QueryParams.EXTERNAL.key()));\n+\n+    OpenCGAResult<File> fileOpenCGAResult = internalGet(study.getUid(), fileId, options, userId);\n+    if (fileOpenCGAResult.getNumResults() == 0) {\n+      throw new CatalogException(\"File \" + fileId + \" not found\");\n+    }\n+    File file = fileOpenCGAResult.first();\n+\n+    // If the user is the owner or the admin, we won't check if he has permissions for every single file\n+    boolean checkPermissions = !authorizationManager.isOwnerOrAdmin(study.getUid(), userId);\n+\n+    Set<Long> indexFiles = new HashSet<>();\n+\n+    if (unlink && !file.isExternal()) {\n+      throw new CatalogException(\"Cannot unlink non-external files. Use delete operation instead\");\n+    } else if (!unlink && file.isExternal()) {\n+      throw new CatalogException(\"Cannot delete external files. Use unlink operation instead\");\n+    }\n+\n+    IOManager ioManager;\n+    try {\n+      ioManager = ioManagerFactory.get(file.getUri());\n+    } catch (IOException e) {\n+      throw CatalogIOException.ioManagerException(file.getUri(), e);\n+    }\n+    if (file.getType() == File.Type.FILE) {\n+      if (checkPermissions) {\n+        authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+        authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.DELETE);\n+      }\n \n-            // Move the file from the temporal directory\n-            try {\n-                // Create the directories where the file will be placed (if they weren't created before)\n-                ioManager.createDirectory(Paths.get(file.getUri()).getParent().toUri(), true);\n+      // File must exist in the file system\n+      if (!unlink && !ioManager.exists(file.getUri())) {\n+        throw new CatalogException(\"File \" + file.getUri() + \" not found in file system\");\n+      }\n \n-                String checksum = null;\n-                if (calculateChecksum) {\n-                    checksum = ioManager.calculateChecksum(sourceUri);\n-                }\n-                if (overwrite) {\n-                    ioManager.move(sourceUri, file.getUri(), StandardCopyOption.REPLACE_EXISTING);\n-                } else {\n-                    ioManager.move(sourceUri, file.getUri());\n-                }\n-                if (calculateChecksum && !checksum.equals(ioManager.calculateChecksum(file.getUri()))) {\n-                    throw new CatalogIOException(\"Error moving file from \" + sourceUri + \" to \" + file.getUri());\n-                }\n+      checkValidStatusForDeletion(file, acceptedStatus);\n+      indexFiles.addAll(getProducedFromIndexFiles(file));\n+    } else {\n+      // We cannot delete the root folder\n+      if (isRootFolder(file)) {\n+        throw new CatalogException(\"Root directories cannot be deleted\");\n+      }\n \n-                // Remove the temporal directory\n-                ioManager.deleteDirectory(tempDirectory);\n+      // Query to get all recursive files and folders\n+      Query query = new Query()\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+          .append(FileDBAdaptor.QueryParams.PATH.key(), \"~^\" + file.getPath() + \"*\");\n \n-                file.setChecksum(checksum);\n+      if (unlink) {\n+        // Only external files/folders are allowed within the folder\n+        Query tmpQuery = new Query(query)\n+            .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), false);\n+        long numMatches = fileDBAdaptor.count(tmpQuery).getNumMatches();\n \n-                // Improve metadata information and extract samples if any\n-                new FileMetadataReader(catalogManager).addMetadataInformation(study.getFqn(), file);\n-                validateNewSamples(study, file, existingSamples, nonExistingSamples, token);\n-            } catch (CatalogException e) {\n-                ioManager.deleteDirectory(tempDirectory);\n-                logger.error(\"Upload file: {}\", e.getMessage(), e);\n-                throw new CatalogException(\"Upload file failed. Could not move the content to \" + file.getUri() + \": \" + e.getMessage());\n-            }\n+        if (numMatches > 0) {\n+          throw new CatalogException(numMatches + \" local files detected within the external \"\n+              + \"folder \" + file.getPath() + \". Please, delete those folders or files manually first\");\n+        }\n+      } else {\n+        // Only non-external files/folders are allowed within the folder\n+        Query tmpQuery = new Query(query)\n+            .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), true);\n+        long numMatches = fileDBAdaptor.count(tmpQuery).getNumMatches();\n \n-            // Register the file in catalog\n-            try {\n-                if (overwrittenFile != null) {\n-                    // We need to update the existing file document\n-                    ObjectMap params = new ObjectMap();\n-                    QueryOptions queryOptions = new QueryOptions();\n-\n-                    params.put(FileDBAdaptor.QueryParams.SIZE.key(), file.getSize());\n-                    params.put(FileDBAdaptor.QueryParams.URI.key(), file.getUri());\n-                    params.put(FileDBAdaptor.QueryParams.EXTERNAL.key(), file.isExternal());\n-                    params.put(FileDBAdaptor.QueryParams.INTERNAL_STATUS_NAME.key(), FileStatus.READY);\n-                    params.put(FileDBAdaptor.QueryParams.CHECKSUM.key(), file.getChecksum());\n-\n-                    if (file.getSampleIds() != null && !file.getSampleIds().isEmpty()) {\n-                        params.put(FileDBAdaptor.QueryParams.SAMPLE_IDS.key(), file.getSampleIds());\n-\n-                        // Set new samples\n-                        Map<String, Object> actionMap = new HashMap<>();\n-                        actionMap.put(FileDBAdaptor.QueryParams.SAMPLE_IDS.key(), ParamUtils.UpdateAction.SET.name());\n-                        queryOptions.put(Constants.ACTIONS, actionMap);\n-                    }\n-                    if (!file.getAttributes().isEmpty()) {\n-                        Map<String, Object> attributes = overwrittenFile.getAttributes();\n-                        attributes.putAll(file.getAttributes());\n-                        params.put(FileDBAdaptor.QueryParams.ATTRIBUTES.key(), attributes);\n-                    }\n-                    if (!file.getStats().isEmpty()) {\n-                        Map<String, Object> stats = overwrittenFile.getStats();\n-                        stats.putAll(file.getStats());\n-                        params.put(FileDBAdaptor.QueryParams.STATS.key(), stats);\n-                    }\n-\n-                    fileDBAdaptor.update(overwrittenFile.getUid(), params, null, queryOptions);\n-                } else {\n-                    // We need to register a new file\n-                    register(study, file, existingSamples, nonExistingSamples, parents, QueryOptions.empty(), token);\n-                }\n-            } catch (CatalogException e) {\n-                ioManager.deleteFile(file.getUri());\n-                logger.error(\"Upload file: {}\", e.getMessage(), e);\n-                throw new CatalogException(\"Upload file failed. Could not register the file in the DB: \" + e.getMessage());\n-            }\n+        if (numMatches > 0) {\n+          throw new CatalogException(numMatches + \" external files detected within the local \"\n+              + \"folder \" + file.getPath() + \". Please, unlink those folders or files manually first\");\n+        }\n+      }\n \n-            auditManager.auditCreate(userId, Enums.Action.UPLOAD, Enums.Resource.FILE, file.getId(), file.getUuid(),\n-                    study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+      DBIterator<File> iterator = fileDBAdaptor.iterator(query, options);\n+      while (iterator.hasNext()) {\n+        File tmpFile = iterator.next();\n \n-            return fileDBAdaptor.get(query, QueryOptions.empty());\n-        } catch (CatalogException e) {\n-            auditManager.auditCreate(userId, Enums.Action.UPLOAD, Enums.Resource.FILE, file.getId(), \"\", study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n+        if (checkPermissions) {\n+          authorizationManager.checkFilePermission(study.getUid(), tmpFile.getUid(), userId, FileAclEntry.FilePermissions.DELETE);\n+          authorizationManager.checkFilePermission(study.getUid(), tmpFile.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n         }\n-    }\n \n-    /**\n-     * Moves a file not yet registered in OpenCGA from origin to finalDestiny in the file system and then registers it in the study.\n-     *\n-     * @param studyStr      Study to which the file will belong.\n-     * @param fileSource    Current location of the file (file system).\n-     * @param folderDestiny Directory where the file needs to be moved (file system).\n-     * @param path          Directory in catalog where the file will be registered (catalog).\n-     * @param token         Token of the user.\n-     * @return An OpenCGAResult with the file registry after moving it to the final destination.\n-     * @throws CatalogException CatalogException.\n-     */\n-    public OpenCGAResult<File> moveAndRegister(String studyStr, Path fileSource, @Nullable Path folderDestiny, @Nullable String path,\n-                                               String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyStr\", studyStr)\n-                .append(\"fileSource\", fileSource)\n-                .append(\"folderDestiny\", folderDestiny)\n-                .append(\"path\", path)\n-                .append(\"token\", token);\n+        // File must exist in the file system\n+        if (!unlink && !ioManager.exists(tmpFile.getUri())) {\n+          throw new CatalogException(\"File \" + tmpFile.getUri() + \" not found in file system\");\n+        }\n \n-        try {\n-            try {\n-                FileUtils.checkFile(fileSource);\n-            } catch (IOException e) {\n-                throw new CatalogException(\"File '\" + fileSource + \"' not found\", e);\n-            }\n-            String fileName = fileSource.toFile().getName();\n+        checkValidStatusForDeletion(tmpFile, acceptedStatus);\n+        indexFiles.addAll(getProducedFromIndexFiles(tmpFile));\n+      }\n \n-            if (folderDestiny == null && path == null) {\n-                throw new CatalogException(\"'folderDestiny' and 'path' cannot be both null.\");\n-            }\n+      // TODO: Validate no file/folder within any registered directory is not registered in OpenCGA\n+    }\n \n-            boolean external = false;\n-            if (folderDestiny == null) {\n-                if (path.startsWith(\"/\")) {\n-                    path = path.substring(1);\n-                }\n-                File parentFolder = getParents(study.getUid(), path, false, INCLUDE_FILE_URI_PATH).first();\n \n-                // We get the relative path\n-                String relativePath = Paths.get(parentFolder.getPath()).relativize(Paths.get(path)).toString();\n-                folderDestiny = Paths.get(parentFolder.getUri()).resolve(relativePath);\n-            }\n+    // Check the original files are not being indexed at the moment\n+    if (!indexFiles.isEmpty()) {\n+      Query query = new Query(FileDBAdaptor.QueryParams.UID.key(), new ArrayList<>(indexFiles));\n+      try (DBIterator<File> iterator = fileDBAdaptor.iterator(query, new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(\n+          FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), FileDBAdaptor.QueryParams.UID.key())))) {\n+        while (iterator.hasNext()) {\n+          File next = iterator.next();\n+          String status = next.getInternal().getIndex().getStatus().getName();\n+          switch (status) {\n+            case FileIndex.IndexStatus.READY:\n+              // If they are already ready, we only need to remove the reference to the transformed files as they will be\n+              // removed\n+              next.getInternal().getIndex().setTransformedFile(null);\n+              break;\n+            case FileIndex.IndexStatus.TRANSFORMED:\n+              // We need to remove the reference to the transformed files and change their status from TRANSFORMED to NONE\n+              next.getInternal().getIndex().setTransformedFile(null);\n+              next.getInternal().getIndex().getStatus().setName(FileIndex.IndexStatus.NONE);\n+              break;\n+            case FileIndex.IndexStatus.NONE:\n+            case FileIndex.IndexStatus.DELETED:\n+              break;\n+            default:\n+              throw new CatalogException(\"Cannot delete files that are in use in storage.\");\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Set<Long> getProducedFromIndexFiles(File fileAux) {\n+    // Check if the file is produced from other file being indexed and add them to the transformedFromFileIds set\n+    if (fileAux.getRelatedFiles() != null && !fileAux.getRelatedFiles().isEmpty()) {\n+      return fileAux.getRelatedFiles().stream()\n+          .filter(myFile -> myFile.getRelation() == FileRelatedFile.Relation.PRODUCED_FROM)\n+          .map(FileRelatedFile::getFile)\n+          .map(File::getUid)\n+          .collect(Collectors.toSet());\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  void checkValidStatusForDeletion(File file, List<String> expectedStatus) throws CatalogException {\n+    if (file.getInternal().getStatus() == null) {\n+      throw new CatalogException(\"Cannot check file status for deletion\");\n+    }\n+    for (String status : expectedStatus) {\n+      if (status.equals(file.getInternal().getStatus().getName())) {\n+        // Valid status\n+        return;\n+      }\n+    }\n+    throw new CatalogException(\"Cannot delete file: \" + file.getName() + \". The status is \" + file.getInternal().getStatus().getName());\n+  }\n+\n+  public DataResult<FacetField> facet(String studyId, Query query, QueryOptions options, boolean defaultStats, String token)\n+      throws CatalogException, IOException {\n+    ParamUtils.defaultObject(query, Query::new);\n+    ParamUtils.defaultObject(options, QueryOptions::new);\n+\n+    String userId = userManager.getUserId(token);\n+    // We need to add variableSets and groups to avoid additional queries as it will be used in the catalogSolrManager\n+    Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n+        Arrays.asList(StudyDBAdaptor.QueryParams.VARIABLE_SET.key(), StudyDBAdaptor.QueryParams.GROUPS.key())));\n+\n+    ObjectMap auditParams = new ObjectMap()\n+        .append(\"studyId\", studyId)\n+        .append(\"query\", new Query(query))\n+        .append(\"options\", options)\n+        .append(\"defaultStats\", defaultStats)\n+        .append(\"token\", token);\n+    try {\n+      if (defaultStats || StringUtils.isEmpty(options.getString(QueryOptions.FACET))) {\n+        String facet = options.getString(QueryOptions.FACET);\n+        options.put(QueryOptions.FACET, StringUtils.isNotEmpty(facet) ? defaultFacet + \";\" + facet : defaultFacet);\n+      }\n+\n+      AnnotationUtils.fixQueryAnnotationSearch(study, userId, query, authorizationManager);\n+\n+      try (CatalogSolrManager catalogSolrManager = new CatalogSolrManager(catalogManager)) {\n+        DataResult<FacetField> result = catalogSolrManager.facetedQuery(study, CatalogSolrManager.FILE_SOLR_COLLECTION, query,\n+            options, userId);\n+        auditManager.auditFacet(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n+            new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n \n-            if (folderDestiny.toString().startsWith(study.getUri().getPath())) {\n-                if (StringUtils.isNotEmpty(path)) {\n-                    String myPath = path;\n-                    if (!myPath.endsWith(\"/\")) {\n-                        myPath += \"/\";\n-                    }\n-                    myPath += fileName;\n-\n-                    String relativePath = Paths.get(study.getUri().getPath()).relativize(folderDestiny.resolve(fileName)).toString();\n-                    if (!relativePath.equals(myPath)) {\n-                        throw new CatalogException(\"Destination uri within the workspace and path do not match\");\n-                    }\n-                } else {\n-                    //Set the path to whichever path would corresponding based on the workspace uri\n-                    path = Paths.get(study.getUri().getPath()).relativize(folderDestiny).toString();\n-                }\n+        return result;\n+      }\n+    } catch (CatalogException e) {\n+      auditManager.auditFacet(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n+          new AuditRecord.Status(AuditRecord.Status.Result.ERROR, new Error(0, \"\", e.getMessage())));\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create the parent directories that are needed.\n+   *\n+   * @param study            study where they will be created.\n+   * @param userId           user that is creating the parents.\n+   * @param studyURI         Base URI where the created folders will be pointing to. (base physical location)\n+   * @param path             Path used in catalog as a virtual location. (whole bunch of directories inside the virtual\n+   *                         location in catalog)\n+   * @param checkPermissions Boolean indicating whether to check if the user has permissions to create a folder in the first directory\n+   *                         that is available in catalog.\n+   * @throws CatalogDBException\n+   */\n+  private void createParents(Study study, String userId, URI studyURI, Path path, boolean checkPermissions) throws CatalogException {\n+    if (path == null) {\n+      if (checkPermissions) {\n+        authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_FILES);\n+      }\n+      return;\n+    }\n+\n+    String stringPath = path.toString();\n+    if ((\"/\").equals(stringPath)) {\n+      return;\n+    }\n \n-                File parentFolder = getParents(study.getUid(), path, false, INCLUDE_FILE_URI_PATH).first();\n-                authorizationManager.checkFilePermission(study.getUid(), parentFolder.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n-            } else {\n-                // It will be moved to an external folder. Only admins can move to that directory\n-                if (!authorizationManager.isOwnerOrAdmin(study.getUid(), userId)) {\n-                    throw new CatalogAuthorizationException(\"Only owners or administrative users are allowed to move to folders different \"\n-                            + \"than the main OpenCGA workspace\");\n-                }\n-                external = true;\n-            }\n+    logger.debug(\"Path: {}\", stringPath);\n \n-            String filePath = path;\n-            if (!filePath.endsWith(\"/\")) {\n-                filePath += \"/\";\n-            }\n-            filePath += fileName;\n-            // Check the path is not in use\n-            Query query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.PATH.key(), filePath)\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-            if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n-                throw new CatalogException(\"Path '\" + filePath + \"' already in use in OpenCGA\");\n-            }\n+    if (stringPath.startsWith(\"/\")) {\n+      stringPath = stringPath.substring(1);\n+    }\n+\n+    if (!stringPath.endsWith(\"/\")) {\n+      stringPath = stringPath + \"/\";\n+    }\n \n-            URI folderDestinyUri = folderDestiny.toUri();\n-            IOManager ioManager = null;\n-            try {\n-                ioManager = ioManagerFactory.get(folderDestinyUri);\n-            } catch (IOException e) {\n-                throw CatalogIOException.ioManagerException(folderDestinyUri, e);\n-            }\n-            // Check uri-path\n-            try {\n-                if (!ioManager.exists(folderDestinyUri)) {\n-                    ioManager.createDirectory(folderDestinyUri, true);\n-                }\n+    // Check if the folder exists\n+    Query query = new Query()\n+        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+        .append(FileDBAdaptor.QueryParams.PATH.key(), stringPath);\n+\n+    if (fileDBAdaptor.count(query).getNumMatches() == 0) {\n+      createParents(study, userId, studyURI, path.getParent(), checkPermissions);\n+    } else {\n+      if (checkPermissions) {\n+        long fileId = fileDBAdaptor.getId(study.getUid(), stringPath);\n+        authorizationManager.checkFilePermission(study.getUid(), fileId, userId, FileAclEntry.FilePermissions.WRITE);\n+      }\n+      return;\n+    }\n \n-                ioManager.move(fileSource.toUri(), folderDestiny.resolve(fileName).toUri(), StandardCopyOption.REPLACE_EXISTING);\n-            } catch (CatalogIOException e) {\n-                throw new CatalogException(\"Unexpected error. Could not move file from '\" + fileSource + \"' to '\" + folderDestiny + \"'\", e);\n-            }\n+    String parentPath = getParentPath(stringPath);\n+    long parentFileId = fileDBAdaptor.getId(study.getUid(), parentPath);\n+    // We obtain the permissions set in the parent folder and set them to the file or folder being created\n+    OpenCGAResult<Map<String, List<String>>> allFileAcls = authorizationManager.getAllFileAcls(study.getUid(), parentFileId, userId,\n+        checkPermissions);\n \n-            OpenCGAResult<File> result;\n-            if (external) {\n-                result = link(study.getFqn(), folderDestiny.resolve(fileName).toUri(), path, new ObjectMap(\"parents\", true), token);\n-            } else {\n-                result = createFile(study.getFqn(), filePath, \"\", true, null, token);\n-            }\n+    URI completeURI = Paths.get(studyURI).resolve(path).toUri();\n \n-            auditManager.audit(userId, Enums.Action.MOVE_AND_REGISTER, Enums.Resource.FILE, result.first().getId(),\n-                    result.first().getUuid(), study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            return result;\n-        } catch (CatalogException e) {\n-            auditManager.audit(userId, Enums.Action.MOVE_AND_REGISTER, Enums.Resource.FILE, \"\", \"\", study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n+    // Create the folder in catalog\n+    File folder = new File(path.getFileName().toString(), File.Type.DIRECTORY, File.Format.PLAIN, File.Bioformat.NONE, completeURI,\n+        stringPath, null, TimeUtils.getTime(), TimeUtils.getTime(), \"\", false, 0, null, new FileExperiment(),\n+        Collections.emptyList(), Collections.emptyList(), \"\", studyManager.getCurrentRelease(study), Collections.emptyList(), null,\n+        new CustomStatus(), FileInternal.initialize(), null);\n+    folder.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n+    checkHooks(folder, study.getFqn(), HookConfiguration.Stage.CREATE);\n+    fileDBAdaptor.insert(study.getUid(), folder, Collections.emptyList(), Collections.emptyList(), Collections.emptyList(),\n+        new QueryOptions());\n+    OpenCGAResult<File> queryResult = getFile(study.getUid(), folder.getUuid(), QueryOptions.empty());\n+    // Propagate ACLs\n+    if (allFileAcls != null && allFileAcls.getNumResults() > 0) {\n+      authorizationManager.replicateAcls(study.getUid(), Arrays.asList(queryResult.first().getUid()), allFileAcls.getResults().get(0),\n+          Enums.Resource.FILE);\n     }\n+  }\n \n-    @Deprecated\n-    public OpenCGAResult<File> get(Long fileId, QueryOptions options, String sessionId) throws CatalogException {\n-        return get(null, String.valueOf(fileId), options, sessionId);\n+  private OpenCGAResult<File> privateLink(Study study, FileLinkParams params, boolean parents, String token)\n+      throws CatalogException {\n+    ParamUtils.checkObj(params, \"FileLinkParams\");\n+    ParamUtils.checkParameter(params.getUri(), \"uri\");\n+    URI uriOrigin;\n+    try {\n+      uriOrigin = UriUtils.createUri(params.getUri());\n+    } catch (URISyntaxException e) {\n+      throw new CatalogException(e.getMessage(), e);\n     }\n \n-    public OpenCGAResult<FileTree> getTree(@Nullable String studyId, String fileId, int maxDepth, QueryOptions options, String token)\n-            throws CatalogException {\n-        long startTime = System.currentTimeMillis();\n+    IOManager ioManager;\n+    try {\n+      ioManager = ioManagerFactory.get(uriOrigin);\n+    } catch (IOException e) {\n+      throw CatalogIOException.ioManagerException(uriOrigin, e);\n+    }\n+    if (!ioManager.exists(uriOrigin)) {\n+      throw new CatalogIOException(\"File \" + uriOrigin + \" does not exist\");\n+    }\n \n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n+    final URI normalizedUri;\n+    try {\n+      normalizedUri = UriUtils.createUri(uriOrigin.normalize().getPath());\n+    } catch (URISyntaxException e) {\n+      throw new CatalogException(e);\n+    }\n \n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, userId);\n+    String userId = userManager.getUserId(token);\n+    authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_FILES);\n \n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"fileId\", fileId)\n-                .append(\"options\", options)\n-                .append(\"maxDepth\", maxDepth)\n-                .append(\"token\", token);\n-        try {\n-            if (maxDepth < 1) {\n-                throw new CatalogException(\"Depth cannot be lower than 1\");\n-            }\n-            if (options.containsKey(QueryOptions.INCLUDE)) {\n-                // Add type and path to the queryOptions\n-                List<String> asStringListOld = options.getAsStringList(QueryOptions.INCLUDE);\n-                Set<String> newList = new HashSet<>(asStringListOld);\n-                newList.add(FileDBAdaptor.QueryParams.TYPE.key());\n-                newList.add(FileDBAdaptor.QueryParams.PATH.key());\n-                options.put(QueryOptions.INCLUDE, new ArrayList<>(newList));\n-            } else {\n-                if (options.containsKey(QueryOptions.EXCLUDE)) {\n-                    // Avoid excluding type and path from queryoptions\n-                    List<String> asStringListOld = options.getAsStringList(QueryOptions.EXCLUDE);\n-                    Set<String> newList = new HashSet<>(asStringListOld);\n-                    newList.remove(FileDBAdaptor.QueryParams.TYPE.key());\n-                    newList.remove(FileDBAdaptor.QueryParams.PATH.key());\n-                    if (newList.size() > 0) {\n-                        options.put(QueryOptions.EXCLUDE, new ArrayList<>(newList));\n-                    } else {\n-                        options.remove(QueryOptions.EXCLUDE);\n-                    }\n-                }\n-            }\n+    params.setPath(ParamUtils.defaultString(params.getPath(), \"\"));\n+    if (params.getPath().length() == 1 && (params.getPath().equals(\".\") || params.getPath().equals(\"/\"))) {\n+      params.setPath(\"\");\n+    } else {\n+      if (params.getPath().startsWith(\"/\")) {\n+        params.setPath(params.getPath().substring(1));\n+      }\n+      if (!params.getPath().isEmpty() && !params.getPath().endsWith(\"/\")) {\n+        params.setPath(params.getPath() + \"/\");\n+      }\n+    }\n+    String externalPathDestinyStr;\n+    if (Paths.get(normalizedUri).toFile().isDirectory()) {\n+      externalPathDestinyStr = Paths.get(params.getPath()).resolve(Paths.get(normalizedUri).getFileName()).toString() + \"/\";\n+    } else {\n+      externalPathDestinyStr = Paths.get(params.getPath()).resolve(Paths.get(normalizedUri).getFileName()).toString();\n+    }\n \n-            File file = internalGet(study.getUid(), fileId, options, userId).first();\n+    // Check if the path already exists and is not external\n+    Query query = new Query()\n+        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+        .append(FileDBAdaptor.QueryParams.PATH.key(), externalPathDestinyStr)\n+        .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), false);\n+    if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n+      throw new CatalogException(\"Cannot link to \" + externalPathDestinyStr + \". The path already existed and is not external.\");\n+    }\n+\n+    // Check if the uri was already linked to that same path\n+    query = new Query()\n+        .append(FileDBAdaptor.QueryParams.URI.key(), normalizedUri)\n+        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+        .append(FileDBAdaptor.QueryParams.PATH.key(), externalPathDestinyStr)\n+        .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), true);\n+\n+\n+    if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n+      // Create a regular expression on URI to return everything linked from that URI\n+      query.put(FileDBAdaptor.QueryParams.URI.key(), \"~^\" + normalizedUri);\n+      query.remove(FileDBAdaptor.QueryParams.PATH.key());\n+\n+      // Limit the number of results and only some fields\n+      QueryOptions queryOptions = new QueryOptions()\n+          .append(QueryOptions.LIMIT, 100);\n+\n+      return fileDBAdaptor.get(query, queryOptions)\n+          .addEvent(new Event(Event.Type.INFO, ParamConstants.FILE_ALREADY_LINKED));\n+    }\n+\n+    // Check if the uri was linked to other path\n+    query = new Query()\n+        .append(FileDBAdaptor.QueryParams.URI.key(), normalizedUri)\n+        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+        .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), true);\n+    if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n+      QueryOptions queryOptions = new QueryOptions(QueryOptions.INCLUDE, FileDBAdaptor.QueryParams.PATH.key());\n+      String path = fileDBAdaptor.get(query, queryOptions).first().getPath();\n+      throw new CatalogException(normalizedUri + \" was already linked to other path: \" + path);\n+    }\n \n-            // Check if the id does not correspond to a directory\n-            if (!file.getType().equals(File.Type.DIRECTORY)) {\n-                throw new CatalogException(\"The file introduced is not a directory.\");\n-            }\n+//         FIXME: Implement resync\n+//        boolean resync = params.getBoolean(\"resync\", false);\n+//        String checksum = params.getString(FileDBAdaptor.QueryParams.CHECKSUM.key(), \"\");\n \n-            // Build regex to obtain all the files/directories up to certain depth\n-            String baseRegex = \"([^\\\\/]+)\";\n-            StringBuilder pathRegex = new StringBuilder(baseRegex);\n-            for (int i = 1; i < maxDepth; i++) {\n-                pathRegex.append(\"[\\\\/]?\").append(baseRegex).append(\"?\");\n-            }\n-            // It can end in a directory or not\n-            pathRegex.append(\"[\\\\/]?$\");\n-            Query query = new Query(FileDBAdaptor.QueryParams.PATH.key(), \"~^\" + file.getPath() + pathRegex.toString());\n-            // We want to know beforehand the number of matches we will get to be able to abort before iterating\n-            options.put(QueryOptions.COUNT, true);\n-\n-            FileTreeBuilder treeBuilder = new FileTreeBuilder(file);\n-            int numResults;\n-            try (DBIterator<File> iterator = fileDBAdaptor.iterator(study.getUid(), query, options, userId)) {\n-                if (iterator.getNumMatches() > MAX_LIMIT) {\n-                    throw new CatalogException(\"Please, decrease the maximum depth. More than \" + MAX_LIMIT + \" files found\");\n-                }\n-                numResults = (int) iterator.getNumMatches() + 1;\n-                while (iterator.hasNext()) {\n-                    treeBuilder.add(iterator.next());\n-                }\n-            }\n-            FileTree fileTree = treeBuilder.toFileTree();\n-            int dbTime = (int) (System.currentTimeMillis() - startTime);\n+    final List<FileRelatedFile> relatedFiles = params.getRelatedFiles();\n+    if (relatedFiles != null) {\n+      for (FileRelatedFile relatedFile : relatedFiles) {\n+        File tmpFile = internalGet(study.getUid(), relatedFile.getFile().getId(), INCLUDE_FILE_URI_PATH, userId).first();\n+        relatedFile.setFile(tmpFile);\n+      }\n+    }\n+\n+    // Because pathDestiny can be null, we will use catalogPath as the virtual destiny where the files will be located in catalog.\n+    Path catalogPath = Paths.get(params.getPath());\n+\n+    if (params.getPath().isEmpty()) {\n+      // If no destiny is given, everything will be linked to the root folder of the study.\n+      authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_FILES);\n+    } else {\n+      // Check if the folder exists\n+      query = new Query()\n+          .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+          .append(FileDBAdaptor.QueryParams.PATH.key(), params.getPath());\n+      if (fileDBAdaptor.count(query).getNumMatches() == 0) {\n+        if (parents) {\n+          // Get the base URI where the files are located in the study\n+          URI studyURI = study.getUri();\n+          createParents(study, userId, studyURI, catalogPath, true);\n+          // Create them in the disk\n+//                    URI directory = Paths.get(studyURI).resolve(catalogPath).toUri();\n+//                    catalogIOManagerFactory.get(directory).createDirectory(directory, true);\n+        } else {\n+          throw new CatalogException(\"The path \" + catalogPath + \" does not exist in catalog.\");\n+        }\n+      } else {\n+        // Check if the user has permissions to link files in the directory\n+        long fileId = fileDBAdaptor.getId(study.getUid(), params.getPath());\n+        authorizationManager.checkFilePermission(study.getUid(), fileId, userId, FileAclEntry.FilePermissions.WRITE);\n+      }\n+    }\n \n-            auditManager.audit(userId, Enums.Action.TREE, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+    // This list will contain the list of transformed files detected during the link\n+    List<File> transformedFiles = new ArrayList<>();\n \n-            return new OpenCGAResult<>(dbTime, Collections.emptyList(), numResults, Collections.singletonList(fileTree), numResults);\n-        } catch (CatalogException e) {\n-            auditManager.audit(userId, Enums.Action.TREE, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n+    // We remove the / at the end for replacement purposes in the walkFileTree\n+    if (externalPathDestinyStr.endsWith(\"/\")) {\n+      externalPathDestinyStr = externalPathDestinyStr.substring(0, externalPathDestinyStr.length() - 1);\n     }\n+    String finalExternalPathDestinyStr = externalPathDestinyStr;\n \n-    public OpenCGAResult<File> getFilesFromFolder(String folderStr, String studyStr, QueryOptions options, String sessionId)\n-            throws CatalogException {\n-        ParamUtils.checkObj(folderStr, \"folder\");\n-        String userId = userManager.getUserId(sessionId);\n-        Study study = studyManager.resolveId(studyStr, userId);\n+    // Link all the files and folders present in the uri\n+    ioManager.walkFileTree(normalizedUri, new SimpleFileVisitor<URI>() {\n+      @Override\n+      public FileVisitResult preVisitDirectory(URI dir, BasicFileAttributes attrs) throws IOException {\n+        try {\n+          String destinyPath = Paths.get(dir).toString().replace(Paths.get(normalizedUri).toString(),\n+              finalExternalPathDestinyStr);\n \n-        File file = internalGet(study.getUid(), folderStr, new QueryOptions(QueryOptions.INCLUDE,\n-                Arrays.asList(FileDBAdaptor.QueryParams.PATH.key(), FileDBAdaptor.QueryParams.TYPE.key())), userId).first();\n+          if (!destinyPath.isEmpty() && !destinyPath.endsWith(\"/\")) {\n+            destinyPath += \"/\";\n+          }\n \n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n+          if (destinyPath.startsWith(\"/\")) {\n+            destinyPath = destinyPath.substring(1);\n+          }\n \n-        if (!file.getType().equals(File.Type.DIRECTORY)) {\n-            throw new CatalogDBException(\"File {path:'\" + file.getPath() + \"'} is not a folder.\");\n-        }\n-        Query query = new Query(FileDBAdaptor.QueryParams.DIRECTORY.key(), file.getPath());\n-        return search(studyStr, query, options, sessionId);\n-    }\n-\n-    @Override\n-    public DBIterator<File> iterator(String studyStr, Query query, QueryOptions options, String sessionId) throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-        String userId = userManager.getUserId(sessionId);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        Query finalQuery = new Query(query);\n-        // Fix query if it contains any annotation\n-        AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n-        AnnotationUtils.fixQueryOptionAnnotation(options);\n-        fixQueryObject(study, finalQuery, userId);\n-        finalQuery.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-\n-        return fileDBAdaptor.iterator(study.getUid(), query, options, userId);\n-    }\n-\n-    @Override\n-    public OpenCGAResult<File> search(String studyId, Query query, QueryOptions options, String token) throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n-        Query finalQuery = new Query(query);\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"query\", new Query(query))\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-        try {\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n-            AnnotationUtils.fixQueryOptionAnnotation(options);\n-            fixQueryObject(study, finalQuery, userId);\n-            finalQuery.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n+          Query query = new Query()\n+              .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+              .append(FileDBAdaptor.QueryParams.PATH.key(), destinyPath);\n+\n+          if (fileDBAdaptor.count(query).getNumMatches() == 0) {\n+            // If the folder does not exist, we create it\n+\n+            String parentPath = getParentPath(destinyPath);\n+            long parentFileId = fileDBAdaptor.getId(study.getUid(), parentPath);\n+            // We obtain the permissions set in the parent folder and set them to the file or folder being created\n+            OpenCGAResult<Map<String, List<String>>> allFileAcls;\n+            try {\n+              allFileAcls = authorizationManager.getAllFileAcls(study.getUid(), parentFileId, userId, true);\n+            } catch (CatalogException e) {\n+              throw new RuntimeException(e);\n+            }\n \n-            OpenCGAResult<File> queryResult = fileDBAdaptor.get(study.getUid(), finalQuery, options, userId);\n-            auditManager.auditSearch(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+            File folder = new File(Paths.get(dir).getFileName().toString(), File.Type.DIRECTORY, File.Format.PLAIN,\n+                File.Bioformat.NONE, dir, destinyPath, null, TimeUtils.getTime(),\n+                TimeUtils.getTime(), params.getDescription(), true, 0, new Software(), new FileExperiment(),\n+                Collections.emptyList(), relatedFiles, \"\", studyManager.getCurrentRelease(study), Collections.emptyList(),\n+                Collections.emptyMap(),\n+                params.getStatus() != null ? params.getStatus().toCustomStatus() : new CustomStatus(),\n+                FileInternal.initialize(), Collections.emptyMap());\n+            folder.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n+            checkHooks(folder, study.getFqn(), HookConfiguration.Stage.CREATE);\n+            fileDBAdaptor.insert(study.getUid(), folder, Collections.emptyList(), Collections.emptyList(),\n+                Collections.emptyList(), new QueryOptions());\n+            OpenCGAResult<File> queryResult = getFile(study.getUid(), folder.getUuid(), QueryOptions.empty());\n+\n+            // Propagate ACLs\n+            if (allFileAcls != null && allFileAcls.getNumResults() > 0) {\n+              authorizationManager.replicateAcls(study.getUid(), Arrays.asList(queryResult.first().getUid()),\n+                  allFileAcls.getResults().get(0), Enums.Resource.FILE);\n+            }\n+          }\n \n-            return queryResult;\n         } catch (CatalogException e) {\n-            auditManager.auditSearch(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n+          logger.error(\"An error occurred when trying to create folder {}\", dir.toString());\n         }\n-    }\n-\n-    @Override\n-    public OpenCGAResult<?> distinct(String studyId, String field, Query query, String token) throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n \n-        String userId = userManager.getUserId(token);\n-        Study study = catalogManager.getStudyManager().resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n+        return FileVisitResult.CONTINUE;\n+      }\n \n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"field\", new Query(query))\n-                .append(\"query\", new Query(query))\n-                .append(\"token\", token);\n+      @Override\n+      public FileVisitResult visitFile(URI fileUri, BasicFileAttributes attrs) throws IOException {\n         try {\n-            FileDBAdaptor.QueryParams param = FileDBAdaptor.QueryParams.getParam(field);\n-            if (param == null) {\n-                throw new CatalogException(\"Unknown '\" + field + \"' parameter.\");\n+          String destinyPath = Paths.get(fileUri).toString().replace(Paths.get(normalizedUri).toString(),\n+              finalExternalPathDestinyStr);\n+\n+          if (destinyPath.startsWith(\"/\")) {\n+            destinyPath = destinyPath.substring(1);\n+          }\n+\n+          Query query = new Query()\n+              .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+              .append(FileDBAdaptor.QueryParams.PATH.key(), destinyPath);\n+\n+          if (fileDBAdaptor.count(query).getNumMatches() == 0) {\n+            long size = ioManager.getFileSize(fileUri);\n+            // If the file does not exist, we create it\n+            String parentPath = getParentPath(destinyPath);\n+            long parentFileId = fileDBAdaptor.getId(study.getUid(), parentPath);\n+            // We obtain the permissions set in the parent folder and set them to the file or folder being created\n+            OpenCGAResult<Map<String, List<String>>> allFileAcls;\n+            try {\n+              allFileAcls = authorizationManager.getAllFileAcls(study.getUid(), parentFileId, userId, true);\n+            } catch (CatalogException e) {\n+              throw new RuntimeException(e);\n             }\n-            Class<?> clazz = getTypeClass(param.type());\n \n-            fixQueryObject(study, query, userId);\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, query);\n+            FileInternal internal = FileInternal.initialize();\n+            if (params.getInternal() != null) {\n+              internal.setSampleMap(params.getInternal().getSampleMap());\n+            }\n \n-            query.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-            OpenCGAResult<?> result = fileDBAdaptor.distinct(study.getUid(), field, query, userId, clazz);\n+            File subfile = new File(Paths.get(fileUri).getFileName().toString(), File.Type.FILE, File.Format.UNKNOWN,\n+                File.Bioformat.NONE, fileUri, destinyPath, null, TimeUtils.getTime(),\n+                TimeUtils.getTime(), params.getDescription(), true, size, new Software(), new FileExperiment(),\n+                Collections.emptyList(), relatedFiles, \"\", studyManager.getCurrentRelease(study), Collections.emptyList(),\n+                Collections.emptyMap(),\n+                params.getStatus() != null ? params.getStatus().toCustomStatus() : new CustomStatus(), internal,\n+                new HashMap<>());\n+            subfile.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n+            checkHooks(subfile, study.getFqn(), HookConfiguration.Stage.CREATE);\n \n-            auditManager.auditDistinct(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n+            // Improve metadata information and extract samples if any\n+            new FileMetadataReader(catalogManager).addMetadataInformation(study.getFqn(), subfile);\n \n-            return result;\n-        } catch (CatalogException e) {\n-            auditManager.auditDistinct(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n+            List<Sample> existingSamples = new LinkedList<>();\n+            List<Sample> nonExistingSamples = new LinkedList<>();\n+            validateNewSamples(study, subfile, existingSamples, nonExistingSamples, token);\n \n-    void fixQueryObject(Study study, Query query, String user) throws CatalogException {\n-        super.fixQueryObject(query);\n+            fileDBAdaptor.insert(study.getUid(), subfile, existingSamples, nonExistingSamples, Collections.emptyList(),\n+                new QueryOptions());\n+            subfile = getFile(study.getUid(), subfile.getUuid(), QueryOptions.empty()).first();\n \n-        if (StringUtils.isNotEmpty(query.getString(FileDBAdaptor.QueryParams.ID.key()))) {\n-            OpenCGAResult<File> queryResult = internalGet(study.getUid(), query.getAsStringList(FileDBAdaptor.QueryParams.ID.key()),\n-                    INCLUDE_FILE_IDS, user, true);\n-            query.remove(FileDBAdaptor.QueryParams.ID.key());\n-            query.put(FileDBAdaptor.QueryParams.UID.key(), queryResult.getResults().stream().map(File::getUid)\n-                    .collect(Collectors.toList()));\n-        }\n+            // Propagate ACLs\n+            if (allFileAcls != null && allFileAcls.getNumResults() > 0) {\n+              authorizationManager.replicateAcls(study.getUid(), Arrays.asList(subfile.getUid()),\n+                  allFileAcls.getResults().get(0), Enums.Resource.FILE);\n+            }\n \n-        validateQueryPath(query, FileDBAdaptor.QueryParams.PATH.key());\n-        validateQueryPath(query, FileDBAdaptor.QueryParams.DIRECTORY.key());\n+            if (isTransformedFile(subfile.getName())) {\n+              logger.info(\"Detected transformed file {}\", subfile.getPath());\n+              transformedFiles.add(subfile);\n+            }\n+          } else {\n+            throw new CatalogException(\"Cannot link the file \" + Paths.get(fileUri).getFileName().toString()\n+                + \". There is already a file in the path \" + destinyPath + \" with the same name.\");\n+          }\n \n-        // Convert jobId=NONE to jobId=\"\"\n-        if (StringUtils.isNotEmpty(query.getString(FileDBAdaptor.QueryParams.JOB_ID.key()))\n-                && \"NONE\".equalsIgnoreCase(query.getString(FileDBAdaptor.QueryParams.JOB_ID.key()))) {\n-            query.put(FileDBAdaptor.QueryParams.JOB_ID.key(), \"\");\n-        }\n-\n-//        // The samples introduced could be either ids or names. As so, we should use the smart resolutor to do this.\n-//        if (StringUtils.isNotEmpty(query.getString(FileDBAdaptor.QueryParams.SAMPLES.key()))) {\n-//            OpenCGAResult<Sample> sampleDataResult = catalogManager.getSampleManager().internalGet(study.getUid(),\n-//                    query.getAsStringList(FileDBAdaptor.QueryParams.SAMPLES.key()), SampleManager.INCLUDE_SAMPLE_IDS, user, true);\n-//            query.put(FileDBAdaptor.QueryParams.SAMPLE_UIDS.key(), sampleDataResult.getResults().stream().map(Sample::getUid)\n-//                    .collect(Collectors.toList()));\n-//            query.remove(FileDBAdaptor.QueryParams.SAMPLES.key());\n-//        }\n-    }\n-\n-    private void validateQueryPath(Query query, String key) {\n-        if (StringUtils.isNotEmpty(query.getString(key))) {\n-            // Path never starts with /\n-            List<String> pathList = query.getAsStringList(key);\n-            List<String> finalPathList = new ArrayList<>(pathList.size());\n-\n-            for (String path : pathList) {\n-                String auxPath = path;\n-                if (auxPath.startsWith(\"/\")) {\n-                    auxPath = auxPath.substring(1);\n-                }\n-                if (FileDBAdaptor.QueryParams.DIRECTORY.key().equals(key) && !auxPath.endsWith(\"/\")) {\n-                    auxPath = auxPath + \"/\";\n-                }\n-                finalPathList.add(auxPath);\n-            }\n-\n-            query.put(key, StringUtils.join(finalPathList, \",\"));\n-        }\n-    }\n-\n-    @Override\n-    public OpenCGAResult<File> count(String studyId, Query query, String token) throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n-\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"query\", new Query(query))\n-                .append(\"token\", token);\n-        try {\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, query);\n-            // The samples introduced could be either ids or names. As so, we should use the smart resolutor to do this.\n-            fixQueryObject(study, query, userId);\n-\n-            query.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-            OpenCGAResult<Long> queryResultAux = fileDBAdaptor.count(query, userId);\n-\n-            auditManager.auditCount(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-\n-            return new OpenCGAResult<>(queryResultAux.getTime(), queryResultAux.getEvents(), 0, Collections.emptyList(),\n-                    queryResultAux.getNumMatches());\n-        } catch (CatalogException e) {\n-            auditManager.auditCount(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n-\n-    @Override\n-    public OpenCGAResult delete(String studyStr, List<String> fileIds, ObjectMap params, String token) throws CatalogException {\n-        return delete(studyStr, fileIds, params, false, token);\n-    }\n-\n-    public OpenCGAResult delete(String studyStr, List<String> fileIds, ObjectMap params, boolean ignoreException, String token)\n-            throws CatalogException {\n-        String userId = catalogManager.getUserManager().getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n-\n-        String operationUuid = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"fileIds\", fileIds)\n-                .append(\"params\", params)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"token\", token);\n-\n-        // We need to avoid processing subfolders or subfiles of an already processed folder independently\n-        Set<String> processedPaths = new HashSet<>();\n-        boolean physicalDelete = params.getBoolean(Constants.SKIP_TRASH, false);\n-\n-        auditManager.initAuditBatch(operationUuid);\n-        OpenCGAResult<File> result = OpenCGAResult.empty();\n-        for (String id : fileIds) {\n-            String fileId = id;\n-            String fileUuid = \"\";\n-\n-            try {\n-                OpenCGAResult<File> internalResult = internalGet(study.getUid(), id, INCLUDE_FILE_URI_PATH, userId);\n-                if (internalResult.getNumResults() == 0) {\n-                    throw new CatalogException(\"File '\" + id + \"' not found\");\n-                }\n-                File file = internalResult.first();\n-                // We set the proper values for the audit\n-                fileId = file.getId();\n-                fileUuid = file.getUuid();\n-\n-                if (subpathInPath(file.getPath(), processedPaths)) {\n-                    // We skip this folder because it is a subfolder or subfile within an already processed folder\n-                    continue;\n-                }\n-\n-                OpenCGAResult updateResult = delete(study, file, physicalDelete, userId);\n-                result.append(updateResult);\n-\n-                // We store the processed path as is\n-                if (file.getType() == File.Type.DIRECTORY) {\n-                    processedPaths.add(file.getPath());\n-                }\n-\n-                auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            } catch (CatalogException e) {\n-                Event event = new Event(Event.Type.ERROR, fileId, e.getMessage());\n-                result.getEvents().add(event);\n-\n-                logger.error(\"Could not delete file {}: {}\", fileId, e.getMessage(), e);\n-                auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, fileId, fileUuid, study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            }\n-        }\n-        auditManager.finishAuditBatch(operationUuid);\n-\n-        return endResult(result, ignoreException);\n-    }\n-\n-    @Override\n-    public OpenCGAResult delete(String studyStr, Query query, ObjectMap params, String token) throws CatalogException {\n-        return delete(studyStr, query, params, false, token);\n-    }\n-\n-    public OpenCGAResult delete(String studyStr, Query query, ObjectMap params, boolean ignoreException, String token)\n-            throws CatalogException {\n-        Query finalQuery = new Query(ParamUtils.defaultObject(query, Query::new));\n-        params = ParamUtils.defaultObject(params, ObjectMap::new);\n-\n-        OpenCGAResult dataResult = OpenCGAResult.empty();\n-\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                StudyDBAdaptor.QueryParams.VARIABLE_SET.key()));\n-\n-        StopWatch watch = StopWatch.createStarted();\n-        String operationUuid = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"query\", new Query(query))\n-                .append(\"params\", params)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"token\", token);\n-\n-        // We try to get an iterator containing all the files to be deleted\n-        DBIterator<File> fileIterator;\n-        try {\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n-            fixQueryObject(study, finalQuery, userId);\n-            finalQuery.append(SampleDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-\n-            fileIterator = fileDBAdaptor.iterator(study.getUid(), finalQuery, INCLUDE_FILE_URI_PATH, userId);\n         } catch (CatalogException e) {\n-            auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, \"\", \"\", study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            throw e;\n-        }\n-\n-        // We need to avoid processing subfolders or subfiles of an already processed folder independently\n-        Set<String> processedPaths = new HashSet<>();\n-        boolean physicalDelete = params.getBoolean(Constants.SKIP_TRASH, false);\n-\n-        long numMatches = 0;\n-\n-        auditManager.initAuditBatch(operationUuid);\n-        while (fileIterator.hasNext()) {\n-            File file = fileIterator.next();\n-\n-            if (subpathInPath(file.getPath(), processedPaths)) {\n-                // We skip this folder because it is a subfolder or subfile within an already processed folder\n-                continue;\n+          logger.error(e.getMessage());\n+        }\n+\n+        return FileVisitResult.CONTINUE;\n+      }\n+\n+      @Override\n+      public FileVisitResult visitFileFailed(URI file, IOException exc) throws IOException {\n+        return FileVisitResult.SKIP_SUBTREE;\n+      }\n+\n+      @Override\n+      public FileVisitResult postVisitDirectory(URI dir, IOException exc) throws IOException {\n+        return FileVisitResult.CONTINUE;\n+      }\n+    });\n+\n+    // Try to link transformed files with their corresponding original files if any\n+    try {\n+      if (transformedFiles.size() > 0) {\n+        matchUpVariantFiles(study.getFqn(), transformedFiles, token);\n+      }\n+    } catch (CatalogException e) {\n+      logger.warn(\"Matching avro to variant file: {}\", e.getMessage());\n+    }\n+\n+    // Check if the uri was already linked to that same path\n+    query = new Query()\n+        .append(FileDBAdaptor.QueryParams.URI.key(), \"~^\" + normalizedUri)\n+        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n+        .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), true);\n+\n+    // Limit the number of results and only some fields\n+    QueryOptions queryOptions = new QueryOptions()\n+        .append(QueryOptions.LIMIT, 100);\n+    return fileDBAdaptor.get(query, queryOptions);\n+  }\n+\n+  OpenCGAResult<File> registerFile(Study study, String filePath, URI fileUri, String jobId, String token) throws CatalogException {\n+    String userId = userManager.getUserId(token);\n+    IOManager ioManager;\n+    try {\n+      ioManager = ioManagerFactory.get(fileUri);\n+    } catch (IOException e) {\n+      throw CatalogIOException.ioManagerException(fileUri, e);\n+    }\n+\n+    // The file is not registered in Catalog, so we will register it\n+    long size = ioManager.getFileSize(fileUri);\n+\n+    String parentPath = getParentPath(filePath);\n+    File parentFile = internalGet(study.getUid(), parentPath, INCLUDE_FILE_URI_PATH, userId).first();\n+    // We obtain the permissions set in the parent folder and set them to the file or folder being created\n+    OpenCGAResult<Map<String, List<String>>> allFileAcls = authorizationManager.getAllFileAcls(study.getUid(),\n+        parentFile.getUid(), userId, true);\n+\n+    File subfile = new File(Paths.get(filePath).getFileName().toString(), File.Type.FILE, File.Format.UNKNOWN,\n+        File.Bioformat.NONE, fileUri, filePath, \"\", TimeUtils.getTime(), TimeUtils.getTime(),\n+        \"\", isExternal(study, filePath, fileUri), size, new Software(), new FileExperiment(), Collections.emptyList(),\n+        Collections.emptyList(), jobId, studyManager.getCurrentRelease(study), Collections.emptyList(), Collections.emptyMap(),\n+        new CustomStatus(), FileInternal.initialize(), Collections.emptyMap());\n+    subfile.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n+    checkHooks(subfile, study.getFqn(), HookConfiguration.Stage.CREATE);\n+\n+    // Improve metadata information and extract samples if any\n+    new FileMetadataReader(catalogManager).addMetadataInformation(study.getFqn(), subfile);\n+    List<Sample> existingSamples = new LinkedList<>();\n+    List<Sample> nonExistingSamples = new LinkedList<>();\n+    validateNewSamples(study, subfile, existingSamples, nonExistingSamples, token);\n+\n+    fileDBAdaptor.insert(study.getUid(), subfile, existingSamples, nonExistingSamples, Collections.emptyList(), new QueryOptions());\n+    OpenCGAResult<File> result = getFile(study.getUid(), subfile.getUuid(), QueryOptions.empty());\n+    subfile = result.first();\n+\n+    // Propagate ACLs\n+    if (allFileAcls != null && allFileAcls.getNumResults() > 0) {\n+      authorizationManager.replicateAcls(study.getUid(), Arrays.asList(subfile.getUid()), allFileAcls.getResults().get(0),\n+          Enums.Resource.FILE);\n+    }\n+\n+    // If it is a transformed file, we will try to link it with the correspondent original file\n+    try {\n+      if (isTransformedFile(subfile.getName())) {\n+        matchUpVariantFiles(study.getFqn(), Arrays.asList(subfile), token);\n+      }\n+    } catch (CatalogException e1) {\n+      logger.warn(\"Matching avro to variant file: {}\", e1.getMessage());\n+    }\n+\n+    return result;\n+  }\n+\n+  private void checkHooks(File file, String fqn, HookConfiguration.Stage stage) throws CatalogException {\n+\n+    Map<String, Map<String, List<HookConfiguration>>> hooks = this.configuration.getHooks();\n+    if (hooks != null && hooks.containsKey(fqn)) {\n+      Map<String, List<HookConfiguration>> entityHookMap = hooks.get(fqn);\n+      List<HookConfiguration> hookList = null;\n+      if (entityHookMap.containsKey(MongoDBAdaptorFactory.FILE_COLLECTION)) {\n+        hookList = entityHookMap.get(MongoDBAdaptorFactory.FILE_COLLECTION);\n+      } else if (entityHookMap.containsKey(MongoDBAdaptorFactory.FILE_COLLECTION.toUpperCase())) {\n+        hookList = entityHookMap.get(MongoDBAdaptorFactory.FILE_COLLECTION.toUpperCase());\n+      }\n+\n+      // We check the hook list\n+      if (hookList != null) {\n+        for (HookConfiguration hookConfiguration : hookList) {\n+          if (hookConfiguration.getStage() != stage) {\n+            continue;\n+          }\n+\n+          String field = hookConfiguration.getField();\n+          if (StringUtils.isEmpty(field)) {\n+            logger.warn(\"Missing 'field' field from hook configuration\");\n+            continue;\n+          }\n+          field = field.toLowerCase();\n+\n+          String filterValue = hookConfiguration.getValue();\n+          if (StringUtils.isEmpty(filterValue)) {\n+            logger.warn(\"Missing 'value' field from hook configuration\");\n+            continue;\n+          }\n+\n+          String value = null;\n+          switch (field) {\n+            case \"name\":\n+              value = file.getName();\n+              break;\n+            case \"format\":\n+              value = file.getFormat().name();\n+              break;\n+            case \"bioformat\":\n+              value = file.getFormat().name();\n+              break;\n+            case \"path\":\n+              value = file.getPath();\n+              break;\n+            case \"description\":\n+              value = file.getDescription();\n+              break;\n+            // TODO: At some point, we will also have to consider any field that is not a String\n+//                        case \"size\":\n+//                            value = file.getSize();\n+//                            break;\n+            default:\n+              break;\n+          }\n+          if (value == null) {\n+            continue;\n+          }\n+\n+          String filterNewValue = hookConfiguration.getWhat();\n+          if (StringUtils.isEmpty(filterNewValue)) {\n+            logger.warn(\"Missing 'what' field from hook configuration\");\n+            continue;\n+          }\n+\n+          String filterWhere = hookConfiguration.getWhere();\n+          if (StringUtils.isEmpty(filterWhere)) {\n+            logger.warn(\"Missing 'where' field from hook configuration\");\n+            continue;\n+          }\n+          filterWhere = filterWhere.toLowerCase();\n+\n+\n+          if (filterValue.startsWith(\"~\")) {\n+            // Regular expression\n+            if (!value.matches(filterValue.substring(1))) {\n+              // If it doesn't match, we will check the next hook of the loop\n+              continue;\n+            }\n+          } else {\n+            if (!value.equals(filterValue)) {\n+              // If it doesn't match, we will check the next hook of the loop\n+              continue;\n+            }\n+          }\n+\n+          // The value matched, so we will perform the action desired by the user\n+          if (hookConfiguration.getAction() == HookConfiguration.Action.ABORT) {\n+            throw new CatalogException(\"A hook to abort the insertion matched\");\n+          }\n+\n+          // We check the field the user wants to update\n+          if (filterWhere.equals(FileDBAdaptor.QueryParams.DESCRIPTION.key())) {\n+            switch (hookConfiguration.getAction()) {\n+              case ADD:\n+              case SET:\n+                file.setDescription(hookConfiguration.getWhat());\n+                break;\n+              case REMOVE:\n+                file.setDescription(\"\");\n+                break;\n+              default:\n+                break;\n             }\n-\n-            try {\n-                OpenCGAResult result = delete(study, file, physicalDelete, userId);\n-                dataResult.append(result);\n-\n-                // We store the processed path as is\n-                if (file.getType() == File.Type.DIRECTORY) {\n-                    processedPaths.add(file.getPath());\n-                }\n-\n-                auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            } catch (CatalogException e) {\n-                String errorMsg;\n-\n-                if (file.getType() == File.Type.FILE) {\n-                    errorMsg = \"Cannot delete file \" + file.getPath() + \": \" + e.getMessage();\n+          } else if (filterWhere.equals(FileDBAdaptor.QueryParams.TAGS.key())) {\n+            switch (hookConfiguration.getAction()) {\n+              case ADD:\n+                List<String> values;\n+                if (hookConfiguration.getWhat().contains(\",\")) {\n+                  values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n                 } else {\n-                    errorMsg = \"Cannot delete folder \" + file.getPath() + \": \" + e.getMessage();\n-                }\n-                dataResult.getEvents().add(new Event(Event.Type.ERROR, file.getPath(), e.getMessage()));\n-\n-                logger.error(errorMsg, e);\n-                auditManager.auditDelete(operationUuid, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            }\n-        }\n-        auditManager.finishAuditBatch(operationUuid);\n-\n-        dataResult.setTime((int) watch.getTime(TimeUnit.MILLISECONDS));\n-        dataResult.setNumMatches(dataResult.getNumMatches() + numMatches);\n-\n-        return endResult(dataResult, ignoreException);\n-    }\n-\n-    private OpenCGAResult delete(Study study, File file, boolean physicalDelete, String userId)\n-            throws CatalogException {\n-        // Check if the file or the folder plus any nested files/folders can be deleted\n-        checkCanDeleteFile(study, file.getPath(), false, Collections.singletonList(FileStatus.PENDING_DELETE), userId);\n-\n-        String currentStatus = file.getInternal().getStatus().getName();\n-        if (FileStatus.DELETED.equals(currentStatus)) {\n-            throw new CatalogException(\"The file was already deleted\");\n-        }\n-        if (FileStatus.DELETING.equals(currentStatus)) {\n-            throw new CatalogException(\"The file is already being deleted\");\n-        }\n-        if (!FileStatus.PENDING_DELETE.equals(currentStatus)) {\n-            throw new CatalogException(\"The status of file should be \" + FileStatus.PENDING_DELETE);\n-        }\n-\n-        if (physicalDelete) {\n-            return physicalDelete(study, file);\n-        } else {\n-            return sendToTrash(file);\n-        }\n-    }\n-\n-    /**\n-     * Given a registered folder in OpenCGA, it will scan its contents to register any nested file/folder that might not be registered.\n-     *\n-     * @param studyId  Study id.\n-     * @param folderId Folder id, path or uuid.\n-     * @param token    Token of the user. The user will need to have read and write access to the folderId.\n-     * @return An OpenCGAResult containing the number of files that have been added and the full list of files registered (old and new).\n-     * @throws CatalogException If there is any of the following errors:\n-     *                          Study not found, folderId does not exist or user does not have permissions.\n-     */\n-    public OpenCGAResult<File> syncUntrackedFiles(String studyId, String folderId, String token) throws CatalogException {\n-        return syncUntrackedFiles(studyId, folderId, uri -> true, \"\", token);\n-    }\n-\n-    public OpenCGAResult<File> syncUntrackedFiles(String studyId, String folderId, Predicate<URI> filter, String token)\n-            throws CatalogException {\n-        return syncUntrackedFiles(studyId, folderId, filter, \"\", token);\n-    }\n-\n-    public OpenCGAResult<File> syncUntrackedFiles(String studyId, String folderId, Predicate<URI> filter, String jobId, String token)\n-            throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, userId);\n-\n-        File folder = internalGet(study.getUid(), folderId, INCLUDE_FILE_URI_PATH, userId).first();\n-\n-        if (folder.getType() == File.Type.FILE) {\n-            throw new CatalogException(\"Provided folder '\" + folderId + \"' is actually a file\");\n-        }\n-\n-        authorizationManager.checkFilePermission(study.getUid(), folder.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n-\n-        IOManager ioManager;\n-        try {\n-            ioManager = ioManagerFactory.get(folder.getUri());\n-        } catch (IOException e) {\n-            throw CatalogIOException.ioManagerException(folder.getUri(), e);\n-        }\n-        Iterator<URI> iterator = ioManager.listFilesStream(folder.getUri()).iterator();\n-\n-        if (filter == null) {\n-            filter = uri -> true;\n-        }\n-\n-        long numMatches = 0;\n-\n-        OpenCGAResult<File> result = OpenCGAResult.empty();\n-        List<File> fileList = new ArrayList<>();\n-        List<Event> eventList = new ArrayList<>();\n-        while (iterator.hasNext()) {\n-            URI fileUri = iterator.next().normalize();\n-\n-            numMatches++;\n-\n-            if (!filter.test(fileUri)) {\n-                continue;\n-            }\n-\n-            String relativeFilePath = folder.getUri().relativize(fileUri).getPath();\n-            String finalCatalogPath = Paths.get(folder.getPath()).resolve(relativeFilePath).toString();\n-            if (relativeFilePath.endsWith(\"/\") && !finalCatalogPath.endsWith(\"/\")) {\n-                finalCatalogPath += \"/\";\n-            }\n-\n-            try {\n-                File registeredFile = internalGet(study.getUid(), finalCatalogPath, INCLUDE_FILE_URI_PATH, userId).first();\n-                if (!registeredFile.getUri().equals(fileUri)) {\n-                    eventList.add(new Event(Event.Type.WARNING, registeredFile.getPath(), \"The uri registered in Catalog '\"\n-                            + registeredFile.getUri().getPath() + \"' for the path does not match the uri that would have been synced '\"\n-                            + fileUri.getPath() + \"'\"));\n+                  values = Collections.singletonList(hookConfiguration.getWhat());\n                 }\n-                fileList.add(registeredFile);\n-            } catch (CatalogException e) {\n-                File file = registerFile(study, finalCatalogPath, fileUri, jobId, token).first();\n-\n-                result.setNumInserted(result.getNumInserted() + 1);\n-                fileList.add(file);\n-            }\n-        }\n-        result.setNumMatches(numMatches);\n-        result.setEvents(eventList);\n-        result.setResults(fileList);\n-        result.setNumResults(fileList.size());\n-\n-        return result;\n-    }\n-\n-    public OpenCGAResult<File> unlink(@Nullable String studyId, String fileId, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, userId);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyId)\n-                .append(\"file\", fileId)\n-                .append(\"token\", token);\n-\n-        try {\n-            ParamUtils.checkParameter(fileId, \"File\");\n-\n-            File file = internalGet(study.getUid(), fileId, QueryOptions.empty(), userId).first();\n-\n-            if (!file.isExternal()) {\n-                throw new CatalogException(\"Only previously linked files can be unlinked. Please, use delete instead.\");\n-            }\n-\n-            // Check if the file or the folder plus any nested files/folders can be deleted\n-            checkCanDeleteFile(study, file.getPath(), true, Collections.singletonList(FileStatus.PENDING_DELETE), userId);\n-\n-            OpenCGAResult result = unlink(file);\n-            auditManager.audit(userId, Enums.Action.UNLINK, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-\n-            return result;\n-        } catch (CatalogException e) {\n-            auditManager.audit(userId, Enums.Action.UNLINK, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n-\n-    /**\n-     * Delete the file from the file system and from OpenCGA.\n-     *\n-     * @param study Study object.\n-     * @param file File or folder.\n-     * @return a OpenCGAResult object.\n-     */\n-    private OpenCGAResult physicalDelete(Study study, File file) throws CatalogException {\n-        URI fileUri = getUri(file);\n-        IOManager ioManager = null;\n-        try {\n-            ioManager = ioManagerFactory.get(fileUri);\n-        } catch (IOException e) {\n-            throw CatalogIOException.ioManagerException(fileUri, e);\n-        }\n-\n-        OpenCGAResult result = OpenCGAResult.empty();\n-        if (file.getType() == File.Type.FILE) {\n-            // 1. Set the file status to deleting\n-            ObjectMap update = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_STATUS_NAME.key(), FileStatus.DELETING);\n-            fileDBAdaptor.update(file.getUid(), update, QueryOptions.empty());\n-\n-            // 2. Delete file from the file system\n-            logger.debug(\"Deleting file '{} ({})' with uri '{}' from the file system\", file.getPath(), file.getUid(), fileUri);\n-            if (ioManager.exists(fileUri)) {\n-                try {\n-                    ioManager.deleteFile(fileUri);\n-                } catch (CatalogIOException e) {\n-                    logger.error(\"Could not delete physically the file '{} ({})'. File deletion aborted.\", file.getPath(), file.getUid());\n-                    // FIXME: Do we restore the status to READY\n-                    throw new CatalogException(\"Error deleting file \" + file.getPath() + \" physically: \" + e.getMessage(), e.getCause());\n-                }\n-            } else {\n-                // FIXME: What do we do if the file does not exist in the file system\n-                logger.warn(\"Could not delete file '{}'. The file is not accessible or does not exist.\", fileUri);\n-            }\n-\n-            // 3. Delete file from the database\n-            result = fileDBAdaptor.delete(file, FileStatus.DELETED);\n-        } else {\n-            // 1. Set the folder and all nested files/folders to DELETING\n-            Query query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                    .append(FileDBAdaptor.QueryParams.PATH.key(), \"~^\" + file.getPath() + \"*\");\n-            ObjectMap update = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_STATUS_NAME.key(), FileStatus.DELETING);\n-            fileDBAdaptor.update(query, update, QueryOptions.empty());\n-\n-            // 2. Delete files to be deleted from the file system\n-            QueryOptions options = new QueryOptions(INCLUDE_FILE_URI_PATH)\n-                    .append(QueryOptions.SORT, FileDBAdaptor.QueryParams.PATH.key())\n-                    .append(QueryOptions.ORDER, QueryOptions.DESCENDING);\n-            DBIterator<File> iterator = fileDBAdaptor.iterator(query, options);\n-            while (iterator.hasNext()) {\n-                File tmpFile = iterator.next();\n-                if (ioManager.isDirectory(tmpFile.getUri())) {\n-                    // If the directory is not empty, it might be that there are other files/folders not registered in OpenCGA, so we only\n-                    // delete the directory if the directory is empty\n-                    if (ioManager.listFiles(tmpFile.getUri()).isEmpty()) {\n-                        ioManager.deleteDirectory(tmpFile.getUri());\n-                    }\n-                } else {\n-                    ioManager.deleteFile(tmpFile.getUri());\n+                List<String> tagsCopy = new ArrayList<>();\n+                if (file.getTags() != null) {\n+                  tagsCopy.addAll(file.getTags());\n                 }\n-            }\n-\n-            // 3. Delete the folder and all nested files/folders to DELETED\n-            result = fileDBAdaptor.delete(file, FileStatus.DELETED);\n-        }\n-\n-        return result;\n-    }\n-\n-    private OpenCGAResult sendToTrash(File file) throws CatalogException {\n-        return fileDBAdaptor.delete(file, FileStatus.TRASHED);\n-    }\n-\n-    private OpenCGAResult unlink(File file) throws CatalogException {\n-        return fileDBAdaptor.delete(file, FileStatus.REMOVED);\n-    }\n-\n-    private boolean subpathInPath(String subpath, Set<String> pathSet) {\n-        String[] split = StringUtils.split(subpath, \"/\");\n-        String auxPath = \"\";\n-        for (String s : split) {\n-            auxPath += s + \"/\";\n-            if (pathSet.contains(auxPath)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public OpenCGAResult<File> updateAnnotations(String studyStr, String fileStr, String annotationSetId,\n-                                                 Map<String, Object> annotations, ParamUtils.CompleteUpdateAction action,\n-                                                 QueryOptions options, String token) throws CatalogException {\n-        if (annotations == null || annotations.isEmpty()) {\n-            throw new CatalogException(\"Missing array of annotations.\");\n-        }\n-        FileUpdateParams updateParams = new FileUpdateParams()\n-                .setAnnotationSets(Collections.singletonList(new AnnotationSet(annotationSetId, \"\", annotations)));\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-        options.put(Constants.ACTIONS, new ObjectMap(AnnotationSetManager.ANNOTATIONS, action));\n-\n-        return update(studyStr, fileStr, updateParams, options, token);\n-    }\n-\n-    public OpenCGAResult<File> removeAnnotations(String studyStr, String fileStr, String annotationSetId,\n-                                                 List<String> annotations, QueryOptions options, String token) throws CatalogException {\n-        return updateAnnotations(studyStr, fileStr, annotationSetId, new ObjectMap(\"remove\", StringUtils.join(annotations, \",\")),\n-                ParamUtils.CompleteUpdateAction.REMOVE, options, token);\n-    }\n-\n-    public OpenCGAResult<File> resetAnnotations(String studyStr, String fileStr, String annotationSetId, List<String> annotations,\n-                                                QueryOptions options, String token) throws CatalogException {\n-        return updateAnnotations(studyStr, fileStr, annotationSetId, new ObjectMap(\"reset\", StringUtils.join(annotations, \",\")),\n-                ParamUtils.CompleteUpdateAction.RESET, options, token);\n-    }\n-\n-    public OpenCGAResult<File> update(String studyStr, Query query, FileUpdateParams updateParams, QueryOptions options, String token)\n-            throws CatalogException {\n-        return update(studyStr, query, updateParams, false, options, token);\n-    }\n-\n-    public OpenCGAResult<File> update(String studyStr, Query query, FileUpdateParams updateParams, boolean ignoreException,\n-                                      QueryOptions options, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n-\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap updateMap;\n-        try {\n-            updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n-        } catch (JsonProcessingException e) {\n-            throw new CatalogException(\"Could not parse FileUpdateParams object: \" + e.getMessage(), e);\n-        }\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"query\", query)\n-                .append(\"updateParams\", updateMap)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-\n-        Query finalQuery = new Query(ParamUtils.defaultObject(query, Query::new));\n-\n-        DBIterator<File> iterator;\n-        try {\n-            // Fix query if it contains any annotation\n-            AnnotationUtils.fixQueryAnnotationSearch(study, finalQuery);\n-            fixQueryObject(study, finalQuery, userId);\n-            finalQuery.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-\n-            iterator = fileDBAdaptor.iterator(study.getUid(), finalQuery, EXCLUDE_FILE_ATTRIBUTES, userId);\n-        } catch (CatalogException e) {\n-            auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, \"\", \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-\n-        auditManager.initAuditBatch(operationId);\n-        OpenCGAResult<File> result = OpenCGAResult.empty();\n-        while (iterator.hasNext()) {\n-            File file = iterator.next();\n-            try {\n-                OpenCGAResult<File> updateResult = update(study, file, updateParams, options, userId, token);\n-                result.append(updateResult);\n-\n-                auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            } catch (CatalogException e) {\n-                Event event = new Event(Event.Type.ERROR, file.getId(), e.getMessage());\n-                result.getEvents().add(event);\n-\n-                logger.error(\"Cannot update file {}: {}\", file.getId(), e.getMessage());\n-                auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            }\n-        }\n-        auditManager.finishAuditBatch(operationId);\n-        return endResult(result, ignoreException);\n-    }\n-\n-    public OpenCGAResult<File> update(String studyStr, String fileId, FileUpdateParams updateParams, QueryOptions options, String token)\n-            throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n-\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap updateMap;\n-        try {\n-            updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n-        } catch (JsonProcessingException e) {\n-            throw new CatalogException(\"Could not parse FileUpdateParams object: \" + e.getMessage(), e);\n-        }\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"fileId\", fileId)\n-                .append(\"updateParams\", updateMap)\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-\n-        OpenCGAResult<File> result = OpenCGAResult.empty();\n-        String fileUuid = \"\";\n-        try {\n-            OpenCGAResult<File> internalResult = internalGet(study.getUid(), fileId, EXCLUDE_FILE_ATTRIBUTES, userId);\n-            if (internalResult.getNumResults() == 0) {\n-                throw new CatalogException(\"File '\" + fileId + \"' not found\");\n-            }\n-            File file = internalResult.first();\n-\n-            // We set the proper values for the audit\n-            fileId = file.getId();\n-            fileUuid = file.getUuid();\n-\n-            OpenCGAResult<File> updateResult = update(study, file, updateParams, options, userId, token);\n-            result.append(updateResult);\n-\n-            auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-        } catch (CatalogException e) {\n-            Event event = new Event(Event.Type.ERROR, fileId, e.getMessage());\n-            result.getEvents().add(event);\n-\n-            logger.error(\"Cannot update file {}: {}\", fileId, e.getMessage());\n-            auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, fileId, fileUuid, study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * Update a File from catalog.\n-     *\n-     * @param studyStr   Study id in string format. Could be one of [id|user@aliasProject:aliasStudy|aliasProject:aliasStudy|aliasStudy].\n-     * @param fileIds   List of file ids. Could be either the id, path or uuid.\n-     * @param updateParams Data model filled only with the parameters to be updated.\n-     * @param options      QueryOptions object.\n-     * @param token  Session id of the user logged in.\n-     * @return A OpenCGAResult.\n-     * @throws CatalogException if there is any internal error, the user does not have proper permissions or a parameter passed does not\n-     *                          exist or is not allowed to be updated.\n-     */\n-    public OpenCGAResult<File> update(String studyStr, List<String> fileIds, FileUpdateParams updateParams, QueryOptions options,\n-                                      String token) throws CatalogException {\n-        return update(studyStr, fileIds, updateParams, false, options, token);\n-    }\n-\n-    public OpenCGAResult<File> update(String studyStr, List<String> fileIds, FileUpdateParams updateParams, boolean ignoreException,\n-                                      QueryOptions options, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n-\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        ObjectMap updateMap;\n-        try {\n-            updateMap = updateParams != null ? updateParams.getUpdateMap() : null;\n-        } catch (JsonProcessingException e) {\n-            throw new CatalogException(\"Could not parse FileUpdateParams object: \" + e.getMessage(), e);\n-        }\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"fileIds\", fileIds)\n-                .append(\"updateParams\", updateMap)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-\n-        auditManager.initAuditBatch(operationId);\n-        OpenCGAResult<File> result = OpenCGAResult.empty();\n-        for (String id : fileIds) {\n-            String fileId = id;\n-            String fileUuid = \"\";\n-\n-            try {\n-                OpenCGAResult<File> internalResult = internalGet(study.getUid(), fileId, EXCLUDE_FILE_ATTRIBUTES, userId);\n-                if (internalResult.getNumResults() == 0) {\n-                    throw new CatalogException(\"File '\" + id + \"' not found\");\n-                }\n-                File file = internalResult.first();\n-\n-                // We set the proper values for the audit\n-                fileId = file.getId();\n-                fileUuid = file.getUuid();\n-\n-                OpenCGAResult<File> updateResult = update(study, file, updateParams, options, userId, token);\n-                result.append(updateResult);\n-\n-                auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n-                        auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            } catch (CatalogException e) {\n-                Event event = new Event(Event.Type.ERROR, id, e.getMessage());\n-                result.getEvents().add(event);\n-\n-                logger.error(\"Cannot update file {}: {}\", fileId, e.getMessage());\n-                auditManager.auditUpdate(operationId, userId, Enums.Resource.FILE, fileId, fileUuid, study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            }\n-        }\n-        auditManager.finishAuditBatch(operationId);\n-        return endResult(result, ignoreException);\n-    }\n-\n-    private OpenCGAResult<File> update(Study study, File file, FileUpdateParams updateParams, QueryOptions options, String userId,\n-                                       String token) throws CatalogException {\n-        ObjectMap parameters = new ObjectMap();\n-        if (updateParams != null) {\n-            try {\n-                parameters = updateParams.getUpdateMap();\n-            } catch (JsonProcessingException e) {\n-                throw new CatalogException(\"Could not parse FileUpdateParams object: \" + e.getMessage(), e);\n-            }\n-        }\n-        ParamUtils.checkUpdateParametersMap(parameters);\n-\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-\n-        if (parameters.containsKey(FileDBAdaptor.QueryParams.ANNOTATION_SETS.key())) {\n-            Map<String, Object> actionMap = new HashMap<>(options.getMap(Constants.ACTIONS, Collections.emptyMap()));\n-            if (!actionMap.containsKey(AnnotationSetManager.ANNOTATION_SETS)\n-                    && !actionMap.containsKey(AnnotationSetManager.ANNOTATIONS)) {\n-                logger.warn(\"Assuming the user wants to add the list of annotation sets provided\");\n-                actionMap.put(AnnotationSetManager.ANNOTATION_SETS, ParamUtils.UpdateAction.ADD);\n-                options.put(Constants.ACTIONS, actionMap);\n-            }\n-        }\n-\n-        if (parameters.containsKey(FileDBAdaptor.QueryParams.RELATED_FILES.key())) {\n-            List<FileRelatedFile> relatedFileList = new ArrayList<>();\n-            for (SmallRelatedFileParams relatedFile : updateParams.getRelatedFiles()) {\n-                if (StringUtils.isEmpty(relatedFile.getFile()) || relatedFile.getRelation() == null) {\n-                    throw new CatalogException(\"Missing file or relation in relatedFiles list\");\n-                }\n-                File relatedFileFile = internalGet(study.getUid(), relatedFile.getFile(), null, INCLUDE_FILE_URI_PATH, userId).first();\n-                relatedFileList.add(new FileRelatedFile(relatedFileFile, relatedFile.getRelation()));\n-            }\n-            parameters.put(FileDBAdaptor.QueryParams.RELATED_FILES.key(), relatedFileList);\n-\n-            Map<String, Object> actionMap = options.getMap(Constants.ACTIONS, new HashMap<>());\n-            if (!actionMap.containsKey(FileDBAdaptor.QueryParams.RELATED_FILES.key())) {\n-                logger.warn(\"Assuming the user wants to add the list of related files provided\");\n-                actionMap.put(FileDBAdaptor.QueryParams.RELATED_FILES.key(), ParamUtils.UpdateAction.ADD.name());\n-                options.put(Constants.ACTIONS, actionMap);\n-            }\n-        }\n-\n-        // Check permissions...\n-        // Only check write annotation permissions if the user wants to update the annotation sets\n-        if (updateParams != null && updateParams.getAnnotationSets() != null) {\n-            authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId,\n-                    FileAclEntry.FilePermissions.WRITE_ANNOTATIONS);\n-        }\n-        // Only check update permissions if the user wants to update anything apart from the annotation sets\n-        if ((parameters.size() == 1 && !parameters.containsKey(FileDBAdaptor.QueryParams.ANNOTATION_SETS.key()))\n-                || parameters.size() > 1) {\n-            authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n-        }\n-\n-        if (isRootFolder(file)) {\n-            throw new CatalogException(\"Cannot modify root folder\");\n-        }\n-\n-        // We make a query to check both if the samples exists and if the user has permissions to see them\n-        if (updateParams != null && ListUtils.isNotEmpty(updateParams.getSampleIds())) {\n-            catalogManager.getSampleManager().internalGet(study.getUid(), updateParams.getSampleIds(), SampleManager.INCLUDE_SAMPLE_IDS,\n-                    userId, false);\n-        }\n-\n-        //Name must be changed with \"rename\".\n-        if (updateParams != null && StringUtils.isNotEmpty(updateParams.getName())) {\n-            logger.info(\"Rename file using update method!\");\n-            rename(study.getFqn(), file.getPath(), updateParams.getName(), token);\n-            parameters.remove(FileDBAdaptor.QueryParams.NAME.key());\n-        }\n-\n-        checkUpdateAnnotations(study, file, parameters, options, VariableSet.AnnotableDataModels.FILE, fileDBAdaptor, userId);\n-\n-        return fileDBAdaptor.update(file.getUid(), parameters, study.getVariableSets(), options);\n-    }\n-\n-    @Deprecated\n-    public OpenCGAResult<File> update(String studyStr, String entryStr, ObjectMap parameters, QueryOptions options, String token)\n-            throws CatalogException {\n-        ParamUtils.checkObj(parameters, \"Parameters\");\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId, StudyManager.INCLUDE_VARIABLE_SET);\n-\n-        File file = internalGet(study.getUid(), entryStr, QueryOptions.empty(), userId).first();\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"fileId\", entryStr)\n-                .append(\"updateParams\", parameters)\n-                .append(\"options\", options)\n-                .append(\"token\", token);\n-        try {\n-            // Check permissions...\n-            // Only check write annotation permissions if the user wants to update the annotation sets\n-            if (parameters.containsKey(FileDBAdaptor.QueryParams.ANNOTATION_SETS.key())) {\n-                authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId,\n-                        FileAclEntry.FilePermissions.WRITE_ANNOTATIONS);\n-            }\n-            // Only check update permissions if the user wants to update anything apart from the annotation sets\n-            if ((parameters.size() == 1 && !parameters.containsKey(FileDBAdaptor.QueryParams.ANNOTATION_SETS.key()))\n-                    || parameters.size() > 1) {\n-                authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n-            }\n-\n-            try {\n-                ParamUtils.checkAllParametersExist(parameters.keySet().iterator(), (a) -> FileDBAdaptor.UpdateParams.getParam(a) != null);\n-            } catch (CatalogParameterException e) {\n-                throw new CatalogException(\"Could not update: \" + e.getMessage(), e);\n-            }\n-\n-            // We make a query to check both if the samples exists and if the user has permissions to see them\n-            if (parameters.get(FileDBAdaptor.QueryParams.SAMPLE_IDS.key()) != null\n-                    && ListUtils.isNotEmpty(parameters.getAsStringList(FileDBAdaptor.QueryParams.SAMPLE_IDS.key()))) {\n-                List<String> sampleIds = parameters.getAsStringList(FileDBAdaptor.QueryParams.SAMPLE_IDS.key());\n-                catalogManager.getSampleManager().internalGet(study.getUid(), sampleIds, SampleManager.INCLUDE_SAMPLE_IDS, userId, false);\n-            }\n-\n-            //Name must be changed with \"rename\".\n-            if (parameters.containsKey(FileDBAdaptor.QueryParams.NAME.key())) {\n-                logger.info(\"Rename file using update method!\");\n-                rename(studyStr, file.getPath(), parameters.getString(FileDBAdaptor.QueryParams.NAME.key()), token);\n-            }\n-\n-            OpenCGAResult<File> queryResult = unsafeUpdate(study, file, parameters, options, userId);\n-            auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            return queryResult;\n-        } catch (CatalogException e) {\n-            auditManager.auditUpdate(userId, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n-\n-    OpenCGAResult<File> unsafeUpdate(Study study, File file, ObjectMap parameters, QueryOptions options, String userId)\n-            throws CatalogException {\n-        if (isRootFolder(file)) {\n-            throw new CatalogException(\"Cannot modify root folder\");\n-        }\n-\n-        try {\n-            ParamUtils.checkAllParametersExist(parameters.keySet().iterator(), (a) -> FileDBAdaptor.UpdateParams.getParam(a) != null);\n-        } catch (CatalogParameterException e) {\n-            throw new CatalogException(\"Could not update: \" + e.getMessage(), e);\n-        }\n-\n-        checkUpdateAnnotations(study, file, parameters, options, VariableSet.AnnotableDataModels.FILE, fileDBAdaptor, userId);\n-\n-        fileDBAdaptor.update(file.getUid(), parameters, study.getVariableSets(), options);\n-        return fileDBAdaptor.get(file.getUid(), options);\n-    }\n-\n-    public OpenCGAResult<File> link(String studyStr, FileLinkParams params, boolean parents, String token) throws CatalogException {\n-        // We make two attempts to link to ensure the behaviour remains even if it is being called at the same time link from different\n-        // threads\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"params\", params)\n-                .append(\"parents\", parents)\n-                .append(\"token\", token);\n-        try {\n-            OpenCGAResult<File> result = privateLink(study, params, parents, token);\n-            auditManager.auditCreate(userId, Enums.Action.LINK, Enums.Resource.FILE, result.first().getId(),\n-                    result.first().getUuid(), study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            return result;\n-        } catch (CatalogException e) {\n-            try {\n-                OpenCGAResult<File> result = privateLink(study, params, parents, token);\n-                auditManager.auditCreate(userId, Enums.Action.LINK, Enums.Resource.FILE, result.first().getId(),\n-                        result.first().getUuid(), study.getId(), study.getUuid(), auditParams,\n-                        new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-                return result;\n-            } catch (CatalogException e2) {\n-                auditManager.auditCreate(userId, Enums.Action.LINK, Enums.Resource.FILE, params.getUri(), \"\",\n-                        study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n-                                new Error(0, \"\", e2.getMessage())));\n-                throw new CatalogException(e2.getMessage(), e2);\n-            }\n-        }\n-    }\n-\n-    @Deprecated\n-    public OpenCGAResult<File> link(String studyStr, URI uriOrigin, String pathDestiny, ObjectMap params, String token)\n-            throws CatalogException {\n-        params = ParamUtils.defaultObject(params, ObjectMap::new);\n-        FileLinkParams linkParams = new FileLinkParams()\n-                .setDescription(params.getString(\"description\", \"\"))\n-                .setPath(pathDestiny)\n-                .setUri(uriOrigin.toString())\n-                .setRelatedFiles(params.getAsList(\"relatedFiles\", SmallRelatedFileParams.class));\n-        return link(studyStr, linkParams, params.getBoolean(\"parents\", false), token);\n-    }\n-\n-    @Override\n-    public OpenCGAResult rank(String studyStr, Query query, String field, int numResults, boolean asc, String sessionId)\n-            throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n-        ParamUtils.checkObj(field, \"field\");\n-        ParamUtils.checkObj(sessionId, \"sessionId\");\n-\n-        String userId = userManager.getUserId(sessionId);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.VIEW_FILES);\n-\n-        // TODO: In next release, we will have to check the count parameter from the queryOptions object.\n-        boolean count = true;\n-        query.append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-        OpenCGAResult queryResult = null;\n-        if (count) {\n-            // We do not need to check for permissions when we show the count of files\n-            queryResult = fileDBAdaptor.rank(query, field, numResults, asc);\n-        }\n-\n-        return ParamUtils.defaultObject(queryResult, OpenCGAResult::new);\n-    }\n-\n-    @Override\n-    public OpenCGAResult groupBy(@Nullable String studyStr, Query query, List<String> fields, QueryOptions options, String sessionId)\n-            throws CatalogException {\n-        query = ParamUtils.defaultObject(query, Query::new);\n-        options = ParamUtils.defaultObject(options, QueryOptions::new);\n-        if (fields == null || fields.size() == 0) {\n-            throw new CatalogException(\"Empty fields parameter.\");\n-        }\n-\n-        String userId = userManager.getUserId(sessionId);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        fixQueryObject(study, query, userId);\n-\n-        // Add study id to the query\n-        query.put(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-\n-        // We do not need to check for permissions when we show the count of files\n-        OpenCGAResult queryResult = fileDBAdaptor.groupBy(query, fields, options, userId);\n-\n-        return ParamUtils.defaultObject(queryResult, OpenCGAResult::new);\n-    }\n-\n-    OpenCGAResult<File> rename(String studyStr, String fileStr, String newName, String sessionId) throws CatalogException {\n-        ParamUtils.checkFileName(newName, \"name\");\n-\n-        String userId = userManager.getUserId(sessionId);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        File file = internalGet(study.getUid(), fileStr, EXCLUDE_FILE_ATTRIBUTES, userId).first();\n-        authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n-\n-        if (file.getName().equals(newName)) {\n-            OpenCGAResult result = OpenCGAResult.empty();\n-            result.setEvents(Collections.singletonList(new Event(Event.Type.WARNING, newName, \"File already had that name.\")));\n-            return result;\n-        }\n-\n-        if (isRootFolder(file)) {\n-            throw new CatalogException(\"Can not rename root folder\");\n-        }\n-\n-        String oldPath = file.getPath();\n-        Path parent = Paths.get(oldPath).getParent();\n-        String newPath;\n-        if (parent == null) {\n-            newPath = newName;\n-        } else {\n-            newPath = parent.resolve(newName).toString();\n-        }\n-\n-        IOManager ioManager = null;\n-        try {\n-            ioManager = ioManagerFactory.get(file.getUri());\n-        } catch (IOException e) {\n-            throw CatalogIOException.ioManagerException(file.getUri(), e);\n-        }\n-        URI oldUri = file.getUri();\n-        URI newUri = Paths.get(oldUri).getParent().resolve(newName).toUri();\n-//        URI studyUri = file.getUri();\n-        boolean isExternal = file.isExternal(); //If the file URI is not null, the file is external located.\n-\n-        switch (file.getType()) {\n-            case DIRECTORY:\n-                if (!isExternal) {  //Only rename non external files\n-                    // TODO? check if something in the subtree is not READY?\n-                    if (ioManager.exists(oldUri)) {\n-                        ioManager.rename(oldUri, newUri);   // io.move() 1\n-                    }\n-                }\n-                fileDBAdaptor.rename(file.getUid(), newPath, newUri.toString(), null);\n+                tagsCopy.addAll(values);\n+                file.setTags(tagsCopy);\n                 break;\n-            case FILE:\n-                if (!isExternal) {  //Only rename non external files\n-                    ioManager.rename(oldUri, newUri);\n-                }\n-                fileDBAdaptor.rename(file.getUid(), newPath, newUri.toString(), null);\n-                break;\n-            default:\n-                throw new CatalogException(\"Unknown file type \" + file.getType());\n-        }\n-\n-        return fileDBAdaptor.get(file.getUid(), QueryOptions.empty());\n-    }\n-\n-    public OpenCGAResult<FileContent> grep(String studyId, String fileId, String pattern, boolean ignoreCase, int numLines, String token)\n-            throws CatalogException {\n-        long startTime = System.currentTimeMillis();\n-\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, userId);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"fileId\", fileId)\n-                .append(\"pattern\", pattern)\n-                .append(\"ignoreCase\", ignoreCase)\n-                .append(\"numLines\", numLines)\n-                .append(\"token\", token);\n-        try {\n-            File file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI, userId).first();\n-            authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.VIEW_CONTENT);\n-\n-            URI fileUri = getUri(file);\n-            FileContent fileContent;\n-            try {\n-                fileContent = ioManagerFactory.get(fileUri).grep(Paths.get(fileUri), pattern, numLines, ignoreCase);\n-            } catch (IOException e) {\n-                throw CatalogIOException.ioManagerException(fileUri, e);\n-            }\n-\n-            auditManager.audit(userId, Enums.Action.GREP, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-\n-            return new OpenCGAResult<>((int) (System.currentTimeMillis() - startTime), Collections.emptyList(), 1,\n-                    Collections.singletonList(fileContent), 1);\n-        } catch (CatalogException e) {\n-            auditManager.audit(userId, Enums.Action.GREP, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n-\n-    public OpenCGAResult<FileContent> image(String studyStr, String fileId, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        long startTime = System.currentTimeMillis();\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"fileId\", fileId)\n-                .append(\"token\", token);\n-        File file;\n-        try {\n-            file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI_PATH, userId).first();\n-            authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.VIEW_CONTENT);\n-\n-            if (file.getFormat() != File.Format.IMAGE) {\n-                throw new CatalogException(\"File '\" + fileId + \"' is not an image. Format of file is '\" + file.getFormat() + \"'.\");\n-            }\n-\n-            URI fileUri = getUri(file);\n-            FileContent fileContent;\n-\n-            try {\n-                fileContent = ioManagerFactory.get(fileUri).base64Image(Paths.get(fileUri));\n-            } catch (IOException e) {\n-                throw CatalogIOException.ioManagerException(fileUri, e);\n-            }\n-            auditManager.audit(userId, Enums.Action.IMAGE_CONTENT, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-\n-            return new OpenCGAResult<>((int) (System.currentTimeMillis() - startTime), Collections.emptyList(), 1,\n-                    Collections.singletonList(fileContent), 1);\n-        } catch (CatalogException e) {\n-            auditManager.audit(userId, Enums.Action.IMAGE_CONTENT, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n-\n-    public OpenCGAResult<FileContent> head(String studyStr, String fileId, long offset, int lines, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        long startTime = System.currentTimeMillis();\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"fileId\", fileId)\n-                .append(\"offset\", offset)\n-                .append(\"lines\", lines)\n-                .append(\"token\", token);\n-        File file;\n-        try {\n-            file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI, userId).first();\n-            authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.VIEW_CONTENT);\n-            URI fileUri = getUri(file);\n-            FileContent fileContent;\n-            try {\n-                fileContent = ioManagerFactory.get(fileUri).head(Paths.get(fileUri), offset, lines);\n-            } catch (IOException e) {\n-                throw CatalogIOException.ioManagerException(fileUri, e);\n-            }\n-            auditManager.audit(userId, Enums.Action.HEAD_CONTENT, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-\n-            return new OpenCGAResult<>((int) (System.currentTimeMillis() - startTime), Collections.emptyList(), 1,\n-                    Collections.singletonList(fileContent), 1);\n-        } catch (CatalogException e) {\n-            auditManager.audit(userId, Enums.Action.HEAD_CONTENT, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n-\n-    public OpenCGAResult<FileContent> tail(String studyStr, String fileId, int lines, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        long startTime = System.currentTimeMillis();\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"fileId\", fileId)\n-                .append(\"lines\", lines)\n-                .append(\"token\", token);\n-        File file;\n-        try {\n-            file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI, userId).first();\n-            authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.VIEW_CONTENT);\n-            URI fileUri = getUri(file);\n-            FileContent fileContent;\n-            try {\n-                fileContent = ioManagerFactory.get(fileUri).tail(Paths.get(fileUri), lines);\n-            } catch (IOException e) {\n-                throw CatalogIOException.ioManagerException(fileUri, e);\n-            }\n-            auditManager.audit(userId, Enums.Action.TAIL_CONTENT, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-\n-            return new OpenCGAResult<>((int) (System.currentTimeMillis() - startTime), Collections.emptyList(), 1,\n-                    Collections.singletonList(fileContent), 1);\n-        } catch (CatalogException e) {\n-            auditManager.audit(userId, Enums.Action.TAIL_CONTENT, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n-\n-    public DataInputStream download(String studyStr, String fileId, String token) throws CatalogException {\n-        return download(studyStr, fileId, -1, -1, token);\n-    }\n-\n-    public DataInputStream download(String studyStr, String fileId, int start, int limit, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"study\", studyStr)\n-                .append(\"fileId\", fileId)\n-                .append(\"start\", start)\n-                .append(\"limit\", limit)\n-                .append(\"token\", token);\n-        File file;\n-        try {\n-            file = internalGet(study.getUid(), fileId, INCLUDE_FILE_URI, userId).first();\n-            authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.DOWNLOAD);\n-            URI fileUri = getUri(file);\n-            DataInputStream dataInputStream;\n-            try {\n-                dataInputStream = ioManagerFactory.get(fileUri).getFileObject(fileUri, start, limit);\n-            } catch (IOException e) {\n-                throw CatalogIOException.ioManagerException(fileUri, e);\n-            }\n-\n-            auditManager.audit(userId, Enums.Action.DOWNLOAD, Enums.Resource.FILE, file.getId(), file.getUuid(), study.getId(),\n-                    study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-            return dataInputStream;\n-        } catch (CatalogException e) {\n-            auditManager.audit(userId, Enums.Action.DOWNLOAD, Enums.Resource.FILE, fileId, \"\", study.getId(), study.getUuid(),\n-                    auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()));\n-            throw e;\n-        }\n-    }\n-\n-    public void setFileIndex(String studyStr, String fileId, FileIndex index, String sessionId) throws CatalogException {\n-        String userId = userManager.getUserId(sessionId);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-        long fileUid = internalGet(study.getUid(), fileId, INCLUDE_FILE_IDS, userId).first().getUid();\n-\n-        authorizationManager.checkFilePermission(study.getUid(), fileUid, userId, FileAclEntry.FilePermissions.WRITE);\n-\n-        ObjectMap parameters = new ObjectMap(FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), index);\n-        fileDBAdaptor.update(fileUid, parameters, QueryOptions.empty());\n-    }\n-\n-    // **************************   ACLs  ******************************** //\n-    public OpenCGAResult<Map<String, List<String>>> getAcls(String studyId, List<String> fileList, String member, boolean ignoreException,\n-                                                            String token) throws CatalogException {\n-        String user = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, user);\n-\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"fileList\", fileList)\n-                .append(\"member\", member)\n-                .append(\"ignoreException\", ignoreException)\n-                .append(\"token\", token);\n-        try {\n-            OpenCGAResult<Map<String, List<String>>> fileAclList = OpenCGAResult.empty();\n-            InternalGetDataResult<File> fileDataResult = internalGet(study.getUid(), fileList, INCLUDE_FILE_IDS, user, ignoreException);\n-\n-            Map<String, InternalGetDataResult.Missing> missingMap = new HashMap<>();\n-            if (fileDataResult.getMissing() != null) {\n-                missingMap = fileDataResult.getMissing().stream()\n-                        .collect(Collectors.toMap(InternalGetDataResult.Missing::getId, Function.identity()));\n-            }\n-            int counter = 0;\n-            for (String fileId : fileList) {\n-                if (!missingMap.containsKey(fileId)) {\n-                    File file = fileDataResult.getResults().get(counter);\n-                    try {\n-                        OpenCGAResult<Map<String, List<String>>> allFileAcls;\n-                        if (StringUtils.isNotEmpty(member)) {\n-                            allFileAcls = authorizationManager.getFileAcl(study.getUid(), file.getUid(), user, member);\n-                        } else {\n-                            allFileAcls = authorizationManager.getAllFileAcls(study.getUid(), file.getUid(), user, true);\n-                        }\n-                        fileAclList.append(allFileAcls);\n-\n-                        auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FILE, file.getId(),\n-                                file.getUuid(), study.getId(), study.getUuid(), auditParams,\n-                                new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS), new ObjectMap());\n-                    } catch (CatalogException e) {\n-                        auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FILE, file.getId(),\n-                                file.getUuid(), study.getId(), study.getUuid(), auditParams,\n-                                new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()), new ObjectMap());\n-\n-                        if (!ignoreException) {\n-                            throw e;\n-                        } else {\n-                            Event event = new Event(Event.Type.ERROR, fileId, missingMap.get(fileId).getErrorMsg());\n-                            fileAclList.append(new OpenCGAResult<>(0, Collections.singletonList(event), 0,\n-                                    Collections.singletonList(Collections.emptyMap()), 0));\n-                        }\n-                    }\n-                    counter += 1;\n+              case SET:\n+                if (hookConfiguration.getWhat().contains(\",\")) {\n+                  values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n                 } else {\n-                    Event event = new Event(Event.Type.ERROR, fileId, missingMap.get(fileId).getErrorMsg());\n-                    fileAclList.append(new OpenCGAResult<>(0, Collections.singletonList(event), 0,\n-                            Collections.singletonList(Collections.emptyMap()), 0));\n-\n-                    auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FILE, fileId, \"\",\n-                            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n-                                    new Error(0, \"\", missingMap.get(fileId).getErrorMsg())), new ObjectMap());\n+                  values = Collections.singletonList(hookConfiguration.getWhat());\n                 }\n+                file.setTags(values);\n+                break;\n+              case REMOVE:\n+                file.setTags(Collections.emptyList());\n+                break;\n+              default:\n+                break;\n             }\n-            return fileAclList;\n-        } catch (CatalogException e) {\n-            for (String fileId : fileList) {\n-                auditManager.audit(operationId, user, Enums.Action.FETCH_ACLS, Enums.Resource.FILE, fileId, \"\", study.getId(),\n-                        study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError()),\n-                        new ObjectMap());\n-            }\n-            throw e;\n-        }\n-    }\n-\n-    public OpenCGAResult<Map<String, List<String>>> updateAcl(String studyId, List<String> fileStrList, String memberList,\n-                                                              FileAclParams aclParams, ParamUtils.AclAction action, String token)\n-            throws CatalogException {\n-        String user = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyId, user);\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"fileStrList\", fileStrList)\n-                .append(\"memberList\", memberList)\n-                .append(\"aclParams\", aclParams)\n-                .append(\"action\", action)\n-                .append(\"token\", token);\n-        String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT);\n-\n-        try {\n-            int count = 0;\n-            count += fileStrList != null && !fileStrList.isEmpty() ? 1 : 0;\n-            count += StringUtils.isNotEmpty(aclParams.getSample()) ? 1 : 0;\n-\n-            if (count > 1) {\n-                throw new CatalogException(\"Update ACL: Only one of these parameters are allowed: file or sample per query.\");\n-            } else if (count == 0) {\n-                throw new CatalogException(\"Update ACL: At least one of these parameters should be provided: file or sample\");\n-            }\n-\n-            if (action == null) {\n-                throw new CatalogException(\"Invalid action found. Please choose a valid action to be performed.\");\n-            }\n-\n-            List<String> permissions = Collections.emptyList();\n-            if (StringUtils.isNotEmpty(aclParams.getPermissions())) {\n-                permissions = Arrays.asList(aclParams.getPermissions().trim().replaceAll(\"\\\\s\", \"\").split(\",\"));\n-                checkPermissions(permissions, FileAclEntry.FilePermissions::valueOf);\n-            }\n-\n-\n-            List<File> extendedFileList;\n-            if (StringUtils.isNotEmpty(aclParams.getSample())) {\n-                // Obtain the sample ids\n-                OpenCGAResult<Sample> sampleDataResult = catalogManager.getSampleManager().internalGet(study.getUid(),\n-                        Arrays.asList(StringUtils.split(aclParams.getSample(), \",\")), SampleManager.INCLUDE_SAMPLE_IDS, user, false);\n-                Query query = new Query(FileDBAdaptor.QueryParams.SAMPLE_IDS.key(),\n-                        sampleDataResult.getResults().stream().map(Sample::getId).collect(Collectors.toList()));\n-\n-                extendedFileList = catalogManager.getFileManager().search(studyId, query, EXCLUDE_FILE_ATTRIBUTES, token).getResults();\n-            } else {\n-                extendedFileList = internalGet(study.getUid(), fileStrList, EXCLUDE_FILE_ATTRIBUTES, user, false).getResults();\n-            }\n-\n-            authorizationManager.checkCanAssignOrSeePermissions(study.getUid(), user);\n-\n-            // Increase the list with the files/folders within the list of ids that correspond with folders\n-            extendedFileList = getRecursiveFilesAndFolders(study.getUid(), extendedFileList);\n-\n-            // Validate that the members are actually valid members\n-            List<String> members;\n-            if (memberList != null && !memberList.isEmpty()) {\n-                members = Arrays.asList(memberList.split(\",\"));\n-            } else {\n-                members = Collections.emptyList();\n+          } else if (filterWhere.startsWith(FileDBAdaptor.QueryParams.STATS.key())) {\n+            String[] split = StringUtils.split(filterWhere, \".\", 2);\n+            String statsField = null;\n+            if (split.length == 2) {\n+              statsField = split[1];\n             }\n-            authorizationManager.checkNotAssigningPermissionsToAdminsGroup(members);\n-            checkMembers(study.getUid(), members);\n-\n-            List<Long> fileUids = extendedFileList.stream().map(File::getUid).collect(Collectors.toList());\n-            AuthorizationManager.CatalogAclParams catalogAclParams = new AuthorizationManager.CatalogAclParams(fileUids, permissions,\n-                    Enums.Resource.FILE);\n-//        studyManager.membersHavePermissionsInStudy(resourceIds.getStudyId(), members);\n \n-            OpenCGAResult<Map<String, List<String>>> queryResultList;\n-            switch (action) {\n-                case SET:\n-                    queryResultList = authorizationManager.setAcls(study.getUid(), members, catalogAclParams);\n-                    break;\n-                case ADD:\n-                    queryResultList = authorizationManager.addAcls(study.getUid(), members, catalogAclParams);\n-                    break;\n-                case REMOVE:\n-                    queryResultList = authorizationManager.removeAcls(members, catalogAclParams);\n-                    break;\n-                case RESET:\n-                    catalogAclParams.setPermissions(null);\n-                    queryResultList = authorizationManager.removeAcls(members, catalogAclParams);\n-                    break;\n-                default:\n-                    throw new CatalogException(\"Unexpected error occurred. No valid action found.\");\n-            }\n-            for (File file : extendedFileList) {\n-                auditManager.audit(operationId, user, Enums.Action.UPDATE_ACLS, Enums.Resource.FILE, file.getId(),\n-                        file.getUuid(), study.getId(), study.getUuid(), auditParams,\n-                        new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS), new ObjectMap());\n-            }\n-            return queryResultList;\n-        } catch (CatalogException e) {\n-            if (fileStrList != null) {\n-                for (String fileId : fileStrList) {\n-                    auditManager.audit(operationId, user, Enums.Action.UPDATE_ACLS, Enums.Resource.FILE, fileId, \"\",\n-                            study.getId(), study.getUuid(), auditParams, new AuditRecord.Status(AuditRecord.Status.Result.ERROR,\n-                                    e.getError()), new ObjectMap());\n+            switch (hookConfiguration.getAction()) {\n+              case ADD:\n+                if (statsField == null) {\n+                  logger.error(\"Cannot add a value to {} directly. Expected {}.<subfield>\",\n+                      FileDBAdaptor.QueryParams.STATS.key(), FileDBAdaptor.QueryParams.STATS.key());\n+                  continue;\n                 }\n-            }\n-            throw e;\n-        }\n-    }\n-\n-    public OpenCGAResult<File> getParents(String studyStr, String path, boolean rootFirst, QueryOptions options, String token)\n-            throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-\n-        List<String> paths = calculateAllPossiblePaths(path);\n-\n-        Query query = new Query(FileDBAdaptor.QueryParams.PATH.key(), paths);\n-        query.put(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid());\n-        OpenCGAResult<File> result = fileDBAdaptor.get(study.getUid(), query, options, userId);\n-        result.getResults().sort(rootFirst ? ROOT_FIRST_COMPARATOR : ROOT_LAST_COMPARATOR);\n-        return result;\n-    }\n-\n \n-    // **************************   Private methods   ******************************** //\n-    private boolean isRootFolder(File file) throws CatalogException {\n-        ParamUtils.checkObj(file, \"File\");\n-        return file.getPath().isEmpty();\n-    }\n-\n-    /**\n-     * Fetch all the recursive files and folders within the list of file ids given.\n-     *\n-     * @param studyUid Study uid.\n-     * @param fileList List of files\n-     * @return a more complete file list containing all the nested files\n-     */\n-    private List<File> getRecursiveFilesAndFolders(long studyUid, List<File> fileList) throws CatalogException {\n-        List<File> fileListCopy = new LinkedList<>();\n-        fileListCopy.addAll(fileList);\n-\n-        Set<Long> uidFileSet = new HashSet<>();\n-        uidFileSet.addAll(fileList.stream().map(File::getUid).collect(Collectors.toSet()));\n-\n-        List<String> pathList = new ArrayList<>();\n-        for (File file : fileList) {\n-            if (file.getType().equals(File.Type.DIRECTORY)) {\n-                pathList.add(\"~^\" + file.getPath());\n-            }\n-        }\n-\n-        if (CollectionUtils.isNotEmpty(pathList)) {\n-            // Search for all the files within the list of paths\n-            Query query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid)\n-                    .append(FileDBAdaptor.QueryParams.PATH.key(), pathList);\n-            OpenCGAResult<File> fileDataResult1 = fileDBAdaptor.get(query, INCLUDE_FILE_URI_PATH);\n-            for (File file1 : fileDataResult1.getResults()) {\n-                if (!uidFileSet.contains(file1.getUid())) {\n-                    uidFileSet.add(file1.getUid());\n-                    fileListCopy.add(file1);\n+                List<String> values;\n+                if (hookConfiguration.getWhat().contains(\",\")) {\n+                  values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n+                } else {\n+                  values = Collections.singletonList(hookConfiguration.getWhat());\n                 }\n-            }\n-        }\n-\n-        return fileListCopy;\n-    }\n-\n-    private List<String> calculateAllPossiblePaths(String filePath) {\n-        String path = \"\";\n-        String[] split = filePath.split(\"/\");\n-        List<String> paths = new ArrayList<>(split.length + 1);\n-        paths.add(\"\");  //Add study root folder\n-        //Add intermediate folders\n-        //Do not add the last split, could be a file or a folder..\n-        //Depending on this, it could end with '/' or not.\n-        for (int i = 0; i < split.length - 1; i++) {\n-            String f = split[i];\n-            path = path + f + \"/\";\n-            paths.add(path);\n-        }\n-        paths.add(filePath); //Add the file path\n-        return paths;\n-    }\n-\n-    //FIXME: This should use org.opencb.opencga.storage.core.variant.io.VariantReaderUtils\n-    private String getMainVariantFile(String name) {\n-        if (name.endsWith(\".variants.avro.gz\") || name.endsWith(\".variants.proto.gz\") || name.endsWith(\".variants.json.gz\")) {\n-            int idx = name.lastIndexOf(\".variants.\");\n-            return name.substring(0, idx);\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private boolean isTransformedFile(String name) {\n-        return getMainVariantFile(name) != null;\n-    }\n-\n-    private String getVariantMetadataFile(String path) {\n-        String file = getMainVariantFile(path);\n-        if (file != null) {\n-            return file + \".file.json.gz\";\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private OpenCGAResult<File> getParents(long studyUid, String filePath, boolean rootFirst, QueryOptions options)\n-            throws CatalogException {\n-        List<String> paths = calculateAllPossiblePaths(filePath);\n \n-        Query query = new Query(FileDBAdaptor.QueryParams.PATH.key(), paths);\n-        query.put(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyUid);\n-        OpenCGAResult<File> result = fileDBAdaptor.get(query, options);\n-        result.getResults().sort(rootFirst ? ROOT_FIRST_COMPARATOR : ROOT_LAST_COMPARATOR);\n-        return result;\n-    }\n-\n-    private String getParentPath(String path) {\n-        Path parent = Paths.get(path).getParent();\n-        String parentPath;\n-        if (parent == null) {   //If parent == null, the file is in the root of the study\n-            parentPath = \"\";\n-        } else {\n-            parentPath = parent.toString() + \"/\";\n-        }\n-        return parentPath;\n-    }\n-\n-    /**\n-     * Get the URI where a file should be in Catalog, given a study and a path.\n-     *\n-     * @param studyId   Study identifier\n-     * @param path      Path to locate\n-     * @param directory Boolean indicating if the file is a directory\n-     * @return URI where the file should be placed\n-     * @throws CatalogException CatalogException\n-     */\n-    private URI getFileUri(long studyId, String path, boolean directory) throws CatalogException, URISyntaxException {\n-        // Get the closest existing parent. If parents == true, may happen that the parent is not registered in catalog yet.\n-        File existingParent = getParents(studyId, path, false, null).first();\n-\n-        //Relative path to the existing parent\n-        String relativePath = Paths.get(existingParent.getPath()).relativize(Paths.get(path)).toString();\n-        if (path.endsWith(\"/\") && !relativePath.endsWith(\"/\")) {\n-            relativePath += \"/\";\n-        }\n-\n-        String uriStr = Paths.get(existingParent.getUri().getPath()).resolve(relativePath).toString();\n-\n-        if (directory) {\n-            return UriUtils.createDirectoryUri(uriStr);\n-        } else {\n-            return UriUtils.createUri(uriStr);\n-        }\n-    }\n-\n-    private boolean isExternal(Study study, String catalogFilePath, URI fileUri) throws CatalogException {\n-        URI studyUri = study.getUri();\n-\n-        String studyFilePath = Paths.get(studyUri).resolve(catalogFilePath).toString();\n-        String originalFilePath = Paths.get(fileUri).toString();\n-\n-        logger.debug(\"Study file path: {}\", studyFilePath);\n-        logger.debug(\"File path: {}\", originalFilePath);\n-        return !studyFilePath.equals(originalFilePath);\n-    }\n-\n-    /**\n-     * Method to check if a file or folder can be deleted. It will check for indexation, status, permissions and file system availability.\n-     *\n-     * @param studyStr       Study.\n-     * @param fileId         File or folder id.\n-     * @param unlink         Boolean indicating whether the operation only expects to remove the entry from the database or also remove\n-     *                       the file from disk.\n-     * @param token          Token of the user for which DELETE permissions will be checked.\n-     * @throws CatalogException if any of the files cannot be deleted.\n-     */\n-    public void checkCanDeleteFile(String studyStr, String fileId, boolean unlink, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        Study study = studyManager.resolveId(studyStr, userId);\n-        checkCanDeleteFile(study, fileId, unlink, Arrays.asList(FileStatus.READY, FileStatus.TRASHED), userId);\n-    }\n-\n-    /**\n-     * Method to check if a file or folder can be deleted. It will check for indexation, status, permissions and file system availability.\n-     *\n-     * @param study          Study.\n-     * @param fileId         File or folder id.\n-     * @param unlink         Boolean indicating whether the operation only expects to remove the entry from the database or also remove\n-     *                       the file from disk.\n-     * @param acceptedStatus List of valid statuses the file should have. For the public, the file should be in READY or TRASHED status.\n-     *                       However, if someone calls to the delete/unlink methods, the status of those files should already be in\n-     *                       PENDING_DELETE.\n-     * @param userId         user for which DELETE permissions will be checked.\n-     * @throws CatalogException if any of the files cannot be deleted.\n-     */\n-    private void checkCanDeleteFile(Study study, String fileId, boolean unlink, List<String> acceptedStatus, String userId)\n-            throws CatalogException {\n-\n-        QueryOptions options = new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(FileDBAdaptor.QueryParams.UID.key(),\n-                FileDBAdaptor.QueryParams.NAME.key(), FileDBAdaptor.QueryParams.TYPE.key(), FileDBAdaptor.QueryParams.RELATED_FILES.key(),\n-                FileDBAdaptor.QueryParams.SIZE.key(), FileDBAdaptor.QueryParams.URI.key(), FileDBAdaptor.QueryParams.PATH.key(),\n-                FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), FileDBAdaptor.QueryParams.INTERNAL_STATUS.key(),\n-                FileDBAdaptor.QueryParams.EXTERNAL.key()));\n-\n-        OpenCGAResult<File> fileOpenCGAResult = internalGet(study.getUid(), fileId, options, userId);\n-        if (fileOpenCGAResult.getNumResults() == 0) {\n-            throw new CatalogException(\"File \" + fileId + \" not found\");\n-        }\n-        File file = fileOpenCGAResult.first();\n-\n-        // If the user is the owner or the admin, we won't check if he has permissions for every single file\n-        boolean checkPermissions = !authorizationManager.isOwnerOrAdmin(study.getUid(), userId);\n-\n-        Set<Long> indexFiles = new HashSet<>();\n-\n-        if (unlink && !file.isExternal()) {\n-            throw new CatalogException(\"Cannot unlink non-external files. Use delete operation instead\");\n-        } else if (!unlink && file.isExternal()) {\n-            throw new CatalogException(\"Cannot delete external files. Use unlink operation instead\");\n-        }\n-\n-        IOManager ioManager;\n-        try {\n-            ioManager = ioManagerFactory.get(file.getUri());\n-        } catch (IOException e) {\n-            throw CatalogIOException.ioManagerException(file.getUri(), e);\n-        }\n-        if (file.getType() == File.Type.FILE) {\n-            if (checkPermissions) {\n-                authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n-                authorizationManager.checkFilePermission(study.getUid(), file.getUid(), userId, FileAclEntry.FilePermissions.DELETE);\n-            }\n-\n-            // File must exist in the file system\n-            if (!unlink && !ioManager.exists(file.getUri())) {\n-                throw new CatalogException(\"File \" + file.getUri() + \" not found in file system\");\n-            }\n-\n-            checkValidStatusForDeletion(file, acceptedStatus);\n-            indexFiles.addAll(getProducedFromIndexFiles(file));\n-        } else {\n-            // We cannot delete the root folder\n-            if (isRootFolder(file)) {\n-                throw new CatalogException(\"Root directories cannot be deleted\");\n-            }\n-\n-            // Query to get all recursive files and folders\n-            Query query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                    .append(FileDBAdaptor.QueryParams.PATH.key(), \"~^\" + file.getPath() + \"*\");\n-\n-            if (unlink) {\n-                // Only external files/folders are allowed within the folder\n-                Query tmpQuery = new Query(query)\n-                        .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), false);\n-                long numMatches = fileDBAdaptor.count(tmpQuery).getNumMatches();\n-\n-                if (numMatches > 0) {\n-                    throw new CatalogException(numMatches + \" local files detected within the external \"\n-                            + \"folder \" + file.getPath() + \". Please, delete those folders or files manually first\");\n-                }\n-            } else {\n-                // Only non-external files/folders are allowed within the folder\n-                Query tmpQuery = new Query(query)\n-                        .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), true);\n-                long numMatches = fileDBAdaptor.count(tmpQuery).getNumMatches();\n-\n-                if (numMatches > 0) {\n-                    throw new CatalogException(numMatches + \" external files detected within the local \"\n-                            + \"folder \" + file.getPath() + \". Please, unlink those folders or files manually first\");\n+                Object currentStatsValue = file.getStats().get(statsField);\n+                if (currentStatsValue == null) {\n+                  file.getStats().put(statsField, values);\n+                } else if (currentStatsValue instanceof Collection) {\n+                  ((List) currentStatsValue).addAll(values);\n+                } else {\n+                  logger.error(\"Cannot add a value to {} if it is not an array\", filterWhere);\n+                  continue;\n                 }\n-            }\n \n-            DBIterator<File> iterator = fileDBAdaptor.iterator(query, options);\n-            while (iterator.hasNext()) {\n-                File tmpFile = iterator.next();\n-\n-                if (checkPermissions) {\n-                    authorizationManager.checkFilePermission(study.getUid(), tmpFile.getUid(), userId, FileAclEntry.FilePermissions.DELETE);\n-                    authorizationManager.checkFilePermission(study.getUid(), tmpFile.getUid(), userId, FileAclEntry.FilePermissions.WRITE);\n+                break;\n+              case SET:\n+                if (statsField == null) {\n+                  logger.error(\"Cannot set a value to {} directly. Expected {}.<subfield>\",\n+                      FileDBAdaptor.QueryParams.STATS.key(), FileDBAdaptor.QueryParams.STATS.key());\n+                  continue;\n                 }\n \n-                // File must exist in the file system\n-                if (!unlink && !ioManager.exists(tmpFile.getUri())) {\n-                    throw new CatalogException(\"File \" + tmpFile.getUri() + \" not found in file system\");\n+                if (hookConfiguration.getWhat().contains(\",\")) {\n+                  values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n+                } else {\n+                  values = Collections.singletonList(hookConfiguration.getWhat());\n                 }\n-\n-                checkValidStatusForDeletion(tmpFile, acceptedStatus);\n-                indexFiles.addAll(getProducedFromIndexFiles(tmpFile));\n-            }\n-\n-            // TODO: Validate no file/folder within any registered directory is not registered in OpenCGA\n-        }\n-\n-\n-        // Check the original files are not being indexed at the moment\n-        if (!indexFiles.isEmpty()) {\n-            Query query = new Query(FileDBAdaptor.QueryParams.UID.key(), new ArrayList<>(indexFiles));\n-            try (DBIterator<File> iterator = fileDBAdaptor.iterator(query, new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(\n-                    FileDBAdaptor.QueryParams.INTERNAL_INDEX.key(), FileDBAdaptor.QueryParams.UID.key())))) {\n-                while (iterator.hasNext()) {\n-                    File next = iterator.next();\n-                    String status = next.getInternal().getIndex().getStatus().getName();\n-                    switch (status) {\n-                        case FileIndex.IndexStatus.READY:\n-                            // If they are already ready, we only need to remove the reference to the transformed files as they will be\n-                            // removed\n-                            next.getInternal().getIndex().setTransformedFile(null);\n-                            break;\n-                        case FileIndex.IndexStatus.TRANSFORMED:\n-                            // We need to remove the reference to the transformed files and change their status from TRANSFORMED to NONE\n-                            next.getInternal().getIndex().setTransformedFile(null);\n-                            next.getInternal().getIndex().getStatus().setName(FileIndex.IndexStatus.NONE);\n-                            break;\n-                        case FileIndex.IndexStatus.NONE:\n-                        case FileIndex.IndexStatus.DELETED:\n-                            break;\n-                        default:\n-                            throw new CatalogException(\"Cannot delete files that are in use in storage.\");\n-                    }\n+                file.getStats().put(statsField, values);\n+                break;\n+              case REMOVE:\n+                if (statsField == null) {\n+                  file.setStats(Collections.emptyMap());\n+                } else {\n+                  file.getStats().remove(statsField);\n                 }\n+                break;\n+              default:\n+                break;\n             }\n-        }\n-    }\n-\n-    Set<Long> getProducedFromIndexFiles(File fileAux) {\n-        // Check if the file is produced from other file being indexed and add them to the transformedFromFileIds set\n-        if (fileAux.getRelatedFiles() != null && !fileAux.getRelatedFiles().isEmpty()) {\n-            return fileAux.getRelatedFiles().stream()\n-                    .filter(myFile -> myFile.getRelation() == FileRelatedFile.Relation.PRODUCED_FROM)\n-                    .map(FileRelatedFile::getFile)\n-                    .map(File::getUid)\n-                    .collect(Collectors.toSet());\n-        }\n-        return Collections.emptySet();\n-    }\n-\n-    void checkValidStatusForDeletion(File file, List<String> expectedStatus) throws CatalogException {\n-        if (file.getInternal().getStatus() == null) {\n-            throw new CatalogException(\"Cannot check file status for deletion\");\n-        }\n-        for (String status : expectedStatus) {\n-            if (status.equals(file.getInternal().getStatus().getName())) {\n-                // Valid status\n-                return;\n-            }\n-        }\n-        throw new CatalogException(\"Cannot delete file: \" + file.getName() + \". The status is \" + file.getInternal().getStatus().getName());\n-    }\n-\n-    public DataResult<FacetField> facet(String studyId, Query query, QueryOptions options, boolean defaultStats, String token)\n-            throws CatalogException, IOException {\n-        ParamUtils.defaultObject(query, Query::new);\n-        ParamUtils.defaultObject(options, QueryOptions::new);\n-\n-        String userId = userManager.getUserId(token);\n-        // We need to add variableSets and groups to avoid additional queries as it will be used in the catalogSolrManager\n-        Study study = studyManager.resolveId(studyId, userId, new QueryOptions(QueryOptions.INCLUDE,\n-                Arrays.asList(StudyDBAdaptor.QueryParams.VARIABLE_SET.key(), StudyDBAdaptor.QueryParams.GROUPS.key())));\n-\n-        ObjectMap auditParams = new ObjectMap()\n-                .append(\"studyId\", studyId)\n-                .append(\"query\", new Query(query))\n-                .append(\"options\", options)\n-                .append(\"defaultStats\", defaultStats)\n-                .append(\"token\", token);\n-        try {\n-            if (defaultStats || StringUtils.isEmpty(options.getString(QueryOptions.FACET))) {\n-                String facet = options.getString(QueryOptions.FACET);\n-                options.put(QueryOptions.FACET, StringUtils.isNotEmpty(facet) ? defaultFacet + \";\" + facet : defaultFacet);\n-            }\n-\n-            AnnotationUtils.fixQueryAnnotationSearch(study, userId, query, authorizationManager);\n-\n-            try (CatalogSolrManager catalogSolrManager = new CatalogSolrManager(catalogManager)) {\n-                DataResult<FacetField> result = catalogSolrManager.facetedQuery(study, CatalogSolrManager.FILE_SOLR_COLLECTION, query,\n-                        options, userId);\n-                auditManager.auditFacet(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n-                        new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS));\n-\n-                return result;\n-            }\n-        } catch (CatalogException e) {\n-            auditManager.auditFacet(userId, Enums.Resource.FILE, study.getId(), study.getUuid(), auditParams,\n-                    new AuditRecord.Status(AuditRecord.Status.Result.ERROR, new Error(0, \"\", e.getMessage())));\n-            throw e;\n-        }\n-    }\n-\n-    /**\n-     * Create the parent directories that are needed.\n-     *\n-     * @param study            study where they will be created.\n-     * @param userId           user that is creating the parents.\n-     * @param studyURI         Base URI where the created folders will be pointing to. (base physical location)\n-     * @param path             Path used in catalog as a virtual location. (whole bunch of directories inside the virtual\n-     *                         location in catalog)\n-     * @param checkPermissions Boolean indicating whether to check if the user has permissions to create a folder in the first directory\n-     *                         that is available in catalog.\n-     * @throws CatalogDBException\n-     */\n-    private void createParents(Study study, String userId, URI studyURI, Path path, boolean checkPermissions) throws CatalogException {\n-        if (path == null) {\n-            if (checkPermissions) {\n-                authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_FILES);\n-            }\n-            return;\n-        }\n-\n-        String stringPath = path.toString();\n-        if ((\"/\").equals(stringPath)) {\n-            return;\n-        }\n-\n-        logger.debug(\"Path: {}\", stringPath);\n-\n-        if (stringPath.startsWith(\"/\")) {\n-            stringPath = stringPath.substring(1);\n-        }\n-\n-        if (!stringPath.endsWith(\"/\")) {\n-            stringPath = stringPath + \"/\";\n-        }\n-\n-        // Check if the folder exists\n-        Query query = new Query()\n-                .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                .append(FileDBAdaptor.QueryParams.PATH.key(), stringPath);\n-\n-        if (fileDBAdaptor.count(query).getNumMatches() == 0) {\n-            createParents(study, userId, studyURI, path.getParent(), checkPermissions);\n-        } else {\n-            if (checkPermissions) {\n-                long fileId = fileDBAdaptor.getId(study.getUid(), stringPath);\n-                authorizationManager.checkFilePermission(study.getUid(), fileId, userId, FileAclEntry.FilePermissions.WRITE);\n-            }\n-            return;\n-        }\n-\n-        String parentPath = getParentPath(stringPath);\n-        long parentFileId = fileDBAdaptor.getId(study.getUid(), parentPath);\n-        // We obtain the permissions set in the parent folder and set them to the file or folder being created\n-        OpenCGAResult<Map<String, List<String>>> allFileAcls = authorizationManager.getAllFileAcls(study.getUid(), parentFileId, userId,\n-                checkPermissions);\n-\n-        URI completeURI = Paths.get(studyURI).resolve(path).toUri();\n-\n-        // Create the folder in catalog\n-        File folder = new File(path.getFileName().toString(), File.Type.DIRECTORY, File.Format.PLAIN, File.Bioformat.NONE, completeURI,\n-                stringPath, null, TimeUtils.getTime(), TimeUtils.getTime(), \"\", false, 0, null, new FileExperiment(),\n-                Collections.emptyList(), Collections.emptyList(), \"\", studyManager.getCurrentRelease(study), Collections.emptyList(), null,\n-                new CustomStatus(), FileInternal.initialize(), null);\n-        folder.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n-        checkHooks(folder, study.getFqn(), HookConfiguration.Stage.CREATE);\n-        fileDBAdaptor.insert(study.getUid(), folder, Collections.emptyList(), Collections.emptyList(), Collections.emptyList(),\n-                new QueryOptions());\n-        OpenCGAResult<File> queryResult = getFile(study.getUid(), folder.getUuid(), QueryOptions.empty());\n-        // Propagate ACLs\n-        if (allFileAcls != null && allFileAcls.getNumResults() > 0) {\n-            authorizationManager.replicateAcls(study.getUid(), Arrays.asList(queryResult.first().getUid()), allFileAcls.getResults().get(0),\n-                    Enums.Resource.FILE);\n-        }\n-    }\n-\n-    private OpenCGAResult<File> privateLink(Study study, FileLinkParams params, boolean parents, String token)\n-            throws CatalogException {\n-        ParamUtils.checkObj(params, \"FileLinkParams\");\n-        ParamUtils.checkParameter(params.getUri(), \"uri\");\n-        URI uriOrigin;\n-        try {\n-            uriOrigin = UriUtils.createUri(params.getUri());\n-        } catch (URISyntaxException e) {\n-            throw new CatalogException(e.getMessage(), e);\n-        }\n-\n-        IOManager ioManager;\n-        try {\n-            ioManager = ioManagerFactory.get(uriOrigin);\n-        } catch (IOException e) {\n-            throw CatalogIOException.ioManagerException(uriOrigin, e);\n-        }\n-        if (!ioManager.exists(uriOrigin)) {\n-            throw new CatalogIOException(\"File \" + uriOrigin + \" does not exist\");\n-        }\n-\n-        final URI normalizedUri;\n-        try {\n-            normalizedUri = UriUtils.createUri(uriOrigin.normalize().getPath());\n-        } catch (URISyntaxException e) {\n-            throw new CatalogException(e);\n-        }\n-\n-        String userId = userManager.getUserId(token);\n-        authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_FILES);\n-\n-        params.setPath(ParamUtils.defaultString(params.getPath(), \"\"));\n-        if (params.getPath().length() == 1 && (params.getPath().equals(\".\") || params.getPath().equals(\"/\"))) {\n-            params.setPath(\"\");\n-        } else {\n-            if (params.getPath().startsWith(\"/\")) {\n-                params.setPath(params.getPath().substring(1));\n-            }\n-            if (!params.getPath().isEmpty() && !params.getPath().endsWith(\"/\")) {\n-                params.setPath(params.getPath() + \"/\");\n-            }\n-        }\n-        String externalPathDestinyStr;\n-        if (Paths.get(normalizedUri).toFile().isDirectory()) {\n-            externalPathDestinyStr = Paths.get(params.getPath()).resolve(Paths.get(normalizedUri).getFileName()).toString() + \"/\";\n-        } else {\n-            externalPathDestinyStr = Paths.get(params.getPath()).resolve(Paths.get(normalizedUri).getFileName()).toString();\n-        }\n-\n-        // Check if the path already exists and is not external\n-        Query query = new Query()\n-                .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                .append(FileDBAdaptor.QueryParams.PATH.key(), externalPathDestinyStr)\n-                .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), false);\n-        if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n-            throw new CatalogException(\"Cannot link to \" + externalPathDestinyStr + \". The path already existed and is not external.\");\n-        }\n-\n-        // Check if the uri was already linked to that same path\n-        query = new Query()\n-                .append(FileDBAdaptor.QueryParams.URI.key(), normalizedUri)\n-                .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                .append(FileDBAdaptor.QueryParams.PATH.key(), externalPathDestinyStr)\n-                .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), true);\n-\n-\n-        if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n-            // Create a regular expression on URI to return everything linked from that URI\n-            query.put(FileDBAdaptor.QueryParams.URI.key(), \"~^\" + normalizedUri);\n-            query.remove(FileDBAdaptor.QueryParams.PATH.key());\n-\n-            // Limit the number of results and only some fields\n-            QueryOptions queryOptions = new QueryOptions()\n-                    .append(QueryOptions.LIMIT, 100);\n-\n-            return fileDBAdaptor.get(query, queryOptions)\n-                    .addEvent(new Event(Event.Type.INFO, ParamConstants.FILE_ALREADY_LINKED));\n-        }\n-\n-        // Check if the uri was linked to other path\n-        query = new Query()\n-                .append(FileDBAdaptor.QueryParams.URI.key(), normalizedUri)\n-                .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), true);\n-        if (fileDBAdaptor.count(query).getNumMatches() > 0) {\n-            QueryOptions queryOptions = new QueryOptions(QueryOptions.INCLUDE, FileDBAdaptor.QueryParams.PATH.key());\n-            String path = fileDBAdaptor.get(query, queryOptions).first().getPath();\n-            throw new CatalogException(normalizedUri + \" was already linked to other path: \" + path);\n-        }\n-\n-//         FIXME: Implement resync\n-//        boolean resync = params.getBoolean(\"resync\", false);\n-//        String checksum = params.getString(FileDBAdaptor.QueryParams.CHECKSUM.key(), \"\");\n-\n-        final List<FileRelatedFile> relatedFiles = params.getRelatedFiles();\n-        if (relatedFiles != null) {\n-            for (FileRelatedFile relatedFile : relatedFiles) {\n-                File tmpFile = internalGet(study.getUid(), relatedFile.getFile().getId(), INCLUDE_FILE_URI_PATH, userId).first();\n-                relatedFile.setFile(tmpFile);\n+          } else if (filterWhere.startsWith(FileDBAdaptor.QueryParams.ATTRIBUTES.key())) {\n+            String[] split = StringUtils.split(filterWhere, \".\", 2);\n+            String attributesField = null;\n+            if (split.length == 2) {\n+              attributesField = split[1];\n             }\n-        }\n \n-        // Because pathDestiny can be null, we will use catalogPath as the virtual destiny where the files will be located in catalog.\n-        Path catalogPath = Paths.get(params.getPath());\n+            switch (hookConfiguration.getAction()) {\n+              case ADD:\n+                if (attributesField == null) {\n+                  logger.error(\"Cannot add a value to {} directly. Expected {}.<subfield>\",\n+                      FileDBAdaptor.QueryParams.ATTRIBUTES.key(), FileDBAdaptor.QueryParams.ATTRIBUTES.key());\n+                  continue;\n+                }\n \n-        if (params.getPath().isEmpty()) {\n-            // If no destiny is given, everything will be linked to the root folder of the study.\n-            authorizationManager.checkStudyPermission(study.getUid(), userId, StudyAclEntry.StudyPermissions.WRITE_FILES);\n-        } else {\n-            // Check if the folder exists\n-            query = new Query()\n-                    .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                    .append(FileDBAdaptor.QueryParams.PATH.key(), params.getPath());\n-            if (fileDBAdaptor.count(query).getNumMatches() == 0) {\n-                if (parents) {\n-                    // Get the base URI where the files are located in the study\n-                    URI studyURI = study.getUri();\n-                    createParents(study, userId, studyURI, catalogPath, true);\n-                    // Create them in the disk\n-//                    URI directory = Paths.get(studyURI).resolve(catalogPath).toUri();\n-//                    catalogIOManagerFactory.get(directory).createDirectory(directory, true);\n+                List<String> values;\n+                if (hookConfiguration.getWhat().contains(\",\")) {\n+                  values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n                 } else {\n-                    throw new CatalogException(\"The path \" + catalogPath + \" does not exist in catalog.\");\n+                  values = Collections.singletonList(hookConfiguration.getWhat());\n                 }\n-            } else {\n-                // Check if the user has permissions to link files in the directory\n-                long fileId = fileDBAdaptor.getId(study.getUid(), params.getPath());\n-                authorizationManager.checkFilePermission(study.getUid(), fileId, userId, FileAclEntry.FilePermissions.WRITE);\n-            }\n-        }\n \n-        // This list will contain the list of transformed files detected during the link\n-        List<File> transformedFiles = new ArrayList<>();\n-\n-        // We remove the / at the end for replacement purposes in the walkFileTree\n-        if (externalPathDestinyStr.endsWith(\"/\")) {\n-            externalPathDestinyStr = externalPathDestinyStr.substring(0, externalPathDestinyStr.length() - 1);\n-        }\n-        String finalExternalPathDestinyStr = externalPathDestinyStr;\n-\n-        // Link all the files and folders present in the uri\n-        ioManager.walkFileTree(normalizedUri, new SimpleFileVisitor<URI>() {\n-            @Override\n-            public FileVisitResult preVisitDirectory(URI dir, BasicFileAttributes attrs) throws IOException {\n-                try {\n-                    String destinyPath = Paths.get(dir).toString().replace(Paths.get(normalizedUri).toString(),\n-                            finalExternalPathDestinyStr);\n-\n-                    if (!destinyPath.isEmpty() && !destinyPath.endsWith(\"/\")) {\n-                        destinyPath += \"/\";\n-                    }\n-\n-                    if (destinyPath.startsWith(\"/\")) {\n-                        destinyPath = destinyPath.substring(1);\n-                    }\n-\n-                    Query query = new Query()\n-                            .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                            .append(FileDBAdaptor.QueryParams.PATH.key(), destinyPath);\n-\n-                    if (fileDBAdaptor.count(query).getNumMatches() == 0) {\n-                        // If the folder does not exist, we create it\n-\n-                        String parentPath = getParentPath(destinyPath);\n-                        long parentFileId = fileDBAdaptor.getId(study.getUid(), parentPath);\n-                        // We obtain the permissions set in the parent folder and set them to the file or folder being created\n-                        OpenCGAResult<Map<String, List<String>>> allFileAcls;\n-                        try {\n-                            allFileAcls = authorizationManager.getAllFileAcls(study.getUid(), parentFileId, userId, true);\n-                        } catch (CatalogException e) {\n-                            throw new RuntimeException(e);\n-                        }\n-\n-                        File folder = new File(Paths.get(dir).getFileName().toString(), File.Type.DIRECTORY, File.Format.PLAIN,\n-                                File.Bioformat.NONE, dir, destinyPath, null, TimeUtils.getTime(),\n-                                TimeUtils.getTime(), params.getDescription(), true, 0, new Software(), new FileExperiment(),\n-                                Collections.emptyList(), relatedFiles, \"\", studyManager.getCurrentRelease(study), Collections.emptyList(),\n-                                Collections.emptyMap(),\n-                                params.getStatus() != null ? params.getStatus().toCustomStatus() : new CustomStatus(),\n-                                FileInternal.initialize(), Collections.emptyMap());\n-                        folder.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n-                        checkHooks(folder, study.getFqn(), HookConfiguration.Stage.CREATE);\n-                        fileDBAdaptor.insert(study.getUid(), folder, Collections.emptyList(), Collections.emptyList(),\n-                                Collections.emptyList(), new QueryOptions());\n-                        OpenCGAResult<File> queryResult = getFile(study.getUid(), folder.getUuid(), QueryOptions.empty());\n-\n-                        // Propagate ACLs\n-                        if (allFileAcls != null && allFileAcls.getNumResults() > 0) {\n-                            authorizationManager.replicateAcls(study.getUid(), Arrays.asList(queryResult.first().getUid()),\n-                                    allFileAcls.getResults().get(0), Enums.Resource.FILE);\n-                        }\n-                    }\n-\n-                } catch (CatalogException e) {\n-                    logger.error(\"An error occurred when trying to create folder {}\", dir.toString());\n+                Object currentStatsValue = file.getAttributes().get(attributesField);\n+                if (currentStatsValue == null) {\n+                  file.getAttributes().put(attributesField, values);\n+                } else if (currentStatsValue instanceof Collection) {\n+                  ((List) currentStatsValue).addAll(values);\n+                } else {\n+                  logger.error(\"Cannot add a value to {} if it is not an array\", filterWhere);\n+                  continue;\n                 }\n-\n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult visitFile(URI fileUri, BasicFileAttributes attrs) throws IOException {\n-                try {\n-                    String destinyPath = Paths.get(fileUri).toString().replace(Paths.get(normalizedUri).toString(),\n-                            finalExternalPathDestinyStr);\n-\n-                    if (destinyPath.startsWith(\"/\")) {\n-                        destinyPath = destinyPath.substring(1);\n-                    }\n-\n-                    Query query = new Query()\n-                            .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                            .append(FileDBAdaptor.QueryParams.PATH.key(), destinyPath);\n-\n-                    if (fileDBAdaptor.count(query).getNumMatches() == 0) {\n-                        long size = ioManager.getFileSize(fileUri);\n-                        // If the file does not exist, we create it\n-                        String parentPath = getParentPath(destinyPath);\n-                        long parentFileId = fileDBAdaptor.getId(study.getUid(), parentPath);\n-                        // We obtain the permissions set in the parent folder and set them to the file or folder being created\n-                        OpenCGAResult<Map<String, List<String>>> allFileAcls;\n-                        try {\n-                            allFileAcls = authorizationManager.getAllFileAcls(study.getUid(), parentFileId, userId, true);\n-                        } catch (CatalogException e) {\n-                            throw new RuntimeException(e);\n-                        }\n-\n-                        FileInternal internal = FileInternal.initialize();\n-                        if (params.getInternal() != null) {\n-                            internal.setSampleMap(params.getInternal().getSampleMap());\n-                        }\n-\n-                        File subfile = new File(Paths.get(fileUri).getFileName().toString(), File.Type.FILE, File.Format.UNKNOWN,\n-                                File.Bioformat.NONE, fileUri, destinyPath, null, TimeUtils.getTime(),\n-                                TimeUtils.getTime(), params.getDescription(), true, size, new Software(), new FileExperiment(),\n-                                Collections.emptyList(), relatedFiles, \"\", studyManager.getCurrentRelease(study), Collections.emptyList(),\n-                                Collections.emptyMap(),\n-                                params.getStatus() != null ? params.getStatus().toCustomStatus() : new CustomStatus(), internal,\n-                                new HashMap<>());\n-                        subfile.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n-                        checkHooks(subfile, study.getFqn(), HookConfiguration.Stage.CREATE);\n-\n-                        // Improve metadata information and extract samples if any\n-                        new FileMetadataReader(catalogManager).addMetadataInformation(study.getFqn(), subfile);\n-\n-                        List<Sample> existingSamples = new LinkedList<>();\n-                        List<Sample> nonExistingSamples = new LinkedList<>();\n-                        validateNewSamples(study, subfile, existingSamples, nonExistingSamples, token);\n-\n-                        fileDBAdaptor.insert(study.getUid(), subfile, existingSamples, nonExistingSamples, Collections.emptyList(),\n-                                new QueryOptions());\n-                        subfile = getFile(study.getUid(), subfile.getUuid(), QueryOptions.empty()).first();\n-\n-                        // Propagate ACLs\n-                        if (allFileAcls != null && allFileAcls.getNumResults() > 0) {\n-                            authorizationManager.replicateAcls(study.getUid(), Arrays.asList(subfile.getUid()),\n-                                    allFileAcls.getResults().get(0), Enums.Resource.FILE);\n-                        }\n-\n-                        if (isTransformedFile(subfile.getName())) {\n-                            logger.info(\"Detected transformed file {}\", subfile.getPath());\n-                            transformedFiles.add(subfile);\n-                        }\n-                    } else {\n-                        throw new CatalogException(\"Cannot link the file \" + Paths.get(fileUri).getFileName().toString()\n-                                + \". There is already a file in the path \" + destinyPath + \" with the same name.\");\n-                    }\n-\n-                } catch (CatalogException e) {\n-                    logger.error(e.getMessage());\n+                break;\n+              case SET:\n+                if (attributesField == null) {\n+                  logger.error(\"Cannot set a value to {} directly. Expected {}.<subfield>\",\n+                      FileDBAdaptor.QueryParams.ATTRIBUTES.key(), FileDBAdaptor.QueryParams.ATTRIBUTES.key());\n+                  continue;\n                 }\n \n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult visitFileFailed(URI file, IOException exc) throws IOException {\n-                return FileVisitResult.SKIP_SUBTREE;\n-            }\n-\n-            @Override\n-            public FileVisitResult postVisitDirectory(URI dir, IOException exc) throws IOException {\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n-\n-        // Try to link transformed files with their corresponding original files if any\n-        try {\n-            if (transformedFiles.size() > 0) {\n-                matchUpVariantFiles(study.getFqn(), transformedFiles, token);\n-            }\n-        } catch (CatalogException e) {\n-            logger.warn(\"Matching avro to variant file: {}\", e.getMessage());\n-        }\n-\n-        // Check if the uri was already linked to that same path\n-        query = new Query()\n-                .append(FileDBAdaptor.QueryParams.URI.key(), \"~^\" + normalizedUri)\n-                .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), study.getUid())\n-                .append(FileDBAdaptor.QueryParams.EXTERNAL.key(), true);\n-\n-        // Limit the number of results and only some fields\n-        QueryOptions queryOptions = new QueryOptions()\n-                .append(QueryOptions.LIMIT, 100);\n-        return fileDBAdaptor.get(query, queryOptions);\n-    }\n-\n-    OpenCGAResult<File> registerFile(Study study, String filePath, URI fileUri, String jobId, String token) throws CatalogException {\n-        String userId = userManager.getUserId(token);\n-        IOManager ioManager;\n-        try {\n-            ioManager = ioManagerFactory.get(fileUri);\n-        } catch (IOException e) {\n-            throw CatalogIOException.ioManagerException(fileUri, e);\n-        }\n-\n-        // The file is not registered in Catalog, so we will register it\n-        long size = ioManager.getFileSize(fileUri);\n-\n-        String parentPath = getParentPath(filePath);\n-        File parentFile = internalGet(study.getUid(), parentPath, INCLUDE_FILE_URI_PATH, userId).first();\n-        // We obtain the permissions set in the parent folder and set them to the file or folder being created\n-        OpenCGAResult<Map<String, List<String>>> allFileAcls = authorizationManager.getAllFileAcls(study.getUid(),\n-                parentFile.getUid(), userId, true);\n-\n-        File subfile = new File(Paths.get(filePath).getFileName().toString(), File.Type.FILE, File.Format.UNKNOWN,\n-                File.Bioformat.NONE, fileUri, filePath, \"\", TimeUtils.getTime(), TimeUtils.getTime(),\n-                \"\", isExternal(study, filePath, fileUri), size, new Software(), new FileExperiment(), Collections.emptyList(),\n-                Collections.emptyList(), jobId, studyManager.getCurrentRelease(study), Collections.emptyList(), Collections.emptyMap(),\n-                new CustomStatus(), FileInternal.initialize(), Collections.emptyMap());\n-        subfile.setUuid(UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.FILE));\n-        checkHooks(subfile, study.getFqn(), HookConfiguration.Stage.CREATE);\n-\n-        // Improve metadata information and extract samples if any\n-        new FileMetadataReader(catalogManager).addMetadataInformation(study.getFqn(), subfile);\n-        List<Sample> existingSamples = new LinkedList<>();\n-        List<Sample> nonExistingSamples = new LinkedList<>();\n-        validateNewSamples(study, subfile, existingSamples, nonExistingSamples, token);\n-\n-        fileDBAdaptor.insert(study.getUid(), subfile, existingSamples, nonExistingSamples, Collections.emptyList(), new QueryOptions());\n-        OpenCGAResult<File> result = getFile(study.getUid(), subfile.getUuid(), QueryOptions.empty());\n-        subfile = result.first();\n-\n-        // Propagate ACLs\n-        if (allFileAcls != null && allFileAcls.getNumResults() > 0) {\n-            authorizationManager.replicateAcls(study.getUid(), Arrays.asList(subfile.getUid()), allFileAcls.getResults().get(0),\n-                    Enums.Resource.FILE);\n-        }\n-\n-        // If it is a transformed file, we will try to link it with the correspondent original file\n-        try {\n-            if (isTransformedFile(subfile.getName())) {\n-                matchUpVariantFiles(study.getFqn(), Arrays.asList(subfile), token);\n+                if (hookConfiguration.getWhat().contains(\",\")) {\n+                  values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n+                } else {\n+                  values = Collections.singletonList(hookConfiguration.getWhat());\n+                }\n+                file.getAttributes().put(attributesField, values);\n+                break;\n+              case REMOVE:\n+                if (attributesField == null) {\n+                  file.setAttributes(Collections.emptyMap());\n+                } else {\n+                  file.getAttributes().remove(attributesField);\n+                }\n+                break;\n+              default:\n+                break;\n             }\n-        } catch (CatalogException e1) {\n-            logger.warn(\"Matching avro to variant file: {}\", e1.getMessage());\n+          } else {\n+            logger.error(\"{} field cannot be updated. Please, check the hook configured.\", hookConfiguration.getWhere());\n+          }\n         }\n-\n-        return result;\n+      }\n     }\n+  }\n \n-    private void checkHooks(File file, String fqn, HookConfiguration.Stage stage) throws CatalogException {\n+  private URI getStudyUri(long studyId) throws CatalogException {\n+    return studyDBAdaptor.get(studyId, INCLUDE_STUDY_URI).first().getUri();\n+  }\n \n-        Map<String, Map<String, List<HookConfiguration>>> hooks = this.configuration.getHooks();\n-        if (hooks != null && hooks.containsKey(fqn)) {\n-            Map<String, List<HookConfiguration>> entityHookMap = hooks.get(fqn);\n-            List<HookConfiguration> hookList = null;\n-            if (entityHookMap.containsKey(MongoDBAdaptorFactory.FILE_COLLECTION)) {\n-                hookList = entityHookMap.get(MongoDBAdaptorFactory.FILE_COLLECTION);\n-            } else if (entityHookMap.containsKey(MongoDBAdaptorFactory.FILE_COLLECTION.toUpperCase())) {\n-                hookList = entityHookMap.get(MongoDBAdaptorFactory.FILE_COLLECTION.toUpperCase());\n-            }\n-\n-            // We check the hook list\n-            if (hookList != null) {\n-                for (HookConfiguration hookConfiguration : hookList) {\n-                    if (hookConfiguration.getStage() != stage) {\n-                        continue;\n-                    }\n-\n-                    String field = hookConfiguration.getField();\n-                    if (StringUtils.isEmpty(field)) {\n-                        logger.warn(\"Missing 'field' field from hook configuration\");\n-                        continue;\n-                    }\n-                    field = field.toLowerCase();\n-\n-                    String filterValue = hookConfiguration.getValue();\n-                    if (StringUtils.isEmpty(filterValue)) {\n-                        logger.warn(\"Missing 'value' field from hook configuration\");\n-                        continue;\n-                    }\n-\n-                    String value = null;\n-                    switch (field) {\n-                        case \"name\":\n-                            value = file.getName();\n-                            break;\n-                        case \"format\":\n-                            value = file.getFormat().name();\n-                            break;\n-                        case \"bioformat\":\n-                            value = file.getFormat().name();\n-                            break;\n-                        case \"path\":\n-                            value = file.getPath();\n-                            break;\n-                        case \"description\":\n-                            value = file.getDescription();\n-                            break;\n-                        // TODO: At some point, we will also have to consider any field that is not a String\n-//                        case \"size\":\n-//                            value = file.getSize();\n-//                            break;\n-                        default:\n-                            break;\n-                    }\n-                    if (value == null) {\n-                        continue;\n-                    }\n-\n-                    String filterNewValue = hookConfiguration.getWhat();\n-                    if (StringUtils.isEmpty(filterNewValue)) {\n-                        logger.warn(\"Missing 'what' field from hook configuration\");\n-                        continue;\n-                    }\n-\n-                    String filterWhere = hookConfiguration.getWhere();\n-                    if (StringUtils.isEmpty(filterWhere)) {\n-                        logger.warn(\"Missing 'where' field from hook configuration\");\n-                        continue;\n-                    }\n-                    filterWhere = filterWhere.toLowerCase();\n-\n-\n-                    if (filterValue.startsWith(\"~\")) {\n-                        // Regular expression\n-                        if (!value.matches(filterValue.substring(1))) {\n-                            // If it doesn't match, we will check the next hook of the loop\n-                            continue;\n-                        }\n-                    } else {\n-                        if (!value.equals(filterValue)) {\n-                            // If it doesn't match, we will check the next hook of the loop\n-                            continue;\n-                        }\n-                    }\n-\n-                    // The value matched, so we will perform the action desired by the user\n-                    if (hookConfiguration.getAction() == HookConfiguration.Action.ABORT) {\n-                        throw new CatalogException(\"A hook to abort the insertion matched\");\n-                    }\n-\n-                    // We check the field the user wants to update\n-                    if (filterWhere.equals(FileDBAdaptor.QueryParams.DESCRIPTION.key())) {\n-                        switch (hookConfiguration.getAction()) {\n-                            case ADD:\n-                            case SET:\n-                                file.setDescription(hookConfiguration.getWhat());\n-                                break;\n-                            case REMOVE:\n-                                file.setDescription(\"\");\n-                                break;\n-                            default:\n-                                break;\n-                        }\n-                    } else if (filterWhere.equals(FileDBAdaptor.QueryParams.TAGS.key())) {\n-                        switch (hookConfiguration.getAction()) {\n-                            case ADD:\n-                                List<String> values;\n-                                if (hookConfiguration.getWhat().contains(\",\")) {\n-                                    values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n-                                } else {\n-                                    values = Collections.singletonList(hookConfiguration.getWhat());\n-                                }\n-                                List<String> tagsCopy = new ArrayList<>();\n-                                if (file.getTags() != null) {\n-                                    tagsCopy.addAll(file.getTags());\n-                                }\n-                                tagsCopy.addAll(values);\n-                                file.setTags(tagsCopy);\n-                                break;\n-                            case SET:\n-                                if (hookConfiguration.getWhat().contains(\",\")) {\n-                                    values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n-                                } else {\n-                                    values = Collections.singletonList(hookConfiguration.getWhat());\n-                                }\n-                                file.setTags(values);\n-                                break;\n-                            case REMOVE:\n-                                file.setTags(Collections.emptyList());\n-                                break;\n-                            default:\n-                                break;\n-                        }\n-                    } else if (filterWhere.startsWith(FileDBAdaptor.QueryParams.STATS.key())) {\n-                        String[] split = StringUtils.split(filterWhere, \".\", 2);\n-                        String statsField = null;\n-                        if (split.length == 2) {\n-                            statsField = split[1];\n-                        }\n-\n-                        switch (hookConfiguration.getAction()) {\n-                            case ADD:\n-                                if (statsField == null) {\n-                                    logger.error(\"Cannot add a value to {} directly. Expected {}.<subfield>\",\n-                                            FileDBAdaptor.QueryParams.STATS.key(), FileDBAdaptor.QueryParams.STATS.key());\n-                                    continue;\n-                                }\n-\n-                                List<String> values;\n-                                if (hookConfiguration.getWhat().contains(\",\")) {\n-                                    values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n-                                } else {\n-                                    values = Collections.singletonList(hookConfiguration.getWhat());\n-                                }\n-\n-                                Object currentStatsValue = file.getStats().get(statsField);\n-                                if (currentStatsValue == null) {\n-                                    file.getStats().put(statsField, values);\n-                                } else if (currentStatsValue instanceof Collection) {\n-                                    ((List) currentStatsValue).addAll(values);\n-                                } else {\n-                                    logger.error(\"Cannot add a value to {} if it is not an array\", filterWhere);\n-                                    continue;\n-                                }\n-\n-                                break;\n-                            case SET:\n-                                if (statsField == null) {\n-                                    logger.error(\"Cannot set a value to {} directly. Expected {}.<subfield>\",\n-                                            FileDBAdaptor.QueryParams.STATS.key(), FileDBAdaptor.QueryParams.STATS.key());\n-                                    continue;\n-                                }\n-\n-                                if (hookConfiguration.getWhat().contains(\",\")) {\n-                                    values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n-                                } else {\n-                                    values = Collections.singletonList(hookConfiguration.getWhat());\n-                                }\n-                                file.getStats().put(statsField, values);\n-                                break;\n-                            case REMOVE:\n-                                if (statsField == null) {\n-                                    file.setStats(Collections.emptyMap());\n-                                } else {\n-                                    file.getStats().remove(statsField);\n-                                }\n-                                break;\n-                            default:\n-                                break;\n-                        }\n-                    } else if (filterWhere.startsWith(FileDBAdaptor.QueryParams.ATTRIBUTES.key())) {\n-                        String[] split = StringUtils.split(filterWhere, \".\", 2);\n-                        String attributesField = null;\n-                        if (split.length == 2) {\n-                            attributesField = split[1];\n-                        }\n-\n-                        switch (hookConfiguration.getAction()) {\n-                            case ADD:\n-                                if (attributesField == null) {\n-                                    logger.error(\"Cannot add a value to {} directly. Expected {}.<subfield>\",\n-                                            FileDBAdaptor.QueryParams.ATTRIBUTES.key(), FileDBAdaptor.QueryParams.ATTRIBUTES.key());\n-                                    continue;\n-                                }\n-\n-                                List<String> values;\n-                                if (hookConfiguration.getWhat().contains(\",\")) {\n-                                    values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n-                                } else {\n-                                    values = Collections.singletonList(hookConfiguration.getWhat());\n-                                }\n-\n-                                Object currentStatsValue = file.getAttributes().get(attributesField);\n-                                if (currentStatsValue == null) {\n-                                    file.getAttributes().put(attributesField, values);\n-                                } else if (currentStatsValue instanceof Collection) {\n-                                    ((List) currentStatsValue).addAll(values);\n-                                } else {\n-                                    logger.error(\"Cannot add a value to {} if it is not an array\", filterWhere);\n-                                    continue;\n-                                }\n-                                break;\n-                            case SET:\n-                                if (attributesField == null) {\n-                                    logger.error(\"Cannot set a value to {} directly. Expected {}.<subfield>\",\n-                                            FileDBAdaptor.QueryParams.ATTRIBUTES.key(), FileDBAdaptor.QueryParams.ATTRIBUTES.key());\n-                                    continue;\n-                                }\n-\n-                                if (hookConfiguration.getWhat().contains(\",\")) {\n-                                    values = Arrays.asList(hookConfiguration.getWhat().split(\",\"));\n-                                } else {\n-                                    values = Collections.singletonList(hookConfiguration.getWhat());\n-                                }\n-                                file.getAttributes().put(attributesField, values);\n-                                break;\n-                            case REMOVE:\n-                                if (attributesField == null) {\n-                                    file.setAttributes(Collections.emptyMap());\n-                                } else {\n-                                    file.getAttributes().remove(attributesField);\n-                                }\n-                                break;\n-                            default:\n-                                break;\n-                        }\n-                    } else {\n-                        logger.error(\"{} field cannot be updated. Please, check the hook configured.\", hookConfiguration.getWhere());\n-                    }\n-                }\n-            }\n-        }\n-    }\n+  private enum CheckPath {\n+    FREE_PATH, FILE_EXISTS, DIRECTORY_EXISTS\n+  }\n \n-    private URI getStudyUri(long studyId) throws CatalogException {\n-        return studyDBAdaptor.get(studyId, INCLUDE_STUDY_URI).first().getUri();\n+  private CheckPath checkPathExists(String path, long studyId) throws CatalogException {\n+    String myPath = path;\n+    if (myPath.endsWith(\"/\")) {\n+      myPath = myPath.substring(0, myPath.length() - 1);\n     }\n \n-    private enum CheckPath {\n-        FREE_PATH, FILE_EXISTS, DIRECTORY_EXISTS\n+    // We first look for any file called the same way the directory needs to be called\n+    Query query = new Query()\n+        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyId)\n+        .append(FileDBAdaptor.QueryParams.PATH.key(), myPath);\n+    OpenCGAResult<Long> fileDataResult = fileDBAdaptor.count(query);\n+    if (fileDataResult.getNumMatches() > 0) {\n+      return CheckPath.FILE_EXISTS;\n     }\n \n-    private CheckPath checkPathExists(String path, long studyId) throws CatalogException {\n-        String myPath = path;\n-        if (myPath.endsWith(\"/\")) {\n-            myPath = myPath.substring(0, myPath.length() - 1);\n-        }\n-\n-        // We first look for any file called the same way the directory needs to be called\n-        Query query = new Query()\n-                .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyId)\n-                .append(FileDBAdaptor.QueryParams.PATH.key(), myPath);\n-        OpenCGAResult<Long> fileDataResult = fileDBAdaptor.count(query);\n-        if (fileDataResult.getNumMatches() > 0) {\n-            return CheckPath.FILE_EXISTS;\n-        }\n-\n-        query = new Query()\n-                .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyId)\n-                .append(FileDBAdaptor.QueryParams.PATH.key(), myPath + \"/\");\n-        fileDataResult = fileDBAdaptor.count(query);\n+    query = new Query()\n+        .append(FileDBAdaptor.QueryParams.STUDY_UID.key(), studyId)\n+        .append(FileDBAdaptor.QueryParams.PATH.key(), myPath + \"/\");\n+    fileDataResult = fileDBAdaptor.count(query);\n \n-        return fileDataResult.getNumMatches() > 0 ? CheckPath.DIRECTORY_EXISTS : CheckPath.FREE_PATH;\n-    }\n+    return fileDataResult.getNumMatches() > 0 ? CheckPath.DIRECTORY_EXISTS : CheckPath.FREE_PATH;\n+  }\n }\n",
            "diff_size": 6219
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "145",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 148).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "145",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 148).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}