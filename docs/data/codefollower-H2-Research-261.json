{
    "project_name": "codefollower-H2-Research",
    "error_id": "261",
    "information": {
        "errors": [
            {
                "line": "260",
                "column": "17",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "                    // select * from (select * from test)\n                    // where a=1 and b in(10, 20);\n                \t\n                \t//\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n                \t//\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n                \t//\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "261",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/261/IndexCondition.java\nindex 532d440f5ec..ed8572e780e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/261/IndexCondition.java\n@@ -257,10 +257,10 @@ public class IndexCondition {\n                     // insert into test values(1, 10), (2, 20);\n                     // select * from (select * from test)\n                     // where a=1 and b in(10, 20);\n-                \t\n-                \t//\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n-                \t//\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n-                \t//\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n                     return 0;\n                 }\n             }\n",
            "diff_size": 4
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/261/IndexCondition.java\nindex 532d440f5ec..60818ff0447 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/261/IndexCondition.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import java.util.ArrayList;\n@@ -10,6 +11,7 @@ import java.util.Arrays;\n import java.util.Comparator;\n import java.util.HashSet;\n import java.util.List;\n+\n import org.h2.command.dml.Query;\n import org.h2.engine.Session;\n import org.h2.expression.Comparison;\n@@ -35,403 +37,403 @@ import org.h2.value.Value;\n  */\n public class IndexCondition {\n \n-    /**\n-     * A bit of a search mask meaning 'equal'.\n-     */\n-    public static final int EQUALITY = 1;\n-\n-    /**\n-     * A bit of a search mask meaning 'larger or equal'.\n-     */\n-    public static final int START = 2;\n-\n-    /**\n-     * A bit of a search mask meaning 'smaller or equal'.\n-     */\n-    public static final int END = 4;\n-\n-    /**\n-     * A search mask meaning 'between'.\n-     */\n-    public static final int RANGE = START | END;\n-\n-    /**\n-     * A bit of a search mask meaning 'the condition is always false'.\n-     */\n-    public static final int ALWAYS_FALSE = 8;\n-\n-    /**\n-     * A bit of a search mask meaning 'spatial intersection'.\n-     */\n-    public static final int SPATIAL_INTERSECTS = 16;\n-\n-    private final Column column;\n-    /**\n-     * see constants in {@link Comparison}\n-     */\n-    private final int compareType;\n-\n-    private final Expression expression;\n-    private List<Expression> expressionList;\n-    private Query expressionQuery;\n-\n-    /**\n-     * @param compareType the comparison type, see constants in\n-     *            {@link Comparison}\n-     */\n-    private IndexCondition(int compareType, ExpressionColumn column,\n-            Expression expression) {\n-        this.compareType = compareType;\n-        this.column = column == null ? null : column.getColumn();\n-        this.expression = expression;\n-    }\n-\n-    /**\n-     * Create an index condition with the given parameters.\n-     *\n-     * @param compareType the comparison type, see constants in\n-     *            {@link Comparison}\n-     * @param column the column\n-     * @param expression the expression\n-     * @return the index condition\n-     */\n-    public static IndexCondition get(int compareType, ExpressionColumn column,\n-            Expression expression) {\n-        return new IndexCondition(compareType, column, expression);\n-    }\n-\n-    /**\n-     * Create an index condition with the compare type IN_LIST and with the\n-     * given parameters.\n-     *\n-     * @param column the column\n-     * @param list the expression list\n-     * @return the index condition\n-     */\n-    public static IndexCondition getInList(ExpressionColumn column,\n-            List<Expression> list) {\n-        IndexCondition cond = new IndexCondition(Comparison.IN_LIST, column,\n-                null);\n-        cond.expressionList = list;\n-        return cond;\n+  /**\n+   * A bit of a search mask meaning 'equal'.\n+   */\n+  public static final int EQUALITY = 1;\n+\n+  /**\n+   * A bit of a search mask meaning 'larger or equal'.\n+   */\n+  public static final int START = 2;\n+\n+  /**\n+   * A bit of a search mask meaning 'smaller or equal'.\n+   */\n+  public static final int END = 4;\n+\n+  /**\n+   * A search mask meaning 'between'.\n+   */\n+  public static final int RANGE = START | END;\n+\n+  /**\n+   * A bit of a search mask meaning 'the condition is always false'.\n+   */\n+  public static final int ALWAYS_FALSE = 8;\n+\n+  /**\n+   * A bit of a search mask meaning 'spatial intersection'.\n+   */\n+  public static final int SPATIAL_INTERSECTS = 16;\n+\n+  private final Column column;\n+  /**\n+   * see constants in {@link Comparison}\n+   */\n+  private final int compareType;\n+\n+  private final Expression expression;\n+  private List<Expression> expressionList;\n+  private Query expressionQuery;\n+\n+  /**\n+   * @param compareType the comparison type, see constants in\n+   *                    {@link Comparison}\n+   */\n+  private IndexCondition(int compareType, ExpressionColumn column,\n+                         Expression expression) {\n+    this.compareType = compareType;\n+    this.column = column == null ? null : column.getColumn();\n+    this.expression = expression;\n+  }\n+\n+  /**\n+   * Create an index condition with the given parameters.\n+   *\n+   * @param compareType the comparison type, see constants in\n+   *                    {@link Comparison}\n+   * @param column      the column\n+   * @param expression  the expression\n+   * @return the index condition\n+   */\n+  public static IndexCondition get(int compareType, ExpressionColumn column,\n+                                   Expression expression) {\n+    return new IndexCondition(compareType, column, expression);\n+  }\n+\n+  /**\n+   * Create an index condition with the compare type IN_LIST and with the\n+   * given parameters.\n+   *\n+   * @param column the column\n+   * @param list   the expression list\n+   * @return the index condition\n+   */\n+  public static IndexCondition getInList(ExpressionColumn column,\n+                                         List<Expression> list) {\n+    IndexCondition cond = new IndexCondition(Comparison.IN_LIST, column,\n+        null);\n+    cond.expressionList = list;\n+    return cond;\n+  }\n+\n+  /**\n+   * Create an index condition with the compare type IN_QUERY and with the\n+   * given parameters.\n+   *\n+   * @param column the column\n+   * @param query  the select statement\n+   * @return the index condition\n+   */\n+  public static IndexCondition getInQuery(ExpressionColumn column, Query query) {\n+    IndexCondition cond = new IndexCondition(Comparison.IN_QUERY, column,\n+        null);\n+    cond.expressionQuery = query;\n+    return cond;\n+  }\n+\n+  /**\n+   * Get the current value of the expression.\n+   *\n+   * @param session the session\n+   * @return the value\n+   */\n+  public Value getCurrentValue(Session session) {\n+    return expression.getValue(session);\n+  }\n+\n+  /**\n+   * Get the current value list of the expression. The value list is of the\n+   * same type as the column, distinct, and sorted.\n+   *\n+   * @param session the session\n+   * @return the value list\n+   */\n+  public Value[] getCurrentValueList(Session session) {\n+    HashSet<Value> valueSet = new HashSet<Value>();\n+    for (Expression e : expressionList) {\n+      Value v = e.getValue(session);\n+      v = column.convert(v);\n+      valueSet.add(v);\n     }\n-\n-    /**\n-     * Create an index condition with the compare type IN_QUERY and with the\n-     * given parameters.\n-     *\n-     * @param column the column\n-     * @param query the select statement\n-     * @return the index condition\n-     */\n-    public static IndexCondition getInQuery(ExpressionColumn column, Query query) {\n-        IndexCondition cond = new IndexCondition(Comparison.IN_QUERY, column,\n-                null);\n-        cond.expressionQuery = query;\n-        return cond;\n+    Value[] array = new Value[valueSet.size()];\n+    valueSet.toArray(array);\n+    final CompareMode mode = session.getDatabase().getCompareMode();\n+    Arrays.sort(array, new Comparator<Value>() {\n+      @Override\n+      public int compare(Value o1, Value o2) {\n+        return o1.compareTo(o2, mode);\n+      }\n+    });\n+    return array;\n+  }\n+\n+  /**\n+   * Get the current result of the expression. The rows may not be of the same\n+   * type, therefore the rows may not be unique.\n+   *\n+   * @return the result\n+   */\n+  public ResultInterface getCurrentResult() {\n+    return expressionQuery.query(0);\n+  }\n+\n+  /**\n+   * Get the SQL snippet of this comparison.\n+   *\n+   * @return the SQL snippet\n+   */\n+  public String getSQL() {\n+    if (compareType == Comparison.FALSE) {\n+      return \"FALSE\";\n     }\n-\n-    /**\n-     * Get the current value of the expression.\n-     *\n-     * @param session the session\n-     * @return the value\n-     */\n-    public Value getCurrentValue(Session session) {\n-        return expression.getValue(session);\n-    }\n-\n-    /**\n-     * Get the current value list of the expression. The value list is of the\n-     * same type as the column, distinct, and sorted.\n-     *\n-     * @param session the session\n-     * @return the value list\n-     */\n-    public Value[] getCurrentValueList(Session session) {\n-        HashSet<Value> valueSet = new HashSet<Value>();\n+    StatementBuilder buff = new StatementBuilder();\n+    buff.append(column.getSQL());\n+    switch (compareType) {\n+      case Comparison.EQUAL:\n+        buff.append(\" = \");\n+        break;\n+      case Comparison.EQUAL_NULL_SAFE:\n+        buff.append(\" IS \");\n+        break;\n+      case Comparison.BIGGER_EQUAL:\n+        buff.append(\" >= \");\n+        break;\n+      case Comparison.BIGGER:\n+        buff.append(\" > \");\n+        break;\n+      case Comparison.SMALLER_EQUAL:\n+        buff.append(\" <= \");\n+        break;\n+      case Comparison.SMALLER:\n+        buff.append(\" < \");\n+        break;\n+      case Comparison.IN_LIST:\n+        buff.append(\" IN(\");\n         for (Expression e : expressionList) {\n-            Value v = e.getValue(session);\n-            v = column.convert(v);\n-            valueSet.add(v);\n+          buff.appendExceptFirst(\", \");\n+          buff.append(e.getSQL());\n         }\n-        Value[] array = new Value[valueSet.size()];\n-        valueSet.toArray(array);\n-        final CompareMode mode = session.getDatabase().getCompareMode();\n-        Arrays.sort(array, new Comparator<Value>() {\n-            @Override\n-            public int compare(Value o1, Value o2) {\n-                return o1.compareTo(o2, mode);\n-            }\n-        });\n-        return array;\n+        buff.append(')');\n+        break;\n+      case Comparison.IN_QUERY:\n+        buff.append(\" IN(\");\n+        buff.append(expressionQuery.getPlanSQL());\n+        buff.append(')');\n+        break;\n+      case Comparison.SPATIAL_INTERSECTS:\n+        buff.append(\" && \");\n+        break;\n+      default:\n+        DbException.throwInternalError(\"type=\" + compareType);\n     }\n-\n-    /**\n-     * Get the current result of the expression. The rows may not be of the same\n-     * type, therefore the rows may not be unique.\n-     *\n-     * @return the result\n-     */\n-    public ResultInterface getCurrentResult() {\n-        return expressionQuery.query(0);\n+    if (expression != null) {\n+      buff.append(expression.getSQL());\n     }\n-\n-    /**\n-     * Get the SQL snippet of this comparison.\n-     *\n-     * @return the SQL snippet\n-     */\n-    public String getSQL() {\n-        if (compareType == Comparison.FALSE) {\n-            return \"FALSE\";\n-        }\n-        StatementBuilder buff = new StatementBuilder();\n-        buff.append(column.getSQL());\n-        switch (compareType) {\n-        case Comparison.EQUAL:\n-            buff.append(\" = \");\n-            break;\n-        case Comparison.EQUAL_NULL_SAFE:\n-            buff.append(\" IS \");\n-            break;\n-        case Comparison.BIGGER_EQUAL:\n-            buff.append(\" >= \");\n-            break;\n-        case Comparison.BIGGER:\n-            buff.append(\" > \");\n-            break;\n-        case Comparison.SMALLER_EQUAL:\n-            buff.append(\" <= \");\n-            break;\n-        case Comparison.SMALLER:\n-            buff.append(\" < \");\n-            break;\n-        case Comparison.IN_LIST:\n-            buff.append(\" IN(\");\n-            for (Expression e : expressionList) {\n-                buff.appendExceptFirst(\", \");\n-                buff.append(e.getSQL());\n-            }\n-            buff.append(')');\n-            break;\n-        case Comparison.IN_QUERY:\n-            buff.append(\" IN(\");\n-            buff.append(expressionQuery.getPlanSQL());\n-            buff.append(')');\n-            break;\n-        case Comparison.SPATIAL_INTERSECTS:\n-            buff.append(\" && \");\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + compareType);\n+    return buff.toString();\n+  }\n+\n+  /**\n+   * Get the comparison bit mask.\n+   *\n+   * @param indexConditions all index conditions\n+   * @return the mask\n+   */\n+  public int getMask(ArrayList<IndexCondition> indexConditions) {\n+    switch (compareType) {\n+      case Comparison.FALSE:\n+        return ALWAYS_FALSE;\n+      case Comparison.EQUAL:\n+      case Comparison.EQUAL_NULL_SAFE:\n+        return EQUALITY;\n+      case Comparison.IN_LIST:\n+      case Comparison.IN_QUERY:\n+        if (indexConditions.size() > 1) {\n+          if (TableType.TABLE != column.getTable().getTableType()) {\n+            // if combined with other conditions,\n+            // IN(..) can only be used for regular tables\n+            // test case:\n+            // create table test(a int, b int, primary key(id, name));\n+            // create unique index c on test(b, a);\n+            // insert into test values(1, 10), (2, 20);\n+            // select * from (select * from test)\n+            // where a=1 and b in(10, 20);\n+\n+            //\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n+            //\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n+            //\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n+            return 0;\n+          }\n         }\n-        if (expression != null) {\n-            buff.append(expression.getSQL());\n-        }\n-        return buff.toString();\n+        return EQUALITY;\n+      case Comparison.BIGGER_EQUAL:\n+      case Comparison.BIGGER:\n+        return START;\n+      case Comparison.SMALLER_EQUAL:\n+      case Comparison.SMALLER:\n+        return END;\n+      case Comparison.SPATIAL_INTERSECTS:\n+        return SPATIAL_INTERSECTS;\n+      default:\n+        throw DbException.throwInternalError(\"type=\" + compareType);\n     }\n-\n-    /**\n-     * Get the comparison bit mask.\n-     *\n-     * @param indexConditions all index conditions\n-     * @return the mask\n-     */\n-    public int getMask(ArrayList<IndexCondition> indexConditions) {\n-        switch (compareType) {\n-        case Comparison.FALSE:\n-            return ALWAYS_FALSE;\n-        case Comparison.EQUAL:\n-        case Comparison.EQUAL_NULL_SAFE:\n-            return EQUALITY;\n-        case Comparison.IN_LIST:\n-        case Comparison.IN_QUERY:\n-            if (indexConditions.size() > 1) {\n-                if (TableType.TABLE != column.getTable().getTableType()) {\n-                    // if combined with other conditions,\n-                    // IN(..) can only be used for regular tables\n-                    // test case:\n-                    // create table test(a int, b int, primary key(id, name));\n-                    // create unique index c on test(b, a);\n-                    // insert into test values(1, 10), (2, 20);\n-                    // select * from (select * from test)\n-                    // where a=1 and b in(10, 20);\n-                \t\n-                \t//\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n-                \t//\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n-                \t//\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n-                    return 0;\n-                }\n-            }\n-            return EQUALITY;\n-        case Comparison.BIGGER_EQUAL:\n-        case Comparison.BIGGER:\n-            return START;\n-        case Comparison.SMALLER_EQUAL:\n-        case Comparison.SMALLER:\n-            return END;\n-        case Comparison.SPATIAL_INTERSECTS:\n-            return SPATIAL_INTERSECTS;\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + compareType);\n-        }\n+  }\n+\n+  /**\n+   * Check if the result is always false.\n+   *\n+   * @return true if the result will always be false\n+   */\n+  public boolean isAlwaysFalse() {\n+    return compareType == Comparison.FALSE;\n+  }\n+\n+  /**\n+   * Check if this index condition is of the type column larger or equal to\n+   * value.\n+   *\n+   * @return true if this is a start condition\n+   */\n+  public boolean isStart() {\n+    switch (compareType) {\n+      case Comparison.EQUAL:\n+      case Comparison.EQUAL_NULL_SAFE:\n+      case Comparison.BIGGER_EQUAL:\n+      case Comparison.BIGGER:\n+        return true;\n+      default:\n+        return false;\n     }\n-\n-    /**\n-     * Check if the result is always false.\n-     *\n-     * @return true if the result will always be false\n-     */\n-    public boolean isAlwaysFalse() {\n-        return compareType == Comparison.FALSE;\n+  }\n+\n+  /**\n+   * Check if this index condition is of the type column smaller or equal to\n+   * value.\n+   *\n+   * @return true if this is a end condition\n+   */\n+  public boolean isEnd() {\n+    switch (compareType) {\n+      case Comparison.EQUAL:\n+      case Comparison.EQUAL_NULL_SAFE:\n+      case Comparison.SMALLER_EQUAL:\n+      case Comparison.SMALLER:\n+        return true;\n+      default:\n+        return false;\n     }\n-\n-    /**\n-     * Check if this index condition is of the type column larger or equal to\n-     * value.\n-     *\n-     * @return true if this is a start condition\n-     */\n-    public boolean isStart() {\n-        switch (compareType) {\n-        case Comparison.EQUAL:\n-        case Comparison.EQUAL_NULL_SAFE:\n-        case Comparison.BIGGER_EQUAL:\n-        case Comparison.BIGGER:\n-            return true;\n-        default:\n-            return false;\n-        }\n+  }\n+\n+  /**\n+   * Check if this index condition is of the type spatial column intersects\n+   * value.\n+   *\n+   * @return true if this is a spatial intersects condition\n+   */\n+  public boolean isSpatialIntersects() {\n+    switch (compareType) {\n+      case Comparison.SPATIAL_INTERSECTS:\n+        return true;\n+      default:\n+        return false;\n     }\n-\n-    /**\n-     * Check if this index condition is of the type column smaller or equal to\n-     * value.\n-     *\n-     * @return true if this is a end condition\n-     */\n-    public boolean isEnd() {\n-        switch (compareType) {\n-        case Comparison.EQUAL:\n-        case Comparison.EQUAL_NULL_SAFE:\n-        case Comparison.SMALLER_EQUAL:\n-        case Comparison.SMALLER:\n-            return true;\n-        default:\n-            return false;\n-        }\n+  }\n+\n+  public int getCompareType() {\n+    return compareType;\n+  }\n+\n+  /**\n+   * Get the referenced column.\n+   *\n+   * @return the column\n+   */\n+  public Column getColumn() {\n+    return column;\n+  }\n+\n+  /**\n+   * Get expression.\n+   *\n+   * @return Expression.\n+   */\n+  public Expression getExpression() {\n+    return expression;\n+  }\n+\n+  /**\n+   * Get expression list.\n+   *\n+   * @return Expression list.\n+   */\n+  public List<Expression> getExpressionList() {\n+    return expressionList;\n+  }\n+\n+  /**\n+   * Get expression query.\n+   *\n+   * @return Expression query.\n+   */\n+  public Query getExpressionQuery() {\n+    return expressionQuery;\n+  }\n+\n+  /**\n+   * Check if the expression can be evaluated.\n+   *\n+   * @return true if it can be evaluated\n+   */\n+  public boolean isEvaluatable() {\n+    if (expression != null) {\n+      return expression\n+          .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n     }\n-\n-    /**\n-     * Check if this index condition is of the type spatial column intersects\n-     * value.\n-     *\n-     * @return true if this is a spatial intersects condition\n-     */\n-    public boolean isSpatialIntersects() {\n-        switch (compareType) {\n-        case Comparison.SPATIAL_INTERSECTS:\n-            return true;\n-        default:\n-            return false;\n+    if (expressionList != null) {\n+      for (Expression e : expressionList) {\n+        if (!e.isEverything(ExpressionVisitor.EVALUATABLE_VISITOR)) {\n+          return false;\n         }\n+      }\n+      return true;\n     }\n-\n-    public int getCompareType() {\n-        return compareType;\n-    }\n-\n-    /**\n-     * Get the referenced column.\n-     *\n-     * @return the column\n-     */\n-    public Column getColumn() {\n-        return column;\n-    }\n-\n-    /**\n-     * Get expression.\n-     *\n-     * @return Expression.\n-     */\n-    public Expression getExpression() {\n-        return expression;\n+    return expressionQuery\n+        .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"column=\" + column +\n+        \", compareType=\" + compareTypeToString(compareType) +\n+        \", expression=\" + expression +\n+        \", expressionList=\" + expressionList.toString() +\n+        \", expressionQuery=\" + expressionQuery;\n+  }\n+\n+  private static String compareTypeToString(int i) {\n+    StatementBuilder s = new StatementBuilder();\n+    if ((i & EQUALITY) == EQUALITY) {\n+      s.appendExceptFirst(\"&\");\n+      s.append(\"EQUALITY\");\n     }\n-\n-    /**\n-     * Get expression list.\n-     *\n-     * @return Expression list.\n-     */\n-    public List<Expression> getExpressionList() {\n-        return expressionList;\n-    }\n-\n-    /**\n-     * Get expression query.\n-     *\n-     * @return Expression query.\n-     */\n-    public Query getExpressionQuery() {\n-        return expressionQuery;\n+    if ((i & START) == START) {\n+      s.appendExceptFirst(\"&\");\n+      s.append(\"START\");\n     }\n-\n-    /**\n-     * Check if the expression can be evaluated.\n-     *\n-     * @return true if it can be evaluated\n-     */\n-    public boolean isEvaluatable() {\n-        if (expression != null) {\n-            return expression\n-                    .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n-        }\n-        if (expressionList != null) {\n-            for (Expression e : expressionList) {\n-                if (!e.isEverything(ExpressionVisitor.EVALUATABLE_VISITOR)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        return expressionQuery\n-                .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n+    if ((i & END) == END) {\n+      s.appendExceptFirst(\"&\");\n+      s.append(\"END\");\n     }\n-\n-    @Override\n-    public String toString() {\n-        return \"column=\" + column +\n-                \", compareType=\" + compareTypeToString(compareType) +\n-                \", expression=\" + expression +\n-                \", expressionList=\" + expressionList.toString() +\n-                \", expressionQuery=\" + expressionQuery;\n+    if ((i & ALWAYS_FALSE) == ALWAYS_FALSE) {\n+      s.appendExceptFirst(\"&\");\n+      s.append(\"ALWAYS_FALSE\");\n     }\n-\n-    private static String compareTypeToString(int i) {\n-        StatementBuilder s = new StatementBuilder();\n-        if ((i & EQUALITY) == EQUALITY) {\n-            s.appendExceptFirst(\"&\");\n-            s.append(\"EQUALITY\");\n-        }\n-        if ((i & START) == START) {\n-            s.appendExceptFirst(\"&\");\n-            s.append(\"START\");\n-        }\n-        if ((i & END) == END) {\n-            s.appendExceptFirst(\"&\");\n-            s.append(\"END\");\n-        }\n-        if ((i & ALWAYS_FALSE) == ALWAYS_FALSE) {\n-            s.appendExceptFirst(\"&\");\n-            s.append(\"ALWAYS_FALSE\");\n-        }\n-        if ((i & SPATIAL_INTERSECTS) == SPATIAL_INTERSECTS) {\n-            s.appendExceptFirst(\"&\");\n-            s.append(\"SPATIAL_INTERSECTS\");\n-        }\n-        return s.toString();\n+    if ((i & SPATIAL_INTERSECTS) == SPATIAL_INTERSECTS) {\n+      s.appendExceptFirst(\"&\");\n+      s.append(\"SPATIAL_INTERSECTS\");\n     }\n+    return s.toString();\n+  }\n \n }\n",
            "diff_size": 496
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/261/IndexCondition.java\nindex 532d440f5ec..8b9a72fd457 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/261/IndexCondition.java\n@@ -33,44 +33,56 @@ import org.h2.value.Value;\n  * @author Noel Grandin\n  * @author Nicolas Fortin, Atelier SIG, IRSTV FR CNRS 24888\n  */\n+\n+\n public class IndexCondition {\n \n     /**\n      * A bit of a search mask meaning 'equal'.\n      */\n+\n+\n     public static final int EQUALITY = 1;\n \n     /**\n      * A bit of a search mask meaning 'larger or equal'.\n      */\n+\n+\n     public static final int START = 2;\n \n     /**\n      * A bit of a search mask meaning 'smaller or equal'.\n      */\n+\n+\n     public static final int END = 4;\n \n     /**\n      * A search mask meaning 'between'.\n      */\n+\n+\n     public static final int RANGE = START | END;\n \n     /**\n      * A bit of a search mask meaning 'the condition is always false'.\n      */\n+\n+\n     public static final int ALWAYS_FALSE = 8;\n \n     /**\n      * A bit of a search mask meaning 'spatial intersection'.\n      */\n-    public static final int SPATIAL_INTERSECTS = 16;\n \n+\n+    public static final int SPATIAL_INTERSECTS = 16;\n     private final Column column;\n     /**\n      * see constants in {@link Comparison}\n      */\n     private final int compareType;\n-\n     private final Expression expression;\n     private List<Expression> expressionList;\n     private Query expressionQuery;\n@@ -79,8 +91,8 @@ public class IndexCondition {\n      * @param compareType the comparison type, see constants in\n      *            {@link Comparison}\n      */\n-    private IndexCondition(int compareType, ExpressionColumn column,\n-            Expression expression) {\n+\n+    private IndexCondition(int compareType, ExpressionColumn column, Expression expression) {\n         this.compareType = compareType;\n         this.column = column == null ? null : column.getColumn();\n         this.expression = expression;\n@@ -95,8 +107,9 @@ public class IndexCondition {\n      * @param expression the expression\n      * @return the index condition\n      */\n-    public static IndexCondition get(int compareType, ExpressionColumn column,\n-            Expression expression) {\n+\n+\n+    public static IndexCondition get(int compareType, ExpressionColumn column, Expression expression) {\n         return new IndexCondition(compareType, column, expression);\n     }\n \n@@ -108,10 +121,10 @@ public class IndexCondition {\n      * @param list the expression list\n      * @return the index condition\n      */\n-    public static IndexCondition getInList(ExpressionColumn column,\n-            List<Expression> list) {\n-        IndexCondition cond = new IndexCondition(Comparison.IN_LIST, column,\n-                null);\n+\n+\n+    public static IndexCondition getInList(ExpressionColumn column, List<Expression> list) {\n+        IndexCondition cond = new IndexCondition(Comparison.IN_LIST, column, null);\n         cond.expressionList = list;\n         return cond;\n     }\n@@ -124,9 +137,10 @@ public class IndexCondition {\n      * @param query the select statement\n      * @return the index condition\n      */\n+\n+\n     public static IndexCondition getInQuery(ExpressionColumn column, Query query) {\n-        IndexCondition cond = new IndexCondition(Comparison.IN_QUERY, column,\n-                null);\n+        IndexCondition cond = new IndexCondition(Comparison.IN_QUERY, column, null);\n         cond.expressionQuery = query;\n         return cond;\n     }\n@@ -137,6 +151,8 @@ public class IndexCondition {\n      * @param session the session\n      * @return the value\n      */\n+\n+\n     public Value getCurrentValue(Session session) {\n         return expression.getValue(session);\n     }\n@@ -148,6 +164,8 @@ public class IndexCondition {\n      * @param session the session\n      * @return the value list\n      */\n+\n+\n     public Value[] getCurrentValueList(Session session) {\n         HashSet<Value> valueSet = new HashSet<Value>();\n         for (Expression e : expressionList) {\n@@ -159,10 +177,10 @@ public class IndexCondition {\n         valueSet.toArray(array);\n         final CompareMode mode = session.getDatabase().getCompareMode();\n         Arrays.sort(array, new Comparator<Value>() {\n-            @Override\n-            public int compare(Value o1, Value o2) {\n-                return o1.compareTo(o2, mode);\n-            }\n+@Override\n+public int compare(Value o1, Value o2) {\n+    return o1.compareTo(o2, mode);\n+}\n         });\n         return array;\n     }\n@@ -173,6 +191,8 @@ public class IndexCondition {\n      *\n      * @return the result\n      */\n+\n+\n     public ResultInterface getCurrentResult() {\n         return expressionQuery.query(0);\n     }\n@@ -182,6 +202,8 @@ public class IndexCondition {\n      *\n      * @return the SQL snippet\n      */\n+\n+\n     public String getSQL() {\n         if (compareType == Comparison.FALSE) {\n             return \"FALSE\";\n@@ -238,6 +260,8 @@ public class IndexCondition {\n      * @param indexConditions all index conditions\n      * @return the mask\n      */\n+\n+\n     public int getMask(ArrayList<IndexCondition> indexConditions) {\n         switch (compareType) {\n         case Comparison.FALSE:\n@@ -257,10 +281,10 @@ public class IndexCondition {\n                     // insert into test values(1, 10), (2, 20);\n                     // select * from (select * from test)\n                     // where a=1 and b in(10, 20);\n-                \t\n-                \t//\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n-                \t//\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n-                \t//\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n+                    \n+                    //\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n+                    //\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n+                    //\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n                     return 0;\n                 }\n             }\n@@ -283,6 +307,8 @@ public class IndexCondition {\n      *\n      * @return true if the result will always be false\n      */\n+\n+\n     public boolean isAlwaysFalse() {\n         return compareType == Comparison.FALSE;\n     }\n@@ -293,6 +319,8 @@ public class IndexCondition {\n      *\n      * @return true if this is a start condition\n      */\n+\n+\n     public boolean isStart() {\n         switch (compareType) {\n         case Comparison.EQUAL:\n@@ -311,6 +339,8 @@ public class IndexCondition {\n      *\n      * @return true if this is a end condition\n      */\n+\n+\n     public boolean isEnd() {\n         switch (compareType) {\n         case Comparison.EQUAL:\n@@ -329,6 +359,8 @@ public class IndexCondition {\n      *\n      * @return true if this is a spatial intersects condition\n      */\n+\n+\n     public boolean isSpatialIntersects() {\n         switch (compareType) {\n         case Comparison.SPATIAL_INTERSECTS:\n@@ -338,6 +370,7 @@ public class IndexCondition {\n         }\n     }\n \n+\n     public int getCompareType() {\n         return compareType;\n     }\n@@ -347,6 +380,8 @@ public class IndexCondition {\n      *\n      * @return the column\n      */\n+\n+\n     public Column getColumn() {\n         return column;\n     }\n@@ -356,6 +391,8 @@ public class IndexCondition {\n      *\n      * @return Expression.\n      */\n+\n+\n     public Expression getExpression() {\n         return expression;\n     }\n@@ -365,6 +402,8 @@ public class IndexCondition {\n      *\n      * @return Expression list.\n      */\n+\n+\n     public List<Expression> getExpressionList() {\n         return expressionList;\n     }\n@@ -374,6 +413,8 @@ public class IndexCondition {\n      *\n      * @return Expression query.\n      */\n+\n+\n     public Query getExpressionQuery() {\n         return expressionQuery;\n     }\n@@ -383,10 +424,11 @@ public class IndexCondition {\n      *\n      * @return true if it can be evaluated\n      */\n+\n+\n     public boolean isEvaluatable() {\n         if (expression != null) {\n-            return expression\n-                    .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n+            return expression.isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n         }\n         if (expressionList != null) {\n             for (Expression e : expressionList) {\n@@ -396,17 +438,15 @@ public class IndexCondition {\n             }\n             return true;\n         }\n-        return expressionQuery\n-                .isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n+        return expressionQuery.isEverything(ExpressionVisitor.EVALUATABLE_VISITOR);\n     }\n \n     @Override\n     public String toString() {\n-        return \"column=\" + column +\n-                \", compareType=\" + compareTypeToString(compareType) +\n-                \", expression=\" + expression +\n-                \", expressionList=\" + expressionList.toString() +\n-                \", expressionQuery=\" + expressionQuery;\n+        return \"column=\" + column + \", compareType=\"\n+        + compareTypeToString(compareType) + \", expression=\"\n+        + expression + \", expressionList=\"\n+        + expressionList.toString() + \", expressionQuery=\" + expressionQuery;\n     }\n \n     private static String compareTypeToString(int i) {\n@@ -434,4 +474,4 @@ public class IndexCondition {\n         return s.toString();\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 76
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "261",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/261/IndexCondition.java\nindex 532d440f5ec..ed8572e780e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/261/IndexCondition.java\n@@ -257,10 +257,10 @@ public class IndexCondition {\n                     // insert into test values(1, 10), (2, 20);\n                     // select * from (select * from test)\n                     // where a=1 and b in(10, 20);\n-                \t\n-                \t//\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n-                \t//\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n-                \t//\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n                     return 0;\n                 }\n             }\n",
            "diff_size": 4
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "261",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/261/IndexCondition.java\nindex 532d440f5ec..ed8572e780e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/261/IndexCondition.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/261/IndexCondition.java\n@@ -257,10 +257,10 @@ public class IndexCondition {\n                     // insert into test values(1, 10), (2, 20);\n                     // select * from (select * from test)\n                     // where a=1 and b in(10, 20);\n-                \t\n-                \t//\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n-                \t//\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n-                \t//\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n+\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u8fd9\u91cc(select * from test)\u88ab\u5f53\u6210\u4e00\u4e2a\u89c6\u56fe\u4e86\uff0cb\u5b57\u6bb5\u662f\u5c5e\u4e8e(select * from test)\u7684\uff0c\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u56e0\u4e3a(select * from test)\u662f\u5c5e\u4e8e\u7b2c\u4e00\u4e2aselect\u7684from\u5b50\u53e5\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u540c\u6837a\u5b57\u6bb5\u4e5f\u662f\u5c5e\u4e8e\u89c6\u56fe\u4e2d\u7684\u5217\n                     return 0;\n                 }\n             }\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}