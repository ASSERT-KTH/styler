{
    "project_name": "codefollower-H2-Research",
    "error_id": "165",
    "information": {
        "errors": [
            {
                "line": "175",
                "column": "41",
                "severity": "warning",
                "message": "';' is followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
            }
        ]
    },
    "source_code": "        PageDataNode p2 = PageDataNode.create(index, newPageId, parentPageId);\n        int firstChild = childPageIds[splitPoint];\n        for (; splitPoint < entryCount; ) {\n            p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], keys[splitPoint]);\n            removeChild(splitPoint);\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/165/PageDataNode.java\nindex 6ff79ac9ed0..c7067f12478 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/165/PageDataNode.java\n@@ -172,7 +172,7 @@ public class PageDataNode extends PageData {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataNode p2 = PageDataNode.create(index, newPageId, parentPageId);\n         int firstChild = childPageIds[splitPoint];\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], keys[splitPoint]);\n             removeChild(splitPoint);\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "177",
                    "column": "37",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/165/PageDataNode.java\nindex 6ff79ac9ed0..d645559386f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/165/PageDataNode.java\n@@ -3,9 +3,11 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import java.util.Arrays;\n+\n import org.h2.api.DatabaseEventListener;\n import org.h2.api.ErrorCode;\n import org.h2.engine.Session;\n@@ -34,426 +36,426 @@ import org.h2.util.Utils;\n  */\n public class PageDataNode extends PageData {\n \n-    /**\n-     * The page ids of the children.\n-     */\n-    private int[] childPageIds;\n-\n-    private int rowCountStored = UNKNOWN_ROWCOUNT;\n-\n-    private int rowCount = UNKNOWN_ROWCOUNT;\n-\n-    /**\n-     * The number of bytes used in the page\n-     */\n-    private int length;\n-\n-    private PageDataNode(PageDataIndex index, int pageId, Data data) {\n-        super(index, pageId, data);\n-    }\n-\n-    /**\n-     * Create a new page.\n-     *\n-     * @param index the index\n-     * @param pageId the page id\n-     * @param parentPageId the parent\n-     * @return the page\n-     */\n-    static PageDataNode create(PageDataIndex index, int pageId, int parentPageId) {\n-        PageDataNode p = new PageDataNode(index, pageId,\n-                index.getPageStore().createData());\n-        index.getPageStore().logUndo(p, null);\n-        p.parentPageId = parentPageId;\n-        p.writeHead();\n-        // 4 bytes for the rightmost child page id\n-        p.length = p.data.length() + 4;\n-        return p;\n+  /**\n+   * The page ids of the children.\n+   */\n+  private int[] childPageIds;\n+\n+  private int rowCountStored = UNKNOWN_ROWCOUNT;\n+\n+  private int rowCount = UNKNOWN_ROWCOUNT;\n+\n+  /**\n+   * The number of bytes used in the page\n+   */\n+  private int length;\n+\n+  private PageDataNode(PageDataIndex index, int pageId, Data data) {\n+    super(index, pageId, data);\n+  }\n+\n+  /**\n+   * Create a new page.\n+   *\n+   * @param index        the index\n+   * @param pageId       the page id\n+   * @param parentPageId the parent\n+   * @return the page\n+   */\n+  static PageDataNode create(PageDataIndex index, int pageId, int parentPageId) {\n+    PageDataNode p = new PageDataNode(index, pageId,\n+        index.getPageStore().createData());\n+    index.getPageStore().logUndo(p, null);\n+    p.parentPageId = parentPageId;\n+    p.writeHead();\n+    // 4 bytes for the rightmost child page id\n+    p.length = p.data.length() + 4;\n+    return p;\n+  }\n+\n+  /**\n+   * Read a data node page.\n+   *\n+   * @param index  the index\n+   * @param data   the data\n+   * @param pageId the page id\n+   * @return the page\n+   */\n+  public static Page read(PageDataIndex index, Data data, int pageId) {\n+    PageDataNode p = new PageDataNode(index, pageId, data);\n+    p.read();\n+    return p;\n+  }\n+\n+  private void read() {\n+    data.reset();\n+    data.readByte();\n+    data.readShortInt();\n+    this.parentPageId = data.readInt();\n+    int indexId = data.readVarInt();\n+    if (indexId != index.getId()) {\n+      throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n+          \"page:\" + getPos() + \" expected index:\" + index.getId() +\n+              \"got:\" + indexId);\n     }\n-\n-    /**\n-     * Read a data node page.\n-     *\n-     * @param index the index\n-     * @param data the data\n-     * @param pageId the page id\n-     * @return the page\n-     */\n-    public static Page read(PageDataIndex index, Data data, int pageId) {\n-        PageDataNode p = new PageDataNode(index, pageId, data);\n-        p.read();\n-        return p;\n+    rowCount = rowCountStored = data.readInt();\n+    entryCount = data.readShortInt();\n+    childPageIds = new int[entryCount + 1];\n+    childPageIds[entryCount] = data.readInt();\n+    keys = Utils.newLongArray(entryCount);\n+    for (int i = 0; i < entryCount; i++) {\n+      childPageIds[i] = data.readInt();\n+      keys[i] = data.readVarLong();\n     }\n-\n-    private void read() {\n-        data.reset();\n-        data.readByte();\n-        data.readShortInt();\n-        this.parentPageId = data.readInt();\n-        int indexId = data.readVarInt();\n-        if (indexId != index.getId()) {\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                    \"page:\" + getPos() + \" expected index:\" + index.getId() +\n-                    \"got:\" + indexId);\n-        }\n-        rowCount = rowCountStored = data.readInt();\n-        entryCount = data.readShortInt();\n-        childPageIds = new int[entryCount + 1];\n-        childPageIds[entryCount] = data.readInt();\n-        keys = Utils.newLongArray(entryCount);\n-        for (int i = 0; i < entryCount; i++) {\n-            childPageIds[i] = data.readInt();\n-            keys[i] = data.readVarLong();\n-        }\n-        length = data.length();\n-        check();\n-        written = true;\n+    length = data.length();\n+    check();\n+    written = true;\n+  }\n+\n+  private void addChild(int x, int childPageId, long key) {\n+    index.getPageStore().logUndo(this, data);\n+    written = false;\n+    changeCount = index.getPageStore().getChangeCount();\n+    childPageIds = insert(childPageIds, entryCount + 1, x + 1, childPageId);\n+    keys = insert(keys, entryCount, x, key);\n+    entryCount++;\n+    length += 4 + Data.getVarLongLen(key);\n+  }\n+\n+  @Override\n+  int addRowTry(Row row) {\n+    index.getPageStore().logUndo(this, data);\n+    int keyOffsetPairLen = 4 + Data.getVarLongLen(row.getKey());\n+    while (true) {\n+      int x = find(row.getKey());\n+      PageData page = index.getPage(childPageIds[x], getPos());\n+      int splitPoint = page.addRowTry(row);\n+      if (splitPoint == -1) {\n+        break;\n+      }\n+      if (length + keyOffsetPairLen > index.getPageStore().getPageSize()) {\n+        return entryCount / 2;\n+      }\n+      long pivot = splitPoint == 0 ? row.getKey() : page.getKey(splitPoint - 1);\n+      PageData page2 = page.split(splitPoint);\n+      index.getPageStore().update(page);\n+      index.getPageStore().update(page2);\n+      addChild(x, page2.getPos(), pivot);\n+      index.getPageStore().update(this);\n     }\n+    updateRowCount(1);\n+    return -1;\n+  }\n \n-    private void addChild(int x, int childPageId, long key) {\n-        index.getPageStore().logUndo(this, data);\n-        written = false;\n-        changeCount = index.getPageStore().getChangeCount();\n-        childPageIds = insert(childPageIds, entryCount + 1, x + 1, childPageId);\n-        keys = insert(keys, entryCount, x, key);\n-        entryCount++;\n-        length += 4 + Data.getVarLongLen(key);\n+  private void updateRowCount(int offset) {\n+    if (rowCount != UNKNOWN_ROWCOUNT) {\n+      rowCount += offset;\n     }\n-\n-    @Override\n-    int addRowTry(Row row) {\n-        index.getPageStore().logUndo(this, data);\n-        int keyOffsetPairLen = 4 + Data.getVarLongLen(row.getKey());\n-        while (true) {\n-            int x = find(row.getKey());\n-            PageData page = index.getPage(childPageIds[x], getPos());\n-            int splitPoint = page.addRowTry(row);\n-            if (splitPoint == -1) {\n-                break;\n-            }\n-            if (length + keyOffsetPairLen > index.getPageStore().getPageSize()) {\n-                return entryCount / 2;\n-            }\n-            long pivot = splitPoint == 0 ? row.getKey() : page.getKey(splitPoint - 1);\n-            PageData page2 = page.split(splitPoint);\n-            index.getPageStore().update(page);\n-            index.getPageStore().update(page2);\n-            addChild(x, page2.getPos(), pivot);\n-            index.getPageStore().update(this);\n-        }\n-        updateRowCount(1);\n-        return -1;\n+    if (rowCountStored != UNKNOWN_ROWCOUNT) {\n+      rowCountStored = UNKNOWN_ROWCOUNT;\n+      index.getPageStore().logUndo(this, data);\n+      if (written) {\n+        writeHead();\n+      }\n+      index.getPageStore().update(this);\n     }\n-\n-    private void updateRowCount(int offset) {\n-        if (rowCount != UNKNOWN_ROWCOUNT) {\n-            rowCount += offset;\n-        }\n-        if (rowCountStored != UNKNOWN_ROWCOUNT) {\n-            rowCountStored = UNKNOWN_ROWCOUNT;\n-            index.getPageStore().logUndo(this, data);\n-            if (written) {\n-                writeHead();\n-            }\n-            index.getPageStore().update(this);\n-        }\n+  }\n+\n+  @Override\n+  Cursor find(Session session, long minKey, long maxKey, boolean multiVersion) {\n+    int x = find(minKey);\n+    int child = childPageIds[x];\n+    return index.getPage(child, getPos()).find(session, minKey, maxKey,\n+        multiVersion);\n+  }\n+\n+  @Override\n+  PageData split(int splitPoint) {\n+    int newPageId = index.getPageStore().allocatePage();\n+    PageDataNode p2 = PageDataNode.create(index, newPageId, parentPageId);\n+    int firstChild = childPageIds[splitPoint];\n+    for (; splitPoint < entryCount; ) {\n+      p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], keys[splitPoint]);\n+      removeChild(splitPoint);\n     }\n-\n-    @Override\n-    Cursor find(Session session, long minKey, long maxKey, boolean multiVersion) {\n-        int x = find(minKey);\n-        int child = childPageIds[x];\n-        return index.getPage(child, getPos()).find(session, minKey, maxKey,\n-                multiVersion);\n+    int lastChild = childPageIds[splitPoint - 1];\n+    removeChild(splitPoint - 1);\n+    childPageIds[splitPoint - 1] = lastChild;\n+    p2.childPageIds[0] = firstChild;\n+    p2.remapChildren(getPos());\n+    return p2;\n+  }\n+\n+  @Override\n+  protected void remapChildren(int old) {\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      int child = childPageIds[i];\n+      PageData p = index.getPage(child, old);\n+      p.setParentPageId(getPos());\n+      index.getPageStore().update(p);\n     }\n-\n-    @Override\n-    PageData split(int splitPoint) {\n-        int newPageId = index.getPageStore().allocatePage();\n-        PageDataNode p2 = PageDataNode.create(index, newPageId, parentPageId);\n-        int firstChild = childPageIds[splitPoint];\n-        for (; splitPoint < entryCount; ) {\n-            p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], keys[splitPoint]);\n-            removeChild(splitPoint);\n-        }\n-        int lastChild = childPageIds[splitPoint - 1];\n-        removeChild(splitPoint - 1);\n-        childPageIds[splitPoint - 1] = lastChild;\n-        p2.childPageIds[0] = firstChild;\n-        p2.remapChildren(getPos());\n-        return p2;\n+  }\n+\n+  /**\n+   * Initialize the page.\n+   *\n+   * @param page1 the first child page\n+   * @param pivot the pivot key\n+   * @param page2 the last child page\n+   */\n+  void init(PageData page1, long pivot, PageData page2) {\n+    entryCount = 1;\n+    childPageIds = new int[] {page1.getPos(), page2.getPos()};\n+    keys = new long[] {pivot};\n+    length += 4 + Data.getVarLongLen(pivot);\n+    check();\n+  }\n+\n+  @Override\n+  long getLastKey() {\n+    return index.getPage(childPageIds[entryCount], getPos()).getLastKey();\n+  }\n+\n+  /**\n+   * Get the next leaf page.\n+   *\n+   * @param key the last key of the current page\n+   * @return the next leaf page\n+   */\n+  PageDataLeaf getNextPage(long key) {\n+    int i = find(key) + 1;\n+    if (i > entryCount) {\n+      if (parentPageId == PageData.ROOT) {\n+        return null;\n+      }\n+      PageDataNode next = (PageDataNode) index.getPage(parentPageId, -1);\n+      return next.getNextPage(key);\n     }\n-\n-    @Override\n-    protected void remapChildren(int old) {\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            int child = childPageIds[i];\n-            PageData p = index.getPage(child, old);\n-            p.setParentPageId(getPos());\n-            index.getPageStore().update(p);\n-        }\n+    PageData page = index.getPage(childPageIds[i], getPos());\n+    return page.getFirstLeaf();\n+  }\n+\n+  @Override\n+  PageDataLeaf getFirstLeaf() {\n+    int child = childPageIds[0];\n+    return index.getPage(child, getPos()).getFirstLeaf();\n+  }\n+\n+  @Override\n+  boolean remove(long key) {\n+    int at = find(key);\n+    // merge is not implemented to allow concurrent usage\n+    // TODO maybe implement merge\n+    PageData page = index.getPage(childPageIds[at], getPos());\n+    boolean empty = page.remove(key);\n+    index.getPageStore().logUndo(this, data);\n+    updateRowCount(-1);\n+    if (!empty) {\n+      // the first row didn't change - nothing to do\n+      return false;\n     }\n-\n-    /**\n-     * Initialize the page.\n-     *\n-     * @param page1 the first child page\n-     * @param pivot the pivot key\n-     * @param page2 the last child page\n-     */\n-    void init(PageData page1, long pivot, PageData page2) {\n-        entryCount = 1;\n-        childPageIds = new int[] { page1.getPos(), page2.getPos() };\n-        keys = new long[] { pivot };\n-        length += 4 + Data.getVarLongLen(pivot);\n-        check();\n+    // this child is now empty\n+    index.getPageStore().free(page.getPos());\n+    if (entryCount < 1) {\n+      // no more children - this page is empty as well\n+      return true;\n     }\n-\n-    @Override\n-    long getLastKey() {\n-        return index.getPage(childPageIds[entryCount], getPos()).getLastKey();\n+    removeChild(at);\n+    index.getPageStore().update(this);\n+    return false;\n+  }\n+\n+  @Override\n+  void freeRecursive() {\n+    index.getPageStore().logUndo(this, data);\n+    index.getPageStore().free(getPos());\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      int child = childPageIds[i];\n+      index.getPage(child, getPos()).freeRecursive();\n     }\n-\n-    /**\n-     * Get the next leaf page.\n-     *\n-     * @param key the last key of the current page\n-     * @return the next leaf page\n-     */\n-    PageDataLeaf getNextPage(long key) {\n-        int i = find(key) + 1;\n-        if (i > entryCount) {\n-            if (parentPageId == PageData.ROOT) {\n-                return null;\n-            }\n-            PageDataNode next = (PageDataNode) index.getPage(parentPageId, -1);\n-            return next.getNextPage(key);\n+  }\n+\n+  @Override\n+  Row getRowWithKey(long key) {\n+    int at = find(key);\n+    PageData page = index.getPage(childPageIds[at], getPos());\n+    return page.getRowWithKey(key);\n+  }\n+\n+  @Override\n+  int getRowCount() {\n+    if (rowCount == UNKNOWN_ROWCOUNT) {\n+      int count = 0;\n+      for (int i = 0; i < entryCount + 1; i++) {\n+        int child = childPageIds[i];\n+        PageData page = index.getPage(child, getPos());\n+        if (getPos() == page.getPos()) {\n+          throw DbException.throwInternalError(\"Page is its own child: \" + getPos());\n         }\n-        PageData page = index.getPage(childPageIds[i], getPos());\n-        return page.getFirstLeaf();\n+        count += page.getRowCount();\n+        index.getDatabase().setProgress(DatabaseEventListener.STATE_SCAN_FILE,\n+            index.getTable() + \".\" + index.getName(), count, Integer.MAX_VALUE);\n+      }\n+      rowCount = count;\n     }\n-\n-    @Override\n-    PageDataLeaf getFirstLeaf() {\n-        int child = childPageIds[0];\n-        return index.getPage(child, getPos()).getFirstLeaf();\n+    return rowCount;\n+  }\n+\n+  @Override\n+  long getDiskSpaceUsed() {\n+    long count = 0;\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      int child = childPageIds[i];\n+      PageData page = index.getPage(child, getPos());\n+      if (getPos() == page.getPos()) {\n+        throw DbException.throwInternalError(\"Page is its own child: \" + getPos());\n+      }\n+      count += page.getDiskSpaceUsed();\n+      index.getDatabase().setProgress(DatabaseEventListener.STATE_SCAN_FILE,\n+          index.getTable() + \".\" + index.getName(),\n+          (int) (count >> 16), Integer.MAX_VALUE);\n     }\n-\n-    @Override\n-    boolean remove(long key) {\n-        int at = find(key);\n-        // merge is not implemented to allow concurrent usage\n-        // TODO maybe implement merge\n-        PageData page = index.getPage(childPageIds[at], getPos());\n-        boolean empty = page.remove(key);\n-        index.getPageStore().logUndo(this, data);\n-        updateRowCount(-1);\n-        if (!empty) {\n-            // the first row didn't change - nothing to do\n-            return false;\n-        }\n-        // this child is now empty\n-        index.getPageStore().free(page.getPos());\n-        if (entryCount < 1) {\n-            // no more children - this page is empty as well\n-            return true;\n-        }\n-        removeChild(at);\n-        index.getPageStore().update(this);\n-        return false;\n+    return count;\n+  }\n+\n+  @Override\n+  void setRowCountStored(int rowCount) {\n+    this.rowCount = rowCount;\n+    if (rowCountStored != rowCount) {\n+      rowCountStored = rowCount;\n+      index.getPageStore().logUndo(this, data);\n+      if (written) {\n+        changeCount = index.getPageStore().getChangeCount();\n+        writeHead();\n+      }\n+      index.getPageStore().update(this);\n     }\n-\n-    @Override\n-    void freeRecursive() {\n-        index.getPageStore().logUndo(this, data);\n-        index.getPageStore().free(getPos());\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            int child = childPageIds[i];\n-            index.getPage(child, getPos()).freeRecursive();\n+  }\n+\n+  private void check() {\n+    if (SysProperties.CHECK) {\n+      for (int i = 0; i < entryCount + 1; i++) {\n+        int child = childPageIds[i];\n+        if (child == 0) {\n+          DbException.throwInternalError();\n         }\n+      }\n     }\n-\n-    @Override\n-    Row getRowWithKey(long key) {\n-        int at = find(key);\n-        PageData page = index.getPage(childPageIds[at], getPos());\n-        return page.getRowWithKey(key);\n+  }\n+\n+  @Override\n+  public void write() {\n+    writeData();\n+    index.getPageStore().writePage(getPos(), data);\n+  }\n+\n+  private void writeHead() {\n+    data.reset();\n+    data.writeByte((byte) Page.TYPE_DATA_NODE);\n+    data.writeShortInt(0);\n+    if (SysProperties.CHECK2) {\n+      if (data.length() != START_PARENT) {\n+        DbException.throwInternalError();\n+      }\n     }\n-\n-    @Override\n-    int getRowCount() {\n-        if (rowCount == UNKNOWN_ROWCOUNT) {\n-            int count = 0;\n-            for (int i = 0; i < entryCount + 1; i++) {\n-                int child = childPageIds[i];\n-                PageData page = index.getPage(child, getPos());\n-                if (getPos() == page.getPos()) {\n-                    throw DbException.throwInternalError(\"Page is its own child: \" + getPos());\n-                }\n-                count += page.getRowCount();\n-                index.getDatabase().setProgress(DatabaseEventListener.STATE_SCAN_FILE,\n-                        index.getTable() + \".\" + index.getName(), count, Integer.MAX_VALUE);\n-            }\n-            rowCount = count;\n-        }\n-        return rowCount;\n+    data.writeInt(parentPageId);\n+    data.writeVarInt(index.getId());\n+    data.writeInt(rowCountStored);\n+    data.writeShortInt(entryCount);\n+  }\n+\n+  private void writeData() {\n+    if (written) {\n+      return;\n     }\n-\n-    @Override\n-    long getDiskSpaceUsed() {\n-        long count = 0;\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            int child = childPageIds[i];\n-            PageData page = index.getPage(child, getPos());\n-            if (getPos() == page.getPos()) {\n-                throw DbException.throwInternalError(\"Page is its own child: \" + getPos());\n-            }\n-            count += page.getDiskSpaceUsed();\n-            index.getDatabase().setProgress(DatabaseEventListener.STATE_SCAN_FILE,\n-                    index.getTable() + \".\" + index.getName(),\n-                    (int) (count >> 16), Integer.MAX_VALUE);\n-        }\n-        return count;\n+    check();\n+    writeHead();\n+    data.writeInt(childPageIds[entryCount]);\n+    for (int i = 0; i < entryCount; i++) {\n+      data.writeInt(childPageIds[i]);\n+      data.writeVarLong(keys[i]);\n     }\n-\n-    @Override\n-    void setRowCountStored(int rowCount) {\n-        this.rowCount = rowCount;\n-        if (rowCountStored != rowCount) {\n-            rowCountStored = rowCount;\n-            index.getPageStore().logUndo(this, data);\n-            if (written) {\n-                changeCount = index.getPageStore().getChangeCount();\n-                writeHead();\n-            }\n-            index.getPageStore().update(this);\n-        }\n+    if (length != data.length()) {\n+      DbException.throwInternalError(\"expected pos: \" + length +\n+          \" got: \" + data.length());\n     }\n-\n-    private void check() {\n-        if (SysProperties.CHECK) {\n-            for (int i = 0; i < entryCount + 1; i++) {\n-                int child = childPageIds[i];\n-                if (child == 0) {\n-                    DbException.throwInternalError();\n-                }\n-            }\n-        }\n+    written = true;\n+  }\n+\n+  private void removeChild(int i) {\n+    index.getPageStore().logUndo(this, data);\n+    written = false;\n+    changeCount = index.getPageStore().getChangeCount();\n+    int removedKeyIndex = i < entryCount ? i : i - 1;\n+    entryCount--;\n+    length -= 4 + Data.getVarLongLen(keys[removedKeyIndex]);\n+    if (entryCount < 0) {\n+      DbException.throwInternalError(\"\" + entryCount);\n     }\n-\n-    @Override\n-    public void write() {\n-        writeData();\n-        index.getPageStore().writePage(getPos(), data);\n+    keys = remove(keys, entryCount + 1, removedKeyIndex);\n+    childPageIds = remove(childPageIds, entryCount + 2, i);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"page[\" + getPos() + \"] data node table:\" + index.getId() +\n+        \" entries:\" + entryCount + \" \" + Arrays.toString(childPageIds);\n+  }\n+\n+  @Override\n+  public void moveTo(Session session, int newPos) {\n+    PageStore store = index.getPageStore();\n+    // load the pages into the cache, to ensure old pages\n+    // are written\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      int child = childPageIds[i];\n+      store.getPage(child);\n     }\n-\n-    private void writeHead() {\n-        data.reset();\n-        data.writeByte((byte) Page.TYPE_DATA_NODE);\n-        data.writeShortInt(0);\n-        if (SysProperties.CHECK2) {\n-            if (data.length() != START_PARENT) {\n-                DbException.throwInternalError();\n-            }\n-        }\n-        data.writeInt(parentPageId);\n-        data.writeVarInt(index.getId());\n-        data.writeInt(rowCountStored);\n-        data.writeShortInt(entryCount);\n+    if (parentPageId != ROOT) {\n+      store.getPage(parentPageId);\n     }\n-\n-    private void writeData() {\n-        if (written) {\n-            return;\n-        }\n-        check();\n-        writeHead();\n-        data.writeInt(childPageIds[entryCount]);\n-        for (int i = 0; i < entryCount; i++) {\n-            data.writeInt(childPageIds[i]);\n-            data.writeVarLong(keys[i]);\n-        }\n-        if (length != data.length()) {\n-            DbException.throwInternalError(\"expected pos: \" + length +\n-                    \" got: \" + data.length());\n-        }\n-        written = true;\n+    store.logUndo(this, data);\n+    PageDataNode p2 = PageDataNode.create(index, newPos, parentPageId);\n+    p2.rowCountStored = rowCountStored;\n+    p2.rowCount = rowCount;\n+    p2.childPageIds = childPageIds;\n+    p2.keys = keys;\n+    p2.entryCount = entryCount;\n+    p2.length = length;\n+    store.update(p2);\n+    if (parentPageId == ROOT) {\n+      index.setRootPageId(session, newPos);\n+    } else {\n+      PageDataNode p = (PageDataNode) store.getPage(parentPageId);\n+      p.moveChild(getPos(), newPos);\n     }\n-\n-    private void removeChild(int i) {\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      int child = childPageIds[i];\n+      PageData p = (PageData) store.getPage(child);\n+      p.setParentPageId(newPos);\n+      store.update(p);\n+    }\n+    store.free(getPos());\n+  }\n+\n+  /**\n+   * One of the children has moved to another page.\n+   *\n+   * @param oldPos the old position\n+   * @param newPos the new position\n+   */\n+  void moveChild(int oldPos, int newPos) {\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      if (childPageIds[i] == oldPos) {\n         index.getPageStore().logUndo(this, data);\n         written = false;\n         changeCount = index.getPageStore().getChangeCount();\n-        int removedKeyIndex = i < entryCount ? i : i - 1;\n-        entryCount--;\n-        length -= 4 + Data.getVarLongLen(keys[removedKeyIndex]);\n-        if (entryCount < 0) {\n-            DbException.throwInternalError(\"\" + entryCount);\n-        }\n-        keys = remove(keys, entryCount + 1, removedKeyIndex);\n-        childPageIds = remove(childPageIds, entryCount + 2, i);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"page[\" + getPos() + \"] data node table:\" + index.getId() +\n-            \" entries:\" + entryCount + \" \" + Arrays.toString(childPageIds);\n-    }\n-\n-    @Override\n-    public void moveTo(Session session, int newPos) {\n-        PageStore store = index.getPageStore();\n-        // load the pages into the cache, to ensure old pages\n-        // are written\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            int child = childPageIds[i];\n-            store.getPage(child);\n-        }\n-        if (parentPageId != ROOT) {\n-            store.getPage(parentPageId);\n-        }\n-        store.logUndo(this, data);\n-        PageDataNode p2 = PageDataNode.create(index, newPos, parentPageId);\n-        p2.rowCountStored = rowCountStored;\n-        p2.rowCount = rowCount;\n-        p2.childPageIds = childPageIds;\n-        p2.keys = keys;\n-        p2.entryCount = entryCount;\n-        p2.length = length;\n-        store.update(p2);\n-        if (parentPageId == ROOT) {\n-            index.setRootPageId(session, newPos);\n-        } else {\n-            PageDataNode p = (PageDataNode) store.getPage(parentPageId);\n-            p.moveChild(getPos(), newPos);\n-        }\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            int child = childPageIds[i];\n-            PageData p = (PageData) store.getPage(child);\n-            p.setParentPageId(newPos);\n-            store.update(p);\n-        }\n-        store.free(getPos());\n-    }\n-\n-    /**\n-     * One of the children has moved to another page.\n-     *\n-     * @param oldPos the old position\n-     * @param newPos the new position\n-     */\n-    void moveChild(int oldPos, int newPos) {\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            if (childPageIds[i] == oldPos) {\n-                index.getPageStore().logUndo(this, data);\n-                written = false;\n-                changeCount = index.getPageStore().getChangeCount();\n-                childPageIds[i] = newPos;\n-                index.getPageStore().update(this);\n-                return;\n-            }\n-        }\n-        throw DbException.throwInternalError(oldPos + \" \" + newPos);\n+        childPageIds[i] = newPos;\n+        index.getPageStore().update(this);\n+        return;\n+      }\n     }\n+    throw DbException.throwInternalError(oldPos + \" \" + newPos);\n+  }\n \n }\n",
            "diff_size": 548
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/165/PageDataNode.java\nindex 6ff79ac9ed0..33cf5d5315d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/165/PageDataNode.java\n@@ -172,7 +172,7 @@ public class PageDataNode extends PageData {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataNode p2 = PageDataNode.create(index, newPageId, parentPageId);\n         int firstChild = childPageIds[splitPoint];\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], keys[splitPoint]);\n             removeChild(splitPoint);\n         }\n@@ -456,4 +456,4 @@ public class PageDataNode extends PageData {\n         throw DbException.throwInternalError(oldPos + \" \" + newPos);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/165/PageDataNode.java\nindex 6ff79ac9ed0..86bcc11f62d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/165/PageDataNode.java\n@@ -32,15 +32,16 @@ import org.h2.util.Utils;\n  * The key is the largest key of the respective child, meaning key[0] is the\n  * largest key of child[0].\n  */\n+\n+\n public class PageDataNode extends PageData {\n \n     /**\n      * The page ids of the children.\n      */\n-    private int[] childPageIds;\n \n+    private int[] childPageIds;\n     private int rowCountStored = UNKNOWN_ROWCOUNT;\n-\n     private int rowCount = UNKNOWN_ROWCOUNT;\n \n     /**\n@@ -60,9 +61,10 @@ public class PageDataNode extends PageData {\n      * @param parentPageId the parent\n      * @return the page\n      */\n+\n+\n     static PageDataNode create(PageDataIndex index, int pageId, int parentPageId) {\n-        PageDataNode p = new PageDataNode(index, pageId,\n-                index.getPageStore().createData());\n+        PageDataNode p = new PageDataNode(index, pageId, index.getPageStore().createData());\n         index.getPageStore().logUndo(p, null);\n         p.parentPageId = parentPageId;\n         p.writeHead();\n@@ -79,6 +81,8 @@ public class PageDataNode extends PageData {\n      * @param pageId the page id\n      * @return the page\n      */\n+\n+\n     public static Page read(PageDataIndex index, Data data, int pageId) {\n         PageDataNode p = new PageDataNode(index, pageId, data);\n         p.read();\n@@ -92,9 +96,8 @@ public class PageDataNode extends PageData {\n         this.parentPageId = data.readInt();\n         int indexId = data.readVarInt();\n         if (indexId != index.getId()) {\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                    \"page:\" + getPos() + \" expected index:\" + index.getId() +\n-                    \"got:\" + indexId);\n+            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"page:\" + getPos() + \" expected index:\"\n+            + index.getId() + \"got:\" + indexId);\n         }\n         rowCount = rowCountStored = data.readInt();\n         entryCount = data.readShortInt();\n@@ -163,8 +166,7 @@ public class PageDataNode extends PageData {\n     Cursor find(Session session, long minKey, long maxKey, boolean multiVersion) {\n         int x = find(minKey);\n         int child = childPageIds[x];\n-        return index.getPage(child, getPos()).find(session, minKey, maxKey,\n-                multiVersion);\n+        return index.getPage(child, getPos()).find(session, minKey, maxKey, multiVersion);\n     }\n \n     @Override\n@@ -172,7 +174,7 @@ public class PageDataNode extends PageData {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataNode p2 = PageDataNode.create(index, newPageId, parentPageId);\n         int firstChild = childPageIds[splitPoint];\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], keys[splitPoint]);\n             removeChild(splitPoint);\n         }\n@@ -201,6 +203,8 @@ public class PageDataNode extends PageData {\n      * @param pivot the pivot key\n      * @param page2 the last child page\n      */\n+\n+\n     void init(PageData page1, long pivot, PageData page2) {\n         entryCount = 1;\n         childPageIds = new int[] { page1.getPos(), page2.getPos() };\n@@ -220,6 +224,8 @@ public class PageDataNode extends PageData {\n      * @param key the last key of the current page\n      * @return the next leaf page\n      */\n+\n+\n     PageDataLeaf getNextPage(long key) {\n         int i = find(key) + 1;\n         if (i > entryCount) {\n@@ -291,8 +297,7 @@ public class PageDataNode extends PageData {\n                     throw DbException.throwInternalError(\"Page is its own child: \" + getPos());\n                 }\n                 count += page.getRowCount();\n-                index.getDatabase().setProgress(DatabaseEventListener.STATE_SCAN_FILE,\n-                        index.getTable() + \".\" + index.getName(), count, Integer.MAX_VALUE);\n+                index.getDatabase().setProgress(DatabaseEventListener.STATE_SCAN_FILE, index.getTable() + \".\" + index.getName(), count, Integer.MAX_VALUE);\n             }\n             rowCount = count;\n         }\n@@ -309,9 +314,7 @@ public class PageDataNode extends PageData {\n                 throw DbException.throwInternalError(\"Page is its own child: \" + getPos());\n             }\n             count += page.getDiskSpaceUsed();\n-            index.getDatabase().setProgress(DatabaseEventListener.STATE_SCAN_FILE,\n-                    index.getTable() + \".\" + index.getName(),\n-                    (int) (count >> 16), Integer.MAX_VALUE);\n+            index.getDatabase().setProgress(DatabaseEventListener.STATE_SCAN_FILE, index.getTable() + \".\" + index.getName(), (int) (count >> 16), Integer.MAX_VALUE);\n         }\n         return count;\n     }\n@@ -374,8 +377,7 @@ public class PageDataNode extends PageData {\n             data.writeVarLong(keys[i]);\n         }\n         if (length != data.length()) {\n-            DbException.throwInternalError(\"expected pos: \" + length +\n-                    \" got: \" + data.length());\n+            DbException.throwInternalError(\"expected pos: \" + length + \" got: \" + data.length());\n         }\n         written = true;\n     }\n@@ -396,8 +398,9 @@ public class PageDataNode extends PageData {\n \n     @Override\n     public String toString() {\n-        return \"page[\" + getPos() + \"] data node table:\" + index.getId() +\n-            \" entries:\" + entryCount + \" \" + Arrays.toString(childPageIds);\n+        return \"page[\" + getPos() + \"] data node table:\"\n+        + index.getId() + \" entries:\"\n+        + entryCount + \" \" + Arrays.toString(childPageIds);\n     }\n \n     @Override\n@@ -442,6 +445,8 @@ public class PageDataNode extends PageData {\n      * @param oldPos the old position\n      * @param newPos the new position\n      */\n+\n+\n     void moveChild(int oldPos, int newPos) {\n         for (int i = 0; i < entryCount + 1; i++) {\n             if (childPageIds[i] == oldPos) {\n@@ -456,4 +461,4 @@ public class PageDataNode extends PageData {\n         throw DbException.throwInternalError(oldPos + \" \" + newPos);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 34
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/165/PageDataNode.java\nindex 6ff79ac9ed0..c7067f12478 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/165/PageDataNode.java\n@@ -172,7 +172,7 @@ public class PageDataNode extends PageData {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataNode p2 = PageDataNode.create(index, newPageId, parentPageId);\n         int firstChild = childPageIds[splitPoint];\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], keys[splitPoint]);\n             removeChild(splitPoint);\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/165/PageDataNode.java\nindex 6ff79ac9ed0..c7067f12478 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/165/PageDataNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/165/PageDataNode.java\n@@ -172,7 +172,7 @@ public class PageDataNode extends PageData {\n         int newPageId = index.getPageStore().allocatePage();\n         PageDataNode p2 = PageDataNode.create(index, newPageId, parentPageId);\n         int firstChild = childPageIds[splitPoint];\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], keys[splitPoint]);\n             removeChild(splitPoint);\n         }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij"
    ]
}