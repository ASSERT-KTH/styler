{
    "project_name": "codefollower-H2-Research",
    "error_id": "229",
    "information": {
        "errors": [
            {
                "line": "217",
                "column": "40",
                "severity": "warning",
                "message": "'{' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "                f.read(b);\n            }\n        } catch (IOException ignoreEx) {}\n        return FileUtils.lastModified(fileName);\n    }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/229/FileLock.java\nindex ab1b93fbd83..53c7718e1b2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/229/FileLock.java\n@@ -214,7 +214,7 @@ public class FileLock implements Runnable {\n                 ByteBuffer b = ByteBuffer.wrap(new byte[1]);\n                 f.read(b);\n             }\n-        } catch (IOException ignoreEx) {}\n+        } catch (IOException ignoreEx) {  }\n         return FileUtils.lastModified(fileName);\n     }\n \n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/229/FileLock.java\nindex ab1b93fbd83..6a1faa8007b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/229/FileLock.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.store;\n \n import java.io.IOException;\n@@ -17,6 +18,7 @@ import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n import java.nio.file.Paths;\n import java.util.Properties;\n+\n import org.h2.Driver;\n import org.h2.api.ErrorCode;\n import org.h2.engine.Constants;\n@@ -38,476 +40,477 @@ import org.h2.value.Transfer;\n  */\n public class FileLock implements Runnable {\n \n-    private static final String MAGIC = \"FileLock\";\n-    private static final String FILE = \"file\";\n-    private static final String SOCKET = \"socket\";\n-    private static final int RANDOM_BYTES = 16;\n-    private static final int SLEEP_GAP = 25;\n-    private static final int TIME_GRANULARITY = 2000;\n+  private static final String MAGIC = \"FileLock\";\n+  private static final String FILE = \"file\";\n+  private static final String SOCKET = \"socket\";\n+  private static final int RANDOM_BYTES = 16;\n+  private static final int SLEEP_GAP = 25;\n+  private static final int TIME_GRANULARITY = 2000;\n \n-    /**\n-     * The lock file name.\n-     */\n-    private volatile String fileName;\n+  /**\n+   * The lock file name.\n+   */\n+  private volatile String fileName;\n \n-    /**\n-     * The server socket (only used when using the SOCKET mode).\n-     */\n-    private volatile ServerSocket serverSocket;\n+  /**\n+   * The server socket (only used when using the SOCKET mode).\n+   */\n+  private volatile ServerSocket serverSocket;\n \n-    /**\n-     * Whether the file is locked.\n-     */\n-    private volatile boolean locked;\n+  /**\n+   * Whether the file is locked.\n+   */\n+  private volatile boolean locked;\n \n-    /**\n-     * The number of milliseconds to sleep after checking a file.\n-     */\n-    private final int sleep;\n+  /**\n+   * The number of milliseconds to sleep after checking a file.\n+   */\n+  private final int sleep;\n \n-    /**\n-     * The trace object.\n-     */\n-    private final Trace trace;\n+  /**\n+   * The trace object.\n+   */\n+  private final Trace trace;\n \n-    /**\n-     * The last time the lock file was written.\n-     */\n-    private long lastWrite;\n+  /**\n+   * The last time the lock file was written.\n+   */\n+  private long lastWrite;\n \n-    private String method;\n-    private Properties properties;\n-    private String uniqueId;\n-    private Thread watchdog;\n+  private String method;\n+  private Properties properties;\n+  private String uniqueId;\n+  private Thread watchdog;\n \n-    /**\n-     * Create a new file locking object.\n-     *\n-     * @param traceSystem the trace system to use\n-     * @param fileName the file name\n-     * @param sleep the number of milliseconds to sleep\n-     */\n-    public FileLock(TraceSystem traceSystem, String fileName, int sleep) {\n-        this.trace = traceSystem == null ?\n-                null : traceSystem.getTrace(Trace.FILE_LOCK);\n-        this.fileName = fileName;\n-        this.sleep = sleep;\n-    }\n+  /**\n+   * Create a new file locking object.\n+   *\n+   * @param traceSystem the trace system to use\n+   * @param fileName    the file name\n+   * @param sleep       the number of milliseconds to sleep\n+   */\n+  public FileLock(TraceSystem traceSystem, String fileName, int sleep) {\n+    this.trace = traceSystem == null ?\n+        null : traceSystem.getTrace(Trace.FILE_LOCK);\n+    this.fileName = fileName;\n+    this.sleep = sleep;\n+  }\n \n-    /**\n-     * Lock the file if possible. A file may only be locked once.\n-     *\n-     * @param fileLockMethod the file locking method to use\n-     * @throws DbException if locking was not successful\n-     */\n-    public synchronized void lock(FileLockMethod fileLockMethod) {\n-        checkServer();\n-        if (locked) {\n-            DbException.throwInternalError(\"already locked\");\n-        }\n-        switch (fileLockMethod) {\n-        case FILE:\n-            lockFile();\n-            break;\n-        case SOCKET:\n-            lockSocket();\n-            break;\n-        case FS:\n-        case NO:\n-            break;\n-        }\n-        locked = true;\n+  /**\n+   * Lock the file if possible. A file may only be locked once.\n+   *\n+   * @param fileLockMethod the file locking method to use\n+   * @throws DbException if locking was not successful\n+   */\n+  public synchronized void lock(FileLockMethod fileLockMethod) {\n+    checkServer();\n+    if (locked) {\n+      DbException.throwInternalError(\"already locked\");\n     }\n-\n-    /**\n-     * Unlock the file. The watchdog thread is stopped. This method does nothing\n-     * if the file is already unlocked.\n-     */\n-    public synchronized void unlock() {\n-        if (!locked) {\n-            return;\n-        }\n-        locked = false;\n-        try {\n-            if (watchdog != null) {\n-                watchdog.interrupt();\n-            }\n-        } catch (Exception e) {\n-            trace.debug(e, \"unlock\");\n-        }\n-        try {\n-            if (fileName != null) {\n-                if (load().equals(properties)) {\n-                    FileUtils.delete(fileName);\n-                }\n-            }\n-            if (serverSocket != null) {\n-                serverSocket.close();\n-            }\n-        } catch (Exception e) {\n-            trace.debug(e, \"unlock\");\n-        } finally {\n-            fileName = null;\n-            serverSocket = null;\n-        }\n-        try {\n-            if (watchdog != null) {\n-                watchdog.join();\n-            }\n-        } catch (Exception e) {\n-            trace.debug(e, \"unlock\");\n-        } finally {\n-            watchdog = null;\n-        }\n+    switch (fileLockMethod) {\n+      case FILE:\n+        lockFile();\n+        break;\n+      case SOCKET:\n+        lockSocket();\n+        break;\n+      case FS:\n+      case NO:\n+        break;\n     }\n+    locked = true;\n+  }\n \n-    /**\n-     * Add or change a setting to the properties. This call does not save the\n-     * file.\n-     *\n-     * @param key the key\n-     * @param value the value\n-     */\n-    public void setProperty(String key, String value) {\n-        if (value == null) {\n-            properties.remove(key);\n-        } else {\n-            properties.put(key, value);\n-        }\n+  /**\n+   * Unlock the file. The watchdog thread is stopped. This method does nothing\n+   * if the file is already unlocked.\n+   */\n+  public synchronized void unlock() {\n+    if (!locked) {\n+      return;\n     }\n-\n-    /**\n-     * Save the lock file.\n-     *\n-     * @return the saved properties\n-     */\n-    public Properties save() {\n-        try {\n-            try (OutputStream out = FileUtils.newOutputStream(fileName, false)) {\n-                properties.store(out, MAGIC);\n-            }\n-            lastWrite = aggressiveLastModified(fileName);\n-            if (trace.isDebugEnabled()) {\n-                trace.debug(\"save \" + properties);\n-            }\n-            return properties;\n-        } catch (IOException e) {\n-            throw getExceptionFatal(\"Could not save properties \" + fileName, e);\n+    locked = false;\n+    try {\n+      if (watchdog != null) {\n+        watchdog.interrupt();\n+      }\n+    } catch (Exception e) {\n+      trace.debug(e, \"unlock\");\n+    }\n+    try {\n+      if (fileName != null) {\n+        if (load().equals(properties)) {\n+          FileUtils.delete(fileName);\n         }\n+      }\n+      if (serverSocket != null) {\n+        serverSocket.close();\n+      }\n+    } catch (Exception e) {\n+      trace.debug(e, \"unlock\");\n+    } finally {\n+      fileName = null;\n+      serverSocket = null;\n+    }\n+    try {\n+      if (watchdog != null) {\n+        watchdog.join();\n+      }\n+    } catch (Exception e) {\n+      trace.debug(e, \"unlock\");\n+    } finally {\n+      watchdog = null;\n     }\n+  }\n \n-    /**\n-     * Aggressively read last modified time, to work-around remote filesystems.\n-     *\n-     * @param fileName file name to check\n-     * @return last modified date/time in milliseconds UTC\n-     */\n-    private static long aggressiveLastModified(String fileName) {\n-        /*\n-         * Some remote filesystem, e.g. SMB on Windows, can cache metadata for\n-         * 5-10 seconds. To work around that, do a one-byte read from the\n-         * underlying file, which has the effect of invalidating the metadata\n-         * cache.\n-         */\n-        try {\n-            try (FileChannel f = FileChannel.open(Paths.get(fileName), FileUtils.RWS, FileUtils.NO_ATTRIBUTES);) {\n-                ByteBuffer b = ByteBuffer.wrap(new byte[1]);\n-                f.read(b);\n-            }\n-        } catch (IOException ignoreEx) {}\n-        return FileUtils.lastModified(fileName);\n+  /**\n+   * Add or change a setting to the properties. This call does not save the\n+   * file.\n+   *\n+   * @param key   the key\n+   * @param value the value\n+   */\n+  public void setProperty(String key, String value) {\n+    if (value == null) {\n+      properties.remove(key);\n+    } else {\n+      properties.put(key, value);\n     }\n+  }\n \n-    private void checkServer() {\n-        Properties prop = load();\n-        String server = prop.getProperty(\"server\");\n-        if (server == null) {\n-            return;\n-        }\n-        boolean running = false;\n-        String id = prop.getProperty(\"id\");\n-        try {\n-            Socket socket = NetUtils.createSocket(server,\n-                    Constants.DEFAULT_TCP_PORT, false);\n-            Transfer transfer = new Transfer(null, socket);\n-            transfer.init();\n-            transfer.writeInt(Constants.TCP_PROTOCOL_VERSION_MIN_SUPPORTED);\n-            transfer.writeInt(Constants.TCP_PROTOCOL_VERSION_MAX_SUPPORTED);\n-            transfer.writeString(null);\n-            transfer.writeString(null);\n-            transfer.writeString(id);\n-            transfer.writeInt(SessionRemote.SESSION_CHECK_KEY);\n-            transfer.flush();\n-            int state = transfer.readInt();\n-            if (state == SessionRemote.STATUS_OK) {\n-                running = true;\n-            }\n-            transfer.close();\n-            socket.close();\n-        } catch (IOException e) {\n-            return;\n-        }\n-        if (running) {\n-            DbException e = DbException.get(\n-                    ErrorCode.DATABASE_ALREADY_OPEN_1, \"Server is running\");\n-            throw e.addSQL(server + \"/\" + id);\n-        }\n+  /**\n+   * Save the lock file.\n+   *\n+   * @return the saved properties\n+   */\n+  public Properties save() {\n+    try {\n+      try (OutputStream out = FileUtils.newOutputStream(fileName, false)) {\n+        properties.store(out, MAGIC);\n+      }\n+      lastWrite = aggressiveLastModified(fileName);\n+      if (trace.isDebugEnabled()) {\n+        trace.debug(\"save \" + properties);\n+      }\n+      return properties;\n+    } catch (IOException e) {\n+      throw getExceptionFatal(\"Could not save properties \" + fileName, e);\n     }\n+  }\n \n-    /**\n-     * Load the properties file.\n-     *\n-     * @return the properties\n+  /**\n+   * Aggressively read last modified time, to work-around remote filesystems.\n+   *\n+   * @param fileName file name to check\n+   * @return last modified date/time in milliseconds UTC\n+   */\n+  private static long aggressiveLastModified(String fileName) {\n+    /*\n+     * Some remote filesystem, e.g. SMB on Windows, can cache metadata for\n+     * 5-10 seconds. To work around that, do a one-byte read from the\n+     * underlying file, which has the effect of invalidating the metadata\n+     * cache.\n      */\n-    public Properties load() {\n-        IOException lastException = null;\n-        for (int i = 0; i < 5; i++) {\n-            try {\n-                Properties p2 = SortedProperties.loadProperties(fileName);\n-                if (trace.isDebugEnabled()) {\n-                    trace.debug(\"load \" + p2);\n-                }\n-                return p2;\n-            } catch (IOException e) {\n-                lastException = e;\n-            }\n-        }\n-        throw getExceptionFatal(\n-                \"Could not load properties \" + fileName, lastException);\n+    try {\n+      try (FileChannel f = FileChannel.open(Paths.get(fileName), FileUtils.RWS, FileUtils.NO_ATTRIBUTES);) {\n+        ByteBuffer b = ByteBuffer.wrap(new byte[1]);\n+        f.read(b);\n+      }\n+    } catch (IOException ignoreEx) {\n     }\n+    return FileUtils.lastModified(fileName);\n+  }\n \n-    private void waitUntilOld() {\n-        for (int i = 0; i < 2 * TIME_GRANULARITY / SLEEP_GAP; i++) {\n-            long last = aggressiveLastModified(fileName);\n-            long dist = System.currentTimeMillis() - last;\n-            if (dist < -TIME_GRANULARITY) {\n-                // lock file modified in the future -\n-                // wait for a bit longer than usual\n-                try {\n-                    Thread.sleep(2 * (long) sleep);\n-                } catch (Exception e) {\n-                    trace.debug(e, \"sleep\");\n-                }\n-                return;\n-            } else if (dist > TIME_GRANULARITY) {\n-                return;\n-            }\n-            try {\n-                Thread.sleep(SLEEP_GAP);\n-            } catch (Exception e) {\n-                trace.debug(e, \"sleep\");\n-            }\n-        }\n-        throw getExceptionFatal(\"Lock file recently modified\", null);\n+  private void checkServer() {\n+    Properties prop = load();\n+    String server = prop.getProperty(\"server\");\n+    if (server == null) {\n+      return;\n     }\n-\n-    private void setUniqueId() {\n-        byte[] bytes = MathUtils.secureRandomBytes(RANDOM_BYTES);\n-        String random = StringUtils.convertBytesToHex(bytes);\n-        uniqueId = Long.toHexString(System.currentTimeMillis()) + random;\n-        properties.setProperty(\"id\", uniqueId);\n+    boolean running = false;\n+    String id = prop.getProperty(\"id\");\n+    try {\n+      Socket socket = NetUtils.createSocket(server,\n+          Constants.DEFAULT_TCP_PORT, false);\n+      Transfer transfer = new Transfer(null, socket);\n+      transfer.init();\n+      transfer.writeInt(Constants.TCP_PROTOCOL_VERSION_MIN_SUPPORTED);\n+      transfer.writeInt(Constants.TCP_PROTOCOL_VERSION_MAX_SUPPORTED);\n+      transfer.writeString(null);\n+      transfer.writeString(null);\n+      transfer.writeString(id);\n+      transfer.writeInt(SessionRemote.SESSION_CHECK_KEY);\n+      transfer.flush();\n+      int state = transfer.readInt();\n+      if (state == SessionRemote.STATUS_OK) {\n+        running = true;\n+      }\n+      transfer.close();\n+      socket.close();\n+    } catch (IOException e) {\n+      return;\n+    }\n+    if (running) {\n+      DbException e = DbException.get(\n+          ErrorCode.DATABASE_ALREADY_OPEN_1, \"Server is running\");\n+      throw e.addSQL(server + \"/\" + id);\n     }\n+  }\n \n-    private void lockFile() {\n-        method = FILE;\n-        properties = new SortedProperties();\n-        properties.setProperty(\"method\", String.valueOf(method));\n-        setUniqueId();\n-        FileUtils.createDirectories(FileUtils.getParent(fileName));\n-        if (!FileUtils.createFile(fileName)) {\n-            waitUntilOld();\n-            String m2 = load().getProperty(\"method\", FILE);\n-            if (!m2.equals(FILE)) {\n-                throw getExceptionFatal(\"Unsupported lock method \" + m2, null);\n-            }\n-            save();\n-            sleep(2 * sleep);\n-            if (!load().equals(properties)) {\n-                throw getExceptionAlreadyInUse(\"Locked by another process: \" + fileName);\n-            }\n-            FileUtils.delete(fileName);\n-            if (!FileUtils.createFile(fileName)) {\n-                throw getExceptionFatal(\"Another process was faster\", null);\n-            }\n-        }\n-        save();\n-        sleep(SLEEP_GAP);\n-        if (!load().equals(properties)) {\n-            fileName = null;\n-            throw getExceptionFatal(\"Concurrent update\", null);\n+  /**\n+   * Load the properties file.\n+   *\n+   * @return the properties\n+   */\n+  public Properties load() {\n+    IOException lastException = null;\n+    for (int i = 0; i < 5; i++) {\n+      try {\n+        Properties p2 = SortedProperties.loadProperties(fileName);\n+        if (trace.isDebugEnabled()) {\n+          trace.debug(\"load \" + p2);\n         }\n-        locked = true;\n-        watchdog = new Thread(this, \"H2 File Lock Watchdog \" + fileName);\n-        Driver.setThreadContextClassLoader(watchdog);\n-        watchdog.setDaemon(true);\n-        watchdog.setPriority(Thread.MAX_PRIORITY - 1);\n-        watchdog.start();\n+        return p2;\n+      } catch (IOException e) {\n+        lastException = e;\n+      }\n     }\n+    throw getExceptionFatal(\n+        \"Could not load properties \" + fileName, lastException);\n+  }\n \n-    private void lockSocket() {\n-        method = SOCKET;\n-        properties = new SortedProperties();\n-        properties.setProperty(\"method\", String.valueOf(method));\n-        setUniqueId();\n-        // if this returns 127.0.0.1,\n-        // the computer is probably not networked\n-        String ipAddress = NetUtils.getLocalAddress();\n-        FileUtils.createDirectories(FileUtils.getParent(fileName));\n-        if (!FileUtils.createFile(fileName)) {\n-            waitUntilOld();\n-            long read = aggressiveLastModified(fileName);\n-            Properties p2 = load();\n-            String m2 = p2.getProperty(\"method\", SOCKET);\n-            if (m2.equals(FILE)) {\n-                lockFile();\n-                return;\n-            } else if (!m2.equals(SOCKET)) {\n-                throw getExceptionFatal(\"Unsupported lock method \" + m2, null);\n-            }\n-            String ip = p2.getProperty(\"ipAddress\", ipAddress);\n-            if (!ipAddress.equals(ip)) {\n-                throw getExceptionAlreadyInUse(\"Locked by another computer: \" + ip);\n-            }\n-            String port = p2.getProperty(\"port\", \"0\");\n-            int portId = Integer.parseInt(port);\n-            InetAddress address;\n-            try {\n-                address = InetAddress.getByName(ip);\n-            } catch (UnknownHostException e) {\n-                throw getExceptionFatal(\"Unknown host \" + ip, e);\n-            }\n-            for (int i = 0; i < 3; i++) {\n-                try {\n-                    Socket s = new Socket(address, portId);\n-                    s.close();\n-                    throw getExceptionAlreadyInUse(\"Locked by another process\");\n-                } catch (BindException e) {\n-                    throw getExceptionFatal(\"Bind Exception\", null);\n-                } catch (ConnectException e) {\n-                    trace.debug(e, \"socket not connected to port \" + port);\n-                } catch (IOException e) {\n-                    throw getExceptionFatal(\"IOException\", null);\n-                }\n-            }\n-            if (read != aggressiveLastModified(fileName)) {\n-                throw getExceptionFatal(\"Concurrent update\", null);\n-            }\n-            FileUtils.delete(fileName);\n-            if (!FileUtils.createFile(fileName)) {\n-                throw getExceptionFatal(\"Another process was faster\", null);\n-            }\n-        }\n+  private void waitUntilOld() {\n+    for (int i = 0; i < 2 * TIME_GRANULARITY / SLEEP_GAP; i++) {\n+      long last = aggressiveLastModified(fileName);\n+      long dist = System.currentTimeMillis() - last;\n+      if (dist < -TIME_GRANULARITY) {\n+        // lock file modified in the future -\n+        // wait for a bit longer than usual\n         try {\n-            // 0 to use any free port\n-            serverSocket = NetUtils.createServerSocket(0, false);\n-            int port = serverSocket.getLocalPort();\n-            properties.setProperty(\"ipAddress\", ipAddress);\n-            properties.setProperty(\"port\", Integer.toString(port));\n+          Thread.sleep(2 * (long) sleep);\n         } catch (Exception e) {\n-            trace.debug(e, \"lock\");\n-            serverSocket = null;\n-            lockFile();\n-            return;\n+          trace.debug(e, \"sleep\");\n         }\n-        save();\n-        locked = true;\n-        watchdog = new Thread(this,\n-                \"H2 File Lock Watchdog (Socket) \" + fileName);\n-        watchdog.setDaemon(true);\n-        watchdog.start();\n+        return;\n+      } else if (dist > TIME_GRANULARITY) {\n+        return;\n+      }\n+      try {\n+        Thread.sleep(SLEEP_GAP);\n+      } catch (Exception e) {\n+        trace.debug(e, \"sleep\");\n+      }\n     }\n+    throw getExceptionFatal(\"Lock file recently modified\", null);\n+  }\n+\n+  private void setUniqueId() {\n+    byte[] bytes = MathUtils.secureRandomBytes(RANDOM_BYTES);\n+    String random = StringUtils.convertBytesToHex(bytes);\n+    uniqueId = Long.toHexString(System.currentTimeMillis()) + random;\n+    properties.setProperty(\"id\", uniqueId);\n+  }\n \n-    private static void sleep(int time) {\n+  private void lockFile() {\n+    method = FILE;\n+    properties = new SortedProperties();\n+    properties.setProperty(\"method\", String.valueOf(method));\n+    setUniqueId();\n+    FileUtils.createDirectories(FileUtils.getParent(fileName));\n+    if (!FileUtils.createFile(fileName)) {\n+      waitUntilOld();\n+      String m2 = load().getProperty(\"method\", FILE);\n+      if (!m2.equals(FILE)) {\n+        throw getExceptionFatal(\"Unsupported lock method \" + m2, null);\n+      }\n+      save();\n+      sleep(2 * sleep);\n+      if (!load().equals(properties)) {\n+        throw getExceptionAlreadyInUse(\"Locked by another process: \" + fileName);\n+      }\n+      FileUtils.delete(fileName);\n+      if (!FileUtils.createFile(fileName)) {\n+        throw getExceptionFatal(\"Another process was faster\", null);\n+      }\n+    }\n+    save();\n+    sleep(SLEEP_GAP);\n+    if (!load().equals(properties)) {\n+      fileName = null;\n+      throw getExceptionFatal(\"Concurrent update\", null);\n+    }\n+    locked = true;\n+    watchdog = new Thread(this, \"H2 File Lock Watchdog \" + fileName);\n+    Driver.setThreadContextClassLoader(watchdog);\n+    watchdog.setDaemon(true);\n+    watchdog.setPriority(Thread.MAX_PRIORITY - 1);\n+    watchdog.start();\n+  }\n+\n+  private void lockSocket() {\n+    method = SOCKET;\n+    properties = new SortedProperties();\n+    properties.setProperty(\"method\", String.valueOf(method));\n+    setUniqueId();\n+    // if this returns 127.0.0.1,\n+    // the computer is probably not networked\n+    String ipAddress = NetUtils.getLocalAddress();\n+    FileUtils.createDirectories(FileUtils.getParent(fileName));\n+    if (!FileUtils.createFile(fileName)) {\n+      waitUntilOld();\n+      long read = aggressiveLastModified(fileName);\n+      Properties p2 = load();\n+      String m2 = p2.getProperty(\"method\", SOCKET);\n+      if (m2.equals(FILE)) {\n+        lockFile();\n+        return;\n+      } else if (!m2.equals(SOCKET)) {\n+        throw getExceptionFatal(\"Unsupported lock method \" + m2, null);\n+      }\n+      String ip = p2.getProperty(\"ipAddress\", ipAddress);\n+      if (!ipAddress.equals(ip)) {\n+        throw getExceptionAlreadyInUse(\"Locked by another computer: \" + ip);\n+      }\n+      String port = p2.getProperty(\"port\", \"0\");\n+      int portId = Integer.parseInt(port);\n+      InetAddress address;\n+      try {\n+        address = InetAddress.getByName(ip);\n+      } catch (UnknownHostException e) {\n+        throw getExceptionFatal(\"Unknown host \" + ip, e);\n+      }\n+      for (int i = 0; i < 3; i++) {\n         try {\n-            Thread.sleep(time);\n-        } catch (InterruptedException e) {\n-            throw getExceptionFatal(\"Sleep interrupted\", e);\n+          Socket s = new Socket(address, portId);\n+          s.close();\n+          throw getExceptionAlreadyInUse(\"Locked by another process\");\n+        } catch (BindException e) {\n+          throw getExceptionFatal(\"Bind Exception\", null);\n+        } catch (ConnectException e) {\n+          trace.debug(e, \"socket not connected to port \" + port);\n+        } catch (IOException e) {\n+          throw getExceptionFatal(\"IOException\", null);\n         }\n+      }\n+      if (read != aggressiveLastModified(fileName)) {\n+        throw getExceptionFatal(\"Concurrent update\", null);\n+      }\n+      FileUtils.delete(fileName);\n+      if (!FileUtils.createFile(fileName)) {\n+        throw getExceptionFatal(\"Another process was faster\", null);\n+      }\n     }\n-\n-    private static DbException getExceptionFatal(String reason, Throwable t) {\n-        return DbException.get(\n-                ErrorCode.ERROR_OPENING_DATABASE_1, t, reason);\n+    try {\n+      // 0 to use any free port\n+      serverSocket = NetUtils.createServerSocket(0, false);\n+      int port = serverSocket.getLocalPort();\n+      properties.setProperty(\"ipAddress\", ipAddress);\n+      properties.setProperty(\"port\", Integer.toString(port));\n+    } catch (Exception e) {\n+      trace.debug(e, \"lock\");\n+      serverSocket = null;\n+      lockFile();\n+      return;\n     }\n+    save();\n+    locked = true;\n+    watchdog = new Thread(this,\n+        \"H2 File Lock Watchdog (Socket) \" + fileName);\n+    watchdog.setDaemon(true);\n+    watchdog.start();\n+  }\n \n-    private DbException getExceptionAlreadyInUse(String reason) {\n-        DbException e = DbException.get(\n-                ErrorCode.DATABASE_ALREADY_OPEN_1, reason);\n-        if (fileName != null) {\n-            try {\n-                Properties prop = load();\n-                String server = prop.getProperty(\"server\");\n-                if (server != null) {\n-                    String serverId = server + \"/\" + prop.getProperty(\"id\");\n-                    e = e.addSQL(serverId);\n-                }\n-            } catch (DbException e2) {\n-                // ignore\n-            }\n-        }\n-        return e;\n+  private static void sleep(int time) {\n+    try {\n+      Thread.sleep(time);\n+    } catch (InterruptedException e) {\n+      throw getExceptionFatal(\"Sleep interrupted\", e);\n     }\n+  }\n \n-    /**\n-     * Get the file locking method type given a method name.\n-     *\n-     * @param method the method name\n-     * @return the method type\n-     * @throws DbException if the method name is unknown\n-     */\n-    public static FileLockMethod getFileLockMethod(String method) {\n-        if (method == null || method.equalsIgnoreCase(\"FILE\")) {\n-            return FileLockMethod.FILE;\n-        } else if (method.equalsIgnoreCase(\"NO\")) {\n-            return FileLockMethod.NO;\n-        } else if (method.equalsIgnoreCase(\"SOCKET\")) {\n-            return FileLockMethod.SOCKET;\n-        } else if (method.equalsIgnoreCase(\"FS\")) {\n-            return FileLockMethod.FS;\n-        } else {\n-            throw DbException.get(ErrorCode.UNSUPPORTED_LOCK_METHOD_1, method);\n+  private static DbException getExceptionFatal(String reason, Throwable t) {\n+    return DbException.get(\n+        ErrorCode.ERROR_OPENING_DATABASE_1, t, reason);\n+  }\n+\n+  private DbException getExceptionAlreadyInUse(String reason) {\n+    DbException e = DbException.get(\n+        ErrorCode.DATABASE_ALREADY_OPEN_1, reason);\n+    if (fileName != null) {\n+      try {\n+        Properties prop = load();\n+        String server = prop.getProperty(\"server\");\n+        if (server != null) {\n+          String serverId = server + \"/\" + prop.getProperty(\"id\");\n+          e = e.addSQL(serverId);\n         }\n+      } catch (DbException e2) {\n+        // ignore\n+      }\n     }\n+    return e;\n+  }\n \n-    public String getUniqueId() {\n-        return uniqueId;\n+  /**\n+   * Get the file locking method type given a method name.\n+   *\n+   * @param method the method name\n+   * @return the method type\n+   * @throws DbException if the method name is unknown\n+   */\n+  public static FileLockMethod getFileLockMethod(String method) {\n+    if (method == null || method.equalsIgnoreCase(\"FILE\")) {\n+      return FileLockMethod.FILE;\n+    } else if (method.equalsIgnoreCase(\"NO\")) {\n+      return FileLockMethod.NO;\n+    } else if (method.equalsIgnoreCase(\"SOCKET\")) {\n+      return FileLockMethod.SOCKET;\n+    } else if (method.equalsIgnoreCase(\"FS\")) {\n+      return FileLockMethod.FS;\n+    } else {\n+      throw DbException.get(ErrorCode.UNSUPPORTED_LOCK_METHOD_1, method);\n     }\n+  }\n \n-    @Override\n-    public void run() {\n+  public String getUniqueId() {\n+    return uniqueId;\n+  }\n+\n+  @Override\n+  public void run() {\n+    try {\n+      while (locked && fileName != null) {\n+        // trace.debug(\"watchdog check\");\n+        try {\n+          if (!FileUtils.exists(fileName) ||\n+              aggressiveLastModified(fileName) != lastWrite) {\n+            save();\n+          }\n+          Thread.sleep(sleep);\n+        } catch (OutOfMemoryError | NullPointerException | InterruptedException e) {\n+          // ignore\n+        } catch (Exception e) {\n+          trace.debug(e, \"watchdog\");\n+        }\n+      }\n+      while (true) {\n+        // take a copy so we don't get an NPE between checking it and using it\n+        ServerSocket local = serverSocket;\n+        if (local == null) {\n+          break;\n+        }\n         try {\n-            while (locked && fileName != null) {\n-                // trace.debug(\"watchdog check\");\n-                try {\n-                    if (!FileUtils.exists(fileName) ||\n-                            aggressiveLastModified(fileName) != lastWrite) {\n-                        save();\n-                    }\n-                    Thread.sleep(sleep);\n-                } catch (OutOfMemoryError | NullPointerException | InterruptedException e) {\n-                    // ignore\n-                } catch (Exception e) {\n-                    trace.debug(e, \"watchdog\");\n-                }\n-            }\n-            while (true) {\n-                // take a copy so we don't get an NPE between checking it and using it\n-                ServerSocket local = serverSocket;\n-                if (local == null) {\n-                    break;\n-                }\n-                try {\n-                    trace.debug(\"watchdog accept\");\n-                    Socket s = local.accept();\n-                    s.close();\n-                } catch (Exception e) {\n-                    trace.debug(e, \"watchdog\");\n-                }\n-            }\n+          trace.debug(\"watchdog accept\");\n+          Socket s = local.accept();\n+          s.close();\n         } catch (Exception e) {\n-            trace.debug(e, \"watchdog\");\n+          trace.debug(e, \"watchdog\");\n         }\n-        trace.debug(\"watchdog end\");\n+      }\n+    } catch (Exception e) {\n+      trace.debug(e, \"watchdog\");\n     }\n+    trace.debug(\"watchdog end\");\n+  }\n \n }\n",
            "diff_size": 641
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "217",
                    "column": "40",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/229/FileLock.java\nindex ab1b93fbd83..019e4155fa2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/229/FileLock.java\n@@ -510,4 +510,4 @@ public class FileLock implements Runnable {\n         trace.debug(\"watchdog end\");\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "500",
                    "column": "43",
                    "severity": "warning",
                    "message": "'|' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "500",
                    "column": "64",
                    "severity": "warning",
                    "message": "'|' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/229/FileLock.java\nindex ab1b93fbd83..b23e1912222 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/229/FileLock.java\n@@ -36,6 +36,8 @@ import org.h2.value.Transfer;\n  * to it. It uses a cooperative locking protocol. Usually a .lock.db file is\n  * used, but locking by creating a socket is supported as well.\n  */\n+\n+\n public class FileLock implements Runnable {\n \n     private static final String MAGIC = \"FileLock\";\n@@ -74,7 +76,6 @@ public class FileLock implements Runnable {\n      * The last time the lock file was written.\n      */\n     private long lastWrite;\n-\n     private String method;\n     private Properties properties;\n     private String uniqueId;\n@@ -87,9 +88,9 @@ public class FileLock implements Runnable {\n      * @param fileName the file name\n      * @param sleep the number of milliseconds to sleep\n      */\n+\n     public FileLock(TraceSystem traceSystem, String fileName, int sleep) {\n-        this.trace = traceSystem == null ?\n-                null : traceSystem.getTrace(Trace.FILE_LOCK);\n+        this.trace = traceSystem == null ? null : traceSystem.getTrace(Trace.FILE_LOCK);\n         this.fileName = fileName;\n         this.sleep = sleep;\n     }\n@@ -100,6 +101,8 @@ public class FileLock implements Runnable {\n      * @param fileLockMethod the file locking method to use\n      * @throws DbException if locking was not successful\n      */\n+\n+\n     public synchronized void lock(FileLockMethod fileLockMethod) {\n         checkServer();\n         if (locked) {\n@@ -123,6 +126,8 @@ public class FileLock implements Runnable {\n      * Unlock the file. The watchdog thread is stopped. This method does nothing\n      * if the file is already unlocked.\n      */\n+\n+\n     public synchronized void unlock() {\n         if (!locked) {\n             return;\n@@ -168,6 +173,8 @@ public class FileLock implements Runnable {\n      * @param key the key\n      * @param value the value\n      */\n+\n+\n     public void setProperty(String key, String value) {\n         if (value == null) {\n             properties.remove(key);\n@@ -181,6 +188,8 @@ public class FileLock implements Runnable {\n      *\n      * @return the saved properties\n      */\n+\n+\n     public Properties save() {\n         try {\n             try (OutputStream out = FileUtils.newOutputStream(fileName, false)) {\n@@ -202,6 +211,7 @@ public class FileLock implements Runnable {\n      * @param fileName file name to check\n      * @return last modified date/time in milliseconds UTC\n      */\n+\n     private static long aggressiveLastModified(String fileName) {\n         /*\n          * Some remote filesystem, e.g. SMB on Windows, can cache metadata for\n@@ -210,11 +220,14 @@ public class FileLock implements Runnable {\n          * cache.\n          */\n         try {\n-            try (FileChannel f = FileChannel.open(Paths.get(fileName), FileUtils.RWS, FileUtils.NO_ATTRIBUTES);) {\n+            try (FileChannel f = FileChannel.open(Paths.get(fileName), FileUtils.RWS, FileUtils.NO_ATTRIBUTES);\n+            ) {\n                 ByteBuffer b = ByteBuffer.wrap(new byte[1]);\n                 f.read(b);\n             }\n-        } catch (IOException ignoreEx) {}\n+        } catch (IOException ignoreEx) {\n+\n+        }\n         return FileUtils.lastModified(fileName);\n     }\n \n@@ -227,8 +240,7 @@ public class FileLock implements Runnable {\n         boolean running = false;\n         String id = prop.getProperty(\"id\");\n         try {\n-            Socket socket = NetUtils.createSocket(server,\n-                    Constants.DEFAULT_TCP_PORT, false);\n+            Socket socket = NetUtils.createSocket(server, Constants.DEFAULT_TCP_PORT, false);\n             Transfer transfer = new Transfer(null, socket);\n             transfer.init();\n             transfer.writeInt(Constants.TCP_PROTOCOL_VERSION_MIN_SUPPORTED);\n@@ -248,8 +260,8 @@ public class FileLock implements Runnable {\n             return;\n         }\n         if (running) {\n-            DbException e = DbException.get(\n-                    ErrorCode.DATABASE_ALREADY_OPEN_1, \"Server is running\");\n+            DbException e = DbException.get(ErrorCode.DATABASE_ALREADY_OPEN_1,\n+                                            \"Server is running\");\n             throw e.addSQL(server + \"/\" + id);\n         }\n     }\n@@ -259,6 +271,8 @@ public class FileLock implements Runnable {\n      *\n      * @return the properties\n      */\n+\n+\n     public Properties load() {\n         IOException lastException = null;\n         for (int i = 0; i < 5; i++) {\n@@ -272,8 +286,7 @@ public class FileLock implements Runnable {\n                 lastException = e;\n             }\n         }\n-        throw getExceptionFatal(\n-                \"Could not load properties \" + fileName, lastException);\n+        throw getExceptionFatal(\"Could not load properties \" + fileName, lastException);\n     }\n \n     private void waitUntilOld() {\n@@ -411,8 +424,7 @@ public class FileLock implements Runnable {\n         }\n         save();\n         locked = true;\n-        watchdog = new Thread(this,\n-                \"H2 File Lock Watchdog (Socket) \" + fileName);\n+        watchdog = new Thread(this, \"H2 File Lock Watchdog (Socket) \" + fileName);\n         watchdog.setDaemon(true);\n         watchdog.start();\n     }\n@@ -426,13 +438,11 @@ public class FileLock implements Runnable {\n     }\n \n     private static DbException getExceptionFatal(String reason, Throwable t) {\n-        return DbException.get(\n-                ErrorCode.ERROR_OPENING_DATABASE_1, t, reason);\n+        return DbException.get(ErrorCode.ERROR_OPENING_DATABASE_1, t, reason);\n     }\n \n     private DbException getExceptionAlreadyInUse(String reason) {\n-        DbException e = DbException.get(\n-                ErrorCode.DATABASE_ALREADY_OPEN_1, reason);\n+        DbException e = DbException.get(ErrorCode.DATABASE_ALREADY_OPEN_1, reason);\n         if (fileName != null) {\n             try {\n                 Properties prop = load();\n@@ -443,6 +453,7 @@ public class FileLock implements Runnable {\n                 }\n             } catch (DbException e2) {\n                 // ignore\n+\n             }\n         }\n         return e;\n@@ -455,20 +466,23 @@ public class FileLock implements Runnable {\n      * @return the method type\n      * @throws DbException if the method name is unknown\n      */\n+\n+\n     public static FileLockMethod getFileLockMethod(String method) {\n         if (method == null || method.equalsIgnoreCase(\"FILE\")) {\n             return FileLockMethod.FILE;\n         } else if (method.equalsIgnoreCase(\"NO\")) {\n             return FileLockMethod.NO;\n-        } else if (method.equalsIgnoreCase(\"SOCKET\")) {\n+                                                                  } else if (method.equalsIgnoreCase(\"SOCKET\")) {\n             return FileLockMethod.SOCKET;\n         } else if (method.equalsIgnoreCase(\"FS\")) {\n-            return FileLockMethod.FS;\n+                   return FileLockMethod.FS;\n         } else {\n-            throw DbException.get(ErrorCode.UNSUPPORTED_LOCK_METHOD_1, method);\n-        }\n+                                                                             throw DbException.get(ErrorCode.UNSUPPORTED_LOCK_METHOD_1, method);\n+                                                                         }\n     }\n \n+\n     public String getUniqueId() {\n         return uniqueId;\n     }\n@@ -479,13 +493,13 @@ public class FileLock implements Runnable {\n             while (locked && fileName != null) {\n                 // trace.debug(\"watchdog check\");\n                 try {\n-                    if (!FileUtils.exists(fileName) ||\n-                            aggressiveLastModified(fileName) != lastWrite) {\n+                    if (!FileUtils.exists(fileName) || aggressiveLastModified(fileName) != lastWrite) {\n                         save();\n                     }\n                     Thread.sleep(sleep);\n-                } catch (OutOfMemoryError | NullPointerException | InterruptedException e) {\n+                } catch (OutOfMemoryError |NullPointerException| InterruptedException e) {\n                     // ignore\n+\n                 } catch (Exception e) {\n                     trace.debug(e, \"watchdog\");\n                 }\n@@ -510,4 +524,4 @@ public class FileLock implements Runnable {\n         trace.debug(\"watchdog end\");\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 47
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/229/FileLock.java\nindex ab1b93fbd83..53c7718e1b2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/229/FileLock.java\n@@ -214,7 +214,7 @@ public class FileLock implements Runnable {\n                 ByteBuffer b = ByteBuffer.wrap(new byte[1]);\n                 f.read(b);\n             }\n-        } catch (IOException ignoreEx) {}\n+        } catch (IOException ignoreEx) {  }\n         return FileUtils.lastModified(fileName);\n     }\n \n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/229/FileLock.java\nindex ab1b93fbd83..77cb9085d25 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/229/FileLock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/229/FileLock.java\n@@ -214,7 +214,7 @@ public class FileLock implements Runnable {\n                 ByteBuffer b = ByteBuffer.wrap(new byte[1]);\n                 f.read(b);\n             }\n-        } catch (IOException ignoreEx) {}\n+        } catch (IOException ignoreEx) { }\n         return FileUtils.lastModified(fileName);\n     }\n \n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}