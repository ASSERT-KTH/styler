{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "90",
    "information": {
        "errors": [
            {
                "line": "34",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final public class MergeNodeIterator<N> implements NodeIterator<N>\n{\n\tprivate NodeIterator<N>[] iters;\n\tprivate List<N> nodes;\n\tprivate int length;\n\tprivate final Model<N> model;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "35",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/90/MergeNodeIterator.java\nindex 3f53d4366de..dfad985aef1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/90/MergeNodeIterator.java\n@@ -31,7 +31,7 @@ import org.genxdm.xpath.v10.NodeIterator;\n  */\r\n final public class MergeNodeIterator<N> implements NodeIterator<N>\r\n {\r\n-\tprivate NodeIterator<N>[] iters;\r\n+private NodeIterator<N>[] iters;\r\n \tprivate List<N> nodes;\r\n \tprivate int length;\r\n \tprivate final Model<N> model;\r\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/90/MergeNodeIterator.java\nindex 3f53d4366de..af277b82071 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/90/MergeNodeIterator.java\n@@ -3,7 +3,7 @@\n  * license details\r\n  * Portions copyright (c) 2002, Bill Lindsey : see copying.txt for license\r\n  * details\r\n- * \r\n+ *\r\n  * Portions copyright (c) 2009-2011 TIBCO Software Inc.\r\n  *\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n@@ -18,6 +18,7 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n+\r\n package org.genxdm.processor.xpath.v10.iterators;\r\n \r\n import java.util.ArrayList;\r\n@@ -29,154 +30,130 @@ import org.genxdm.xpath.v10.NodeIterator;\n /**\r\n  * does some sort of sort/merge on NodeIterators, I think\r\n  */\r\n-final public class MergeNodeIterator<N> implements NodeIterator<N>\r\n-{\r\n-\tprivate NodeIterator<N>[] iters;\r\n-\tprivate List<N> nodes;\r\n-\tprivate int length;\r\n-\tprivate final Model<N> model;\r\n-\r\n-\t/**\r\n-\t * construct with an array of iterators\r\n-\t * \r\n-\t * @param length\r\n-\t *            the number of slots in the array which really have NodeIterators for us\r\n-\t */\r\n-\tpublic MergeNodeIterator(NodeIterator<N>[] iters, int length, final Model<N> model)\r\n-\t{\r\n-\t\tthis.length = length;\r\n-\t\tthis.iters = iters;\r\n-\t\tnodes = new ArrayList<N>(length);\r\n-\t\tthis.model = model;\r\n-\t\tint j = 0;\r\n-\t\tfor (int i = 0; i < length; i++)\r\n-\t\t{\r\n-\t\t\t// we squeeze out NodeIterators with no nodes\r\n-\t\t\t// and put the first node from each iterator\r\n-\t\t\t// in our \"nodes\" array\r\n-\t\t\tif (i != j)\r\n-\t\t\t{\r\n-\t\t\t\titers[j] = iters[i];\r\n-\t\t\t}\r\n-\t\t\tN tem = iters[j].next();\r\n-\t\t\tif (tem != null)\r\n-\t\t\t{\r\n-\t\t\t\tnodes.add(tem);\r\n-\t\t\t\tj++;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\tthis.length = j; // reset the length to reflect squeezing\r\n-\t\tbuildHeap();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Make the heap rooted at i a heap, assuming its children are heaps.\r\n-\t */\r\n-\tprivate final void heapify(int i)\r\n-\t{\r\n-\t\t// i starts out around (length / 2) - 1\r\n-\t\tfor (;;)\r\n-\t\t{\r\n-\t\t\tint left = (i << 1) | 1; // (i*2) + 1 ??\r\n-\t\t\tint right = left + 1; // (i*2) + 2 ??\r\n-\r\n-\t\t\tif (right < length)\r\n-\t\t\t{\r\n-\r\n-\t\t\t\tif (compare(left, right) <= 0)\r\n-\t\t\t\t{\r\n-\t\t\t\t\t// left <= right\r\n-\r\n-\t\t\t\t\tif (compare(left, i) > 0)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tbreak;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\texchange(left, i);\r\n-\t\t\t\t\ti = left;\r\n-\t\t\t\t}\r\n-\t\t\t\telse\r\n-\t\t\t\t{\r\n-\t\t\t\t\t// right >= left\r\n-\t\t\t\t\tif (compare(right, i) > 0)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tbreak;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\texchange(right, i);\r\n-\t\t\t\t\ti = right;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\telse if (left < length)\r\n-\t\t\t{\r\n-\t\t\t\tif (compare(left, i) > 0)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t}\r\n-\t\t\t\texchange(left, i);\r\n-\t\t\t\ti = left;\r\n-\t\t\t}\r\n-\t\t\telse\r\n-\t\t\t{\r\n-\t\t\t\tbreak;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * swaps the items with the given indices\r\n-\t */\r\n-\tprivate final void exchange(int i, int j)\r\n-\t{\r\n-\t\t{\r\n-\t\t\tN tem = nodes.get(i);\r\n-\t\t\tnodes.set(i, nodes.get(j));\r\n-\t\t\tnodes.set(j, tem);\r\n-\t\t}\r\n-\t\t{\r\n-\t\t\tNodeIterator<N> tem = iters[i];\r\n-\t\t\titers[i] = iters[j];\r\n-\t\t\titers[j] = tem;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tprivate final int compare(final int i, final int j)\r\n-\t{\r\n-\t\treturn model.compare(nodes.get(i), nodes.get(j));\r\n-\t}\r\n-\r\n-\tprivate void buildHeap()\r\n-\t{\r\n-\t\tfor (int i = length / 2 - 1; i >= 0; --i)\r\n-\t\t{\r\n-\t\t\theapify(i);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * finds and returns the next node (in document(s) order?)\r\n-\t */\r\n-\tpublic N next() {\r\n-\t\tif (length == 0)\r\n-\t\t{\r\n-\t\t\treturn null;\r\n-\t\t}\r\n-\t\tN max = nodes.get(0);\r\n-\t\tdo\r\n-\t\t{\r\n-\t\t\tN tem = iters[0].next();\r\n-\t\t\tif (tem == null)\r\n-\t\t\t{\r\n-\t\t\t\tif (--length == 0)\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\tnodes.set(0, nodes.get(length));\r\n-\t\t\t\titers[0] = iters[length];\r\n-\t\t\t}\r\n-\t\t\telse\r\n-\t\t\t{\r\n-\t\t\t\tnodes.set(0, tem);\r\n-\t\t\t}\r\n-\t\t\theapify(0);\r\n-\t\t}\r\n-\t\twhile (max.equals(nodes.get(0)));\r\n-\t\treturn max;\r\n-\t}\r\n+final public class MergeNodeIterator<N> implements NodeIterator<N> {\r\n+    private NodeIterator<N>[] iters;\r\n+\r\n+    private List<N> nodes;\r\n+\r\n+    private int length;\r\n+\r\n+    private final Model<N> model;\r\n+\r\n+    /**\r\n+     * construct with an array of iterators\r\n+     *\r\n+     * @param length the number of slots in the array which really have NodeIterators for us\r\n+     */\r\n+    public MergeNodeIterator(NodeIterator<N>[] iters, int length, final Model<N> model) {\r\n+        this.length = length;\r\n+        this.iters = iters;\r\n+        nodes = new ArrayList<N>(length);\r\n+        this.model = model;\r\n+        int j = 0;\r\n+        for (int i = 0; i < length; i++) {\r\n+            // we squeeze out NodeIterators with no nodes\r\n+            // and put the first node from each iterator\r\n+            // in our \"nodes\" array\r\n+            if (i != j) {\r\n+                iters[j] = iters[i];\r\n+            }\r\n+            N tem = iters[j].next();\r\n+            if (tem != null) {\r\n+                nodes.add(tem);\r\n+                j++;\r\n+            }\r\n+        }\r\n+        this.length = j; // reset the length to reflect squeezing\r\n+        buildHeap();\r\n+    }\r\n+\r\n+    /**\r\n+     * Make the heap rooted at i a heap, assuming its children are heaps.\r\n+     */\r\n+    private final void heapify(int i) {\r\n+        // i starts out around (length / 2) - 1\r\n+        for (; ; ) {\r\n+            int left = (i << 1) | 1; // (i*2) + 1 ??\r\n+            int right = left + 1; // (i*2) + 2 ??\r\n+\r\n+            if (right < length) {\r\n+\r\n+                if (compare(left, right) <= 0) {\r\n+                    // left <= right\r\n+\r\n+                    if (compare(left, i) > 0) {\r\n+                        break;\r\n+                    }\r\n+                    exchange(left, i);\r\n+                    i = left;\r\n+                } else {\r\n+                    // right >= left\r\n+                    if (compare(right, i) > 0) {\r\n+                        break;\r\n+                    }\r\n+                    exchange(right, i);\r\n+                    i = right;\r\n+                }\r\n+            } else if (left < length) {\r\n+                if (compare(left, i) > 0) {\r\n+                    break;\r\n+                }\r\n+                exchange(left, i);\r\n+                i = left;\r\n+            } else {\r\n+                break;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * swaps the items with the given indices\r\n+     */\r\n+    private final void exchange(int i, int j) {\r\n+        {\r\n+            N tem = nodes.get(i);\r\n+            nodes.set(i, nodes.get(j));\r\n+            nodes.set(j, tem);\r\n+        }\r\n+        {\r\n+            NodeIterator<N> tem = iters[i];\r\n+            iters[i] = iters[j];\r\n+            iters[j] = tem;\r\n+        }\r\n+    }\r\n+\r\n+    private final int compare(final int i, final int j) {\r\n+        return model.compare(nodes.get(i), nodes.get(j));\r\n+    }\r\n+\r\n+    private void buildHeap() {\r\n+        for (int i = length / 2 - 1; i >= 0; --i) {\r\n+            heapify(i);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * finds and returns the next node (in document(s) order?)\r\n+     */\r\n+    public N next() {\r\n+        if (length == 0) {\r\n+            return null;\r\n+        }\r\n+        N max = nodes.get(0);\r\n+        do {\r\n+            N tem = iters[0].next();\r\n+            if (tem == null) {\r\n+                if (--length == 0) {\r\n+                    break;\r\n+                }\r\n+                nodes.set(0, nodes.get(length));\r\n+                iters[0] = iters[length];\r\n+            } else {\r\n+                nodes.set(0, tem);\r\n+            }\r\n+            heapify(0);\r\n+        }\r\n+        while (max.equals(nodes.get(0)));\r\n+        return max;\r\n+    }\r\n }\r\n",
            "diff_size": 152
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "35",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/90/MergeNodeIterator.java\nindex 3f53d4366de..85121964c79 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/90/MergeNodeIterator.java\n@@ -30,8 +30,8 @@ import org.genxdm.xpath.v10.NodeIterator;\n  * does some sort of sort/merge on NodeIterators, I think\r\n  */\r\n final public class MergeNodeIterator<N> implements NodeIterator<N>\r\n-{\r\n-\tprivate NodeIterator<N>[] iters;\r\n+{\n+    private NodeIterator<N>[] iters;\r\n \tprivate List<N> nodes;\r\n \tprivate int length;\r\n \tprivate final Model<N> model;\r\n@@ -43,140 +43,140 @@ final public class MergeNodeIterator<N> implements NodeIterator<N>\n \t *            the number of slots in the array which really have NodeIterators for us\r\n \t */\r\n \tpublic MergeNodeIterator(NodeIterator<N>[] iters, int length, final Model<N> model)\r\n-\t{\r\n-\t\tthis.length = length;\r\n+\t{\n+    this.length = length;\r\n \t\tthis.iters = iters;\r\n \t\tnodes = new ArrayList<N>(length);\r\n \t\tthis.model = model;\r\n \t\tint j = 0;\r\n \t\tfor (int i = 0; i < length; i++)\r\n-\t\t{\r\n-\t\t\t// we squeeze out NodeIterators with no nodes\r\n+\t\t{\n+    // we squeeze out NodeIterators with no nodes\r\n \t\t\t// and put the first node from each iterator\r\n \t\t\t// in our \"nodes\" array\r\n \t\t\tif (i != j)\r\n-\t\t\t{\r\n-\t\t\t\titers[j] = iters[i];\r\n-\t\t\t}\r\n+\t\t\t{\n+    iters[j] = iters[i];\n+    }\r\n \t\t\tN tem = iters[j].next();\r\n \t\t\tif (tem != null)\r\n-\t\t\t{\r\n-\t\t\t\tnodes.add(tem);\r\n-\t\t\t\tj++;\r\n-\t\t\t}\r\n-\t\t}\r\n+\t\t\t{\n+    nodes.add(tem);\r\n+\t\t\t\tj++;\n+    }\n+    }\r\n \t\tthis.length = j; // reset the length to reflect squeezing\r\n-\t\tbuildHeap();\r\n-\t}\r\n+\t\tbuildHeap();\n+    }\r\n \r\n \t/**\r\n \t * Make the heap rooted at i a heap, assuming its children are heaps.\r\n \t */\r\n \tprivate final void heapify(int i)\r\n-\t{\r\n-\t\t// i starts out around (length / 2) - 1\r\n+\t{\n+    // i starts out around (length / 2) - 1\r\n \t\tfor (;;)\r\n-\t\t{\r\n-\t\t\tint left = (i << 1) | 1; // (i*2) + 1 ??\r\n+\t\t{\n+    int left = (i << 1) | 1; // (i*2) + 1 ??\r\n \t\t\tint right = left + 1; // (i*2) + 2 ??\r\n \r\n \t\t\tif (right < length)\r\n-\t\t\t{\r\n-\r\n-\t\t\t\tif (compare(left, right) <= 0)\r\n-\t\t\t\t{\r\n-\t\t\t\t\t// left <= right\r\n+\t\t\t{\n+    if (compare(left, right) <= 0)\r\n+\t\t\t\t{\n+    // left <= right\r\n \r\n \t\t\t\t\tif (compare(left, i) > 0)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tbreak;\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t{\n+    break;\n+    }\r\n \t\t\t\t\texchange(left, i);\r\n-\t\t\t\t\ti = left;\r\n-\t\t\t\t}\r\n+\t\t\t\t\ti = left;\n+    }\r\n \t\t\t\telse\r\n-\t\t\t\t{\r\n-\t\t\t\t\t// right >= left\r\n+\t\t\t\t{\n+    // right >= left\r\n \t\t\t\t\tif (compare(right, i) > 0)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tbreak;\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t{\n+    break;\n+    }\r\n \t\t\t\t\texchange(right, i);\r\n-\t\t\t\t\ti = right;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n+\t\t\t\t\ti = right;\n+    }\n+    }\r\n \t\t\telse if (left < length)\r\n-\t\t\t{\r\n-\t\t\t\tif (compare(left, i) > 0)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t}\r\n+\t\t\t{\n+    if (compare(left, i) > 0)\r\n+\t\t\t\t{\n+    break;\n+    }\r\n \t\t\t\texchange(left, i);\r\n-\t\t\t\ti = left;\r\n-\t\t\t}\r\n+\t\t\t\ti = left;\n+    }\r\n \t\t\telse\r\n-\t\t\t{\r\n-\t\t\t\tbreak;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n+\t\t\t{\n+    break;\n+    }\n+    }\n+    }\r\n \r\n \t/**\r\n \t * swaps the items with the given indices\r\n \t */\r\n \tprivate final void exchange(int i, int j)\r\n-\t{\r\n-\t\t{\r\n-\t\t\tN tem = nodes.get(i);\r\n+\t{\n+    {\n+    N tem = nodes.get(i);\r\n \t\t\tnodes.set(i, nodes.get(j));\r\n-\t\t\tnodes.set(j, tem);\r\n-\t\t}\r\n-\t\t{\r\n-\t\t\tNodeIterator<N> tem = iters[i];\r\n+\t\t\tnodes.set(j, tem);\n+    }\r\n+\t\t{\n+    NodeIterator<N> tem = iters[i];\r\n \t\t\titers[i] = iters[j];\r\n-\t\t\titers[j] = tem;\r\n-\t\t}\r\n-\t}\r\n+\t\t\titers[j] = tem;\n+    }\n+    }\r\n \r\n \tprivate final int compare(final int i, final int j)\r\n-\t{\r\n-\t\treturn model.compare(nodes.get(i), nodes.get(j));\r\n-\t}\r\n+\t{\n+    return model.compare(nodes.get(i), nodes.get(j));\n+    }\r\n \r\n \tprivate void buildHeap()\r\n-\t{\r\n-\t\tfor (int i = length / 2 - 1; i >= 0; --i)\r\n-\t\t{\r\n-\t\t\theapify(i);\r\n-\t\t}\r\n-\t}\r\n+\t{\n+    for (int i = length / 2 - 1; i >= 0;\n+--i)\r\n+\t\t{\n+    heapify(i);\n+    }\n+    }\r\n \r\n \t/**\r\n \t * finds and returns the next node (in document(s) order?)\r\n \t */\r\n-\tpublic N next() {\r\n-\t\tif (length == 0)\r\n-\t\t{\r\n-\t\t\treturn null;\r\n-\t\t}\r\n+\tpublic N next() {\n+    if (length == 0)\r\n+\t\t{\n+    return null;\n+    }\r\n \t\tN max = nodes.get(0);\r\n \t\tdo\r\n-\t\t{\r\n-\t\t\tN tem = iters[0].next();\r\n+\t\t{\n+    N tem = iters[0].next();\r\n \t\t\tif (tem == null)\r\n-\t\t\t{\r\n-\t\t\t\tif (--length == 0)\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\tnodes.set(0, nodes.get(length));\r\n-\t\t\t\titers[0] = iters[length];\r\n-\t\t\t}\r\n+\t\t\t{\n+    if (--length == 0)\n+    break;\n+nodes.set(0, nodes.get(length));\r\n+\t\t\t\titers[0] = iters[length];\n+    }\r\n \t\t\telse\r\n-\t\t\t{\r\n-\t\t\t\tnodes.set(0, tem);\r\n-\t\t\t}\r\n-\t\t\theapify(0);\r\n-\t\t}\r\n+\t\t\t{\n+    nodes.set(0, tem);\n+    }\r\n+\t\t\theapify(0);\n+    }\r\n \t\twhile (max.equals(nodes.get(0)));\r\n-\t\treturn max;\r\n-\t}\r\n-}\r\n+\t\treturn max;\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 91
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/90/MergeNodeIterator.java\nindex 3f53d4366de..525b2649ee9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/90/MergeNodeIterator.java\n@@ -18,165 +18,166 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n-package org.genxdm.processor.xpath.v10.iterators;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.List;\r\n-\r\n-import org.genxdm.Model;\r\n+package org.genxdm.processor.xpath.v10.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.genxdm.Model;\n import org.genxdm.xpath.v10.NodeIterator;\r\n \r\n /**\r\n  * does some sort of sort/merge on NodeIterators, I think\r\n- */\r\n-final public class MergeNodeIterator<N> implements NodeIterator<N>\r\n-{\r\n-\tprivate NodeIterator<N>[] iters;\r\n-\tprivate List<N> nodes;\r\n-\tprivate int length;\r\n-\tprivate final Model<N> model;\r\n-\r\n-\t/**\r\n-\t * construct with an array of iterators\r\n-\t * \r\n-\t * @param length\r\n-\t *            the number of slots in the array which really have NodeIterators for us\r\n-\t */\r\n-\tpublic MergeNodeIterator(NodeIterator<N>[] iters, int length, final Model<N> model)\r\n-\t{\r\n-\t\tthis.length = length;\r\n-\t\tthis.iters = iters;\r\n-\t\tnodes = new ArrayList<N>(length);\r\n-\t\tthis.model = model;\r\n-\t\tint j = 0;\r\n-\t\tfor (int i = 0; i < length; i++)\r\n-\t\t{\r\n-\t\t\t// we squeeze out NodeIterators with no nodes\r\n-\t\t\t// and put the first node from each iterator\r\n-\t\t\t// in our \"nodes\" array\r\n-\t\t\tif (i != j)\r\n-\t\t\t{\r\n-\t\t\t\titers[j] = iters[i];\r\n-\t\t\t}\r\n-\t\t\tN tem = iters[j].next();\r\n-\t\t\tif (tem != null)\r\n-\t\t\t{\r\n-\t\t\t\tnodes.add(tem);\r\n-\t\t\t\tj++;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\tthis.length = j; // reset the length to reflect squeezing\r\n-\t\tbuildHeap();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Make the heap rooted at i a heap, assuming its children are heaps.\r\n-\t */\r\n-\tprivate final void heapify(int i)\r\n-\t{\r\n-\t\t// i starts out around (length / 2) - 1\r\n-\t\tfor (;;)\r\n-\t\t{\r\n-\t\t\tint left = (i << 1) | 1; // (i*2) + 1 ??\r\n-\t\t\tint right = left + 1; // (i*2) + 2 ??\r\n-\r\n-\t\t\tif (right < length)\r\n-\t\t\t{\r\n-\r\n-\t\t\t\tif (compare(left, right) <= 0)\r\n-\t\t\t\t{\r\n-\t\t\t\t\t// left <= right\r\n-\r\n-\t\t\t\t\tif (compare(left, i) > 0)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tbreak;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\texchange(left, i);\r\n-\t\t\t\t\ti = left;\r\n-\t\t\t\t}\r\n-\t\t\t\telse\r\n-\t\t\t\t{\r\n-\t\t\t\t\t// right >= left\r\n-\t\t\t\t\tif (compare(right, i) > 0)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tbreak;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\texchange(right, i);\r\n-\t\t\t\t\ti = right;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\telse if (left < length)\r\n-\t\t\t{\r\n-\t\t\t\tif (compare(left, i) > 0)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t}\r\n-\t\t\t\texchange(left, i);\r\n-\t\t\t\ti = left;\r\n-\t\t\t}\r\n-\t\t\telse\r\n-\t\t\t{\r\n-\t\t\t\tbreak;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n+ */\n+\n+final public class MergeNodeIterator<N> implements NodeIterator<N>\n+{\n+    private NodeIterator<N>[] iters;\n+    private List<N> nodes;\n+    private int length;\n+    private final Model<N> model;\r\n \r\n-\t/**\r\n-\t * swaps the items with the given indices\r\n-\t */\r\n-\tprivate final void exchange(int i, int j)\r\n-\t{\r\n-\t\t{\r\n-\t\t\tN tem = nodes.get(i);\r\n-\t\t\tnodes.set(i, nodes.get(j));\r\n-\t\t\tnodes.set(j, tem);\r\n-\t\t}\r\n-\t\t{\r\n-\t\t\tNodeIterator<N> tem = iters[i];\r\n-\t\t\titers[i] = iters[j];\r\n-\t\t\titers[j] = tem;\r\n-\t\t}\r\n-\t}\r\n+    /**\r\n+     * construct with an array of iterators\r\n+     * \r\n+     * @param length\r\n+     *            the number of slots in the array which really have NodeIterators for us\r\n+     */\n+\n+    public MergeNodeIterator(NodeIterator<N>[] iters, int length, final Model<N> model)\n+    {\n+        this.length = length;\n+        this.iters = iters;\n+        nodes = new ArrayList<N>(length);\n+        this.model = model;\n+\n+        int j = 0;\n+        for (int i = 0; i < length; i++)\n+        {\r\n+            // we squeeze out NodeIterators with no nodes\r\n+            // and put the first node from each iterator\r\n+            // in our \"nodes\" array\n+            if (i != j)\n+            {\n+                iters[j] = iters[i];\n+            }\n+            N tem = iters[j].next();\n+            if (tem != null)\n+            {\n+                nodes.add(tem);\n+                j++;\n+            }\n+        }\n+        this.length = j; // reset the length to reflect squeezing\n+        buildHeap();\n+    }\r\n \r\n-\tprivate final int compare(final int i, final int j)\r\n-\t{\r\n-\t\treturn model.compare(nodes.get(i), nodes.get(j));\r\n-\t}\r\n+    /**\r\n+     * Make the heap rooted at i a heap, assuming its children are heaps.\r\n+     */\n+\n+    private final void heapify(int i)\n+    {\r\n+        // i starts out around (length / 2) - 1\n+        for (;;)\n+        {\n+            int left = (i << 1) | 1; // (i*2) + 1 ??\n+            int right = left + 1; // (i*2) + 2 ??\n+            if (right < length)\n+            {\n+                if (compare(left, right) <= 0)\n+                {\r\n+                    // left <= right\n+                    if (compare(left, i) > 0)\n+                    {\n+                        break;\n+                    }\n+                    exchange(left, i);\n+                    i = left;\n+                }\n+                else\n+                {\r\n+                    // right >= left\n+                    if (compare(right, i) > 0)\n+                    {\n+                        break;\n+                    }\n+                    exchange(right, i);\n+                    i = right;\n+                }\n+            }\n+            else if (left < length)\n+            {\n+                if (compare(left, i) > 0)\n+                {\n+                    break;\n+                }\n+                exchange(left, i);\n+                i = left;\n+            }\n+            else\n+            {\n+                break;\n+            }\n+        }\n+    }\r\n \r\n-\tprivate void buildHeap()\r\n-\t{\r\n-\t\tfor (int i = length / 2 - 1; i >= 0; --i)\r\n-\t\t{\r\n-\t\t\theapify(i);\r\n-\t\t}\r\n-\t}\r\n+    /**\r\n+     * swaps the items with the given indices\r\n+     */\n+\n+    private final void exchange(int i, int j)\n+    {\n+        {\n+            N tem = nodes.get(i);\n+            nodes.set(i, nodes.get(j));\n+            nodes.set(j, tem);\n+        }\n+        {\n+            NodeIterator<N> tem = iters[i];\n+            iters[i] = iters[j];\n+            iters[j] = tem;\n+        }\n+    }\n+\n+    private final int compare(final int i, final int j)\n+    {\n+        return model.compare(nodes.get(i), nodes.get(j));\n+    }\n+\n+    private void buildHeap()\n+    {\n+        for (int i = length / 2 - 1; i >= 0; --i)\n+        {\n+            heapify(i);\n+        }\n+    }\r\n \r\n-\t/**\r\n-\t * finds and returns the next node (in document(s) order?)\r\n-\t */\r\n-\tpublic N next() {\r\n-\t\tif (length == 0)\r\n-\t\t{\r\n-\t\t\treturn null;\r\n-\t\t}\r\n-\t\tN max = nodes.get(0);\r\n-\t\tdo\r\n-\t\t{\r\n-\t\t\tN tem = iters[0].next();\r\n-\t\t\tif (tem == null)\r\n-\t\t\t{\r\n-\t\t\t\tif (--length == 0)\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\tnodes.set(0, nodes.get(length));\r\n-\t\t\t\titers[0] = iters[length];\r\n-\t\t\t}\r\n-\t\t\telse\r\n-\t\t\t{\r\n-\t\t\t\tnodes.set(0, tem);\r\n-\t\t\t}\r\n-\t\t\theapify(0);\r\n-\t\t}\r\n-\t\twhile (max.equals(nodes.get(0)));\r\n-\t\treturn max;\r\n-\t}\r\n-}\r\n+    /**\r\n+     * finds and returns the next node (in document(s) order?)\r\n+     */\n+\n+    public N next()\n+    {\n+        if (length == 0)\n+        {\n+            return null;\n+        }\n+        N max = nodes.get(0);\n+        do {\n+            N tem = iters[0].next();\n+            if (tem == null)\n+            {\n+                if (--length == 0)\n+                break;\n+                nodes.set(0, nodes.get(length));\n+                iters[0] = iters[length];\n+            }\n+            else\n+            {\n+                nodes.set(0, tem);\n+            }\n+            heapify(0);\n+        } while (max.equals(nodes.get(0)));\n+        return max;\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 240
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "35",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/90/MergeNodeIterator.java\nindex 3f53d4366de..dfad985aef1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/90/MergeNodeIterator.java\n@@ -31,7 +31,7 @@ import org.genxdm.xpath.v10.NodeIterator;\n  */\r\n final public class MergeNodeIterator<N> implements NodeIterator<N>\r\n {\r\n-\tprivate NodeIterator<N>[] iters;\r\n+private NodeIterator<N>[] iters;\r\n \tprivate List<N> nodes;\r\n \tprivate int length;\r\n \tprivate final Model<N> model;\r\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "35",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/90/MergeNodeIterator.java\nindex 3f53d4366de..4acba5d976a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/90/MergeNodeIterator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/90/MergeNodeIterator.java\n@@ -31,7 +31,7 @@ import org.genxdm.xpath.v10.NodeIterator;\n  */\r\n final public class MergeNodeIterator<N> implements NodeIterator<N>\r\n {\r\n-\tprivate NodeIterator<N>[] iters;\r\n+    private NodeIterator<N>[] iters;\r\n \tprivate List<N> nodes;\r\n \tprivate int length;\r\n \tprivate final Model<N> model;\r\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}