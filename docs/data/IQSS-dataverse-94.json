{
    "project_name": "IQSS-dataverse",
    "error_id": "94",
    "information": {
        "errors": [
            {
                "line": "51",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "    private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.dataaccess.SwiftAccessIO\");\n\n\tpublic SwiftAccessIO() {\n\t\t//Partially functional StorageIO object - constructor only for testing\n\t\tsuper();\n\t}",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "52",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/94/SwiftAccessIO.java\nindex 3bc29cb9836..5fef3a6dc64 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/94/SwiftAccessIO.java\n@@ -48,7 +48,7 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n \n     private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.dataaccess.SwiftAccessIO\");\n \n-\tpublic SwiftAccessIO() {\n+publicSwiftAccessIOSwiftAccessIO() {\n \t\t//Partially functional StorageIO object - constructor only for testing\n \t\tsuper();\n \t}\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/94/SwiftAccessIO.java\nindex 3bc29cb9836..64fe43a6420 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/94/SwiftAccessIO.java\n@@ -1,4 +1,5 @@\n package edu.harvard.iq.dataverse.dataaccess;\n+\n import edu.harvard.iq.dataverse.DataFile;\n import edu.harvard.iq.dataverse.Dataset;\n import edu.harvard.iq.dataverse.Dataverse;\n@@ -33,9 +34,8 @@ import org.javaswift.joss.model.Container;\n import org.javaswift.joss.model.StoredObject;\n \n /**\n- *\n- * @author leonid andreev\n  * @param <T> what it stores\n+ * @author leonid andreev\n  */\n /* \n     Swift driver, implemented as part of the Dataverse - Mass Open Cloud\n@@ -43,194 +43,196 @@ import org.javaswift.joss.model.StoredObject;\n  */\n public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n \n-    private String swiftFolderPath;\n-    private String swiftLocation; \n-\n-    private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.dataaccess.SwiftAccessIO\");\n-\n-\tpublic SwiftAccessIO() {\n-\t\t//Partially functional StorageIO object - constructor only for testing\n-\t\tsuper();\n-\t}\n-\t\n-    public SwiftAccessIO(T dvObject, DataAccessRequest req, String driverId) {\n-        super(dvObject, req, driverId);\n-        readSettings();\n-        this.setIsLocalFile(false);\n-    }\n-    \n-    public SwiftAccessIO(String swiftLocation, String driverId) {\n-    \tsuper(swiftLocation, driverId);\n-    \treadSettings();\n-        this.swiftLocation = swiftLocation;\n-        this.setIsLocalFile(false);\n-    }\n-\n-    private void readSettings() {\n-    \tisPublicContainer = Boolean.parseBoolean(System.getProperty(\"dataverse.files.\" + this.driverId + \".isPublicContainer\", \"true\"));\n-        swiftFolderPathSeparator = System.getProperty(\"dataverse.files.\" + this.driverId + \".folderPathSeparator\", \"_\");\n-        swiftDefaultEndpoint = System.getProperty(\"dataverse.files.\" + this.driverId + \".defaultEndpoint\");\n-        tempUrlExpires = Integer.parseInt(System.getProperty(\"dataverse.files.\" + this.driverId + \".temporaryUrlExpiryTime\", \"60\"));\n-\t\t\n-\t}\n-\n-\tprivate Account account = null;\n-    private StoredObject swiftFileObject = null;\n-    private Container swiftContainer = null;\n-    private boolean isPublicContainer = true;\n-    private String swiftFolderPathSeparator = \"_\";\n-    private String swiftDefaultEndpoint = null;\n-\n-    //for hash\n-    private static final String HMAC_SHA1_ALGORITHM = \"HmacSHA1\";\n-    \n-    //TODO: should this be dynamically generated based on size of file?\n-    //Also, this is in seconds\n-    private int tempUrlExpires = 60;\n-\n-    private static int LIST_PAGE_LIMIT = 100;\n-\n-    @Override\n-    public void open(DataAccessOption... options) throws IOException {\n-        DataAccessRequest req = this.getRequest();\n-        \n-        if (isWriteAccessRequested(options)) {\n-            isWriteAccess = true;\n-            isReadAccess = false;\n-        } else {\n-            isWriteAccess = false;\n-            isReadAccess = true;\n-        }\n+  private String swiftFolderPath;\n+  private String swiftLocation;\n \n-        if (dvObject instanceof DataFile) {\n-            String storageIdentifier = dvObject.getStorageIdentifier();\n-            DataFile dataFile = this.getDataFile();\n+  private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.dataaccess.SwiftAccessIO\");\n \n-            if (req != null && req.getParameter(\"noVarHeader\") != null) {\n-                this.setNoVarHeader(true);\n-            }\n+  public SwiftAccessIO() {\n+    //Partially functional StorageIO object - constructor only for testing\n+    super();\n+  }\n \n-            if (storageIdentifier == null || \"\".equals(storageIdentifier)) {\n-                throw new IOException(\"Data Access: No local storage identifier defined for this datafile.\");\n-            }\n+  public SwiftAccessIO(T dvObject, DataAccessRequest req, String driverId) {\n+    super(dvObject, req, driverId);\n+    readSettings();\n+    this.setIsLocalFile(false);\n+  }\n \n-            if (isReadAccess) {\n-                InputStream fin = openSwiftFileAsInputStream();\n+  public SwiftAccessIO(String swiftLocation, String driverId) {\n+    super(swiftLocation, driverId);\n+    readSettings();\n+    this.swiftLocation = swiftLocation;\n+    this.setIsLocalFile(false);\n+  }\n \n-                if (fin == null) {\n-                    throw new IOException(\"Failed to open Swift file \" + getStorageLocation());\n-                }\n+  private void readSettings() {\n+    isPublicContainer =\n+      Boolean.parseBoolean(System.getProperty(\"dataverse.files.\" + this.driverId + \".isPublicContainer\", \"true\"));\n+    swiftFolderPathSeparator = System.getProperty(\"dataverse.files.\" + this.driverId + \".folderPathSeparator\", \"_\");\n+    swiftDefaultEndpoint = System.getProperty(\"dataverse.files.\" + this.driverId + \".defaultEndpoint\");\n+    tempUrlExpires =\n+      Integer.parseInt(System.getProperty(\"dataverse.files.\" + this.driverId + \".temporaryUrlExpiryTime\", \"60\"));\n \n-                this.setInputStream(fin);\n-                setChannel(Channels.newChannel(fin));\n+  }\n \n-                if (dataFile.getContentType() != null\n-                        && dataFile.getContentType().equals(\"text/tab-separated-values\")\n-                        && dataFile.isTabularData()\n-                        && dataFile.getDataTable() != null\n-                        && (!this.noVarHeader())) {\n+  private Account account = null;\n+  private StoredObject swiftFileObject = null;\n+  private Container swiftContainer = null;\n+  private boolean isPublicContainer = true;\n+  private String swiftFolderPathSeparator = \"_\";\n+  private String swiftDefaultEndpoint = null;\n \n-                    List<DataVariable> datavariables = dataFile.getDataTable().getDataVariables();\n-                    String varHeaderLine = generateVariableHeader(datavariables);\n-                    this.setVarHeader(varHeaderLine);\n-                }\n+  //for hash\n+  private static final String HMAC_SHA1_ALGORITHM = \"HmacSHA1\";\n \n-            } else if (isWriteAccess) {\n-                swiftFileObject = initializeSwiftFileObject(true);\n-            }\n+  //TODO: should this be dynamically generated based on size of file?\n+  //Also, this is in seconds\n+  private int tempUrlExpires = 60;\n \n-            this.setMimeType(dataFile.getContentType());\n+  private static int LIST_PAGE_LIMIT = 100;\n \n+  @Override\n+  public void open(DataAccessOption... options) throws IOException {\n+    DataAccessRequest req = this.getRequest();\n \n-            try {\n-                this.setFileName(dataFile.getFileMetadata().getLabel());\n-            } catch (Exception ex) {\n-                this.setFileName(\"unknown\");\n-            }\n-        } else if (dvObject instanceof Dataset) {\n-            //we are uploading a dataset related auxilary file\n-            //such as a dataset thumbnail or a metadata export\n-            if (isReadAccess) {\n-                //TODO: fix this\n-                InputStream fin = openSwiftFileAsInputStream();\n-\n-                if (fin == null) {\n-                    throw new IOException(\"Failed to open Swift file \" + getStorageLocation());\n-                }\n-\n-                this.setInputStream(fin);\n-            } else if (isWriteAccess) {\n-                swiftFileObject = initializeSwiftFileObject(true);\n-            }\n-        } else if (dvObject instanceof Dataverse) {\n-        } else {\n-            throw new IOException(\"Data Access: Invalid DvObject type\");\n-        }\n+    if (isWriteAccessRequested(options)) {\n+      isWriteAccess = true;\n+      isReadAccess = false;\n+    } else {\n+      isWriteAccess = false;\n+      isReadAccess = true;\n     }\n \n+    if (dvObject instanceof DataFile) {\n+      String storageIdentifier = dvObject.getStorageIdentifier();\n+      DataFile dataFile = this.getDataFile();\n+\n+      if (req != null && req.getParameter(\"noVarHeader\") != null) {\n+        this.setNoVarHeader(true);\n+      }\n+\n+      if (storageIdentifier == null || \"\".equals(storageIdentifier)) {\n+        throw new IOException(\"Data Access: No local storage identifier defined for this datafile.\");\n+      }\n+\n+      if (isReadAccess) {\n+        InputStream fin = openSwiftFileAsInputStream();\n \n-    // StorageIO method for copying a local Path (for ex., a temp file), into this DataAccess location:\n-    @Override\n-    public void savePath(Path fileSystemPath) throws IOException {\n-        long newFileSize = -1;\n+        if (fin == null) {\n+          throw new IOException(\"Failed to open Swift file \" + getStorageLocation());\n+        }\n+\n+        this.setInputStream(fin);\n+        setChannel(Channels.newChannel(fin));\n \n-        if (swiftFileObject == null || !this.canWrite()) {\n-            open(DataAccessOption.WRITE_ACCESS);\n+        if (dataFile.getContentType() != null\n+          && dataFile.getContentType().equals(\"text/tab-separated-values\")\n+          && dataFile.isTabularData()\n+          && dataFile.getDataTable() != null\n+          && (!this.noVarHeader())) {\n+\n+          List<DataVariable> datavariables = dataFile.getDataTable().getDataVariables();\n+          String varHeaderLine = generateVariableHeader(datavariables);\n+          this.setVarHeader(varHeaderLine);\n         }\n \n-        try {\n-            File inputFile = fileSystemPath.toFile();\n+      } else if (isWriteAccess) {\n+        swiftFileObject = initializeSwiftFileObject(true);\n+      }\n \n-            swiftFileObject.uploadObject(inputFile);\n+      this.setMimeType(dataFile.getContentType());\n \n-            newFileSize = inputFile.length();\n \n-        } catch (Exception ioex) {\n-            String failureMsg = ioex.getMessage();\n-            if (failureMsg == null) {\n-                failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n-            }\n+      try {\n+        this.setFileName(dataFile.getFileMetadata().getLabel());\n+      } catch (Exception ex) {\n+        this.setFileName(\"unknown\");\n+      }\n+    } else if (dvObject instanceof Dataset) {\n+      //we are uploading a dataset related auxilary file\n+      //such as a dataset thumbnail or a metadata export\n+      if (isReadAccess) {\n+        //TODO: fix this\n+        InputStream fin = openSwiftFileAsInputStream();\n \n-            throw new IOException(failureMsg);\n+        if (fin == null) {\n+          throw new IOException(\"Failed to open Swift file \" + getStorageLocation());\n         }\n \n-        // if it has uploaded successfully, we can reset the size\n-        // of the object:\n-        setSize(newFileSize);\n+        this.setInputStream(fin);\n+      } else if (isWriteAccess) {\n+        swiftFileObject = initializeSwiftFileObject(true);\n+      }\n+    } else if (dvObject instanceof Dataverse) {\n+    } else {\n+      throw new IOException(\"Data Access: Invalid DvObject type\");\n+    }\n+  }\n+\n \n+  // StorageIO method for copying a local Path (for ex., a temp file), into this DataAccess location:\n+  @Override\n+  public void savePath(Path fileSystemPath) throws IOException {\n+    long newFileSize = -1;\n+\n+    if (swiftFileObject == null || !this.canWrite()) {\n+      open(DataAccessOption.WRITE_ACCESS);\n     }\n-    \n-    \n-    @Override\n-    public void saveInputStream(InputStream inputStream, Long filesize) throws IOException {\n-        saveInputStream(inputStream);\n+\n+    try {\n+      File inputFile = fileSystemPath.toFile();\n+\n+      swiftFileObject.uploadObject(inputFile);\n+\n+      newFileSize = inputFile.length();\n+\n+    } catch (Exception ioex) {\n+      String failureMsg = ioex.getMessage();\n+      if (failureMsg == null) {\n+        failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n+      }\n+\n+      throw new IOException(failureMsg);\n     }\n-    \n-    @Override\n-    public void saveInputStream(InputStream inputStream) throws IOException {\n-        long newFileSize = -1;\n \n-        if (swiftFileObject == null || !this.canWrite()) {\n-            open(DataAccessOption.WRITE_ACCESS);\n-        }\n+    // if it has uploaded successfully, we can reset the size\n+    // of the object:\n+    setSize(newFileSize);\n \n-        try {\n-            swiftFileObject.uploadObject(inputStream);\n+  }\n \n-        } catch (Exception ioex) {\n-            String failureMsg = ioex.getMessage();\n-            if (failureMsg == null) {\n-                failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n-            }\n \n-            throw new IOException(failureMsg);\n-        }\n+  @Override\n+  public void saveInputStream(InputStream inputStream, Long filesize) throws IOException {\n+    saveInputStream(inputStream);\n+  }\n+\n+  @Override\n+  public void saveInputStream(InputStream inputStream) throws IOException {\n+    long newFileSize = -1;\n+\n+    if (swiftFileObject == null || !this.canWrite()) {\n+      open(DataAccessOption.WRITE_ACCESS);\n+    }\n+\n+    try {\n+      swiftFileObject.uploadObject(inputStream);\n \n-        // if it has uploaded successfully, we can reset the size\n-        // of this SwiftAccessIO object:\n-        setSize(swiftFileObject.getContentLength());\n+    } catch (Exception ioex) {\n+      String failureMsg = ioex.getMessage();\n+      if (failureMsg == null) {\n+        failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n+      }\n+\n+      throw new IOException(failureMsg);\n     }\n \n+    // if it has uploaded successfully, we can reset the size\n+    // of this SwiftAccessIO object:\n+    setSize(swiftFileObject.getContentLength());\n+  }\n+\n     /*@Override\n     public void delete() throws IOException {\n         if (swiftFileObject == null) {\n@@ -245,378 +247,390 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n             swiftFileObject.delete();\n         }\n     }*/\n-    \n-    @Override\n-    public void delete() throws IOException {\n-        if (!isDirectAccess()) {\n-            throw new IOException(\"Direct Access IO must be used to permanently delete stored file objects\");\n-        }\n-        \n-        swiftFileObject = initializeSwiftFileDirectAccess();\n-        swiftFileObject.delete();\n+\n+  @Override\n+  public void delete() throws IOException {\n+    if (!isDirectAccess()) {\n+      throw new IOException(\"Direct Access IO must be used to permanently delete stored file objects\");\n     }\n-    \n \n-    @Override\n-    public Channel openAuxChannel(String auxItemTag, DataAccessOption... options) throws IOException {\n+    swiftFileObject = initializeSwiftFileDirectAccess();\n+    swiftFileObject.delete();\n+  }\n \n-        if (isWriteAccessRequested(options)) {\n-            throw new UnsupportedDataAccessOperationException(\"SwiftAccessIO: write mode openAuxChannel() not yet implemented in this storage driver.\");\n-        }\n \n-        InputStream fin = openSwiftAuxFileAsInputStream(auxItemTag);\n+  @Override\n+  public Channel openAuxChannel(String auxItemTag, DataAccessOption... options) throws IOException {\n \n-        if (fin == null) {\n-            throw new IOException(\"Failed to open auxilary file \" + auxItemTag + \" for Swift file \" + getStorageLocation());\n-        }\n+    if (isWriteAccessRequested(options)) {\n+      throw new UnsupportedDataAccessOperationException(\n+        \"SwiftAccessIO: write mode openAuxChannel() not yet implemented in this storage driver.\");\n+    }\n \n-        return Channels.newChannel(fin);\n+    InputStream fin = openSwiftAuxFileAsInputStream(auxItemTag);\n \n+    if (fin == null) {\n+      throw new IOException(\"Failed to open auxilary file \" + auxItemTag + \" for Swift file \" + getStorageLocation());\n     }\n \n-    @Override\n-    public boolean isAuxObjectCached(String auxItemTag) {\n-        StoredObject swiftAuxObject;\n-        try {\n-            swiftAuxObject = openSwiftAuxFile(auxItemTag);\n-        } catch (IOException ioex) {\n-            swiftAuxObject = null;\n-        }\n+    return Channels.newChannel(fin);\n+\n+  }\n \n-        return swiftAuxObject != null;\n+  @Override\n+  public boolean isAuxObjectCached(String auxItemTag) {\n+    StoredObject swiftAuxObject;\n+    try {\n+      swiftAuxObject = openSwiftAuxFile(auxItemTag);\n+    } catch (IOException ioex) {\n+      swiftAuxObject = null;\n     }\n \n-    @Override\n-    public long getAuxObjectSize(String auxItemTag) throws IOException {\n-        StoredObject swiftAuxObject = openSwiftAuxFile(auxItemTag);\n+    return swiftAuxObject != null;\n+  }\n \n-        if (swiftAuxObject == null) {\n-            return -1L;\n-        }\n+  @Override\n+  public long getAuxObjectSize(String auxItemTag) throws IOException {\n+    StoredObject swiftAuxObject = openSwiftAuxFile(auxItemTag);\n \n-        return swiftAuxObject.getContentLength();\n+    if (swiftAuxObject == null) {\n+      return -1L;\n     }\n \n-    @Override\n-    public Path getAuxObjectAsPath(String auxItemTag) throws IOException {\n-        throw new UnsupportedDataAccessOperationException(\"SwiftAccessIO: this is a remote DataAccess IO object, its Aux objects have no local filesystem Paths associated with it.\");\n+    return swiftAuxObject.getContentLength();\n+  }\n+\n+  @Override\n+  public Path getAuxObjectAsPath(String auxItemTag) throws IOException {\n+    throw new UnsupportedDataAccessOperationException(\n+      \"SwiftAccessIO: this is a remote DataAccess IO object, its Aux objects have no local filesystem Paths associated with it.\");\n+  }\n+\n+  @Override\n+  public void backupAsAux(String auxItemTag) throws IOException {\n+\n+    if (swiftFileObject == null || swiftContainer == null) {\n+      open();\n     }\n \n-    @Override\n-    public void backupAsAux(String auxItemTag) throws IOException {\n+    try {\n+      StoredObject swiftAuxObject = openSwiftAuxFile(true, auxItemTag);\n+      swiftFileObject.copyObject(swiftContainer, swiftAuxObject);\n+      // I'm assuming we don't need to delete the main object here - ?\n+      //swiftFileObject.delete();\n \n-        if (swiftFileObject == null || swiftContainer == null) {\n-            open();\n-        }\n+    } catch (IOException ioex) {\n+      String failureMsg = ioex.getMessage();\n+      if (failureMsg == null) {\n+        failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n+      }\n \n-        try {\n-            StoredObject swiftAuxObject = openSwiftAuxFile(true, auxItemTag);\n-            swiftFileObject.copyObject(swiftContainer, swiftAuxObject);\n-            // I'm assuming we don't need to delete the main object here - ?\n-            //swiftFileObject.delete();\n+      throw new IOException(failureMsg);\n+    }\n+  }\n \n-        } catch (IOException ioex) {\n-            String failureMsg = ioex.getMessage();\n-            if (failureMsg == null) {\n-                failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n-            }\n+  @Override\n+  public void revertBackupAsAux(String auxItemTag) throws IOException {\n+    // We are going to try and overwrite the current main file\n+    // with the contents of the stored original, currently saved as an\n+    // Aux file. So we need WRITE access on the main file:\n \n-            throw new IOException(failureMsg);\n-        }\n+    if (swiftFileObject == null || swiftContainer == null || !this.canWrite()) {\n+      open(DataAccessOption.WRITE_ACCESS);\n     }\n-    \n-    @Override\n-    public void revertBackupAsAux(String auxItemTag) throws IOException {\n-        // We are going to try and overwrite the current main file \n-        // with the contents of the stored original, currently saved as an \n-        // Aux file. So we need WRITE access on the main file: \n-        \n-        if (swiftFileObject == null || swiftContainer == null || !this.canWrite()) {\n-            open(DataAccessOption.WRITE_ACCESS);\n-        }\n \n-        try {\n-            // We are writing FROM the saved AUX object, back to the main object;\n-            // So we need READ access on the AUX object:\n-            \n-            StoredObject swiftAuxObject = openSwiftAuxFile(auxItemTag);\n-            swiftAuxObject.copyObject(swiftContainer, swiftFileObject);\n-\n-        } catch (Exception ex) {\n-            String failureMsg = ex.getMessage();\n-            if (failureMsg == null) {\n-                failureMsg = \"Swift AccessIO: Unknown exception occured while renaming orig file\";\n-            }\n+    try {\n+      // We are writing FROM the saved AUX object, back to the main object;\n+      // So we need READ access on the AUX object:\n \n-            throw new IOException(failureMsg);\n-        }\n+      StoredObject swiftAuxObject = openSwiftAuxFile(auxItemTag);\n+      swiftAuxObject.copyObject(swiftContainer, swiftFileObject);\n+\n+    } catch (Exception ex) {\n+      String failureMsg = ex.getMessage();\n+      if (failureMsg == null) {\n+        failureMsg = \"Swift AccessIO: Unknown exception occured while renaming orig file\";\n+      }\n \n+      throw new IOException(failureMsg);\n     }\n \n-    @Override\n-    // this method copies a local filesystem Path into this DataAccess Auxiliary location:\n-    public void savePathAsAux(Path fileSystemPath, String auxItemTag) throws IOException {\n-        if (swiftFileObject == null) {\n-            open();\n-        }\n+  }\n \n-        try {\n-            File inputFile = fileSystemPath.toFile();\n-            StoredObject swiftAuxObject = openSwiftAuxFile(true, auxItemTag);\n-            swiftAuxObject.uploadObject(inputFile);\n+  @Override\n+  // this method copies a local filesystem Path into this DataAccess Auxiliary location:\n+  public void savePathAsAux(Path fileSystemPath, String auxItemTag) throws IOException {\n+    if (swiftFileObject == null) {\n+      open();\n+    }\n \n-        } catch (IOException ex) {\n-            String failureMsg = ex.getMessage();\n+    try {\n+      File inputFile = fileSystemPath.toFile();\n+      StoredObject swiftAuxObject = openSwiftAuxFile(true, auxItemTag);\n+      swiftAuxObject.uploadObject(inputFile);\n \n-            if (failureMsg == null) {\n-                failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n-            }\n+    } catch (IOException ex) {\n+      String failureMsg = ex.getMessage();\n \n-            throw new IOException(failureMsg);\n-        }\n+      if (failureMsg == null) {\n+        failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n+      }\n \n+      throw new IOException(failureMsg);\n     }\n-    \n-    @Override\n-    public void saveInputStreamAsAux(InputStream inputStream, String auxItemTag, Long filesize) throws IOException {\n-        saveInputStreamAsAux(inputStream, auxItemTag);\n+\n+  }\n+\n+  @Override\n+  public void saveInputStreamAsAux(InputStream inputStream, String auxItemTag, Long filesize) throws IOException {\n+    saveInputStreamAsAux(inputStream, auxItemTag);\n+  }\n+\n+  // this method copies a local InputStream into this DataAccess Auxiliary location:\n+  @Override\n+  public void saveInputStreamAsAux(InputStream inputStream, String auxItemTag) throws IOException {\n+    if (swiftFileObject == null) {\n+      open();\n     }\n-    \n-    // this method copies a local InputStream into this DataAccess Auxiliary location:\n-    @Override\n-    public void saveInputStreamAsAux(InputStream inputStream, String auxItemTag) throws IOException {\n-        if (swiftFileObject == null) {\n-            open();\n-        }\n \n-        try {\n-            StoredObject swiftAuxObject = openSwiftAuxFile(true, auxItemTag);\n-            swiftAuxObject.uploadObject(inputStream);\n+    try {\n+      StoredObject swiftAuxObject = openSwiftAuxFile(true, auxItemTag);\n+      swiftAuxObject.uploadObject(inputStream);\n \n-        } catch (IOException ex) {\n-            String failureMsg = ex.getMessage();\n+    } catch (IOException ex) {\n+      String failureMsg = ex.getMessage();\n \n-            if (failureMsg == null) {\n-                failureMsg = \"Swift AccessIO: Unknown exception occured while saving a local InputStream as a Swift StoredObject\";\n-            }\n+      if (failureMsg == null) {\n+        failureMsg =\n+          \"Swift AccessIO: Unknown exception occured while saving a local InputStream as a Swift StoredObject\";\n+      }\n \n-            throw new IOException(failureMsg);\n-        }\n+      throw new IOException(failureMsg);\n     }\n+  }\n \n-    @Override\n-    public List<String> listAuxObjects() throws IOException {\n-        if (this.swiftContainer == null || this.swiftFileObject == null) {\n-            throw new IOException(\"This SwiftAccessIO() hasn't been properly initialized yet.\");\n-        }\n-        \n-        String namePrefix = this.swiftFileObject.getName()+\".\";\n-        \n-        Collection<StoredObject> items; \n-        String lastItemName = null; \n-        List<String> ret = new ArrayList<>();\n-\n-        while ((items = this.swiftContainer.list(namePrefix, lastItemName, LIST_PAGE_LIMIT)) != null && items.size() > 0) {\n-            for (StoredObject item : items) {\n-                lastItemName = item.getName().substring(namePrefix.length());\n-                ret.add(lastItemName);\n-            }\n-        }\n-\n-        return ret;\n+  @Override\n+  public List<String> listAuxObjects() throws IOException {\n+    if (this.swiftContainer == null || this.swiftFileObject == null) {\n+      throw new IOException(\"This SwiftAccessIO() hasn't been properly initialized yet.\");\n     }\n \n-    @Override\n-    public void deleteAuxObject(String auxItemTag) throws IOException {\n-        StoredObject swiftAuxObject = openSwiftAuxFile(auxItemTag);\n+    String namePrefix = this.swiftFileObject.getName() + \".\";\n \n-        if (swiftAuxObject == null) {\n-            throw new FileNotFoundException(\"No such Aux object: \" + auxItemTag);\n-        }\n+    Collection<StoredObject> items;\n+    String lastItemName = null;\n+    List<String> ret = new ArrayList<>();\n \n-        swiftAuxObject.delete();\n+    while ((items = this.swiftContainer.list(namePrefix, lastItemName, LIST_PAGE_LIMIT)) != null && items.size() > 0) {\n+      for (StoredObject item : items) {\n+        lastItemName = item.getName().substring(namePrefix.length());\n+        ret.add(lastItemName);\n+      }\n     }\n \n-    @Override\n-    public void deleteAllAuxObjects() throws IOException {\n-        if (this.swiftContainer == null || this.swiftFileObject == null) {\n-            throw new IOException(\"This SwiftAccessIO() hasn't been properly initialized yet. (did you execute SwiftAccessIO.open()?)\");\n-        }\n+    return ret;\n+  }\n \n-        Collection<StoredObject> victims; \n-        String lastVictim = null; \n-          \n-        while ((victims = this.swiftContainer.list(this.swiftFileObject.getName()+\".\", lastVictim, LIST_PAGE_LIMIT))!= null && victims.size() > 0) {\n-            for (StoredObject victim : victims) {\n-                lastVictim = victim.getName();\n-                logger.info(\"trying to delete \" + lastVictim);\n+  @Override\n+  public void deleteAuxObject(String auxItemTag) throws IOException {\n+    StoredObject swiftAuxObject = openSwiftAuxFile(auxItemTag);\n \n-                victim.delete();\n-            }\n-        }\n+    if (swiftAuxObject == null) {\n+      throw new FileNotFoundException(\"No such Aux object: \" + auxItemTag);\n     }\n \n-    @Override\n-    public String getStorageLocation() {\n-        if (isDirectAccess()) {\n-            return \"swift://\" + swiftLocation; \n-        }\n-        // For Swift, the \"storageLocation\" and \"storageIdentifier\" of the DvObject are the same thing.\n-        return dvObject.getStorageIdentifier();\n-    }\n+    swiftAuxObject.delete();\n+  }\n \n-    @Override\n-    public Path getFileSystemPath() throws IOException {\n-        throw new UnsupportedDataAccessOperationException(\"SwiftAccessIO: this is a remote DataAccess IO object, it has no local filesystem path associated with it.\");\n+  @Override\n+  public void deleteAllAuxObjects() throws IOException {\n+    if (this.swiftContainer == null || this.swiftFileObject == null) {\n+      throw new IOException(\n+        \"This SwiftAccessIO() hasn't been properly initialized yet. (did you execute SwiftAccessIO.open()?)\");\n     }\n \n-    @Override\n-    public boolean exists() throws IOException {\n-        try {\n-            swiftFileObject = initializeSwiftFileObject(false);\n-        } catch (FileNotFoundException fnfe) {\n-            return false;\n-        }\n+    Collection<StoredObject> victims;\n+    String lastVictim = null;\n \n-        return true;\n-    }\n+    while (\n+      (victims = this.swiftContainer.list(this.swiftFileObject.getName() + \".\", lastVictim, LIST_PAGE_LIMIT)) != null &&\n+        victims.size() > 0) {\n+      for (StoredObject victim : victims) {\n+        lastVictim = victim.getName();\n+        logger.info(\"trying to delete \" + lastVictim);\n \n-    @Override\n-    public WritableByteChannel getWriteChannel() throws IOException {\n-        throw new UnsupportedDataAccessOperationException(\"SwiftAccessIO: there are no write Channels associated with Swift objects.\");\n+        victim.delete();\n+      }\n     }\n+  }\n \n-    @Override\n-    public OutputStream getOutputStream() throws IOException {\n-        throw new UnsupportedDataAccessOperationException(\"SwiftAccessIO: there are no output Streams associated with Swift objects.\");\n+  @Override\n+  public String getStorageLocation() {\n+    if (isDirectAccess()) {\n+      return \"swift://\" + swiftLocation;\n     }\n+    // For Swift, the \"storageLocation\" and \"storageIdentifier\" of the DvObject are the same thing.\n+    return dvObject.getStorageIdentifier();\n+  }\n+\n+  @Override\n+  public Path getFileSystemPath() throws IOException {\n+    throw new UnsupportedDataAccessOperationException(\n+      \"SwiftAccessIO: this is a remote DataAccess IO object, it has no local filesystem path associated with it.\");\n+  }\n \n-    // Auxilary helper methods, Swift-specific:\n-    //TODO: rename initializeSwiftObject \n-    private StoredObject initializeSwiftFileObject(boolean writeAccess) throws IOException {\n-        return initializeSwiftFileObject(writeAccess, null);\n+  @Override\n+  public boolean exists() throws IOException {\n+    try {\n+      swiftFileObject = initializeSwiftFileObject(false);\n+    } catch (FileNotFoundException fnfe) {\n+      return false;\n     }\n \n-    private StoredObject initializeSwiftFileObject(boolean writeAccess, String auxItemTag) throws IOException {\n-        String swiftEndPoint = null;\n-        String swiftContainerName = null;\n-        String swiftFileName = null;\n+    return true;\n+  }\n \n-        StoredObject fileObject;\n-        String storageIdentifier = dvObject.getStorageIdentifier();\n+  @Override\n+  public WritableByteChannel getWriteChannel() throws IOException {\n+    throw new UnsupportedDataAccessOperationException(\n+      \"SwiftAccessIO: there are no write Channels associated with Swift objects.\");\n+  }\n \n-        if (dvObject instanceof DataFile) {\n-            Dataset owner = this.getDataFile().getOwner();\n+  @Override\n+  public OutputStream getOutputStream() throws IOException {\n+    throw new UnsupportedDataAccessOperationException(\n+      \"SwiftAccessIO: there are no output Streams associated with Swift objects.\");\n+  }\n \n-            if (storageIdentifier.startsWith(this.driverId + \"://\")) {\n-                // This is a call on an already existing swift object. \n+  // Auxilary helper methods, Swift-specific:\n+  //TODO: rename initializeSwiftObject\n+  private StoredObject initializeSwiftFileObject(boolean writeAccess) throws IOException {\n+    return initializeSwiftFileObject(writeAccess, null);\n+  }\n \n-                String[] swiftStorageTokens = storageIdentifier.substring(8).split(\":\", 3);    \n+  private StoredObject initializeSwiftFileObject(boolean writeAccess, String auxItemTag) throws IOException {\n+    String swiftEndPoint = null;\n+    String swiftContainerName = null;\n+    String swiftFileName = null;\n \n-                if (swiftStorageTokens.length != 3) {\n-                    // bad storage identifier\n-                    throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n-                }\n+    StoredObject fileObject;\n+    String storageIdentifier = dvObject.getStorageIdentifier();\n \n-                swiftEndPoint = swiftStorageTokens[0];\n-                swiftContainerName = swiftStorageTokens[1];\n-                swiftFileName = swiftStorageTokens[2];\n+    if (dvObject instanceof DataFile) {\n+      Dataset owner = this.getDataFile().getOwner();\n \n-                if (StringUtil.isEmpty(swiftEndPoint) || StringUtil.isEmpty(swiftContainerName) || StringUtil.isEmpty(swiftFileName)) {\n-                    // all of these things need to be specified, for this to be a valid Swift location\n-                    // identifier.\n-                    throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n-                }\n+      if (storageIdentifier.startsWith(this.driverId + \"://\")) {\n+        // This is a call on an already existing swift object.\n \n-                if (auxItemTag != null) {\n-                    swiftFileName = swiftFileName.concat(\".\"+auxItemTag);\n-                }\n-            } else if (this.isReadAccess) {\n-                // An attempt to call Swift driver,  in a Read mode on a non-swift stored datafile\n-                // object!\n-                throw new IOException(\"IO driver mismatch: SwiftAccessIO called on a non-swift stored object.\");\n-            } else if (this.isWriteAccess) {\n-                swiftEndPoint = swiftDefaultEndpoint;\n+        String[] swiftStorageTokens = storageIdentifier.substring(8).split(\":\", 3);\n \n-                // Swift uses this to create pseudo-hierarchical folders\n-                String swiftPseudoFolderPathSeparator = \"/\";\n+        if (swiftStorageTokens.length != 3) {\n+          // bad storage identifier\n+          throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n+        }\n \n-                //swiftFolderPath = dataFile.getOwner().getDisplayName();\n-                String swiftFolderPathSeparator = \"-\";\n-                String authorityNoSlashes = owner.getAuthority().replace(\"/\", swiftFolderPathSeparator);\n-                swiftFolderPath = owner.getProtocolForFileStorage() + swiftFolderPathSeparator\n-                                  + authorityNoSlashes.replace(\".\", swiftFolderPathSeparator);\n+        swiftEndPoint = swiftStorageTokens[0];\n+        swiftContainerName = swiftStorageTokens[1];\n+        swiftFileName = swiftStorageTokens[2];\n \n-                swiftFileName = owner.getIdentifierForFileStorage() + swiftPseudoFolderPathSeparator\n-                                + storageIdentifier;\n-                //setSwiftContainerName(swiftFolderPath);\n-                //swiftFileName = dataFile.getDisplayName();\n-                //Storage Identifier is now updated after the object is uploaded on Swift.\n-                dvObject.setStorageIdentifier(this.driverId + \"://\" + swiftDefaultEndpoint + \":\" + swiftFolderPath + \":\" + swiftFileName);\n-            } else {\n-                throw new IOException(\"SwiftAccessIO: unknown access mode.\");\n-            }\n-        } else if (dvObject instanceof Dataset) {\n-            Dataset dataset = this.getDataset();\n-\n-            if (storageIdentifier.startsWith(this.driverId + \"://\")) {\n-                // This is a call on an already existing swift object. \n-\n-                //TODO: determine how storage identifier will give us info\n-                String[] swiftStorageTokens = storageIdentifier.substring(8).split(\":\", 3);\n-                //number of tokens should be two because there is not main file\n-                if (swiftStorageTokens.length != 2) {\n-                    // bad storage identifier\n-                    throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n-                }\n-\n-                swiftEndPoint = swiftStorageTokens[0];\n-                swiftContainerName = swiftStorageTokens[1];\n-                //We will not have a file name, just an aux tag\n-                if (auxItemTag != null) {\n-                    swiftFileName = auxItemTag;\n-                } else {\n-                    throw new IOException(\"Dataset related auxillary files require an auxItemTag\");\n-                }       \n-\n-                if (StringUtil.isEmpty(swiftEndPoint) || StringUtil.isEmpty(swiftContainerName) || StringUtil.isEmpty(swiftFileName) ) {\n-                    // all of these things need to be specified, for this to be a valid Swift location\n-                    // identifier.1\n-                    throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n-                }\n-\n-            } else if (this.isReadAccess) {\n-                // An attempt to call Swift driver,  in a Read mode on a non-swift stored datafile\n-                // object!\n-                throw new IOException(\"IO driver mismatch: SwiftAccessIO called on a non-swift stored object.\");\n-            } else if (this.isWriteAccess) {\n-                swiftEndPoint = swiftDefaultEndpoint;\n-\n-                // Swift uses this to create pseudo-hierarchical folders\n-                String swiftPseudoFolderPathSeparator = \"/\";\n-\n-                String authorityNoSlashes = dataset.getAuthorityForFileStorage().replace(\"/\", swiftFolderPathSeparator);\n-                swiftFolderPath = dataset.getProtocolForFileStorage() + swiftFolderPathSeparator +\n-                    authorityNoSlashes.replace(\".\", swiftFolderPathSeparator) +\n-                    swiftPseudoFolderPathSeparator + dataset.getIdentifierForFileStorage();\n-\n-                swiftFileName = auxItemTag;\n-                dvObject.setStorageIdentifier(this.driverId + \"://\" + swiftEndPoint + \":\" + swiftFolderPath);\n-            } else {\n-                throw new IOException(\"SwiftAccessIO: unknown access mode.\");\n-            }\n-        } else {\n-            //for future scope, if dataverse is decided to be stored in swift storage containersopen    \n-            throw new FileNotFoundException(\"Error initializing swift object\");  \n+        if (StringUtil.isEmpty(swiftEndPoint) || StringUtil.isEmpty(swiftContainerName) ||\n+          StringUtil.isEmpty(swiftFileName)) {\n+          // all of these things need to be specified, for this to be a valid Swift location\n+          // identifier.\n+          throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n+        }\n+\n+        if (auxItemTag != null) {\n+          swiftFileName = swiftFileName.concat(\".\" + auxItemTag);\n+        }\n+      } else if (this.isReadAccess) {\n+        // An attempt to call Swift driver,  in a Read mode on a non-swift stored datafile\n+        // object!\n+        throw new IOException(\"IO driver mismatch: SwiftAccessIO called on a non-swift stored object.\");\n+      } else if (this.isWriteAccess) {\n+        swiftEndPoint = swiftDefaultEndpoint;\n+\n+        // Swift uses this to create pseudo-hierarchical folders\n+        String swiftPseudoFolderPathSeparator = \"/\";\n+\n+        //swiftFolderPath = dataFile.getOwner().getDisplayName();\n+        String swiftFolderPathSeparator = \"-\";\n+        String authorityNoSlashes = owner.getAuthority().replace(\"/\", swiftFolderPathSeparator);\n+        swiftFolderPath = owner.getProtocolForFileStorage() + swiftFolderPathSeparator\n+          + authorityNoSlashes.replace(\".\", swiftFolderPathSeparator);\n+\n+        swiftFileName = owner.getIdentifierForFileStorage() + swiftPseudoFolderPathSeparator\n+          + storageIdentifier;\n+        //setSwiftContainerName(swiftFolderPath);\n+        //swiftFileName = dataFile.getDisplayName();\n+        //Storage Identifier is now updated after the object is uploaded on Swift.\n+        dvObject.setStorageIdentifier(\n+          this.driverId + \"://\" + swiftDefaultEndpoint + \":\" + swiftFolderPath + \":\" + swiftFileName);\n+      } else {\n+        throw new IOException(\"SwiftAccessIO: unknown access mode.\");\n+      }\n+    } else if (dvObject instanceof Dataset) {\n+      Dataset dataset = this.getDataset();\n+\n+      if (storageIdentifier.startsWith(this.driverId + \"://\")) {\n+        // This is a call on an already existing swift object.\n+\n+        //TODO: determine how storage identifier will give us info\n+        String[] swiftStorageTokens = storageIdentifier.substring(8).split(\":\", 3);\n+        //number of tokens should be two because there is not main file\n+        if (swiftStorageTokens.length != 2) {\n+          // bad storage identifier\n+          throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n         }\n-        // Authenticate with Swift: \n \n-        // should we only authenticate when account == null? \n+        swiftEndPoint = swiftStorageTokens[0];\n+        swiftContainerName = swiftStorageTokens[1];\n+        //We will not have a file name, just an aux tag\n+        if (auxItemTag != null) {\n+          swiftFileName = auxItemTag;\n+        } else {\n+          throw new IOException(\"Dataset related auxillary files require an auxItemTag\");\n+        }\n \n-        if (this.account == null) {\n-            account = authenticateWithSwift(swiftEndPoint);\n+        if (StringUtil.isEmpty(swiftEndPoint) || StringUtil.isEmpty(swiftContainerName) ||\n+          StringUtil.isEmpty(swiftFileName)) {\n+          // all of these things need to be specified, for this to be a valid Swift location\n+          // identifier.1\n+          throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n         }\n \n+      } else if (this.isReadAccess) {\n+        // An attempt to call Swift driver,  in a Read mode on a non-swift stored datafile\n+        // object!\n+        throw new IOException(\"IO driver mismatch: SwiftAccessIO called on a non-swift stored object.\");\n+      } else if (this.isWriteAccess) {\n+        swiftEndPoint = swiftDefaultEndpoint;\n+\n+        // Swift uses this to create pseudo-hierarchical folders\n+        String swiftPseudoFolderPathSeparator = \"/\";\n+\n+        String authorityNoSlashes = dataset.getAuthorityForFileStorage().replace(\"/\", swiftFolderPathSeparator);\n+        swiftFolderPath = dataset.getProtocolForFileStorage() + swiftFolderPathSeparator +\n+          authorityNoSlashes.replace(\".\", swiftFolderPathSeparator) +\n+          swiftPseudoFolderPathSeparator + dataset.getIdentifierForFileStorage();\n+\n+        swiftFileName = auxItemTag;\n+        dvObject.setStorageIdentifier(this.driverId + \"://\" + swiftEndPoint + \":\" + swiftFolderPath);\n+      } else {\n+        throw new IOException(\"SwiftAccessIO: unknown access mode.\");\n+      }\n+    } else {\n+      //for future scope, if dataverse is decided to be stored in swift storage containersopen\n+      throw new FileNotFoundException(\"Error initializing swift object\");\n+    }\n+    // Authenticate with Swift:\n+\n+    // should we only authenticate when account == null?\n+\n+    if (this.account == null) {\n+      account = authenticateWithSwift(swiftEndPoint);\n+    }\n+\n         /*\n         The containers created is swiftEndPoint concatenated with the swiftContainerName\n         property. Creating container with certain names throws 'Unable to create\n@@ -628,270 +642,287 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         other swiftContainerName Object Store pseudo-folder can be created, which is\n         not provide by the joss Java swift library as of yet.\n          */\n-        if (storageIdentifier.startsWith(this.driverId + \"://\")) {\n-            // An existing swift object; the container must already exist as well.\n-            this.swiftContainer = account.getContainer(swiftContainerName);\n-        } else {\n-            // This is a new object being created.\n-            this.swiftContainer = account.getContainer(swiftFolderPath); //changed from swiftendpoint\n-        }\n-        if (!this.swiftContainer.exists()) {\n-            if (writeAccess) {\n-                //creates a private data container\n-                swiftContainer.create();\n-                if (isPublicContainer) {\n-                    try {\n-                        //creates a public data container\n-                        this.swiftContainer.makePublic();\n-                    }\n-                    catch (Exception e){\n-                        //e.printStackTrace();\n-                        logger.warning(\"Caught exception \"+e.getClass()+\" while creating a swift container (it's likely not fatal!)\");\n-                    }\n-                }\n-            } else {\n-                // This is a fatal condition - it has to exist, if we were to \n-                // read an existing object!\n-                throw new IOException(\"SwiftAccessIO: container \" + swiftContainerName + \" does not exist.\");\n-            }\n+    if (storageIdentifier.startsWith(this.driverId + \"://\")) {\n+      // An existing swift object; the container must already exist as well.\n+      this.swiftContainer = account.getContainer(swiftContainerName);\n+    } else {\n+      // This is a new object being created.\n+      this.swiftContainer = account.getContainer(swiftFolderPath); //changed from swiftendpoint\n+    }\n+    if (!this.swiftContainer.exists()) {\n+      if (writeAccess) {\n+        //creates a private data container\n+        swiftContainer.create();\n+        if (isPublicContainer) {\n+          try {\n+            //creates a public data container\n+            this.swiftContainer.makePublic();\n+          } catch (Exception e) {\n+            //e.printStackTrace();\n+            logger.warning(\n+              \"Caught exception \" + e.getClass() + \" while creating a swift container (it's likely not fatal!)\");\n+          }\n         }\n+      } else {\n+        // This is a fatal condition - it has to exist, if we were to\n+        // read an existing object!\n+        throw new IOException(\"SwiftAccessIO: container \" + swiftContainerName + \" does not exist.\");\n+      }\n+    }\n \n-        fileObject = this.swiftContainer.getObject(swiftFileName);\n-\n-        // If this is the main, primary datafile object (i.e., not an auxiliary \n-        // object for a primary file), we also set the file download url here: \n-        if (auxItemTag == null && dvObject instanceof DataFile) {\n-            setRemoteUrl(getSwiftFileURI(fileObject));\n-            if (!this.isWriteAccess && !this.getDataFile().isIngestInProgress()) {\n-                //otherwise this gets called a bunch on upload\n-                setTemporarySwiftUrl(generateTemporarySwiftUrl(swiftEndPoint, swiftContainerName, swiftFileName, tempUrlExpires));\n-                setTempUrlSignature(generateTempUrlSignature(swiftEndPoint, swiftContainerName, swiftFileName, tempUrlExpires));\n-                setTempUrlExpiry(generateTempUrlExpiry(tempUrlExpires, System.currentTimeMillis()));\n-            }\n-            setSwiftFileName(swiftFileName);\n-\n-            logger.fine(getRemoteUrl() + \" success; write mode: \" + writeAccess);\n-        } else {\n-            logger.fine(\"sucessfully opened AUX object \" + auxItemTag + \" , write mode: \" + writeAccess);\n-        }\n+    fileObject = this.swiftContainer.getObject(swiftFileName);\n \n-        if (!writeAccess && !fileObject.exists()) {\n-            throw new FileNotFoundException(\"SwiftAccessIO: DvObject \" + swiftFileName + \" does not exist (Dataverse dvObject id: \" + dvObject.getId());\n-        }\n+    // If this is the main, primary datafile object (i.e., not an auxiliary\n+    // object for a primary file), we also set the file download url here:\n+    if (auxItemTag == null && dvObject instanceof DataFile) {\n+      setRemoteUrl(getSwiftFileURI(fileObject));\n+      if (!this.isWriteAccess && !this.getDataFile().isIngestInProgress()) {\n+        //otherwise this gets called a bunch on upload\n+        setTemporarySwiftUrl(\n+          generateTemporarySwiftUrl(swiftEndPoint, swiftContainerName, swiftFileName, tempUrlExpires));\n+        setTempUrlSignature(generateTempUrlSignature(swiftEndPoint, swiftContainerName, swiftFileName, tempUrlExpires));\n+        setTempUrlExpiry(generateTempUrlExpiry(tempUrlExpires, System.currentTimeMillis()));\n+      }\n+      setSwiftFileName(swiftFileName);\n \n-        return fileObject;\n+      logger.fine(getRemoteUrl() + \" success; write mode: \" + writeAccess);\n+    } else {\n+      logger.fine(\"sucessfully opened AUX object \" + auxItemTag + \" , write mode: \" + writeAccess);\n     }\n \n-    private StoredObject initializeSwiftFileDirectAccess() throws IOException {\n-        if (!isDirectAccess()) {\n-            throw new IOException(\"Direct access attempted on a SwiftAccessIO associated with a DvObject\");\n-        }\n-        \n-        String swiftEndPoint = null;\n-        String swiftContainerName = null;\n-        String swiftFileName = null;\n-\n-        String[] swiftStorageTokens = swiftLocation.split(\":\", 3);\n+    if (!writeAccess && !fileObject.exists()) {\n+      throw new FileNotFoundException(\n+        \"SwiftAccessIO: DvObject \" + swiftFileName + \" does not exist (Dataverse dvObject id: \" + dvObject.getId());\n+    }\n \n-        if (swiftStorageTokens.length != 3) {\n-            throw new IOException(\"SwiftAccessIO: invalid storage location: \" + swiftLocation);\n-        }\n+    return fileObject;\n+  }\n \n-        swiftEndPoint = swiftStorageTokens[0];\n-        swiftContainerName = swiftStorageTokens[1];\n-        swiftFileName = swiftStorageTokens[2];\n-        \n-        if (this.account == null) {\n-            account = authenticateWithSwift(swiftEndPoint);\n-        }\n-        \n-        this.swiftContainer = account.getContainer(swiftContainerName);\n-        \n-        StoredObject fileObject = this.swiftContainer.getObject(swiftFileName);\n+  private StoredObject initializeSwiftFileDirectAccess() throws IOException {\n+    if (!isDirectAccess()) {\n+      throw new IOException(\"Direct access attempted on a SwiftAccessIO associated with a DvObject\");\n+    }\n \n-        if (!fileObject.exists()) {\n-            throw new FileNotFoundException(\"SwiftAccessIO/Direct Access: \" + swiftLocation + \" does not exist\");\n-        }\n+    String swiftEndPoint = null;\n+    String swiftContainerName = null;\n+    String swiftFileName = null;\n \n-        return fileObject;\n+    String[] swiftStorageTokens = swiftLocation.split(\":\", 3);\n \n+    if (swiftStorageTokens.length != 3) {\n+      throw new IOException(\"SwiftAccessIO: invalid storage location: \" + swiftLocation);\n     }\n-    \n-    private InputStream openSwiftFileAsInputStream() throws IOException {\n-        swiftFileObject = initializeSwiftFileObject(false);\n-        this.setSize(swiftFileObject.getContentLength());\n \n-        return swiftFileObject.downloadObjectAsInputStream();\n-    }\n+    swiftEndPoint = swiftStorageTokens[0];\n+    swiftContainerName = swiftStorageTokens[1];\n+    swiftFileName = swiftStorageTokens[2];\n \n-    private InputStream openSwiftAuxFileAsInputStream(String auxItemTag) throws IOException {\n-        return initializeSwiftFileObject(false, auxItemTag).downloadObjectAsInputStream();\n+    if (this.account == null) {\n+      account = authenticateWithSwift(swiftEndPoint);\n     }\n \n-    private StoredObject openSwiftAuxFile(String auxItemTag) throws IOException {\n-        return openSwiftAuxFile(false, auxItemTag);\n-    }\n+    this.swiftContainer = account.getContainer(swiftContainerName);\n+\n+    StoredObject fileObject = this.swiftContainer.getObject(swiftFileName);\n \n-    private StoredObject openSwiftAuxFile(boolean writeAccess, String auxItemTag) throws IOException {\n-        return initializeSwiftFileObject(writeAccess, auxItemTag);\n+    if (!fileObject.exists()) {\n+      throw new FileNotFoundException(\"SwiftAccessIO/Direct Access: \" + swiftLocation + \" does not exist\");\n     }\n \n-    Account authenticateWithSwift(String swiftEndPoint) throws IOException {\n-        String swiftEndPointAuthUrl = System.getProperty(\"dataverse.files.\" + this.driverId + \".authUrl.\" + swiftEndPoint);\n-        String swiftEndPointUsername = System.getProperty(\"dataverse.files.\" + this.driverId + \".username.\" + swiftEndPoint);\n-        String swiftEndPointSecretKey = System.getProperty(\"dataverse.files.\" + this.driverId + \".password.\" + swiftEndPoint);\n-        String swiftEndPointTenantName = System.getProperty(\"dataverse.files.\" + this.driverId + \".tenant.\" + swiftEndPoint);\n-        String swiftEndPointAuthMethod = System.getProperty(\"dataverse.files.\" + this.driverId + \".authType.\" + swiftEndPoint);\n-        String swiftEndPointTenantId = System.getProperty(\"dataverse.files.\" + this.driverId + \".tenant.\" + swiftEndPoint);\n+    return fileObject;\n \n-        if (swiftEndPointAuthUrl == null || swiftEndPointUsername == null || swiftEndPointSecretKey == null\n-                || \"\".equals(swiftEndPointAuthUrl) || \"\".equals(swiftEndPointUsername) || \"\".equals(swiftEndPointSecretKey)) {\n-            // again, all of these things need to be defined, for this Swift endpoint to be \n-            // accessible.\n-            throw new IOException(\"SwiftAccessIO: no configuration available for endpoint \" + swiftEndPoint);\n-        }\n+  }\n \n-        // Authenticate: \n-        Account account = null;\n+  private InputStream openSwiftFileAsInputStream() throws IOException {\n+    swiftFileObject = initializeSwiftFileObject(false);\n+    this.setSize(swiftFileObject.getContentLength());\n \n-        /*\n-        This try { } now authenticates using either the KEYSTONE mechanism which uses\n-        the tenant name in addition to the Username Password and AuthUrl OR the BASIC method\n-        Also, the AuthUrl is now the identity service endpoint of MOC Openstack\n-        environment instead of the Object store service endpoint.\n-         */\n-        // Keystone vs. Basic vs. Keystone V3\n-        try {\n-            if (swiftEndPointAuthMethod.equals(\"keystone\")) {\n-                logger.fine(\"Authentication type: keystone v2.0\");\n-                account = new AccountFactory()\n-                        .setTenantName(swiftEndPointTenantName)\n-                        .setUsername(swiftEndPointUsername)\n-                        .setPassword(swiftEndPointSecretKey)\n-                        .setAuthUrl(swiftEndPointAuthUrl)\n-                        .createAccount();\n-            } else if (swiftEndPointAuthMethod.equals(\"keystone_v3\")) {\n-                logger.fine(\"Authentication type: keystone_v3\");\n-                account = new AccountFactory()\n-                        .setTenantName(swiftEndPointTenantName)\n-                        .setUsername(swiftEndPointUsername)\n-                        .setAuthenticationMethod(KEYSTONE_V3)\n-                        .setPassword(swiftEndPointSecretKey)\n-                        .setAuthUrl(swiftEndPointAuthUrl)\n-                        .createAccount();\n-            }\n-            else { // assume BASIC\n-                logger.fine(\"Authentication type: basic\");\n-                account = new AccountFactory()\n-                        .setUsername(swiftEndPointUsername)\n-                        .setPassword(swiftEndPointSecretKey)\n-                        .setAuthUrl(swiftEndPointAuthUrl)\n-                        .setAuthenticationMethod(BASIC)\n-                        .createAccount();\n-            }\n+    return swiftFileObject.downloadObjectAsInputStream();\n+  }\n \n-        } catch (Exception ex) {\n-            ex.printStackTrace();\n-            throw new IOException(\"SwiftAccessIO: failed to authenticate \" + swiftEndPointAuthMethod + \" for the end point \" + swiftEndPoint);\n-        }\n+  private InputStream openSwiftAuxFileAsInputStream(String auxItemTag) throws IOException {\n+    return initializeSwiftFileObject(false, auxItemTag).downloadObjectAsInputStream();\n+  }\n \n-        return account;\n-    }\n-    \n-    private String getSwiftFileURI(StoredObject fileObject) throws IOException {\n-        try {\n-            return fileObject.getPublicURL();\n-        } catch (Exception ex) {\n-            throw new IOException(\"SwiftAccessIO: failed to get public URL of the stored object\");\n-        }\n-    }\n-    \n-    //these all get called a lot (20+ times) to load a page\n-    //lets cache them if the expiry is not expired\n-    private String hmac = null;\n-    public String generateTempUrlSignature(String swiftEndPoint, String containerName, String objectName, int duration) throws IOException {\n-        if (hmac == null || isExpiryExpired(generateTempUrlExpiry(duration, System.currentTimeMillis()), duration, System.currentTimeMillis())) {\n-            String secretKey = System.getProperty(\"dataverse.files.\" + this.driverId + \".hashKey.\" + swiftEndPoint);\n-            if (secretKey == null) {\n-                throw new IOException(\"Please input a hash key under dataverse.files.\" + this.driverId + \".hashKey.\" + swiftEndPoint);\n-            }\n-            String path = \"/v1/\" + containerName + \"/\" + objectName;\n-            Long expires = generateTempUrlExpiry(duration, System.currentTimeMillis());\n-            String hmacBody = \"GET\\n\" + expires + \"\\n\" + path;\n-            try {\n-                hmac = calculateRFC2104HMAC(hmacBody, secretKey);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-        return hmac;\n+  private StoredObject openSwiftAuxFile(String auxItemTag) throws IOException {\n+    return openSwiftAuxFile(false, auxItemTag);\n+  }\n \n-    }\n-    \n-    private long expiry = -1;\n-    public long generateTempUrlExpiry(int duration, long currentTime) {\n-        if (expiry == -1 || isExpiryExpired(expiry, duration, System.currentTimeMillis())) {\n-            expiry = (currentTime / 1000) + duration;\n-        }\n-        return expiry;\n-    }\n+  private StoredObject openSwiftAuxFile(boolean writeAccess, String auxItemTag) throws IOException {\n+    return initializeSwiftFileObject(writeAccess, auxItemTag);\n+  }\n \n-    private String temporaryUrl = null;\n-    private String generateTemporarySwiftUrl(String swiftEndPoint, String containerName, String objectName, int duration) throws IOException {\n-        String baseUrl = System.getProperty(\"dataverse.files.\" + this.driverId + \".endpoint.\" + swiftEndPoint);\n-        String path = \"/v1/\" + containerName + \"/\" + objectName;\n-        \n-        if (temporaryUrl == null || isExpiryExpired(generateTempUrlExpiry(duration, System.currentTimeMillis()), duration, System.currentTimeMillis())) {\n-            temporaryUrl = baseUrl + path + \"?temp_url_sig=\" + generateTempUrlSignature(swiftEndPoint, containerName, objectName, duration) + \"&temp_url_expires=\" + generateTempUrlExpiry(duration, System.currentTimeMillis());\n-        }\n-        if (temporaryUrl == null) {\n-            throw new IOException(\"Failed to generate the temporary Url\");\n-        }\n+  Account authenticateWithSwift(String swiftEndPoint) throws IOException {\n+    String swiftEndPointAuthUrl = System.getProperty(\"dataverse.files.\" + this.driverId + \".authUrl.\" + swiftEndPoint);\n+    String swiftEndPointUsername =\n+      System.getProperty(\"dataverse.files.\" + this.driverId + \".username.\" + swiftEndPoint);\n+    String swiftEndPointSecretKey =\n+      System.getProperty(\"dataverse.files.\" + this.driverId + \".password.\" + swiftEndPoint);\n+    String swiftEndPointTenantName =\n+      System.getProperty(\"dataverse.files.\" + this.driverId + \".tenant.\" + swiftEndPoint);\n+    String swiftEndPointAuthMethod =\n+      System.getProperty(\"dataverse.files.\" + this.driverId + \".authType.\" + swiftEndPoint);\n+    String swiftEndPointTenantId = System.getProperty(\"dataverse.files.\" + this.driverId + \".tenant.\" + swiftEndPoint);\n \n-        return temporaryUrl;\n-    }\n-    \n-    public boolean isExpiryExpired(long expiry, int duration, long currentTime) {\n-        return ((expiry - duration) * 1000) > currentTime;\n+    if (swiftEndPointAuthUrl == null || swiftEndPointUsername == null || swiftEndPointSecretKey == null\n+      || \"\".equals(swiftEndPointAuthUrl) || \"\".equals(swiftEndPointUsername) || \"\".equals(swiftEndPointSecretKey)) {\n+      // again, all of these things need to be defined, for this Swift endpoint to be\n+      // accessible.\n+      throw new IOException(\"SwiftAccessIO: no configuration available for endpoint \" + swiftEndPoint);\n     }\n \n-    @Override\n-    public InputStream getAuxFileAsInputStream(String auxItemTag) throws IOException {        \n-        if (this.isAuxObjectCached(auxItemTag)) {\n-            return openSwiftAuxFileAsInputStream(auxItemTag);\n-        } else {\n-            throw new IOException(\"SwiftAccessIO: Failed to get aux file as input stream\");\n-        }\n-    }\n+    // Authenticate:\n+    Account account = null;\n \n-    @Override\n-    public String getSwiftContainerName() {\n-        if (dvObject instanceof DataFile) {\n-            String authorityNoSlashes = this.getDataFile().getOwner().getAuthorityForFileStorage().replace(\"/\", swiftFolderPathSeparator);\n-            return this.getDataFile().getOwner().getProtocolForFileStorage() + swiftFolderPathSeparator\n-                   +            authorityNoSlashes.replace(\".\", swiftFolderPathSeparator) +\n-                swiftFolderPathSeparator + this.getDataFile().getOwner().getIdentifierForFileStorage();\n-        }\n-        return null;\n-     }\n-     \n-    //https://gist.github.com/ishikawa/88599\n-    public static String toHexString(byte[] bytes) {\n-        Formatter formatter = new Formatter();\n-\n-        for (byte b : bytes) {\n-            formatter.format(\"%02x\", b);\n-        }\n-        \n-        return formatter.toString();\n+        /*\n+        This try { } now authenticates using either the KEYSTONE mechanism which uses\n+        the tenant name in addition to the Username Password and AuthUrl OR the BASIC method\n+        Also, the AuthUrl is now the identity service endpoint of MOC Openstack\n+        environment instead of the Object store service endpoint.\n+         */\n+    // Keystone vs. Basic vs. Keystone V3\n+    try {\n+      if (swiftEndPointAuthMethod.equals(\"keystone\")) {\n+        logger.fine(\"Authentication type: keystone v2.0\");\n+        account = new AccountFactory()\n+          .setTenantName(swiftEndPointTenantName)\n+          .setUsername(swiftEndPointUsername)\n+          .setPassword(swiftEndPointSecretKey)\n+          .setAuthUrl(swiftEndPointAuthUrl)\n+          .createAccount();\n+      } else if (swiftEndPointAuthMethod.equals(\"keystone_v3\")) {\n+        logger.fine(\"Authentication type: keystone_v3\");\n+        account = new AccountFactory()\n+          .setTenantName(swiftEndPointTenantName)\n+          .setUsername(swiftEndPointUsername)\n+          .setAuthenticationMethod(KEYSTONE_V3)\n+          .setPassword(swiftEndPointSecretKey)\n+          .setAuthUrl(swiftEndPointAuthUrl)\n+          .createAccount();\n+      } else { // assume BASIC\n+        logger.fine(\"Authentication type: basic\");\n+        account = new AccountFactory()\n+          .setUsername(swiftEndPointUsername)\n+          .setPassword(swiftEndPointSecretKey)\n+          .setAuthUrl(swiftEndPointAuthUrl)\n+          .setAuthenticationMethod(BASIC)\n+          .createAccount();\n+      }\n+\n+    } catch (Exception ex) {\n+      ex.printStackTrace();\n+      throw new IOException(\n+        \"SwiftAccessIO: failed to authenticate \" + swiftEndPointAuthMethod + \" for the end point \" + swiftEndPoint);\n+    }\n+\n+    return account;\n+  }\n+\n+  private String getSwiftFileURI(StoredObject fileObject) throws IOException {\n+    try {\n+      return fileObject.getPublicURL();\n+    } catch (Exception ex) {\n+      throw new IOException(\"SwiftAccessIO: failed to get public URL of the stored object\");\n+    }\n+  }\n+\n+  //these all get called a lot (20+ times) to load a page\n+  //lets cache them if the expiry is not expired\n+  private String hmac = null;\n+\n+  public String generateTempUrlSignature(String swiftEndPoint, String containerName, String objectName, int duration)\n+    throws IOException {\n+    if (hmac == null || isExpiryExpired(generateTempUrlExpiry(duration, System.currentTimeMillis()), duration,\n+      System.currentTimeMillis())) {\n+      String secretKey = System.getProperty(\"dataverse.files.\" + this.driverId + \".hashKey.\" + swiftEndPoint);\n+      if (secretKey == null) {\n+        throw new IOException(\n+          \"Please input a hash key under dataverse.files.\" + this.driverId + \".hashKey.\" + swiftEndPoint);\n+      }\n+      String path = \"/v1/\" + containerName + \"/\" + objectName;\n+      Long expires = generateTempUrlExpiry(duration, System.currentTimeMillis());\n+      String hmacBody = \"GET\\n\" + expires + \"\\n\" + path;\n+      try {\n+        hmac = calculateRFC2104HMAC(hmacBody, secretKey);\n+      } catch (Exception ex) {\n+        ex.printStackTrace();\n+      }\n+    }\n+    return hmac;\n+\n+  }\n+\n+  private long expiry = -1;\n+\n+  public long generateTempUrlExpiry(int duration, long currentTime) {\n+    if (expiry == -1 || isExpiryExpired(expiry, duration, System.currentTimeMillis())) {\n+      expiry = (currentTime / 1000) + duration;\n+    }\n+    return expiry;\n+  }\n+\n+  private String temporaryUrl = null;\n+\n+  private String generateTemporarySwiftUrl(String swiftEndPoint, String containerName, String objectName, int duration)\n+    throws IOException {\n+    String baseUrl = System.getProperty(\"dataverse.files.\" + this.driverId + \".endpoint.\" + swiftEndPoint);\n+    String path = \"/v1/\" + containerName + \"/\" + objectName;\n+\n+    if (temporaryUrl == null || isExpiryExpired(generateTempUrlExpiry(duration, System.currentTimeMillis()), duration,\n+      System.currentTimeMillis())) {\n+      temporaryUrl = baseUrl + path + \"?temp_url_sig=\" +\n+        generateTempUrlSignature(swiftEndPoint, containerName, objectName, duration) + \"&temp_url_expires=\" +\n+        generateTempUrlExpiry(duration, System.currentTimeMillis());\n+    }\n+    if (temporaryUrl == null) {\n+      throw new IOException(\"Failed to generate the temporary Url\");\n+    }\n+\n+    return temporaryUrl;\n+  }\n+\n+  public boolean isExpiryExpired(long expiry, int duration, long currentTime) {\n+    return ((expiry - duration) * 1000) > currentTime;\n+  }\n+\n+  @Override\n+  public InputStream getAuxFileAsInputStream(String auxItemTag) throws IOException {\n+    if (this.isAuxObjectCached(auxItemTag)) {\n+      return openSwiftAuxFileAsInputStream(auxItemTag);\n+    } else {\n+      throw new IOException(\"SwiftAccessIO: Failed to get aux file as input stream\");\n+    }\n+  }\n+\n+  @Override\n+  public String getSwiftContainerName() {\n+    if (dvObject instanceof DataFile) {\n+      String authorityNoSlashes =\n+        this.getDataFile().getOwner().getAuthorityForFileStorage().replace(\"/\", swiftFolderPathSeparator);\n+      return this.getDataFile().getOwner().getProtocolForFileStorage() + swiftFolderPathSeparator\n+        + authorityNoSlashes.replace(\".\", swiftFolderPathSeparator) +\n+        swiftFolderPathSeparator + this.getDataFile().getOwner().getIdentifierForFileStorage();\n+    }\n+    return null;\n+  }\n+\n+  //https://gist.github.com/ishikawa/88599\n+  public static String toHexString(byte[] bytes) {\n+    Formatter formatter = new Formatter();\n+\n+    for (byte b : bytes) {\n+      formatter.format(\"%02x\", b);\n     }\n \n-    public static String calculateRFC2104HMAC(String data, String key)\n-            throws SignatureException, NoSuchAlgorithmException, InvalidKeyException {\n-        SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);\n-        Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);\n-        mac.init(signingKey);\n-        return toHexString(mac.doFinal(data.getBytes()));\n-    }\n-     \n+    return formatter.toString();\n+  }\n+\n+  public static String calculateRFC2104HMAC(String data, String key)\n+    throws SignatureException, NoSuchAlgorithmException, InvalidKeyException {\n+    SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);\n+    Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);\n+    mac.init(signingKey);\n+    return toHexString(mac.doFinal(data.getBytes()));\n+  }\n+\n }\n",
            "diff_size": 1051
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/94/SwiftAccessIO.java\nindex 3bc29cb9836..7236452f3b4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/94/SwiftAccessIO.java\n@@ -1,4 +1,5 @@\n package edu.harvard.iq.dataverse.dataaccess;\n+\n import edu.harvard.iq.dataverse.DataFile;\n import edu.harvard.iq.dataverse.Dataset;\n import edu.harvard.iq.dataverse.Dataverse;\n@@ -41,40 +42,40 @@ import org.javaswift.joss.model.StoredObject;\n     Swift driver, implemented as part of the Dataverse - Mass Open Cloud\n     collaboration. \n  */\n+\n+\n public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n \n     private String swiftFolderPath;\n-    private String swiftLocation; \n-\n+    private String swiftLocation;\n     private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.dataaccess.SwiftAccessIO\");\n \n-\tpublic SwiftAccessIO() {\n-\t\t//Partially functional StorageIO object - constructor only for testing\n-\t\tsuper();\n-\t}\n-\t\n+    public SwiftAccessIO() {\n+        //Partially functional StorageIO object - constructor only for testing\n+        super();\n+    }\n+\n     public SwiftAccessIO(T dvObject, DataAccessRequest req, String driverId) {\n         super(dvObject, req, driverId);\n         readSettings();\n         this.setIsLocalFile(false);\n     }\n-    \n+\n     public SwiftAccessIO(String swiftLocation, String driverId) {\n-    \tsuper(swiftLocation, driverId);\n-    \treadSettings();\n+        super(swiftLocation, driverId);\n+        readSettings();\n         this.swiftLocation = swiftLocation;\n         this.setIsLocalFile(false);\n     }\n \n     private void readSettings() {\n-    \tisPublicContainer = Boolean.parseBoolean(System.getProperty(\"dataverse.files.\" + this.driverId + \".isPublicContainer\", \"true\"));\n+        isPublicContainer = Boolean.parseBoolean(System.getProperty(\"dataverse.files.\" + this.driverId + \".isPublicContainer\", \"true\"));\n         swiftFolderPathSeparator = System.getProperty(\"dataverse.files.\" + this.driverId + \".folderPathSeparator\", \"_\");\n         swiftDefaultEndpoint = System.getProperty(\"dataverse.files.\" + this.driverId + \".defaultEndpoint\");\n         tempUrlExpires = Integer.parseInt(System.getProperty(\"dataverse.files.\" + this.driverId + \".temporaryUrlExpiryTime\", \"60\"));\n-\t\t\n-\t}\n+    }\n \n-\tprivate Account account = null;\n+    private Account account = null;\n     private StoredObject swiftFileObject = null;\n     private Container swiftContainer = null;\n     private boolean isPublicContainer = true;\n@@ -87,13 +88,11 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n     //TODO: should this be dynamically generated based on size of file?\n     //Also, this is in seconds\n     private int tempUrlExpires = 60;\n-\n     private static int LIST_PAGE_LIMIT = 100;\n \n     @Override\n     public void open(DataAccessOption... options) throws IOException {\n         DataAccessRequest req = this.getRequest();\n-        \n         if (isWriteAccessRequested(options)) {\n             isWriteAccess = true;\n             isReadAccess = false;\n@@ -105,7 +104,6 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         if (dvObject instanceof DataFile) {\n             String storageIdentifier = dvObject.getStorageIdentifier();\n             DataFile dataFile = this.getDataFile();\n-\n             if (req != null && req.getParameter(\"noVarHeader\") != null) {\n                 this.setNoVarHeader(true);\n             }\n@@ -116,32 +114,22 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n \n             if (isReadAccess) {\n                 InputStream fin = openSwiftFileAsInputStream();\n-\n                 if (fin == null) {\n                     throw new IOException(\"Failed to open Swift file \" + getStorageLocation());\n                 }\n-\n                 this.setInputStream(fin);\n                 setChannel(Channels.newChannel(fin));\n-\n-                if (dataFile.getContentType() != null\n-                        && dataFile.getContentType().equals(\"text/tab-separated-values\")\n-                        && dataFile.isTabularData()\n-                        && dataFile.getDataTable() != null\n-                        && (!this.noVarHeader())) {\n-\n+                if (dataFile.getContentType() != null && dataFile.getContentType().equals(\"text/tab-separated-values\")\n+                && dataFile.isTabularData()\n+                && dataFile.getDataTable() != null && (!this.noVarHeader())) {\n                     List<DataVariable> datavariables = dataFile.getDataTable().getDataVariables();\n                     String varHeaderLine = generateVariableHeader(datavariables);\n                     this.setVarHeader(varHeaderLine);\n                 }\n-\n             } else if (isWriteAccess) {\n                 swiftFileObject = initializeSwiftFileObject(true);\n             }\n-\n             this.setMimeType(dataFile.getContentType());\n-\n-\n             try {\n                 this.setFileName(dataFile.getFileMetadata().getLabel());\n             } catch (Exception ex) {\n@@ -153,76 +141,62 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n             if (isReadAccess) {\n                 //TODO: fix this\n                 InputStream fin = openSwiftFileAsInputStream();\n-\n                 if (fin == null) {\n                     throw new IOException(\"Failed to open Swift file \" + getStorageLocation());\n                 }\n-\n                 this.setInputStream(fin);\n             } else if (isWriteAccess) {\n                 swiftFileObject = initializeSwiftFileObject(true);\n             }\n-        } else if (dvObject instanceof Dataverse) {\n-        } else {\n-            throw new IOException(\"Data Access: Invalid DvObject type\");\n-        }\n+        } else if (dvObject instanceof Dataverse) {} else {\n+                   throw new IOException(\"Data Access: Invalid DvObject type\");\n+               }\n     }\n \n \n     // StorageIO method for copying a local Path (for ex., a temp file), into this DataAccess location:\n+\n     @Override\n     public void savePath(Path fileSystemPath) throws IOException {\n         long newFileSize = -1;\n-\n         if (swiftFileObject == null || !this.canWrite()) {\n             open(DataAccessOption.WRITE_ACCESS);\n         }\n-\n         try {\n             File inputFile = fileSystemPath.toFile();\n-\n             swiftFileObject.uploadObject(inputFile);\n-\n             newFileSize = inputFile.length();\n-\n         } catch (Exception ioex) {\n             String failureMsg = ioex.getMessage();\n             if (failureMsg == null) {\n                 failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n             }\n-\n             throw new IOException(failureMsg);\n         }\n \n         // if it has uploaded successfully, we can reset the size\n         // of the object:\n         setSize(newFileSize);\n-\n     }\n-    \n-    \n+\n     @Override\n     public void saveInputStream(InputStream inputStream, Long filesize) throws IOException {\n         saveInputStream(inputStream);\n     }\n-    \n+\n     @Override\n     public void saveInputStream(InputStream inputStream) throws IOException {\n         long newFileSize = -1;\n-\n         if (swiftFileObject == null || !this.canWrite()) {\n             open(DataAccessOption.WRITE_ACCESS);\n         }\n-\n         try {\n             swiftFileObject.uploadObject(inputStream);\n-\n         } catch (Exception ioex) {\n             String failureMsg = ioex.getMessage();\n             if (failureMsg == null) {\n                 failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n             }\n-\n             throw new IOException(failureMsg);\n         }\n \n@@ -245,33 +219,27 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n             swiftFileObject.delete();\n         }\n     }*/\n-    \n+\n     @Override\n     public void delete() throws IOException {\n         if (!isDirectAccess()) {\n             throw new IOException(\"Direct Access IO must be used to permanently delete stored file objects\");\n         }\n-        \n         swiftFileObject = initializeSwiftFileDirectAccess();\n         swiftFileObject.delete();\n     }\n-    \n \n     @Override\n     public Channel openAuxChannel(String auxItemTag, DataAccessOption... options) throws IOException {\n-\n         if (isWriteAccessRequested(options)) {\n             throw new UnsupportedDataAccessOperationException(\"SwiftAccessIO: write mode openAuxChannel() not yet implemented in this storage driver.\");\n         }\n \n         InputStream fin = openSwiftAuxFileAsInputStream(auxItemTag);\n-\n         if (fin == null) {\n             throw new IOException(\"Failed to open auxilary file \" + auxItemTag + \" for Swift file \" + getStorageLocation());\n         }\n-\n         return Channels.newChannel(fin);\n-\n     }\n \n     @Override\n@@ -282,18 +250,15 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         } catch (IOException ioex) {\n             swiftAuxObject = null;\n         }\n-\n         return swiftAuxObject != null;\n     }\n \n     @Override\n     public long getAuxObjectSize(String auxItemTag) throws IOException {\n         StoredObject swiftAuxObject = openSwiftAuxFile(auxItemTag);\n-\n         if (swiftAuxObject == null) {\n             return -1L;\n         }\n-\n         return swiftAuxObject.getContentLength();\n     }\n \n@@ -304,53 +269,43 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n \n     @Override\n     public void backupAsAux(String auxItemTag) throws IOException {\n-\n         if (swiftFileObject == null || swiftContainer == null) {\n             open();\n         }\n-\n         try {\n             StoredObject swiftAuxObject = openSwiftAuxFile(true, auxItemTag);\n             swiftFileObject.copyObject(swiftContainer, swiftAuxObject);\n             // I'm assuming we don't need to delete the main object here - ?\n             //swiftFileObject.delete();\n-\n         } catch (IOException ioex) {\n             String failureMsg = ioex.getMessage();\n             if (failureMsg == null) {\n                 failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n             }\n-\n             throw new IOException(failureMsg);\n         }\n     }\n-    \n+\n     @Override\n     public void revertBackupAsAux(String auxItemTag) throws IOException {\n         // We are going to try and overwrite the current main file \n         // with the contents of the stored original, currently saved as an \n         // Aux file. So we need WRITE access on the main file: \n-        \n         if (swiftFileObject == null || swiftContainer == null || !this.canWrite()) {\n             open(DataAccessOption.WRITE_ACCESS);\n         }\n-\n         try {\n             // We are writing FROM the saved AUX object, back to the main object;\n             // So we need READ access on the AUX object:\n-            \n             StoredObject swiftAuxObject = openSwiftAuxFile(auxItemTag);\n             swiftAuxObject.copyObject(swiftContainer, swiftFileObject);\n-\n         } catch (Exception ex) {\n             String failureMsg = ex.getMessage();\n             if (failureMsg == null) {\n                 failureMsg = \"Swift AccessIO: Unknown exception occured while renaming orig file\";\n             }\n-\n             throw new IOException(failureMsg);\n         }\n-\n     }\n \n     @Override\n@@ -359,47 +314,39 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         if (swiftFileObject == null) {\n             open();\n         }\n-\n         try {\n             File inputFile = fileSystemPath.toFile();\n             StoredObject swiftAuxObject = openSwiftAuxFile(true, auxItemTag);\n             swiftAuxObject.uploadObject(inputFile);\n-\n         } catch (IOException ex) {\n             String failureMsg = ex.getMessage();\n-\n             if (failureMsg == null) {\n                 failureMsg = \"Swift AccessIO: Unknown exception occured while uploading a local file into a Swift StoredObject\";\n             }\n-\n             throw new IOException(failureMsg);\n         }\n-\n     }\n-    \n+\n     @Override\n     public void saveInputStreamAsAux(InputStream inputStream, String auxItemTag, Long filesize) throws IOException {\n         saveInputStreamAsAux(inputStream, auxItemTag);\n     }\n     \n     // this method copies a local InputStream into this DataAccess Auxiliary location:\n+\n     @Override\n     public void saveInputStreamAsAux(InputStream inputStream, String auxItemTag) throws IOException {\n         if (swiftFileObject == null) {\n             open();\n         }\n-\n         try {\n             StoredObject swiftAuxObject = openSwiftAuxFile(true, auxItemTag);\n             swiftAuxObject.uploadObject(inputStream);\n-\n         } catch (IOException ex) {\n             String failureMsg = ex.getMessage();\n-\n             if (failureMsg == null) {\n                 failureMsg = \"Swift AccessIO: Unknown exception occured while saving a local InputStream as a Swift StoredObject\";\n             }\n-\n             throw new IOException(failureMsg);\n         }\n     }\n@@ -409,31 +356,26 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         if (this.swiftContainer == null || this.swiftFileObject == null) {\n             throw new IOException(\"This SwiftAccessIO() hasn't been properly initialized yet.\");\n         }\n-        \n-        String namePrefix = this.swiftFileObject.getName()+\".\";\n-        \n-        Collection<StoredObject> items; \n-        String lastItemName = null; \n-        List<String> ret = new ArrayList<>();\n \n+        String namePrefix = this.swiftFileObject.getName() + \".\";\n+        Collection<StoredObject> items;\n+        String lastItemName = null;\n+        List<String> ret = new ArrayList<>();\n         while ((items = this.swiftContainer.list(namePrefix, lastItemName, LIST_PAGE_LIMIT)) != null && items.size() > 0) {\n             for (StoredObject item : items) {\n                 lastItemName = item.getName().substring(namePrefix.length());\n                 ret.add(lastItemName);\n             }\n         }\n-\n         return ret;\n     }\n \n     @Override\n     public void deleteAuxObject(String auxItemTag) throws IOException {\n         StoredObject swiftAuxObject = openSwiftAuxFile(auxItemTag);\n-\n         if (swiftAuxObject == null) {\n             throw new FileNotFoundException(\"No such Aux object: \" + auxItemTag);\n         }\n-\n         swiftAuxObject.delete();\n     }\n \n@@ -443,14 +385,12 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n             throw new IOException(\"This SwiftAccessIO() hasn't been properly initialized yet. (did you execute SwiftAccessIO.open()?)\");\n         }\n \n-        Collection<StoredObject> victims; \n-        String lastVictim = null; \n-          \n-        while ((victims = this.swiftContainer.list(this.swiftFileObject.getName()+\".\", lastVictim, LIST_PAGE_LIMIT))!= null && victims.size() > 0) {\n+        Collection<StoredObject> victims;\n+        String lastVictim = null;\n+        while ((victims = this.swiftContainer.list(this.swiftFileObject.getName() + \".\", lastVictim, LIST_PAGE_LIMIT)) != null && victims.size() > 0) {\n             for (StoredObject victim : victims) {\n                 lastVictim = victim.getName();\n                 logger.info(\"trying to delete \" + lastVictim);\n-\n                 victim.delete();\n             }\n         }\n@@ -459,7 +399,7 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n     @Override\n     public String getStorageLocation() {\n         if (isDirectAccess()) {\n-            return \"swift://\" + swiftLocation; \n+            return \"swift://\" + swiftLocation;\n         }\n         // For Swift, the \"storageLocation\" and \"storageIdentifier\" of the DvObject are the same thing.\n         return dvObject.getStorageIdentifier();\n@@ -477,7 +417,6 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         } catch (FileNotFoundException fnfe) {\n             return false;\n         }\n-\n         return true;\n     }\n \n@@ -493,6 +432,7 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n \n     // Auxilary helper methods, Swift-specific:\n     //TODO: rename initializeSwiftObject \n+\n     private StoredObject initializeSwiftFileObject(boolean writeAccess) throws IOException {\n         return initializeSwiftFileObject(writeAccess, null);\n     }\n@@ -501,27 +441,20 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         String swiftEndPoint = null;\n         String swiftContainerName = null;\n         String swiftFileName = null;\n-\n         StoredObject fileObject;\n         String storageIdentifier = dvObject.getStorageIdentifier();\n-\n         if (dvObject instanceof DataFile) {\n             Dataset owner = this.getDataFile().getOwner();\n-\n             if (storageIdentifier.startsWith(this.driverId + \"://\")) {\n                 // This is a call on an already existing swift object. \n-\n-                String[] swiftStorageTokens = storageIdentifier.substring(8).split(\":\", 3);    \n-\n+                String[] swiftStorageTokens = storageIdentifier.substring(8).split(\":\", 3);\n                 if (swiftStorageTokens.length != 3) {\n                     // bad storage identifier\n                     throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n                 }\n-\n                 swiftEndPoint = swiftStorageTokens[0];\n                 swiftContainerName = swiftStorageTokens[1];\n                 swiftFileName = swiftStorageTokens[2];\n-\n                 if (StringUtil.isEmpty(swiftEndPoint) || StringUtil.isEmpty(swiftContainerName) || StringUtil.isEmpty(swiftFileName)) {\n                     // all of these things need to be specified, for this to be a valid Swift location\n                     // identifier.\n@@ -529,36 +462,32 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n                 }\n \n                 if (auxItemTag != null) {\n-                    swiftFileName = swiftFileName.concat(\".\"+auxItemTag);\n+                    swiftFileName = swiftFileName.concat(\".\" + auxItemTag);\n                 }\n             } else if (this.isReadAccess) {\n                 // An attempt to call Swift driver,  in a Read mode on a non-swift stored datafile\n                 // object!\n                 throw new IOException(\"IO driver mismatch: SwiftAccessIO called on a non-swift stored object.\");\n             } else if (this.isWriteAccess) {\n-                swiftEndPoint = swiftDefaultEndpoint;\n+                       swiftEndPoint = swiftDefaultEndpoint;\n \n                 // Swift uses this to create pseudo-hierarchical folders\n-                String swiftPseudoFolderPathSeparator = \"/\";\n+                       String swiftPseudoFolderPathSeparator = \"/\";\n \n                 //swiftFolderPath = dataFile.getOwner().getDisplayName();\n-                String swiftFolderPathSeparator = \"-\";\n-                String authorityNoSlashes = owner.getAuthority().replace(\"/\", swiftFolderPathSeparator);\n-                swiftFolderPath = owner.getProtocolForFileStorage() + swiftFolderPathSeparator\n-                                  + authorityNoSlashes.replace(\".\", swiftFolderPathSeparator);\n-\n-                swiftFileName = owner.getIdentifierForFileStorage() + swiftPseudoFolderPathSeparator\n-                                + storageIdentifier;\n+                       String swiftFolderPathSeparator = \"-\";\n+                       String authorityNoSlashes = owner.getAuthority().replace(\"/\", swiftFolderPathSeparator);\n+                       swiftFolderPath = owner.getProtocolForFileStorage() + swiftFolderPathSeparator + authorityNoSlashes.replace(\".\", swiftFolderPathSeparator);\n+                       swiftFileName = owner.getIdentifierForFileStorage() + swiftPseudoFolderPathSeparator + storageIdentifier;\n                 //setSwiftContainerName(swiftFolderPath);\n                 //swiftFileName = dataFile.getDisplayName();\n                 //Storage Identifier is now updated after the object is uploaded on Swift.\n-                dvObject.setStorageIdentifier(this.driverId + \"://\" + swiftDefaultEndpoint + \":\" + swiftFolderPath + \":\" + swiftFileName);\n-            } else {\n-                throw new IOException(\"SwiftAccessIO: unknown access mode.\");\n-            }\n+                       dvObject.setStorageIdentifier(this.driverId + \"://\" + swiftDefaultEndpoint + \":\" + swiftFolderPath + \":\" + swiftFileName);\n+                   } else {\n+                       throw new IOException(\"SwiftAccessIO: unknown access mode.\");\n+                   }\n         } else if (dvObject instanceof Dataset) {\n             Dataset dataset = this.getDataset();\n-\n             if (storageIdentifier.startsWith(this.driverId + \"://\")) {\n                 // This is a call on an already existing swift object. \n \n@@ -569,7 +498,6 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n                     // bad storage identifier\n                     throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n                 }\n-\n                 swiftEndPoint = swiftStorageTokens[0];\n                 swiftContainerName = swiftStorageTokens[1];\n                 //We will not have a file name, just an aux tag\n@@ -577,37 +505,32 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n                     swiftFileName = auxItemTag;\n                 } else {\n                     throw new IOException(\"Dataset related auxillary files require an auxItemTag\");\n-                }       \n+                }\n \n-                if (StringUtil.isEmpty(swiftEndPoint) || StringUtil.isEmpty(swiftContainerName) || StringUtil.isEmpty(swiftFileName) ) {\n+                if (StringUtil.isEmpty(swiftEndPoint) || StringUtil.isEmpty(swiftContainerName) || StringUtil.isEmpty(swiftFileName)) {\n                     // all of these things need to be specified, for this to be a valid Swift location\n                     // identifier.1\n                     throw new IOException(\"SwiftAccessIO: invalid swift storage token: \" + storageIdentifier);\n                 }\n-\n             } else if (this.isReadAccess) {\n                 // An attempt to call Swift driver,  in a Read mode on a non-swift stored datafile\n                 // object!\n                 throw new IOException(\"IO driver mismatch: SwiftAccessIO called on a non-swift stored object.\");\n             } else if (this.isWriteAccess) {\n-                swiftEndPoint = swiftDefaultEndpoint;\n+                       swiftEndPoint = swiftDefaultEndpoint;\n \n                 // Swift uses this to create pseudo-hierarchical folders\n-                String swiftPseudoFolderPathSeparator = \"/\";\n-\n-                String authorityNoSlashes = dataset.getAuthorityForFileStorage().replace(\"/\", swiftFolderPathSeparator);\n-                swiftFolderPath = dataset.getProtocolForFileStorage() + swiftFolderPathSeparator +\n-                    authorityNoSlashes.replace(\".\", swiftFolderPathSeparator) +\n-                    swiftPseudoFolderPathSeparator + dataset.getIdentifierForFileStorage();\n-\n-                swiftFileName = auxItemTag;\n-                dvObject.setStorageIdentifier(this.driverId + \"://\" + swiftEndPoint + \":\" + swiftFolderPath);\n-            } else {\n-                throw new IOException(\"SwiftAccessIO: unknown access mode.\");\n-            }\n+                       String swiftPseudoFolderPathSeparator = \"/\";\n+                       String authorityNoSlashes = dataset.getAuthorityForFileStorage().replace(\"/\", swiftFolderPathSeparator);\n+                       swiftFolderPath = dataset.getProtocolForFileStorage() + swiftFolderPathSeparator + authorityNoSlashes.replace(\".\", swiftFolderPathSeparator) + swiftPseudoFolderPathSeparator + dataset.getIdentifierForFileStorage();\n+                       swiftFileName = auxItemTag;\n+                       dvObject.setStorageIdentifier(this.driverId + \"://\" + swiftEndPoint + \":\" + swiftFolderPath);\n+                   } else {\n+                       throw new IOException(\"SwiftAccessIO: unknown access mode.\");\n+                   }\n         } else {\n             //for future scope, if dataverse is decided to be stored in swift storage containersopen    \n-            throw new FileNotFoundException(\"Error initializing swift object\");  \n+            throw new FileNotFoundException(\"Error initializing swift object\");\n         }\n         // Authenticate with Swift: \n \n@@ -628,6 +551,7 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         other swiftContainerName Object Store pseudo-folder can be created, which is\n         not provide by the joss Java swift library as of yet.\n          */\n+\n         if (storageIdentifier.startsWith(this.driverId + \"://\")) {\n             // An existing swift object; the container must already exist as well.\n             this.swiftContainer = account.getContainer(swiftContainerName);\n@@ -635,6 +559,7 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n             // This is a new object being created.\n             this.swiftContainer = account.getContainer(swiftFolderPath); //changed from swiftendpoint\n         }\n+\n         if (!this.swiftContainer.exists()) {\n             if (writeAccess) {\n                 //creates a private data container\n@@ -643,10 +568,9 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n                     try {\n                         //creates a public data container\n                         this.swiftContainer.makePublic();\n-                    }\n-                    catch (Exception e){\n+                    } catch (Exception e) {\n                         //e.printStackTrace();\n-                        logger.warning(\"Caught exception \"+e.getClass()+\" while creating a swift container (it's likely not fatal!)\");\n+                        logger.warning(\"Caught exception \" + e.getClass() + \" while creating a swift container (it's likely not fatal!)\");\n                     }\n                 }\n             } else {\n@@ -655,7 +579,6 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n                 throw new IOException(\"SwiftAccessIO: container \" + swiftContainerName + \" does not exist.\");\n             }\n         }\n-\n         fileObject = this.swiftContainer.getObject(swiftFileName);\n \n         // If this is the main, primary datafile object (i.e., not an auxiliary \n@@ -669,7 +592,6 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n                 setTempUrlExpiry(generateTempUrlExpiry(tempUrlExpires, System.currentTimeMillis()));\n             }\n             setSwiftFileName(swiftFileName);\n-\n             logger.fine(getRemoteUrl() + \" success; write mode: \" + writeAccess);\n         } else {\n             logger.fine(\"sucessfully opened AUX object \" + auxItemTag + \" , write mode: \" + writeAccess);\n@@ -678,7 +600,6 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         if (!writeAccess && !fileObject.exists()) {\n             throw new FileNotFoundException(\"SwiftAccessIO: DvObject \" + swiftFileName + \" does not exist (Dataverse dvObject id: \" + dvObject.getId());\n         }\n-\n         return fileObject;\n     }\n \n@@ -686,41 +607,31 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         if (!isDirectAccess()) {\n             throw new IOException(\"Direct access attempted on a SwiftAccessIO associated with a DvObject\");\n         }\n-        \n+\n         String swiftEndPoint = null;\n         String swiftContainerName = null;\n         String swiftFileName = null;\n-\n         String[] swiftStorageTokens = swiftLocation.split(\":\", 3);\n-\n         if (swiftStorageTokens.length != 3) {\n             throw new IOException(\"SwiftAccessIO: invalid storage location: \" + swiftLocation);\n         }\n-\n         swiftEndPoint = swiftStorageTokens[0];\n         swiftContainerName = swiftStorageTokens[1];\n         swiftFileName = swiftStorageTokens[2];\n-        \n         if (this.account == null) {\n             account = authenticateWithSwift(swiftEndPoint);\n         }\n-        \n         this.swiftContainer = account.getContainer(swiftContainerName);\n-        \n         StoredObject fileObject = this.swiftContainer.getObject(swiftFileName);\n-\n         if (!fileObject.exists()) {\n             throw new FileNotFoundException(\"SwiftAccessIO/Direct Access: \" + swiftLocation + \" does not exist\");\n         }\n-\n         return fileObject;\n-\n     }\n-    \n+\n     private InputStream openSwiftFileAsInputStream() throws IOException {\n         swiftFileObject = initializeSwiftFileObject(false);\n         this.setSize(swiftFileObject.getContentLength());\n-\n         return swiftFileObject.downloadObjectAsInputStream();\n     }\n \n@@ -743,15 +654,17 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         String swiftEndPointTenantName = System.getProperty(\"dataverse.files.\" + this.driverId + \".tenant.\" + swiftEndPoint);\n         String swiftEndPointAuthMethod = System.getProperty(\"dataverse.files.\" + this.driverId + \".authType.\" + swiftEndPoint);\n         String swiftEndPointTenantId = System.getProperty(\"dataverse.files.\" + this.driverId + \".tenant.\" + swiftEndPoint);\n-\n-        if (swiftEndPointAuthUrl == null || swiftEndPointUsername == null || swiftEndPointSecretKey == null\n-                || \"\".equals(swiftEndPointAuthUrl) || \"\".equals(swiftEndPointUsername) || \"\".equals(swiftEndPointSecretKey)) {\n+        if (swiftEndPointAuthUrl == null || swiftEndPointUsername == null\n+        || swiftEndPointSecretKey == null\n+        || \"\".equals(swiftEndPointAuthUrl)\n+        || \"\".equals(swiftEndPointUsername) || \"\".equals(swiftEndPointSecretKey)) {\n             // again, all of these things need to be defined, for this Swift endpoint to be \n             // accessible.\n             throw new IOException(\"SwiftAccessIO: no configuration available for endpoint \" + swiftEndPoint);\n         }\n \n         // Authenticate: \n+\n         Account account = null;\n \n         /*\n@@ -764,40 +677,21 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n         try {\n             if (swiftEndPointAuthMethod.equals(\"keystone\")) {\n                 logger.fine(\"Authentication type: keystone v2.0\");\n-                account = new AccountFactory()\n-                        .setTenantName(swiftEndPointTenantName)\n-                        .setUsername(swiftEndPointUsername)\n-                        .setPassword(swiftEndPointSecretKey)\n-                        .setAuthUrl(swiftEndPointAuthUrl)\n-                        .createAccount();\n+                account = new AccountFactory().setTenantName(swiftEndPointTenantName).setUsername(swiftEndPointUsername).setPassword(swiftEndPointSecretKey).setAuthUrl(swiftEndPointAuthUrl).createAccount();\n             } else if (swiftEndPointAuthMethod.equals(\"keystone_v3\")) {\n                 logger.fine(\"Authentication type: keystone_v3\");\n-                account = new AccountFactory()\n-                        .setTenantName(swiftEndPointTenantName)\n-                        .setUsername(swiftEndPointUsername)\n-                        .setAuthenticationMethod(KEYSTONE_V3)\n-                        .setPassword(swiftEndPointSecretKey)\n-                        .setAuthUrl(swiftEndPointAuthUrl)\n-                        .createAccount();\n-            }\n-            else { // assume BASIC\n+                account = new AccountFactory().setTenantName(swiftEndPointTenantName).setUsername(swiftEndPointUsername).setAuthenticationMethod(KEYSTONE_V3).setPassword(swiftEndPointSecretKey).setAuthUrl(swiftEndPointAuthUrl).createAccount();\n+            } else { // assume BASIC\n                 logger.fine(\"Authentication type: basic\");\n-                account = new AccountFactory()\n-                        .setUsername(swiftEndPointUsername)\n-                        .setPassword(swiftEndPointSecretKey)\n-                        .setAuthUrl(swiftEndPointAuthUrl)\n-                        .setAuthenticationMethod(BASIC)\n-                        .createAccount();\n+                account = new AccountFactory().setUsername(swiftEndPointUsername).setPassword(swiftEndPointSecretKey).setAuthUrl(swiftEndPointAuthUrl).setAuthenticationMethod(BASIC).createAccount();\n             }\n-\n         } catch (Exception ex) {\n             ex.printStackTrace();\n             throw new IOException(\"SwiftAccessIO: failed to authenticate \" + swiftEndPointAuthMethod + \" for the end point \" + swiftEndPoint);\n         }\n-\n         return account;\n     }\n-    \n+\n     private String getSwiftFileURI(StoredObject fileObject) throws IOException {\n         try {\n             return fileObject.getPublicURL();\n@@ -808,13 +702,16 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n     \n     //these all get called a lot (20+ times) to load a page\n     //lets cache them if the expiry is not expired\n+\n     private String hmac = null;\n+\n     public String generateTempUrlSignature(String swiftEndPoint, String containerName, String objectName, int duration) throws IOException {\n         if (hmac == null || isExpiryExpired(generateTempUrlExpiry(duration, System.currentTimeMillis()), duration, System.currentTimeMillis())) {\n             String secretKey = System.getProperty(\"dataverse.files.\" + this.driverId + \".hashKey.\" + swiftEndPoint);\n             if (secretKey == null) {\n                 throw new IOException(\"Please input a hash key under dataverse.files.\" + this.driverId + \".hashKey.\" + swiftEndPoint);\n             }\n+\n             String path = \"/v1/\" + containerName + \"/\" + objectName;\n             Long expires = generateTempUrlExpiry(duration, System.currentTimeMillis());\n             String hmacBody = \"GET\\n\" + expires + \"\\n\" + path;\n@@ -825,10 +722,10 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n             }\n         }\n         return hmac;\n-\n     }\n-    \n+\n     private long expiry = -1;\n+\n     public long generateTempUrlExpiry(int duration, long currentTime) {\n         if (expiry == -1 || isExpiryExpired(expiry, duration, System.currentTimeMillis())) {\n             expiry = (currentTime / 1000) + duration;\n@@ -840,23 +737,22 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n     private String generateTemporarySwiftUrl(String swiftEndPoint, String containerName, String objectName, int duration) throws IOException {\n         String baseUrl = System.getProperty(\"dataverse.files.\" + this.driverId + \".endpoint.\" + swiftEndPoint);\n         String path = \"/v1/\" + containerName + \"/\" + objectName;\n-        \n         if (temporaryUrl == null || isExpiryExpired(generateTempUrlExpiry(duration, System.currentTimeMillis()), duration, System.currentTimeMillis())) {\n             temporaryUrl = baseUrl + path + \"?temp_url_sig=\" + generateTempUrlSignature(swiftEndPoint, containerName, objectName, duration) + \"&temp_url_expires=\" + generateTempUrlExpiry(duration, System.currentTimeMillis());\n         }\n+\n         if (temporaryUrl == null) {\n             throw new IOException(\"Failed to generate the temporary Url\");\n         }\n-\n         return temporaryUrl;\n     }\n-    \n+\n     public boolean isExpiryExpired(long expiry, int duration, long currentTime) {\n         return ((expiry - duration) * 1000) > currentTime;\n     }\n \n     @Override\n-    public InputStream getAuxFileAsInputStream(String auxItemTag) throws IOException {        \n+    public InputStream getAuxFileAsInputStream(String auxItemTag) throws IOException {\n         if (this.isAuxObjectCached(auxItemTag)) {\n             return openSwiftAuxFileAsInputStream(auxItemTag);\n         } else {\n@@ -868,30 +764,25 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n     public String getSwiftContainerName() {\n         if (dvObject instanceof DataFile) {\n             String authorityNoSlashes = this.getDataFile().getOwner().getAuthorityForFileStorage().replace(\"/\", swiftFolderPathSeparator);\n-            return this.getDataFile().getOwner().getProtocolForFileStorage() + swiftFolderPathSeparator\n-                   +            authorityNoSlashes.replace(\".\", swiftFolderPathSeparator) +\n-                swiftFolderPathSeparator + this.getDataFile().getOwner().getIdentifierForFileStorage();\n+            return this.getDataFile().getOwner().getProtocolForFileStorage() + swiftFolderPathSeparator + authorityNoSlashes.replace(\".\", swiftFolderPathSeparator) + swiftFolderPathSeparator + this.getDataFile().getOwner().getIdentifierForFileStorage();\n         }\n         return null;\n-     }\n+    }\n      \n     //https://gist.github.com/ishikawa/88599\n+\n     public static String toHexString(byte[] bytes) {\n         Formatter formatter = new Formatter();\n-\n         for (byte b : bytes) {\n             formatter.format(\"%02x\", b);\n         }\n-        \n         return formatter.toString();\n     }\n \n-    public static String calculateRFC2104HMAC(String data, String key)\n-            throws SignatureException, NoSuchAlgorithmException, InvalidKeyException {\n+    public static String calculateRFC2104HMAC(String data, String key) throws SignatureException, NoSuchAlgorithmException, InvalidKeyException {\n         SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);\n         Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);\n         mac.init(signingKey);\n         return toHexString(mac.doFinal(data.getBytes()));\n     }\n-     \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 219
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "52",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/94/SwiftAccessIO.java\nindex 3bc29cb9836..5fef3a6dc64 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/94/SwiftAccessIO.java\n@@ -48,7 +48,7 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n \n     private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.dataaccess.SwiftAccessIO\");\n \n-\tpublic SwiftAccessIO() {\n+publicSwiftAccessIOSwiftAccessIO() {\n \t\t//Partially functional StorageIO object - constructor only for testing\n \t\tsuper();\n \t}\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "52",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/94/SwiftAccessIO.java\nindex 3bc29cb9836..ccfb5947da3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/94/SwiftAccessIO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/94/SwiftAccessIO.java\n@@ -46,9 +46,9 @@ public class SwiftAccessIO<T extends DvObject> extends StorageIO<T> {\n     private String swiftFolderPath;\n     private String swiftLocation; \n \n-    private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.dataaccess.SwiftAccessIO\");\n+    private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.dataaccess.SwiftAccessIO\"); public\n \n-\tpublic SwiftAccessIO() {\n+SwiftAccessIO() {\n \t\t//Partially functional StorageIO object - constructor only for testing\n \t\tsuper();\n \t}\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}