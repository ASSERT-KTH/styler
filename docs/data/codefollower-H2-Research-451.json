{
    "project_name": "codefollower-H2-Research",
    "error_id": "451",
    "information": {
        "errors": [
            {
                "line": "185",
                "column": "46",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "     */\n    public void init() {\n        int len = Constants.FILE_BLOCK_SIZE; //16\u5b57\u8282\n        byte[] salt;\n//<<<<<<< HEAD\n//        byte[] magic = HEADER.getBytes(Constants.UTF8);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/451/FileStore.java\nindex e90ce399fdd..27802943929 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/451/FileStore.java\n@@ -182,8 +182,9 @@ public class FileStore {\n      * required.\n      */\n     public void init() {\n-        int len = Constants.FILE_BLOCK_SIZE; //16\u5b57\u8282\n-        byte[] salt;\n+        int len = Constants.FILE_BLOCK_SIZE;\n+        //16\u5b57\u8282\n+         byte[] salt;\n //<<<<<<< HEAD\n //        byte[] magic = HEADER.getBytes(Constants.UTF8);\n //        if (length() < HEADER_LENGTH) { //HEADER_LENGTH = 48, \u7b2c\u4e00\u6b21\u5efa\u7acb*.h2.db\u6587\u4ef6\u65f6length\u4e3a0\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "187",
                    "column": "42",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/451/FileStore.java\nindex e90ce399fdd..bcaffdc8877 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/451/FileStore.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.store;\n \n import java.io.IOException;\n@@ -11,6 +12,7 @@ import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n+\n import org.h2.api.ErrorCode;\n import org.h2.engine.Constants;\n import org.h2.engine.SysProperties;\n@@ -25,496 +27,496 @@ import org.h2.store.fs.FileUtils;\n  */\n public class FileStore {\n \n-    /**\n-     * The size of the file header in bytes.\n-     */\n-    public static final int HEADER_LENGTH = 3 * Constants.FILE_BLOCK_SIZE;\n-\n-    /**\n-     * The magic file header.\n-     */\n-    private static final String HEADER =\n-            \"-- H2 0.5/B --      \".substring(0, Constants.FILE_BLOCK_SIZE - 1) + \"\\n\";\n-\n-    private static final boolean ASSERT;\n-\n-    static {\n-        boolean a = false;\n-        // Intentional side-effect\n-        assert a = true;\n-        ASSERT = a;\n-    }\n-\n-    /**\n-     * The file name.\n-     */\n-    protected String name;\n-\n-    /**\n-     * The callback object is responsible to check access rights, and free up\n-     * disk space if required.\n-     */\n-    private final DataHandler handler;\n-\n-    private FileChannel file;\n-    private long filePos;\n-    private long fileLength;\n-    private Reference<?> autoDeleteReference;\n-    private boolean checkedWriting = true;\n-    private final String mode;\n-    private java.nio.channels.FileLock lock;\n-\n-    /**\n-     * Create a new file using the given settings.\n-     *\n-     * @param handler the callback object\n-     * @param name the file name\n-     * @param mode the access mode (\"r\", \"rw\", \"rws\", \"rwd\")\n-     */\n-    protected FileStore(DataHandler handler, String name, String mode) {\n-        this.handler = handler;\n-        this.name = name;\n-        try {\n-            boolean exists = FileUtils.exists(name);\n-            if (exists && !FileUtils.canWrite(name)) {\n-                mode = \"r\";\n-            } else {\n-                FileUtils.createDirectories(FileUtils.getParent(name));\n-            }\n-            file = FileUtils.open(name, mode);\n-            if (exists) {\n-                fileLength = file.size();\n-            }\n-        } catch (IOException e) {\n-            throw DbException.convertIOException(\n-                    e, \"name: \" + name + \" mode: \" + mode);\n-        }\n-        this.mode = mode;\n-    }\n-\n-    /**\n-     * Open a non encrypted file store with the given settings.\n-     *\n-     * @param handler the data handler\n-     * @param name the file name\n-     * @param mode the access mode (r, rw, rws, rwd)\n-     * @return the created object\n-     */\n-    public static FileStore open(DataHandler handler, String name, String mode) {\n-        return open(handler, name, mode, null, null, 0);\n-    }\n-\n-    /**\n-     * Open an encrypted file store with the given settings.\n-     *\n-     * @param handler the data handler\n-     * @param name the file name\n-     * @param mode the access mode (r, rw, rws, rwd)\n-     * @param cipher the name of the cipher algorithm\n-     * @param key the encryption key\n-     * @return the created object\n-     */\n-    public static FileStore open(DataHandler handler, String name, String mode,\n-            String cipher, byte[] key) {\n-        return open(handler, name, mode, cipher, key,\n-                Constants.ENCRYPTION_KEY_HASH_ITERATIONS);\n-    }\n-\n-    /**\n-     * Open an encrypted file store with the given settings.\n-     *\n-     * @param handler the data handler\n-     * @param name the file name\n-     * @param mode the access mode (r, rw, rws, rwd)\n-     * @param cipher the name of the cipher algorithm\n-     * @param key the encryption key\n-     * @param keyIterations the number of iterations the key should be hashed\n-     * @return the created object\n-     */\n-    public static FileStore open(DataHandler handler, String name, String mode,\n-            String cipher, byte[] key, int keyIterations) {\n-        FileStore store;\n-        if (cipher == null) {\n-            store = new FileStore(handler, name, mode);\n-        } else {\n-            store = new SecureFileStore(handler, name, mode,\n-                    cipher, key, keyIterations);\n-        }\n-        return store;\n-    }\n-\n-    /**\n-     * Generate the random salt bytes if required.\n-     *\n-     * @return the random salt or the magic\n-     */\n-    protected byte[] generateSalt() {\n-        return HEADER.getBytes(StandardCharsets.UTF_8);\n+  /**\n+   * The size of the file header in bytes.\n+   */\n+  public static final int HEADER_LENGTH = 3 * Constants.FILE_BLOCK_SIZE;\n+\n+  /**\n+   * The magic file header.\n+   */\n+  private static final String HEADER =\n+      \"-- H2 0.5/B --      \".substring(0, Constants.FILE_BLOCK_SIZE - 1) + \"\\n\";\n+\n+  private static final boolean ASSERT;\n+\n+  static {\n+    boolean a = false;\n+    // Intentional side-effect\n+    assert a = true;\n+    ASSERT = a;\n+  }\n+\n+  /**\n+   * The file name.\n+   */\n+  protected String name;\n+\n+  /**\n+   * The callback object is responsible to check access rights, and free up\n+   * disk space if required.\n+   */\n+  private final DataHandler handler;\n+\n+  private FileChannel file;\n+  private long filePos;\n+  private long fileLength;\n+  private Reference<?> autoDeleteReference;\n+  private boolean checkedWriting = true;\n+  private final String mode;\n+  private java.nio.channels.FileLock lock;\n+\n+  /**\n+   * Create a new file using the given settings.\n+   *\n+   * @param handler the callback object\n+   * @param name    the file name\n+   * @param mode    the access mode (\"r\", \"rw\", \"rws\", \"rwd\")\n+   */\n+  protected FileStore(DataHandler handler, String name, String mode) {\n+    this.handler = handler;\n+    this.name = name;\n+    try {\n+      boolean exists = FileUtils.exists(name);\n+      if (exists && !FileUtils.canWrite(name)) {\n+        mode = \"r\";\n+      } else {\n+        FileUtils.createDirectories(FileUtils.getParent(name));\n+      }\n+      file = FileUtils.open(name, mode);\n+      if (exists) {\n+        fileLength = file.size();\n+      }\n+    } catch (IOException e) {\n+      throw DbException.convertIOException(\n+          e, \"name: \" + name + \" mode: \" + mode);\n     }\n-\n-    /**\n-     * Initialize the key using the given salt.\n-     *\n-     * @param salt the salt\n-     */\n-    protected void initKey(byte[] salt) {\n-        // do nothing\n+    this.mode = mode;\n+  }\n+\n+  /**\n+   * Open a non encrypted file store with the given settings.\n+   *\n+   * @param handler the data handler\n+   * @param name    the file name\n+   * @param mode    the access mode (r, rw, rws, rwd)\n+   * @return the created object\n+   */\n+  public static FileStore open(DataHandler handler, String name, String mode) {\n+    return open(handler, name, mode, null, null, 0);\n+  }\n+\n+  /**\n+   * Open an encrypted file store with the given settings.\n+   *\n+   * @param handler the data handler\n+   * @param name    the file name\n+   * @param mode    the access mode (r, rw, rws, rwd)\n+   * @param cipher  the name of the cipher algorithm\n+   * @param key     the encryption key\n+   * @return the created object\n+   */\n+  public static FileStore open(DataHandler handler, String name, String mode,\n+                               String cipher, byte[] key) {\n+    return open(handler, name, mode, cipher, key,\n+        Constants.ENCRYPTION_KEY_HASH_ITERATIONS);\n+  }\n+\n+  /**\n+   * Open an encrypted file store with the given settings.\n+   *\n+   * @param handler       the data handler\n+   * @param name          the file name\n+   * @param mode          the access mode (r, rw, rws, rwd)\n+   * @param cipher        the name of the cipher algorithm\n+   * @param key           the encryption key\n+   * @param keyIterations the number of iterations the key should be hashed\n+   * @return the created object\n+   */\n+  public static FileStore open(DataHandler handler, String name, String mode,\n+                               String cipher, byte[] key, int keyIterations) {\n+    FileStore store;\n+    if (cipher == null) {\n+      store = new FileStore(handler, name, mode);\n+    } else {\n+      store = new SecureFileStore(handler, name, mode,\n+          cipher, key, keyIterations);\n     }\n-\n-    public void setCheckedWriting(boolean value) {\n-        this.checkedWriting = value;\n+    return store;\n+  }\n+\n+  /**\n+   * Generate the random salt bytes if required.\n+   *\n+   * @return the random salt or the magic\n+   */\n+  protected byte[] generateSalt() {\n+    return HEADER.getBytes(StandardCharsets.UTF_8);\n+  }\n+\n+  /**\n+   * Initialize the key using the given salt.\n+   *\n+   * @param salt the salt\n+   */\n+  protected void initKey(byte[] salt) {\n+    // do nothing\n+  }\n+\n+  public void setCheckedWriting(boolean value) {\n+    this.checkedWriting = value;\n+  }\n+\n+  private void checkWritingAllowed() {\n+    if (handler != null && checkedWriting) {\n+      handler.checkWritingAllowed();\n     }\n+  }\n \n-    private void checkWritingAllowed() {\n-        if (handler != null && checkedWriting) {\n-            handler.checkWritingAllowed();\n-        }\n+  private void checkPowerOff() {\n+    if (handler != null) {\n+      handler.checkPowerOff();\n     }\n-\n-    private void checkPowerOff() {\n-        if (handler != null) {\n-            handler.checkPowerOff();\n-        }\n-    }\n-\n-    /**\n-     * Initialize the file. This method will write or check the file header if\n-     * required.\n-     */\n-    public void init() {\n-        int len = Constants.FILE_BLOCK_SIZE; //16\u5b57\u8282\n-        byte[] salt;\n+  }\n+\n+  /**\n+   * Initialize the file. This method will write or check the file header if\n+   * required.\n+   */\n+  public void init() {\n+    int len = Constants.FILE_BLOCK_SIZE; //16\u5b57\u8282\n+    byte[] salt;\n //<<<<<<< HEAD\n //        byte[] magic = HEADER.getBytes(Constants.UTF8);\n //        if (length() < HEADER_LENGTH) { //HEADER_LENGTH = 48, \u7b2c\u4e00\u6b21\u5efa\u7acb*.h2.db\u6587\u4ef6\u65f6length\u4e3a0\n //=======\n-        byte[] magic = HEADER.getBytes(StandardCharsets.UTF_8);\n-        if (length() < HEADER_LENGTH) {\n-            // write unencrypted\n-            checkedWriting = false;\n-            //\u5199\u5165\u4e09\u4e2a\"-- H2 0.5/B -- \\n\"\uff0c\u6bcf\u4e2a16\u5b57\u8282\n-            writeDirect(magic, 0, len);\n-            salt = generateSalt();\n-            writeDirect(salt, 0, len);\n-            initKey(salt);\n-            // write (maybe) encrypted\n-            write(magic, 0, len);\n-            checkedWriting = true;\n-        } else {\n-            // read unencrypted\n-            seek(0);\n-            byte[] buff = new byte[len];\n-            readFullyDirect(buff, 0, len);\n-            if (!Arrays.equals(buff, magic)) {\n-                throw DbException.get(ErrorCode.FILE_VERSION_ERROR_1, name);\n-            }\n-            salt = new byte[len];\n-            readFullyDirect(salt, 0, len);\n-            initKey(salt);\n-            // read (maybe) encrypted\n-            readFully(buff, 0, Constants.FILE_BLOCK_SIZE);\n-            if (!Arrays.equals(buff, magic)) {\n-                throw DbException.get(ErrorCode.FILE_ENCRYPTION_ERROR_1, name);\n-            }\n-        }\n+    byte[] magic = HEADER.getBytes(StandardCharsets.UTF_8);\n+    if (length() < HEADER_LENGTH) {\n+      // write unencrypted\n+      checkedWriting = false;\n+      //\u5199\u5165\u4e09\u4e2a\"-- H2 0.5/B -- \\n\"\uff0c\u6bcf\u4e2a16\u5b57\u8282\n+      writeDirect(magic, 0, len);\n+      salt = generateSalt();\n+      writeDirect(salt, 0, len);\n+      initKey(salt);\n+      // write (maybe) encrypted\n+      write(magic, 0, len);\n+      checkedWriting = true;\n+    } else {\n+      // read unencrypted\n+      seek(0);\n+      byte[] buff = new byte[len];\n+      readFullyDirect(buff, 0, len);\n+      if (!Arrays.equals(buff, magic)) {\n+        throw DbException.get(ErrorCode.FILE_VERSION_ERROR_1, name);\n+      }\n+      salt = new byte[len];\n+      readFullyDirect(salt, 0, len);\n+      initKey(salt);\n+      // read (maybe) encrypted\n+      readFully(buff, 0, Constants.FILE_BLOCK_SIZE);\n+      if (!Arrays.equals(buff, magic)) {\n+        throw DbException.get(ErrorCode.FILE_ENCRYPTION_ERROR_1, name);\n+      }\n     }\n-\n-    /**\n-     * Close the file.\n-     */\n-    public void close() {\n-        if (file != null) {\n-            try {\n-                trace(\"close\", name, file);\n-                file.close();\n-            } catch (IOException e) {\n-                throw DbException.convertIOException(e, name);\n-            } finally {\n-                file = null;\n-            }\n-        }\n+  }\n+\n+  /**\n+   * Close the file.\n+   */\n+  public void close() {\n+    if (file != null) {\n+      try {\n+        trace(\"close\", name, file);\n+        file.close();\n+      } catch (IOException e) {\n+        throw DbException.convertIOException(e, name);\n+      } finally {\n+        file = null;\n+      }\n     }\n-\n-    /**\n-     * Close the file without throwing any exceptions. Exceptions are simply\n-     * ignored.\n-     */\n-    public void closeSilently() {\n-        try {\n-            close();\n-        } catch (Exception e) {\n-            // ignore\n-        }\n+  }\n+\n+  /**\n+   * Close the file without throwing any exceptions. Exceptions are simply\n+   * ignored.\n+   */\n+  public void closeSilently() {\n+    try {\n+      close();\n+    } catch (Exception e) {\n+      // ignore\n     }\n-\n-    /**\n-     * Close the file (ignoring exceptions) and delete the file.\n-     */\n-    public void closeAndDeleteSilently() {\n-        if (file != null) {\n-            closeSilently();\n-            handler.getTempFileDeleter().deleteFile(autoDeleteReference, name);\n-            name = null;\n-        }\n+  }\n+\n+  /**\n+   * Close the file (ignoring exceptions) and delete the file.\n+   */\n+  public void closeAndDeleteSilently() {\n+    if (file != null) {\n+      closeSilently();\n+      handler.getTempFileDeleter().deleteFile(autoDeleteReference, name);\n+      name = null;\n     }\n-\n-    /**\n-     * Read a number of bytes without decrypting.\n-     *\n-     * @param b the target buffer\n-     * @param off the offset\n-     * @param len the number of bytes to read\n-     */\n-    public void readFullyDirect(byte[] b, int off, int len) {\n-        readFully(b, off, len);\n+  }\n+\n+  /**\n+   * Read a number of bytes without decrypting.\n+   *\n+   * @param b   the target buffer\n+   * @param off the offset\n+   * @param len the number of bytes to read\n+   */\n+  public void readFullyDirect(byte[] b, int off, int len) {\n+    readFully(b, off, len);\n+  }\n+\n+  /**\n+   * Read a number of bytes.\n+   *\n+   * @param b   the target buffer\n+   * @param off the offset\n+   * @param len the number of bytes to read\n+   */\n+  public void readFully(byte[] b, int off, int len) {\n+    if (len < 0 || len % Constants.FILE_BLOCK_SIZE != 0) {\n+      DbException.throwInternalError(\n+          \"unaligned read \" + name + \" len \" + len);\n     }\n-\n-    /**\n-     * Read a number of bytes.\n-     *\n-     * @param b the target buffer\n-     * @param off the offset\n-     * @param len the number of bytes to read\n-     */\n-    public void readFully(byte[] b, int off, int len) {\n-        if (len < 0 || len % Constants.FILE_BLOCK_SIZE != 0) {\n-            DbException.throwInternalError(\n-                    \"unaligned read \" + name + \" len \" + len);\n-        }\n-        checkPowerOff();\n-        try {\n-            FileUtils.readFully(file, ByteBuffer.wrap(b, off, len));\n-        } catch (IOException e) {\n-            throw DbException.convertIOException(e, name);\n-        }\n-        filePos += len;\n+    checkPowerOff();\n+    try {\n+      FileUtils.readFully(file, ByteBuffer.wrap(b, off, len));\n+    } catch (IOException e) {\n+      throw DbException.convertIOException(e, name);\n     }\n-\n-    /**\n-     * Go to the specified file location.\n-     *\n-     * @param pos the location\n-     */\n-    public void seek(long pos) {\n-        if (pos % Constants.FILE_BLOCK_SIZE != 0) {\n-            DbException.throwInternalError(\n-                    \"unaligned seek \" + name + \" pos \" + pos);\n-        }\n-        try {\n-            if (pos != filePos) {\n-                file.position(pos);\n-                filePos = pos;\n-            }\n-        } catch (IOException e) {\n-            throw DbException.convertIOException(e, name);\n-        }\n+    filePos += len;\n+  }\n+\n+  /**\n+   * Go to the specified file location.\n+   *\n+   * @param pos the location\n+   */\n+  public void seek(long pos) {\n+    if (pos % Constants.FILE_BLOCK_SIZE != 0) {\n+      DbException.throwInternalError(\n+          \"unaligned seek \" + name + \" pos \" + pos);\n     }\n-\n-    /**\n-     * Write a number of bytes without encrypting.\n-     *\n-     * @param b the source buffer\n-     * @param off the offset\n-     * @param len the number of bytes to write\n-     */\n-    protected void writeDirect(byte[] b, int off, int len) {\n-        write(b, off, len);\n+    try {\n+      if (pos != filePos) {\n+        file.position(pos);\n+        filePos = pos;\n+      }\n+    } catch (IOException e) {\n+      throw DbException.convertIOException(e, name);\n     }\n-\n-    /**\n-     * Write a number of bytes.\n-     *\n-     * @param b the source buffer\n-     * @param off the offset\n-     * @param len the number of bytes to write\n-     */\n-    public void write(byte[] b, int off, int len) {\n-        if (len < 0 || len % Constants.FILE_BLOCK_SIZE != 0) {\n-            DbException.throwInternalError(\n-                    \"unaligned write \" + name + \" len \" + len);\n-        }\n-        checkWritingAllowed();\n-        checkPowerOff();\n-        try {\n-            FileUtils.writeFully(file, ByteBuffer.wrap(b, off, len));\n-        } catch (IOException e) {\n-            closeFileSilently();\n-            throw DbException.convertIOException(e, name);\n-        }\n-        filePos += len;\n-        fileLength = Math.max(filePos, fileLength);\n+  }\n+\n+  /**\n+   * Write a number of bytes without encrypting.\n+   *\n+   * @param b   the source buffer\n+   * @param off the offset\n+   * @param len the number of bytes to write\n+   */\n+  protected void writeDirect(byte[] b, int off, int len) {\n+    write(b, off, len);\n+  }\n+\n+  /**\n+   * Write a number of bytes.\n+   *\n+   * @param b   the source buffer\n+   * @param off the offset\n+   * @param len the number of bytes to write\n+   */\n+  public void write(byte[] b, int off, int len) {\n+    if (len < 0 || len % Constants.FILE_BLOCK_SIZE != 0) {\n+      DbException.throwInternalError(\n+          \"unaligned write \" + name + \" len \" + len);\n     }\n-\n-    /**\n-     * Set the length of the file. This will expand or shrink the file.\n-     *\n-     * @param newLength the new file size\n-     */\n-    public void setLength(long newLength) {\n-        if (newLength % Constants.FILE_BLOCK_SIZE != 0) {\n-            DbException.throwInternalError(\n-                    \"unaligned setLength \" + name + \" pos \" + newLength);\n-        }\n-        checkPowerOff();\n-        checkWritingAllowed();\n-        try {\n-            if (newLength > fileLength) {\n-                long pos = filePos;\n-                file.position(newLength - 1);\n-                FileUtils.writeFully(file, ByteBuffer.wrap(new byte[1]));\n-                file.position(pos);\n-            } else {\n-                file.truncate(newLength);\n-            }\n-            fileLength = newLength;\n-        } catch (IOException e) {\n-            closeFileSilently();\n-            throw DbException.convertIOException(e, name);\n-        }\n+    checkWritingAllowed();\n+    checkPowerOff();\n+    try {\n+      FileUtils.writeFully(file, ByteBuffer.wrap(b, off, len));\n+    } catch (IOException e) {\n+      closeFileSilently();\n+      throw DbException.convertIOException(e, name);\n     }\n-\n-    /**\n-     * Get the file size in bytes.\n-     *\n-     * @return the file size\n-     */\n-    public long length() {\n-        long len = fileLength;\n-        if (ASSERT) {\n-            try {\n-                len = file.size();\n-                if (len != fileLength) {\n-                    DbException.throwInternalError(\n-                            \"file \" + name + \" length \" + len + \" expected \" + fileLength);\n-                }\n-                if (len % Constants.FILE_BLOCK_SIZE != 0) {\n-                    long newLength = len + Constants.FILE_BLOCK_SIZE -\n-                            (len % Constants.FILE_BLOCK_SIZE);\n-                    file.truncate(newLength);\n-                    fileLength = newLength;\n-                    DbException.throwInternalError(\n-                            \"unaligned file length \" + name + \" len \" + len);\n-                }\n-            } catch (IOException e) {\n-                throw DbException.convertIOException(e, name);\n-            }\n-        }\n-        return len;\n+    filePos += len;\n+    fileLength = Math.max(filePos, fileLength);\n+  }\n+\n+  /**\n+   * Set the length of the file. This will expand or shrink the file.\n+   *\n+   * @param newLength the new file size\n+   */\n+  public void setLength(long newLength) {\n+    if (newLength % Constants.FILE_BLOCK_SIZE != 0) {\n+      DbException.throwInternalError(\n+          \"unaligned setLength \" + name + \" pos \" + newLength);\n     }\n-\n-    /**\n-     * Get the current location of the file pointer.\n-     *\n-     * @return the location\n-     */\n-    public long getFilePointer() {\n-        if (ASSERT) {\n-            try {\n-                if (file.position() != filePos) {\n-                    DbException.throwInternalError(file.position() + \" \" + filePos);\n-                }\n-            } catch (IOException e) {\n-                throw DbException.convertIOException(e, name);\n-            }\n-        }\n-        return filePos;\n+    checkPowerOff();\n+    checkWritingAllowed();\n+    try {\n+      if (newLength > fileLength) {\n+        long pos = filePos;\n+        file.position(newLength - 1);\n+        FileUtils.writeFully(file, ByteBuffer.wrap(new byte[1]));\n+        file.position(pos);\n+      } else {\n+        file.truncate(newLength);\n+      }\n+      fileLength = newLength;\n+    } catch (IOException e) {\n+      closeFileSilently();\n+      throw DbException.convertIOException(e, name);\n     }\n-\n-    /**\n-     * Call fsync. Depending on the operating system and hardware, this may or\n-     * may not in fact write the changes.\n-     */\n-    public void sync() {\n-        try {\n-            file.force(true);\n-        } catch (IOException e) {\n-            closeFileSilently();\n-            throw DbException.convertIOException(e, name);\n+  }\n+\n+  /**\n+   * Get the file size in bytes.\n+   *\n+   * @return the file size\n+   */\n+  public long length() {\n+    long len = fileLength;\n+    if (ASSERT) {\n+      try {\n+        len = file.size();\n+        if (len != fileLength) {\n+          DbException.throwInternalError(\n+              \"file \" + name + \" length \" + len + \" expected \" + fileLength);\n+        }\n+        if (len % Constants.FILE_BLOCK_SIZE != 0) {\n+          long newLength = len + Constants.FILE_BLOCK_SIZE -\n+              (len % Constants.FILE_BLOCK_SIZE);\n+          file.truncate(newLength);\n+          fileLength = newLength;\n+          DbException.throwInternalError(\n+              \"unaligned file length \" + name + \" len \" + len);\n         }\n+      } catch (IOException e) {\n+        throw DbException.convertIOException(e, name);\n+      }\n     }\n-\n-    /**\n-     * Automatically delete the file once it is no longer in use.\n-     */\n-    public void autoDelete() {\n-        if (autoDeleteReference == null) {\n-            autoDeleteReference = handler.getTempFileDeleter().addFile(name, this);\n+    return len;\n+  }\n+\n+  /**\n+   * Get the current location of the file pointer.\n+   *\n+   * @return the location\n+   */\n+  public long getFilePointer() {\n+    if (ASSERT) {\n+      try {\n+        if (file.position() != filePos) {\n+          DbException.throwInternalError(file.position() + \" \" + filePos);\n         }\n+      } catch (IOException e) {\n+        throw DbException.convertIOException(e, name);\n+      }\n     }\n-\n-    /**\n-     * No longer automatically delete the file once it is no longer in use.\n-     */\n-    public void stopAutoDelete() {\n-        handler.getTempFileDeleter().stopAutoDelete(autoDeleteReference, name);\n-        autoDeleteReference = null;\n+    return filePos;\n+  }\n+\n+  /**\n+   * Call fsync. Depending on the operating system and hardware, this may or\n+   * may not in fact write the changes.\n+   */\n+  public void sync() {\n+    try {\n+      file.force(true);\n+    } catch (IOException e) {\n+      closeFileSilently();\n+      throw DbException.convertIOException(e, name);\n     }\n-\n-    /**\n-     * Close the file. The file may later be re-opened using openFile.\n-     */\n-    public void closeFile() throws IOException {\n-        file.close();\n-        file = null;\n+  }\n+\n+  /**\n+   * Automatically delete the file once it is no longer in use.\n+   */\n+  public void autoDelete() {\n+    if (autoDeleteReference == null) {\n+      autoDeleteReference = handler.getTempFileDeleter().addFile(name, this);\n     }\n-\n-    /**\n-     * Just close the file, without setting the reference to null. This method\n-     * is called when writing failed. The reference is not set to null so that\n-     * there are no NullPointerExceptions later on.\n-     */\n-    private void closeFileSilently() {\n-        try {\n-            file.close();\n-        } catch (IOException e) {\n-            // ignore\n-        }\n+  }\n+\n+  /**\n+   * No longer automatically delete the file once it is no longer in use.\n+   */\n+  public void stopAutoDelete() {\n+    handler.getTempFileDeleter().stopAutoDelete(autoDeleteReference, name);\n+    autoDeleteReference = null;\n+  }\n+\n+  /**\n+   * Close the file. The file may later be re-opened using openFile.\n+   */\n+  public void closeFile() throws IOException {\n+    file.close();\n+    file = null;\n+  }\n+\n+  /**\n+   * Just close the file, without setting the reference to null. This method\n+   * is called when writing failed. The reference is not set to null so that\n+   * there are no NullPointerExceptions later on.\n+   */\n+  private void closeFileSilently() {\n+    try {\n+      file.close();\n+    } catch (IOException e) {\n+      // ignore\n     }\n-\n-    /**\n-     * Re-open the file. The file pointer will be reset to the previous\n-     * location.\n-     */\n-    public void openFile() throws IOException {\n-        if (file == null) {\n-            file = FileUtils.open(name, mode);\n-            file.position(filePos);\n-        }\n+  }\n+\n+  /**\n+   * Re-open the file. The file pointer will be reset to the previous\n+   * location.\n+   */\n+  public void openFile() throws IOException {\n+    if (file == null) {\n+      file = FileUtils.open(name, mode);\n+      file.position(filePos);\n     }\n+  }\n \n-    private static void trace(String method, String fileName, Object o) {\n-        if (SysProperties.TRACE_IO) {\n-            System.out.println(\"FileStore.\" + method + \" \" + fileName + \" \" + o);\n-        }\n+  private static void trace(String method, String fileName, Object o) {\n+    if (SysProperties.TRACE_IO) {\n+      System.out.println(\"FileStore.\" + method + \" \" + fileName + \" \" + o);\n     }\n-\n-    /**\n-     * Try to lock the file.\n-     *\n-     * @return true if successful\n-     */\n-    public synchronized boolean tryLock() {\n-        try {\n-            lock = file.tryLock();\n-            return lock != null;\n-        } catch (Exception e) {\n-            // ignore OverlappingFileLockException\n-            return false;\n-        }\n+  }\n+\n+  /**\n+   * Try to lock the file.\n+   *\n+   * @return true if successful\n+   */\n+  public synchronized boolean tryLock() {\n+    try {\n+      lock = file.tryLock();\n+      return lock != null;\n+    } catch (Exception e) {\n+      // ignore OverlappingFileLockException\n+      return false;\n     }\n-\n-    /**\n-     * Release the file lock.\n-     */\n-    public synchronized void releaseLock() {\n-        if (file != null && lock != null) {\n-            try {\n-                lock.release();\n-            } catch (Exception e) {\n-                // ignore\n-            }\n-            lock = null;\n-        }\n+  }\n+\n+  /**\n+   * Release the file lock.\n+   */\n+  public synchronized void releaseLock() {\n+    if (file != null && lock != null) {\n+      try {\n+        lock.release();\n+      } catch (Exception e) {\n+        // ignore\n+      }\n+      lock = null;\n     }\n+  }\n \n }\n",
            "diff_size": 592
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/451/FileStore.java\nindex e90ce399fdd..7fc5d6dcdfd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/451/FileStore.java\n@@ -182,13 +182,11 @@ public class FileStore {\n      * required.\n      */\n     public void init() {\n-        int len = Constants.FILE_BLOCK_SIZE; //16\u5b57\u8282\n+        int len = Constants.FILE_BLOCK_SIZE;\n+//16\u5b57\u8282\n         byte[] salt;\n-//<<<<<<< HEAD\n-//        byte[] magic = HEADER.getBytes(Constants.UTF8);\n-//        if (length() < HEADER_LENGTH) { //HEADER_LENGTH = 48, \u7b2c\u4e00\u6b21\u5efa\u7acb*.h2.db\u6587\u4ef6\u65f6length\u4e3a0\n-//=======\n-        byte[] magic = HEADER.getBytes(StandardCharsets.UTF_8);\n+//<<<<<\n+byte[] magic = HEADER.getBytes(StandardCharsets.UTF_8);\n         if (length() < HEADER_LENGTH) {\n             // write unencrypted\n             checkedWriting = false;\n@@ -517,4 +515,4 @@ public class FileStore {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 8
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "199",
                    "column": "46",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/451/FileStore.java\nindex e90ce399fdd..c914ae3d124 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/451/FileStore.java\n@@ -23,19 +23,21 @@ import org.h2.store.fs.FileUtils;\n  * Each file contains a magic header, and reading / writing is done in blocks.\n  * See also {@link SecureFileStore}\n  */\n+\n+\n public class FileStore {\n \n     /**\n      * The size of the file header in bytes.\n      */\n+\n+\n     public static final int HEADER_LENGTH = 3 * Constants.FILE_BLOCK_SIZE;\n \n     /**\n      * The magic file header.\n      */\n-    private static final String HEADER =\n-            \"-- H2 0.5/B --      \".substring(0, Constants.FILE_BLOCK_SIZE - 1) + \"\\n\";\n-\n+    private static final String HEADER = \"-- H2 0.5/B --      \".substring(0, Constants.FILE_BLOCK_SIZE - 1) + \"\\n\";\n     private static final boolean ASSERT;\n \n     static {\n@@ -48,6 +50,8 @@ public class FileStore {\n     /**\n      * The file name.\n      */\n+\n+\n     protected String name;\n \n     /**\n@@ -55,7 +59,6 @@ public class FileStore {\n      * disk space if required.\n      */\n     private final DataHandler handler;\n-\n     private FileChannel file;\n     private long filePos;\n     private long fileLength;\n@@ -71,6 +74,7 @@ public class FileStore {\n      * @param name the file name\n      * @param mode the access mode (\"r\", \"rw\", \"rws\", \"rwd\")\n      */\n+\n     protected FileStore(DataHandler handler, String name, String mode) {\n         this.handler = handler;\n         this.name = name;\n@@ -86,8 +90,7 @@ public class FileStore {\n                 fileLength = file.size();\n             }\n         } catch (IOException e) {\n-            throw DbException.convertIOException(\n-                    e, \"name: \" + name + \" mode: \" + mode);\n+            throw DbException.convertIOException(e, \"name: \" + name + \" mode: \" + mode);\n         }\n         this.mode = mode;\n     }\n@@ -100,6 +103,8 @@ public class FileStore {\n      * @param mode the access mode (r, rw, rws, rwd)\n      * @return the created object\n      */\n+\n+\n     public static FileStore open(DataHandler handler, String name, String mode) {\n         return open(handler, name, mode, null, null, 0);\n     }\n@@ -114,10 +119,11 @@ public class FileStore {\n      * @param key the encryption key\n      * @return the created object\n      */\n-    public static FileStore open(DataHandler handler, String name, String mode,\n-            String cipher, byte[] key) {\n-        return open(handler, name, mode, cipher, key,\n-                Constants.ENCRYPTION_KEY_HASH_ITERATIONS);\n+\n+\n+    public static FileStore open(DataHandler handler, String name, String mode, String cipher, byte[] key) {\n+        return open(\n+handler, name, mode, cipher, key, Constants.ENCRYPTION_KEY_HASH_ITERATIONS);\n     }\n \n     /**\n@@ -131,14 +137,14 @@ public class FileStore {\n      * @param keyIterations the number of iterations the key should be hashed\n      * @return the created object\n      */\n-    public static FileStore open(DataHandler handler, String name, String mode,\n-            String cipher, byte[] key, int keyIterations) {\n+\n+\n+    public static FileStore open(DataHandler handler, String name, String mode, String cipher, byte[] key, int keyIterations) {\n         FileStore store;\n         if (cipher == null) {\n             store = new FileStore(handler, name, mode);\n         } else {\n-            store = new SecureFileStore(handler, name, mode,\n-                    cipher, key, keyIterations);\n+            store = new SecureFileStore(handler, name, mode, cipher, key, keyIterations);\n         }\n         return store;\n     }\n@@ -148,6 +154,8 @@ public class FileStore {\n      *\n      * @return the random salt or the magic\n      */\n+\n+\n     protected byte[] generateSalt() {\n         return HEADER.getBytes(StandardCharsets.UTF_8);\n     }\n@@ -157,10 +165,14 @@ public class FileStore {\n      *\n      * @param salt the salt\n      */\n+\n+\n     protected void initKey(byte[] salt) {\n         // do nothing\n+\n     }\n \n+\n     public void setCheckedWriting(boolean value) {\n         this.checkedWriting = value;\n     }\n@@ -181,6 +193,8 @@ public class FileStore {\n      * Initialize the file. This method will write or check the file header if\n      * required.\n      */\n+\n+\n     public void init() {\n         int len = Constants.FILE_BLOCK_SIZE; //16\u5b57\u8282\n         byte[] salt;\n@@ -222,6 +236,8 @@ public class FileStore {\n     /**\n      * Close the file.\n      */\n+\n+\n     public void close() {\n         if (file != null) {\n             try {\n@@ -239,17 +255,22 @@ public class FileStore {\n      * Close the file without throwing any exceptions. Exceptions are simply\n      * ignored.\n      */\n+\n+\n     public void closeSilently() {\n         try {\n             close();\n         } catch (Exception e) {\n             // ignore\n+\n         }\n     }\n \n     /**\n      * Close the file (ignoring exceptions) and delete the file.\n      */\n+\n+\n     public void closeAndDeleteSilently() {\n         if (file != null) {\n             closeSilently();\n@@ -265,6 +286,8 @@ public class FileStore {\n      * @param off the offset\n      * @param len the number of bytes to read\n      */\n+\n+\n     public void readFullyDirect(byte[] b, int off, int len) {\n         readFully(b, off, len);\n     }\n@@ -276,10 +299,11 @@ public class FileStore {\n      * @param off the offset\n      * @param len the number of bytes to read\n      */\n+\n+\n     public void readFully(byte[] b, int off, int len) {\n         if (len < 0 || len % Constants.FILE_BLOCK_SIZE != 0) {\n-            DbException.throwInternalError(\n-                    \"unaligned read \" + name + \" len \" + len);\n+            DbException.throwInternalError(\"unaligned read \" + name + \" len \" + len);\n         }\n         checkPowerOff();\n         try {\n@@ -295,10 +319,11 @@ public class FileStore {\n      *\n      * @param pos the location\n      */\n+\n+\n     public void seek(long pos) {\n         if (pos % Constants.FILE_BLOCK_SIZE != 0) {\n-            DbException.throwInternalError(\n-                    \"unaligned seek \" + name + \" pos \" + pos);\n+            DbException.throwInternalError(\"unaligned seek \" + name + \" pos \" + pos);\n         }\n         try {\n             if (pos != filePos) {\n@@ -317,6 +342,8 @@ public class FileStore {\n      * @param off the offset\n      * @param len the number of bytes to write\n      */\n+\n+\n     protected void writeDirect(byte[] b, int off, int len) {\n         write(b, off, len);\n     }\n@@ -328,10 +355,11 @@ public class FileStore {\n      * @param off the offset\n      * @param len the number of bytes to write\n      */\n+\n+\n     public void write(byte[] b, int off, int len) {\n         if (len < 0 || len % Constants.FILE_BLOCK_SIZE != 0) {\n-            DbException.throwInternalError(\n-                    \"unaligned write \" + name + \" len \" + len);\n+            DbException.throwInternalError(\"unaligned write \" + name + \" len \" + len);\n         }\n         checkWritingAllowed();\n         checkPowerOff();\n@@ -350,10 +378,11 @@ public class FileStore {\n      *\n      * @param newLength the new file size\n      */\n+\n+\n     public void setLength(long newLength) {\n         if (newLength % Constants.FILE_BLOCK_SIZE != 0) {\n-            DbException.throwInternalError(\n-                    \"unaligned setLength \" + name + \" pos \" + newLength);\n+            DbException.throwInternalError(\"unaligned setLength \" + name + \" pos \" + newLength);\n         }\n         checkPowerOff();\n         checkWritingAllowed();\n@@ -378,22 +407,22 @@ public class FileStore {\n      *\n      * @return the file size\n      */\n+\n+\n     public long length() {\n         long len = fileLength;\n         if (ASSERT) {\n             try {\n                 len = file.size();\n                 if (len != fileLength) {\n-                    DbException.throwInternalError(\n-                            \"file \" + name + \" length \" + len + \" expected \" + fileLength);\n+                    DbException.throwInternalError(\"file \" + name + \" length \"\n+                    + len + \" expected \" + fileLength);\n                 }\n                 if (len % Constants.FILE_BLOCK_SIZE != 0) {\n-                    long newLength = len + Constants.FILE_BLOCK_SIZE -\n-                            (len % Constants.FILE_BLOCK_SIZE);\n+                    long newLength = len + Constants.FILE_BLOCK_SIZE - (len % Constants.FILE_BLOCK_SIZE);\n                     file.truncate(newLength);\n                     fileLength = newLength;\n-                    DbException.throwInternalError(\n-                            \"unaligned file length \" + name + \" len \" + len);\n+                    DbException.throwInternalError(\"unaligned file length \" + name + \" len \" + len);\n                 }\n             } catch (IOException e) {\n                 throw DbException.convertIOException(e, name);\n@@ -407,6 +436,8 @@ public class FileStore {\n      *\n      * @return the location\n      */\n+\n+\n     public long getFilePointer() {\n         if (ASSERT) {\n             try {\n@@ -424,6 +455,8 @@ public class FileStore {\n      * Call fsync. Depending on the operating system and hardware, this may or\n      * may not in fact write the changes.\n      */\n+\n+\n     public void sync() {\n         try {\n             file.force(true);\n@@ -436,6 +469,8 @@ public class FileStore {\n     /**\n      * Automatically delete the file once it is no longer in use.\n      */\n+\n+\n     public void autoDelete() {\n         if (autoDeleteReference == null) {\n             autoDeleteReference = handler.getTempFileDeleter().addFile(name, this);\n@@ -445,6 +480,8 @@ public class FileStore {\n     /**\n      * No longer automatically delete the file once it is no longer in use.\n      */\n+\n+\n     public void stopAutoDelete() {\n         handler.getTempFileDeleter().stopAutoDelete(autoDeleteReference, name);\n         autoDeleteReference = null;\n@@ -453,6 +490,8 @@ public class FileStore {\n     /**\n      * Close the file. The file may later be re-opened using openFile.\n      */\n+\n+\n     public void closeFile() throws IOException {\n         file.close();\n         file = null;\n@@ -463,11 +502,13 @@ public class FileStore {\n      * is called when writing failed. The reference is not set to null so that\n      * there are no NullPointerExceptions later on.\n      */\n+\n     private void closeFileSilently() {\n         try {\n             file.close();\n         } catch (IOException e) {\n             // ignore\n+\n         }\n     }\n \n@@ -475,6 +516,8 @@ public class FileStore {\n      * Re-open the file. The file pointer will be reset to the previous\n      * location.\n      */\n+\n+\n     public void openFile() throws IOException {\n         if (file == null) {\n             file = FileUtils.open(name, mode);\n@@ -484,7 +527,8 @@ public class FileStore {\n \n     private static void trace(String method, String fileName, Object o) {\n         if (SysProperties.TRACE_IO) {\n-            System.out.println(\"FileStore.\" + method + \" \" + fileName + \" \" + o);\n+            System.out.println(\"FileStore.\" + method + \" \"\n+            + fileName + \" \" + o);\n         }\n     }\n \n@@ -493,6 +537,8 @@ public class FileStore {\n      *\n      * @return true if successful\n      */\n+\n+\n     public synchronized boolean tryLock() {\n         try {\n             lock = file.tryLock();\n@@ -506,15 +552,18 @@ public class FileStore {\n     /**\n      * Release the file lock.\n      */\n+\n+\n     public synchronized void releaseLock() {\n         if (file != null && lock != null) {\n             try {\n                 lock.release();\n             } catch (Exception e) {\n                 // ignore\n+\n             }\n             lock = null;\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 90
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/451/FileStore.java\nindex e90ce399fdd..27802943929 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/451/FileStore.java\n@@ -182,8 +182,9 @@ public class FileStore {\n      * required.\n      */\n     public void init() {\n-        int len = Constants.FILE_BLOCK_SIZE; //16\u5b57\u8282\n-        byte[] salt;\n+        int len = Constants.FILE_BLOCK_SIZE;\n+        //16\u5b57\u8282\n+         byte[] salt;\n //<<<<<<< HEAD\n //        byte[] magic = HEADER.getBytes(Constants.UTF8);\n //        if (length() < HEADER_LENGTH) { //HEADER_LENGTH = 48, \u7b2c\u4e00\u6b21\u5efa\u7acb*.h2.db\u6587\u4ef6\u65f6length\u4e3a0\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/451/FileStore.java\nindex e90ce399fdd..27802943929 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/451/FileStore.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/451/FileStore.java\n@@ -182,8 +182,9 @@ public class FileStore {\n      * required.\n      */\n     public void init() {\n-        int len = Constants.FILE_BLOCK_SIZE; //16\u5b57\u8282\n-        byte[] salt;\n+        int len = Constants.FILE_BLOCK_SIZE;\n+        //16\u5b57\u8282\n+         byte[] salt;\n //<<<<<<< HEAD\n //        byte[] magic = HEADER.getBytes(Constants.UTF8);\n //        if (length() < HEADER_LENGTH) { //HEADER_LENGTH = 48, \u7b2c\u4e00\u6b21\u5efa\u7acb*.h2.db\u6587\u4ef6\u65f6length\u4e3a0\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}