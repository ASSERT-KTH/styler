{
    "project_name": "opencb-opencga",
    "error_id": "185",
    "information": {
        "errors": [
            {
                "line": "207",
                "severity": "error",
                "message": "Line is longer than 140 characters (found 141).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "//                            Arrays.asList(File.Format.VCF, File.Format.GVCF, File.Format.AVRO));\n                            Arrays.asList(File.Format.VCF, File.Format.GVCF));\n                    DataResult<File> fileDataResult = catalogManager.getFileManager().search(studyFqn, query, FILE_GET_QUERY_OPTIONS, token);\n//                    fileDataResult.getResults().sort(Comparator.comparing(File::getName));\n                    inputFiles.addAll(fileDataResult.getResults());\n                } else {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "207",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/185/VariantFileIndexerStorageOperation.java\nindex c97a2686eac..3d52984e2e6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/185/VariantFileIndexerStorageOperation.java\n@@ -205,7 +205,7 @@ public class VariantFileIndexerStorageOperation extends StorageOperation {\n //                            Arrays.asList(File.Format.VCF, File.Format.GVCF, File.Format.AVRO));\n                             Arrays.asList(File.Format.VCF, File.Format.GVCF));\n                     DataResult<File> fileDataResult = catalogManager.getFileManager().search(studyFqn, query, FILE_GET_QUERY_OPTIONS, token);\n-//                    fileDataResult.getResults().sort(Comparator.comparing(File::getName));\n+                //                    fileDataResult.getResults().sort(Comparator.comparing(File::getName));\n                     inputFiles.addAll(fileDataResult.getResults());\n                 } else {\n                     throw new CatalogException(String.format(\"Expected file type %s or %s instead of %s\",\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/185/VariantFileIndexerStorageOperation.java\nindex c97a2686eac..681317e0453 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/185/VariantFileIndexerStorageOperation.java\n@@ -64,725 +64,725 @@ import static org.opencb.opencga.catalog.utils.FileMetadataReader.VARIANT_FILE_S\n @Analysis(id = \"variant-index\", type = Analysis.AnalysisType.VARIANT)\n public class VariantFileIndexerStorageOperation extends StorageOperation {\n \n-    public static final String DEFAULT_COHORT_DESCRIPTION = \"Default cohort with almost all indexed samples\";\n-    public static final QueryOptions FILE_GET_QUERY_OPTIONS = new QueryOptions()\n-            .append(QueryOptions.EXCLUDE, Arrays.asList(\n-                    FileDBAdaptor.QueryParams.ATTRIBUTES.key(),\n-                    FileDBAdaptor.QueryParams.STATS.key()))\n-            .append(QueryOptions.SORT, FileDBAdaptor.QueryParams.NAME.key())\n-            .append(QueryOptions.ORDER, QueryOptions.ASCENDING);\n-\n-    public static final String TRANSFORM = \"transform\";\n-    public static final String LOAD = \"load\";\n-    // FIXME : Needed?\n-    public static final String TRANSFORMED_FILES = \"transformedFiles\";\n-\n-\n-    private String studyFqn;\n-    private List<String> files;\n-\n-    private boolean calculateStats;\n-    private boolean transform;\n-    private boolean load;\n-    private boolean resume;\n-    private Type step;\n-    private List<URI> fileUris;\n-    private VariantStorageEngine variantStorageEngine;\n-    private URI outDirUri;\n-    private int release;\n-    private List<File> filesToIndex;\n-    private List<StoragePipelineResult> storagePipelineResults = Collections.emptyList();\n-    private CatalogStorageMetadataSynchronizer synchronizer;\n-\n-    private enum Type {\n-        // AUTO, // TODO\n-        TRANSFORM,\n-        LOAD,\n-        INDEX\n+  public static final String DEFAULT_COHORT_DESCRIPTION = \"Default cohort with almost all indexed samples\";\n+  public static final QueryOptions FILE_GET_QUERY_OPTIONS = new QueryOptions()\n+      .append(QueryOptions.EXCLUDE, Arrays.asList(\n+          FileDBAdaptor.QueryParams.ATTRIBUTES.key(),\n+          FileDBAdaptor.QueryParams.STATS.key()))\n+      .append(QueryOptions.SORT, FileDBAdaptor.QueryParams.NAME.key())\n+      .append(QueryOptions.ORDER, QueryOptions.ASCENDING);\n+\n+  public static final String TRANSFORM = \"transform\";\n+  public static final String LOAD = \"load\";\n+  // FIXME : Needed?\n+  public static final String TRANSFORMED_FILES = \"transformedFiles\";\n+\n+\n+  private String studyFqn;\n+  private List<String> files;\n+\n+  private boolean calculateStats;\n+  private boolean transform;\n+  private boolean load;\n+  private boolean resume;\n+  private Type step;\n+  private List<URI> fileUris;\n+  private VariantStorageEngine variantStorageEngine;\n+  private URI outDirUri;\n+  private int release;\n+  private List<File> filesToIndex;\n+  private List<StoragePipelineResult> storagePipelineResults = Collections.emptyList();\n+  private CatalogStorageMetadataSynchronizer synchronizer;\n+\n+  private enum Type {\n+    // AUTO, // TODO\n+    TRANSFORM,\n+    LOAD,\n+    INDEX\n+  }\n+\n+  public VariantFileIndexerStorageOperation setStudy(String studyId) {\n+    this.studyFqn = studyId;\n+    return this;\n+  }\n+\n+  public VariantFileIndexerStorageOperation setFiles(List<String> files) {\n+    this.files = files;\n+    return this;\n+  }\n+\n+  public List<StoragePipelineResult> getStoragePipelineResults() {\n+    return storagePipelineResults;\n+  }\n+\n+  private URI checkOutdir(String study) throws Exception {\n+    Path outDir;\n+    if (keepIntermediateFiles) {\n+      // Check the output directory does not correspond with a catalog directory\n+      outDir = getOutDir();\n+      Query query = new Query(FileDBAdaptor.QueryParams.URI.key(), outDir.toUri().toString());\n+      DataResult<File> count = catalogManager.getFileManager().count(study, query, token);\n+      if (count.getNumMatches() > 0) {\n+        throw new AnalysisException(\"The output directory is pointing to one in catalog. Please, choose other out of catalog \"\n+            + \"boundaries.\");\n+      }\n+    } else {\n+      outDir = getScratchDir();\n     }\n-\n-    public VariantFileIndexerStorageOperation setStudy(String studyId) {\n-        this.studyFqn = studyId;\n-        return this;\n-    }\n-\n-    public VariantFileIndexerStorageOperation setFiles(List<String> files) {\n-        this.files = files;\n-        return this;\n+    FileUtils.checkDirectory(outDir, true);\n+\n+    return outDir.toUri();\n+  }\n+\n+  @Override\n+  protected void check() throws Exception {\n+    super.check();\n+    studyFqn = getStudyFqn(studyFqn);\n+    outDirUri = checkOutdir(studyFqn);\n+\n+    transform = true;\n+    load = true;\n+    // If any of them is defined and at least one is different from false then we set the values\n+    if (params.getBoolean(TRANSFORM, false) || params.getBoolean(LOAD, false)) {\n+      transform = params.getBoolean(TRANSFORM, false);\n+      load = params.getBoolean(LOAD, false);\n     }\n+    resume = params.getBoolean(VariantStorageOptions.RESUME.key());\n \n-    public List<StoragePipelineResult> getStoragePipelineResults() {\n-        return storagePipelineResults;\n-    }\n+    // Obtain the type of analysis (transform, load or index)\n+    step = getType(load, transform);\n \n-    private URI checkOutdir(String study) throws Exception {\n-        Path outDir;\n-        if (keepIntermediateFiles) {\n-            // Check the output directory does not correspond with a catalog directory\n-            outDir = getOutDir();\n-            Query query = new Query(FileDBAdaptor.QueryParams.URI.key(), outDir.toUri().toString());\n-            DataResult<File> count = catalogManager.getFileManager().count(study, query, token);\n-            if (count.getNumMatches() > 0) {\n-                throw new AnalysisException(\"The output directory is pointing to one in catalog. Please, choose other out of catalog \"\n-                        + \"boundaries.\");\n-            }\n-        } else {\n-            outDir = getScratchDir();\n-        }\n-        FileUtils.checkDirectory(outDir, true);\n+    params.put(VariantStorageOptions.STUDY.key(), studyFqn);\n+    Aggregation aggregation = VariantStatsAnalysis.getAggregation(catalogManager, studyFqn, params, token);\n+    params.putIfAbsent(VariantStorageOptions.STATS_AGGREGATION.key(), aggregation);\n+    calculateStats = params.getBoolean(VariantStorageOptions.STATS_CALCULATE.key())\n+        && (step.equals(Type.LOAD) || step.equals(Type.INDEX));\n \n-        return outDir.toUri();\n+    // Create default cohort if needed.\n+    if (step.equals(Type.INDEX) || step.equals(Type.LOAD)) {\n+      createDefaultCohortIfNeeded(studyFqn, token);\n     }\n-\n-    @Override\n-    protected void check() throws Exception {\n-        super.check();\n-        studyFqn = getStudyFqn(studyFqn);\n-        outDirUri = checkOutdir(studyFqn);\n-\n-        transform = true;\n-        load = true;\n-        // If any of them is defined and at least one is different from false then we set the values\n-        if (params.getBoolean(TRANSFORM, false) || params.getBoolean(LOAD, false)) {\n-            transform = params.getBoolean(TRANSFORM, false);\n-            load = params.getBoolean(LOAD, false);\n-        }\n-        resume = params.getBoolean(VariantStorageOptions.RESUME.key());\n-\n-        // Obtain the type of analysis (transform, load or index)\n-        step = getType(load, transform);\n-\n-        params.put(VariantStorageOptions.STUDY.key(), studyFqn);\n-        Aggregation aggregation = VariantStatsAnalysis.getAggregation(catalogManager, studyFqn, params, token);\n-        params.putIfAbsent(VariantStorageOptions.STATS_AGGREGATION.key(), aggregation);\n-        calculateStats = params.getBoolean(VariantStorageOptions.STATS_CALCULATE.key())\n-                && (step.equals(Type.LOAD) || step.equals(Type.INDEX));\n-\n-        // Create default cohort if needed.\n-        if (step.equals(Type.INDEX) || step.equals(Type.LOAD)) {\n-            createDefaultCohortIfNeeded(studyFqn, token);\n+  }\n+\n+  private void updateProject(String studyFqn, VariantStorageEngine variantStorageEngine) throws CatalogException, StorageEngineException {\n+    String projectFqn = catalogManager.getStudyManager().getProjectFqn(studyFqn);\n+    Project project = catalogManager\n+        .getProjectManager()\n+        .get(projectFqn,\n+            new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(CURRENT_RELEASE.key(), ORGANISM.key())), token).first();\n+    release = project.getCurrentRelease();\n+\n+    // Add species, assembly and release\n+    CatalogStorageMetadataSynchronizer.updateProjectMetadata(variantStorageEngine.getMetadataManager(), project.getOrganism(), release);\n+  }\n+\n+  /**\n+   * We read all input files from fileId. This can either be a single file and then we just use it,\n+   * or this can be a directory, in that case we use all VCF files in that directory or subdirectory\n+   *\n+   * @return\n+   * @throws CatalogException\n+   * @throws URISyntaxException\n+   * @throws StorageEngineException\n+   */\n+  private List<File> findFilesToIndex() throws CatalogException, URISyntaxException, StorageEngineException {\n+    synchronizer = new CatalogStorageMetadataSynchronizer(catalogManager, variantStorageEngine.getMetadataManager());\n+\n+    List<File> inputFiles = new ArrayList<>();\n+    for (String file : files) {\n+      File inputFile = catalogManager.getFileManager().get(studyFqn, file, FILE_GET_QUERY_OPTIONS, token).first();\n+\n+      if (inputFile.getType() == File.Type.FILE) {\n+        // If is a transformed file, get the related VCF file\n+        if (VariantReaderUtils.isTransformedVariants(inputFile.getName())) {\n+          inputFiles.add(getOriginalFromTransformed(studyFqn, inputFile, token));\n+        } else {\n+          inputFiles.add(inputFile);\n         }\n-    }\n-\n-    private void updateProject(String studyFqn, VariantStorageEngine variantStorageEngine) throws CatalogException, StorageEngineException {\n-        String projectFqn = catalogManager.getStudyManager().getProjectFqn(studyFqn);\n-        Project project = catalogManager\n-                .getProjectManager()\n-                .get(projectFqn,\n-                        new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(CURRENT_RELEASE.key(), ORGANISM.key())), token).first();\n-        release = project.getCurrentRelease();\n-\n-        // Add species, assembly and release\n-        CatalogStorageMetadataSynchronizer.updateProjectMetadata(variantStorageEngine.getMetadataManager(), project.getOrganism(), release);\n-    }\n-\n-    /**\n-     * We read all input files from fileId. This can either be a single file and then we just use it,\n-     * or this can be a directory, in that case we use all VCF files in that directory or subdirectory\n-     * @return\n-     * @throws CatalogException\n-     * @throws URISyntaxException\n-     * @throws StorageEngineException\n-     */\n-    private List<File> findFilesToIndex() throws CatalogException, URISyntaxException, StorageEngineException {\n-        synchronizer = new CatalogStorageMetadataSynchronizer(catalogManager, variantStorageEngine.getMetadataManager());\n-\n-        List<File> inputFiles = new ArrayList<>();\n-        for (String file : files) {\n-            File inputFile = catalogManager.getFileManager().get(studyFqn, file, FILE_GET_QUERY_OPTIONS, token).first();\n-\n-            if (inputFile.getType() == File.Type.FILE) {\n-                // If is a transformed file, get the related VCF file\n-                if (VariantReaderUtils.isTransformedVariants(inputFile.getName())) {\n-                    inputFiles.add(getOriginalFromTransformed(studyFqn, inputFile, token));\n-                } else {\n-                    inputFiles.add(inputFile);\n-                }\n-            } else {\n-                if (inputFile.getType() == File.Type.DIRECTORY) {\n-                    Query query = new Query(FileDBAdaptor.QueryParams.DIRECTORY.key(), inputFile.getPath());\n-                    query.append(FileDBAdaptor.QueryParams.FORMAT.key(),\n+      } else {\n+        if (inputFile.getType() == File.Type.DIRECTORY) {\n+          Query query = new Query(FileDBAdaptor.QueryParams.DIRECTORY.key(), inputFile.getPath());\n+          query.append(FileDBAdaptor.QueryParams.FORMAT.key(),\n //                            Arrays.asList(File.Format.VCF, File.Format.GVCF, File.Format.AVRO));\n-                            Arrays.asList(File.Format.VCF, File.Format.GVCF));\n-                    DataResult<File> fileDataResult = catalogManager.getFileManager().search(studyFqn, query, FILE_GET_QUERY_OPTIONS, token);\n+              Arrays.asList(File.Format.VCF, File.Format.GVCF));\n+          DataResult<File> fileDataResult = catalogManager.getFileManager().search(studyFqn, query, FILE_GET_QUERY_OPTIONS, token);\n //                    fileDataResult.getResults().sort(Comparator.comparing(File::getName));\n-                    inputFiles.addAll(fileDataResult.getResults());\n-                } else {\n-                    throw new CatalogException(String.format(\"Expected file type %s or %s instead of %s\",\n-                            File.Type.FILE, File.Type.DIRECTORY, inputFile.getType()));\n-                }\n-            }\n+          inputFiles.addAll(fileDataResult.getResults());\n+        } else {\n+          throw new CatalogException(String.format(\"Expected file type %s or %s instead of %s\",\n+              File.Type.FILE, File.Type.DIRECTORY, inputFile.getType()));\n         }\n+      }\n+    }\n \n \n-        // Update Catalog from the storage metadata. This may change the index status of the inputFiles .\n-        synchronizer.synchronizeCatalogFilesFromStorage(studyFqn, inputFiles, token, FILE_GET_QUERY_OPTIONS);\n-\n-        logger.debug(\"Index - Number of files to be indexed: {}, list of files: {}\", inputFiles.size(),\n-                inputFiles.stream().map(File::getName).collect(Collectors.toList()));\n-\n-        String fileStatus;\n-        String fileStatusMessage;\n-        fileUris = new ArrayList<>(inputFiles.size());\n-        switch (step) {\n-            case INDEX:\n-                fileStatus = FileIndex.IndexStatus.INDEXING;\n-                fileStatusMessage = \"Start indexing file\";\n-                filesToIndex = filterTransformFiles(inputFiles, resume);\n-                for (File file : filesToIndex) {\n-                    fileUris.add(file.getUri());\n-                }\n-                break;\n-            case TRANSFORM:\n-                fileStatus = FileIndex.IndexStatus.TRANSFORMING;\n-                fileStatusMessage = \"Start transforming file\";\n-                filesToIndex = filterTransformFiles(inputFiles, resume);\n-                for (File file : filesToIndex) {\n-                    fileUris.add(file.getUri());\n-                }\n-                break;\n-            case LOAD:\n-                filesToIndex = filterLoadFiles(studyFqn, inputFiles, params, fileUris, resume, token);\n-                fileStatus = FileIndex.IndexStatus.LOADING;\n-                fileStatusMessage = \"Start loading file\";\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unknown step '\" + step + \"'.\");\n-        }\n+    // Update Catalog from the storage metadata. This may change the index status of the inputFiles .\n+    synchronizer.synchronizeCatalogFilesFromStorage(studyFqn, inputFiles, token, FILE_GET_QUERY_OPTIONS);\n \n+    logger.debug(\"Index - Number of files to be indexed: {}, list of files: {}\", inputFiles.size(),\n+        inputFiles.stream().map(File::getName).collect(Collectors.toList()));\n \n-        // Check that we are not indexing two or more files with the same name at the same time\n-        Set<String> fileNamesToIndexSet = new HashSet<>();\n-        for (File fileToIndex : filesToIndex) {\n-            if (!fileNamesToIndexSet.add(fileToIndex.getName())) {\n-                throw new CatalogException(\"Unable to \" + step + \" multiple files with the same name\");\n-            }\n+    String fileStatus;\n+    String fileStatusMessage;\n+    fileUris = new ArrayList<>(inputFiles.size());\n+    switch (step) {\n+      case INDEX:\n+        fileStatus = FileIndex.IndexStatus.INDEXING;\n+        fileStatusMessage = \"Start indexing file\";\n+        filesToIndex = filterTransformFiles(inputFiles, resume);\n+        for (File file : filesToIndex) {\n+          fileUris.add(file.getUri());\n         }\n-\n-        // Only if we are not transforming or if a path has been passed, we will update catalog information\n-        if (!step.equals(Type.TRANSFORM) || keepIntermediateFiles) {\n-            for (File file : filesToIndex) {\n-                DataResult<FileIndex> fileIndexDataResult = catalogManager.getFileManager().updateFileIndexStatus(file, fileStatus,\n-                        fileStatusMessage, release, token);\n-                file.setIndex(fileIndexDataResult.first());\n-            }\n+        break;\n+      case TRANSFORM:\n+        fileStatus = FileIndex.IndexStatus.TRANSFORMING;\n+        fileStatusMessage = \"Start transforming file\";\n+        filesToIndex = filterTransformFiles(inputFiles, resume);\n+        for (File file : filesToIndex) {\n+          fileUris.add(file.getUri());\n         }\n-        return filesToIndex;\n+        break;\n+      case LOAD:\n+        filesToIndex = filterLoadFiles(studyFqn, inputFiles, params, fileUris, resume, token);\n+        fileStatus = FileIndex.IndexStatus.LOADING;\n+        fileStatusMessage = \"Start loading file\";\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown step '\" + step + \"'.\");\n     }\n \n-    @Override\n-    protected void run() throws Exception {\n \n-        variantStorageEngine = getVariantStorageEngine(studyFqn);\n-        variantStorageEngine.getOptions().putAll(params);\n+    // Check that we are not indexing two or more files with the same name at the same time\n+    Set<String> fileNamesToIndexSet = new HashSet<>();\n+    for (File fileToIndex : filesToIndex) {\n+      if (!fileNamesToIndexSet.add(fileToIndex.getName())) {\n+        throw new CatalogException(\"Unable to \" + step + \" multiple files with the same name\");\n+      }\n+    }\n \n-        updateProject(studyFqn, variantStorageEngine);\n+    // Only if we are not transforming or if a path has been passed, we will update catalog information\n+    if (!step.equals(Type.TRANSFORM) || keepIntermediateFiles) {\n+      for (File file : filesToIndex) {\n+        DataResult<FileIndex> fileIndexDataResult = catalogManager.getFileManager().updateFileIndexStatus(file, fileStatus,\n+            fileStatusMessage, release, token);\n+        file.setIndex(fileIndexDataResult.first());\n+      }\n+    }\n+    return filesToIndex;\n+  }\n \n-        findFilesToIndex();\n-        if (fileUris.size() == 0) {\n-            logger.warn(\"Nothing to do.\");\n-            return;\n-        }\n+  @Override\n+  protected void run() throws Exception {\n \n-        String prevDefaultCohortStatus = Cohort.CohortStatus.NONE;\n-        if (step.equals(Type.INDEX) || step.equals(Type.LOAD)) {\n-            if (calculateStats) {\n-                prevDefaultCohortStatus = updateDefaultCohortStatus(studyFqn, Cohort.CohortStatus.CALCULATING, token);\n-            }\n-        }\n+    variantStorageEngine = getVariantStorageEngine(studyFqn);\n+    variantStorageEngine.getOptions().putAll(params);\n \n-        logger.info(\"Starting to {}\", step);\n+    updateProject(studyFqn, variantStorageEngine);\n \n-        // Save exception to throw at the end\n-        StorageEngineException exception = null;\n-        try {\n-            storagePipelineResults = variantStorageEngine.index(fileUris, outDirUri, false, transform, load);\n-        } catch (StoragePipelineException e) {\n-            logger.error(\"Error executing \" + step, e);\n-            storagePipelineResults = e.getResults();\n-            exception = e;\n-            throw e;\n-        } catch (StorageEngineException e) {\n-            logger.error(\"Error executing \" + step, e);\n-            storagePipelineResults = Collections.emptyList();\n-            exception = e;\n-            throw e;\n-        } catch (RuntimeException e) {\n-            logger.error(\"Error executing \" + step, e);\n-            storagePipelineResults = Collections.emptyList();\n-            exception = new StorageEngineException(\"Error executing \" + step, e);\n-            throw e;\n-        } finally {\n-            // Only if we are not transforming or if a path has been passed, we will update catalog information\n-            if (!step.equals(Type.TRANSFORM) || keepIntermediateFiles) {\n-\n-                updateFileInfo(studyFqn, filesToIndex, variantStorageEngine.getVariantReaderUtils(),\n-                        storagePipelineResults, Paths.get(outDirUri), release, keepIntermediateFiles, params, token);\n-\n-                // Restore previous cohort status. Cohort status will be read from StudyConfiguration.\n-                if (calculateStats && exception != null) {\n-                    updateDefaultCohortStatus(studyFqn, prevDefaultCohortStatus, token);\n-                }\n-                synchronizer.synchronizeCatalogStudyFromStorage(studyFqn, token);\n-            }\n-            addAttribute(\"storagePipelineResults\", storagePipelineResults);\n-            variantStorageEngine.close();\n-        }\n+    findFilesToIndex();\n+    if (fileUris.size() == 0) {\n+      logger.warn(\"Nothing to do.\");\n+      return;\n+    }\n \n-        for (StoragePipelineResult result : storagePipelineResults) {\n-            if (step == Type.TRANSFORM || step == Type.INDEX) {\n-                addFile(Paths.get(result.getTransformResult()), FileResult.FileType.AVRO);\n-                addFile(Paths.get(VariantReaderUtils.getMetaFromTransformedFile(result.getTransformResult())), FileResult.FileType.JSON);\n-            }\n-        }\n+    String prevDefaultCohortStatus = Cohort.CohortStatus.NONE;\n+    if (step.equals(Type.INDEX) || step.equals(Type.LOAD)) {\n+      if (calculateStats) {\n+        prevDefaultCohortStatus = updateDefaultCohortStatus(studyFqn, Cohort.CohortStatus.CALCULATING, token);\n+      }\n     }\n \n-    private Type getType(Boolean load, Boolean transform) {\n-        if (transform && load) {\n-            return Type.INDEX;\n+    logger.info(\"Starting to {}\", step);\n+\n+    // Save exception to throw at the end\n+    StorageEngineException exception = null;\n+    try {\n+      storagePipelineResults = variantStorageEngine.index(fileUris, outDirUri, false, transform, load);\n+    } catch (StoragePipelineException e) {\n+      logger.error(\"Error executing \" + step, e);\n+      storagePipelineResults = e.getResults();\n+      exception = e;\n+      throw e;\n+    } catch (StorageEngineException e) {\n+      logger.error(\"Error executing \" + step, e);\n+      storagePipelineResults = Collections.emptyList();\n+      exception = e;\n+      throw e;\n+    } catch (RuntimeException e) {\n+      logger.error(\"Error executing \" + step, e);\n+      storagePipelineResults = Collections.emptyList();\n+      exception = new StorageEngineException(\"Error executing \" + step, e);\n+      throw e;\n+    } finally {\n+      // Only if we are not transforming or if a path has been passed, we will update catalog information\n+      if (!step.equals(Type.TRANSFORM) || keepIntermediateFiles) {\n+\n+        updateFileInfo(studyFqn, filesToIndex, variantStorageEngine.getVariantReaderUtils(),\n+            storagePipelineResults, Paths.get(outDirUri), release, keepIntermediateFiles, params, token);\n+\n+        // Restore previous cohort status. Cohort status will be read from StudyConfiguration.\n+        if (calculateStats && exception != null) {\n+          updateDefaultCohortStatus(studyFqn, prevDefaultCohortStatus, token);\n         }\n-        if (transform) {\n-            return Type.TRANSFORM;\n-        }\n-        return Type.LOAD;\n+        synchronizer.synchronizeCatalogStudyFromStorage(studyFqn, token);\n+      }\n+      addAttribute(\"storagePipelineResults\", storagePipelineResults);\n+      variantStorageEngine.close();\n     }\n \n-    private void updateFileInfo(String study, List<File> filesToIndex, VariantReaderUtils variantReaderUtils,\n-                                List<StoragePipelineResult> storagePipelineResults, Path outdir,\n-                                Integer release, boolean saveIntermediateFiles, ObjectMap options, String sessionId)\n-            throws CatalogException, IOException {\n-\n-        Map<String, StoragePipelineResult> map;\n-        try {\n-            map = storagePipelineResults\n-                    .stream()\n-                    .collect(Collectors.toMap(s -> {\n-                        String input = s.getInput().getPath();\n-                        String inputFileName = Paths.get(input).getFileName().toString();\n-                        // Input file may be the transformed one. Convert into original file.\n-                        return VariantReaderUtils.getOriginalFromTransformedFile(inputFileName);\n-                    }, i -> i));\n-        } catch (IllegalStateException e) {\n-            throw e;\n-        }\n+    for (StoragePipelineResult result : storagePipelineResults) {\n+      if (step == Type.TRANSFORM || step == Type.INDEX) {\n+        addFile(Paths.get(result.getTransformResult()), FileResult.FileType.AVRO);\n+        addFile(Paths.get(VariantReaderUtils.getMetaFromTransformedFile(result.getTransformResult())), FileResult.FileType.JSON);\n+      }\n+    }\n+  }\n+\n+  private Type getType(Boolean load, Boolean transform) {\n+    if (transform && load) {\n+      return Type.INDEX;\n+    }\n+    if (transform) {\n+      return Type.TRANSFORM;\n+    }\n+    return Type.LOAD;\n+  }\n+\n+  private void updateFileInfo(String study, List<File> filesToIndex, VariantReaderUtils variantReaderUtils,\n+                              List<StoragePipelineResult> storagePipelineResults, Path outdir,\n+                              Integer release, boolean saveIntermediateFiles, ObjectMap options, String sessionId)\n+      throws CatalogException, IOException {\n+\n+    Map<String, StoragePipelineResult> map;\n+    try {\n+      map = storagePipelineResults\n+          .stream()\n+          .collect(Collectors.toMap(s -> {\n+            String input = s.getInput().getPath();\n+            String inputFileName = Paths.get(input).getFileName().toString();\n+            // Input file may be the transformed one. Convert into original file.\n+            return VariantReaderUtils.getOriginalFromTransformedFile(inputFileName);\n+          }, i -> i));\n+    } catch (IllegalStateException e) {\n+      throw e;\n+    }\n \n-        for (File indexedFile : filesToIndex) {\n-            // Fetch from catalog. {@link #copyResult} may modify the content\n-            indexedFile = catalogManager.getFileManager().get(study, indexedFile.getId(), null, sessionId).first();\n-            // Suppose that the missing results are due to errors, and those files were not indexed.\n-            StoragePipelineResult storagePipelineResult = map.get(indexedFile.getName());\n-\n-            boolean jobFailed = storagePipelineResult == null || storagePipelineResult.getLoadError() != null\n-                    || storagePipelineResult.getTransformError() != null;\n-\n-            boolean transformedSuccess = storagePipelineResult != null && storagePipelineResult.isTransformExecuted()\n-                    && storagePipelineResult.getTransformError() == null;\n-            boolean loadedSuccess = storagePipelineResult != null && storagePipelineResult.isLoadExecuted()\n-                    && storagePipelineResult.getLoadError() == null;\n-\n-            String indexStatusName;\n-            String indexStatusMessage = null;\n-\n-            if (indexedFile.getIndex() != null) {\n-                FileIndex index = indexedFile.getIndex();\n-                switch (index.getStatus().getName()) {\n-                    case FileIndex.IndexStatus.NONE:\n-                    case FileIndex.IndexStatus.TRANSFORMED:\n-                        indexStatusMessage = \"Unexpected index status. Expected \" + FileIndex.IndexStatus.TRANSFORMING + \", \"\n-                                + FileIndex.IndexStatus.LOADING + \" or \" + FileIndex.IndexStatus.INDEXING + \" and got \"\n-                                + index.getStatus();\n-                        logger.warn(indexStatusMessage);\n-                    case FileIndex.IndexStatus.READY: //Do not show warn message when index status is READY.\n-                        indexStatusName = index.getStatus().getName();\n-                        break;\n-                    case FileIndex.IndexStatus.TRANSFORMING:\n-                        if (jobFailed) {\n-                            indexStatusMessage = \"Job failed. Restoring status from \" + FileIndex.IndexStatus.TRANSFORMING + \" to \"\n-                                    + FileIndex.IndexStatus.NONE;\n-                            logger.warn(indexStatusMessage);\n-                            indexStatusName = FileIndex.IndexStatus.NONE;\n-                        } else {\n-                            indexStatusMessage = \"Job finished. File transformed\";\n-                            indexStatusName = FileIndex.IndexStatus.TRANSFORMED;\n-                        }\n-                        break;\n-                    case FileIndex.IndexStatus.LOADING:\n-                        if (jobFailed) {\n-                            if (indexedFile.getIndex().getTransformedFile() == null) {\n-                                indexStatusName = FileIndex.IndexStatus.NONE;\n-                            } else {\n-                                indexStatusName = FileIndex.IndexStatus.TRANSFORMED;\n-                            }\n-                            indexStatusMessage = \"Job failed. Restoring status from \" + FileIndex.IndexStatus.LOADING + \" to \"\n-                                    + indexStatusName;\n-                            logger.warn(indexStatusMessage);\n-                        } else {\n-                            indexStatusMessage = \"Job finished. File index ready\";\n-                            indexStatusName = FileIndex.IndexStatus.READY;\n-                        }\n-                        break;\n-                    case FileIndex.IndexStatus.INDEXING:\n-                        if (jobFailed) {\n-                            // If transform was executed, restore status to Transformed.\n-                            if (transformedSuccess && saveIntermediateFiles) {\n-                                indexStatusName = FileIndex.IndexStatus.TRANSFORMED;\n-                            } else if (indexedFile.getIndex().getTransformedFile() != null) {\n-                                // If transform file already exists, restore to Transformed\n-                                indexStatusName = FileIndex.IndexStatus.TRANSFORMED;\n-                            } else {\n-                                indexStatusName = FileIndex.IndexStatus.NONE;\n-                            }\n-                            indexStatusMessage = \"Job failed. Restoring status from \" + FileIndex.IndexStatus.INDEXING\n-                                    + \" to \" + indexStatusName;\n-                            logger.warn(indexStatusMessage);\n-                        } else {\n-                            indexStatusName = FileIndex.IndexStatus.READY;\n-                            indexStatusMessage = \"Job finished. File index ready\";\n-                        }\n-                        break;\n-                    default:\n-                        throw new IllegalStateException(\"Unknown Index Status \" + index.getStatus().getName());\n-                }\n+    for (File indexedFile : filesToIndex) {\n+      // Fetch from catalog. {@link #copyResult} may modify the content\n+      indexedFile = catalogManager.getFileManager().get(study, indexedFile.getId(), null, sessionId).first();\n+      // Suppose that the missing results are due to errors, and those files were not indexed.\n+      StoragePipelineResult storagePipelineResult = map.get(indexedFile.getName());\n+\n+      boolean jobFailed = storagePipelineResult == null || storagePipelineResult.getLoadError() != null\n+          || storagePipelineResult.getTransformError() != null;\n+\n+      boolean transformedSuccess = storagePipelineResult != null && storagePipelineResult.isTransformExecuted()\n+          && storagePipelineResult.getTransformError() == null;\n+      boolean loadedSuccess = storagePipelineResult != null && storagePipelineResult.isLoadExecuted()\n+          && storagePipelineResult.getLoadError() == null;\n+\n+      String indexStatusName;\n+      String indexStatusMessage = null;\n+\n+      if (indexedFile.getIndex() != null) {\n+        FileIndex index = indexedFile.getIndex();\n+        switch (index.getStatus().getName()) {\n+          case FileIndex.IndexStatus.NONE:\n+          case FileIndex.IndexStatus.TRANSFORMED:\n+            indexStatusMessage = \"Unexpected index status. Expected \" + FileIndex.IndexStatus.TRANSFORMING + \", \"\n+                + FileIndex.IndexStatus.LOADING + \" or \" + FileIndex.IndexStatus.INDEXING + \" and got \"\n+                + index.getStatus();\n+            logger.warn(indexStatusMessage);\n+          case FileIndex.IndexStatus.READY: //Do not show warn message when index status is READY.\n+            indexStatusName = index.getStatus().getName();\n+            break;\n+          case FileIndex.IndexStatus.TRANSFORMING:\n+            if (jobFailed) {\n+              indexStatusMessage = \"Job failed. Restoring status from \" + FileIndex.IndexStatus.TRANSFORMING + \" to \"\n+                  + FileIndex.IndexStatus.NONE;\n+              logger.warn(indexStatusMessage);\n+              indexStatusName = FileIndex.IndexStatus.NONE;\n             } else {\n-                logger.error(\"The execution should never get into this condition. Critical error.\");\n-                throw new CatalogException(\"Critical error. Empty index parameter in file \" + indexedFile.getUid());\n+              indexStatusMessage = \"Job finished. File transformed\";\n+              indexStatusName = FileIndex.IndexStatus.TRANSFORMED;\n             }\n-\n-            if (transformedSuccess) {\n-                updateVariantFileStats(study, variantReaderUtils, indexedFile, outdir, sessionId);\n+            break;\n+          case FileIndex.IndexStatus.LOADING:\n+            if (jobFailed) {\n+              if (indexedFile.getIndex().getTransformedFile() == null) {\n+                indexStatusName = FileIndex.IndexStatus.NONE;\n+              } else {\n+                indexStatusName = FileIndex.IndexStatus.TRANSFORMED;\n+              }\n+              indexStatusMessage = \"Job failed. Restoring status from \" + FileIndex.IndexStatus.LOADING + \" to \"\n+                  + indexStatusName;\n+              logger.warn(indexStatusMessage);\n+            } else {\n+              indexStatusMessage = \"Job finished. File index ready\";\n+              indexStatusName = FileIndex.IndexStatus.READY;\n             }\n-\n-            // Update storagePipelineResult\n-            Map<String, Object> attributes = indexedFile.getAttributes();\n-            attributes.put(\"storagePipelineResult\", storagePipelineResult);\n-            FileUpdateParams updateParams = new FileUpdateParams().setAttributes(attributes);\n-            catalogManager.getFileManager().update(study, indexedFile.getPath(), updateParams, new QueryOptions(), sessionId);\n-\n-            // Update index status\n-            catalogManager.getFileManager().updateFileIndexStatus(indexedFile, indexStatusName, indexStatusMessage, release, sessionId);\n-\n-            boolean calculateStats = options.getBoolean(VariantStorageOptions.STATS_CALCULATE.key());\n-            if (indexStatusName.equals(FileIndex.IndexStatus.READY) && calculateStats) {\n-                Query query = new Query(CohortDBAdaptor.QueryParams.ID.key(), StudyEntry.DEFAULT_COHORT);\n-                DataResult<Cohort> queryResult = catalogManager.getCohortManager()\n-                        .search(study, query, new QueryOptions(), sessionId);\n-                if (queryResult.getNumResults() != 0) {\n-                    logger.debug(\"Default cohort status set to READY\");\n-                    Cohort defaultCohort = queryResult.first();\n-                    catalogManager.getCohortManager().setStatus(study, defaultCohort.getId(), Cohort.CohortStatus.READY, null,\n-                            sessionId);\n-//                    params = new ObjectMap(CohortDBAdaptor.QueryParams.STATUS_NAME.key(), Cohort.CohortStatus.READY);\n-//                    catalogManager.getCohortManager().update(defaultCohort.getId(), params, new QueryOptions(), sessionId);\n-                }\n+            break;\n+          case FileIndex.IndexStatus.INDEXING:\n+            if (jobFailed) {\n+              // If transform was executed, restore status to Transformed.\n+              if (transformedSuccess && saveIntermediateFiles) {\n+                indexStatusName = FileIndex.IndexStatus.TRANSFORMED;\n+              } else if (indexedFile.getIndex().getTransformedFile() != null) {\n+                // If transform file already exists, restore to Transformed\n+                indexStatusName = FileIndex.IndexStatus.TRANSFORMED;\n+              } else {\n+                indexStatusName = FileIndex.IndexStatus.NONE;\n+              }\n+              indexStatusMessage = \"Job failed. Restoring status from \" + FileIndex.IndexStatus.INDEXING\n+                  + \" to \" + indexStatusName;\n+              logger.warn(indexStatusMessage);\n+            } else {\n+              indexStatusName = FileIndex.IndexStatus.READY;\n+              indexStatusMessage = \"Job finished. File index ready\";\n             }\n+            break;\n+          default:\n+            throw new IllegalStateException(\"Unknown Index Status \" + index.getStatus().getName());\n         }\n-    }\n-\n-    /**\n-     * Updates the file stats from a transformed variant file.\n-     * Reads the stats generated on the transform step.\n-     *\n-     *\n-     * @param studyFqn\n-     * @param variantReaderUtils\n-     * @param inputFile\n-     * @param outdir\n-     * @param sessionId\n-     * @throws CatalogException if a Catalog error occurs.\n-     */\n-    private void updateVariantFileStats(String studyFqn, VariantReaderUtils variantReaderUtils, File inputFile, Path outdir,\n-                                        String sessionId)\n-            throws CatalogException, IOException {\n-        Path metaFile = outdir.resolve(inputFile.getName() + \".\" + VariantReaderUtils.METADATA_FILE_FORMAT_GZ);\n-        if (!metaFile.toFile().exists()) {\n-            throw new IOException(\"Stats file not found.\");\n-        }\n-        VariantSetStats stats;\n-        try {\n-            VariantFileMetadata fileMetadata = variantReaderUtils.readVariantFileMetadata(metaFile, null);\n-            stats = fileMetadata.getStats();\n-        } catch (StorageEngineException e) {\n-            throw new CatalogException(\"Error reading file \\\"\" + metaFile + \"\\\"\", e);\n-        }\n-        FileUpdateParams updateParams = new FileUpdateParams().setStats(new ObjectMap(VARIANT_FILE_STATS, stats));\n-        catalogManager.getFileManager().update(studyFqn, inputFile.getPath(), updateParams, new QueryOptions(), sessionId);\n-\n-    }\n-\n-    private Cohort createDefaultCohortIfNeeded(String studyFqn, String sessionId) throws CatalogException {\n+      } else {\n+        logger.error(\"The execution should never get into this condition. Critical error.\");\n+        throw new CatalogException(\"Critical error. Empty index parameter in file \" + indexedFile.getUid());\n+      }\n+\n+      if (transformedSuccess) {\n+        updateVariantFileStats(study, variantReaderUtils, indexedFile, outdir, sessionId);\n+      }\n+\n+      // Update storagePipelineResult\n+      Map<String, Object> attributes = indexedFile.getAttributes();\n+      attributes.put(\"storagePipelineResult\", storagePipelineResult);\n+      FileUpdateParams updateParams = new FileUpdateParams().setAttributes(attributes);\n+      catalogManager.getFileManager().update(study, indexedFile.getPath(), updateParams, new QueryOptions(), sessionId);\n+\n+      // Update index status\n+      catalogManager.getFileManager().updateFileIndexStatus(indexedFile, indexStatusName, indexStatusMessage, release, sessionId);\n+\n+      boolean calculateStats = options.getBoolean(VariantStorageOptions.STATS_CALCULATE.key());\n+      if (indexStatusName.equals(FileIndex.IndexStatus.READY) && calculateStats) {\n         Query query = new Query(CohortDBAdaptor.QueryParams.ID.key(), StudyEntry.DEFAULT_COHORT);\n-        Cohort cohort = catalogManager.getCohortManager().search(studyFqn, query, null, sessionId).first();\n-        if (cohort == null) {\n-            try {\n-                return createDefaultCohort(studyFqn, sessionId);\n-            } catch (CatalogDBException e) {\n-                if (e.getMessage().contains(\"already exists\")) {\n-                    cohort = catalogManager.getCohortManager().search(studyFqn, query, null, sessionId).first();\n-                    if (cohort == null) {\n-                        throw e;\n-                    } else {\n-                        // Do not fail when concurrent cohort creation.\n-                        return cohort;\n-                    }\n-                } else {\n-                    throw e;\n-                }\n-            }\n-        } else {\n-            return cohort;\n+        DataResult<Cohort> queryResult = catalogManager.getCohortManager()\n+            .search(study, query, new QueryOptions(), sessionId);\n+        if (queryResult.getNumResults() != 0) {\n+          logger.debug(\"Default cohort status set to READY\");\n+          Cohort defaultCohort = queryResult.first();\n+          catalogManager.getCohortManager().setStatus(study, defaultCohort.getId(), Cohort.CohortStatus.READY, null,\n+              sessionId);\n+//                    params = new ObjectMap(CohortDBAdaptor.QueryParams.STATUS_NAME.key(), Cohort.CohortStatus.READY);\n+//                    catalogManager.getCohortManager().update(defaultCohort.getId(), params, new QueryOptions(), sessionId);\n         }\n+      }\n     }\n-\n-    private Cohort createDefaultCohort(String studyFqn, String sessionId) throws CatalogException {\n-        return catalogManager.getCohortManager().create(studyFqn, StudyEntry.DEFAULT_COHORT, Study.Type.COLLECTION,\n-                DEFAULT_COHORT_DESCRIPTION, Collections.emptyList(), null, null, sessionId).first();\n+  }\n+\n+  /**\n+   * Updates the file stats from a transformed variant file.\n+   * Reads the stats generated on the transform step.\n+   *\n+   * @param studyFqn\n+   * @param variantReaderUtils\n+   * @param inputFile\n+   * @param outdir\n+   * @param sessionId\n+   * @throws CatalogException if a Catalog error occurs.\n+   */\n+  private void updateVariantFileStats(String studyFqn, VariantReaderUtils variantReaderUtils, File inputFile, Path outdir,\n+                                      String sessionId)\n+      throws CatalogException, IOException {\n+    Path metaFile = outdir.resolve(inputFile.getName() + \".\" + VariantReaderUtils.METADATA_FILE_FORMAT_GZ);\n+    if (!metaFile.toFile().exists()) {\n+      throw new IOException(\"Stats file not found.\");\n     }\n-\n-    private void updateDefaultCohortStatus(Study study, StorageEngineException exception, String sessionId) throws CatalogException {\n-        if (exception == null) {\n-            updateDefaultCohortStatus(study.getFqn(), Cohort.CohortStatus.READY, sessionId);\n+    VariantSetStats stats;\n+    try {\n+      VariantFileMetadata fileMetadata = variantReaderUtils.readVariantFileMetadata(metaFile, null);\n+      stats = fileMetadata.getStats();\n+    } catch (StorageEngineException e) {\n+      throw new CatalogException(\"Error reading file \\\"\" + metaFile + \"\\\"\", e);\n+    }\n+    FileUpdateParams updateParams = new FileUpdateParams().setStats(new ObjectMap(VARIANT_FILE_STATS, stats));\n+    catalogManager.getFileManager().update(studyFqn, inputFile.getPath(), updateParams, new QueryOptions(), sessionId);\n+\n+  }\n+\n+  private Cohort createDefaultCohortIfNeeded(String studyFqn, String sessionId) throws CatalogException {\n+    Query query = new Query(CohortDBAdaptor.QueryParams.ID.key(), StudyEntry.DEFAULT_COHORT);\n+    Cohort cohort = catalogManager.getCohortManager().search(studyFqn, query, null, sessionId).first();\n+    if (cohort == null) {\n+      try {\n+        return createDefaultCohort(studyFqn, sessionId);\n+      } catch (CatalogDBException e) {\n+        if (e.getMessage().contains(\"already exists\")) {\n+          cohort = catalogManager.getCohortManager().search(studyFqn, query, null, sessionId).first();\n+          if (cohort == null) {\n+            throw e;\n+          } else {\n+            // Do not fail when concurrent cohort creation.\n+            return cohort;\n+          }\n         } else {\n-            updateDefaultCohortStatus(study.getFqn(), Cohort.CohortStatus.INVALID, sessionId);\n+          throw e;\n         }\n+      }\n+    } else {\n+      return cohort;\n     }\n-\n-    private String updateDefaultCohortStatus(String study, String status, String sessionId) throws CatalogException {\n-        Query query = new Query(CohortDBAdaptor.QueryParams.ID.key(), StudyEntry.DEFAULT_COHORT);\n-        Cohort defaultCohort = catalogManager.getCohortManager().search(study, query, new QueryOptions(), sessionId).first();\n-        String prevStatus = defaultCohort.getStatus().getName();\n-\n-        catalogManager.getCohortManager().setStatus(study, defaultCohort.getId(), status, null,\n-                sessionId);\n-\n-        return prevStatus;\n+  }\n+\n+  private Cohort createDefaultCohort(String studyFqn, String sessionId) throws CatalogException {\n+    return catalogManager.getCohortManager().create(studyFqn, StudyEntry.DEFAULT_COHORT, Study.Type.COLLECTION,\n+        DEFAULT_COHORT_DESCRIPTION, Collections.emptyList(), null, null, sessionId).first();\n+  }\n+\n+  private void updateDefaultCohortStatus(Study study, StorageEngineException exception, String sessionId) throws CatalogException {\n+    if (exception == null) {\n+      updateDefaultCohortStatus(study.getFqn(), Cohort.CohortStatus.READY, sessionId);\n+    } else {\n+      updateDefaultCohortStatus(study.getFqn(), Cohort.CohortStatus.INVALID, sessionId);\n+    }\n+  }\n+\n+  private String updateDefaultCohortStatus(String study, String status, String sessionId) throws CatalogException {\n+    Query query = new Query(CohortDBAdaptor.QueryParams.ID.key(), StudyEntry.DEFAULT_COHORT);\n+    Cohort defaultCohort = catalogManager.getCohortManager().search(study, query, new QueryOptions(), sessionId).first();\n+    String prevStatus = defaultCohort.getStatus().getName();\n+\n+    catalogManager.getCohortManager().setStatus(study, defaultCohort.getId(), status, null,\n+        sessionId);\n+\n+    return prevStatus;\n+  }\n+\n+  /**\n+   * Get non transformed files.\n+   *\n+   * @param fileList Files to filter\n+   * @param resume   If resume, get also TRANSFORMING and INDEXING files.\n+   * @return List of non transformed files\n+   */\n+  private List<File> filterTransformFiles(List<File> fileList, boolean resume) {\n+    if (fileList == null || fileList.isEmpty()) {\n+      return new ArrayList<>();\n     }\n \n-    /**\n-     * Get non transformed files.\n-     *\n-     * @param fileList Files to filter\n-     * @param resume If resume, get also TRANSFORMING and INDEXING files.\n-     * @return List of non transformed files\n-     */\n-    private List<File> filterTransformFiles(List<File> fileList, boolean resume) {\n-        if (fileList == null || fileList.isEmpty()) {\n-            return new ArrayList<>();\n+    List<File> filteredFiles = new ArrayList<>(fileList.size());\n+    for (File file : fileList) {\n+      if (file.getStatus().getName().equals(File.FileStatus.READY) && StorageOperation.isVcfFormat(file)) {\n+        String indexStatus;\n+        if (file.getIndex() != null && file.getIndex().getStatus() != null && file.getIndex().getStatus().getName() != null) {\n+          indexStatus = file.getIndex().getStatus().getName();\n+        } else {\n+          indexStatus = FileIndex.IndexStatus.NONE;\n         }\n-\n-        List<File> filteredFiles = new ArrayList<>(fileList.size());\n-        for (File file : fileList) {\n-            if (file.getStatus().getName().equals(File.FileStatus.READY) && StorageOperation.isVcfFormat(file)) {\n-                String indexStatus;\n-                if (file.getIndex() != null && file.getIndex().getStatus() != null && file.getIndex().getStatus().getName() != null) {\n-                    indexStatus = file.getIndex().getStatus().getName();\n-                } else {\n-                    indexStatus = FileIndex.IndexStatus.NONE;\n-                }\n-                switch (indexStatus) {\n-                    case FileIndex.IndexStatus.NONE:\n-                        filteredFiles.add(file);\n-                        break;\n-                    case FileIndex.IndexStatus.INDEXING:\n-                    case FileIndex.IndexStatus.TRANSFORMING:\n-                        if (!resume) {\n-                            logger.warn(\"File already being transformed. \"\n-                                            + \"We can only transform VCF files not transformed, the status is {}. \"\n-                                            + \"Do '\" + VariantStorageOptions.RESUME.key() + \"' to continue.\",\n-                                    indexStatus);\n-                        } else {\n-                            filteredFiles.add(file);\n-                        }\n-                        break;\n-                    case FileIndex.IndexStatus.TRANSFORMED:\n-                    case FileIndex.IndexStatus.LOADING:\n-                    case FileIndex.IndexStatus.READY:\n-                    default:\n-                        logger.warn(\"We can only transform VCF files not transformed, the status is {}\",\n-                                indexStatus);\n-                        break;\n-                }\n+        switch (indexStatus) {\n+          case FileIndex.IndexStatus.NONE:\n+            filteredFiles.add(file);\n+            break;\n+          case FileIndex.IndexStatus.INDEXING:\n+          case FileIndex.IndexStatus.TRANSFORMING:\n+            if (!resume) {\n+              logger.warn(\"File already being transformed. \"\n+                      + \"We can only transform VCF files not transformed, the status is {}. \"\n+                      + \"Do '\" + VariantStorageOptions.RESUME.key() + \"' to continue.\",\n+                  indexStatus);\n             } else {\n-                logger.warn(\"Skip file \" + file.getName() + \" with format \" + file.getFormat() + \" and status \"\n-                        + file.getStatus().getName());\n+              filteredFiles.add(file);\n             }\n+            break;\n+          case FileIndex.IndexStatus.TRANSFORMED:\n+          case FileIndex.IndexStatus.LOADING:\n+          case FileIndex.IndexStatus.READY:\n+          default:\n+            logger.warn(\"We can only transform VCF files not transformed, the status is {}\",\n+                indexStatus);\n+            break;\n         }\n-        return filteredFiles;\n+      } else {\n+        logger.warn(\"Skip file \" + file.getName() + \" with format \" + file.getFormat() + \" and status \"\n+            + file.getStatus().getName());\n+      }\n+    }\n+    return filteredFiles;\n+  }\n+\n+  private List<File> filterLoadFiles(String studyFQN, List<File> fileList, ObjectMap options, List<URI> fileUris,\n+                                     boolean resume, String sessionId)\n+      throws CatalogException, URISyntaxException {\n+    if (fileList == null || fileList.isEmpty()) {\n+      return new ArrayList<>();\n     }\n \n-    private List<File> filterLoadFiles(String studyFQN, List<File> fileList, ObjectMap options, List<URI> fileUris,\n-                                       boolean resume, String sessionId)\n-            throws CatalogException, URISyntaxException {\n-        if (fileList == null || fileList.isEmpty()) {\n-            return new ArrayList<>();\n+    List<String> transformedFiles;\n+    if (options.get(TRANSFORMED_FILES) != null) {\n+      transformedFiles = options.getAsStringList(TRANSFORMED_FILES);\n+      if (transformedFiles.size() != fileList.size()) {\n+        throw new CatalogException(\"The number of transformed files (\" + transformedFiles.size() + \") passed does not match the\"\n+            + \" number of vcf files (\" + fileList.size() + \").\");\n+      }\n+      // Check all the files are accessible and are actually files\n+      for (String transformedFile : transformedFiles) {\n+        java.io.File file = Paths.get(transformedFile).toFile();\n+        if (!file.exists() || !file.isFile()) {\n+          throw new CatalogException(\"File \" + file + \" does not exist or it is not an avro file\");\n         }\n+      }\n+    } else {\n+      transformedFiles = null;\n+    }\n \n-        List<String> transformedFiles;\n-        if (options.get(TRANSFORMED_FILES) != null) {\n-            transformedFiles = options.getAsStringList(TRANSFORMED_FILES);\n-            if (transformedFiles.size() != fileList.size()) {\n-                throw new CatalogException(\"The number of transformed files (\" + transformedFiles.size() + \") passed does not match the\"\n-                        + \" number of vcf files (\" + fileList.size() + \").\");\n-            }\n-            // Check all the files are accessible and are actually files\n-            for (String transformedFile : transformedFiles) {\n-                java.io.File file = Paths.get(transformedFile).toFile();\n-                if (!file.exists() || !file.isFile()) {\n-                    throw new CatalogException(\"File \" + file + \" does not exist or it is not an avro file\");\n-                }\n-            }\n-        } else {\n-            transformedFiles = null;\n+    List<File> filteredFiles = new ArrayList<>(fileList.size());\n+    Map<Long, Long> transformedToOrigFileIdsMap = new HashMap<>();\n+    for (int i = 0; i < fileList.size(); i++) {\n+      File file = fileList.get(i);\n+      File transformed = null;\n+\n+      // If is a transformed file, get the related VCF file\n+      if (VariantReaderUtils.isTransformedVariants(file.getName())) {\n+        if (transformedFiles != null) {\n+          // Check if the uri is different\n+          URI avroUri = UriUtils.createUri(transformedFiles.get(i));\n+          if (!avroUri.equals(file.getUri())) {\n+            // This case should never happen. If we are here, it means that the input file was already an avro file and that\n+            // a list of avro uris have been found. However, the uri of the avro does not match the uri we have for the avro\n+            // file. Nonsense.\n+            throw new CatalogException(\"The avro file \" + file.getName() + \" in \" + file.getUri() + \" has been associated a \"\n+                + \"different uri \" + avroUri + \" by the user.\");\n+          }\n         }\n-\n-        List<File> filteredFiles = new ArrayList<>(fileList.size());\n-        Map<Long, Long> transformedToOrigFileIdsMap = new HashMap<>();\n-        for (int i = 0; i < fileList.size(); i++) {\n-            File file = fileList.get(i);\n-            File transformed = null;\n-\n-            // If is a transformed file, get the related VCF file\n-            if (VariantReaderUtils.isTransformedVariants(file.getName())) {\n-                if (transformedFiles != null) {\n-                    // Check if the uri is different\n-                    URI avroUri = UriUtils.createUri(transformedFiles.get(i));\n-                    if (!avroUri.equals(file.getUri())) {\n-                        // This case should never happen. If we are here, it means that the input file was already an avro file and that\n-                        // a list of avro uris have been found. However, the uri of the avro does not match the uri we have for the avro\n-                        // file. Nonsense.\n-                        throw new CatalogException(\"The avro file \" + file.getName() + \" in \" + file.getUri() + \" has been associated a \"\n-                                + \"different uri \" + avroUri + \" by the user.\");\n-                    }\n-                }\n-                transformed = file;\n-                file = getOriginalFromTransformed(studyFQN, file, sessionId);\n-            }\n-\n-            if (StorageOperation.isVcfFormat(file)) {\n-                String status = file.getIndex() == null || file.getIndex().getStatus() == null ? FileIndex.IndexStatus.NONE\n-                        : file.getIndex().getStatus().getName();\n-                switch (status) {\n-                    case FileIndex.IndexStatus.NONE:\n-                        if (transformedFiles != null) {\n-                            filteredFiles.add(file);\n-                            fileUris.add(UriUtils.createUri(transformedFiles.get(i)));\n-                        } else {\n-                            logger.warn(\"Cannot load vcf file \" + file.getName() + \" if no avro file is provided.\");\n-                        }\n-                        break;\n-                    case FileIndex.IndexStatus.INDEXING:\n-                    case FileIndex.IndexStatus.LOADING:\n-                        if (!resume) {\n-                            logger.warn(\"Unable to load this file. Already being loaded. Skipping file {}\", file.getName());\n-                            break;\n-                        }\n-                    case FileIndex.IndexStatus.TRANSFORMED:\n-                        // We will attempt to use the avro file registered in catalog\n-                        if (transformed == null) {\n-                            // Don't query file by file. Make one single call at the end\n-                            transformedToOrigFileIdsMap.put(getTransformedFileIdFromOriginal(file), file.getUid());\n-                        } else {\n-                            fileUris.add(transformed.getUri());\n-                        }\n-                        filteredFiles.add(file);\n-                        break;\n-                    case FileIndex.IndexStatus.TRANSFORMING:\n-                        logger.warn(\"We can only load files previously transformed. Skipping file {}\", file.getName());\n-                        break;\n-                    case FileIndex.IndexStatus.READY:\n-                        logger.warn(\"Already loaded file. Skipping file {}\", file.getName());\n-                        break;\n-                    default:\n-                        logger.warn(\"We can only load files previously transformed, File {} with status is {}\", file.getName(), status);\n-                        break;\n-                }\n+        transformed = file;\n+        file = getOriginalFromTransformed(studyFQN, file, sessionId);\n+      }\n+\n+      if (StorageOperation.isVcfFormat(file)) {\n+        String status = file.getIndex() == null || file.getIndex().getStatus() == null ? FileIndex.IndexStatus.NONE\n+            : file.getIndex().getStatus().getName();\n+        switch (status) {\n+          case FileIndex.IndexStatus.NONE:\n+            if (transformedFiles != null) {\n+              filteredFiles.add(file);\n+              fileUris.add(UriUtils.createUri(transformedFiles.get(i)));\n             } else {\n-                logger.warn(\"The input file is not a variant file. Format {}\", file.getFormat());\n+              logger.warn(\"Cannot load vcf file \" + file.getName() + \" if no avro file is provided.\");\n             }\n-\n-        }\n-        if (!transformedToOrigFileIdsMap.isEmpty()) {\n-            Query query = new Query(UID.key(), new ArrayList<>(transformedToOrigFileIdsMap.keySet()));\n-            Set<Long> foundTransformedFiles = new HashSet<>();\n-            catalogManager.getFileManager().iterator(studyFQN, query, new QueryOptions(QueryOptions.INCLUDE,\n-                    Arrays.asList(UID.key(), FileDBAdaptor.QueryParams.URI.key())), sessionId)\n-                    .forEachRemaining(transformed -> {\n-                        foundTransformedFiles.add(transformed.getUid());\n-                        fileUris.add(transformed.getUri());\n-                        //if (transformedFiles != null) {\n-                        //    // Check that the uri from the avro file obtained from catalog is the same the user has put as input\n-                        //    URI uri = UriUtils.createUri(transformedFiles.get(i));\n-                        //    if (!uri.equals(transformed.getUri())) {\n-                        //        throw new CatalogException(\"A transformed file was found for file \" + file.getId() + \" in \"\n-                        //                + transformed.getUri() + \". However, the user selected a different one in \" + uri);\n-                        //    }\n-                        //}\n-                    });\n-            if (foundTransformedFiles.size() != transformedToOrigFileIdsMap.size()) {\n-                for (Long foundTransformedFile : foundTransformedFiles) {\n-                    transformedToOrigFileIdsMap.remove(foundTransformedFile);\n-                }\n-                throw new CatalogException(\"Internal error. No transformed file could be found for files \"\n-                        + transformedToOrigFileIdsMap.values());\n+            break;\n+          case FileIndex.IndexStatus.INDEXING:\n+          case FileIndex.IndexStatus.LOADING:\n+            if (!resume) {\n+              logger.warn(\"Unable to load this file. Already being loaded. Skipping file {}\", file.getName());\n+              break;\n             }\n+          case FileIndex.IndexStatus.TRANSFORMED:\n+            // We will attempt to use the avro file registered in catalog\n+            if (transformed == null) {\n+              // Don't query file by file. Make one single call at the end\n+              transformedToOrigFileIdsMap.put(getTransformedFileIdFromOriginal(file), file.getUid());\n+            } else {\n+              fileUris.add(transformed.getUri());\n+            }\n+            filteredFiles.add(file);\n+            break;\n+          case FileIndex.IndexStatus.TRANSFORMING:\n+            logger.warn(\"We can only load files previously transformed. Skipping file {}\", file.getName());\n+            break;\n+          case FileIndex.IndexStatus.READY:\n+            logger.warn(\"Already loaded file. Skipping file {}\", file.getName());\n+            break;\n+          default:\n+            logger.warn(\"We can only load files previously transformed, File {} with status is {}\", file.getName(), status);\n+            break;\n         }\n+      } else {\n+        logger.warn(\"The input file is not a variant file. Format {}\", file.getFormat());\n+      }\n \n-\n-        return filteredFiles;\n     }\n-\n-    private File getOriginalFromTransformed(String study, File file, String sessionId)\n-            throws CatalogException {\n-        // Look for the vcf file\n-        String vcfId = null;\n-        // Matchup variant files, if missing\n-        if (file.getRelatedFiles() == null || file.getRelatedFiles().isEmpty()) {\n-            catalogManager.getFileManager().matchUpVariantFiles(null, Collections.singletonList(file), sessionId);\n-        }\n-        for (File.RelatedFile relatedFile : file.getRelatedFiles()) {\n-            if (File.RelatedFile.Relation.PRODUCED_FROM.equals(relatedFile.getRelation())) {\n-                long fileUid = relatedFile.getFile().getUid();\n-                // FIXME!!!\n-                vcfId = catalogManager.getFileManager().search(study, new Query(UID.key(), fileUid),\n-                        new QueryOptions(QueryOptions.INCLUDE, ID.key()), sessionId).first().getId();\n-                break;\n-            }\n+    if (!transformedToOrigFileIdsMap.isEmpty()) {\n+      Query query = new Query(UID.key(), new ArrayList<>(transformedToOrigFileIdsMap.keySet()));\n+      Set<Long> foundTransformedFiles = new HashSet<>();\n+      catalogManager.getFileManager().iterator(studyFQN, query, new QueryOptions(QueryOptions.INCLUDE,\n+          Arrays.asList(UID.key(), FileDBAdaptor.QueryParams.URI.key())), sessionId)\n+          .forEachRemaining(transformed -> {\n+            foundTransformedFiles.add(transformed.getUid());\n+            fileUris.add(transformed.getUri());\n+            //if (transformedFiles != null) {\n+            //    // Check that the uri from the avro file obtained from catalog is the same the user has put as input\n+            //    URI uri = UriUtils.createUri(transformedFiles.get(i));\n+            //    if (!uri.equals(transformed.getUri())) {\n+            //        throw new CatalogException(\"A transformed file was found for file \" + file.getId() + \" in \"\n+            //                + transformed.getUri() + \". However, the user selected a different one in \" + uri);\n+            //    }\n+            //}\n+          });\n+      if (foundTransformedFiles.size() != transformedToOrigFileIdsMap.size()) {\n+        for (Long foundTransformedFile : foundTransformedFiles) {\n+          transformedToOrigFileIdsMap.remove(foundTransformedFile);\n         }\n-        if (vcfId == null) {\n-            logger.error(\"This code should never be executed. Every transformed avro file should come from a registered vcf file\");\n-            throw new CatalogException(\"Internal error. No vcf file could be found for file \" + file.getPath());\n-        }\n-        DataResult<File> vcfDataResult = catalogManager.getFileManager().get(study, vcfId, FILE_GET_QUERY_OPTIONS, sessionId);\n-        if (vcfDataResult.getNumResults() != 1) {\n-            logger.error(\"This code should never be executed. No vcf file could be found for vcf id \" + vcfId);\n-            throw new CatalogException(\"Internal error. No vcf file could be found under id \" + vcfId);\n-        }\n-        file = vcfDataResult.first();\n-        return file;\n+        throw new CatalogException(\"Internal error. No transformed file could be found for files \"\n+            + transformedToOrigFileIdsMap.values());\n+      }\n     }\n \n-    private File getTransformedFromOriginal(String sessionId, File file)\n-            throws CatalogException {\n-        long transformedFileId = getTransformedFileIdFromOriginal(file);\n-        DataResult<File> queryResult = catalogManager.getFileManager().get(transformedFileId, FILE_GET_QUERY_OPTIONS, sessionId);\n-        if (queryResult.getNumResults() != 1) {\n-            logger.error(\"This code should never be executed. No transformed file could be found under \");\n-            throw new CatalogException(\"Internal error. No transformed file could be found under id \" + transformedFileId);\n-        }\n \n-        return queryResult.first();\n+    return filteredFiles;\n+  }\n+\n+  private File getOriginalFromTransformed(String study, File file, String sessionId)\n+      throws CatalogException {\n+    // Look for the vcf file\n+    String vcfId = null;\n+    // Matchup variant files, if missing\n+    if (file.getRelatedFiles() == null || file.getRelatedFiles().isEmpty()) {\n+      catalogManager.getFileManager().matchUpVariantFiles(null, Collections.singletonList(file), sessionId);\n+    }\n+    for (File.RelatedFile relatedFile : file.getRelatedFiles()) {\n+      if (File.RelatedFile.Relation.PRODUCED_FROM.equals(relatedFile.getRelation())) {\n+        long fileUid = relatedFile.getFile().getUid();\n+        // FIXME!!!\n+        vcfId = catalogManager.getFileManager().search(study, new Query(UID.key(), fileUid),\n+            new QueryOptions(QueryOptions.INCLUDE, ID.key()), sessionId).first().getId();\n+        break;\n+      }\n+    }\n+    if (vcfId == null) {\n+      logger.error(\"This code should never be executed. Every transformed avro file should come from a registered vcf file\");\n+      throw new CatalogException(\"Internal error. No vcf file could be found for file \" + file.getPath());\n+    }\n+    DataResult<File> vcfDataResult = catalogManager.getFileManager().get(study, vcfId, FILE_GET_QUERY_OPTIONS, sessionId);\n+    if (vcfDataResult.getNumResults() != 1) {\n+      logger.error(\"This code should never be executed. No vcf file could be found for vcf id \" + vcfId);\n+      throw new CatalogException(\"Internal error. No vcf file could be found under id \" + vcfId);\n+    }\n+    file = vcfDataResult.first();\n+    return file;\n+  }\n+\n+  private File getTransformedFromOriginal(String sessionId, File file)\n+      throws CatalogException {\n+    long transformedFileId = getTransformedFileIdFromOriginal(file);\n+    DataResult<File> queryResult = catalogManager.getFileManager().get(transformedFileId, FILE_GET_QUERY_OPTIONS, sessionId);\n+    if (queryResult.getNumResults() != 1) {\n+      logger.error(\"This code should never be executed. No transformed file could be found under \");\n+      throw new CatalogException(\"Internal error. No transformed file could be found under id \" + transformedFileId);\n     }\n \n-    private long getTransformedFileIdFromOriginal(File file) throws CatalogException {\n-        long transformedFile = file.getIndex() != null && file.getIndex().getTransformedFile() != null\n-                ? file.getIndex().getTransformedFile().getId()\n-                : -1;\n-        if (transformedFile == -1) {\n-            logger.error(\"This code should never be executed. Every vcf file containing the transformed status should have\"\n-                    + \" a registered transformed file\");\n-            throw new CatalogException(\"Internal error. No transformed file could be found for file \" + file.getUid());\n-        }\n-        return transformedFile;\n+    return queryResult.first();\n+  }\n+\n+  private long getTransformedFileIdFromOriginal(File file) throws CatalogException {\n+    long transformedFile = file.getIndex() != null && file.getIndex().getTransformedFile() != null\n+        ? file.getIndex().getTransformedFile().getId()\n+        : -1;\n+    if (transformedFile == -1) {\n+      logger.error(\"This code should never be executed. Every vcf file containing the transformed status should have\"\n+          + \" a registered transformed file\");\n+      throw new CatalogException(\"Internal error. No transformed file could be found for file \" + file.getUid());\n     }\n+    return transformedFile;\n+  }\n \n \n }\n",
            "diff_size": 957
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "205",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "348",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 181).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/185/VariantFileIndexerStorageOperation.java\nindex c97a2686eac..e134de9ee00 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/185/VariantFileIndexerStorageOperation.java\n@@ -76,9 +76,7 @@ public class VariantFileIndexerStorageOperation extends StorageOperation {\n     public static final String LOAD = \"load\";\n     // FIXME : Needed?\n     public static final String TRANSFORMED_FILES = \"transformedFiles\";\n-\n-\n-    private String studyFqn;\n+private String studyFqn;\n     private List<String> files;\n \n     private boolean calculateStats;\n@@ -170,7 +168,7 @@ public class VariantFileIndexerStorageOperation extends StorageOperation {\n                 .getProjectManager()\n                 .get(projectFqn,\n                         new QueryOptions(QueryOptions.INCLUDE, Arrays.asList(CURRENT_RELEASE.key(), ORGANISM.key())), token).first();\n-        release = project.getCurrentRelease();\n+release = project.getCurrentRelease();\n \n         // Add species, assembly and release\n         CatalogStorageMetadataSynchronizer.updateProjectMetadata(variantStorageEngine.getMetadataManager(), project.getOrganism(), release);\n@@ -248,10 +246,9 @@ public class VariantFileIndexerStorageOperation extends StorageOperation {\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Unknown step '\" + step + \"'.\");\n-        }\n-\n+    }\n \n-        // Check that we are not indexing two or more files with the same name at the same time\n+// Check that we are not indexing two or more files with the same name at the same time\n         Set<String> fileNamesToIndexSet = new HashSet<>();\n         for (File fileToIndex : filesToIndex) {\n             if (!fileNamesToIndexSet.add(fileToIndex.getName())) {\n@@ -348,8 +345,7 @@ public class VariantFileIndexerStorageOperation extends StorageOperation {\n     }\n \n     private void updateFileInfo(String study, List<File> filesToIndex, VariantReaderUtils variantReaderUtils,\n-                                List<StoragePipelineResult> storagePipelineResults, Path outdir,\n-                                Integer release, boolean saveIntermediateFiles, ObjectMap options, String sessionId)\n+                                List<StoragePipelineResult> storagePipelineResults, Path outdir, Integer release, boolean saveIntermediateFiles, ObjectMap options, String sessionId)\n             throws CatalogException, IOException {\n \n         Map<String, StoragePipelineResult> map;\n@@ -785,4 +781,4 @@ public class VariantFileIndexerStorageOperation extends StorageOperation {\n     }\n \n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 10
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "207",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/185/VariantFileIndexerStorageOperation.java\nindex c97a2686eac..3d52984e2e6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/185/VariantFileIndexerStorageOperation.java\n@@ -205,7 +205,7 @@ public class VariantFileIndexerStorageOperation extends StorageOperation {\n //                            Arrays.asList(File.Format.VCF, File.Format.GVCF, File.Format.AVRO));\n                             Arrays.asList(File.Format.VCF, File.Format.GVCF));\n                     DataResult<File> fileDataResult = catalogManager.getFileManager().search(studyFqn, query, FILE_GET_QUERY_OPTIONS, token);\n-//                    fileDataResult.getResults().sort(Comparator.comparing(File::getName));\n+                //                    fileDataResult.getResults().sort(Comparator.comparing(File::getName));\n                     inputFiles.addAll(fileDataResult.getResults());\n                 } else {\n                     throw new CatalogException(String.format(\"Expected file type %s or %s instead of %s\",\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "207",
                    "column": "45",
                    "severity": "error",
                    "message": "'>' is followed by an illegal character.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "207",
                    "column": "91",
                    "severity": "error",
                    "message": "'(' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.MethodParamPadCheck"
                },
                {
                    "line": "208",
                    "column": "20",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "208",
                    "column": "22",
                    "severity": "error",
                    "message": "',' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/185/VariantFileIndexerStorageOperation.java\nindex c97a2686eac..828100c4ba0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/185/VariantFileIndexerStorageOperation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/185/VariantFileIndexerStorageOperation.java\n@@ -204,7 +204,8 @@ public class VariantFileIndexerStorageOperation extends StorageOperation {\n                     query.append(FileDBAdaptor.QueryParams.FORMAT.key(),\n //                            Arrays.asList(File.Format.VCF, File.Format.GVCF, File.Format.AVRO));\n                             Arrays.asList(File.Format.VCF, File.Format.GVCF));\n-                    DataResult<File> fileDataResult = catalogManager.getFileManager().search(studyFqn, query, FILE_GET_QUERY_OPTIONS, token);\n+                            DataResult<File>fileDataResult =catalogManager.getFileManager () .search(studyFqn\n+                    ,query, FILE_GET_QUERY_OPTIONS, token);\n //                    fileDataResult.getResults().sort(Comparator.comparing(File::getName));\n                     inputFiles.addAll(fileDataResult.getResults());\n                 } else {\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}