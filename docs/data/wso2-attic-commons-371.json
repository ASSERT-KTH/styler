{
    "project_name": "wso2-attic-commons",
    "error_id": "371",
    "information": {
        "errors": [
            {
                "line": "69",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 128).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "    private static final List<BpelEvent> events = new ArrayList<BpelEvent>();\n    private static final Map<String, Long> mexAge = new ConcurrentHashMap<String, Long>();\n    private static final Map<String, MessageExchangeDAOImpl> mexStore = new ConcurrentHashMap<String, MessageExchangeDAOImpl>();\n\n    private volatile long lastRemoval = 0;\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/371/BpelDAOConnectionImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/371/BpelDAOConnectionImpl.java\nindex 3e5f67998e3..b4666d9bd34 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/371/BpelDAOConnectionImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/371/BpelDAOConnectionImpl.java\n@@ -66,7 +66,8 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n \n     private static final List<BpelEvent> events = new ArrayList<BpelEvent>();\n     private static final Map<String, Long> mexAge = new ConcurrentHashMap<String, Long>();\n-    private static final Map<String, MessageExchangeDAOImpl> mexStore = new ConcurrentHashMap<String, MessageExchangeDAOImpl>();\n+    private static final Map<\n+            String, MessageExchangeDAOImpl> mexStore = new ConcurrentHashMap<String, MessageExchangeDAOImpl>();\n \n     private volatile long lastRemoval = 0;\n \n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/371/BpelDAOConnectionImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/371/BpelDAOConnectionImpl.java\nindex 3e5f67998e3..71d3d3ed9b0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/371/BpelDAOConnectionImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/371/BpelDAOConnectionImpl.java\n@@ -16,6 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n+\n package org.apache.ode.bpel.memdao;\n \n import java.util.ArrayList;\n@@ -57,384 +58,385 @@ import org.apache.ode.utils.stl.UnaryFunction;\n  * A very simple, in-memory implementation of the {@link BpelDAOConnection} interface.\n  */\n class BpelDAOConnectionImpl implements BpelDAOConnection {\n-    private static final Log log = LogFactory.getLog(BpelDAOConnectionImpl.class);\n-    public static long TIME_TO_LIVE = 2 * 60 * 1000;\n+  private static final Log log = LogFactory.getLog(BpelDAOConnectionImpl.class);\n+  public static long TIME_TO_LIVE = 2 * 60 * 1000;\n \n-    private TransactionManager transactionManager;\n+  private TransactionManager transactionManager;\n \n-    private Map<QName, ProcessDaoImpl> processDaoStore;\n+  private Map<QName, ProcessDaoImpl> processDaoStore;\n \n-    private static final List<BpelEvent> events = new ArrayList<BpelEvent>();\n-    private static final Map<String, Long> mexAge = new ConcurrentHashMap<String, Long>();\n-    private static final Map<String, MessageExchangeDAOImpl> mexStore = new ConcurrentHashMap<String, MessageExchangeDAOImpl>();\n+  private static final List<BpelEvent> events = new ArrayList<BpelEvent>();\n+  private static final Map<String, Long> mexAge = new ConcurrentHashMap<String, Long>();\n+  private static final Map<String, MessageExchangeDAOImpl> mexStore =\n+    new ConcurrentHashMap<String, MessageExchangeDAOImpl>();\n \n-    private volatile long lastRemoval = 0;\n+  private volatile long lastRemoval = 0;\n \n-    BpelDAOConnectionImpl(Map<QName, ProcessDaoImpl> store, TransactionManager txm) {\n-        processDaoStore = store;\n-        transactionManager = txm;\n-    }\n+  BpelDAOConnectionImpl(Map<QName, ProcessDaoImpl> store, TransactionManager txm) {\n+    processDaoStore = store;\n+    transactionManager = txm;\n+  }\n \n-    public ProcessDAO getProcess(QName processId) {\n-        return processDaoStore.get(processId);\n-    }\n+  public ProcessDAO getProcess(QName processId) {\n+    return processDaoStore.get(processId);\n+  }\n \n-    public ProcessDAO createProcess(QName pid, QName type, String guid, long version) {\n-        ProcessDaoImpl process = new ProcessDaoImpl(this, processDaoStore, pid, type, guid, version);\n-        processDaoStore.put(pid, process);\n-        return process;\n-    }\n+  public ProcessDAO createProcess(QName pid, QName type, String guid, long version) {\n+    ProcessDaoImpl process = new ProcessDaoImpl(this, processDaoStore, pid, type, guid, version);\n+    processDaoStore.put(pid, process);\n+    return process;\n+  }\n \n-    public ProcessInstanceDAO getInstance(Long iid) {\n-        for (ProcessDaoImpl proc : processDaoStore.values()) {\n-            ProcessInstanceDAO instance = proc._instances.get(iid);\n-            if (instance != null) {\n-                return instance;\n-            }\n-        }\n-        return null;\n+  public ProcessInstanceDAO getInstance(Long iid) {\n+    for (ProcessDaoImpl proc : processDaoStore.values()) {\n+      ProcessInstanceDAO instance = proc._instances.get(iid);\n+      if (instance != null) {\n+        return instance;\n+      }\n     }\n+    return null;\n+  }\n \n-    public Collection<ProcessInstanceDAO> instanceQuery(InstanceFilter filter) {\n-        if (filter.getLimit() == 0) {\n-            return Collections.EMPTY_LIST;\n-        }\n-        List<ProcessInstanceDAO> matched = new ArrayList<ProcessInstanceDAO>();\n-        // Selecting\n-        selectionCompleted:\n-        for (ProcessDaoImpl proc : processDaoStore.values()) {\n-            boolean pmatch = true;\n-            if (filter.getNameFilter() != null\n-                && !equalsOrWildcardMatch(filter.getNameFilter(), proc.getProcessId().getLocalPart())) {\n-                pmatch = false;\n+  public Collection<ProcessInstanceDAO> instanceQuery(InstanceFilter filter) {\n+    if (filter.getLimit() == 0) {\n+      return Collections.EMPTY_LIST;\n+    }\n+    List<ProcessInstanceDAO> matched = new ArrayList<ProcessInstanceDAO>();\n+    // Selecting\n+    selectionCompleted:\n+    for (ProcessDaoImpl proc : processDaoStore.values()) {\n+      boolean pmatch = true;\n+      if (filter.getNameFilter() != null\n+        && !equalsOrWildcardMatch(filter.getNameFilter(), proc.getProcessId().getLocalPart())) {\n+        pmatch = false;\n+      }\n+      if (filter.getNamespaceFilter() != null\n+        && !equalsOrWildcardMatch(filter.getNamespaceFilter(), proc.getProcessId().getNamespaceURI())) {\n+        pmatch = false;\n+      }\n+\n+      if (pmatch) {\n+        for (ProcessInstanceDAO inst : proc._instances.values()) {\n+          boolean match = true;\n+\n+          if (filter.getStatusFilter() != null) {\n+            boolean statusMatch = false;\n+            for (Short status : filter.convertFilterState()) {\n+              if (inst.getState() == status.byteValue()) {\n+                statusMatch = true;\n+              }\n             }\n-            if (filter.getNamespaceFilter() != null\n-                && !equalsOrWildcardMatch(filter.getNamespaceFilter(), proc.getProcessId().getNamespaceURI())) {\n-                pmatch = false;\n+            if (!statusMatch) {\n+              match = false;\n             }\n-\n-            if (pmatch) {\n-                for (ProcessInstanceDAO inst : proc._instances.values()) {\n-                    boolean match = true;\n-\n-                    if (filter.getStatusFilter() != null) {\n-                        boolean statusMatch = false;\n-                        for (Short status : filter.convertFilterState()) {\n-                            if (inst.getState() == status.byteValue()) {\n-                                statusMatch = true;\n-                            }\n-                        }\n-                        if (!statusMatch) {\n-                            match = false;\n-                        }\n-                    }\n-                    if (filter.getStartedDateFilter() != null\n-                        && !dateMatch(filter.getStartedDateFilter(), inst.getCreateTime(), filter)) {\n-                        match = false;\n-                    }\n-                    if (filter.getLastActiveDateFilter() != null\n-                        && !dateMatch(filter.getLastActiveDateFilter(), inst.getLastActiveTime(), filter)) {\n-                        match = false;\n-                    }\n-\n-                    // if (filter.getPropertyValuesFilter() != null) {\n-                    // for (Map.Entry propEntry : filter.getPropertyValuesFilter().entrySet()) {\n-                    // boolean entryMatched = false;\n-                    // for (ProcessPropertyDAO prop : proc.getProperties()) {\n-                    // if (prop.getName().equals(propEntry.getKey())\n-                    // && (propEntry.getValue().equals(prop.getMixedContent())\n-                    // || propEntry.getValue().equals(prop.getSimpleContent()))) {\n-                    // entryMatched = true;\n-                    // }\n-                    // }\n-                    // if (!entryMatched) {\n-                    // match = false;\n-                    // }\n-                    // }\n-                    // }\n-\n-                    if (match) {\n-                        matched.add(inst);\n-                        if (matched.size() == filter.getLimit()) {\n-                            break selectionCompleted;\n-                        }\n-                    }\n-                }\n+          }\n+          if (filter.getStartedDateFilter() != null\n+            && !dateMatch(filter.getStartedDateFilter(), inst.getCreateTime(), filter)) {\n+            match = false;\n+          }\n+          if (filter.getLastActiveDateFilter() != null\n+            && !dateMatch(filter.getLastActiveDateFilter(), inst.getLastActiveTime(), filter)) {\n+            match = false;\n+          }\n+\n+          // if (filter.getPropertyValuesFilter() != null) {\n+          // for (Map.Entry propEntry : filter.getPropertyValuesFilter().entrySet()) {\n+          // boolean entryMatched = false;\n+          // for (ProcessPropertyDAO prop : proc.getProperties()) {\n+          // if (prop.getName().equals(propEntry.getKey())\n+          // && (propEntry.getValue().equals(prop.getMixedContent())\n+          // || propEntry.getValue().equals(prop.getSimpleContent()))) {\n+          // entryMatched = true;\n+          // }\n+          // }\n+          // if (!entryMatched) {\n+          // match = false;\n+          // }\n+          // }\n+          // }\n+\n+          if (match) {\n+            matched.add(inst);\n+            if (matched.size() == filter.getLimit()) {\n+              break selectionCompleted;\n             }\n+          }\n         }\n-        // And ordering\n-        if (filter.getOrders() != null) {\n-            final List<String> orders = filter.getOrders();\n-\n-            Collections.sort(matched, new Comparator<ProcessInstanceDAO>() {\n-                public int compare(ProcessInstanceDAO o1, ProcessInstanceDAO o2) {\n-                    for (String orderKey : orders) {\n-                        int result = compareInstanceUsingKey(orderKey, o1, o2);\n-                        if (result != 0) {\n-                            return result;\n-                        }\n-                    }\n-                    return 0;\n-                }\n-            });\n+      }\n+    }\n+    // And ordering\n+    if (filter.getOrders() != null) {\n+      final List<String> orders = filter.getOrders();\n+\n+      Collections.sort(matched, new Comparator<ProcessInstanceDAO>() {\n+        public int compare(ProcessInstanceDAO o1, ProcessInstanceDAO o2) {\n+          for (String orderKey : orders) {\n+            int result = compareInstanceUsingKey(orderKey, o1, o2);\n+            if (result != 0) {\n+              return result;\n+            }\n+          }\n+          return 0;\n         }\n-\n-        return matched;\n+      });\n     }\n \n-    public int instanceQueryCount(InstanceFilter filter) {\n-        Collection<ProcessInstanceDAO> matched = instanceQuery(filter);\n-        return matched.size();\n+    return matched;\n+  }\n+\n+  public int instanceQueryCount(InstanceFilter filter) {\n+    Collection<ProcessInstanceDAO> matched = instanceQuery(filter);\n+    return matched.size();\n+  }\n+\n+  /**\n+   * Close this DAO connection.\n+   */\n+  public void close() {\n+  }\n+\n+  public Collection<ProcessDAO> processQuery(ProcessFilter filter) {\n+    throw new UnsupportedOperationException(\"Can't query process configuration using a transient DAO.\");\n+  }\n+\n+  public MessageExchangeDAO createMessageExchange(final String mexId, char dir) {\n+    MessageExchangeDAOImpl mex = new MessageExchangeDAOImpl(dir, mexId, this);\n+    mex.createTime = new Date();\n+    long now = System.currentTimeMillis();\n+\n+    mexStore.put(mexId, mex);\n+    mexAge.put(mexId, now);\n+\n+    if (now > lastRemoval + (TIME_TO_LIVE / 10)) {\n+      lastRemoval = now;\n+      Object[] oldMexs = mexAge.keySet().toArray();\n+      for (int i = oldMexs.length - 1; i > 0; i--) {\n+        String oldMex = (String) oldMexs[i];\n+        Long age = mexAge.get(oldMex);\n+        if (age != null && now - age > TIME_TO_LIVE) {\n+          releaseMessageExchange(oldMex);\n+        }\n+      }\n     }\n \n-    /**\n-     * Close this DAO connection.\n-     */\n-    public void close() {\n-    }\n+    // Removing right away on rollback\n+    onRollback(new Runnable() {\n+      public void run() {\n+        releaseMessageExchange(mexId);\n+      }\n+    });\n \n-    public Collection<ProcessDAO> processQuery(ProcessFilter filter) {\n-        throw new UnsupportedOperationException(\"Can't query process configuration using a transient DAO.\");\n-    }\n+    return mex;\n+  }\n \n-    public MessageExchangeDAO createMessageExchange(final String mexId, char dir) {\n-        MessageExchangeDAOImpl mex = new MessageExchangeDAOImpl(dir, mexId, this);\n-        mex.createTime = new Date();\n-        long now = System.currentTimeMillis();\n-\n-        mexStore.put(mexId, mex);\n-        mexAge.put(mexId, now);\n-\n-        if (now > lastRemoval + (TIME_TO_LIVE / 10)) {\n-            lastRemoval = now;\n-            Object[] oldMexs = mexAge.keySet().toArray();\n-            for (int i = oldMexs.length - 1; i > 0; i--) {\n-                String oldMex = (String) oldMexs[i];\n-                Long age = mexAge.get(oldMex);\n-                if (age != null && now - age > TIME_TO_LIVE) {\n-                    releaseMessageExchange(oldMex);\n-                }\n-            }\n-        }\n+  // TODO: Implement this.\n \n-        // Removing right away on rollback\n-        onRollback(new Runnable() {\n-            public void run() {\n-                releaseMessageExchange(mexId);\n-            }\n-        });\n+  public MessageDAO createMessage(QName type) {\n+    MessageDAO messageDAO = new MessageDAOImpl();\n+    messageDAO.setType(type);\n+    return messageDAO;\n+  }\n \n-        return mex;\n-    }\n+  public MessageExchangeDAO getMessageExchange(String mexid) {\n+    return mexStore.get(mexid);\n \n-    // TODO: Implement this.\n+  }\n \n-    public MessageDAO createMessage(QName type) {\n-        MessageDAO messageDAO = new MessageDAOImpl();\n-        messageDAO.setType(type);\n-        return messageDAO;\n+  public void releaseMessageExchange(String mexid) {\n+    if (log.isDebugEnabled()) {\n+      log.debug(\"Releasing Message exchange \" + mexid);\n     }\n-\n-    public MessageExchangeDAO getMessageExchange(String mexid) {\n-        return mexStore.get(mexid);\n-\n+    MessageExchangeDAO mexDao = mexStore.remove(mexid);\n+    if (mexDao == null) {\n+      log.warn(\"Could not find mex \" + mexDao + \" for cleanup.\");\n     }\n-\n-    public void releaseMessageExchange(String mexid) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Releasing Message exchange \" + mexid);\n-        }\n-        MessageExchangeDAO mexDao = mexStore.remove(mexid);\n-        if (mexDao == null) {\n-            log.warn(\"Could not find mex \" + mexDao + \" for cleanup.\");\n-        }\n-        mexAge.remove(mexid);\n-\n+    mexAge.remove(mexid);\n+\n+  }\n+\n+  private int compareInstanceUsingKey(String key, ProcessInstanceDAO instanceDAO1,\n+                                      ProcessInstanceDAO instanceDAO2) {\n+    String s1 = null;\n+    String s2 = null;\n+    boolean ascending = true;\n+    String orderKey = key;\n+    if (key.startsWith(\"+\") || key.startsWith(\"-\")) {\n+      orderKey = key.substring(1, key.length());\n+      if (key.startsWith(\"-\")) {\n+        ascending = false;\n+      }\n     }\n-\n-    private int compareInstanceUsingKey(String key, ProcessInstanceDAO instanceDAO1,\n-                                        ProcessInstanceDAO instanceDAO2) {\n-        String s1 = null;\n-        String s2 = null;\n-        boolean ascending = true;\n-        String orderKey = key;\n-        if (key.startsWith(\"+\") || key.startsWith(\"-\")) {\n-            orderKey = key.substring(1, key.length());\n-            if (key.startsWith(\"-\")) {\n-                ascending = false;\n-            }\n-        }\n-        ProcessDAO process1 = getProcess(instanceDAO1.getProcess().getProcessId());\n-        ProcessDAO process2 = getProcess(instanceDAO2.getProcess().getProcessId());\n-        if (\"pid\".equals(orderKey)) {\n-            s1 = process1.getProcessId().toString();\n-            s2 = process2.getProcessId().toString();\n-        } else if (\"name\".equals(orderKey)) {\n-            s1 = process1.getProcessId().getLocalPart();\n-            s2 = process2.getProcessId().getLocalPart();\n-        } else if (\"namespace\".equals(orderKey)) {\n-            s1 = process1.getProcessId().getNamespaceURI();\n-            s2 = process2.getProcessId().getNamespaceURI();\n-        } else if (\"version\".equals(orderKey)) {\n-            s1 = \"\" + process1.getVersion();\n-            s2 = \"\" + process2.getVersion();\n-        } else if (\"status\".equals(orderKey)) {\n-            s1 = \"\" + instanceDAO1.getState();\n-            s2 = \"\" + instanceDAO2.getState();\n-        } else if (\"started\".equals(orderKey)) {\n-            s1 = ISO8601DateParser.format(instanceDAO1.getCreateTime());\n-            s2 = ISO8601DateParser.format(instanceDAO2.getCreateTime());\n-        } else if (\"last-active\".equals(orderKey)) {\n-            s1 = ISO8601DateParser.format(instanceDAO1.getLastActiveTime());\n-            s2 = ISO8601DateParser.format(instanceDAO2.getLastActiveTime());\n-        }\n-        if (ascending) {\n-            return s1.compareTo(s2);\n-        } else {\n-            return s2.compareTo(s1);\n-        }\n+    ProcessDAO process1 = getProcess(instanceDAO1.getProcess().getProcessId());\n+    ProcessDAO process2 = getProcess(instanceDAO2.getProcess().getProcessId());\n+    if (\"pid\".equals(orderKey)) {\n+      s1 = process1.getProcessId().toString();\n+      s2 = process2.getProcessId().toString();\n+    } else if (\"name\".equals(orderKey)) {\n+      s1 = process1.getProcessId().getLocalPart();\n+      s2 = process2.getProcessId().getLocalPart();\n+    } else if (\"namespace\".equals(orderKey)) {\n+      s1 = process1.getProcessId().getNamespaceURI();\n+      s2 = process2.getProcessId().getNamespaceURI();\n+    } else if (\"version\".equals(orderKey)) {\n+      s1 = \"\" + process1.getVersion();\n+      s2 = \"\" + process2.getVersion();\n+    } else if (\"status\".equals(orderKey)) {\n+      s1 = \"\" + instanceDAO1.getState();\n+      s2 = \"\" + instanceDAO2.getState();\n+    } else if (\"started\".equals(orderKey)) {\n+      s1 = ISO8601DateParser.format(instanceDAO1.getCreateTime());\n+      s2 = ISO8601DateParser.format(instanceDAO2.getCreateTime());\n+    } else if (\"last-active\".equals(orderKey)) {\n+      s1 = ISO8601DateParser.format(instanceDAO1.getLastActiveTime());\n+      s2 = ISO8601DateParser.format(instanceDAO2.getLastActiveTime());\n+    }\n+    if (ascending) {\n+      return s1.compareTo(s2);\n+    } else {\n+      return s2.compareTo(s1);\n     }\n+  }\n \n-    private boolean equalsOrWildcardMatch(String s1, String s2) {\n-        if (s1 == null || s2 == null) {\n-            return false;\n+  private boolean equalsOrWildcardMatch(String s1, String s2) {\n+    if (s1 == null || s2 == null) {\n+      return false;\n+    }\n+    if (s1.equals(s2)) {\n+      return true;\n+    }\n+    if (s1.endsWith(\"*\")) {\n+      if (s2.startsWith(s1.substring(0, s1.length() - 1))) {\n+        return true;\n+      }\n+    }\n+    if (s2.endsWith(\"*\")) {\n+      if (s1.startsWith(s2.substring(0, s2.length() - 1))) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public boolean dateMatch(List<String> dateFilters, Date instanceDate, InstanceFilter filter) {\n+    boolean match = true;\n+    for (String ddf : dateFilters) {\n+      String isoDate = ISO8601DateParser.format(instanceDate);\n+      String critDate = Filter.getDateWithoutOp(ddf);\n+      if (ddf.startsWith(\"=\")) {\n+        if (!isoDate.startsWith(critDate)) {\n+          match = false;\n         }\n-        if (s1.equals(s2)) {\n-            return true;\n+      } else if (ddf.startsWith(\"<=\")) {\n+        if (!isoDate.startsWith(critDate) && isoDate.compareTo(critDate) > 0) {\n+          match = false;\n         }\n-        if (s1.endsWith(\"*\")) {\n-            if (s2.startsWith(s1.substring(0, s1.length() - 1))) {\n-                return true;\n-            }\n+      } else if (ddf.startsWith(\">=\")) {\n+        if (!isoDate.startsWith(critDate) && isoDate.compareTo(critDate) < 0) {\n+          match = false;\n         }\n-        if (s2.endsWith(\"*\")) {\n-            if (s1.startsWith(s2.substring(0, s2.length() - 1))) {\n-                return true;\n-            }\n+      } else if (ddf.startsWith(\"<\")) {\n+        if (isoDate.compareTo(critDate) > 0) {\n+          match = false;\n         }\n-        return false;\n-    }\n-\n-    public boolean dateMatch(List<String> dateFilters, Date instanceDate, InstanceFilter filter) {\n-        boolean match = true;\n-        for (String ddf : dateFilters) {\n-            String isoDate = ISO8601DateParser.format(instanceDate);\n-            String critDate = Filter.getDateWithoutOp(ddf);\n-            if (ddf.startsWith(\"=\")) {\n-                if (!isoDate.startsWith(critDate)) {\n-                    match = false;\n-                }\n-            } else if (ddf.startsWith(\"<=\")) {\n-                if (!isoDate.startsWith(critDate) && isoDate.compareTo(critDate) > 0) {\n-                    match = false;\n-                }\n-            } else if (ddf.startsWith(\">=\")) {\n-                if (!isoDate.startsWith(critDate) && isoDate.compareTo(critDate) < 0) {\n-                    match = false;\n-                }\n-            } else if (ddf.startsWith(\"<\")) {\n-                if (isoDate.compareTo(critDate) > 0) {\n-                    match = false;\n-                }\n-            } else if (ddf.startsWith(\">\")) {\n-                if (isoDate.compareTo(critDate) < 0) {\n-                    match = false;\n-                }\n-            }\n+      } else if (ddf.startsWith(\">\")) {\n+        if (isoDate.compareTo(critDate) < 0) {\n+          match = false;\n         }\n-        return match;\n+      }\n     }\n-\n-    public ScopeDAO getScope(Long siidl) {\n-        for (ProcessDaoImpl process : processDaoStore.values()) {\n-            for (ProcessInstanceDAO instance : process._instances.values()) {\n-                if (instance.getScope(siidl) != null) {\n-                    return instance.getScope(siidl);\n-                }\n-            }\n+    return match;\n+  }\n+\n+  public ScopeDAO getScope(Long siidl) {\n+    for (ProcessDaoImpl process : processDaoStore.values()) {\n+      for (ProcessInstanceDAO instance : process._instances.values()) {\n+        if (instance.getScope(siidl) != null) {\n+          return instance.getScope(siidl);\n         }\n-        return null;\n-    }\n-\n-    public void insertBpelEvent(BpelEvent event, ProcessDAO processConfiguration,\n-                                ProcessInstanceDAO instance) {\n-        events.add(event);\n-    }\n-\n-    public List<Date> bpelEventTimelineQuery(InstanceFilter ifilter, BpelEventFilter efilter) {\n-        // TODO : Provide more correct implementation:\n-        ArrayList<Date> dates = new ArrayList<Date>();\n-        CollectionsX.transform(dates, events, new UnaryFunction<BpelEvent, Date>() {\n-            public Date apply(BpelEvent x) {\n-                return x.getTimestamp();\n-            }\n-        });\n-        return dates;\n+      }\n     }\n+    return null;\n+  }\n+\n+  public void insertBpelEvent(BpelEvent event, ProcessDAO processConfiguration,\n+                              ProcessInstanceDAO instance) {\n+    events.add(event);\n+  }\n+\n+  public List<Date> bpelEventTimelineQuery(InstanceFilter ifilter, BpelEventFilter efilter) {\n+    // TODO : Provide more correct implementation:\n+    ArrayList<Date> dates = new ArrayList<Date>();\n+    CollectionsX.transform(dates, events, new UnaryFunction<BpelEvent, Date>() {\n+      public Date apply(BpelEvent x) {\n+        return x.getTimestamp();\n+      }\n+    });\n+    return dates;\n+  }\n+\n+  public List<BpelEvent> bpelEventQuery(InstanceFilter ifilter, BpelEventFilter efilter) {\n+    // TODO : Provide a more correct (filtering) implementation:\n+    return events;\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.dao.BpelDAOConnection#instanceQuery(String)\n+   */\n+  public Collection<ProcessInstanceDAO> instanceQuery(String expression) {\n+    // TODO\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void defer(final Runnable runnable) {\n+    try {\n+      transactionManager.getTransaction().registerSynchronization(new Synchronization() {\n+        public void afterCompletion(int status) {\n+        }\n \n-    public List<BpelEvent> bpelEventQuery(InstanceFilter ifilter, BpelEventFilter efilter) {\n-        // TODO : Provide a more correct (filtering) implementation:\n-        return events;\n-    }\n+        public void beforeCompletion() {\n+          runnable.run();\n+        }\n+      });\n \n-    /**\n-     * @see org.apache.ode.bpel.dao.BpelDAOConnection#instanceQuery(String)\n-     */\n-    public Collection<ProcessInstanceDAO> instanceQuery(String expression) {\n-        // TODO\n-        throw new UnsupportedOperationException();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n     }\n+  }\n \n-    public void defer(final Runnable runnable) {\n-        try {\n-            transactionManager.getTransaction().registerSynchronization(new Synchronization() {\n-                public void afterCompletion(int status) {\n-                }\n \n-                public void beforeCompletion() {\n-                    runnable.run();\n-                }\n-            });\n-\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n+  public void onRollback(final Runnable runnable) {\n+    try {\n+      transactionManager.getTransaction().registerSynchronization(new Synchronization() {\n+        public void afterCompletion(int status) {\n+          if (status != Status.STATUS_COMMITTED) {\n+            runnable.run();\n+          }\n         }\n-    }\n \n-\n-    public void onRollback(final Runnable runnable) {\n-        try {\n-            transactionManager.getTransaction().registerSynchronization(new Synchronization() {\n-                public void afterCompletion(int status) {\n-                    if (status != Status.STATUS_COMMITTED) {\n-                        runnable.run();\n-                    }\n-                }\n-\n-                public void beforeCompletion() {\n-                }\n-            });\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n+        public void beforeCompletion() {\n         }\n+      });\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n     }\n-\n-    public Map<Long, Collection<CorrelationSetDAO>> getCorrelationSets(\n-            Collection<ProcessInstanceDAO> instances) {\n-        Map<Long, Collection<CorrelationSetDAO>> map = new HashMap<Long, Collection<CorrelationSetDAO>>();\n-        for (ProcessInstanceDAO instance : instances) {\n-            Long id = instance.getInstanceId();\n-            Collection<CorrelationSetDAO> existing = map.get(id);\n-            if (existing == null) {\n-                existing = new ArrayList<CorrelationSetDAO>();\n-                map.put(id, existing);\n-            }\n-            existing.addAll(instance.getCorrelationSets());\n-        }\n-        return map;\n+  }\n+\n+  public Map<Long, Collection<CorrelationSetDAO>> getCorrelationSets(\n+    Collection<ProcessInstanceDAO> instances) {\n+    Map<Long, Collection<CorrelationSetDAO>> map = new HashMap<Long, Collection<CorrelationSetDAO>>();\n+    for (ProcessInstanceDAO instance : instances) {\n+      Long id = instance.getInstanceId();\n+      Collection<CorrelationSetDAO> existing = map.get(id);\n+      if (existing == null) {\n+        existing = new ArrayList<CorrelationSetDAO>();\n+        map.put(id, existing);\n+      }\n+      existing.addAll(instance.getCorrelationSets());\n     }\n+    return map;\n+  }\n \n-    public ProcessManagementDaoImpl getProcessManagement() {\n-        return new ProcessManagementDaoImpl();\n-    }\n+  public ProcessManagementDaoImpl getProcessManagement() {\n+    return new ProcessManagementDaoImpl();\n+  }\n }\n",
            "diff_size": 460
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "69",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/371/BpelDAOConnectionImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/371/BpelDAOConnectionImpl.java\nindex 3e5f67998e3..42b09a29dfc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/371/BpelDAOConnectionImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/371/BpelDAOConnectionImpl.java\n@@ -252,9 +252,8 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n \n     }\n \n-    private int compareInstanceUsingKey(String key, ProcessInstanceDAO instanceDAO1,\n-                                        ProcessInstanceDAO instanceDAO2) {\n-        String s1 = null;\n+    private int compareInstanceUsingKey(String key, ProcessInstanceDAO instanceDAO1, ProcessInstanceDAO instanceDAO2) {\n+    String s1 = null;\n         String s2 = null;\n         boolean ascending = true;\n         String orderKey = key;\n@@ -356,9 +355,8 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n         return null;\n     }\n \n-    public void insertBpelEvent(BpelEvent event, ProcessDAO processConfiguration,\n-                                ProcessInstanceDAO instance) {\n-        events.add(event);\n+    public void insertBpelEvent(BpelEvent event, ProcessDAO processConfiguration, ProcessInstanceDAO instance) {\n+    events.add(event);\n     }\n \n     public List<Date> bpelEventTimelineQuery(InstanceFilter ifilter, BpelEventFilter efilter) {\n@@ -437,4 +435,4 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n     public ProcessManagementDaoImpl getProcessManagement() {\n         return new ProcessManagementDaoImpl();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "69",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/371/BpelDAOConnectionImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/371/BpelDAOConnectionImpl.java\nindex 3e5f67998e3..b4666d9bd34 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/371/BpelDAOConnectionImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/371/BpelDAOConnectionImpl.java\n@@ -66,7 +66,8 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n \n     private static final List<BpelEvent> events = new ArrayList<BpelEvent>();\n     private static final Map<String, Long> mexAge = new ConcurrentHashMap<String, Long>();\n-    private static final Map<String, MessageExchangeDAOImpl> mexStore = new ConcurrentHashMap<String, MessageExchangeDAOImpl>();\n+    private static final Map<\n+            String, MessageExchangeDAOImpl> mexStore = new ConcurrentHashMap<String, MessageExchangeDAOImpl>();\n \n     private volatile long lastRemoval = 0;\n \n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}