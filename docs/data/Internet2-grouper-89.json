{
    "project_name": "Internet2-grouper",
    "error_id": "89",
    "information": {
        "errors": [
            {
                "line": "99",
                "severity": "warning",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": " * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.\n * </p>\n * \n * @since 2.0\n * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\n */",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "99",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/89/ReflectionToStringBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/intellij/89/ReflectionToStringBuilder.java\nindex 9ba7082e128..f6761444b9a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/89/ReflectionToStringBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/intellij/89/ReflectionToStringBuilder.java\n@@ -1,12 +1,12 @@\n /**\r\n  * Copyright 2014 Internet2\r\n- *\r\n+ * <p>\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n+ * <p>\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ * <p>\r\n  * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n@@ -96,611 +96,611 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassU\n  * <p>\r\n  * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the constructor.\r\n  * </p>\r\n- * \r\n+ *\r\n  * @since 2.0\r\n  * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\r\n  */\r\n public class ReflectionToStringBuilder extends ToStringBuilder {\r\n \r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n-     * Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object) {\r\n-        return toString(object, null, false, false, null);\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n+   * Superclass fields will be appended.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   */\r\n+  public static String toString(Object object) {\r\n+    return toString(object, null, false, false, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n+   * Superclass fields will be appended.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object or <code>ToStringStyle</code> is <code>null</code>\r\n+   */\r\n+  public static String toString(Object object, ToStringStyle style) {\r\n+    return toString(object, style, false, false, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be included. Superclass fields will be appended.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param outputTransients\r\n+   *            whether to include transient fields\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   */\r\n+  public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\r\n+    return toString(object, style, outputTransients, false, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n+   * ignored.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Static fields will not be included. Superclass fields will be appended.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param outputTransients\r\n+   *            whether to include transient fields\r\n+   * @param outputStatics\r\n+   *            whether to include transient fields\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @since 2.1\r\n+   */\r\n+  public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\r\n+    return toString(object, style, outputTransients, outputStatics, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Builds a <code>toString</code> value through reflection.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n+   * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n+   * also not as efficient as testing explicitly.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n+   * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n+   * ignored.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\r\n+   * <code>java.lang.Object</code>.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n+   * </p>\r\n+   *\r\n+   * @param <T>\r\n+   *            the type of the object\r\n+   * @param object\r\n+   *            the Object to be output\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param outputTransients\r\n+   *            whether to include transient fields\r\n+   * @param outputStatics\r\n+   *            whether to include static fields\r\n+   * @param reflectUpToClass\r\n+   *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n+   * @return the String result\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object is <code>null</code>\r\n+   * @since 2.1\r\n+   */\r\n+  public static <T> String toString(\r\n+    T object, ToStringStyle style, boolean outputTransients,\r\n+    boolean outputStatics, Class<? super T> reflectUpToClass) {\r\n+    return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\r\n+      .toString();\r\n+  }\r\n+\r\n+  /**\r\n+   * Builds a String for a toString method excluding the given field names.\r\n+   *\r\n+   * @param object\r\n+   *            The object to \"toString\".\r\n+   * @param excludeFieldNames\r\n+   *            The field names to exclude. Null excludes nothing.\r\n+   * @return The toString value.\r\n+   */\r\n+  public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\r\n+    return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\r\n+  }\r\n+\r\n+  /**\r\n+   * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\r\n+   * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element\r\n+   * is <code>null</code>.\r\n+   *\r\n+   * @param collection\r\n+   *            The collection to convert\r\n+   * @return A new array of Strings.\r\n+   */\r\n+  static String[] toNoNullStringArray(Collection<String> collection) {\r\n+    if (collection == null) {\r\n+      return ArrayUtils.EMPTY_STRING_ARRAY;\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\r\n-     * Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style) {\r\n-        return toString(object, style, false, false, null);\r\n+    return toNoNullStringArray(collection.toArray());\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\r\n+   * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\r\n+   * if an array element is <code>null</code>.\r\n+   *\r\n+   * @param array\r\n+   *            The array to check\r\n+   * @return The given array or a new array without null.\r\n+   */\r\n+  static String[] toNoNullStringArray(Object[] array) {\r\n+    List<String> list = new ArrayList<String>(array.length);\r\n+    for (Object e : array) {\r\n+      if (e != null) {\r\n+        list.add(e.toString());\r\n+      }\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\r\n-        return toString(object, style, outputTransients, false, null);\r\n+    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\r\n+  }\r\n+\r\n+\r\n+  /**\r\n+   * Builds a String for a toString method excluding the given field names.\r\n+   *\r\n+   * @param object\r\n+   *            The object to \"toString\".\r\n+   * @param excludeFieldNames\r\n+   *            The field names to exclude\r\n+   * @return The toString value.\r\n+   */\r\n+  public static String toStringExclude(Object object, String... excludeFieldNames) {\r\n+    return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\r\n+  }\r\n+\r\n+  /**\r\n+   * Whether or not to append static fields.\r\n+   */\r\n+  private boolean appendStatics = false;\r\n+\r\n+  /**\r\n+   * Whether or not to append transient fields.\r\n+   */\r\n+  private boolean appendTransients = false;\r\n+\r\n+  /**\r\n+   * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\r\n+   *\r\n+   * @since 3.0 this is protected instead of private\r\n+   */\r\n+  protected String[] excludeFieldNames;\r\n+\r\n+  /**\r\n+   * The last super class to stop appending fields for.\r\n+   */\r\n+  private Class<?> upToClass = null;\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Constructor.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object passed in is <code>null</code>\r\n+   */\r\n+  public ReflectionToStringBuilder(Object object) {\r\n+    super(object);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Constructor.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default style is used.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object passed in is <code>null</code>\r\n+   */\r\n+  public ReflectionToStringBuilder(Object object, ToStringStyle style) {\r\n+    super(object, style);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Constructor.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the style is <code>null</code>, the default style is used.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If the buffer is <code>null</code>, a new one is created.\r\n+   * </p>\r\n+   *\r\n+   * @param object\r\n+   *            the Object to build a <code>toString</code> for\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param buffer\r\n+   *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n+   * @throws IllegalArgumentException\r\n+   *             if the Object passed in is <code>null</code>\r\n+   */\r\n+  public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\r\n+    super(object, style, buffer);\r\n+  }\r\n+\r\n+  /**\r\n+   * Constructor.\r\n+   *\r\n+   * @param <T>\r\n+   *            the type of the object\r\n+   * @param object\r\n+   *            the Object to build a <code>toString</code> for\r\n+   * @param style\r\n+   *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n+   * @param buffer\r\n+   *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n+   * @param reflectUpToClass\r\n+   *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n+   * @param outputTransients\r\n+   *            whether to include transient fields\r\n+   * @param outputStatics\r\n+   *            whether to include static fields\r\n+   * @since 2.1\r\n+   */\r\n+  public <T> ReflectionToStringBuilder(\r\n+    T object, ToStringStyle style, StringBuffer buffer,\r\n+    Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\r\n+    super(object, style, buffer);\r\n+    this.setUpToClass(reflectUpToClass);\r\n+    this.setAppendTransients(outputTransients);\r\n+    this.setAppendStatics(outputStatics);\r\n+  }\r\n+\r\n+  /**\r\n+   * Returns whether or not to append the given <code>Field</code>.\r\n+   * <ul>\r\n+   * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\r\n+   * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\r\n+   * <li>Inner class fields are not appened.</li>\r\n+   * </ul>\r\n+   *\r\n+   * @param field\r\n+   *            The Field to test.\r\n+   * @return Whether or not to append the given <code>Field</code>.\r\n+   */\r\n+  protected boolean accept(Field field) {\r\n+    if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\r\n+      // Reject field from inner class.\r\n+      return false;\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n-     * ignored.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Static fields will not be included. Superclass fields will be appended.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include transient fields\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @since 2.1\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\r\n-        return toString(object, style, outputTransients, outputStatics, null);\r\n+    if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\r\n+      // Reject transient fields.\r\n+      return false;\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Builds a <code>toString</code> value through reflection.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\r\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\r\n-     * also not as efficient as testing explicitly.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\r\n-     * are ignored, as they are likely derived fields, and not part of the value of the Object.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\r\n-     * ignored.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\r\n-     * <code>java.lang.Object</code>.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\r\n-     * </p>\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object\r\n-     * @param object\r\n-     *            the Object to be output\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include static fields\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @return the String result\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object is <code>null</code>\r\n-     * @since 2.1\r\n-     */\r\n-    public static <T> String toString(\r\n-            T object, ToStringStyle style, boolean outputTransients,\r\n-            boolean outputStatics, Class<? super T> reflectUpToClass) {\r\n-        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\r\n-                .toString();\r\n+    if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\r\n+      // Reject static fields.\r\n+      return false;\r\n     }\r\n-\r\n-    /**\r\n-     * Builds a String for a toString method excluding the given field names.\r\n-     *\r\n-     * @param object\r\n-     *            The object to \"toString\".\r\n-     * @param excludeFieldNames\r\n-     *            The field names to exclude. Null excludes nothing.\r\n-     * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\r\n-        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\r\n-    }\r\n-\r\n-    /**\r\n-     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\r\n-     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element\r\n-     * is <code>null</code>.\r\n-     *\r\n-     * @param collection\r\n-     *            The collection to convert\r\n-     * @return A new array of Strings.\r\n-     */\r\n-    static String[] toNoNullStringArray(Collection<String> collection) {\r\n-        if (collection == null) {\r\n-            return ArrayUtils.EMPTY_STRING_ARRAY;\r\n-        }\r\n-        return toNoNullStringArray(collection.toArray());\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\r\n-     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException}\r\n-     * if an array element is <code>null</code>.\r\n-     *\r\n-     * @param array\r\n-     *            The array to check\r\n-     * @return The given array or a new array without null.\r\n-     */\r\n-    static String[] toNoNullStringArray(Object[] array) {\r\n-        List<String> list = new ArrayList<String>(array.length);\r\n-        for (Object e : array) {\r\n-            if (e != null) {\r\n-                list.add(e.toString());\r\n-            }\r\n-        }\r\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\r\n-    }\r\n-\r\n-\r\n-    /**\r\n-     * Builds a String for a toString method excluding the given field names.\r\n-     *\r\n-     * @param object\r\n-     *            The object to \"toString\".\r\n-     * @param excludeFieldNames\r\n-     *            The field names to exclude\r\n-     * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, String... excludeFieldNames) {\r\n-        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether or not to append static fields.\r\n-     */\r\n-    private boolean appendStatics = false;\r\n-\r\n-    /**\r\n-     * Whether or not to append transient fields.\r\n-     */\r\n-    private boolean appendTransients = false;\r\n-\r\n-    /**\r\n-     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\r\n-     *\r\n-     * @since 3.0 this is protected instead of private\r\n-     */\r\n-    protected String[] excludeFieldNames;\r\n-\r\n-    /**\r\n-     * The last super class to stop appending fields for.\r\n-     */\r\n-    private Class<?> upToClass = null;\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object) {\r\n-        super(object);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default style is used.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\r\n-        super(object, style);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Constructor.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the style is <code>null</code>, the default style is used.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If the buffer is <code>null</code>, a new one is created.\r\n-     * </p>\r\n-     *\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param buffer\r\n-     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n-     * @throws IllegalArgumentException\r\n-     *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\r\n-        super(object, style, buffer);\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param <T>\r\n-     *            the type of the object\r\n-     * @param object\r\n-     *            the Object to build a <code>toString</code> for\r\n-     * @param style\r\n-     *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n-     * @param buffer\r\n-     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n-     * @param reflectUpToClass\r\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\r\n-     * @param outputTransients\r\n-     *            whether to include transient fields\r\n-     * @param outputStatics\r\n-     *            whether to include static fields\r\n-     * @since 2.1\r\n-     */\r\n-    public <T> ReflectionToStringBuilder(\r\n-            T object, ToStringStyle style, StringBuffer buffer,\r\n-            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\r\n-        super(object, style, buffer);\r\n-        this.setUpToClass(reflectUpToClass);\r\n-        this.setAppendTransients(outputTransients);\r\n-        this.setAppendStatics(outputStatics);\r\n+    if (this.excludeFieldNames != null\r\n+      && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n+      // Reject fields from the getExcludeFieldNames list.\r\n+      return false;\r\n     }\r\n-\r\n-    /**\r\n-     * Returns whether or not to append the given <code>Field</code>.\r\n-     * <ul>\r\n-     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\r\n-     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\r\n-     * <li>Inner class fields are not appened.</li>\r\n-     * </ul>\r\n-     *\r\n-     * @param field\r\n-     *            The Field to test.\r\n-     * @return Whether or not to append the given <code>Field</code>.\r\n-     */\r\n-    protected boolean accept(Field field) {\r\n-        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\r\n-            // Reject field from inner class.\r\n-            return false;\r\n-        }\r\n-        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\r\n-            // Reject transient fields.\r\n-            return false;\r\n-        }\r\n-        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\r\n-            // Reject static fields.\r\n-            return false;\r\n-        }\r\n-        if (this.excludeFieldNames != null\r\n-            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n-            // Reject fields from the getExcludeFieldNames list.\r\n-            return false;\r\n-        }\r\n-        return true;\r\n+    return true;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Appends the fields and values defined by the given object of the given Class.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\r\n+   * <code>Object.toString()</code> had been called and not implemented by the object.\r\n+   * </p>\r\n+   *\r\n+   * @param clazz\r\n+   *            The class of object parameter\r\n+   */\r\n+  protected void appendFieldsIn(Class<?> clazz) {\r\n+    if (clazz.isArray()) {\r\n+      this.reflectionAppendArray(this.getObject());\r\n+      return;\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Appends the fields and values defined by the given object of the given Class.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\r\n-     * <code>Object.toString()</code> had been called and not implemented by the object.\r\n-     * </p>\r\n-     *\r\n-     * @param clazz\r\n-     *            The class of object parameter\r\n-     */\r\n-    protected void appendFieldsIn(Class<?> clazz) {\r\n-        if (clazz.isArray()) {\r\n-            this.reflectionAppendArray(this.getObject());\r\n-            return;\r\n-        }\r\n-        Field[] fields = clazz.getDeclaredFields();\r\n-        AccessibleObject.setAccessible(fields, true);\r\n-        for (Field field : fields) {\r\n-            String fieldName = field.getName();\r\n-            if (this.accept(field)) {\r\n-                try {\r\n-                    // Warning: Field.get(Object) creates wrappers objects\r\n-                    // for primitive types.\r\n-                    Object fieldValue = this.getValue(field);\r\n-                    this.append(fieldName, fieldValue);\r\n-                } catch (IllegalAccessException ex) {\r\n-                    //this can't happen. Would get a Security exception\r\n-                    // instead\r\n-                    //throw a runtime exception in case the impossible\r\n-                    // happens.\r\n-                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\r\n-                }\r\n-            }\r\n+    Field[] fields = clazz.getDeclaredFields();\r\n+    AccessibleObject.setAccessible(fields, true);\r\n+    for (Field field : fields) {\r\n+      String fieldName = field.getName();\r\n+      if (this.accept(field)) {\r\n+        try {\r\n+          // Warning: Field.get(Object) creates wrappers objects\r\n+          // for primitive types.\r\n+          Object fieldValue = this.getValue(field);\r\n+          this.append(fieldName, fieldValue);\r\n+        } catch (IllegalAccessException ex) {\r\n+          //this can't happen. Would get a Security exception\r\n+          // instead\r\n+          //throw a runtime exception in case the impossible\r\n+          // happens.\r\n+          throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\r\n         }\r\n+      }\r\n     }\r\n-\r\n-    /**\r\n-     * @return Returns the excludeFieldNames.\r\n-     */\r\n-    public String[] getExcludeFieldNames() {\r\n-        return this.excludeFieldNames.clone();\r\n+  }\r\n+\r\n+  /**\r\n+   * @return Returns the excludeFieldNames.\r\n+   */\r\n+  public String[] getExcludeFieldNames() {\r\n+    return this.excludeFieldNames.clone();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Gets the last super class to stop appending fields for.\r\n+   * </p>\r\n+   *\r\n+   * @return The last super class to stop appending fields for.\r\n+   */\r\n+  public Class<?> getUpToClass() {\r\n+    return this.upToClass;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Calls <code>java.lang.reflect.Field.get(Object)</code>.\r\n+   * </p>\r\n+   *\r\n+   * @param field\r\n+   *            The Field to query.\r\n+   * @return The Object from the given Field.\r\n+   *\r\n+   * @throws IllegalArgumentException\r\n+   *             see {@link java.lang.reflect.Field#get(Object)}\r\n+   * @throws IllegalAccessException\r\n+   *             see {@link java.lang.reflect.Field#get(Object)}\r\n+   *\r\n+   * @see java.lang.reflect.Field#get(Object)\r\n+   */\r\n+  protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\r\n+    return field.get(this.getObject());\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Gets whether or not to append static fields.\r\n+   * </p>\r\n+   *\r\n+   * @return Whether or not to append static fields.\r\n+   * @since 2.1\r\n+   */\r\n+  public boolean isAppendStatics() {\r\n+    return this.appendStatics;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Gets whether or not to append transient fields.\r\n+   * </p>\r\n+   *\r\n+   * @return Whether or not to append transient fields.\r\n+   */\r\n+  public boolean isAppendTransients() {\r\n+    return this.appendTransients;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Append to the <code>toString</code> an <code>Object</code> array.\r\n+   * </p>\r\n+   *\r\n+   * @param array\r\n+   *            the array to add to the <code>toString</code>\r\n+   * @return this\r\n+   */\r\n+  public ReflectionToStringBuilder reflectionAppendArray(Object array) {\r\n+    this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Sets whether or not to append static fields.\r\n+   * </p>\r\n+   *\r\n+   * @param appendStatics\r\n+   *            Whether or not to append static fields.\r\n+   * @since 2.1\r\n+   */\r\n+  public void setAppendStatics(boolean appendStatics) {\r\n+    this.appendStatics = appendStatics;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Sets whether or not to append transient fields.\r\n+   * </p>\r\n+   *\r\n+   * @param appendTransients\r\n+   *            Whether or not to append transient fields.\r\n+   */\r\n+  public void setAppendTransients(boolean appendTransients) {\r\n+    this.appendTransients = appendTransients;\r\n+  }\r\n+\r\n+  /**\r\n+   * Sets the field names to exclude.\r\n+   *\r\n+   * @param excludeFieldNamesParam\r\n+   *            The excludeFieldNames to excluding from toString or <code>null</code>.\r\n+   * @return <code>this</code>\r\n+   */\r\n+  public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\r\n+    if (excludeFieldNamesParam == null) {\r\n+      this.excludeFieldNames = null;\r\n+    } else {\r\n+      //clone and remove nulls\r\n+      this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\r\n+      Arrays.sort(this.excludeFieldNames);\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets the last super class to stop appending fields for.\r\n-     * </p>\r\n-     *\r\n-     * @return The last super class to stop appending fields for.\r\n-     */\r\n-    public Class<?> getUpToClass() {\r\n-        return this.upToClass;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\r\n-     * </p>\r\n-     *\r\n-     * @param field\r\n-     *            The Field to query.\r\n-     * @return The Object from the given Field.\r\n-     *\r\n-     * @throws IllegalArgumentException\r\n-     *             see {@link java.lang.reflect.Field#get(Object)}\r\n-     * @throws IllegalAccessException\r\n-     *             see {@link java.lang.reflect.Field#get(Object)}\r\n-     *\r\n-     * @see java.lang.reflect.Field#get(Object)\r\n-     */\r\n-    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\r\n-        return field.get(this.getObject());\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Sets the last super class to stop appending fields for.\r\n+   * </p>\r\n+   *\r\n+   * @param clazz\r\n+   *            The last super class to stop appending fields for.\r\n+   */\r\n+  public void setUpToClass(Class<?> clazz) {\r\n+    if (clazz != null) {\r\n+      Object object = getObject();\r\n+      if (object != null && clazz.isInstance(object) == false) {\r\n+        throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\r\n+      }\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets whether or not to append static fields.\r\n-     * </p>\r\n-     *\r\n-     * @return Whether or not to append static fields.\r\n-     * @since 2.1\r\n-     */\r\n-    public boolean isAppendStatics() {\r\n-        return this.appendStatics;\r\n+    this.upToClass = clazz;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Gets the String built by this builder.\r\n+   * </p>\r\n+   *\r\n+   * @return the built string\r\n+   */\r\n+  @Override\r\n+  public String toString() {\r\n+    if (this.getObject() == null) {\r\n+      return this.getStyle().getNullText();\r\n     }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets whether or not to append transient fields.\r\n-     * </p>\r\n-     *\r\n-     * @return Whether or not to append transient fields.\r\n-     */\r\n-    public boolean isAppendTransients() {\r\n-        return this.appendTransients;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Append to the <code>toString</code> an <code>Object</code> array.\r\n-     * </p>\r\n-     *\r\n-     * @param array\r\n-     *            the array to add to the <code>toString</code>\r\n-     * @return this\r\n-     */\r\n-    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\r\n-        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets whether or not to append static fields.\r\n-     * </p>\r\n-     *\r\n-     * @param appendStatics\r\n-     *            Whether or not to append static fields.\r\n-     * @since 2.1\r\n-     */\r\n-    public void setAppendStatics(boolean appendStatics) {\r\n-        this.appendStatics = appendStatics;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets whether or not to append transient fields.\r\n-     * </p>\r\n-     *\r\n-     * @param appendTransients\r\n-     *            Whether or not to append transient fields.\r\n-     */\r\n-    public void setAppendTransients(boolean appendTransients) {\r\n-        this.appendTransients = appendTransients;\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the field names to exclude.\r\n-     *\r\n-     * @param excludeFieldNamesParam\r\n-     *            The excludeFieldNames to excluding from toString or <code>null</code>.\r\n-     * @return <code>this</code>\r\n-     */\r\n-    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\r\n-        if (excludeFieldNamesParam == null) {\r\n-            this.excludeFieldNames = null;\r\n-        } else {\r\n-            //clone and remove nulls\r\n-            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\r\n-            Arrays.sort(this.excludeFieldNames);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Sets the last super class to stop appending fields for.\r\n-     * </p>\r\n-     *\r\n-     * @param clazz\r\n-     *            The last super class to stop appending fields for.\r\n-     */\r\n-    public void setUpToClass(Class<?> clazz) {\r\n-        if (clazz != null) {\r\n-            Object object = getObject();\r\n-            if (object != null && clazz.isInstance(object) == false) {\r\n-                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\r\n-            }\r\n-        }\r\n-        this.upToClass = clazz;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Gets the String built by this builder.\r\n-     * </p>\r\n-     *\r\n-     * @return the built string\r\n-     */\r\n-    @Override\r\n-    public String toString() {\r\n-        if (this.getObject() == null) {\r\n-            return this.getStyle().getNullText();\r\n-        }\r\n-        Class<?> clazz = this.getObject().getClass();\r\n-        this.appendFieldsIn(clazz);\r\n-        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\r\n-            clazz = clazz.getSuperclass();\r\n-            this.appendFieldsIn(clazz);\r\n-        }\r\n-        return super.toString();\r\n+    Class<?> clazz = this.getObject().getClass();\r\n+    this.appendFieldsIn(clazz);\r\n+    while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\r\n+      clazz = clazz.getSuperclass();\r\n+      this.appendFieldsIn(clazz);\r\n     }\r\n+    return super.toString();\r\n+  }\r\n \r\n }\r\n",
            "diff_size": 1015
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "99",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/89/ReflectionToStringBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/naturalize/89/ReflectionToStringBuilder.java\nindex 9ba7082e128..ef486fecd56 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/89/ReflectionToStringBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/naturalize/89/ReflectionToStringBuilder.java\n@@ -499,8 +499,8 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n             // Reject static fields.\r\n             return false;\r\n         }\r\n-        if (this.excludeFieldNames != null\r\n-            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n+        if (this.excludeFieldNames != null\n+&& Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n             // Reject fields from the getExcludeFieldNames list.\r\n             return false;\r\n         }\r\n@@ -703,4 +703,4 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n         return super.toString();\r\n     }\r\n \r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "98",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/89/ReflectionToStringBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/codebuff/89/ReflectionToStringBuilder.java\nindex 9ba7082e128..80fb85cb7db 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/89/ReflectionToStringBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/codebuff/89/ReflectionToStringBuilder.java\n@@ -30,17 +30,16 @@\n  * limitations under the License.\r\n  */\r\n \r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n-\r\n-import java.lang.reflect.AccessibleObject;\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Collection;\r\n-import java.util.List;\r\n-\r\n-import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\r\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ArrayUtils;\n import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassUtils;\r\n \r\n /**\r\n@@ -99,7 +98,9 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.ClassU\n  * \r\n  * @since 2.0\r\n  * @version $Id: ReflectionToStringBuilder.java 1200177 2011-11-10 06:14:33Z ggregory $\r\n- */\r\n+ */\n+\n+\n public class ReflectionToStringBuilder extends ToStringBuilder {\r\n \r\n     /**\r\n@@ -123,9 +124,9 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @return the String result\r\n      * @throws IllegalArgumentException\r\n      *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object) {\r\n-        return toString(object, null, false, false, null);\r\n+     */\n+    public static String toString(Object object) {\n+        return toString(object, null, false, false, null);\n     }\r\n \r\n     /**\r\n@@ -155,9 +156,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @return the String result\r\n      * @throws IllegalArgumentException\r\n      *             if the Object or <code>ToStringStyle</code> is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style) {\r\n-        return toString(object, style, false, false, null);\r\n+     */\n+\n+\n+    public static String toString(Object object, ToStringStyle style) {\n+        return toString(object, style, false, false, null);\n     }\r\n \r\n     /**\r\n@@ -193,9 +196,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @return the String result\r\n      * @throws IllegalArgumentException\r\n      *             if the Object is <code>null</code>\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\r\n-        return toString(object, style, outputTransients, false, null);\r\n+     */\n+\n+\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return toString(object, style, outputTransients, false, null);\n     }\r\n \r\n     /**\r\n@@ -239,9 +244,15 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @throws IllegalArgumentException\r\n      *             if the Object is <code>null</code>\r\n      * @since 2.1\r\n-     */\r\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\r\n-        return toString(object, style, outputTransients, outputStatics, null);\r\n+     */\n+\n+\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n+        return toString(object,\n+                        style,\n+                        outputTransients,\n+                        outputStatics,\n+                        null);\n     }\r\n \r\n     /**\r\n@@ -290,12 +301,14 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @throws IllegalArgumentException\r\n      *             if the Object is <code>null</code>\r\n      * @since 2.1\r\n-     */\r\n-    public static <T> String toString(\r\n-            T object, ToStringStyle style, boolean outputTransients,\r\n-            boolean outputStatics, Class<? super T> reflectUpToClass) {\r\n-        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\r\n-                .toString();\r\n+     */\n+\n+\n+    public static <T> String toString(T object,\n+                                      ToStringStyle style,\n+                                      boolean outputTransients,\n+                                      boolean outputStatics, Class<? super T> reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString();\n     }\r\n \r\n     /**\r\n@@ -306,9 +319,12 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param excludeFieldNames\r\n      *            The field names to exclude. Null excludes nothing.\r\n      * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\r\n-        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\r\n+     */\n+\n+\n+    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\n+        return toStringExclude(object,\n+                               toNoNullStringArray(excludeFieldNames));\n     }\r\n \r\n     /**\r\n@@ -319,12 +335,14 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param collection\r\n      *            The collection to convert\r\n      * @return A new array of Strings.\r\n-     */\r\n-    static String[] toNoNullStringArray(Collection<String> collection) {\r\n-        if (collection == null) {\r\n-            return ArrayUtils.EMPTY_STRING_ARRAY;\r\n-        }\r\n-        return toNoNullStringArray(collection.toArray());\r\n+     */\n+\n+\n+    static String[] toNoNullStringArray(Collection<String> collection) {\n+        if (collection == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return toNoNullStringArray(collection.toArray());\n     }\r\n \r\n     /**\r\n@@ -335,15 +353,18 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param array\r\n      *            The array to check\r\n      * @return The given array or a new array without null.\r\n-     */\r\n-    static String[] toNoNullStringArray(Object[] array) {\r\n-        List<String> list = new ArrayList<String>(array.length);\r\n-        for (Object e : array) {\r\n-            if (e != null) {\r\n-                list.add(e.toString());\r\n-            }\r\n-        }\r\n-        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\r\n+     */\n+\n+\n+    static String[] toNoNullStringArray(Object[] array) {\n+        List<String> list = new ArrayList<String>(array.length);\n+\n+        for (Object e : array) {\n+            if (e != null) {\n+                list.add(e.toString());\n+            }\n+        }\n+        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\r\n \r\n \r\n@@ -355,31 +376,36 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param excludeFieldNames\r\n      *            The field names to exclude\r\n      * @return The toString value.\r\n-     */\r\n-    public static String toStringExclude(Object object, String... excludeFieldNames) {\r\n-        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\r\n+     */\n+\n+\n+    public static String toStringExclude(Object object, String... excludeFieldNames) {\n+        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n     }\r\n \r\n     /**\r\n      * Whether or not to append static fields.\r\n-     */\r\n+     */\n+\n+\n     private boolean appendStatics = false;\r\n \r\n     /**\r\n      * Whether or not to append transient fields.\r\n-     */\r\n+     */\n     private boolean appendTransients = false;\r\n \r\n     /**\r\n      * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\r\n      *\r\n      * @since 3.0 this is protected instead of private\r\n-     */\r\n+     */\n+\n     protected String[] excludeFieldNames;\r\n \r\n     /**\r\n      * The last super class to stop appending fields for.\r\n-     */\r\n+     */\n     private Class<?> upToClass = null;\r\n \r\n     /**\r\n@@ -395,9 +421,10 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *            the Object to build a <code>toString</code> for, must not be <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object) {\r\n-        super(object);\r\n+     */\n+\n+    public ReflectionToStringBuilder(Object object) {\n+    super(object);\n     }\r\n \r\n     /**\r\n@@ -415,9 +442,10 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *            the style of the <code>toString</code> to create, may be <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\r\n-        super(object, style);\r\n+     */\n+\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n+    super(object, style);\n     }\r\n \r\n     /**\r\n@@ -441,9 +469,10 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *            the <code>StringBuffer</code> to populate, may be <code>null</code>\r\n      * @throws IllegalArgumentException\r\n      *             if the Object passed in is <code>null</code>\r\n-     */\r\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\r\n-        super(object, style, buffer);\r\n+     */\n+\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+    super(object, style, buffer);\n     }\r\n \r\n     /**\r\n@@ -464,14 +493,13 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param outputStatics\r\n      *            whether to include static fields\r\n      * @since 2.1\r\n-     */\r\n-    public <T> ReflectionToStringBuilder(\r\n-            T object, ToStringStyle style, StringBuffer buffer,\r\n-            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\r\n-        super(object, style, buffer);\r\n-        this.setUpToClass(reflectUpToClass);\r\n-        this.setAppendTransients(outputTransients);\r\n-        this.setAppendStatics(outputStatics);\r\n+     */\n+\n+    public <T> ReflectionToStringBuilder(T object, ToStringStyle style, StringBuffer buffer, Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n+    super(object, style, buffer);\n+    this.setUpToClass(reflectUpToClass);\n+    this.setAppendTransients(outputTransients);\n+    this.setAppendStatics(outputStatics);\n     }\r\n \r\n     /**\r\n@@ -485,26 +513,26 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param field\r\n      *            The Field to test.\r\n      * @return Whether or not to append the given <code>Field</code>.\r\n-     */\r\n-    protected boolean accept(Field field) {\r\n+     */\n+\n+    protected boolean accept(Field field) {\n         if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\r\n-            // Reject field from inner class.\r\n-            return false;\r\n-        }\r\n+            // Reject field from inner class.\n+            return false;\n+        }\n         if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\r\n-            // Reject transient fields.\r\n-            return false;\r\n-        }\r\n+            // Reject transient fields.\n+            return false;\n+        }\n         if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\r\n-            // Reject static fields.\r\n-            return false;\r\n-        }\r\n-        if (this.excludeFieldNames != null\r\n-            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n-            // Reject fields from the getExcludeFieldNames list.\r\n-            return false;\r\n-        }\r\n-        return true;\r\n+            // Reject static fields.\n+            return false;\n+        }\n+        if (this.excludeFieldNames != null && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\r\n+            // Reject fields from the getExcludeFieldNames list.\n+            return false;\n+        }\n+        return true;\n     }\r\n \r\n     /**\r\n@@ -519,38 +547,44 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *\r\n      * @param clazz\r\n      *            The class of object parameter\r\n-     */\r\n-    protected void appendFieldsIn(Class<?> clazz) {\r\n-        if (clazz.isArray()) {\r\n-            this.reflectionAppendArray(this.getObject());\r\n-            return;\r\n-        }\r\n-        Field[] fields = clazz.getDeclaredFields();\r\n-        AccessibleObject.setAccessible(fields, true);\r\n-        for (Field field : fields) {\r\n-            String fieldName = field.getName();\r\n-            if (this.accept(field)) {\r\n+     */\n+\n+\n+    protected void appendFieldsIn(Class<?> clazz) {\n+        if (clazz.isArray()) {\n+            this.reflectionAppendArray(this.getObject());\n+            return;\n+        }\n+        Field[] fields = clazz.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields, true);\n+\n+        for (Field field : fields) {\n+            String fieldName = field.getName();\n+\n+            if (this.accept(field)) {\n                 try {\r\n                     // Warning: Field.get(Object) creates wrappers objects\r\n-                    // for primitive types.\r\n-                    Object fieldValue = this.getValue(field);\r\n-                    this.append(fieldName, fieldValue);\r\n+                    // for primitive types.\n+                    Object fieldValue = this.getValue(field);\n+                    this.append(fieldName, fieldValue);\n                 } catch (IllegalAccessException ex) {\r\n                     //this can't happen. Would get a Security exception\r\n                     // instead\r\n                     //throw a runtime exception in case the impossible\r\n-                    // happens.\r\n-                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\r\n-                }\r\n-            }\r\n-        }\r\n+                    // happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+                }\n+            }\n+        }\n     }\r\n \r\n     /**\r\n      * @return Returns the excludeFieldNames.\r\n-     */\r\n-    public String[] getExcludeFieldNames() {\r\n-        return this.excludeFieldNames.clone();\r\n+     */\n+\n+\n+    public String[] getExcludeFieldNames() {\n+        return this.excludeFieldNames.clone();\n     }\r\n \r\n     /**\r\n@@ -559,9 +593,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * </p>\r\n      *\r\n      * @return The last super class to stop appending fields for.\r\n-     */\r\n-    public Class<?> getUpToClass() {\r\n-        return this.upToClass;\r\n+     */\n+\n+\n+    public Class<?> getUpToClass() {\n+        return this.upToClass;\n     }\r\n \r\n     /**\r\n@@ -579,9 +615,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *             see {@link java.lang.reflect.Field#get(Object)}\r\n      *\r\n      * @see java.lang.reflect.Field#get(Object)\r\n-     */\r\n-    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\r\n-        return field.get(this.getObject());\r\n+     */\n+\n+\n+    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n+        return field.get(this.getObject());\n     }\r\n \r\n     /**\r\n@@ -591,9 +629,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *\r\n      * @return Whether or not to append static fields.\r\n      * @since 2.1\r\n-     */\r\n-    public boolean isAppendStatics() {\r\n-        return this.appendStatics;\r\n+     */\n+\n+\n+    public boolean isAppendStatics() {\n+        return this.appendStatics;\n     }\r\n \r\n     /**\r\n@@ -602,9 +642,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * </p>\r\n      *\r\n      * @return Whether or not to append transient fields.\r\n-     */\r\n-    public boolean isAppendTransients() {\r\n-        return this.appendTransients;\r\n+     */\n+\n+\n+    public boolean isAppendTransients() {\n+        return this.appendTransients;\n     }\r\n \r\n     /**\r\n@@ -615,10 +657,12 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param array\r\n      *            the array to add to the <code>toString</code>\r\n      * @return this\r\n-     */\r\n-    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\r\n-        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\r\n-        return this;\r\n+     */\n+\n+\n+    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n+    this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n+    return this;\n     }\r\n \r\n     /**\r\n@@ -629,9 +673,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param appendStatics\r\n      *            Whether or not to append static fields.\r\n      * @since 2.1\r\n-     */\r\n-    public void setAppendStatics(boolean appendStatics) {\r\n-        this.appendStatics = appendStatics;\r\n+     */\n+\n+\n+    public void setAppendStatics(boolean appendStatics) {\n+    this.appendStatics = appendStatics;\n     }\r\n \r\n     /**\r\n@@ -641,9 +687,11 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *\r\n      * @param appendTransients\r\n      *            Whether or not to append transient fields.\r\n-     */\r\n-    public void setAppendTransients(boolean appendTransients) {\r\n-        this.appendTransients = appendTransients;\r\n+     */\n+\n+\n+    public void setAppendTransients(boolean appendTransients) {\n+    this.appendTransients = appendTransients;\n     }\r\n \r\n     /**\r\n@@ -652,16 +700,18 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * @param excludeFieldNamesParam\r\n      *            The excludeFieldNames to excluding from toString or <code>null</code>.\r\n      * @return <code>this</code>\r\n-     */\r\n-    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\r\n-        if (excludeFieldNamesParam == null) {\r\n-            this.excludeFieldNames = null;\r\n+     */\n+\n+\n+    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\n+        if (excludeFieldNamesParam == null) {\n+            this.excludeFieldNames = null;\n         } else {\r\n-            //clone and remove nulls\r\n-            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\r\n-            Arrays.sort(this.excludeFieldNames);\r\n-        }\r\n-        return this;\r\n+            //clone and remove nulls\n+            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n+            Arrays.sort(this.excludeFieldNames);\n+        }\n+        return this;\n     }\r\n \r\n     /**\r\n@@ -671,15 +721,18 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      *\r\n      * @param clazz\r\n      *            The last super class to stop appending fields for.\r\n-     */\r\n-    public void setUpToClass(Class<?> clazz) {\r\n-        if (clazz != null) {\r\n-            Object object = getObject();\r\n-            if (object != null && clazz.isInstance(object) == false) {\r\n-                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\r\n-            }\r\n-        }\r\n-        this.upToClass = clazz;\r\n+     */\n+\n+\n+    public void setUpToClass(Class<?> clazz) {\n+        if (clazz != null) {\n+            Object object = getObject();\n+\n+            if (object != null && clazz.isInstance(object) == false) {\n+                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n+            }\n+        }\n+        this.upToClass = clazz;\n     }\r\n \r\n     /**\r\n@@ -688,19 +741,21 @@ public class ReflectionToStringBuilder extends ToStringBuilder {\n      * </p>\r\n      *\r\n      * @return the built string\r\n-     */\r\n-    @Override\r\n-    public String toString() {\r\n-        if (this.getObject() == null) {\r\n-            return this.getStyle().getNullText();\r\n-        }\r\n-        Class<?> clazz = this.getObject().getClass();\r\n-        this.appendFieldsIn(clazz);\r\n-        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\r\n-            clazz = clazz.getSuperclass();\r\n-            this.appendFieldsIn(clazz);\r\n-        }\r\n-        return super.toString();\r\n-    }\r\n-\r\n-}\r\n+     */\n+\n+\n+    @Override\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            return this.getStyle().getNullText();\n+        }\n+        Class<?> clazz = this.getObject().getClass();\n+        this.appendFieldsIn(clazz);\n+\n+        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n+            clazz = clazz.getSuperclass();\n+            this.appendFieldsIn(clazz);\n+        }\n+        return super.toString();\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 225
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "99",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "99",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}