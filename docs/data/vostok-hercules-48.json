{
    "project_name": "vostok-hercules",
    "error_id": "48",
    "information": {
        "errors": [
            {
                "line": "166",
                "severity": "warning",
                "message": "Line is longer than 160 characters (found 196).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "            ResponseUtil.badRequest(\n                    httpServerExchange,\n                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n            return;\n        }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "166",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 196).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/48/ReadTimelineHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/48/ReadTimelineHandler.java\nindex 9df791f11c2..f9d54a15d2d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/48/ReadTimelineHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/48/ReadTimelineHandler.java\n@@ -26,172 +26,173 @@ import java.util.Optional;\n \n public class ReadTimelineHandler implements HttpHandler {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(ReadTimelineHandler.class);\n-\n-    private static final TimelineStateReader STATE_READER = new TimelineStateReader();\n-    private static final TimelineByteContentWriter CONTENT_WRITER = new TimelineByteContentWriter();\n-\n-    private static final String REASON_MISSING_PARAM = \"Missing required parameter \";\n-\n-    private static final String PARAM_TIMELINE = \"timeline\";\n-    private static final String PARAM_SHARD_INDEX = \"shardIndex\";\n-    private static final String PARAM_SHARD_COUNT = \"shardCount\";\n-    private static final String PARAM_TAKE = \"take\";\n-    private static final String PARAM_FROM = \"from\";\n-    private static final String PARAM_TO = \"to\";\n-\n-    private final TimelineRepository timelineRepository;\n-    private final TimelineReader timelineReader;\n-    private final AuthManager authManager;\n-    private final int timetrapCountLimit;\n-\n-    public ReadTimelineHandler(TimelineRepository timelineRepository, TimelineReader timelineReader, AuthManager authManager, int timetrapCountLimit) {\n-        this.timelineRepository = timelineRepository;\n-        this.timelineReader = timelineReader;\n-        this.authManager = authManager;\n-        this.timetrapCountLimit = timetrapCountLimit;\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ReadTimelineHandler.class);\n+\n+  private static final TimelineStateReader STATE_READER = new TimelineStateReader();\n+  private static final TimelineByteContentWriter CONTENT_WRITER = new TimelineByteContentWriter();\n+\n+  private static final String REASON_MISSING_PARAM = \"Missing required parameter \";\n+\n+  private static final String PARAM_TIMELINE = \"timeline\";\n+  private static final String PARAM_SHARD_INDEX = \"shardIndex\";\n+  private static final String PARAM_SHARD_COUNT = \"shardCount\";\n+  private static final String PARAM_TAKE = \"take\";\n+  private static final String PARAM_FROM = \"from\";\n+  private static final String PARAM_TO = \"to\";\n+\n+  private final TimelineRepository timelineRepository;\n+  private final TimelineReader timelineReader;\n+  private final AuthManager authManager;\n+  private final int timetrapCountLimit;\n+\n+  public ReadTimelineHandler(TimelineRepository timelineRepository, TimelineReader timelineReader, AuthManager authManager, int timetrapCountLimit) {\n+    this.timelineRepository = timelineRepository;\n+    this.timelineReader = timelineReader;\n+    this.authManager = authManager;\n+    this.timetrapCountLimit = timetrapCountLimit;\n+  }\n+\n+  public static boolean isTimetrapCountLimitExceeded(long from, long to, long timetrapSize, int timetrapCountLimit) {\n+    return (to - from) >= TimeUtil.millisToTicks(timetrapCountLimit * timetrapSize);\n+  }\n+\n+  @Override\n+  public void handleRequest(HttpServerExchange httpServerExchange) throws Exception {\n+\n+    Optional<Integer> optionalContentLength = ExchangeUtil.extractContentLength(httpServerExchange);\n+    if (!optionalContentLength.isPresent()) {\n+      ResponseUtil.lengthRequired(httpServerExchange);\n+      return;\n     }\n-\n-    public static boolean isTimetrapCountLimitExceeded(long from, long to, long timetrapSize, int timetrapCountLimit) {\n-        return (to - from) >= TimeUtil.millisToTicks(timetrapCountLimit * timetrapSize);\n+    if (optionalContentLength.get() < 0) {\n+      ResponseUtil.badRequest(httpServerExchange);\n+      return;\n     }\n \n-    @Override\n-    public void handleRequest(HttpServerExchange httpServerExchange) throws Exception {\n-\n-        Optional<Integer> optionalContentLength = ExchangeUtil.extractContentLength(httpServerExchange);\n-        if (!optionalContentLength.isPresent()) {\n-            ResponseUtil.lengthRequired(httpServerExchange);\n-            return;\n-        }\n-        if (optionalContentLength.get() < 0) {\n-            ResponseUtil.badRequest(httpServerExchange);\n-            return;\n-        }\n-\n-        Optional<String> optionalApiKey = ExchangeUtil.extractHeaderValue(httpServerExchange, \"apiKey\");\n-        if (!optionalApiKey.isPresent()) {\n-            ResponseUtil.unauthorized(httpServerExchange);\n-            return;\n-        }\n-        String apiKey = optionalApiKey.get();\n-\n-        Optional<String> optionalTimelineName = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_TIMELINE);\n-        if (!optionalTimelineName.isPresent()) {\n-            ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_TIMELINE);\n-            return;\n-        }\n+    Optional<String> optionalApiKey = ExchangeUtil.extractHeaderValue(httpServerExchange, \"apiKey\");\n+    if (!optionalApiKey.isPresent()) {\n+      ResponseUtil.unauthorized(httpServerExchange);\n+      return;\n+    }\n+    String apiKey = optionalApiKey.get();\n \n-        AuthResult authResult = authManager.authRead(apiKey, optionalTimelineName.get());\n+    Optional<String> optionalTimelineName = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_TIMELINE);\n+    if (!optionalTimelineName.isPresent()) {\n+      ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_TIMELINE);\n+      return;\n+    }\n \n-        if (!authResult.isSuccess()) {\n-            if (authResult.isUnknown()) {\n-                ResponseUtil.unauthorized(httpServerExchange);\n-                return;\n-            }\n-            ResponseUtil.forbidden(httpServerExchange);\n-            return;\n-        }\n+    AuthResult authResult = authManager.authRead(apiKey, optionalTimelineName.get());\n \n-        Optional<String> optionalShardIndex = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_SHARD_INDEX);\n-        if (!optionalShardIndex.isPresent()) {\n-            ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_SHARD_INDEX);\n-            return;\n-        }\n+    if (!authResult.isSuccess()) {\n+      if (authResult.isUnknown()) {\n+        ResponseUtil.unauthorized(httpServerExchange);\n+        return;\n+      }\n+      ResponseUtil.forbidden(httpServerExchange);\n+      return;\n+    }\n \n-        Result<Integer, String> shardIndex = Parsers.parseInteger(optionalShardIndex.get());\n-        if (!shardIndex.isOk()) {\n-            ResponseUtil.badRequest(httpServerExchange, shardIndex.getError() + \" in parameter \" + PARAM_SHARD_INDEX);\n-            return;\n-        }\n+    Optional<String> optionalShardIndex = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_SHARD_INDEX);\n+    if (!optionalShardIndex.isPresent()) {\n+      ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_SHARD_INDEX);\n+      return;\n+    }\n \n-        Optional<String> optionalShardCount = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_SHARD_COUNT);\n-        if (!optionalShardCount.isPresent()) {\n-            ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_SHARD_COUNT);\n-            return;\n-        }\n+    Result<Integer, String> shardIndex = Parsers.parseInteger(optionalShardIndex.get());\n+    if (!shardIndex.isOk()) {\n+      ResponseUtil.badRequest(httpServerExchange, shardIndex.getError() + \" in parameter \" + PARAM_SHARD_INDEX);\n+      return;\n+    }\n \n-        Result<Integer, String> shardCount = Parsers.parseInteger(optionalShardCount.get());\n-        if (!shardCount.isOk()) {\n-            ResponseUtil.badRequest(httpServerExchange, shardCount.getError() + \" in parameter \" + PARAM_SHARD_COUNT);\n-            return;\n-        }\n+    Optional<String> optionalShardCount = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_SHARD_COUNT);\n+    if (!optionalShardCount.isPresent()) {\n+      ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_SHARD_COUNT);\n+      return;\n+    }\n \n-        Optional<String> optionalTake = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_TAKE);\n-        if (!optionalTake.isPresent()) {\n-            ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_TAKE);\n-            return;\n-        }\n+    Result<Integer, String> shardCount = Parsers.parseInteger(optionalShardCount.get());\n+    if (!shardCount.isOk()) {\n+      ResponseUtil.badRequest(httpServerExchange, shardCount.getError() + \" in parameter \" + PARAM_SHARD_COUNT);\n+      return;\n+    }\n \n-        Result<Integer, String> take = Parsers.parseInteger(optionalTake.get());\n-        if (!take.isOk()) {\n-            ResponseUtil.badRequest(httpServerExchange, take.getError() + \" in parameter \" + PARAM_TAKE);\n-            return;\n-        }\n+    Optional<String> optionalTake = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_TAKE);\n+    if (!optionalTake.isPresent()) {\n+      ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_TAKE);\n+      return;\n+    }\n \n-        Optional<String> optionalFrom = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_FROM);\n-        if (!optionalFrom.isPresent()) {\n-            ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_FROM);\n-            return;\n-        }\n+    Result<Integer, String> take = Parsers.parseInteger(optionalTake.get());\n+    if (!take.isOk()) {\n+      ResponseUtil.badRequest(httpServerExchange, take.getError() + \" in parameter \" + PARAM_TAKE);\n+      return;\n+    }\n \n-        Result<Long, String> from = Parsers.parseLong(optionalFrom.get());\n-        if (!from.isOk()) {\n-            ResponseUtil.badRequest(httpServerExchange, take.getError() + \" in parameter \" + PARAM_FROM);\n-            return;\n-        }\n+    Optional<String> optionalFrom = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_FROM);\n+    if (!optionalFrom.isPresent()) {\n+      ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_FROM);\n+      return;\n+    }\n \n-        Optional<String> optionalTo = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_TO);\n-        if (!optionalTo.isPresent()) {\n-            ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_TO);\n-            return;\n-        }\n+    Result<Long, String> from = Parsers.parseLong(optionalFrom.get());\n+    if (!from.isOk()) {\n+      ResponseUtil.badRequest(httpServerExchange, take.getError() + \" in parameter \" + PARAM_FROM);\n+      return;\n+    }\n \n-        Result<Long, String> to = Parsers.parseLong(optionalTo.get());\n-        if (!to.isOk()) {\n-            ResponseUtil.badRequest(httpServerExchange, take.getError() + \" in parameter \" + PARAM_TO);\n-            return;\n-        }\n+    Optional<String> optionalTo = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_TO);\n+    if (!optionalTo.isPresent()) {\n+      ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_TO);\n+      return;\n+    }\n \n-        Optional<Timeline> optionalTimeline = timelineRepository.read(optionalTimelineName.get());\n-        if (!optionalTimeline.isPresent()) {\n-            ResponseUtil.notFound(httpServerExchange);\n-            return;\n-        }\n+    Result<Long, String> to = Parsers.parseLong(optionalTo.get());\n+    if (!to.isOk()) {\n+      ResponseUtil.badRequest(httpServerExchange, take.getError() + \" in parameter \" + PARAM_TO);\n+      return;\n+    }\n \n-        Timeline timeline = optionalTimeline.get();\n-        if (isTimetrapCountLimitExceeded(from.get(), to.get(), timeline.getTimetrapSize(), timetrapCountLimit)) {\n-            ResponseUtil.badRequest(\n-                    httpServerExchange,\n-                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n-            return;\n-        }\n+    Optional<Timeline> optionalTimeline = timelineRepository.read(optionalTimelineName.get());\n+    if (!optionalTimeline.isPresent()) {\n+      ResponseUtil.notFound(httpServerExchange);\n+      return;\n+    }\n \n-        httpServerExchange.getRequestReceiver().receiveFullBytes((exchange, message) -> {\n-            exchange.dispatch(() -> {\n-                try {\n-                    TimelineState readState = STATE_READER.read(new Decoder(message));\n-\n-                    TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n-                            readState,\n-                            shardIndex.get(),\n-                            shardCount.get(),\n-                            take.get(),\n-                            from.get(),\n-                            to.get());\n-\n-                    ByteArrayOutputStream stream = new ByteArrayOutputStream();\n-                    Encoder encoder = new Encoder(stream);\n-                    CONTENT_WRITER.write(encoder, byteContent);\n-\n-                    exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n-                } catch (Exception e) {\n-                    LOGGER.error(\"Error on processing request\", e);\n-                    ResponseUtil.internalServerError(exchange);\n-                } finally {\n-                    exchange.endExchange();\n-                }\n-            });\n-        });\n+    Timeline timeline = optionalTimeline.get();\n+    if (isTimetrapCountLimitExceeded(from.get(), to.get(), timeline.getTimetrapSize(), timetrapCountLimit)) {\n+      ResponseUtil.badRequest(\n+        httpServerExchange,\n+        \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" +\n+          (to.get() - from.get()) + \" ticks\");\n+      return;\n     }\n+\n+    httpServerExchange.getRequestReceiver().receiveFullBytes((exchange, message) -> {\n+      exchange.dispatch(() -> {\n+        try {\n+          TimelineState readState = STATE_READER.read(new Decoder(message));\n+\n+          TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n+            readState,\n+            shardIndex.get(),\n+            shardCount.get(),\n+            take.get(),\n+            from.get(),\n+            to.get());\n+\n+          ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+          Encoder encoder = new Encoder(stream);\n+          CONTENT_WRITER.write(encoder, byteContent);\n+\n+          exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n+        } catch (Exception e) {\n+          LOGGER.error(\"Error on processing request\", e);\n+          ResponseUtil.internalServerError(exchange);\n+        } finally {\n+          exchange.endExchange();\n+        }\n+      });\n+    });\n+  }\n }\n",
            "diff_size": 197
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "166",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 196).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/48/ReadTimelineHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/48/ReadTimelineHandler.java\nindex 9df791f11c2..13579b00574 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/48/ReadTimelineHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/48/ReadTimelineHandler.java\n@@ -173,7 +173,7 @@ public class ReadTimelineHandler implements HttpHandler {\n                     TimelineState readState = STATE_READER.read(new Decoder(message));\n \n                     TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n-                            readState,\n+readState,\n                             shardIndex.get(),\n                             shardCount.get(),\n                             take.get(),\n@@ -194,4 +194,4 @@ public class ReadTimelineHandler implements HttpHandler {\n             });\n         });\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "169",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 193).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/48/ReadTimelineHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/48/ReadTimelineHandler.java\nindex 9df791f11c2..3b785ea0cbe 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/48/ReadTimelineHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/48/ReadTimelineHandler.java\n@@ -19,33 +19,33 @@ import ru.kontur.vostok.hercules.undertow.util.ResponseUtil;\n import ru.kontur.vostok.hercules.util.functional.Result;\n import ru.kontur.vostok.hercules.util.parsing.Parsers;\n import ru.kontur.vostok.hercules.util.time.TimeUtil;\n-\n import java.io.ByteArrayOutputStream;\n import java.nio.ByteBuffer;\n import java.util.Optional;\n \n+\n public class ReadTimelineHandler implements HttpHandler {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(ReadTimelineHandler.class);\n-\n     private static final TimelineStateReader STATE_READER = new TimelineStateReader();\n     private static final TimelineByteContentWriter CONTENT_WRITER = new TimelineByteContentWriter();\n-\n     private static final String REASON_MISSING_PARAM = \"Missing required parameter \";\n-\n     private static final String PARAM_TIMELINE = \"timeline\";\n     private static final String PARAM_SHARD_INDEX = \"shardIndex\";\n     private static final String PARAM_SHARD_COUNT = \"shardCount\";\n     private static final String PARAM_TAKE = \"take\";\n     private static final String PARAM_FROM = \"from\";\n     private static final String PARAM_TO = \"to\";\n-\n     private final TimelineRepository timelineRepository;\n     private final TimelineReader timelineReader;\n     private final AuthManager authManager;\n     private final int timetrapCountLimit;\n \n-    public ReadTimelineHandler(TimelineRepository timelineRepository, TimelineReader timelineReader, AuthManager authManager, int timetrapCountLimit) {\n+    public ReadTimelineHandler(\n+        TimelineRepository timelineRepository,\n+        TimelineReader timelineReader,\n+        AuthManager authManager, int timetrapCountLimit\n+    ) {\n         this.timelineRepository = timelineRepository;\n         this.timelineReader = timelineReader;\n         this.authManager = authManager;\n@@ -58,7 +58,6 @@ public class ReadTimelineHandler implements HttpHandler {\n \n     @Override\n     public void handleRequest(HttpServerExchange httpServerExchange) throws Exception {\n-\n         Optional<Integer> optionalContentLength = ExchangeUtil.extractContentLength(httpServerExchange);\n         if (!optionalContentLength.isPresent()) {\n             ResponseUtil.lengthRequired(httpServerExchange);\n@@ -74,8 +73,8 @@ public class ReadTimelineHandler implements HttpHandler {\n             ResponseUtil.unauthorized(httpServerExchange);\n             return;\n         }\n-        String apiKey = optionalApiKey.get();\n \n+        String apiKey = optionalApiKey.get();\n         Optional<String> optionalTimelineName = ExchangeUtil.extractQueryParam(httpServerExchange, PARAM_TIMELINE);\n         if (!optionalTimelineName.isPresent()) {\n             ResponseUtil.badRequest(httpServerExchange, REASON_MISSING_PARAM + PARAM_TIMELINE);\n@@ -83,12 +82,12 @@ public class ReadTimelineHandler implements HttpHandler {\n         }\n \n         AuthResult authResult = authManager.authRead(apiKey, optionalTimelineName.get());\n-\n         if (!authResult.isSuccess()) {\n             if (authResult.isUnknown()) {\n                 ResponseUtil.unauthorized(httpServerExchange);\n                 return;\n             }\n+\n             ResponseUtil.forbidden(httpServerExchange);\n             return;\n         }\n@@ -101,7 +100,10 @@ public class ReadTimelineHandler implements HttpHandler {\n \n         Result<Integer, String> shardIndex = Parsers.parseInteger(optionalShardIndex.get());\n         if (!shardIndex.isOk()) {\n-            ResponseUtil.badRequest(httpServerExchange, shardIndex.getError() + \" in parameter \" + PARAM_SHARD_INDEX);\n+            ResponseUtil.badRequest(\n+                httpServerExchange,\n+                shardIndex.getError() + \" in parameter \" + PARAM_SHARD_INDEX\n+            );\n             return;\n         }\n \n@@ -113,7 +115,10 @@ public class ReadTimelineHandler implements HttpHandler {\n \n         Result<Integer, String> shardCount = Parsers.parseInteger(optionalShardCount.get());\n         if (!shardCount.isOk()) {\n-            ResponseUtil.badRequest(httpServerExchange, shardCount.getError() + \" in parameter \" + PARAM_SHARD_COUNT);\n+            ResponseUtil.badRequest(\n+                httpServerExchange,\n+                shardCount.getError() + \" in parameter \" + PARAM_SHARD_COUNT\n+            );\n             return;\n         }\n \n@@ -161,9 +166,8 @@ public class ReadTimelineHandler implements HttpHandler {\n \n         Timeline timeline = optionalTimeline.get();\n         if (isTimetrapCountLimitExceeded(from.get(), to.get(), timeline.getTimetrapSize(), timetrapCountLimit)) {\n-            ResponseUtil.badRequest(\n-                    httpServerExchange,\n-                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n+            ResponseUtil.badRequest(httpServerExchange, \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \"\n+            + (to.get() - from.get()) + \" ticks\");\n             return;\n         }\n \n@@ -171,19 +175,18 @@ public class ReadTimelineHandler implements HttpHandler {\n             exchange.dispatch(() -> {\n                 try {\n                     TimelineState readState = STATE_READER.read(new Decoder(message));\n-\n-                    TimelineByteContent byteContent = timelineReader.readTimeline(optionalTimeline.get(),\n-                            readState,\n-                            shardIndex.get(),\n-                            shardCount.get(),\n-                            take.get(),\n-                            from.get(),\n-                            to.get());\n-\n+                    TimelineByteContent byteContent = timelineReader.readTimeline(\n+                        optionalTimeline.get(),\n+                        readState,\n+                        shardIndex.get(),\n+                        shardCount.get(),\n+                        take.get(),\n+                        from.get(),\n+                        to.get()\n+            );\n                     ByteArrayOutputStream stream = new ByteArrayOutputStream();\n                     Encoder encoder = new Encoder(stream);\n                     CONTENT_WRITER.write(encoder, byteContent);\n-\n                     exchange.getResponseSender().send(ByteBuffer.wrap(stream.toByteArray()));\n                 } catch (Exception e) {\n                     LOGGER.error(\"Error on processing request\", e);\n@@ -194,4 +197,4 @@ public class ReadTimelineHandler implements HttpHandler {\n             });\n         });\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 38
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "166",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 196).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "166",
                    "column": "62",
                    "severity": "warning",
                    "message": "'+' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "166",
                    "column": "106",
                    "severity": "warning",
                    "message": "'*' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "166",
                    "column": "106",
                    "severity": "warning",
                    "message": "'*' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "167",
                    "column": "42",
                    "severity": "warning",
                    "message": "'+' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "167",
                    "column": "42",
                    "severity": "warning",
                    "message": "'+' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "167",
                    "column": "67",
                    "severity": "warning",
                    "message": "'+' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "167",
                    "column": "67",
                    "severity": "warning",
                    "message": "'+' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "167",
                    "column": "77",
                    "severity": "warning",
                    "message": "'-' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "167",
                    "column": "77",
                    "severity": "warning",
                    "message": "'-' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/48/ReadTimelineHandler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/48/ReadTimelineHandler.java\nindex 9df791f11c2..27c2ee9a415 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/48/ReadTimelineHandler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/48/ReadTimelineHandler.java\n@@ -163,7 +163,9 @@ public class ReadTimelineHandler implements HttpHandler {\n         if (isTimetrapCountLimitExceeded(from.get(), to.get(), timeline.getTimetrapSize(), timetrapCountLimit)) {\n             ResponseUtil.badRequest(\n                     httpServerExchange,\n-                    \"Time interval should not exceeded \" + TimeUtil.millisToTicks(timetrapCountLimit * timeline.getTimetrapSize()) + \" ticks, but requested \" + (to.get() - from.get()) + \" ticks\");\n+                        \"Time interval should not exceeded \" +TimeUtil . millisToTicks(timetrapCountLimit*timeline.\n+                    getTimetrapSize ( ) )+\" ticks, but requested \"+(to.get()-from\n+                    . get()) + \" ticks\");\n             return;\n         }\n \n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}