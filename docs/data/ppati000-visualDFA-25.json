{
    "project_name": "ppati000-visualDFA",
    "error_id": "25",
    "information": {
        "errors": [
            {
                "line": "414",
                "column": "38",
                "severity": "warning",
                "message": "'=' should be on a new line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
            }
        ]
    },
    "source_code": "\n                if (nextElementaryBlock == null) {\n                    newAnalysisState =\n                            finishBasicBlock(prevBasicBlock, prevOutState, prevAnalysisState, visitedBasicBlocks);\n                } else {\n                    E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "414",
                    "column": "38",
                    "severity": "warning",
                    "message": "'=' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "129",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "398",
                    "column": "28",
                    "severity": "warning",
                    "message": "'=' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/25/DFAExecution.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/intellij/25/DFAExecution.java\nindex bf37683eef0..b95bad596c4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/25/DFAExecution.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/intellij/25/DFAExecution.java\n@@ -13,520 +13,504 @@ import soot.toolkits.graph.Block;\n /**\n  * A {@code DFAExecution} precalculates a {@code DataFlowAnalysis} and provides the intermediate analysis-steps.\n  *\n- * @param <E>\n- *        the type of {@code LatticeElement} used in this {@code DFAExecution}\n- * \n+ * @param <E> the type of {@code LatticeElement} used in this {@code DFAExecution}\n  * @author Sebastian Rauch\n  */\n public class DFAExecution<E extends LatticeElement> {\n \n-    private final Worklist initialWorklist;\n-\n-    private final DFADirection direction;\n-\n-    private final DataFlowAnalysis<E> dfa;\n-\n-    private final ControlFlowGraph cfg;\n-\n-    private List<AnalysisState<E>> analysisStates = new ArrayList<>();\n-    private List<Integer> blockSteps = new ArrayList<>();\n-\n-    private int currentElementaryStep = 0;\n-    private int currentBlockStep = 0;\n-\n-    /**\n-     * Creates a {@code DFAExecution} from a given {@code DFAFactory}, an initial {@code Worklist} and a\n-     * {@code SimpleBlockGraph}.\n-     * \n-     * @param dfaFactory\n-     *        a {@code DFAFactory} from which a {@code DataFlowAnalysis} will be generated\n-     * @param initialWorklist\n-     *        an (empty) worklist to use in this {@code DFAExecution}\n-     * @param blockGraph\n-     *        the {@code SimpleBlockGraph} the analysis is based on\n-     * @param precalcController\n-     *        a {@code DFAPrecalcController} to control the precalculation of this {@code DFAExecution}\n-     * \n-     * @throws IllegalArgumentException\n-     *         if any of {@code initialWorklist} or {@code blockGraph} is {@code null}\n-     * \n-     * @throws NullPointerException\n-     *         if {@code dfaFactory} is {@code null}\n-     */\n-    public DFAExecution(DFAFactory<E> dfaFactory, Worklist initialWorklist, SimpleBlockGraph blockGraph,\n-            DFAPrecalcController precalcController) {\n-        if (initialWorklist == null) {\n-            throw new IllegalArgumentException(\"initialWorklist must not be null\");\n-        }\n-\n-        if (blockGraph == null) {\n-            throw new IllegalArgumentException(\"blockGraph must not be null\");\n-        }\n+  private final Worklist initialWorklist;\n \n-        this.initialWorklist = initialWorklist;\n-        this.direction = dfaFactory.getDirection();\n+  private final DFADirection direction;\n \n-        dfa = dfaFactory.getAnalysis(blockGraph);\n+  private final DataFlowAnalysis<E> dfa;\n \n-        this.cfg = new ControlFlowGraph(blockGraph);\n+  private final ControlFlowGraph cfg;\n \n-        precalc(precalcController);\n-    }\n-\n-    private DFAExecution(DFAExecution<E> copyFrom) {\n-        this.initialWorklist = copyFrom.initialWorklist;\n-        this.direction = copyFrom.getDirection();\n-        this.dfa = copyFrom.dfa;\n-        this.cfg = copyFrom.getCFG();\n+  private List<AnalysisState<E>> analysisStates = new ArrayList<>();\n+  private List<Integer> blockSteps = new ArrayList<>();\n \n-        this.analysisStates = copyFrom.analysisStates;\n-        this.blockSteps = copyFrom.blockSteps;\n+  private int currentElementaryStep = 0;\n+  private int currentBlockStep = 0;\n \n-        setCurrentElementaryStep(copyFrom.getCurrentElementaryStep());\n-        setCurrentBlockStep(copyFrom.getCurrentBlockStep());\n+  /**\n+   * Creates a {@code DFAExecution} from a given {@code DFAFactory}, an initial {@code Worklist} and a\n+   * {@code SimpleBlockGraph}.\n+   *\n+   * @param dfaFactory        a {@code DFAFactory} from which a {@code DataFlowAnalysis} will be generated\n+   * @param initialWorklist   an (empty) worklist to use in this {@code DFAExecution}\n+   * @param blockGraph        the {@code SimpleBlockGraph} the analysis is based on\n+   * @param precalcController a {@code DFAPrecalcController} to control the precalculation of this {@code DFAExecution}\n+   * @throws IllegalArgumentException if any of {@code initialWorklist} or {@code blockGraph} is {@code null}\n+   * @throws NullPointerException     if {@code dfaFactory} is {@code null}\n+   */\n+  public DFAExecution(DFAFactory<E> dfaFactory, Worklist initialWorklist, SimpleBlockGraph blockGraph,\n+                      DFAPrecalcController precalcController) {\n+    if (initialWorklist == null) {\n+      throw new IllegalArgumentException(\"initialWorklist must not be null\");\n     }\n \n-    /**\n-     * Returns the {@code ControlFlowGraph} that is used to execute the dataflow-analysis.\n-     * \n-     * @return the {@code ControlFlowGraph} used to execute the dataflow-analysis\n-     */\n-    public ControlFlowGraph getCFG() {\n-        return cfg;\n+    if (blockGraph == null) {\n+      throw new IllegalArgumentException(\"blockGraph must not be null\");\n     }\n \n-    /**\n-     * Returns the direction of the {@code DataFlowAnalysis} that is executed.\n-     * \n-     * @return the direction of the {@code DataFlowAnalysis} that is executed\n-     */\n-    public DFADirection getDirection() {\n-        return direction;\n+    this.initialWorklist = initialWorklist;\n+    this.direction = dfaFactory.getDirection();\n+\n+    dfa = dfaFactory.getAnalysis(blockGraph);\n+\n+    this.cfg = new ControlFlowGraph(blockGraph);\n+\n+    precalc(precalcController);\n+  }\n+\n+  private DFAExecution(DFAExecution<E> copyFrom) {\n+    this.initialWorklist = copyFrom.initialWorklist;\n+    this.direction = copyFrom.getDirection();\n+    this.dfa = copyFrom.dfa;\n+    this.cfg = copyFrom.getCFG();\n+\n+    this.analysisStates = copyFrom.analysisStates;\n+    this.blockSteps = copyFrom.blockSteps;\n+\n+    setCurrentElementaryStep(copyFrom.getCurrentElementaryStep());\n+    setCurrentBlockStep(copyFrom.getCurrentBlockStep());\n+  }\n+\n+  /**\n+   * Returns the {@code ControlFlowGraph} that is used to execute the dataflow-analysis.\n+   *\n+   * @return the {@code ControlFlowGraph} used to execute the dataflow-analysis\n+   */\n+  public ControlFlowGraph getCFG() {\n+    return cfg;\n+  }\n+\n+  /**\n+   * Returns the direction of the {@code DataFlowAnalysis} that is executed.\n+   *\n+   * @return the direction of the {@code DataFlowAnalysis} that is executed\n+   */\n+  public DFADirection getDirection() {\n+    return direction;\n+  }\n+\n+  /**\n+   * Returns the total number of elementary-steps.\n+   *\n+   * @return the total number of elementary-steps\n+   */\n+  public int getTotalElementarySteps() {\n+    return analysisStates.size();\n+  }\n+\n+  /**\n+   * Returns the total number of block-steps.\n+   *\n+   * @return the total number of block-steps\n+   */\n+  public int getTotalBlockSteps() {\n+    return blockSteps.size();\n+  }\n+\n+  /**\n+   * Returns the current elementary-step.\n+   *\n+   * @return the current elementary-step, always in range {@code [0, ..., getTotalElementarySteps() - 1]}\n+   */\n+  public int getCurrentElementaryStep() {\n+    return currentElementaryStep;\n+  }\n+\n+  /**\n+   * Sets the current elementary-step. The current block-step is updated to be consistent with the current\n+   * elementary-step.\n+   *\n+   * @param elementaryStep the elementary-step to set as current elementary-step\n+   * @throws IllegalArgumentException if {@code elementaryStep} is not in range {@code [0, ..., getTotalElementarySteps() - 1]}\n+   */\n+  public void setCurrentElementaryStep(int elementaryStep) {\n+    if (elementaryStep < 0 || elementaryStep >= getTotalElementarySteps()) {\n+      throw new IndexOutOfBoundsException(\"invalid elementaryStep: \" + elementaryStep);\n     }\n \n-    /**\n-     * Returns the total number of elementary-steps.\n-     * \n-     * @return the total number of elementary-steps\n-     */\n-    public int getTotalElementarySteps() {\n-        return analysisStates.size();\n-    }\n+    currentElementaryStep = elementaryStep;\n+    int idx = Collections.binarySearch(blockSteps, currentElementaryStep);\n \n-    /**\n-     * Returns the total number of block-steps.\n-     * \n-     * @return the total number of block-steps\n-     */\n-    public int getTotalBlockSteps() {\n-        return blockSteps.size();\n+    if (idx < 0) { // currentElementaryStep has not been found\n+      idx = -(idx + 1) - 1; // this gives the correct index of the corresponding block-step\n     }\n-\n-    /**\n-     * Returns the current elementary-step.\n-     * \n-     * @return the current elementary-step, always in range {@code [0, ..., getTotalElementarySteps() - 1]}\n-     */\n-    public int getCurrentElementaryStep() {\n-        return currentElementaryStep;\n+    currentBlockStep = idx;\n+  }\n+\n+  /**\n+   * Returns the current block-step.\n+   *\n+   * @return the current block-step, always in range {@code [0, ..., getTotalBlockSteps() - 1]}\n+   */\n+  public int getCurrentBlockStep() {\n+    return currentBlockStep;\n+  }\n+\n+  /**\n+   * Sets the current block-step. The current elementary-step is updated to be consistent with the current block-step.\n+   *\n+   * @param blockStep the block-step to set as current block-step\n+   * @throws IllegalArgumentException if {@code blockStep} is not in range {@code [0, ..., getTotalBlockSteps() - 1]}\n+   */\n+  public void setCurrentBlockStep(int blockStep) {\n+    if (blockStep < 0 || blockStep >= getTotalBlockSteps()) {\n+      throw new IndexOutOfBoundsException(\"invalid blockStep: \" + blockStep);\n     }\n \n-    /**\n-     * Sets the current elementary-step. The current block-step is updated to be consistent with the current\n-     * elementary-step.\n-     * \n-     * @param elementaryStep\n-     *        the elementary-step to set as current elementary-step\n-     * \n-     * @throws IllegalArgumentException\n-     *         if {@code elementaryStep} is not in range {@code [0, ..., getTotalElementarySteps() - 1]}\n-     */\n-    public void setCurrentElementaryStep(int elementaryStep) {\n-        if (elementaryStep < 0 || elementaryStep >= getTotalElementarySteps()) {\n-            throw new IndexOutOfBoundsException(\"invalid elementaryStep: \" + elementaryStep);\n-        }\n-\n-        currentElementaryStep = elementaryStep;\n-        int idx = Collections.binarySearch(blockSteps, currentElementaryStep);\n-\n-        if (idx < 0) { // currentElementaryStep has not been found\n-            idx = -(idx + 1) - 1; // this gives the correct index of the corresponding block-step\n-        }\n-        currentBlockStep = idx;\n+    currentBlockStep = blockStep;\n+    currentElementaryStep = blockSteps.get(blockStep);\n+  }\n+\n+  /**\n+   * Increases the current elementary-step (by 1) if possible.\n+   *\n+   * @return {@code true} if there was a next elementary-step, {@code false} otherwise\n+   */\n+  public boolean nextElementaryStep() {\n+    int nextStep = getCurrentElementaryStep() + 1;\n+    if (nextStep < getTotalElementarySteps()) {\n+      setCurrentElementaryStep(nextStep);\n+      return true;\n     }\n \n-    /**\n-     * Returns the current block-step.\n-     * \n-     * @return the current block-step, always in range {@code [0, ..., getTotalBlockSteps() - 1]}\n-     */\n-    public int getCurrentBlockStep() {\n-        return currentBlockStep;\n+    return false;\n+  }\n+\n+  /**\n+   * Decreases the current elementary-step by 1 if possible.\n+   *\n+   * @return {@code true} if there was a next elementary-step, {@code false} otherwise\n+   */\n+  public boolean previousElementaryStep() {\n+    int prevStep = getCurrentElementaryStep() - 1;\n+    if (prevStep >= 0) {\n+      setCurrentElementaryStep(prevStep);\n+      return true;\n     }\n \n-    /**\n-     * Sets the current block-step. The current elementary-step is updated to be consistent with the current block-step.\n-     * \n-     * @param blockStep\n-     *        the block-step to set as current block-step\n-     * \n-     * @throws IllegalArgumentException\n-     *         if {@code blockStep} is not in range {@code [0, ..., getTotalBlockSteps() - 1]}\n-     */\n-    public void setCurrentBlockStep(int blockStep) {\n-        if (blockStep < 0 || blockStep >= getTotalBlockSteps()) {\n-            throw new IndexOutOfBoundsException(\"invalid blockStep: \" + blockStep);\n-        }\n-\n-        currentBlockStep = blockStep;\n-        currentElementaryStep = blockSteps.get(blockStep);\n+    return false;\n+  }\n+\n+  /**\n+   * Advances the current block-step (by 1) if possible.\n+   *\n+   * @return {@code true} if there was a next block-step, {@code false} otherwise\n+   */\n+  public boolean nextBlockStep() {\n+    int nextBlockStep = getCurrentBlockStep() + 1;\n+    if (nextBlockStep < getTotalBlockSteps()) {\n+      setCurrentBlockStep(nextBlockStep);\n+      return true;\n     }\n \n-    /**\n-     * Increases the current elementary-step (by 1) if possible.\n-     * \n-     * @return {@code true} if there was a next elementary-step, {@code false} otherwise\n-     */\n-    public boolean nextElementaryStep() {\n-        int nextStep = getCurrentElementaryStep() + 1;\n-        if (nextStep < getTotalElementarySteps()) {\n-            setCurrentElementaryStep(nextStep);\n-            return true;\n-        }\n-\n-        return false;\n+    return false;\n+  }\n+\n+  /**\n+   * Decreases the current block-step by 1 if possible.\n+   *\n+   * @return {@code true} if there was a next block-step, {@code false} otherwise\n+   */\n+  public boolean previousBlockStep() {\n+    int currentBlockStep = getCurrentBlockStep() - 1;\n+    if (currentBlockStep >= 0) {\n+      setCurrentBlockStep(currentBlockStep);\n+      return true;\n     }\n \n-    /**\n-     * Decreases the current elementary-step by 1 if possible.\n-     * \n-     * @return {@code true} if there was a next elementary-step, {@code false} otherwise\n-     */\n-    public boolean previousElementaryStep() {\n-        int prevStep = getCurrentElementaryStep() - 1;\n-        if (prevStep >= 0) {\n-            setCurrentElementaryStep(prevStep);\n-            return true;\n-        }\n-\n-        return false;\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the current elementary-step is at {@code ElementaryBlock} that has a breakpoint.\n+   *\n+   * @return {@code true} if the {@code ElementaryBlock} of the current elementary-step has a breakpoint,\n+   * {@code false} otherwise\n+   */\n+  public boolean isAtBreakpoint() {\n+    AnalysisState<? extends LatticeElement> currentState = getCurrentAnalysisState();\n+    BasicBlock bBlock = currentState.getCurrentBasicBlock();\n+\n+    int eBlockIdx = currentState.getCurrentElementaryBlockIndex();\n+    if (bBlock == null || eBlockIdx < 0 || eBlockIdx >= bBlock.getElementaryBlockCount()) {\n+      return false;\n     }\n \n-    /**\n-     * Advances the current block-step (by 1) if possible.\n-     * \n-     * @return {@code true} if there was a next block-step, {@code false} otherwise\n-     */\n-    public boolean nextBlockStep() {\n-        int nextBlockStep = getCurrentBlockStep() + 1;\n-        if (nextBlockStep < getTotalBlockSteps()) {\n-            setCurrentBlockStep(nextBlockStep);\n-            return true;\n-        }\n-\n-        return false;\n+    return bBlock.getElementaryBlock(eBlockIdx).hasBreakpoint();\n+  }\n+\n+  /**\n+   * Returns the current {@code AnalysisState}, i. e. the state of the analysis at the current elementary-step.\n+   *\n+   * @return the current {@code AnalysisState}\n+   */\n+  public AnalysisState<E> getCurrentAnalysisState() {\n+    return analysisStates.get(currentElementaryStep);\n+  }\n+\n+  /**\n+   * Creates a <em>shallow copy</em> of this {@code DFAExecution}. The returned copy shares the {@code AnalysisState}s\n+   * with the original but can have different current block- or elementary-steps.\n+   */\n+  @Override\n+  public DFAExecution<E> clone() {\n+    return new DFAExecution<E>(this);\n+  }\n+\n+  private void precalc(DFAPrecalcController precalcCtrl) {\n+    Map<Block, BlockState<E>> initialStates = dfa.getInitialStates();\n+\n+    BasicBlock startBlock = getStartBlock();\n+    if (startBlock == null) {\n+      throw new DFAException(\"there is no start block\");\n     }\n \n-    /**\n-     * Decreases the current block-step by 1 if possible.\n-     * \n-     * @return {@code true} if there was a next block-step, {@code false} otherwise\n-     */\n-    public boolean previousBlockStep() {\n-        int currentBlockStep = getCurrentBlockStep() - 1;\n-        if (currentBlockStep >= 0) {\n-            setCurrentBlockStep(currentBlockStep);\n-            return true;\n-        }\n-\n-        return false;\n-    }\n+    AnalysisState<E> initialState = new AnalysisState<E>(initialWorklist, startBlock, -1);\n \n-    /**\n-     * Returns whether the current elementary-step is at {@code ElementaryBlock} that has a breakpoint.\n-     * \n-     * @return {@code true} if the {@code ElementaryBlock} of the current elementary-step has a breakpoint,\n-     *         {@code false} otherwise\n-     */\n-    public boolean isAtBreakpoint() {\n-        AnalysisState<? extends LatticeElement> currentState = getCurrentAnalysisState();\n-        BasicBlock bBlock = currentState.getCurrentBasicBlock();\n-\n-        int eBlockIdx = currentState.getCurrentElementaryBlockIndex();\n-        if (bBlock == null || eBlockIdx < 0 || eBlockIdx >= bBlock.getElementaryBlockCount()) {\n-            return false;\n-        }\n+    List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\n+    for (BasicBlock bBlock : basicBlocks) {\n+      Block sootBlock = bBlock.getSootBlock();\n+      BlockState<E> state = initialStates.get(sootBlock);\n \n-        return bBlock.getElementaryBlock(eBlockIdx).hasBreakpoint();\n-    }\n+      LogicalColor lColor = bBlock.equals(startBlock) ? LogicalColor.CURRENT : LogicalColor.NOT_VISITED;\n+      initialState.setBlockState(bBlock, state);\n+      initialState.setColor(bBlock, lColor);\n \n-    /**\n-     * Returns the current {@code AnalysisState}, i. e. the state of the analysis at the current elementary-step.\n-     * \n-     * @return the current {@code AnalysisState}\n-     */\n-    public AnalysisState<E> getCurrentAnalysisState() {\n-        return analysisStates.get(currentElementaryStep);\n-    }\n+      // set all in- and out-states to null for the elementary-blocks\n+      List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\n+      BlockState<E> nullState = new BlockState<E>(null, null);\n+      for (ElementaryBlock eBlock : elementaryBlocks) {\n+        initialState.setBlockState(eBlock, nullState);\n+      }\n \n-    /**\n-     * Creates a <em>shallow copy</em> of this {@code DFAExecution}. The returned copy shares the {@code AnalysisState}s\n-     * with the original but can have different current block- or elementary-steps.\n-     */\n-    @Override\n-    public DFAExecution<E> clone() {\n-        return new DFAExecution<E>(this);\n     }\n \n-    private void precalc(DFAPrecalcController precalcCtrl) {\n-        Map<Block, BlockState<E>> initialStates = dfa.getInitialStates();\n-\n-        BasicBlock startBlock = getStartBlock();\n-        if (startBlock == null) {\n-            throw new DFAException(\"there is no start block\");\n-        }\n-\n-        AnalysisState<E> initialState = new AnalysisState<E>(initialWorklist, startBlock, -1);\n-\n-        List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\n-        for (BasicBlock bBlock : basicBlocks) {\n-            Block sootBlock = bBlock.getSootBlock();\n-            BlockState<E> state = initialStates.get(sootBlock);\n+    analysisStates.add(initialState);\n+\n+    // elementary step 0 is always a block step\n+    blockSteps.add(0);\n+\n+    iterateToFixpoint(initialState, precalcCtrl);\n+  }\n+\n+  private void iterateToFixpoint(AnalysisState<E> initialState, DFAPrecalcController precalcCtrl) {\n+    Set<BasicBlock> visitedBasicBlocks = new HashSet<BasicBlock>();\n+    visitedBasicBlocks.add(getStartBlock());\n+\n+    int elementaryStep = 1;\n+    AnalysisState<E> prevAnalysisState = initialState;\n+\n+    while (true) {\n+      switch (precalcCtrl.getPrecalcState()) {\n+        case CALCULATING:\n+          break; // break switch\n+        case COMPLETED:\n+          return;\n+        case PAUSED:\n+          try {\n+            Thread.sleep(precalcCtrl.getWaitTime());\n+          } catch (InterruptedException e) {\n+            e.printStackTrace();\n+          }\n+          continue;\n+        case STOPPED:\n+          precalcCtrl.setResult(this, false);\n+          return;\n+        default:\n+          throw new IllegalStateException(\"unknown precalc state: \" + precalcCtrl.getPrecalcState());\n+      }\n \n-            LogicalColor lColor = bBlock.equals(startBlock) ? LogicalColor.CURRENT : LogicalColor.NOT_VISITED;\n-            initialState.setBlockState(bBlock, state);\n-            initialState.setColor(bBlock, lColor);\n+      BasicBlock prevBasicBlock = prevAnalysisState.getCurrentBasicBlock();\n \n-            // set all in- and out-states to null for the elementary-blocks\n-            List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\n-            BlockState<E> nullState = new BlockState<E>(null, null);\n-            for (ElementaryBlock eBlock : elementaryBlocks) {\n-                initialState.setBlockState(eBlock, nullState);\n-            }\n+      AnalysisState<E> newAnalysisState = null;\n+      Worklist prevWorklist = prevAnalysisState.getWorklist();\n+      if (prevBasicBlock == null) {\n+        // no basic block currently selected, this begins a new basic block step (or completes calculation)\n \n+        if (prevWorklist.isEmpty()) {\n+          // we are at a fixpoint\n+          precalcCtrl.setResult(this, true);\n+          return;\n         }\n \n-        analysisStates.add(initialState);\n+        Worklist newWorklist = prevWorklist.clone();\n+        BasicBlock newBasicBlock = newWorklist.poll();\n+        visitedBasicBlocks.add(newBasicBlock);\n \n-        // elementary step 0 is always a block step\n-        blockSteps.add(0);\n+        newAnalysisState = newState(prevAnalysisState, newWorklist, newBasicBlock, -1);\n \n-        iterateToFixpoint(initialState, precalcCtrl);\n-    }\n+        // join predecessors out-states\n+        List<BasicBlock> preds = getPredecessors(newBasicBlock);\n+        Set<E> predOutStates = new HashSet<E>();\n \n-    private void iterateToFixpoint(AnalysisState<E> initialState, DFAPrecalcController precalcCtrl) {\n-        Set<BasicBlock> visitedBasicBlocks = new HashSet<BasicBlock>();\n-        visitedBasicBlocks.add(getStartBlock());\n-\n-        int elementaryStep = 1;\n-        AnalysisState<E> prevAnalysisState = initialState;\n-\n-        while (true) {\n-            switch (precalcCtrl.getPrecalcState()) {\n-            case CALCULATING:\n-                break; // break switch\n-            case COMPLETED:\n-                return;\n-            case PAUSED:\n-                try {\n-                    Thread.sleep(precalcCtrl.getWaitTime());\n-                } catch (InterruptedException e) {\n-                    e.printStackTrace();\n-                }\n-                continue;\n-            case STOPPED:\n-                precalcCtrl.setResult(this, false);\n-                return;\n-            default:\n-                throw new IllegalStateException(\"unknown precalc state: \" + precalcCtrl.getPrecalcState());\n-            }\n-\n-            BasicBlock prevBasicBlock = prevAnalysisState.getCurrentBasicBlock();\n-\n-            AnalysisState<E> newAnalysisState = null;\n-            Worklist prevWorklist = prevAnalysisState.getWorklist();\n-            if (prevBasicBlock == null) {\n-                // no basic block currently selected, this begins a new basic block step (or completes calculation)\n-\n-                if (prevWorklist.isEmpty()) {\n-                    // we are at a fixpoint\n-                    precalcCtrl.setResult(this, true);\n-                    return;\n-                }\n-\n-                Worklist newWorklist = prevWorklist.clone();\n-                BasicBlock newBasicBlock = newWorklist.poll();\n-                visitedBasicBlocks.add(newBasicBlock);\n-\n-                newAnalysisState = newState(prevAnalysisState, newWorklist, newBasicBlock, -1);\n-\n-                // join predecessors out-states\n-                List<BasicBlock> preds = getPredecessors(newBasicBlock);\n-                Set<E> predOutStates = new HashSet<E>();\n-\n-                for (BasicBlock p : preds) {\n-                    E predOutState = prevAnalysisState.getBlockState(p).getOutState();\n-                    predOutStates.add(predOutState);\n-                }\n-\n-                E outStatesJoin = dfa.join(predOutStates);\n-\n-                BlockState<E> prevBlockState = prevAnalysisState.getBlockState(newBasicBlock);\n-                BlockState<E> newBlockState = new BlockState<E>(outStatesJoin, prevBlockState.getOutState());\n-                newAnalysisState.setBlockState(newBasicBlock, newBlockState);\n-\n-                updateColors(prevAnalysisState, newAnalysisState, visitedBasicBlocks);\n-\n-                analysisStates.add(newAnalysisState);\n-\n-                // this begins a new block step\n-                blockSteps.add(elementaryStep++);\n-                prevAnalysisState = newAnalysisState;\n-                continue;\n-            }\n-\n-            // prevBasicBlock is not null (so this is not a new block step)\n-            int eBlockIdx = prevAnalysisState.getCurrentElementaryBlockIndex();\n-            if (prevBasicBlock.getElementaryBlockCount() == 0) {\n-                // handle empty basic block [e. g. artificial end block]\n-                E inState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n-                newAnalysisState = finishBasicBlock(prevBasicBlock, inState, prevAnalysisState, visitedBasicBlocks);\n-            } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount()) {\n-                // handle non-empty basic block\n-                E prevOutState;\n-                ElementaryBlock nextElementaryBlock;\n-                if (eBlockIdx < 0) {\n-                    // first elementary block\n-                    prevOutState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n-                    nextElementaryBlock = getElementaryBlock(prevBasicBlock, 0);\n-                } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount() - 1) {\n-                    // some elementary block that is not the first or last in the basic block\n-                    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n-                    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n-                    nextElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx + 1);\n-                } else {\n-                    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n-                    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n-                    nextElementaryBlock = null;\n-                }\n-\n-                if (nextElementaryBlock == null) {\n-                    newAnalysisState =\n-                            finishBasicBlock(prevBasicBlock, prevOutState, prevAnalysisState, visitedBasicBlocks);\n-                } else {\n-                    E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\n-                    BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\n-                    newAnalysisState = newState(prevAnalysisState, prevWorklist.clone(), prevBasicBlock, ++eBlockIdx);\n-                    newAnalysisState.setBlockState(nextElementaryBlock, nextBlockState);\n-                }\n-            }\n-\n-            analysisStates.add(newAnalysisState);\n-            prevAnalysisState = newAnalysisState;\n-            ++elementaryStep;\n+        for (BasicBlock p : preds) {\n+          E predOutState = prevAnalysisState.getBlockState(p).getOutState();\n+          predOutStates.add(predOutState);\n         }\n-    }\n \n-    private BasicBlock getStartBlock() {\n-        switch (getDirection()) {\n-        case FORWARD:\n-            return cfg.getStartBlock();\n-        case BACKWARD:\n-            return cfg.getEndBlock();\n-        default:\n-            throw new IllegalStateException(\"unknown direction: \" + getDirection());\n+        E outStatesJoin = dfa.join(predOutStates);\n+\n+        BlockState<E> prevBlockState = prevAnalysisState.getBlockState(newBasicBlock);\n+        BlockState<E> newBlockState = new BlockState<E>(outStatesJoin, prevBlockState.getOutState());\n+        newAnalysisState.setBlockState(newBasicBlock, newBlockState);\n+\n+        updateColors(prevAnalysisState, newAnalysisState, visitedBasicBlocks);\n+\n+        analysisStates.add(newAnalysisState);\n+\n+        // this begins a new block step\n+        blockSteps.add(elementaryStep++);\n+        prevAnalysisState = newAnalysisState;\n+        continue;\n+      }\n+\n+      // prevBasicBlock is not null (so this is not a new block step)\n+      int eBlockIdx = prevAnalysisState.getCurrentElementaryBlockIndex();\n+      if (prevBasicBlock.getElementaryBlockCount() == 0) {\n+        // handle empty basic block [e. g. artificial end block]\n+        E inState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n+        newAnalysisState = finishBasicBlock(prevBasicBlock, inState, prevAnalysisState, visitedBasicBlocks);\n+      } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount()) {\n+        // handle non-empty basic block\n+        E prevOutState;\n+        ElementaryBlock nextElementaryBlock;\n+        if (eBlockIdx < 0) {\n+          // first elementary block\n+          prevOutState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n+          nextElementaryBlock = getElementaryBlock(prevBasicBlock, 0);\n+        } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount() - 1) {\n+          // some elementary block that is not the first or last in the basic block\n+          ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n+          prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n+          nextElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx + 1);\n+        } else {\n+          ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n+          prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n+          nextElementaryBlock = null;\n         }\n-    }\n \n-    private List<BasicBlock> getPredecessors(BasicBlock bBlock) {\n-        switch (direction) {\n-        case FORWARD:\n-            return cfg.getPredecessors(bBlock);\n-        case BACKWARD:\n-            return cfg.getSuccessors(bBlock);\n-        default:\n-            throw new IllegalStateException();\n+        if (nextElementaryBlock == null) {\n+          newAnalysisState =\n+              finishBasicBlock(prevBasicBlock, prevOutState, prevAnalysisState, visitedBasicBlocks);\n+        } else {\n+          E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\n+          BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\n+          newAnalysisState = newState(prevAnalysisState, prevWorklist.clone(), prevBasicBlock, ++eBlockIdx);\n+          newAnalysisState.setBlockState(nextElementaryBlock, nextBlockState);\n         }\n-    }\n+      }\n \n-    private List<BasicBlock> getSuccessors(BasicBlock bBlock) {\n-        switch (direction) {\n-        case FORWARD:\n-            return cfg.getSuccessors(bBlock);\n-        case BACKWARD:\n-            return cfg.getPredecessors(bBlock);\n-        default:\n-            throw new IllegalStateException(\"unknown direction: \" + getDirection());\n-        }\n+      analysisStates.add(newAnalysisState);\n+      prevAnalysisState = newAnalysisState;\n+      ++elementaryStep;\n     }\n-\n-    private AnalysisState<E> newState(AnalysisState<E> state, Worklist newWorklist, BasicBlock currentBBlock,\n-            int eBlockIdx) {\n-        Map<AbstractBlock, BlockState<E>> stateMap = new HashMap<AbstractBlock, BlockState<E>>(state.getStateMap());\n-        Map<BasicBlock, LogicalColor> colorMap = new HashMap<BasicBlock, LogicalColor>(state.getColorMap());\n-\n-        AnalysisState<E> newState = new AnalysisState<E>(newWorklist, currentBBlock, eBlockIdx, stateMap, colorMap);\n-        newState.setCurrentElementaryBlockIndex(eBlockIdx);\n-        return newState;\n+  }\n+\n+  private BasicBlock getStartBlock() {\n+    switch (getDirection()) {\n+      case FORWARD:\n+        return cfg.getStartBlock();\n+      case BACKWARD:\n+        return cfg.getEndBlock();\n+      default:\n+        throw new IllegalStateException(\"unknown direction: \" + getDirection());\n     }\n-\n-    /*\n-     * updates the color-mapping in newState according to prevState and the worklist and current BasicBlock of newState\n-     */\n-    private void updateColors(AnalysisState<E> prevState, AnalysisState<E> newState, Set<BasicBlock> visited) {\n-        List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\n-        Worklist newWorklist = newState.getWorklist();\n-\n-        for (BasicBlock basicBlock : basicBlocks) {\n-            LogicalColor newColor;\n-            if (basicBlock.equals(newState.getCurrentBasicBlock())) {\n-                newColor = LogicalColor.CURRENT;\n-            } else if (newWorklist.contains(basicBlock)) {\n-                newColor = LogicalColor.ON_WORKLIST;\n-            } else {\n-                if (visited.contains(basicBlock)) {\n-                    newColor = LogicalColor.VISITED_NOT_ON_WORKLIST;\n-                } else {\n-                    newColor = LogicalColor.NOT_VISITED;\n-                }\n-            }\n-            newState.setColor(basicBlock, newColor);\n+  }\n+\n+  private List<BasicBlock> getPredecessors(BasicBlock bBlock) {\n+    switch (direction) {\n+      case FORWARD:\n+        return cfg.getPredecessors(bBlock);\n+      case BACKWARD:\n+        return cfg.getSuccessors(bBlock);\n+      default:\n+        throw new IllegalStateException();\n+    }\n+  }\n+\n+  private List<BasicBlock> getSuccessors(BasicBlock bBlock) {\n+    switch (direction) {\n+      case FORWARD:\n+        return cfg.getSuccessors(bBlock);\n+      case BACKWARD:\n+        return cfg.getPredecessors(bBlock);\n+      default:\n+        throw new IllegalStateException(\"unknown direction: \" + getDirection());\n+    }\n+  }\n+\n+  private AnalysisState<E> newState(AnalysisState<E> state, Worklist newWorklist, BasicBlock currentBBlock,\n+                                    int eBlockIdx) {\n+    Map<AbstractBlock, BlockState<E>> stateMap = new HashMap<AbstractBlock, BlockState<E>>(state.getStateMap());\n+    Map<BasicBlock, LogicalColor> colorMap = new HashMap<BasicBlock, LogicalColor>(state.getColorMap());\n+\n+    AnalysisState<E> newState = new AnalysisState<E>(newWorklist, currentBBlock, eBlockIdx, stateMap, colorMap);\n+    newState.setCurrentElementaryBlockIndex(eBlockIdx);\n+    return newState;\n+  }\n+\n+  /*\n+   * updates the color-mapping in newState according to prevState and the worklist and current BasicBlock of newState\n+   */\n+  private void updateColors(AnalysisState<E> prevState, AnalysisState<E> newState, Set<BasicBlock> visited) {\n+    List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\n+    Worklist newWorklist = newState.getWorklist();\n+\n+    for (BasicBlock basicBlock : basicBlocks) {\n+      LogicalColor newColor;\n+      if (basicBlock.equals(newState.getCurrentBasicBlock())) {\n+        newColor = LogicalColor.CURRENT;\n+      } else if (newWorklist.contains(basicBlock)) {\n+        newColor = LogicalColor.ON_WORKLIST;\n+      } else {\n+        if (visited.contains(basicBlock)) {\n+          newColor = LogicalColor.VISITED_NOT_ON_WORKLIST;\n+        } else {\n+          newColor = LogicalColor.NOT_VISITED;\n         }\n+      }\n+      newState.setColor(basicBlock, newColor);\n     }\n+  }\n \n-    private AnalysisState<E> finishBasicBlock(BasicBlock currentBBlock, E outState, AnalysisState<E> prevAnalysisState,\n-            Set<BasicBlock> visited) {\n-        Worklist newWorklist = prevAnalysisState.getWorklist().clone();\n-        BlockState<E> prevBlockState = prevAnalysisState.getBlockState(currentBBlock);\n-\n-        List<BasicBlock> successors = getSuccessors(currentBBlock);\n-        E prevOutState = prevBlockState.getOutState();\n-\n-        boolean outStateChanged = !outState.equals(prevOutState);\n-        for (BasicBlock bSucc : successors) {\n-            if (outStateChanged || !visited.contains(bSucc)) {\n-                newWorklist.add(bSucc);\n-            }\n-        }\n+  private AnalysisState<E> finishBasicBlock(BasicBlock currentBBlock, E outState, AnalysisState<E> prevAnalysisState,\n+                                            Set<BasicBlock> visited) {\n+    Worklist newWorklist = prevAnalysisState.getWorklist().clone();\n+    BlockState<E> prevBlockState = prevAnalysisState.getBlockState(currentBBlock);\n \n-        AnalysisState<E> newAnalysisState = newState(prevAnalysisState, newWorklist, null, -1);\n-        BlockState<E> newBlockState = new BlockState<E>(prevBlockState.getInState(), outState);\n-        newAnalysisState.setBlockState(currentBBlock, newBlockState);\n+    List<BasicBlock> successors = getSuccessors(currentBBlock);\n+    E prevOutState = prevBlockState.getOutState();\n \n-        updateColors(prevAnalysisState, newAnalysisState, visited);\n-        return newAnalysisState;\n+    boolean outStateChanged = !outState.equals(prevOutState);\n+    for (BasicBlock bSucc : successors) {\n+      if (outStateChanged || !visited.contains(bSucc)) {\n+        newWorklist.add(bSucc);\n+      }\n     }\n \n-    private ElementaryBlock getElementaryBlock(BasicBlock bBlock, int eBlockIdx) {\n-        List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\n-        switch (direction) {\n-        case FORWARD:\n-            return elementaryBlocks.get(eBlockIdx);\n-        case BACKWARD:\n-            return elementaryBlocks.get(bBlock.getElementaryBlockCount() - 1 - eBlockIdx);\n-        default:\n-            throw new IllegalStateException(\"unknown direction: \" + getDirection());\n-        }\n+    AnalysisState<E> newAnalysisState = newState(prevAnalysisState, newWorklist, null, -1);\n+    BlockState<E> newBlockState = new BlockState<E>(prevBlockState.getInState(), outState);\n+    newAnalysisState.setBlockState(currentBBlock, newBlockState);\n+\n+    updateColors(prevAnalysisState, newAnalysisState, visited);\n+    return newAnalysisState;\n+  }\n+\n+  private ElementaryBlock getElementaryBlock(BasicBlock bBlock, int eBlockIdx) {\n+    List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\n+    switch (direction) {\n+      case FORWARD:\n+        return elementaryBlocks.get(eBlockIdx);\n+      case BACKWARD:\n+        return elementaryBlocks.get(bBlock.getElementaryBlockCount() - 1 - eBlockIdx);\n+      default:\n+        throw new IllegalStateException(\"unknown direction: \" + getDirection());\n     }\n+  }\n \n }\n",
            "diff_size": 677
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "61",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "282",
                    "column": "27",
                    "severity": "warning",
                    "message": "'||' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "363",
                    "column": "26",
                    "severity": "warning",
                    "message": "'catch' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "410",
                    "column": "46",
                    "severity": "warning",
                    "message": "'++' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "418",
                    "column": "15",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "431",
                    "column": "7",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "440",
                    "column": "3",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "454",
                    "column": "7",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "469",
                    "column": "15",
                    "severity": "warning",
                    "message": "'++' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceAfterCheck"
                },
                {
                    "line": "519",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 126).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "537",
                    "column": "15",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "544",
                    "column": "3",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "550",
                    "column": "7",
                    "severity": "warning",
                    "message": "'if' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "565",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/25/DFAExecution.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/codebuff/25/DFAExecution.java\nindex bf37683eef0..9e0ee7e1d19 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/errored/1/25/DFAExecution.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/ppati000-visualDFA/codebuff/25/DFAExecution.java\n@@ -7,7 +7,6 @@ import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n import soot.toolkits.graph.Block;\n \n /**\n@@ -18,6 +17,8 @@ import soot.toolkits.graph.Block;\n  * \n  * @author Sebastian Rauch\n  */\n+\n+\n public class DFAExecution<E extends LatticeElement> {\n \n     private final Worklist initialWorklist;\n@@ -29,9 +30,11 @@ public class DFAExecution<E extends LatticeElement> {\n     private final ControlFlowGraph cfg;\n \n     private List<AnalysisState<E>> analysisStates = new ArrayList<>();\n+\n     private List<Integer> blockSteps = new ArrayList<>();\n \n     private int currentElementaryStep = 0;\n+\n     private int currentBlockStep = 0;\n \n     /**\n@@ -53,8 +56,9 @@ public class DFAExecution<E extends LatticeElement> {\n      * @throws NullPointerException\n      *         if {@code dfaFactory} is {@code null}\n      */\n-    public DFAExecution(DFAFactory<E> dfaFactory, Worklist initialWorklist, SimpleBlockGraph blockGraph,\n-            DFAPrecalcController precalcController) {\n+\n+\n+    public DFAExecution(DFAFactory<E> dfaFactory, Worklist initialWorklist, SimpleBlockGraph blockGraph, DFAPrecalcController precalcController) {\n         if (initialWorklist == null) {\n             throw new IllegalArgumentException(\"initialWorklist must not be null\");\n         }\n@@ -65,23 +69,19 @@ public class DFAExecution<E extends LatticeElement> {\n \n         this.initialWorklist = initialWorklist;\n         this.direction = dfaFactory.getDirection();\n-\n         dfa = dfaFactory.getAnalysis(blockGraph);\n-\n         this.cfg = new ControlFlowGraph(blockGraph);\n-\n         precalc(precalcController);\n     }\n \n+\n     private DFAExecution(DFAExecution<E> copyFrom) {\n         this.initialWorklist = copyFrom.initialWorklist;\n         this.direction = copyFrom.getDirection();\n         this.dfa = copyFrom.dfa;\n         this.cfg = copyFrom.getCFG();\n-\n         this.analysisStates = copyFrom.analysisStates;\n         this.blockSteps = copyFrom.blockSteps;\n-\n         setCurrentElementaryStep(copyFrom.getCurrentElementaryStep());\n         setCurrentBlockStep(copyFrom.getCurrentBlockStep());\n     }\n@@ -91,6 +91,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return the {@code ControlFlowGraph} used to execute the dataflow-analysis\n      */\n+\n+\n     public ControlFlowGraph getCFG() {\n         return cfg;\n     }\n@@ -100,6 +102,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return the direction of the {@code DataFlowAnalysis} that is executed\n      */\n+\n+\n     public DFADirection getDirection() {\n         return direction;\n     }\n@@ -109,6 +113,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return the total number of elementary-steps\n      */\n+\n+\n     public int getTotalElementarySteps() {\n         return analysisStates.size();\n     }\n@@ -118,6 +124,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return the total number of block-steps\n      */\n+\n+\n     public int getTotalBlockSteps() {\n         return blockSteps.size();\n     }\n@@ -127,6 +135,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return the current elementary-step, always in range {@code [0, ..., getTotalElementarySteps() - 1]}\n      */\n+\n+\n     public int getCurrentElementaryStep() {\n         return currentElementaryStep;\n     }\n@@ -141,17 +151,20 @@ public class DFAExecution<E extends LatticeElement> {\n      * @throws IllegalArgumentException\n      *         if {@code elementaryStep} is not in range {@code [0, ..., getTotalElementarySteps() - 1]}\n      */\n+\n+\n     public void setCurrentElementaryStep(int elementaryStep) {\n         if (elementaryStep < 0 || elementaryStep >= getTotalElementarySteps()) {\n             throw new IndexOutOfBoundsException(\"invalid elementaryStep: \" + elementaryStep);\n         }\n \n         currentElementaryStep = elementaryStep;\n-        int idx = Collections.binarySearch(blockSteps, currentElementaryStep);\n \n+        int idx = Collections.binarySearch(blockSteps, currentElementaryStep);\n         if (idx < 0) { // currentElementaryStep has not been found\n             idx = -(idx + 1) - 1; // this gives the correct index of the corresponding block-step\n         }\n+\n         currentBlockStep = idx;\n     }\n \n@@ -160,6 +173,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return the current block-step, always in range {@code [0, ..., getTotalBlockSteps() - 1]}\n      */\n+\n+\n     public int getCurrentBlockStep() {\n         return currentBlockStep;\n     }\n@@ -173,6 +188,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * @throws IllegalArgumentException\n      *         if {@code blockStep} is not in range {@code [0, ..., getTotalBlockSteps() - 1]}\n      */\n+\n+\n     public void setCurrentBlockStep(int blockStep) {\n         if (blockStep < 0 || blockStep >= getTotalBlockSteps()) {\n             throw new IndexOutOfBoundsException(\"invalid blockStep: \" + blockStep);\n@@ -187,6 +204,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return {@code true} if there was a next elementary-step, {@code false} otherwise\n      */\n+\n+\n     public boolean nextElementaryStep() {\n         int nextStep = getCurrentElementaryStep() + 1;\n         if (nextStep < getTotalElementarySteps()) {\n@@ -202,6 +221,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return {@code true} if there was a next elementary-step, {@code false} otherwise\n      */\n+\n+\n     public boolean previousElementaryStep() {\n         int prevStep = getCurrentElementaryStep() - 1;\n         if (prevStep >= 0) {\n@@ -217,6 +238,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return {@code true} if there was a next block-step, {@code false} otherwise\n      */\n+\n+\n     public boolean nextBlockStep() {\n         int nextBlockStep = getCurrentBlockStep() + 1;\n         if (nextBlockStep < getTotalBlockSteps()) {\n@@ -232,6 +255,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return {@code true} if there was a next block-step, {@code false} otherwise\n      */\n+\n+\n     public boolean previousBlockStep() {\n         int currentBlockStep = getCurrentBlockStep() - 1;\n         if (currentBlockStep >= 0) {\n@@ -248,12 +273,13 @@ public class DFAExecution<E extends LatticeElement> {\n      * @return {@code true} if the {@code ElementaryBlock} of the current elementary-step has a breakpoint,\n      *         {@code false} otherwise\n      */\n+\n+\n     public boolean isAtBreakpoint() {\n         AnalysisState<? extends LatticeElement> currentState = getCurrentAnalysisState();\n         BasicBlock bBlock = currentState.getCurrentBasicBlock();\n-\n         int eBlockIdx = currentState.getCurrentElementaryBlockIndex();\n-        if (bBlock == null || eBlockIdx < 0 || eBlockIdx >= bBlock.getElementaryBlockCount()) {\n+        if (bBlock == null|| eBlockIdx < 0 || eBlockIdx >= bBlock.getElementaryBlockCount()) {\n             return false;\n         }\n \n@@ -265,6 +291,8 @@ public class DFAExecution<E extends LatticeElement> {\n      * \n      * @return the current {@code AnalysisState}\n      */\n+\n+\n     public AnalysisState<E> getCurrentAnalysisState() {\n         return analysisStates.get(currentElementaryStep);\n     }\n@@ -273,26 +301,25 @@ public class DFAExecution<E extends LatticeElement> {\n      * Creates a <em>shallow copy</em> of this {@code DFAExecution}. The returned copy shares the {@code AnalysisState}s\n      * with the original but can have different current block- or elementary-steps.\n      */\n+\n     @Override\n     public DFAExecution<E> clone() {\n         return new DFAExecution<E>(this);\n     }\n \n+\n     private void precalc(DFAPrecalcController precalcCtrl) {\n         Map<Block, BlockState<E>> initialStates = dfa.getInitialStates();\n-\n         BasicBlock startBlock = getStartBlock();\n         if (startBlock == null) {\n             throw new DFAException(\"there is no start block\");\n         }\n \n         AnalysisState<E> initialState = new AnalysisState<E>(initialWorklist, startBlock, -1);\n-\n         List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\n         for (BasicBlock bBlock : basicBlocks) {\n             Block sootBlock = bBlock.getSootBlock();\n             BlockState<E> state = initialStates.get(sootBlock);\n-\n             LogicalColor lColor = bBlock.equals(startBlock) ? LogicalColor.CURRENT : LogicalColor.NOT_VISITED;\n             initialState.setBlockState(bBlock, state);\n             initialState.setColor(bBlock, lColor);\n@@ -303,51 +330,56 @@ public class DFAExecution<E extends LatticeElement> {\n             for (ElementaryBlock eBlock : elementaryBlocks) {\n                 initialState.setBlockState(eBlock, nullState);\n             }\n-\n         }\n \n         analysisStates.add(initialState);\n \n         // elementary step 0 is always a block step\n         blockSteps.add(0);\n-\n         iterateToFixpoint(initialState, precalcCtrl);\n     }\n \n+\n     private void iterateToFixpoint(AnalysisState<E> initialState, DFAPrecalcController precalcCtrl) {\n         Set<BasicBlock> visitedBasicBlocks = new HashSet<BasicBlock>();\n         visitedBasicBlocks.add(getStartBlock());\n \n         int elementaryStep = 1;\n         AnalysisState<E> prevAnalysisState = initialState;\n-\n         while (true) {\n-            switch (precalcCtrl.getPrecalcState()) {\n-            case CALCULATING:\n+            switch(precalcCtrl.getPrecalcState()) {\n+                case CALCULATING:\n                 break; // break switch\n-            case COMPLETED:\n+\n+                                                  case COMPLETED:\n                 return;\n-            case PAUSED:\n+\n+                                                  case PAUSED:\n                 try {\n                     Thread.sleep(precalcCtrl.getWaitTime());\n-                } catch (InterruptedException e) {\n+                }\n+\n+\n+                    catch(InterruptedException e) {\n                     e.printStackTrace();\n                 }\n+\n                 continue;\n-            case STOPPED:\n+\n+                                                  case STOPPED:\n                 precalcCtrl.setResult(this, false);\n                 return;\n-            default:\n+\n+                                                  default:\n                 throw new IllegalStateException(\"unknown precalc state: \" + precalcCtrl.getPrecalcState());\n-            }\n \n-            BasicBlock prevBasicBlock = prevAnalysisState.getCurrentBasicBlock();\n+}\n \n+            BasicBlock prevBasicBlock = prevAnalysisState.getCurrentBasicBlock();\n             AnalysisState<E> newAnalysisState = null;\n             Worklist prevWorklist = prevAnalysisState.getWorklist();\n             if (prevBasicBlock == null) {\n                 // no basic block currently selected, this begins a new basic block step (or completes calculation)\n-\n                 if (prevWorklist.isEmpty()) {\n                     // we are at a fixpoint\n                     precalcCtrl.setResult(this, true);\n@@ -357,114 +389,136 @@ public class DFAExecution<E extends LatticeElement> {\n                 Worklist newWorklist = prevWorklist.clone();\n                 BasicBlock newBasicBlock = newWorklist.poll();\n                 visitedBasicBlocks.add(newBasicBlock);\n-\n                 newAnalysisState = newState(prevAnalysisState, newWorklist, newBasicBlock, -1);\n \n                 // join predecessors out-states\n                 List<BasicBlock> preds = getPredecessors(newBasicBlock);\n                 Set<E> predOutStates = new HashSet<E>();\n-\n                 for (BasicBlock p : preds) {\n                     E predOutState = prevAnalysisState.getBlockState(p).getOutState();\n                     predOutStates.add(predOutState);\n                 }\n \n                 E outStatesJoin = dfa.join(predOutStates);\n-\n                 BlockState<E> prevBlockState = prevAnalysisState.getBlockState(newBasicBlock);\n                 BlockState<E> newBlockState = new BlockState<E>(outStatesJoin, prevBlockState.getOutState());\n                 newAnalysisState.setBlockState(newBasicBlock, newBlockState);\n-\n                 updateColors(prevAnalysisState, newAnalysisState, visitedBasicBlocks);\n-\n                 analysisStates.add(newAnalysisState);\n \n                 // this begins a new block step\n-                blockSteps.add(elementaryStep++);\n+                blockSteps.add(elementaryStep ++);\n                 prevAnalysisState = newAnalysisState;\n                 continue;\n             }\n \n             // prevBasicBlock is not null (so this is not a new block step)\n+\n             int eBlockIdx = prevAnalysisState.getCurrentElementaryBlockIndex();\n-            if (prevBasicBlock.getElementaryBlockCount() == 0) {\n+            if(prevBasicBlock.getElementaryBlockCount() == 0) {\n                 // handle empty basic block [e. g. artificial end block]\n                 E inState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n                 newAnalysisState = finishBasicBlock(prevBasicBlock, inState, prevAnalysisState, visitedBasicBlocks);\n-            } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount()) {\n+            }\n+\n+\n+else\n+\n+if (eBlockIdx < prevBasicBlock.getElementaryBlockCount()) {\n                 // handle non-empty basic block\n-                E prevOutState;\n-                ElementaryBlock nextElementaryBlock;\n-                if (eBlockIdx < 0) {\n+    E prevOutState;\n+    ElementaryBlock nextElementaryBlock;\n+    if(eBlockIdx < 0) {\n                     // first elementary block\n-                    prevOutState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n-                    nextElementaryBlock = getElementaryBlock(prevBasicBlock, 0);\n-                } else if (eBlockIdx < prevBasicBlock.getElementaryBlockCount() - 1) {\n+        prevOutState = prevAnalysisState.getBlockState(prevBasicBlock).getInState();\n+        nextElementaryBlock = getElementaryBlock(prevBasicBlock, 0);\n+    }\n+\n+\n+else\n+\n+if(eBlockIdx < prevBasicBlock.getElementaryBlockCount() - 1) {\n                     // some elementary block that is not the first or last in the basic block\n-                    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n-                    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n-                    nextElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx + 1);\n-                } else {\n-                    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n-                    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n-                    nextElementaryBlock = null;\n-                }\n+    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n+    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n+    nextElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx + 1);\n+}\n \n-                if (nextElementaryBlock == null) {\n-                    newAnalysisState =\n-                            finishBasicBlock(prevBasicBlock, prevOutState, prevAnalysisState, visitedBasicBlocks);\n-                } else {\n-                    E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\n-                    BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\n-                    newAnalysisState = newState(prevAnalysisState, prevWorklist.clone(), prevBasicBlock, ++eBlockIdx);\n-                    newAnalysisState.setBlockState(nextElementaryBlock, nextBlockState);\n-                }\n-            }\n+\n+    else {\n+    ElementaryBlock prevElementaryBlock = getElementaryBlock(prevBasicBlock, eBlockIdx);\n+    prevOutState = prevAnalysisState.getBlockState(prevElementaryBlock).getOutState();\n+    nextElementaryBlock = null;\n+}\n+\n+    if(nextElementaryBlock == null) {\n+        newAnalysisState = finishBasicBlock(prevBasicBlock, prevOutState, prevAnalysisState, visitedBasicBlocks);\n+    }\n+\n+\n+else {\n+        E nextOutState = dfa.transition(prevOutState, nextElementaryBlock.getUnit());\n+        BlockState<E> nextBlockState = new BlockState<E>(prevOutState, nextOutState);\n+        newAnalysisState = newState(prevAnalysisState, prevWorklist.clone(), prevBasicBlock, ++eBlockIdx);\n+        newAnalysisState.setBlockState(nextElementaryBlock, nextBlockState);\n+    }\n+}\n \n             analysisStates.add(newAnalysisState);\n             prevAnalysisState = newAnalysisState;\n-            ++elementaryStep;\n+            ++ elementaryStep;\n         }\n     }\n \n+\n     private BasicBlock getStartBlock() {\n-        switch (getDirection()) {\n-        case FORWARD:\n+        switch(getDirection()) {\n+            case FORWARD:\n             return cfg.getStartBlock();\n-        case BACKWARD:\n+\n+                               case BACKWARD:\n             return cfg.getEndBlock();\n-        default:\n+\n+                               default:\n             throw new IllegalStateException(\"unknown direction: \" + getDirection());\n+\n         }\n     }\n \n+\n     private List<BasicBlock> getPredecessors(BasicBlock bBlock) {\n-        switch (direction) {\n-        case FORWARD:\n+        switch(direction) {\n+            case FORWARD:\n             return cfg.getPredecessors(bBlock);\n-        case BACKWARD:\n+\n+                          case BACKWARD:\n             return cfg.getSuccessors(bBlock);\n-        default:\n+\n+                          default:\n             throw new IllegalStateException();\n+\n         }\n     }\n \n+\n     private List<BasicBlock> getSuccessors(BasicBlock bBlock) {\n-        switch (direction) {\n-        case FORWARD:\n+        switch(direction) {\n+            case FORWARD:\n             return cfg.getSuccessors(bBlock);\n-        case BACKWARD:\n+\n+                          case BACKWARD:\n             return cfg.getPredecessors(bBlock);\n-        default:\n+\n+                          default:\n             throw new IllegalStateException(\"unknown direction: \" + getDirection());\n+\n         }\n     }\n \n-    private AnalysisState<E> newState(AnalysisState<E> state, Worklist newWorklist, BasicBlock currentBBlock,\n-            int eBlockIdx) {\n+\n+    private AnalysisState<E> newState(AnalysisState<E> state, Worklist newWorklist, BasicBlock currentBBlock, int eBlockIdx) {\n         Map<AbstractBlock, BlockState<E>> stateMap = new HashMap<AbstractBlock, BlockState<E>>(state.getStateMap());\n         Map<BasicBlock, LogicalColor> colorMap = new HashMap<BasicBlock, LogicalColor>(state.getColorMap());\n-\n         AnalysisState<E> newState = new AnalysisState<E>(newWorklist, currentBBlock, eBlockIdx, stateMap, colorMap);\n         newState.setCurrentElementaryBlockIndex(eBlockIdx);\n         return newState;\n@@ -473,35 +527,46 @@ public class DFAExecution<E extends LatticeElement> {\n     /*\n      * updates the color-mapping in newState according to prevState and the worklist and current BasicBlock of newState\n      */\n+\n+\n     private void updateColors(AnalysisState<E> prevState, AnalysisState<E> newState, Set<BasicBlock> visited) {\n         List<BasicBlock> basicBlocks = cfg.getBasicBlocks();\n         Worklist newWorklist = newState.getWorklist();\n-\n         for (BasicBlock basicBlock : basicBlocks) {\n             LogicalColor newColor;\n-            if (basicBlock.equals(newState.getCurrentBasicBlock())) {\n+            if(basicBlock.equals(newState.getCurrentBasicBlock())) {\n                 newColor = LogicalColor.CURRENT;\n-            } else if (newWorklist.contains(basicBlock)) {\n-                newColor = LogicalColor.ON_WORKLIST;\n-            } else {\n-                if (visited.contains(basicBlock)) {\n-                    newColor = LogicalColor.VISITED_NOT_ON_WORKLIST;\n-                } else {\n-                    newColor = LogicalColor.NOT_VISITED;\n-                }\n             }\n+\n+\n+else\n+\n+if(newWorklist.contains(basicBlock)) {\n+    newColor = LogicalColor.ON_WORKLIST;\n+}\n+\n+\n+            else {\n+    if(visited.contains(basicBlock)) {\n+        newColor = LogicalColor.VISITED_NOT_ON_WORKLIST;\n+    }\n+\n+\n+else {\n+        newColor = LogicalColor.NOT_VISITED;\n+    }\n+}\n+\n             newState.setColor(basicBlock, newColor);\n         }\n     }\n \n-    private AnalysisState<E> finishBasicBlock(BasicBlock currentBBlock, E outState, AnalysisState<E> prevAnalysisState,\n-            Set<BasicBlock> visited) {\n+\n+    private AnalysisState<E> finishBasicBlock(BasicBlock currentBBlock, E outState, AnalysisState<E> prevAnalysisState, Set<BasicBlock> visited) {\n         Worklist newWorklist = prevAnalysisState.getWorklist().clone();\n         BlockState<E> prevBlockState = prevAnalysisState.getBlockState(currentBBlock);\n-\n         List<BasicBlock> successors = getSuccessors(currentBBlock);\n         E prevOutState = prevBlockState.getOutState();\n-\n         boolean outStateChanged = !outState.equals(prevOutState);\n         for (BasicBlock bSucc : successors) {\n             if (outStateChanged || !visited.contains(bSucc)) {\n@@ -512,21 +577,24 @@ public class DFAExecution<E extends LatticeElement> {\n         AnalysisState<E> newAnalysisState = newState(prevAnalysisState, newWorklist, null, -1);\n         BlockState<E> newBlockState = new BlockState<E>(prevBlockState.getInState(), outState);\n         newAnalysisState.setBlockState(currentBBlock, newBlockState);\n-\n         updateColors(prevAnalysisState, newAnalysisState, visited);\n         return newAnalysisState;\n     }\n \n+\n     private ElementaryBlock getElementaryBlock(BasicBlock bBlock, int eBlockIdx) {\n         List<ElementaryBlock> elementaryBlocks = bBlock.getElementaryBlocks();\n-        switch (direction) {\n-        case FORWARD:\n+        switch(direction) {\n+            case FORWARD:\n             return elementaryBlocks.get(eBlockIdx);\n-        case BACKWARD:\n+\n+            case BACKWARD:\n             return elementaryBlocks.get(bBlock.getElementaryBlockCount() - 1 - eBlockIdx);\n-        default:\n+\n+            default:\n             throw new IllegalStateException(\"unknown direction: \" + getDirection());\n+\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 201
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "414",
                    "column": "38",
                    "severity": "warning",
                    "message": "'=' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "414",
                    "column": "38",
                    "severity": "warning",
                    "message": "'=' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}