{
    "project_name": "Internet2-grouper",
    "error_id": "78",
    "information": {
        "errors": [
            {
                "line": "267",
                "severity": "warning",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "         * </p>\n         * @param parm a may-be primitive type class\n         * @return the equivalent object class \n         */\n        static Class<?> primitiveClass(Class<?> parm) {\n            // it is marginally faster to get from the map than call isPrimitive...",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "267",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/78/ClassMap.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/intellij/78/ClassMap.java\nindex 121c8b9f099..8b5aa04e0c1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/78/ClassMap.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/intellij/78/ClassMap.java\n@@ -1,12 +1,12 @@\n /**\r\n  * Copyright 2014 Internet2\r\n- *\r\n+ * <p>\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n+ * <p>\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ * <p>\r\n  * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n@@ -29,6 +29,7 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n+\r\n package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.internal.introspection;\r\n \r\n import java.lang.reflect.Field;\r\n@@ -52,326 +53,328 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.logging.Log;\n  * @since 1.0\r\n  */\r\n final class ClassMap {\r\n-    /** cache of methods. */\r\n-    private final MethodCache methodCache;\r\n-    /** cache of fields. */\r\n-    private final Map<String, Field> fieldCache;\r\n+  /** cache of methods. */\r\n+  private final MethodCache methodCache;\r\n+  /** cache of fields. */\r\n+  private final Map<String, Field> fieldCache;\r\n \r\n-    /**\r\n-     * Standard constructor.\r\n-     *\r\n-     * @param aClass the class to deconstruct.\r\n-     * @param log the logger.\r\n-     */\r\n-    ClassMap(Class<?> aClass, Log log) {\r\n-        // eagerly cache methods\r\n-        methodCache = createMethodCache(aClass, log);\r\n-        // eagerly cache public fields\r\n-        fieldCache = createFieldCache(aClass);\r\n+  /**\r\n+   * Standard constructor.\r\n+   *\r\n+   * @param aClass the class to deconstruct.\r\n+   * @param log the logger.\r\n+   */\r\n+  ClassMap(Class<?> aClass, Log log) {\r\n+    // eagerly cache methods\r\n+    methodCache = createMethodCache(aClass, log);\r\n+    // eagerly cache public fields\r\n+    fieldCache = createFieldCache(aClass);\r\n+  }\r\n+\r\n+  /**\r\n+   * Find a Field using its name.\r\n+   * <p>The clazz parameter <strong>must</strong> be this ClassMap key.</p>\r\n+   * @param clazz the class to introspect\r\n+   * @param fname the field name\r\n+   * @return A Field object representing the field to invoke or null.\r\n+   */\r\n+  Field findField(final Class<?> clazz, final String fname) {\r\n+    return fieldCache.get(fname);\r\n+  }\r\n+\r\n+  /**\r\n+   * Gets the field names cached by this map.\r\n+   * @return the array of field names\r\n+   */\r\n+  String[] getFieldNames() {\r\n+    return fieldCache.keySet().toArray(new String[fieldCache.size()]);\r\n+  }\r\n+\r\n+  /**\r\n+   * Creates a map of all public fields of a given class.\r\n+   * @param clazz the class to introspect\r\n+   * @return the map of fields (may be the empty map, can not be null)\r\n+   */\r\n+  private static Map<String, Field> createFieldCache(Class<?> clazz) {\r\n+    Field[] fields = clazz.getFields();\r\n+    if (fields.length > 0) {\r\n+      Map<String, Field> cache = new HashMap<String, Field>();\r\n+      for (Field field : fields) {\r\n+        cache.put(field.getName(), field);\r\n+      }\r\n+      return cache;\r\n+    } else {\r\n+      return Collections.emptyMap();\r\n     }\r\n+  }\r\n \r\n-    /**\r\n-     * Find a Field using its name.\r\n-     * <p>The clazz parameter <strong>must</strong> be this ClassMap key.</p>\r\n-     * @param clazz the class to introspect\r\n-     * @param fname the field name\r\n-     * @return A Field object representing the field to invoke or null.\r\n-     */\r\n-    Field findField(final Class<?> clazz, final String fname) {\r\n-        return fieldCache.get(fname);\r\n+  /**\r\n+   * Gets the methods names cached by this map.\r\n+   * @return the array of method names\r\n+   */\r\n+  String[] getMethodNames() {\r\n+    return methodCache.names();\r\n+  }\r\n+\r\n+  /**\r\n+   * Gets all the methods with a given name from this map.\r\n+   * @param methodName the seeked methods name\r\n+   * @return the array of methods\r\n+   */\r\n+  Method[] get(final String methodName) {\r\n+    return methodCache.get(methodName);\r\n+  }\r\n+\r\n+  /**\r\n+   * Find a Method using the method name and parameter objects.\r\n+   *\r\n+   * @param key the method key\r\n+   * @return A Method object representing the method to invoke or null.\r\n+   * @throws MethodKey.AmbiguousException When more than one method is a match for the parameters.\r\n+   */\r\n+  Method findMethod(final MethodKey key)\r\n+    throws MethodKey.AmbiguousException {\r\n+    return methodCache.get(key);\r\n+  }\r\n+\r\n+  /**\r\n+   * Populate the Map of direct hits. These are taken from all the public methods\r\n+   * that our class, its parents and their implemented interfaces provide.\r\n+   * @param classToReflect the class to cache\r\n+   * @param log the Log\r\n+   * @return a newly allocated & filled up cache\r\n+   */\r\n+  private static MethodCache createMethodCache(Class<?> classToReflect, Log log) {\r\n+    //\r\n+    // Build a list of all elements in the class hierarchy. This one is bottom-first (i.e. we start\r\n+    // with the actual declaring class and its interfaces and then move up (superclass etc.) until we\r\n+    // hit java.lang.Object. That is important because it will give us the methods of the declaring class\r\n+    // which might in turn be abstract further up the tree.\r\n+    //\r\n+    // We also ignore all SecurityExceptions that might happen due to SecurityManager restrictions (prominently\r\n+    // hit with Tomcat 5.5).\r\n+    //\r\n+    // We can also omit all that complicated getPublic, getAccessible and upcast logic that the class map had up\r\n+    // until Velocity 1.4. As we always reflect all elements of the tree (that's what we have a cache for), we will\r\n+    // hit the public elements sooner or later because we reflect all the public elements anyway.\r\n+    //\r\n+    // Ah, the miracles of Java for(;;) ...\r\n+    MethodCache cache = new MethodCache();\r\n+    for (; classToReflect != null; classToReflect = classToReflect.getSuperclass()) {\r\n+      if (Modifier.isPublic(classToReflect.getModifiers())) {\r\n+        populateMethodCacheWith(cache, classToReflect, log);\r\n+      }\r\n+      Class<?>[] interfaces = classToReflect.getInterfaces();\r\n+      for (int i = 0; i < interfaces.length; i++) {\r\n+        populateMethodCacheWithInterface(cache, interfaces[i], log);\r\n+      }\r\n     }\r\n+    return cache;\r\n+  }\r\n \r\n-    /**\r\n-     * Gets the field names cached by this map.\r\n-     * @return the array of field names\r\n-     */\r\n-    String[] getFieldNames() {\r\n-        return fieldCache.keySet().toArray(new String[fieldCache.size()]);\r\n+  /**\r\n+   * Recurses up interface hierarchy to get all super interfaces.\r\n+   * @param cache the cache to fill\r\n+   * @param iface the interface to populate the cache from\r\n+   * @param log the Log\r\n+   */\r\n+  private static void populateMethodCacheWithInterface(MethodCache cache, Class<?> iface, Log log) {\r\n+    if (Modifier.isPublic(iface.getModifiers())) {\r\n+      populateMethodCacheWith(cache, iface, log);\r\n+    }\r\n+    Class<?>[] supers = iface.getInterfaces();\r\n+    for (int i = 0; i < supers.length; i++) {\r\n+      populateMethodCacheWithInterface(cache, supers[i], log);\r\n     }\r\n+  }\r\n \r\n-    /**\r\n-     * Creates a map of all public fields of a given class.\r\n-     * @param clazz the class to introspect\r\n-     * @return the map of fields (may be the empty map, can not be null)\r\n-     */\r\n-    private static Map<String, Field> createFieldCache(Class<?> clazz) {\r\n-        Field[] fields = clazz.getFields();\r\n-        if (fields.length > 0) {\r\n-            Map<String, Field> cache = new HashMap<String, Field>();\r\n-            for (Field field : fields) {\r\n-                cache.put(field.getName(), field);\r\n-            }\r\n-            return cache;\r\n-        } else {\r\n-            return Collections.emptyMap();\r\n+  /**\r\n+   * Recurses up class hierarchy to get all super classes.\r\n+   * @param cache the cache to fill\r\n+   * @param clazz the class to populate the cache from\r\n+   * @param log the Log\r\n+   */\r\n+  private static void populateMethodCacheWith(MethodCache cache, Class<?> clazz, Log log) {\r\n+    try {\r\n+      Method[] methods = clazz.getDeclaredMethods();\r\n+      for (int i = 0; i < methods.length; i++) {\r\n+        int modifiers = methods[i].getModifiers();\r\n+        if (Modifier.isPublic(modifiers)) {\r\n+          cache.put(methods[i]);\r\n         }\r\n+      }\r\n+    } catch (SecurityException se) {\r\n+      // Everybody feels better with...\r\n+      if (log.isDebugEnabled()) {\r\n+        log.debug(\"While accessing methods of \" + clazz + \": \", se);\r\n+      }\r\n     }\r\n+  }\r\n \r\n+  /**\r\n+   * This is the cache to store and look up the method information.\r\n+   * <p>\r\n+   * It stores the association between:\r\n+   *  - a key made of a method name & an array of argument types.\r\n+   *  - a method.\r\n+   * </p>\r\n+   * <p>\r\n+   * Since the invocation of the associated method is dynamic, there is no need (nor way) to differentiate between\r\n+   * foo(int,int) & foo(Integer,Integer) since in practise, only the latter form will be used through a call.\r\n+   * This of course, applies to all 8 primitive types.\r\n+   * </p>\r\n+   */\r\n+  static final class MethodCache {\r\n     /**\r\n-     * Gets the methods names cached by this map.\r\n-     * @return the array of method names\r\n+     * A method that returns itself used as a marker for cache miss,\r\n+     * allows the underlying cache map to be strongly typed.\r\n+     * @return itself as a method\r\n      */\r\n-    String[] getMethodNames() {\r\n-        return methodCache.names();\r\n+    public static Method cacheMiss() {\r\n+      try {\r\n+        return MethodCache.class.getMethod(\"cacheMiss\");\r\n+      } catch (Exception xio) {\r\n+        // this really cant make an error...\r\n+        return null;\r\n+      }\r\n     }\r\n \r\n-    /**\r\n-     * Gets all the methods with a given name from this map.\r\n-     * @param methodName the seeked methods name\r\n-     * @return the array of methods\r\n+    /** The cache miss marker method. */\r\n+    private static final Method CACHE_MISS = cacheMiss();\r\n+    /** The initial size of the primitive conversion map. */\r\n+    private static final int PRIMITIVE_SIZE = 13;\r\n+    /** The primitive type to class conversion map. */\r\n+    private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPES;\r\n+\r\n+    static {\r\n+      PRIMITIVE_TYPES = new HashMap<Class<?>, Class<?>>(PRIMITIVE_SIZE);\r\n+      PRIMITIVE_TYPES.put(Boolean.TYPE, Boolean.class);\r\n+      PRIMITIVE_TYPES.put(Byte.TYPE, Byte.class);\r\n+      PRIMITIVE_TYPES.put(Character.TYPE, Character.class);\r\n+      PRIMITIVE_TYPES.put(Double.TYPE, Double.class);\r\n+      PRIMITIVE_TYPES.put(Float.TYPE, Float.class);\r\n+      PRIMITIVE_TYPES.put(Integer.TYPE, Integer.class);\r\n+      PRIMITIVE_TYPES.put(Long.TYPE, Long.class);\r\n+      PRIMITIVE_TYPES.put(Short.TYPE, Short.class);\r\n+    }\r\n+\r\n+    /** Converts a primitive type to its corresponding class.\r\n+     * <p>\r\n+     * If the argument type is primitive then we want to convert our\r\n+     * primitive type signature to the corresponding Object type so\r\n+     * introspection for methods with primitive types will work\r\n+     * correctly.\r\n+     * </p>\r\n+     * @param parm a may-be primitive type class\r\n+     * @return the equivalent object class\r\n      */\r\n-    Method[] get(final String methodName) {\r\n-        return methodCache.get(methodName);\r\n+    static Class<?> primitiveClass(Class<?> parm) {\r\n+      // it is marginally faster to get from the map than call isPrimitive...\r\n+      //if (!parm.isPrimitive()) return parm;\r\n+      Class<?> prim = PRIMITIVE_TYPES.get(parm);\r\n+      return prim == null ? parm : prim;\r\n     }\r\n \r\n+    /**\r\n+     * The method cache.\r\n+     * <p>\r\n+     * Cache of Methods, or CACHE_MISS, keyed by method\r\n+     * name and actual arguments used to find it.\r\n+     * </p>\r\n+     */\r\n+    private final Map<MethodKey, Method> methods = new HashMap<MethodKey, Method>();\r\n+    /**\r\n+     * Map of methods that are searchable according to method parameters to find a match.\r\n+     */\r\n+    private final MethodMap methodMap = new MethodMap();\r\n+\r\n     /**\r\n      * Find a Method using the method name and parameter objects.\r\n-     *\r\n-     * @param key the method key\r\n+     *<p>\r\n+     * Look in the methodMap for an entry.  If found,\r\n+     * it'll either be a CACHE_MISS, in which case we\r\n+     * simply give up, or it'll be a Method, in which\r\n+     * case, we return it.\r\n+     *</p>\r\n+     * <p>\r\n+     * If nothing is found, then we must actually go\r\n+     * and introspect the method from the MethodMap.\r\n+     *</p>\r\n+     * @param methodKey the method key\r\n      * @return A Method object representing the method to invoke or null.\r\n      * @throws MethodKey.AmbiguousException When more than one method is a match for the parameters.\r\n      */\r\n-    Method findMethod(final MethodKey key)\r\n-            throws MethodKey.AmbiguousException {\r\n-        return methodCache.get(key);\r\n-    }\r\n+    Method get(final MethodKey methodKey) throws MethodKey.AmbiguousException {\r\n+      synchronized (methodMap) {\r\n+        Method cacheEntry = methods.get(methodKey);\r\n+        // We looked this up before and failed.\r\n+        if (cacheEntry == CACHE_MISS) {\r\n+          return null;\r\n+        }\r\n \r\n-    /**\r\n-     * Populate the Map of direct hits. These are taken from all the public methods\r\n-     * that our class, its parents and their implemented interfaces provide.\r\n-     * @param classToReflect the class to cache\r\n-     * @param log the Log\r\n-     * @return a newly allocated & filled up cache\r\n-     */\r\n-    private static MethodCache createMethodCache(Class<?> classToReflect, Log log) {\r\n-        //\r\n-        // Build a list of all elements in the class hierarchy. This one is bottom-first (i.e. we start\r\n-        // with the actual declaring class and its interfaces and then move up (superclass etc.) until we\r\n-        // hit java.lang.Object. That is important because it will give us the methods of the declaring class\r\n-        // which might in turn be abstract further up the tree.\r\n-        //\r\n-        // We also ignore all SecurityExceptions that might happen due to SecurityManager restrictions (prominently\r\n-        // hit with Tomcat 5.5).\r\n-        //\r\n-        // We can also omit all that complicated getPublic, getAccessible and upcast logic that the class map had up\r\n-        // until Velocity 1.4. As we always reflect all elements of the tree (that's what we have a cache for), we will\r\n-        // hit the public elements sooner or later because we reflect all the public elements anyway.\r\n-        //\r\n-        // Ah, the miracles of Java for(;;) ...\r\n-        MethodCache cache = new MethodCache();\r\n-        for (; classToReflect != null; classToReflect = classToReflect.getSuperclass()) {\r\n-            if (Modifier.isPublic(classToReflect.getModifiers())) {\r\n-                populateMethodCacheWith(cache, classToReflect, log);\r\n-            }\r\n-            Class<?>[] interfaces = classToReflect.getInterfaces();\r\n-            for (int i = 0; i < interfaces.length; i++) {\r\n-                populateMethodCacheWithInterface(cache, interfaces[i], log);\r\n+        if (cacheEntry == null) {\r\n+          try {\r\n+            // That one is expensive...\r\n+            cacheEntry = methodMap.find(methodKey);\r\n+            if (cacheEntry != null) {\r\n+              methods.put(methodKey, cacheEntry);\r\n+            } else {\r\n+              methods.put(methodKey, CACHE_MISS);\r\n             }\r\n+          } catch (MethodKey.AmbiguousException ae) {\r\n+            // that's a miss :-)\r\n+            methods.put(methodKey, CACHE_MISS);\r\n+            throw ae;\r\n+          }\r\n         }\r\n-        return cache;\r\n+\r\n+        // Yes, this might just be null.\r\n+        return cacheEntry;\r\n+      }\r\n     }\r\n \r\n     /**\r\n-     * Recurses up interface hierarchy to get all super interfaces.\r\n-     * @param cache the cache to fill\r\n-     * @param iface the interface to populate the cache from\r\n-     * @param log the Log\r\n+     * Adds a method to the map.\r\n+     * @param method the method to add\r\n      */\r\n-    private static void populateMethodCacheWithInterface(MethodCache cache, Class<?> iface, Log log) {\r\n-        if (Modifier.isPublic(iface.getModifiers())) {\r\n-            populateMethodCacheWith(cache, iface, log);\r\n-        }\r\n-        Class<?>[] supers = iface.getInterfaces();\r\n-        for (int i = 0; i < supers.length; i++) {\r\n-            populateMethodCacheWithInterface(cache, supers[i], log);\r\n+    void put(Method method) {\r\n+      synchronized (methodMap) {\r\n+        MethodKey methodKey = new MethodKey(method);\r\n+        // We don't overwrite methods. Especially not if we fill the\r\n+        // cache from defined class towards java.lang.Object because\r\n+        // abstract methods in superclasses would else overwrite concrete\r\n+        // classes further down the hierarchy.\r\n+        if (methods.get(methodKey) == null) {\r\n+          methods.put(methodKey, method);\r\n+          methodMap.add(method);\r\n         }\r\n+      }\r\n     }\r\n \r\n     /**\r\n-     * Recurses up class hierarchy to get all super classes.\r\n-     * @param cache the cache to fill\r\n-     * @param clazz the class to populate the cache from\r\n-     * @param log the Log\r\n+     * Gets all the method names from this map.\r\n+     * @return the array of method name\r\n      */\r\n-    private static void populateMethodCacheWith(MethodCache cache, Class<?> clazz, Log log) {\r\n-        try {\r\n-            Method[] methods = clazz.getDeclaredMethods();\r\n-            for (int i = 0; i < methods.length; i++) {\r\n-                int modifiers = methods[i].getModifiers();\r\n-                if (Modifier.isPublic(modifiers)) {\r\n-                    cache.put(methods[i]);\r\n-                }\r\n-            }\r\n-        } catch (SecurityException se) {\r\n-            // Everybody feels better with...\r\n-            if (log.isDebugEnabled()) {\r\n-                log.debug(\"While accessing methods of \" + clazz + \": \", se);\r\n-            }\r\n-        }\r\n+    String[] names() {\r\n+      synchronized (methodMap) {\r\n+        return methodMap.names();\r\n+      }\r\n     }\r\n \r\n     /**\r\n-     * This is the cache to store and look up the method information.\r\n-     * <p>\r\n-     * It stores the association between:\r\n-     *  - a key made of a method name & an array of argument types.\r\n-     *  - a method.\r\n-     * </p>\r\n-     * <p>\r\n-     * Since the invocation of the associated method is dynamic, there is no need (nor way) to differentiate between\r\n-     * foo(int,int) & foo(Integer,Integer) since in practise, only the latter form will be used through a call.\r\n-     * This of course, applies to all 8 primitive types.\r\n-     * </p>\r\n+     * Gets all the methods with a given name from this map.\r\n+     * @param methodName the seeked methods name\r\n+     * @return the array of methods (null or non-empty)\r\n      */\r\n-    static final class MethodCache {\r\n-        /**\r\n-         * A method that returns itself used as a marker for cache miss,\r\n-         * allows the underlying cache map to be strongly typed.\r\n-         * @return itself as a method\r\n-         */\r\n-        public static Method cacheMiss() {\r\n-            try {\r\n-                return MethodCache.class.getMethod(\"cacheMiss\");\r\n-            } catch (Exception xio) {\r\n-                // this really cant make an error...\r\n-                return null;\r\n-            }\r\n-        }\r\n-        /** The cache miss marker method. */\r\n-        private static final Method CACHE_MISS = cacheMiss();\r\n-        /** The initial size of the primitive conversion map. */\r\n-        private static final int PRIMITIVE_SIZE = 13;\r\n-        /** The primitive type to class conversion map. */\r\n-        private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPES;\r\n-\r\n-        static {\r\n-            PRIMITIVE_TYPES = new HashMap<Class<?>, Class<?>>(PRIMITIVE_SIZE);\r\n-            PRIMITIVE_TYPES.put(Boolean.TYPE, Boolean.class);\r\n-            PRIMITIVE_TYPES.put(Byte.TYPE, Byte.class);\r\n-            PRIMITIVE_TYPES.put(Character.TYPE, Character.class);\r\n-            PRIMITIVE_TYPES.put(Double.TYPE, Double.class);\r\n-            PRIMITIVE_TYPES.put(Float.TYPE, Float.class);\r\n-            PRIMITIVE_TYPES.put(Integer.TYPE, Integer.class);\r\n-            PRIMITIVE_TYPES.put(Long.TYPE, Long.class);\r\n-            PRIMITIVE_TYPES.put(Short.TYPE, Short.class);\r\n-        }\r\n-\r\n-        /** Converts a primitive type to its corresponding class.\r\n-         * <p>\r\n-         * If the argument type is primitive then we want to convert our\r\n-         * primitive type signature to the corresponding Object type so\r\n-         * introspection for methods with primitive types will work\r\n-         * correctly.\r\n-         * </p>\r\n-         * @param parm a may-be primitive type class\r\n-         * @return the equivalent object class \r\n-         */\r\n-        static Class<?> primitiveClass(Class<?> parm) {\r\n-            // it is marginally faster to get from the map than call isPrimitive...\r\n-            //if (!parm.isPrimitive()) return parm;\r\n-            Class<?> prim = PRIMITIVE_TYPES.get(parm);\r\n-            return prim == null ? parm : prim;\r\n-        }\r\n-        /**\r\n-         * The method cache.\r\n-         * <p>\r\n-         * Cache of Methods, or CACHE_MISS, keyed by method\r\n-         * name and actual arguments used to find it.\r\n-         * </p>\r\n-         */\r\n-        private final Map<MethodKey, Method> methods = new HashMap<MethodKey, Method>();\r\n-        /**\r\n-         * Map of methods that are searchable according to method parameters to find a match.\r\n-         */\r\n-        private final MethodMap methodMap = new MethodMap();\r\n-\r\n-        /**\r\n-         * Find a Method using the method name and parameter objects.\r\n-         *<p>\r\n-         * Look in the methodMap for an entry.  If found,\r\n-         * it'll either be a CACHE_MISS, in which case we\r\n-         * simply give up, or it'll be a Method, in which\r\n-         * case, we return it.\r\n-         *</p>\r\n-         * <p>\r\n-         * If nothing is found, then we must actually go\r\n-         * and introspect the method from the MethodMap.\r\n-         *</p>\r\n-         * @param methodKey the method key\r\n-         * @return A Method object representing the method to invoke or null.\r\n-         * @throws MethodKey.AmbiguousException When more than one method is a match for the parameters.\r\n-         */\r\n-        Method get(final MethodKey methodKey) throws MethodKey.AmbiguousException {\r\n-            synchronized (methodMap) {\r\n-                Method cacheEntry = methods.get(methodKey);\r\n-                // We looked this up before and failed.\r\n-                if (cacheEntry == CACHE_MISS) {\r\n-                    return null;\r\n-                }\r\n-\r\n-                if (cacheEntry == null) {\r\n-                    try {\r\n-                        // That one is expensive...\r\n-                        cacheEntry = methodMap.find(methodKey);\r\n-                        if (cacheEntry != null) {\r\n-                            methods.put(methodKey, cacheEntry);\r\n-                        } else {\r\n-                            methods.put(methodKey, CACHE_MISS);\r\n-                        }\r\n-                    } catch (MethodKey.AmbiguousException ae) {\r\n-                        // that's a miss :-)\r\n-                        methods.put(methodKey, CACHE_MISS);\r\n-                        throw ae;\r\n-                    }\r\n-                }\r\n-\r\n-                // Yes, this might just be null.\r\n-                return cacheEntry;\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * Adds a method to the map.\r\n-         * @param method the method to add\r\n-         */\r\n-        void put(Method method) {\r\n-            synchronized (methodMap) {\r\n-                MethodKey methodKey = new MethodKey(method);\r\n-                // We don't overwrite methods. Especially not if we fill the\r\n-                // cache from defined class towards java.lang.Object because\r\n-                // abstract methods in superclasses would else overwrite concrete\r\n-                // classes further down the hierarchy.\r\n-                if (methods.get(methodKey) == null) {\r\n-                    methods.put(methodKey, method);\r\n-                    methodMap.add(method);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * Gets all the method names from this map.\r\n-         * @return the array of method name\r\n-         */\r\n-        String[] names() {\r\n-            synchronized (methodMap) {\r\n-                return methodMap.names();\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * Gets all the methods with a given name from this map.\r\n-         * @param methodName the seeked methods name\r\n-         * @return the array of methods (null or non-empty)\r\n-         */\r\n-        Method[] get(final String methodName) {\r\n-            synchronized (methodMap) {\r\n-                List<Method> lm = methodMap.get(methodName);\r\n-                if (lm != null && !lm.isEmpty()) {\r\n-                    return lm.toArray(new Method[lm.size()]);\r\n-                } else {\r\n-                    return null;\r\n-                }\r\n-            }\r\n+    Method[] get(final String methodName) {\r\n+      synchronized (methodMap) {\r\n+        List<Method> lm = methodMap.get(methodName);\r\n+        if (lm != null && !lm.isEmpty()) {\r\n+          return lm.toArray(new Method[lm.size()]);\r\n+        } else {\r\n+          return null;\r\n         }\r\n+      }\r\n     }\r\n+  }\r\n }\r\n",
            "diff_size": 478
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "267",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/78/ClassMap.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/naturalize/78/ClassMap.java\nindex 121c8b9f099..3d72f41e493 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/78/ClassMap.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/naturalize/78/ClassMap.java\n@@ -374,4 +374,4 @@ final class ClassMap {\n             }\r\n         }\r\n     }\r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "293",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/78/ClassMap.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/codebuff/78/ClassMap.java\nindex 121c8b9f099..5fe25b29ccf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/78/ClassMap.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/codebuff/78/ClassMap.java\n@@ -29,16 +29,15 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n-package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.internal.introspection;\r\n-\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Method;\r\n-import java.lang.reflect.Modifier;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n+package edu.internet2.middleware.grouperClientExt.org.apache.commons.jexl2.internal.introspection;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n import edu.internet2.middleware.grouperClientExt.org.apache.commons.logging.Log;\r\n \r\n /**\r\n@@ -50,11 +49,13 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.logging.Log;\n  * </p>\r\n  * @see MethodKey\r\n  * @since 1.0\r\n- */\r\n+ */\n+\n final class ClassMap {\r\n-    /** cache of methods. */\r\n+    /** cache of methods. */\n+\n     private final MethodCache methodCache;\r\n-    /** cache of fields. */\r\n+    /** cache of fields. */\n     private final Map<String, Field> fieldCache;\r\n \r\n     /**\r\n@@ -62,12 +63,13 @@ final class ClassMap {\n      *\r\n      * @param aClass the class to deconstruct.\r\n      * @param log the logger.\r\n-     */\r\n+     */\n+\n     ClassMap(Class<?> aClass, Log log) {\r\n-        // eagerly cache methods\r\n+        // eagerly cache methods\n         methodCache = createMethodCache(aClass, log);\r\n-        // eagerly cache public fields\r\n-        fieldCache = createFieldCache(aClass);\r\n+        // eagerly cache public fields\n+        fieldCache = createFieldCache(aClass);\n     }\r\n \r\n     /**\r\n@@ -76,52 +78,60 @@ final class ClassMap {\n      * @param clazz the class to introspect\r\n      * @param fname the field name\r\n      * @return A Field object representing the field to invoke or null.\r\n-     */\r\n-    Field findField(final Class<?> clazz, final String fname) {\r\n-        return fieldCache.get(fname);\r\n+     */\n+\n+    Field findField(final Class<?> clazz, final String fname) {\n+        return fieldCache.get(fname);\n     }\r\n \r\n     /**\r\n      * Gets the field names cached by this map.\r\n      * @return the array of field names\r\n-     */\r\n-    String[] getFieldNames() {\r\n-        return fieldCache.keySet().toArray(new String[fieldCache.size()]);\r\n+     */\n+\n+    String[] getFieldNames() {\n+        return fieldCache.keySet().toArray(new String[fieldCache.size()]);\n     }\r\n \r\n     /**\r\n      * Creates a map of all public fields of a given class.\r\n      * @param clazz the class to introspect\r\n      * @return the map of fields (may be the empty map, can not be null)\r\n-     */\r\n-    private static Map<String, Field> createFieldCache(Class<?> clazz) {\r\n-        Field[] fields = clazz.getFields();\r\n-        if (fields.length > 0) {\r\n-            Map<String, Field> cache = new HashMap<String, Field>();\r\n-            for (Field field : fields) {\r\n-                cache.put(field.getName(), field);\r\n-            }\r\n-            return cache;\r\n-        } else {\r\n-            return Collections.emptyMap();\r\n-        }\r\n+     */\n+\n+\n+    private static Map<String, Field> createFieldCache(Class<?> clazz) {\n+        Field[] fields = clazz.getFields();\n+\n+        if (fields.length > 0) {\n+            Map<String, Field> cache = new HashMap<String, Field>();\n+\n+            for (Field field : fields) {\n+                cache.put(field.getName(), field);\n+            }\n+            return cache;\n+        } else {\n+            return Collections.emptyMap();\n+        }\n     }\r\n \r\n     /**\r\n      * Gets the methods names cached by this map.\r\n      * @return the array of method names\r\n-     */\r\n-    String[] getMethodNames() {\r\n-        return methodCache.names();\r\n+     */\n+\n+    String[] getMethodNames() {\n+        return methodCache.names();\n     }\r\n \r\n     /**\r\n      * Gets all the methods with a given name from this map.\r\n      * @param methodName the seeked methods name\r\n      * @return the array of methods\r\n-     */\r\n-    Method[] get(final String methodName) {\r\n-        return methodCache.get(methodName);\r\n+     */\n+\n+    Method[] get(final String methodName) {\n+        return methodCache.get(methodName);\n     }\r\n \r\n     /**\r\n@@ -130,10 +140,10 @@ final class ClassMap {\n      * @param key the method key\r\n      * @return A Method object representing the method to invoke or null.\r\n      * @throws MethodKey.AmbiguousException When more than one method is a match for the parameters.\r\n-     */\r\n-    Method findMethod(final MethodKey key)\r\n-            throws MethodKey.AmbiguousException {\r\n-        return methodCache.get(key);\r\n+     */\n+\n+    Method findMethod(final MethodKey key) throws MethodKey.AmbiguousException {\n+        return methodCache.get(key);\n     }\r\n \r\n     /**\r\n@@ -142,7 +152,9 @@ final class ClassMap {\n      * @param classToReflect the class to cache\r\n      * @param log the Log\r\n      * @return a newly allocated & filled up cache\r\n-     */\r\n+     */\n+\n+\n     private static MethodCache createMethodCache(Class<?> classToReflect, Log log) {\r\n         //\r\n         // Build a list of all elements in the class hierarchy. This one is bottom-first (i.e. we start\r\n@@ -157,18 +169,20 @@ final class ClassMap {\n         // until Velocity 1.4. As we always reflect all elements of the tree (that's what we have a cache for), we will\r\n         // hit the public elements sooner or later because we reflect all the public elements anyway.\r\n         //\r\n-        // Ah, the miracles of Java for(;;) ...\r\n-        MethodCache cache = new MethodCache();\r\n-        for (; classToReflect != null; classToReflect = classToReflect.getSuperclass()) {\r\n-            if (Modifier.isPublic(classToReflect.getModifiers())) {\r\n-                populateMethodCacheWith(cache, classToReflect, log);\r\n-            }\r\n-            Class<?>[] interfaces = classToReflect.getInterfaces();\r\n-            for (int i = 0; i < interfaces.length; i++) {\r\n-                populateMethodCacheWithInterface(cache, interfaces[i], log);\r\n-            }\r\n-        }\r\n-        return cache;\r\n+        // Ah, the miracles of Java for(;;) ...\n+        MethodCache cache = new MethodCache();\n+\n+        for (; classToReflect != null; classToReflect = classToReflect.getSuperclass()) {\n+            if (Modifier.isPublic(classToReflect.getModifiers())) {\n+                populateMethodCacheWith(cache, classToReflect, log);\n+            }\n+            Class<?>[] interfaces = classToReflect.getInterfaces();\n+\n+            for (int i = 0; i < interfaces.length; i++) {\n+                populateMethodCacheWithInterface(cache, interfaces[i], log);\n+            }\n+        }\n+        return cache;\n     }\r\n \r\n     /**\r\n@@ -176,15 +190,18 @@ final class ClassMap {\n      * @param cache the cache to fill\r\n      * @param iface the interface to populate the cache from\r\n      * @param log the Log\r\n-     */\r\n-    private static void populateMethodCacheWithInterface(MethodCache cache, Class<?> iface, Log log) {\r\n-        if (Modifier.isPublic(iface.getModifiers())) {\r\n-            populateMethodCacheWith(cache, iface, log);\r\n-        }\r\n-        Class<?>[] supers = iface.getInterfaces();\r\n-        for (int i = 0; i < supers.length; i++) {\r\n-            populateMethodCacheWithInterface(cache, supers[i], log);\r\n-        }\r\n+     */\n+\n+\n+    private static void populateMethodCacheWithInterface(MethodCache cache, Class<?> iface, Log log) {\n+        if (Modifier.isPublic(iface.getModifiers())) {\n+            populateMethodCacheWith(cache, iface, log);\n+        }\n+        Class<?>[] supers = iface.getInterfaces();\n+\n+        for (int i = 0; i < supers.length; i++) {\n+            populateMethodCacheWithInterface(cache, supers[i], log);\n+        }\n     }\r\n \r\n     /**\r\n@@ -192,22 +209,27 @@ final class ClassMap {\n      * @param cache the cache to fill\r\n      * @param clazz the class to populate the cache from\r\n      * @param log the Log\r\n-     */\r\n-    private static void populateMethodCacheWith(MethodCache cache, Class<?> clazz, Log log) {\r\n-        try {\r\n-            Method[] methods = clazz.getDeclaredMethods();\r\n-            for (int i = 0; i < methods.length; i++) {\r\n-                int modifiers = methods[i].getModifiers();\r\n-                if (Modifier.isPublic(modifiers)) {\r\n-                    cache.put(methods[i]);\r\n-                }\r\n-            }\r\n+     */\n+\n+\n+    private static void populateMethodCacheWith(MethodCache cache, Class<?> clazz, Log log) {\n+        try {\n+            Method[] methods = clazz.getDeclaredMethods();\n+\n+            for (int i = 0; i < methods.length; i++) {\n+                int modifiers = methods[i].getModifiers();\n+\n+                if (Modifier.isPublic(modifiers)) {\n+                    cache.put(methods[i]);\n+                }\n+            }\n         } catch (SecurityException se) {\r\n-            // Everybody feels better with...\r\n-            if (log.isDebugEnabled()) {\r\n-                log.debug(\"While accessing methods of \" + clazz + \": \", se);\r\n-            }\r\n-        }\r\n+            // Everybody feels better with...\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"While accessing methods of \" + clazz + \": \",\n+                          se);\n+            }\n+        }\n     }\r\n \r\n     /**\r\n@@ -222,38 +244,42 @@ final class ClassMap {\n      * foo(int,int) & foo(Integer,Integer) since in practise, only the latter form will be used through a call.\r\n      * This of course, applies to all 8 primitive types.\r\n      * </p>\r\n-     */\r\n+     */\n+\n+\n     static final class MethodCache {\r\n         /**\r\n          * A method that returns itself used as a marker for cache miss,\r\n          * allows the underlying cache map to be strongly typed.\r\n          * @return itself as a method\r\n-         */\r\n-        public static Method cacheMiss() {\r\n-            try {\r\n-                return MethodCache.class.getMethod(\"cacheMiss\");\r\n+         */\n+        public static Method cacheMiss() {\n+            try {\n+                return MethodCache.class.getMethod(\"cacheMiss\");\n             } catch (Exception xio) {\r\n-                // this really cant make an error...\r\n-                return null;\r\n-            }\r\n+                // this really cant make an error...\n+                return null;\n+            }\n         }\r\n-        /** The cache miss marker method. */\r\n+        /** The cache miss marker method. */\n+\n+\n         private static final Method CACHE_MISS = cacheMiss();\r\n-        /** The initial size of the primitive conversion map. */\r\n+        /** The initial size of the primitive conversion map. */\n         private static final int PRIMITIVE_SIZE = 13;\r\n-        /** The primitive type to class conversion map. */\r\n-        private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPES;\r\n-\r\n-        static {\r\n-            PRIMITIVE_TYPES = new HashMap<Class<?>, Class<?>>(PRIMITIVE_SIZE);\r\n-            PRIMITIVE_TYPES.put(Boolean.TYPE, Boolean.class);\r\n-            PRIMITIVE_TYPES.put(Byte.TYPE, Byte.class);\r\n-            PRIMITIVE_TYPES.put(Character.TYPE, Character.class);\r\n-            PRIMITIVE_TYPES.put(Double.TYPE, Double.class);\r\n-            PRIMITIVE_TYPES.put(Float.TYPE, Float.class);\r\n-            PRIMITIVE_TYPES.put(Integer.TYPE, Integer.class);\r\n-            PRIMITIVE_TYPES.put(Long.TYPE, Long.class);\r\n-            PRIMITIVE_TYPES.put(Short.TYPE, Short.class);\r\n+        /** The primitive type to class conversion map. */\n+        private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPES;\n+\n+        static {\n+            PRIMITIVE_TYPES = new HashMap<Class<?>, Class<?>>(PRIMITIVE_SIZE);\n+            PRIMITIVE_TYPES.put(Boolean.TYPE, Boolean.class);\n+            PRIMITIVE_TYPES.put(Byte.TYPE, Byte.class);\n+            PRIMITIVE_TYPES.put(Character.TYPE, Character.class);\n+            PRIMITIVE_TYPES.put(Double.TYPE, Double.class);\n+            PRIMITIVE_TYPES.put(Float.TYPE, Float.class);\n+            PRIMITIVE_TYPES.put(Integer.TYPE, Integer.class);\n+            PRIMITIVE_TYPES.put(Long.TYPE, Long.class);\n+            PRIMITIVE_TYPES.put(Short.TYPE, Short.class);\n         }\r\n \r\n         /** Converts a primitive type to its corresponding class.\r\n@@ -265,12 +291,14 @@ final class ClassMap {\n          * </p>\r\n          * @param parm a may-be primitive type class\r\n          * @return the equivalent object class \r\n-         */\r\n+         */\n+\n+\n         static Class<?> primitiveClass(Class<?> parm) {\r\n             // it is marginally faster to get from the map than call isPrimitive...\r\n-            //if (!parm.isPrimitive()) return parm;\r\n-            Class<?> prim = PRIMITIVE_TYPES.get(parm);\r\n-            return prim == null ? parm : prim;\r\n+            //if (!parm.isPrimitive()) return parm;\n+            Class<?> prim = PRIMITIVE_TYPES.get(parm);\n+            return prim == null ? parm : prim;\n         }\r\n         /**\r\n          * The method cache.\r\n@@ -278,11 +306,13 @@ final class ClassMap {\n          * Cache of Methods, or CACHE_MISS, keyed by method\r\n          * name and actual arguments used to find it.\r\n          * </p>\r\n-         */\r\n+         */\n+\n+\n         private final Map<MethodKey, Method> methods = new HashMap<MethodKey, Method>();\r\n         /**\r\n          * Map of methods that are searchable according to method parameters to find a match.\r\n-         */\r\n+         */\n         private final MethodMap methodMap = new MethodMap();\r\n \r\n         /**\r\n@@ -300,78 +330,84 @@ final class ClassMap {\n          * @param methodKey the method key\r\n          * @return A Method object representing the method to invoke or null.\r\n          * @throws MethodKey.AmbiguousException When more than one method is a match for the parameters.\r\n-         */\r\n-        Method get(final MethodKey methodKey) throws MethodKey.AmbiguousException {\r\n-            synchronized (methodMap) {\r\n+         */\n+        Method get(final MethodKey methodKey) throws MethodKey.AmbiguousException {\n+            synchronized (methodMap) {\n                 Method cacheEntry = methods.get(methodKey);\r\n-                // We looked this up before and failed.\r\n-                if (cacheEntry == CACHE_MISS) {\r\n-                    return null;\r\n-                }\r\n-\r\n-                if (cacheEntry == null) {\r\n+                // We looked this up before and failed.\n+\n+                if (cacheEntry == CACHE_MISS) {\n+                    return null;\n+                }\n+                if (cacheEntry == null) {\n                     try {\r\n-                        // That one is expensive...\r\n-                        cacheEntry = methodMap.find(methodKey);\r\n-                        if (cacheEntry != null) {\r\n-                            methods.put(methodKey, cacheEntry);\r\n-                        } else {\r\n-                            methods.put(methodKey, CACHE_MISS);\r\n-                        }\r\n+                        // That one is expensive...\n+                        cacheEntry = methodMap.find(methodKey);\n+\n+                        if (cacheEntry != null) {\n+                            methods.put(methodKey, cacheEntry);\n+                        } else {\n+                            methods.put(methodKey, CACHE_MISS);\n+                        }\n                     } catch (MethodKey.AmbiguousException ae) {\r\n-                        // that's a miss :-)\r\n-                        methods.put(methodKey, CACHE_MISS);\r\n-                        throw ae;\r\n-                    }\r\n+                        // that's a miss :-)\n+                        methods.put(methodKey, CACHE_MISS);\n+                        throw ae;\n+                    }\n                 }\r\n \r\n-                // Yes, this might just be null.\r\n-                return cacheEntry;\r\n-            }\r\n+                // Yes, this might just be null.\n+                return cacheEntry;\n+            }\n         }\r\n \r\n         /**\r\n          * Adds a method to the map.\r\n          * @param method the method to add\r\n-         */\r\n-        void put(Method method) {\r\n-            synchronized (methodMap) {\r\n+         */\n+\n+        void put(Method method) {\n+            synchronized (methodMap) {\n                 MethodKey methodKey = new MethodKey(method);\r\n                 // We don't overwrite methods. Especially not if we fill the\r\n                 // cache from defined class towards java.lang.Object because\r\n                 // abstract methods in superclasses would else overwrite concrete\r\n-                // classes further down the hierarchy.\r\n-                if (methods.get(methodKey) == null) {\r\n-                    methods.put(methodKey, method);\r\n-                    methodMap.add(method);\r\n-                }\r\n-            }\r\n+                // classes further down the hierarchy.\n+\n+                if (methods.get(methodKey) == null) {\n+                    methods.put(methodKey, method);\n+                    methodMap.add(method);\n+                }\n+            }\n         }\r\n \r\n         /**\r\n          * Gets all the method names from this map.\r\n          * @return the array of method name\r\n-         */\r\n-        String[] names() {\r\n-            synchronized (methodMap) {\r\n-                return methodMap.names();\r\n-            }\r\n+         */\n+\n+        String[] names() {\n+            synchronized (methodMap) {\n+                return methodMap.names();\n+            }\n         }\r\n \r\n         /**\r\n          * Gets all the methods with a given name from this map.\r\n          * @param methodName the seeked methods name\r\n          * @return the array of methods (null or non-empty)\r\n-         */\r\n-        Method[] get(final String methodName) {\r\n-            synchronized (methodMap) {\r\n-                List<Method> lm = methodMap.get(methodName);\r\n-                if (lm != null && !lm.isEmpty()) {\r\n-                    return lm.toArray(new Method[lm.size()]);\r\n-                } else {\r\n-                    return null;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n+         */\n+\n+        Method[] get(final String methodName) {\n+            synchronized (methodMap) {\n+                List<Method> lm = methodMap.get(methodName);\n+\n+                if (lm != null && !lm.isEmpty()) {\n+                    return lm.toArray(new Method[lm.size()]);\n+                } else {\n+                    return null;\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 198
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "267",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "265",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/78/ClassMap.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_three_grams/78/ClassMap.java\nindex 121c8b9f099..3a931ac919d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/78/ClassMap.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_three_grams/78/ClassMap.java\n@@ -254,9 +254,7 @@ final class ClassMap {\n             PRIMITIVE_TYPES.put(Integer.TYPE, Integer.class);\r\n             PRIMITIVE_TYPES.put(Long.TYPE, Long.class);\r\n             PRIMITIVE_TYPES.put(Short.TYPE, Short.class);\r\n-        }\r\n-\r\n-        /** Converts a primitive type to its corresponding class.\r\n+        }/** Converts a primitive type to its corresponding class.\r\n          * <p>\r\n          * If the argument type is primitive then we want to convert our\r\n          * primitive type signature to the corresponding Object type so\r\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}