{
    "project_name": "IQSS-dataverse",
    "error_id": "28",
    "information": {
        "errors": [
            {
                "line": "513",
                "column": "5",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "    \n    private WorkflowContext refresh( WorkflowContext ctxt ) {\n    \treturn refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n    }\n\n    private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/28/WorkflowServiceBean.java\nindex 11b2ede9d76..0ba6f80bff4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/28/WorkflowServiceBean.java\n@@ -510,7 +510,7 @@ public class WorkflowServiceBean {\n     }\n     \n     private WorkflowContext refresh( WorkflowContext ctxt ) {\n-    \treturn refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n+    return refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n     }\n \n     private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/28/WorkflowServiceBean.java\nindex 11b2ede9d76..08f257b6541 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/28/WorkflowServiceBean.java\n@@ -51,37 +51,37 @@ import javax.persistence.TypedQuery;\n @Stateless\n public class WorkflowServiceBean {\n \n-    private static final Logger logger = Logger.getLogger(WorkflowServiceBean.class.getName());\n-    private static final String WORKFLOW_ID_KEY = \"WorkflowServiceBean.WorkflowId:\";\n-\n-    @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n-    EntityManager em;\n-    \n-    @EJB\n-    DatasetServiceBean datasets;\n-\n-    @EJB\n-    SettingsServiceBean settings;\n-\n-    @EJB\n-    RoleAssigneeServiceBean roleAssignees;\n-    \n-    @EJB \n-    SystemConfig systemConfig;\n-\n-    @EJB\n-    UserNotificationServiceBean userNotificationService;\n-    \n-    @EJB\n-    EjbDataverseEngine engine;\n-    \n-    @Inject\n-    DataverseRequestServiceBean dvRequestService;\n-    \n-    final Map<String, WorkflowStepSPI> providers = new HashMap<>();\n-\n-    public WorkflowServiceBean() {\n-        providers.put(\":internal\", new InternalWorkflowStepSP());\n+  private static final Logger logger = Logger.getLogger(WorkflowServiceBean.class.getName());\n+  private static final String WORKFLOW_ID_KEY = \"WorkflowServiceBean.WorkflowId:\";\n+\n+  @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n+  EntityManager em;\n+\n+  @EJB\n+  DatasetServiceBean datasets;\n+\n+  @EJB\n+  SettingsServiceBean settings;\n+\n+  @EJB\n+  RoleAssigneeServiceBean roleAssignees;\n+\n+  @EJB\n+  SystemConfig systemConfig;\n+\n+  @EJB\n+  UserNotificationServiceBean userNotificationService;\n+\n+  @EJB\n+  EjbDataverseEngine engine;\n+\n+  @Inject\n+  DataverseRequestServiceBean dvRequestService;\n+\n+  final Map<String, WorkflowStepSPI> providers = new HashMap<>();\n+\n+  public WorkflowServiceBean() {\n+    providers.put(\":internal\", new InternalWorkflowStepSP());\n \n //        Re-enable code below, if we allow .jars in the classpath to provide WorkflowStepProviders.\n //        ServiceLoader<WorkflowStepSPI> loader = ServiceLoader.load(WorkflowStepSPI.class);\n@@ -96,456 +96,474 @@ public class WorkflowServiceBean {\n //        } catch (ServiceConfigurationError serviceError) {\n //            logger.log(Level.WARNING, \"Service Error loading workflow step providers: \" + serviceError.getMessage(), serviceError);\n //        }\n-        \n-    }\n-    \n-    /**\n-     * Starts executing workflow {@code wf} under the passed context.\n-     *\n-     * @param wf the workflow to execute.\n-     * @param ctxt the context in which the workflow is executed.\n-     * @throws CommandException If the dataset could not be locked.\n-     */\n-    //ToDo - should this be @Async? or just the forward() method?\n-    @Asynchronous\n-    public void start(Workflow wf, WorkflowContext ctxt, boolean findDataset) throws CommandException {\n-        /*\n-         * Workflows appear to start running prior to the caller's transaction\n-         * completing which can result in exceptions in setting the lock below. To avoid\n-         * this, there are two work-arounds - wait briefly for that transaction to end,\n-         * or refresh the dataset from the db - so the lock is written based on the\n-         * current db state. The latter works for pre-publication workflows (since the\n-         * only changes to the Dataset in the Publish command are edits to the version\n-         * number in the draft version (which aren't valid for the draft anyway)), while\n-         * the former is required for post-publication workflows which may need to see\n-         * the final version number, update times and other changes made in the Finalize\n-         * Publication command. Not waiting saves significant time when many datasets\n-         * are processed, so is prefereable when it makes sense.\n-         * \n-         * This code should be reconsidered if/when the launching of pre/post\n-         * publication workflows is moved to command onSuccess methods (and when\n-         * onSuccess methods are guaranteed to be after the transaction completes (see\n-         * #7568) or other changes are made that can guarantee the dataset in the\n-         * WorkflowContext is up-to-date/usable in further transactions in the workflow.\n-         * (e.g. if this method is not asynchronous)\n-         * \n-         */\n-\n-        if (!findDataset) {\n-            /*\n-             * Sleep here briefly to make sure the database update from the callers\n-             * transaction completes which avoids any concurrency/optimistic lock issues.\n-             * Note: 1 second appears long enough, but shorter delays may work\n-             */\n-            try {\n-                Thread.sleep(1000);\n-            } catch (Exception ex) {\n-                logger.warning(\"Failed to sleep for a second.\");\n-            }\n-        }\n-        //Refresh will only em.find the dataset if findDataset is true. (otherwise the dataset is em.merged)\n-        ctxt = refresh(ctxt, retrieveRequestedSettings( wf.getRequiredSettings()), getCurrentApiToken(ctxt.getRequest().getAuthenticatedUser()), findDataset);\n-        lockDataset(ctxt, new DatasetLock(DatasetLock.Reason.Workflow, ctxt.getRequest().getAuthenticatedUser()));\n-        forward(wf, ctxt);\n-    }\n-    \n-\n-    private ApiToken getCurrentApiToken(AuthenticatedUser au) {\n-        if (au != null) {\n-            CommandContext ctxt = engine.getContext();\n-            ApiToken token = ctxt.authentication().findApiTokenByUser(au);\n-            if (token == null) {\n-                //No un-expired token\n-                token = ctxt.authentication().generateApiTokenForUser(au);\n-            }\n-            return token;\n-        }\n-        return null;\n-    }\n \n-    private Map<String, Object> retrieveRequestedSettings(Map<String, String> requiredSettings) {\n-        Map<String, Object> retrievedSettings = new HashMap<String, Object>();\n-        for (String setting : requiredSettings.keySet()) {\n-            String settingType = requiredSettings.get(setting);\n-            switch (settingType) {\n-            case \"string\": {\n-                retrievedSettings.put(setting, settings.get(setting));\n-                break;\n-            }\n-            case \"boolean\": {\n-                retrievedSettings.put(setting, settings.isTrue(settingType, false));\n-                break;\n-            }\n-            case \"long\": {\n-                retrievedSettings.put(setting,\n-                        settings.getValueForKeyAsLong(SettingsServiceBean.Key.valueOf(setting)));\n-                break;\n-            }\n-            }\n-        }\n-        return retrievedSettings;\n-    }\n-\n-    /**\n-     * Starting the resume process for a pending workflow. We first delete the\n-     * pending workflow to minimize double invocation, and then asynchronously\n-     * resume the work.\n+  }\n+\n+  /**\n+   * Starts executing workflow {@code wf} under the passed context.\n+   *\n+   * @param wf   the workflow to execute.\n+   * @param ctxt the context in which the workflow is executed.\n+   * @throws CommandException If the dataset could not be locked.\n+   */\n+  //ToDo - should this be @Async? or just the forward() method?\n+  @Asynchronous\n+  public void start(Workflow wf, WorkflowContext ctxt, boolean findDataset) throws CommandException {\n+    /*\n+     * Workflows appear to start running prior to the caller's transaction\n+     * completing which can result in exceptions in setting the lock below. To avoid\n+     * this, there are two work-arounds - wait briefly for that transaction to end,\n+     * or refresh the dataset from the db - so the lock is written based on the\n+     * current db state. The latter works for pre-publication workflows (since the\n+     * only changes to the Dataset in the Publish command are edits to the version\n+     * number in the draft version (which aren't valid for the draft anyway)), while\n+     * the former is required for post-publication workflows which may need to see\n+     * the final version number, update times and other changes made in the Finalize\n+     * Publication command. Not waiting saves significant time when many datasets\n+     * are processed, so is prefereable when it makes sense.\n+     *\n+     * This code should be reconsidered if/when the launching of pre/post\n+     * publication workflows is moved to command onSuccess methods (and when\n+     * onSuccess methods are guaranteed to be after the transaction completes (see\n+     * #7568) or other changes are made that can guarantee the dataset in the\n+     * WorkflowContext is up-to-date/usable in further transactions in the workflow.\n+     * (e.g. if this method is not asynchronous)\n      *\n-     * @param pending The workflow to resume.\n-     * @param body the response from the remote system.\n-     * @see\n-     * #doResume(edu.harvard.iq.dataverse.workflow.PendingWorkflowInvocation,\n-     * java.lang.String)\n      */\n-    @Asynchronous\n-    public void resume(PendingWorkflowInvocation pending, String body) {\n-        em.remove(em.merge(pending));\n-        doResume(pending, body);\n-    }\n-    \n-    \n-    @Asynchronous\n-    private void forward(Workflow wf, WorkflowContext ctxt) {\n-        executeSteps(wf, ctxt, 0);\n+\n+    if (!findDataset) {\n+      /*\n+       * Sleep here briefly to make sure the database update from the callers\n+       * transaction completes which avoids any concurrency/optimistic lock issues.\n+       * Note: 1 second appears long enough, but shorter delays may work\n+       */\n+      try {\n+        Thread.sleep(1000);\n+      } catch (Exception ex) {\n+        logger.warning(\"Failed to sleep for a second.\");\n+      }\n     }\n-    \n-    private void doResume(PendingWorkflowInvocation pending, String body) {\n-        Workflow wf = pending.getWorkflow();\n-        List<WorkflowStepData> stepsLeft = wf.getSteps().subList(pending.getPendingStepIdx(), wf.getSteps().size());\n-        \n-        WorkflowStep pendingStep = createStep(stepsLeft.get(0));\n-        WorkflowContext newCtxt = pending.reCreateContext(roleAssignees);\n-        final WorkflowContext ctxt = refresh(newCtxt,retrieveRequestedSettings( wf.getRequiredSettings()), getCurrentApiToken(newCtxt.getRequest().getAuthenticatedUser()));\n-        WorkflowStepResult res = pendingStep.resume(ctxt, pending.getLocalData(), body);\n-        if (res instanceof Failure) {\n-            logger.warning(((Failure) res).getReason());\n-            userNotificationService.sendNotification(ctxt.getRequest().getAuthenticatedUser(), Timestamp.from(Instant.now()), UserNotification.Type.WORKFLOW_FAILURE, ctxt.getDataset().getLatestVersion().getId(), ((Failure) res).getMessage());\n-            //UserNotification isn't meant to be a long-term record and doesn't store the comment, so we'll also keep it as a workflow comment\n-            WorkflowComment wfc = new WorkflowComment(ctxt.getDataset().getLatestVersion(), WorkflowComment.Type.WORKFLOW_FAILURE, ((Failure) res).getMessage(), ctxt.getRequest().getAuthenticatedUser());\n-            datasets.addWorkflowComment(wfc);\n-            rollback(wf, ctxt, (Failure) res, pending.getPendingStepIdx() - 1);\n-        } else if (res instanceof Pending) {\n-            pauseAndAwait(wf, ctxt, (Pending) res, pending.getPendingStepIdx());\n-        } else {\n-            if (res instanceof Success) {\n-                logger.info(((Success) res).getReason());\n-                userNotificationService.sendNotification(ctxt.getRequest().getAuthenticatedUser(), Timestamp.from(Instant.now()), UserNotification.Type.WORKFLOW_SUCCESS, ctxt.getDataset().getLatestVersion().getId(), ((Success) res).getMessage());\n-                //UserNotification isn't meant to be a long-term record and doesn't store the comment, so we'll also keep it as a workflow comment\n-                WorkflowComment wfc = new WorkflowComment(ctxt.getDataset().getLatestVersion(), WorkflowComment.Type.WORKFLOW_SUCCESS, ((Success) res).getMessage(), ctxt.getRequest().getAuthenticatedUser());\n-                datasets.addWorkflowComment(wfc);\n-        }\n-            executeSteps(wf, ctxt, pending.getPendingStepIdx() + 1);\n-        }\n+    //Refresh will only em.find the dataset if findDataset is true. (otherwise the dataset is em.merged)\n+    ctxt = refresh(ctxt, retrieveRequestedSettings(wf.getRequiredSettings()),\n+      getCurrentApiToken(ctxt.getRequest().getAuthenticatedUser()), findDataset);\n+    lockDataset(ctxt, new DatasetLock(DatasetLock.Reason.Workflow, ctxt.getRequest().getAuthenticatedUser()));\n+    forward(wf, ctxt);\n+  }\n+\n+\n+  private ApiToken getCurrentApiToken(AuthenticatedUser au) {\n+    if (au != null) {\n+      CommandContext ctxt = engine.getContext();\n+      ApiToken token = ctxt.authentication().findApiTokenByUser(au);\n+      if (token == null) {\n+        //No un-expired token\n+        token = ctxt.authentication().generateApiTokenForUser(au);\n+      }\n+      return token;\n     }\n-\n-    @Asynchronous\n-    private void rollback(Workflow wf, WorkflowContext ctxt, Failure failure, int lastCompletedStepIdx) {\n-        ctxt = refresh(ctxt);\n-        final List<WorkflowStepData> steps = wf.getSteps();\n-        \n-        for ( int stepIdx = lastCompletedStepIdx; stepIdx >= 0; --stepIdx ) {\n-            WorkflowStepData wsd = steps.get(stepIdx);\n-            WorkflowStep step = createStep(wsd);\n-            \n-            try {\n-                logger.log(Level.INFO, \"Workflow {0} step {1}: Rollback\", new Object[]{ctxt.getInvocationId(), stepIdx});\n-                rollbackStep(step, ctxt, failure);\n-                \n-            } catch (Exception e) {\n-                logger.log(Level.WARNING, \"Workflow \" + ctxt.getInvocationId() \n-                                          + \" step \" + stepIdx + \": Rollback error: \" + e.getMessage(), e);\n-            }\n-\n+    return null;\n+  }\n+\n+  private Map<String, Object> retrieveRequestedSettings(Map<String, String> requiredSettings) {\n+    Map<String, Object> retrievedSettings = new HashMap<String, Object>();\n+    for (String setting : requiredSettings.keySet()) {\n+      String settingType = requiredSettings.get(setting);\n+      switch (settingType) {\n+        case \"string\": {\n+          retrievedSettings.put(setting, settings.get(setting));\n+          break;\n         }\n-        \n-        logger.log( Level.INFO, \"Removing workflow lock\");\n-        try {\n-            unlockDataset(ctxt);\n-        } catch (CommandException ex) {\n-            logger.log(Level.SEVERE, \"Error restoring dataset locks state after rollback: \" + ex.getMessage(), ex);\n+        case \"boolean\": {\n+          retrievedSettings.put(setting, settings.isTrue(settingType, false));\n+          break;\n         }\n-    }\n-    \n-    /**\n-     * Execute the passed workflow, starting from {@code initialStepIdx}.\n-     * @param wf    The workflow to run.\n-     * @param ctxt  Execution context to run the workflow in.  \n-     * @param initialStepIdx 0-based index of the first step to run.\n-     */\n-    private void executeSteps(Workflow wf, WorkflowContext ctxt, int initialStepIdx ) {\n-        final List<WorkflowStepData> steps = wf.getSteps();\n-        \n-        for ( int stepIdx = initialStepIdx; stepIdx < steps.size(); stepIdx++ ) {\n-            WorkflowStepData wsd = steps.get(stepIdx);\n-            WorkflowStep step = createStep(wsd);\n-            WorkflowStepResult res = runStep(step, ctxt);\n-            \n-            try {\n-                if (res == WorkflowStepResult.OK) {\n-                    logger.log(Level.INFO, \"Workflow {0} step {1}: OK\", new Object[]{ctxt.getInvocationId(), stepIdx});\n-                    em.merge(ctxt.getDataset());\n-                    ctxt = refresh(ctxt);\n-                } else if (res instanceof Failure) {\n-                    logger.log(Level.WARNING, \"Workflow {0} failed: {1}\", new Object[]{ctxt.getInvocationId(), ((Failure) res).getReason()});\n-                    rollback(wf, ctxt, (Failure) res, stepIdx-1 );\n-                    return;\n-\n-                } else if (res instanceof Pending) {\n-                    pauseAndAwait(wf, ctxt, (Pending) res, stepIdx);\n-                    return;\n-                }\n-                \n-            } catch ( Exception e ) {\n-                logger.log(Level.WARNING, \"Workflow {0} step {1}: Uncought exception:\", new Object[]{ctxt.getInvocationId(), e.getMessage()});\n-                logger.log(Level.WARNING, \"Trace:\", e);\n-                rollback(wf, ctxt, (Failure) res, stepIdx-1 );\n-                return;\n-            }\n+        case \"long\": {\n+          retrievedSettings.put(setting,\n+            settings.getValueForKeyAsLong(SettingsServiceBean.Key.valueOf(setting)));\n+          break;\n         }\n-        \n-        workflowCompleted(wf, ctxt);\n-        \n-    }\n-    \n-    //////////////////////////////////////////////////////////////\n-    // Internal methods to run each step in its own transaction.\n-    //\n-    \n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    WorkflowStepResult runStep( WorkflowStep step, WorkflowContext ctxt ) {\n-        return step.run(ctxt);\n-    }\n-    \n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    WorkflowStepResult resumeStep( WorkflowStep step, WorkflowContext ctxt, Map<String,String> localData, String externalData ) {\n-        return step.resume(ctxt, localData, externalData);\n+      }\n     }\n-    \n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    void rollbackStep( WorkflowStep step, WorkflowContext ctxt, Failure reason ) {\n-        step.rollback(ctxt, reason);\n-    }\n-    \n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    void lockDataset(WorkflowContext ctxt, DatasetLock datasetLock) throws CommandException {\n-        /*\n-         * Note that this method directly adds a lock to the database rather than adding\n-         * it via engine.submit(new AddLockCommand(ctxt.getRequest(), ctxt.getDataset(),\n-         * datasetLock)); which would update the dataset's list of locks, etc. An\n-         * em.find() for the dataset would get a Dataset that has an updated list of\n-         * locks, but this copy would not have any changes made in a calling command\n-         * (e.g. for a PostPublication workflow, the fact that the latest version is\n-         * 'released' is not yet in the database.\n-         */\n-        datasetLock.setDataset(ctxt.getDataset());\n-        em.persist(datasetLock);\n-        //flush creates the id\n-        em.flush();\n-        ctxt.setLockId(datasetLock.getId());\n+    return retrievedSettings;\n+  }\n+\n+  /**\n+   * Starting the resume process for a pending workflow. We first delete the\n+   * pending workflow to minimize double invocation, and then asynchronously\n+   * resume the work.\n+   *\n+   * @param pending The workflow to resume.\n+   * @param body    the response from the remote system.\n+   * @see #doResume(edu.harvard.iq.dataverse.workflow.PendingWorkflowInvocation,\n+   * java.lang.String)\n+   */\n+  @Asynchronous\n+  public void resume(PendingWorkflowInvocation pending, String body) {\n+    em.remove(em.merge(pending));\n+    doResume(pending, body);\n+  }\n+\n+\n+  @Asynchronous\n+  private void forward(Workflow wf, WorkflowContext ctxt) {\n+    executeSteps(wf, ctxt, 0);\n+  }\n+\n+  private void doResume(PendingWorkflowInvocation pending, String body) {\n+    Workflow wf = pending.getWorkflow();\n+    List<WorkflowStepData> stepsLeft = wf.getSteps().subList(pending.getPendingStepIdx(), wf.getSteps().size());\n+\n+    WorkflowStep pendingStep = createStep(stepsLeft.get(0));\n+    WorkflowContext newCtxt = pending.reCreateContext(roleAssignees);\n+    final WorkflowContext ctxt = refresh(newCtxt, retrieveRequestedSettings(wf.getRequiredSettings()),\n+      getCurrentApiToken(newCtxt.getRequest().getAuthenticatedUser()));\n+    WorkflowStepResult res = pendingStep.resume(ctxt, pending.getLocalData(), body);\n+    if (res instanceof Failure) {\n+      logger.warning(((Failure) res).getReason());\n+      userNotificationService.sendNotification(ctxt.getRequest().getAuthenticatedUser(), Timestamp.from(Instant.now()),\n+        UserNotification.Type.WORKFLOW_FAILURE, ctxt.getDataset().getLatestVersion().getId(),\n+        ((Failure) res).getMessage());\n+      //UserNotification isn't meant to be a long-term record and doesn't store the comment, so we'll also keep it as a workflow comment\n+      WorkflowComment wfc =\n+        new WorkflowComment(ctxt.getDataset().getLatestVersion(), WorkflowComment.Type.WORKFLOW_FAILURE,\n+          ((Failure) res).getMessage(), ctxt.getRequest().getAuthenticatedUser());\n+      datasets.addWorkflowComment(wfc);\n+      rollback(wf, ctxt, (Failure) res, pending.getPendingStepIdx() - 1);\n+    } else if (res instanceof Pending) {\n+      pauseAndAwait(wf, ctxt, (Pending) res, pending.getPendingStepIdx());\n+    } else {\n+      if (res instanceof Success) {\n+        logger.info(((Success) res).getReason());\n+        userNotificationService\n+          .sendNotification(ctxt.getRequest().getAuthenticatedUser(), Timestamp.from(Instant.now()),\n+            UserNotification.Type.WORKFLOW_SUCCESS, ctxt.getDataset().getLatestVersion().getId(),\n+            ((Success) res).getMessage());\n+        //UserNotification isn't meant to be a long-term record and doesn't store the comment, so we'll also keep it as a workflow comment\n+        WorkflowComment wfc =\n+          new WorkflowComment(ctxt.getDataset().getLatestVersion(), WorkflowComment.Type.WORKFLOW_SUCCESS,\n+            ((Success) res).getMessage(), ctxt.getRequest().getAuthenticatedUser());\n+        datasets.addWorkflowComment(wfc);\n+      }\n+      executeSteps(wf, ctxt, pending.getPendingStepIdx() + 1);\n     }\n+  }\n \n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    void unlockDataset(WorkflowContext ctxt) throws CommandException {\n-        /*\n-         * Since the lockDataset command above directly persists a lock to the database,\n-         * the ctxt.getDataset() is not updated and its list of locks can't be used.\n-         * Using the named query below will find the workflow lock and remove it\n-         * (actually all workflow locks for this Dataset but only one workflow should be\n-         * active).\n-         */\n-        TypedQuery<DatasetLock> lockCounter = em.createNamedQuery(\"DatasetLock.getLocksByDatasetId\", DatasetLock.class);\n-        lockCounter.setParameter(\"datasetId\", ctxt.getDataset().getId());\n-        List<DatasetLock> locks = lockCounter.getResultList();\n-        for (DatasetLock lock : locks) {\n-            if (lock.getReason() == DatasetLock.Reason.Workflow) {\n-                ctxt.getDataset().removeLock(lock);\n-                em.remove(lock);\n-            }\n-        }\n-        em.flush();\n-    }\n-    \n-    //\n-    //\n-    //////////////////////////////////////////////////////////////\n-    \n-    private void pauseAndAwait(Workflow wf, WorkflowContext ctxt, Pending pendingRes, int idx) {\n-        PendingWorkflowInvocation pending = new PendingWorkflowInvocation(wf, ctxt, pendingRes);\n-        pending.setPendingStepIdx(idx);\n-        em.persist(pending);\n-    }\n+  @Asynchronous\n+  private void rollback(Workflow wf, WorkflowContext ctxt, Failure failure, int lastCompletedStepIdx) {\n+    ctxt = refresh(ctxt);\n+    final List<WorkflowStepData> steps = wf.getSteps();\n \n-    private void workflowCompleted(Workflow wf, WorkflowContext ctxt) {\n-        logger.log(Level.INFO, \"Workflow {0} completed.\", ctxt.getInvocationId());\n-        \n-            try {\n-        if ( ctxt.getType() == TriggerType.PrePublishDataset ) {\n-                ctxt = refresh(ctxt);\n-                //Now lock for FinalizePublication - this block mirrors that in PublishDatasetCommand\n-                AuthenticatedUser user = ctxt.getRequest().getAuthenticatedUser();\n-                DatasetLock lock = new DatasetLock(DatasetLock.Reason.finalizePublication, user);\n-                lock.setDataset(ctxt.getDataset());\n-                String currentGlobalIdProtocol = settings.getValueForKey(SettingsServiceBean.Key.Protocol, \"\");\n-                String currentGlobalAuthority= settings.getValueForKey(SettingsServiceBean.Key.Authority, \"\");\n-                String dataFilePIDFormat = settings.getValueForKey(SettingsServiceBean.Key.DataFilePIDFormat, \"DEPENDENT\");\n-                boolean registerGlobalIdsForFiles = \n-                        (currentGlobalIdProtocol.equals(ctxt.getDataset().getProtocol()) || dataFilePIDFormat.equals(\"INDEPENDENT\")) \n-                        && systemConfig.isFilePIDsEnabled();\n-                if ( registerGlobalIdsForFiles ){\n-                    registerGlobalIdsForFiles = currentGlobalAuthority.equals( ctxt.getDataset().getAuthority() );\n-                }\n-                \n-                boolean validatePhysicalFiles = systemConfig.isDatafileValidationOnPublishEnabled();\n-                String info = \"Publishing the dataset; \"; \n-                info += registerGlobalIdsForFiles ? \"Registering PIDs for Datafiles; \" : \"\";\n-                info += validatePhysicalFiles ? \"Validating Datafiles Asynchronously\" : \"\";\n-                lock.setInfo(info);\n-                lockDataset(ctxt, lock);\n-                ctxt.getDataset().addLock(lock);\n-                \n-                unlockDataset(ctxt);\n-                ctxt.setLockId(null); //the workflow lock\n-                //Refreshing merges the dataset\n-                ctxt = refresh(ctxt);\n-                //Then call Finalize\n-                engine.submit(new FinalizeDatasetPublicationCommand(ctxt.getDataset(), ctxt.getRequest(), ctxt.getDatasetExternallyReleased()));\n-            } else {\n-                logger.fine(\"Removing workflow lock\");\n-                unlockDataset(ctxt);\n-            }\n-            } catch (CommandException ex) {\n-                logger.log(Level.SEVERE, \"Exception finalizing workflow \" + ctxt.getInvocationId() +\": \" + ex.getMessage(), ex);\n-                rollback(wf, ctxt, new Failure(\"Exception while finalizing the publication: \" + ex.getMessage()), wf.steps.size()-1);\n-            }\n-        \n-    }\n+    for (int stepIdx = lastCompletedStepIdx; stepIdx >= 0; --stepIdx) {\n+      WorkflowStepData wsd = steps.get(stepIdx);\n+      WorkflowStep step = createStep(wsd);\n+\n+      try {\n+        logger.log(Level.INFO, \"Workflow {0} step {1}: Rollback\", new Object[] {ctxt.getInvocationId(), stepIdx});\n+        rollbackStep(step, ctxt, failure);\n+\n+      } catch (Exception e) {\n+        logger.log(Level.WARNING, \"Workflow \" + ctxt.getInvocationId()\n+          + \" step \" + stepIdx + \": Rollback error: \" + e.getMessage(), e);\n+      }\n \n-    public List<Workflow> listWorkflows() {\n-        return em.createNamedQuery(\"Workflow.listAll\").getResultList();\n     }\n \n-    public Optional<Workflow> getWorkflow(long workflowId) {\n-        return Optional.ofNullable(em.find(Workflow.class, workflowId));\n+    logger.log(Level.INFO, \"Removing workflow lock\");\n+    try {\n+      unlockDataset(ctxt);\n+    } catch (CommandException ex) {\n+      logger.log(Level.SEVERE, \"Error restoring dataset locks state after rollback: \" + ex.getMessage(), ex);\n     }\n+  }\n+\n+  /**\n+   * Execute the passed workflow, starting from {@code initialStepIdx}.\n+   *\n+   * @param wf             The workflow to run.\n+   * @param ctxt           Execution context to run the workflow in.\n+   * @param initialStepIdx 0-based index of the first step to run.\n+   */\n+  private void executeSteps(Workflow wf, WorkflowContext ctxt, int initialStepIdx) {\n+    final List<WorkflowStepData> steps = wf.getSteps();\n+\n+    for (int stepIdx = initialStepIdx; stepIdx < steps.size(); stepIdx++) {\n+      WorkflowStepData wsd = steps.get(stepIdx);\n+      WorkflowStep step = createStep(wsd);\n+      WorkflowStepResult res = runStep(step, ctxt);\n+\n+      try {\n+        if (res == WorkflowStepResult.OK) {\n+          logger.log(Level.INFO, \"Workflow {0} step {1}: OK\", new Object[] {ctxt.getInvocationId(), stepIdx});\n+          em.merge(ctxt.getDataset());\n+          ctxt = refresh(ctxt);\n+        } else if (res instanceof Failure) {\n+          logger.log(Level.WARNING, \"Workflow {0} failed: {1}\",\n+            new Object[] {ctxt.getInvocationId(), ((Failure) res).getReason()});\n+          rollback(wf, ctxt, (Failure) res, stepIdx - 1);\n+          return;\n \n-    public Workflow save(Workflow workflow) {\n-        if (workflow.getId() == null) {\n-            em.persist(workflow);\n-            em.flush();\n-            return workflow;\n-        } else {\n-            return em.merge(workflow);\n+        } else if (res instanceof Pending) {\n+          pauseAndAwait(wf, ctxt, (Pending) res, stepIdx);\n+          return;\n         }\n+\n+      } catch (Exception e) {\n+        logger.log(Level.WARNING, \"Workflow {0} step {1}: Uncought exception:\",\n+          new Object[] {ctxt.getInvocationId(), e.getMessage()});\n+        logger.log(Level.WARNING, \"Trace:\", e);\n+        rollback(wf, ctxt, (Failure) res, stepIdx - 1);\n+        return;\n+      }\n     }\n \n-    /**\n-     * Deletes the workflow with the passed id (if possible).\n-     * @param workflowId id of the workflow to be deleted.\n-     * @return {@code true} iff the workflow was deleted, {@code false} if it was not found.\n-     * @throws IllegalArgumentException iff the workflow is a default workflow.\n+    workflowCompleted(wf, ctxt);\n+\n+  }\n+\n+  //////////////////////////////////////////////////////////////\n+  // Internal methods to run each step in its own transaction.\n+  //\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  WorkflowStepResult runStep(WorkflowStep step, WorkflowContext ctxt) {\n+    return step.run(ctxt);\n+  }\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  WorkflowStepResult resumeStep(WorkflowStep step, WorkflowContext ctxt, Map<String, String> localData,\n+                                String externalData) {\n+    return step.resume(ctxt, localData, externalData);\n+  }\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  void rollbackStep(WorkflowStep step, WorkflowContext ctxt, Failure reason) {\n+    step.rollback(ctxt, reason);\n+  }\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  void lockDataset(WorkflowContext ctxt, DatasetLock datasetLock) throws CommandException {\n+    /*\n+     * Note that this method directly adds a lock to the database rather than adding\n+     * it via engine.submit(new AddLockCommand(ctxt.getRequest(), ctxt.getDataset(),\n+     * datasetLock)); which would update the dataset's list of locks, etc. An\n+     * em.find() for the dataset would get a Dataset that has an updated list of\n+     * locks, but this copy would not have any changes made in a calling command\n+     * (e.g. for a PostPublication workflow, the fact that the latest version is\n+     * 'released' is not yet in the database.\n      */\n-    public boolean deleteWorkflow(long workflowId) {\n-        Optional<Workflow> doomedOpt = getWorkflow(workflowId);\n-        if (doomedOpt.isPresent()) {\n-            // validate that this is not the default workflow\n-            for ( WorkflowContext.TriggerType tp : WorkflowContext.TriggerType.values() ) {\n-                String defaultWorkflowId = settings.get(workflowSettingKey(tp));\n-                if (defaultWorkflowId != null\n-                        && Long.parseLong(defaultWorkflowId) == doomedOpt.get().getId()) {\n-                    throw new IllegalArgumentException(\"Workflow \" + workflowId + \" cannot be deleted as it is the default workflow for trigger \" + tp.name() );\n-                }\n-            }\n-\n-            em.remove(doomedOpt.get());\n-            return true;\n-        } else {\n-            return false;\n-        }\n+    datasetLock.setDataset(ctxt.getDataset());\n+    em.persist(datasetLock);\n+    //flush creates the id\n+    em.flush();\n+    ctxt.setLockId(datasetLock.getId());\n+  }\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  void unlockDataset(WorkflowContext ctxt) throws CommandException {\n+    /*\n+     * Since the lockDataset command above directly persists a lock to the database,\n+     * the ctxt.getDataset() is not updated and its list of locks can't be used.\n+     * Using the named query below will find the workflow lock and remove it\n+     * (actually all workflow locks for this Dataset but only one workflow should be\n+     * active).\n+     */\n+    TypedQuery<DatasetLock> lockCounter = em.createNamedQuery(\"DatasetLock.getLocksByDatasetId\", DatasetLock.class);\n+    lockCounter.setParameter(\"datasetId\", ctxt.getDataset().getId());\n+    List<DatasetLock> locks = lockCounter.getResultList();\n+    for (DatasetLock lock : locks) {\n+      if (lock.getReason() == DatasetLock.Reason.Workflow) {\n+        ctxt.getDataset().removeLock(lock);\n+        em.remove(lock);\n+      }\n     }\n+    em.flush();\n+  }\n \n-    public List<PendingWorkflowInvocation> listPendingInvocations() {\n-        return em.createNamedQuery(\"PendingWorkflowInvocation.listAll\")\n-                .getResultList();\n-    }\n+  //\n+  //\n+  //////////////////////////////////////////////////////////////\n \n-    public PendingWorkflowInvocation getPendingWorkflow(String invocationId) {\n-        return em.find(PendingWorkflowInvocation.class, invocationId);\n-    }\n+  private void pauseAndAwait(Workflow wf, WorkflowContext ctxt, Pending pendingRes, int idx) {\n+    PendingWorkflowInvocation pending = new PendingWorkflowInvocation(wf, ctxt, pendingRes);\n+    pending.setPendingStepIdx(idx);\n+    em.persist(pending);\n+  }\n+\n+  private void workflowCompleted(Workflow wf, WorkflowContext ctxt) {\n+    logger.log(Level.INFO, \"Workflow {0} completed.\", ctxt.getInvocationId());\n \n-    public Optional<Workflow> getDefaultWorkflow( WorkflowContext.TriggerType type ) {\n-        String defaultWorkflowId = settings.get(workflowSettingKey(type));\n-        if (defaultWorkflowId == null) {\n-            return Optional.empty();\n+    try {\n+      if (ctxt.getType() == TriggerType.PrePublishDataset) {\n+        ctxt = refresh(ctxt);\n+        //Now lock for FinalizePublication - this block mirrors that in PublishDatasetCommand\n+        AuthenticatedUser user = ctxt.getRequest().getAuthenticatedUser();\n+        DatasetLock lock = new DatasetLock(DatasetLock.Reason.finalizePublication, user);\n+        lock.setDataset(ctxt.getDataset());\n+        String currentGlobalIdProtocol = settings.getValueForKey(SettingsServiceBean.Key.Protocol, \"\");\n+        String currentGlobalAuthority = settings.getValueForKey(SettingsServiceBean.Key.Authority, \"\");\n+        String dataFilePIDFormat = settings.getValueForKey(SettingsServiceBean.Key.DataFilePIDFormat, \"DEPENDENT\");\n+        boolean registerGlobalIdsForFiles =\n+          (currentGlobalIdProtocol.equals(ctxt.getDataset().getProtocol()) || dataFilePIDFormat.equals(\"INDEPENDENT\"))\n+            && systemConfig.isFilePIDsEnabled();\n+        if (registerGlobalIdsForFiles) {\n+          registerGlobalIdsForFiles = currentGlobalAuthority.equals(ctxt.getDataset().getAuthority());\n         }\n-        return getWorkflow(Long.parseLong(defaultWorkflowId));\n+\n+        boolean validatePhysicalFiles = systemConfig.isDatafileValidationOnPublishEnabled();\n+        String info = \"Publishing the dataset; \";\n+        info += registerGlobalIdsForFiles ? \"Registering PIDs for Datafiles; \" : \"\";\n+        info += validatePhysicalFiles ? \"Validating Datafiles Asynchronously\" : \"\";\n+        lock.setInfo(info);\n+        lockDataset(ctxt, lock);\n+        ctxt.getDataset().addLock(lock);\n+\n+        unlockDataset(ctxt);\n+        ctxt.setLockId(null); //the workflow lock\n+        //Refreshing merges the dataset\n+        ctxt = refresh(ctxt);\n+        //Then call Finalize\n+        engine.submit(new FinalizeDatasetPublicationCommand(ctxt.getDataset(), ctxt.getRequest(),\n+          ctxt.getDatasetExternallyReleased()));\n+      } else {\n+        logger.fine(\"Removing workflow lock\");\n+        unlockDataset(ctxt);\n+      }\n+    } catch (CommandException ex) {\n+      logger.log(Level.SEVERE, \"Exception finalizing workflow \" + ctxt.getInvocationId() + \": \" + ex.getMessage(), ex);\n+      rollback(wf, ctxt, new Failure(\"Exception while finalizing the publication: \" + ex.getMessage()),\n+        wf.steps.size() - 1);\n     }\n \n-    /**\n-     * Sets the workflow of the default it.\n-     *\n-     * @param id Id of the default workflow, or {@code null}, for disabling the\n-     * default workflow.\n-     * @param type type of the workflow.\n-     */\n-    public void setDefaultWorkflowId(WorkflowContext.TriggerType type, Long id) {\n-        String workflowKey = workflowSettingKey(type);\n-        if (id == null) {\n-            settings.delete(workflowKey);\n-        } else {\n-            settings.set(workflowKey, id.toString());\n-        }\n+  }\n+\n+  public List<Workflow> listWorkflows() {\n+    return em.createNamedQuery(\"Workflow.listAll\").getResultList();\n+  }\n+\n+  public Optional<Workflow> getWorkflow(long workflowId) {\n+    return Optional.ofNullable(em.find(Workflow.class, workflowId));\n+  }\n+\n+  public Workflow save(Workflow workflow) {\n+    if (workflow.getId() == null) {\n+      em.persist(workflow);\n+      em.flush();\n+      return workflow;\n+    } else {\n+      return em.merge(workflow);\n     }\n+  }\n+\n+  /**\n+   * Deletes the workflow with the passed id (if possible).\n+   *\n+   * @param workflowId id of the workflow to be deleted.\n+   * @return {@code true} iff the workflow was deleted, {@code false} if it was not found.\n+   * @throws IllegalArgumentException iff the workflow is a default workflow.\n+   */\n+  public boolean deleteWorkflow(long workflowId) {\n+    Optional<Workflow> doomedOpt = getWorkflow(workflowId);\n+    if (doomedOpt.isPresent()) {\n+      // validate that this is not the default workflow\n+      for (WorkflowContext.TriggerType tp : WorkflowContext.TriggerType.values()) {\n+        String defaultWorkflowId = settings.get(workflowSettingKey(tp));\n+        if (defaultWorkflowId != null\n+          && Long.parseLong(defaultWorkflowId) == doomedOpt.get().getId()) {\n+          throw new IllegalArgumentException(\n+            \"Workflow \" + workflowId + \" cannot be deleted as it is the default workflow for trigger \" + tp.name());\n+        }\n+      }\n \n-    private String workflowSettingKey(WorkflowContext.TriggerType type) {\n-        return WORKFLOW_ID_KEY+type.name();\n+      em.remove(doomedOpt.get());\n+      return true;\n+    } else {\n+      return false;\n     }\n+  }\n \n-    private WorkflowStep createStep(WorkflowStepData wsd) {\n-        WorkflowStepSPI provider = providers.get(wsd.getProviderId());\n-        if (provider == null) {\n-            logger.log(Level.SEVERE, \"Cannot find a step provider with id ''{0}''\", wsd.getProviderId());\n-            throw new IllegalArgumentException(\"Bad WorkflowStepSPI id: '\" + wsd.getProviderId() + \"'\");\n-        }\n-        return provider.getStep(wsd.getStepType(), wsd.getStepParameters());\n+  public List<PendingWorkflowInvocation> listPendingInvocations() {\n+    return em.createNamedQuery(\"PendingWorkflowInvocation.listAll\")\n+      .getResultList();\n+  }\n+\n+  public PendingWorkflowInvocation getPendingWorkflow(String invocationId) {\n+    return em.find(PendingWorkflowInvocation.class, invocationId);\n+  }\n+\n+  public Optional<Workflow> getDefaultWorkflow(WorkflowContext.TriggerType type) {\n+    String defaultWorkflowId = settings.get(workflowSettingKey(type));\n+    if (defaultWorkflowId == null) {\n+      return Optional.empty();\n     }\n-    \n-    private WorkflowContext refresh( WorkflowContext ctxt ) {\n-    \treturn refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n+    return getWorkflow(Long.parseLong(defaultWorkflowId));\n+  }\n+\n+  /**\n+   * Sets the workflow of the default it.\n+   *\n+   * @param id   Id of the default workflow, or {@code null}, for disabling the\n+   *             default workflow.\n+   * @param type type of the workflow.\n+   */\n+  public void setDefaultWorkflowId(WorkflowContext.TriggerType type, Long id) {\n+    String workflowKey = workflowSettingKey(type);\n+    if (id == null) {\n+      settings.delete(workflowKey);\n+    } else {\n+      settings.set(workflowKey, id.toString());\n     }\n+  }\n \n-    private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken) {\n-        return refresh(ctxt, settings, apiToken, false);\n-    }\n+  private String workflowSettingKey(WorkflowContext.TriggerType type) {\n+    return WORKFLOW_ID_KEY + type.name();\n+  }\n \n-    private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken,\n-            boolean findDataset) {\n-        /*\n-         * An earlier version of this class used em.find() to 'refresh' the Dataset in\n-         * the context. For a PostPublication workflow, this had the consequence of\n-         * hiding/removing changes to the Dataset made in the\n-         * FinalizeDatasetPublicationCommand (i.e. the fact that the draft version is\n-         * now released and has a version number). It is not clear to me if the em.merge\n-         * below is needed or if it handles the case of resumed workflows. (The overall\n-         * method is needed to allow the context to be updated in the start() method\n-         * with the settings and APItoken retrieved by the WorkflowServiceBean) - JM -\n-         * 9/18.\n-         */\n-        /*\n-         * Introduced the findDataset boolean to optionally revert above change.\n-         * Refreshing the Dataset just before trying to set the workflow lock greatly\n-         * reduces the number of OptimisticLockExceptions. JvM 2/21\n-         */\n-        WorkflowContext newCtxt;\n-        if (findDataset) {\n-            newCtxt = new WorkflowContext(ctxt.getRequest(), datasets.find(ctxt.getDataset().getId()),\n-                    ctxt.getNextVersionNumber(), ctxt.getNextMinorVersionNumber(), ctxt.getType(), settings, apiToken,\n-                    ctxt.getDatasetExternallyReleased(), ctxt.getInvocationId(), ctxt.getLockId());\n-        } else {\n-            newCtxt = new WorkflowContext(ctxt.getRequest(), em.merge(ctxt.getDataset()), ctxt.getNextVersionNumber(),\n-                    ctxt.getNextMinorVersionNumber(), ctxt.getType(), settings, apiToken,\n-                    ctxt.getDatasetExternallyReleased(), ctxt.getInvocationId(), ctxt.getLockId());\n-        }\n-        return newCtxt;\n+  private WorkflowStep createStep(WorkflowStepData wsd) {\n+    WorkflowStepSPI provider = providers.get(wsd.getProviderId());\n+    if (provider == null) {\n+      logger.log(Level.SEVERE, \"Cannot find a step provider with id ''{0}''\", wsd.getProviderId());\n+      throw new IllegalArgumentException(\"Bad WorkflowStepSPI id: '\" + wsd.getProviderId() + \"'\");\n+    }\n+    return provider.getStep(wsd.getStepType(), wsd.getStepParameters());\n+  }\n+\n+  private WorkflowContext refresh(WorkflowContext ctxt) {\n+    return refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n+  }\n+\n+  private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken) {\n+    return refresh(ctxt, settings, apiToken, false);\n+  }\n+\n+  private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken,\n+                                  boolean findDataset) {\n+    /*\n+     * An earlier version of this class used em.find() to 'refresh' the Dataset in\n+     * the context. For a PostPublication workflow, this had the consequence of\n+     * hiding/removing changes to the Dataset made in the\n+     * FinalizeDatasetPublicationCommand (i.e. the fact that the draft version is\n+     * now released and has a version number). It is not clear to me if the em.merge\n+     * below is needed or if it handles the case of resumed workflows. (The overall\n+     * method is needed to allow the context to be updated in the start() method\n+     * with the settings and APItoken retrieved by the WorkflowServiceBean) - JM -\n+     * 9/18.\n+     */\n+    /*\n+     * Introduced the findDataset boolean to optionally revert above change.\n+     * Refreshing the Dataset just before trying to set the workflow lock greatly\n+     * reduces the number of OptimisticLockExceptions. JvM 2/21\n+     */\n+    WorkflowContext newCtxt;\n+    if (findDataset) {\n+      newCtxt = new WorkflowContext(ctxt.getRequest(), datasets.find(ctxt.getDataset().getId()),\n+        ctxt.getNextVersionNumber(), ctxt.getNextMinorVersionNumber(), ctxt.getType(), settings, apiToken,\n+        ctxt.getDatasetExternallyReleased(), ctxt.getInvocationId(), ctxt.getLockId());\n+    } else {\n+      newCtxt = new WorkflowContext(ctxt.getRequest(), em.merge(ctxt.getDataset()), ctxt.getNextVersionNumber(),\n+        ctxt.getNextMinorVersionNumber(), ctxt.getType(), settings, apiToken,\n+        ctxt.getDatasetExternallyReleased(), ctxt.getInvocationId(), ctxt.getLockId());\n     }\n+    return newCtxt;\n+  }\n \n }\n",
            "diff_size": 670
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "170",
                    "column": "21",
                    "severity": "error",
                    "message": "'{' at column 21 should be on the previous line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                },
                {
                    "line": "175",
                    "column": "21",
                    "severity": "error",
                    "message": "'{' at column 21 should be on the previous line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                },
                {
                    "line": "180",
                    "column": "21",
                    "severity": "error",
                    "message": "'{' at column 21 should be on the previous line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/28/WorkflowServiceBean.java\nindex 11b2ede9d76..9c45c00a1d3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/28/WorkflowServiceBean.java\n@@ -24,7 +24,6 @@ import edu.harvard.iq.dataverse.workflow.step.WorkflowStep;\n import edu.harvard.iq.dataverse.workflow.step.WorkflowStepData;\n import edu.harvard.iq.dataverse.workflow.step.WorkflowStepResult;\n import edu.harvard.iq.dataverse.workflows.WorkflowComment;\n-\n import java.sql.Timestamp;\n import java.time.Instant;\n import java.util.HashMap;\n@@ -48,6 +47,8 @@ import javax.persistence.TypedQuery;\n  *\n  * @author michael\n  */\n+\n+\n @Stateless\n public class WorkflowServiceBean {\n \n@@ -56,7 +57,7 @@ public class WorkflowServiceBean {\n \n     @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n     EntityManager em;\n-    \n+\n     @EJB\n     DatasetServiceBean datasets;\n \n@@ -65,19 +66,18 @@ public class WorkflowServiceBean {\n \n     @EJB\n     RoleAssigneeServiceBean roleAssignees;\n-    \n-    @EJB \n+\n+    @EJB\n     SystemConfig systemConfig;\n \n     @EJB\n     UserNotificationServiceBean userNotificationService;\n-    \n+\n     @EJB\n     EjbDataverseEngine engine;\n-    \n+\n     @Inject\n     DataverseRequestServiceBean dvRequestService;\n-    \n     final Map<String, WorkflowStepSPI> providers = new HashMap<>();\n \n     public WorkflowServiceBean() {\n@@ -96,7 +96,6 @@ public class WorkflowServiceBean {\n //        } catch (ServiceConfigurationError serviceError) {\n //            logger.log(Level.WARNING, \"Service Error loading workflow step providers: \" + serviceError.getMessage(), serviceError);\n //        }\n-        \n     }\n     \n     /**\n@@ -107,6 +106,7 @@ public class WorkflowServiceBean {\n      * @throws CommandException If the dataset could not be locked.\n      */\n     //ToDo - should this be @Async? or just the forward() method?\n+\n     @Asynchronous\n     public void start(Workflow wf, WorkflowContext ctxt, boolean findDataset) throws CommandException {\n         /*\n@@ -130,7 +130,6 @@ public class WorkflowServiceBean {\n          * (e.g. if this method is not asynchronous)\n          * \n          */\n-\n         if (!findDataset) {\n             /*\n              * Sleep here briefly to make sure the database update from the callers\n@@ -144,11 +143,10 @@ public class WorkflowServiceBean {\n             }\n         }\n         //Refresh will only em.find the dataset if findDataset is true. (otherwise the dataset is em.merged)\n-        ctxt = refresh(ctxt, retrieveRequestedSettings( wf.getRequiredSettings()), getCurrentApiToken(ctxt.getRequest().getAuthenticatedUser()), findDataset);\n+        ctxt = refresh(ctxt, retrieveRequestedSettings(wf.getRequiredSettings()), getCurrentApiToken(ctxt.getRequest().getAuthenticatedUser()), findDataset);\n         lockDataset(ctxt, new DatasetLock(DatasetLock.Reason.Workflow, ctxt.getRequest().getAuthenticatedUser()));\n         forward(wf, ctxt);\n     }\n-    \n \n     private ApiToken getCurrentApiToken(AuthenticatedUser au) {\n         if (au != null) {\n@@ -168,19 +166,21 @@ public class WorkflowServiceBean {\n         for (String setting : requiredSettings.keySet()) {\n             String settingType = requiredSettings.get(setting);\n             switch (settingType) {\n-            case \"string\": {\n-                retrievedSettings.put(setting, settings.get(setting));\n-                break;\n-            }\n-            case \"boolean\": {\n-                retrievedSettings.put(setting, settings.isTrue(settingType, false));\n-                break;\n-            }\n-            case \"long\": {\n-                retrievedSettings.put(setting,\n-                        settings.getValueForKeyAsLong(SettingsServiceBean.Key.valueOf(setting)));\n-                break;\n-            }\n+                case \"string\":\n+                    {\n+                        retrievedSettings.put(setting, settings.get(setting));\n+                        break;\n+                    }\n+                case \"boolean\":\n+                    {\n+                        retrievedSettings.put(setting, settings.isTrue(settingType, false));\n+                        break;\n+                    }\n+                case \"long\":\n+                    {\n+                        retrievedSettings.put(setting, settings.getValueForKeyAsLong(SettingsServiceBean.Key.valueOf(setting)));\n+                        break;\n+                    }\n             }\n         }\n         return retrievedSettings;\n@@ -197,25 +197,24 @@ public class WorkflowServiceBean {\n      * #doResume(edu.harvard.iq.dataverse.workflow.PendingWorkflowInvocation,\n      * java.lang.String)\n      */\n+\n     @Asynchronous\n     public void resume(PendingWorkflowInvocation pending, String body) {\n         em.remove(em.merge(pending));\n         doResume(pending, body);\n     }\n-    \n-    \n+\n     @Asynchronous\n     private void forward(Workflow wf, WorkflowContext ctxt) {\n         executeSteps(wf, ctxt, 0);\n     }\n-    \n+\n     private void doResume(PendingWorkflowInvocation pending, String body) {\n         Workflow wf = pending.getWorkflow();\n         List<WorkflowStepData> stepsLeft = wf.getSteps().subList(pending.getPendingStepIdx(), wf.getSteps().size());\n-        \n         WorkflowStep pendingStep = createStep(stepsLeft.get(0));\n         WorkflowContext newCtxt = pending.reCreateContext(roleAssignees);\n-        final WorkflowContext ctxt = refresh(newCtxt,retrieveRequestedSettings( wf.getRequiredSettings()), getCurrentApiToken(newCtxt.getRequest().getAuthenticatedUser()));\n+        final WorkflowContext ctxt = refresh(newCtxt, retrieveRequestedSettings(wf.getRequiredSettings()), getCurrentApiToken(newCtxt.getRequest().getAuthenticatedUser()));\n         WorkflowStepResult res = pendingStep.resume(ctxt, pending.getLocalData(), body);\n         if (res instanceof Failure) {\n             logger.warning(((Failure) res).getReason());\n@@ -233,7 +232,7 @@ public class WorkflowServiceBean {\n                 //UserNotification isn't meant to be a long-term record and doesn't store the comment, so we'll also keep it as a workflow comment\n                 WorkflowComment wfc = new WorkflowComment(ctxt.getDataset().getLatestVersion(), WorkflowComment.Type.WORKFLOW_SUCCESS, ((Success) res).getMessage(), ctxt.getRequest().getAuthenticatedUser());\n                 datasets.addWorkflowComment(wfc);\n-        }\n+            }\n             executeSteps(wf, ctxt, pending.getPendingStepIdx() + 1);\n         }\n     }\n@@ -242,23 +241,20 @@ public class WorkflowServiceBean {\n     private void rollback(Workflow wf, WorkflowContext ctxt, Failure failure, int lastCompletedStepIdx) {\n         ctxt = refresh(ctxt);\n         final List<WorkflowStepData> steps = wf.getSteps();\n-        \n-        for ( int stepIdx = lastCompletedStepIdx; stepIdx >= 0; --stepIdx ) {\n+        for (int stepIdx = lastCompletedStepIdx; stepIdx >=0; --stepIdx) {\n             WorkflowStepData wsd = steps.get(stepIdx);\n             WorkflowStep step = createStep(wsd);\n-            \n             try {\n                 logger.log(Level.INFO, \"Workflow {0} step {1}: Rollback\", new Object[]{ctxt.getInvocationId(), stepIdx});\n                 rollbackStep(step, ctxt, failure);\n-                \n             } catch (Exception e) {\n-                logger.log(Level.WARNING, \"Workflow \" + ctxt.getInvocationId() \n-                                          + \" step \" + stepIdx + \": Rollback error: \" + e.getMessage(), e);\n+                logger.log(Level.WARNING,\n+                           \"Workflow \"\n+                               + ctxt.getInvocationId() + \" step \" + stepIdx + \": Rollback error: \" + e.getMessage(),\n+                           e);\n             }\n-\n         }\n-        \n-        logger.log( Level.INFO, \"Removing workflow lock\");\n+        logger.log(Level.INFO, \"Removing workflow lock\");\n         try {\n             unlockDataset(ctxt);\n         } catch (CommandException ex) {\n@@ -272,60 +268,59 @@ public class WorkflowServiceBean {\n      * @param ctxt  Execution context to run the workflow in.  \n      * @param initialStepIdx 0-based index of the first step to run.\n      */\n-    private void executeSteps(Workflow wf, WorkflowContext ctxt, int initialStepIdx ) {\n+\n+    private void executeSteps(Workflow wf, WorkflowContext ctxt, int initialStepIdx) {\n         final List<WorkflowStepData> steps = wf.getSteps();\n-        \n-        for ( int stepIdx = initialStepIdx; stepIdx < steps.size(); stepIdx++ ) {\n+        for (int stepIdx = initialStepIdx; stepIdx < steps.size(); stepIdx++) {\n             WorkflowStepData wsd = steps.get(stepIdx);\n             WorkflowStep step = createStep(wsd);\n             WorkflowStepResult res = runStep(step, ctxt);\n-            \n             try {\n                 if (res == WorkflowStepResult.OK) {\n                     logger.log(Level.INFO, \"Workflow {0} step {1}: OK\", new Object[]{ctxt.getInvocationId(), stepIdx});\n                     em.merge(ctxt.getDataset());\n                     ctxt = refresh(ctxt);\n                 } else if (res instanceof Failure) {\n-                    logger.log(Level.WARNING, \"Workflow {0} failed: {1}\", new Object[]{ctxt.getInvocationId(), ((Failure) res).getReason()});\n-                    rollback(wf, ctxt, (Failure) res, stepIdx-1 );\n+                    logger.log(Level.WARNING,\n+                               \"Workflow {0} failed: {1}\",\n+                           new Object[]{ctxt.getInvocationId(),((Failure) res).getReason()});\n+                    rollback(wf, ctxt, (Failure) res, stepIdx - 1);\n                     return;\n-\n                 } else if (res instanceof Pending) {\n-                    pauseAndAwait(wf, ctxt, (Pending) res, stepIdx);\n-                    return;\n-                }\n-                \n-            } catch ( Exception e ) {\n-                logger.log(Level.WARNING, \"Workflow {0} step {1}: Uncought exception:\", new Object[]{ctxt.getInvocationId(), e.getMessage()});\n+                           pauseAndAwait(wf, ctxt, (Pending) res, stepIdx);\n+                           return;\n+                       }\n+            } catch (Exception e) {\n+                logger.log(Level.WARNING,\n+                           \"Workflow {0} step {1}: Uncought exception:\",\n+                       new Object[]{ctxt.getInvocationId(), e.getMessage()});\n                 logger.log(Level.WARNING, \"Trace:\", e);\n-                rollback(wf, ctxt, (Failure) res, stepIdx-1 );\n+                rollback(wf, ctxt, (Failure) res, stepIdx - 1);\n                 return;\n             }\n         }\n-        \n         workflowCompleted(wf, ctxt);\n-        \n     }\n     \n     //////////////////////////////////////////////////////////////\n     // Internal methods to run each step in its own transaction.\n     //\n-    \n+\n     @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    WorkflowStepResult runStep( WorkflowStep step, WorkflowContext ctxt ) {\n+    WorkflowStepResult runStep(WorkflowStep step, WorkflowContext ctxt) {\n         return step.run(ctxt);\n     }\n-    \n+\n     @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    WorkflowStepResult resumeStep( WorkflowStep step, WorkflowContext ctxt, Map<String,String> localData, String externalData ) {\n+    WorkflowStepResult resumeStep(WorkflowStep step, WorkflowContext ctxt, Map<String, String> localData, String externalData) {\n         return step.resume(ctxt, localData, externalData);\n     }\n-    \n+\n     @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    void rollbackStep( WorkflowStep step, WorkflowContext ctxt, Failure reason ) {\n+    void rollbackStep(WorkflowStep step, WorkflowContext ctxt, Failure reason) {\n         step.rollback(ctxt, reason);\n     }\n-    \n+\n     @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n     void lockDataset(WorkflowContext ctxt, DatasetLock datasetLock) throws CommandException {\n         /*\n@@ -368,7 +363,7 @@ public class WorkflowServiceBean {\n     //\n     //\n     //////////////////////////////////////////////////////////////\n-    \n+\n     private void pauseAndAwait(Workflow wf, WorkflowContext ctxt, Pending pendingRes, int idx) {\n         PendingWorkflowInvocation pending = new PendingWorkflowInvocation(wf, ctxt, pendingRes);\n         pending.setPendingStepIdx(idx);\n@@ -377,32 +372,28 @@ public class WorkflowServiceBean {\n \n     private void workflowCompleted(Workflow wf, WorkflowContext ctxt) {\n         logger.log(Level.INFO, \"Workflow {0} completed.\", ctxt.getInvocationId());\n-        \n-            try {\n-        if ( ctxt.getType() == TriggerType.PrePublishDataset ) {\n+        try {\n+            if (ctxt.getType() == TriggerType.PrePublishDataset) {\n                 ctxt = refresh(ctxt);\n                 //Now lock for FinalizePublication - this block mirrors that in PublishDatasetCommand\n                 AuthenticatedUser user = ctxt.getRequest().getAuthenticatedUser();\n                 DatasetLock lock = new DatasetLock(DatasetLock.Reason.finalizePublication, user);\n                 lock.setDataset(ctxt.getDataset());\n                 String currentGlobalIdProtocol = settings.getValueForKey(SettingsServiceBean.Key.Protocol, \"\");\n-                String currentGlobalAuthority= settings.getValueForKey(SettingsServiceBean.Key.Authority, \"\");\n+                String currentGlobalAuthority = settings.getValueForKey(SettingsServiceBean.Key.Authority, \"\");\n                 String dataFilePIDFormat = settings.getValueForKey(SettingsServiceBean.Key.DataFilePIDFormat, \"DEPENDENT\");\n-                boolean registerGlobalIdsForFiles = \n-                        (currentGlobalIdProtocol.equals(ctxt.getDataset().getProtocol()) || dataFilePIDFormat.equals(\"INDEPENDENT\")) \n-                        && systemConfig.isFilePIDsEnabled();\n-                if ( registerGlobalIdsForFiles ){\n-                    registerGlobalIdsForFiles = currentGlobalAuthority.equals( ctxt.getDataset().getAuthority() );\n+                boolean registerGlobalIdsForFiles = (currentGlobalIdProtocol.equals(ctxt.getDataset().getProtocol()) || dataFilePIDFormat.equals(\"INDEPENDENT\")) && systemConfig.isFilePIDsEnabled();\n+                if (registerGlobalIdsForFiles) {\n+                    registerGlobalIdsForFiles = currentGlobalAuthority.equals(ctxt.getDataset().getAuthority());\n                 }\n-                \n+\n                 boolean validatePhysicalFiles = systemConfig.isDatafileValidationOnPublishEnabled();\n-                String info = \"Publishing the dataset; \"; \n+                String info = \"Publishing the dataset; \";\n                 info += registerGlobalIdsForFiles ? \"Registering PIDs for Datafiles; \" : \"\";\n                 info += validatePhysicalFiles ? \"Validating Datafiles Asynchronously\" : \"\";\n                 lock.setInfo(info);\n                 lockDataset(ctxt, lock);\n                 ctxt.getDataset().addLock(lock);\n-                \n                 unlockDataset(ctxt);\n                 ctxt.setLockId(null); //the workflow lock\n                 //Refreshing merges the dataset\n@@ -413,11 +404,13 @@ public class WorkflowServiceBean {\n                 logger.fine(\"Removing workflow lock\");\n                 unlockDataset(ctxt);\n             }\n-            } catch (CommandException ex) {\n-                logger.log(Level.SEVERE, \"Exception finalizing workflow \" + ctxt.getInvocationId() +\": \" + ex.getMessage(), ex);\n-                rollback(wf, ctxt, new Failure(\"Exception while finalizing the publication: \" + ex.getMessage()), wf.steps.size()-1);\n-            }\n-        \n+        } catch (CommandException ex) {\n+            logger.log(Level.SEVERE, \"Exception finalizing workflow \" + ctxt.getInvocationId() + \": \" + ex.getMessage(), ex);\n+            rollback(wf,\n+ctxt,\n+new Failure(\"Exception while finalizing the publication: \" + ex.getMessage()),\n+wf.steps.size() - 1);\n+        }\n     }\n \n     public List<Workflow> listWorkflows() {\n@@ -444,18 +437,17 @@ public class WorkflowServiceBean {\n      * @return {@code true} iff the workflow was deleted, {@code false} if it was not found.\n      * @throws IllegalArgumentException iff the workflow is a default workflow.\n      */\n+\n     public boolean deleteWorkflow(long workflowId) {\n         Optional<Workflow> doomedOpt = getWorkflow(workflowId);\n         if (doomedOpt.isPresent()) {\n             // validate that this is not the default workflow\n-            for ( WorkflowContext.TriggerType tp : WorkflowContext.TriggerType.values() ) {\n+            for (WorkflowContext.TriggerType tp : WorkflowContext.TriggerType.values()) {\n                 String defaultWorkflowId = settings.get(workflowSettingKey(tp));\n-                if (defaultWorkflowId != null\n-                        && Long.parseLong(defaultWorkflowId) == doomedOpt.get().getId()) {\n-                    throw new IllegalArgumentException(\"Workflow \" + workflowId + \" cannot be deleted as it is the default workflow for trigger \" + tp.name() );\n+                if (defaultWorkflowId != null && Long.parseLong(defaultWorkflowId) == doomedOpt.get().getId()) {\n+                    throw new IllegalArgumentException(\"Workflow \" + workflowId + \" cannot be deleted as it is the default workflow for trigger \" + tp.name());\n                 }\n             }\n-\n             em.remove(doomedOpt.get());\n             return true;\n         } else {\n@@ -464,15 +456,14 @@ public class WorkflowServiceBean {\n     }\n \n     public List<PendingWorkflowInvocation> listPendingInvocations() {\n-        return em.createNamedQuery(\"PendingWorkflowInvocation.listAll\")\n-                .getResultList();\n+        return em.createNamedQuery(\"PendingWorkflowInvocation.listAll\").getResultList();\n     }\n \n     public PendingWorkflowInvocation getPendingWorkflow(String invocationId) {\n         return em.find(PendingWorkflowInvocation.class, invocationId);\n     }\n \n-    public Optional<Workflow> getDefaultWorkflow( WorkflowContext.TriggerType type ) {\n+    public Optional<Workflow> getDefaultWorkflow(WorkflowContext.TriggerType type) {\n         String defaultWorkflowId = settings.get(workflowSettingKey(type));\n         if (defaultWorkflowId == null) {\n             return Optional.empty();\n@@ -487,6 +478,7 @@ public class WorkflowServiceBean {\n      * default workflow.\n      * @param type type of the workflow.\n      */\n+\n     public void setDefaultWorkflowId(WorkflowContext.TriggerType type, Long id) {\n         String workflowKey = workflowSettingKey(type);\n         if (id == null) {\n@@ -497,7 +489,7 @@ public class WorkflowServiceBean {\n     }\n \n     private String workflowSettingKey(WorkflowContext.TriggerType type) {\n-        return WORKFLOW_ID_KEY+type.name();\n+        return WORKFLOW_ID_KEY + type.name();\n     }\n \n     private WorkflowStep createStep(WorkflowStepData wsd) {\n@@ -508,17 +500,16 @@ public class WorkflowServiceBean {\n         }\n         return provider.getStep(wsd.getStepType(), wsd.getStepParameters());\n     }\n-    \n-    private WorkflowContext refresh( WorkflowContext ctxt ) {\n-    \treturn refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n+\n+    private WorkflowContext refresh(WorkflowContext ctxt) {\n+        return refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n     }\n \n     private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken) {\n         return refresh(ctxt, settings, apiToken, false);\n     }\n \n-    private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken,\n-            boolean findDataset) {\n+    private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken, boolean findDataset) {\n         /*\n          * An earlier version of this class used em.find() to 'refresh' the Dataset in\n          * the context. For a PostPublication workflow, this had the consequence of\n@@ -537,15 +528,11 @@ public class WorkflowServiceBean {\n          */\n         WorkflowContext newCtxt;\n         if (findDataset) {\n-            newCtxt = new WorkflowContext(ctxt.getRequest(), datasets.find(ctxt.getDataset().getId()),\n-                    ctxt.getNextVersionNumber(), ctxt.getNextMinorVersionNumber(), ctxt.getType(), settings, apiToken,\n-                    ctxt.getDatasetExternallyReleased(), ctxt.getInvocationId(), ctxt.getLockId());\n+            newCtxt = new WorkflowContext(ctxt.getRequest(), datasets.find(ctxt.getDataset().getId()), ctxt.getNextVersionNumber(), ctxt.getNextMinorVersionNumber(), ctxt.getType(), settings, apiToken, ctxt.getDatasetExternallyReleased(), ctxt.getInvocationId(), ctxt.getLockId());\n         } else {\n-            newCtxt = new WorkflowContext(ctxt.getRequest(), em.merge(ctxt.getDataset()), ctxt.getNextVersionNumber(),\n-                    ctxt.getNextMinorVersionNumber(), ctxt.getType(), settings, apiToken,\n-                    ctxt.getDatasetExternallyReleased(), ctxt.getInvocationId(), ctxt.getLockId());\n+            newCtxt = new WorkflowContext(ctxt.getRequest(), em.merge(ctxt.getDataset()), ctxt.getNextVersionNumber(), ctxt.getNextMinorVersionNumber(), ctxt.getType(), settings, apiToken, ctxt.getDatasetExternallyReleased(), ctxt.getInvocationId(), ctxt.getLockId());\n         }\n         return newCtxt;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 117
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/28/WorkflowServiceBean.java\nindex 11b2ede9d76..0ba6f80bff4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/28/WorkflowServiceBean.java\n@@ -510,7 +510,7 @@ public class WorkflowServiceBean {\n     }\n     \n     private WorkflowContext refresh( WorkflowContext ctxt ) {\n-    \treturn refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n+    return refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n     }\n \n     private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/28/WorkflowServiceBean.java\nindex 11b2ede9d76..fe73c521f57 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/28/WorkflowServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/28/WorkflowServiceBean.java\n@@ -510,7 +510,7 @@ public class WorkflowServiceBean {\n     }\n     \n     private WorkflowContext refresh( WorkflowContext ctxt ) {\n-    \treturn refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n+        return refresh(ctxt, ctxt.getSettings(), ctxt.getApiToken());\n     }\n \n     private WorkflowContext refresh(WorkflowContext ctxt, Map<String, Object> settings, ApiToken apiToken) {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}