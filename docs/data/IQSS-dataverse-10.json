{
    "project_name": "IQSS-dataverse",
    "error_id": "10",
    "information": {
        "errors": [
            {
                "line": "39",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "public class DataAccess {\n\n\tprivate static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n\t\n    public DataAccess() {\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "40",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/10/DataAccess.java\nindex a422a825259..8b120a36dcb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/10/DataAccess.java\n@@ -36,7 +36,7 @@ import org.apache.commons.lang3.StringUtils;\n \n public class DataAccess {\n \n-\tprivate static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n+private static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n \t\n     public DataAccess() {\n \n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/10/DataAccess.java\nindex a422a825259..81cc449caaa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/10/DataAccess.java\n@@ -28,226 +28,232 @@ import java.util.Properties;\n import java.util.logging.Logger;\n \n import org.apache.commons.lang3.StringUtils;\n+\n /**\n- *\n  * @author Leonid Andreev\n  */\n \n \n public class DataAccess {\n \n-\tprivate static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n-\t\n-    public DataAccess() {\n+  private static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n+\n+  public DataAccess() {\n+\n+  }\n+\n+  ;\n+\n+  //Default to \"file\" is for tests only\n+  public static final String DEFAULT_STORAGE_DRIVER_IDENTIFIER =\n+    System.getProperty(\"dataverse.files.storage-driver-id\", \"file\");\n+  public static final String UNDEFINED_STORAGE_DRIVER_IDENTIFIER = \"undefined\";\n+    //Used in dataverse.xhtml as a non-null selection option value (indicating a null driver/inheriting the default)\n+\n+  // The getStorageIO() methods initialize StorageIO objects for\n+  // datafiles that are already saved using one of the supported Dataverse\n+  // DataAccess IO drivers.\n+  public static <T extends DvObject> StorageIO<T> getStorageIO(T dvObject) throws IOException {\n+    return getStorageIO(dvObject, null);\n+  }\n \n-    };\n+  //passing DVObject instead of a datafile to accomodate for use of datafiles as well as datasets\n+  public static <T extends DvObject> StorageIO<T> getStorageIO(T dvObject, DataAccessRequest req) throws IOException {\n \n-    //Default to \"file\" is for tests only\n-    public static final String DEFAULT_STORAGE_DRIVER_IDENTIFIER = System.getProperty(\"dataverse.files.storage-driver-id\", \"file\");\n-    public static final String UNDEFINED_STORAGE_DRIVER_IDENTIFIER = \"undefined\"; //Used in dataverse.xhtml as a non-null selection option value (indicating a null driver/inheriting the default)\n-    \n-    // The getStorageIO() methods initialize StorageIO objects for\n-    // datafiles that are already saved using one of the supported Dataverse\n-    // DataAccess IO drivers.\n-    public static <T extends DvObject> StorageIO<T> getStorageIO(T dvObject) throws IOException {\n-        return getStorageIO(dvObject, null);\n+    if (dvObject == null\n+      || dvObject.getStorageIdentifier() == null\n+      || dvObject.getStorageIdentifier().isEmpty()) {\n+      throw new IOException(\"getDataAccessObject: null or invalid datafile.\");\n+    }\n+    String storageIdentifier = dvObject.getStorageIdentifier();\n+    int separatorIndex = storageIdentifier.indexOf(\"://\");\n+    String storageDriverId = DEFAULT_STORAGE_DRIVER_IDENTIFIER; //default\n+    if (separatorIndex > 0) {\n+      storageDriverId = storageIdentifier.substring(0, separatorIndex);\n+    }\n+    String storageType = getDriverType(storageDriverId);\n+    switch (storageType) {\n+      case \"file\":\n+        return new FileAccessIO<>(dvObject, req, storageDriverId);\n+      case \"s3\":\n+        return new S3AccessIO<>(dvObject, req, storageDriverId);\n+      case \"swift\":\n+        return new SwiftAccessIO<>(dvObject, req, storageDriverId);\n+      case \"tmp\":\n+        throw new IOException(\"DataAccess IO attempted on a temporary file that hasn't been permanently saved yet.\");\n     }\n \n-    //passing DVObject instead of a datafile to accomodate for use of datafiles as well as datasets\n-    public static <T extends DvObject> StorageIO<T> getStorageIO(T dvObject, DataAccessRequest req) throws IOException {\n+    // TODO:\n+    // This code will need to be extended with a system of looking up\n+    // available storage plugins by the storage tag embedded in the\n+    // \"storage identifier\".\n+    // -- L.A. 4.0.2\n \n-        if (dvObject == null\n-                || dvObject.getStorageIdentifier() == null\n-            || dvObject.getStorageIdentifier().isEmpty()) {\n-            throw new IOException(\"getDataAccessObject: null or invalid datafile.\");\n-        }\n-        String storageIdentifier = dvObject.getStorageIdentifier();\n-        int separatorIndex = storageIdentifier.indexOf(\"://\");\n-    \tString storageDriverId = DEFAULT_STORAGE_DRIVER_IDENTIFIER; //default\n-        if(separatorIndex>0) {\n-        \tstorageDriverId = storageIdentifier.substring(0,separatorIndex);\n-        }\n-        String storageType = getDriverType(storageDriverId);\n-        switch(storageType) {\n-        case \"file\":\n-            return new FileAccessIO<>(dvObject, req, storageDriverId);\n-        case \"s3\":\n-            return new S3AccessIO<>(dvObject, req, storageDriverId);\n-        case \"swift\":\n-            return new SwiftAccessIO<>(dvObject, req, storageDriverId);\n-        case \"tmp\":\n-        \tthrow new IOException(\"DataAccess IO attempted on a temporary file that hasn't been permanently saved yet.\");\n-        }\n+    logger.warning(\"Could not find storage driver for: \" + storageIdentifier);\n+    throw new IOException(\"getDataAccessObject: Unsupported storage method.\");\n+  }\n \n-        // TODO:\n-        // This code will need to be extended with a system of looking up\n-        // available storage plugins by the storage tag embedded in the\n-        // \"storage identifier\".\n-        // -- L.A. 4.0.2\n-\n-        logger.warning(\"Could not find storage driver for: \" + storageIdentifier);\n-        throw new IOException(\"getDataAccessObject: Unsupported storage method.\");\n-    }\n-\n-    // Experimental extension of the StorageIO system allowing direct access to\n-    // stored physical files that may not be associated with any DvObjects\n-\n-    public static StorageIO<DvObject> getDirectStorageIO(String fullStorageLocation) throws IOException {\n-    \tString[] response = getDriverIdAndStorageLocation(fullStorageLocation);\n-    \tString storageDriverId = response[0];\n-    \tString storageLocation=response[1];\n-        String storageType = getDriverType(storageDriverId);\n-        switch(storageType) {\n-        case \"file\":\n-            return new FileAccessIO<>(storageLocation, storageDriverId);\n-        case \"s3\":\n-            return new S3AccessIO<>(storageLocation, storageDriverId);\n-        case \"swift\":\n-            return new SwiftAccessIO<>(storageLocation, storageDriverId);\n-        default:\n-        \tlogger.warning(\"Could not find storage driver for: \" + fullStorageLocation);\n-        \tthrow new IOException(\"getDirectStorageIO: Unsupported storage method.\");\n-        }\n+  // Experimental extension of the StorageIO system allowing direct access to\n+  // stored physical files that may not be associated with any DvObjects\n+\n+  public static StorageIO<DvObject> getDirectStorageIO(String fullStorageLocation) throws IOException {\n+    String[] response = getDriverIdAndStorageLocation(fullStorageLocation);\n+    String storageDriverId = response[0];\n+    String storageLocation = response[1];\n+    String storageType = getDriverType(storageDriverId);\n+    switch (storageType) {\n+      case \"file\":\n+        return new FileAccessIO<>(storageLocation, storageDriverId);\n+      case \"s3\":\n+        return new S3AccessIO<>(storageLocation, storageDriverId);\n+      case \"swift\":\n+        return new SwiftAccessIO<>(storageLocation, storageDriverId);\n+      default:\n+        logger.warning(\"Could not find storage driver for: \" + fullStorageLocation);\n+        throw new IOException(\"getDirectStorageIO: Unsupported storage method.\");\n     }\n-    \n-    public static String[] getDriverIdAndStorageLocation(String storageLocation) {\n-    \t//default if no prefix\n-    \tString storageIdentifier=storageLocation;\n-        int separatorIndex = storageLocation.indexOf(\"://\");\n-    \tString storageDriverId = \"\"; //default\n-        if(separatorIndex>0) {\n-        \tstorageDriverId = storageLocation.substring(0,separatorIndex);\n-        \tstorageIdentifier = storageLocation.substring(separatorIndex + 3);\n-        }\n-\t\treturn new String[]{storageDriverId, storageIdentifier};\n-    }\n-    \n-    public static String getStorarageIdFromLocation(String location) {\n-    \tif(location.contains(\"://\")) {\n-    \t\t//It's a full location with a driverId, so strip and reapply the driver id\n-    \t\t//NOte that this will strip the bucketname out (which s3 uses) but the S3IOStorage class knows to look at re-insert it\n-    \t\treturn location.substring(0,location.indexOf(\"://\") +3) + location.substring(location.lastIndexOf('/')+1); \n-    \t}\n-    \treturn location.substring(location.lastIndexOf('/')+1);\n-    }\n-    \n-    public static String getDriverType(String driverId) {\n-    \tif(driverId.isEmpty() || driverId.equals(\"tmp\")) {\n-    \t\treturn \"tmp\";\n-    \t}\n-    \treturn System.getProperty(\"dataverse.files.\" + driverId + \".type\", \"Undefined\");\n-    }\n-\n-    // createDataAccessObject() methods create a *new*, empty DataAccess objects,\n-    // for saving new, not yet saved datafiles.\n-    public static <T extends DvObject> StorageIO<T> createNewStorageIO(T dvObject, String storageTag) throws IOException {\n-        if (dvObject == null\n-        \t\t|| dvObject.getDataverseContext()==null\n-                || storageTag == null\n-                || storageTag.isEmpty()) {\n-            throw new IOException(\"getDataAccessObject: null or invalid datafile.\");\n-        }\n-                \n-        if (dvObject instanceof Dataset) {\n-            return createNewStorageIO(dvObject, storageTag, ((Dataset)dvObject).getEffectiveStorageDriverId());\n-        } \n-        // it's a DataFile:\n-        return createNewStorageIO(dvObject, storageTag, dvObject.getOwner().getEffectiveStorageDriverId());\n-    }\n-\n-    public static <T extends DvObject> StorageIO<T> createNewStorageIO(T dvObject, String storageTag, String storageDriverId) throws IOException {\n-        if (dvObject == null\n-                || storageTag == null\n-                || storageTag.isEmpty()) {\n-            throw new IOException(\"getDataAccessObject: null or invalid datafile.\");\n-        }\n-        \n-        /* Prior versions sometimes called createNewStorageIO(object, \"placeholder\") with an existing object to get a ~clone for use in storing/reading Aux files\n-         * Since PR #6488 for multi-store - this can return a clone using a different store than the original (e.g. if the default store changes) which causes errors\n-         * This if will catch any cases where that's attempted.\n-         */\n-        // Tests send objects with no storageIdentifier set\n-        if((dvObject.getStorageIdentifier()!=null) && dvObject.getStorageIdentifier().contains(\"://\")) {\n-        \tthrow new IOException(\"Attempt to create new StorageIO for already stored object: \" + dvObject.getStorageIdentifier());\n-        }\n+  }\n \n-        StorageIO<T> storageIO = null;\n-        \n-        dvObject.setStorageIdentifier(storageTag);\n+  public static String[] getDriverIdAndStorageLocation(String storageLocation) {\n+    //default if no prefix\n+    String storageIdentifier = storageLocation;\n+    int separatorIndex = storageLocation.indexOf(\"://\");\n+    String storageDriverId = \"\"; //default\n+    if (separatorIndex > 0) {\n+      storageDriverId = storageLocation.substring(0, separatorIndex);\n+      storageIdentifier = storageLocation.substring(separatorIndex + 3);\n+    }\n+    return new String[] {storageDriverId, storageIdentifier};\n+  }\n \n-        if (StringUtils.isBlank(storageDriverId)) {\n-        \tstorageDriverId = DEFAULT_STORAGE_DRIVER_IDENTIFIER;\n-        }\n-        String storageType = getDriverType(storageDriverId);\n-        switch(storageType) {\n-        case \"file\":\n-        \tstorageIO = new FileAccessIO<>(dvObject, null, storageDriverId);\n-        \tbreak;\n-        case \"swift\":\n-        \tstorageIO = new SwiftAccessIO<>(dvObject, null, storageDriverId);\n-        \tbreak;\n-        case \"s3\":\n-        \tstorageIO = new S3AccessIO<>(dvObject, null, storageDriverId);\n-        \tbreak;\n-        default:\n-        \tlogger.warning(\"Could not find storage driver for: \" + storageTag);\n-        \tthrow new IOException(\"createDataAccessObject: Unsupported storage method \" + storageDriverId);\n+  public static String getStorarageIdFromLocation(String location) {\n+    if (location.contains(\"://\")) {\n+      //It's a full location with a driverId, so strip and reapply the driver id\n+      //NOte that this will strip the bucketname out (which s3 uses) but the S3IOStorage class knows to look at re-insert it\n+      return location.substring(0, location.indexOf(\"://\") + 3) + location.substring(location.lastIndexOf('/') + 1);\n+    }\n+    return location.substring(location.lastIndexOf('/') + 1);\n+  }\n+\n+  public static String getDriverType(String driverId) {\n+    if (driverId.isEmpty() || driverId.equals(\"tmp\")) {\n+      return \"tmp\";\n+    }\n+    return System.getProperty(\"dataverse.files.\" + driverId + \".type\", \"Undefined\");\n+  }\n+\n+  // createDataAccessObject() methods create a *new*, empty DataAccess objects,\n+  // for saving new, not yet saved datafiles.\n+  public static <T extends DvObject> StorageIO<T> createNewStorageIO(T dvObject, String storageTag) throws IOException {\n+    if (dvObject == null\n+      || dvObject.getDataverseContext() == null\n+      || storageTag == null\n+      || storageTag.isEmpty()) {\n+      throw new IOException(\"getDataAccessObject: null or invalid datafile.\");\n+    }\n+\n+    if (dvObject instanceof Dataset) {\n+      return createNewStorageIO(dvObject, storageTag, ((Dataset) dvObject).getEffectiveStorageDriverId());\n+    }\n+    // it's a DataFile:\n+    return createNewStorageIO(dvObject, storageTag, dvObject.getOwner().getEffectiveStorageDriverId());\n+  }\n+\n+  public static <T extends DvObject> StorageIO<T> createNewStorageIO(T dvObject, String storageTag,\n+                                                                     String storageDriverId) throws IOException {\n+    if (dvObject == null\n+      || storageTag == null\n+      || storageTag.isEmpty()) {\n+      throw new IOException(\"getDataAccessObject: null or invalid datafile.\");\n+    }\n+\n+    /* Prior versions sometimes called createNewStorageIO(object, \"placeholder\") with an existing object to get a ~clone for use in storing/reading Aux files\n+     * Since PR #6488 for multi-store - this can return a clone using a different store than the original (e.g. if the default store changes) which causes errors\n+     * This if will catch any cases where that's attempted.\n+     */\n+    // Tests send objects with no storageIdentifier set\n+    if ((dvObject.getStorageIdentifier() != null) && dvObject.getStorageIdentifier().contains(\"://\")) {\n+      throw new IOException(\n+        \"Attempt to create new StorageIO for already stored object: \" + dvObject.getStorageIdentifier());\n+    }\n+\n+    StorageIO<T> storageIO = null;\n+\n+    dvObject.setStorageIdentifier(storageTag);\n+\n+    if (StringUtils.isBlank(storageDriverId)) {\n+      storageDriverId = DEFAULT_STORAGE_DRIVER_IDENTIFIER;\n+    }\n+    String storageType = getDriverType(storageDriverId);\n+    switch (storageType) {\n+      case \"file\":\n+        storageIO = new FileAccessIO<>(dvObject, null, storageDriverId);\n+        break;\n+      case \"swift\":\n+        storageIO = new SwiftAccessIO<>(dvObject, null, storageDriverId);\n+        break;\n+      case \"s3\":\n+        storageIO = new S3AccessIO<>(dvObject, null, storageDriverId);\n+        break;\n+      default:\n+        logger.warning(\"Could not find storage driver for: \" + storageTag);\n+        throw new IOException(\"createDataAccessObject: Unsupported storage method \" + storageDriverId);\n+    }\n+    // Note: All storageIO classes must assure that dvObject instances' storageIdentifiers are prepended with\n+    // the <driverId>:// + any additional storageIO type information required (e.g. the bucketname for s3/swift)\n+    // This currently happens when the storageIO is opened for write access\n+    storageIO.open(DataAccessOption.WRITE_ACCESS);\n+    return storageIO;\n+  }\n+\n+  static HashMap<String, String> drivers = null;\n+\n+  public static String getStorageDriverId(String driverLabel) {\n+    if (drivers == null) {\n+      populateDrivers();\n+    }\n+    if (!StringUtils.isBlank(driverLabel) && drivers.containsKey(driverLabel)) {\n+      return drivers.get(driverLabel);\n+    }\n+    return DEFAULT_STORAGE_DRIVER_IDENTIFIER;\n+  }\n+\n+  public static HashMap<String, String> getStorageDriverLabels() {\n+    if (drivers == null) {\n+      populateDrivers();\n+    }\n+    return drivers;\n+  }\n+\n+  private static void populateDrivers() {\n+    drivers = new HashMap<String, String>();\n+    Properties p = System.getProperties();\n+    for (String property : p.stringPropertyNames()) {\n+      if (property.startsWith(\"dataverse.files.\") && property.endsWith(\".label\")) {\n+        String driverId = property.substring(16); // \"dataverse.files.\".length\n+        driverId = driverId.substring(0, driverId.indexOf('.'));\n+        logger.info(\"Found Storage Driver: \" + driverId + \" for \" + p.get(property).toString());\n+        drivers.put(p.get(property).toString(), driverId);\n+      }\n+    }\n+  }\n+\n+  public static String getStorageDriverLabelFor(String storageDriverId) {\n+    String label = null;\n+    if (!StringUtils.isEmpty(storageDriverId)) {\n+      if (drivers == null) {\n+        populateDrivers();\n+      }\n+\n+      if (drivers.containsValue(storageDriverId)) {\n+        for (String key : drivers.keySet()) {\n+          if (drivers.get(key).equals(storageDriverId)) {\n+            label = key;\n+            break;\n+          }\n         }\n-        // Note: All storageIO classes must assure that dvObject instances' storageIdentifiers are prepended with \n-        // the <driverId>:// + any additional storageIO type information required (e.g. the bucketname for s3/swift)\n-        // This currently happens when the storageIO is opened for write access\n-        storageIO.open(DataAccessOption.WRITE_ACCESS);\n-        return storageIO;\n-    }\n-\n-    static HashMap<String, String> drivers = null;\n-    \n-    public static String getStorageDriverId(String driverLabel) {\n-    \tif (drivers==null) {\n-    \t\tpopulateDrivers();\n-    \t}\n-    \tif(!StringUtils.isBlank(driverLabel) && drivers.containsKey(driverLabel)) {\n-    \t\treturn drivers.get(driverLabel);\n-    \t} \n-    \treturn DEFAULT_STORAGE_DRIVER_IDENTIFIER;\n-    }\n-\n-    public static HashMap<String, String> getStorageDriverLabels() {\n-    \tif (drivers==null) {\n-    \t\tpopulateDrivers();\n-    \t}\n-    \treturn drivers;\n-    }\n-\n-    private static void populateDrivers() {\n-    \tdrivers = new HashMap<String, String>();\n-    \tProperties p = System.getProperties();\n-    \tfor(String property: p.stringPropertyNames()) {\n-    \t\tif(property.startsWith(\"dataverse.files.\") && property.endsWith(\".label\")) {\n-    \t\t\tString driverId = property.substring(16); // \"dataverse.files.\".length\n-    \t\t\tdriverId=driverId.substring(0,driverId.indexOf('.'));\n-    \t\t\tlogger.info(\"Found Storage Driver: \" + driverId + \" for \" + p.get(property).toString());\n-    \t\t\tdrivers.put(p.get(property).toString(), driverId);\n-    \t\t}\n-    \t}\n-    }\n-\n-    public static String getStorageDriverLabelFor(String storageDriverId) {\n-    \tString label = null;\n-    \tif(!StringUtils.isEmpty(storageDriverId)) {\n-    \t\tif (drivers==null) {\n-    \t\t\tpopulateDrivers();\n-    \t\t}\n-\n-    \t\tif(drivers.containsValue(storageDriverId)) {\n-    \t\t\tfor(String key: drivers.keySet()) {\n-    \t\t\t\tif(drivers.get(key).equals(storageDriverId)) {\n-    \t\t\t\t\tlabel = key;\n-    \t\t\t\t\tbreak;\n-    \t\t\t\t}\n-    \t\t\t}\n-    \t\t}\n-    \t}\n-    \treturn label;\n+      }\n     }\n+    return label;\n+  }\n }\n",
            "diff_size": 356
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/10/DataAccess.java\nindex a422a825259..230481c4dc3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/10/DataAccess.java\n@@ -26,7 +26,6 @@ import java.io.IOException;\n import java.util.HashMap;\n import java.util.Properties;\n import java.util.logging.Logger;\n-\n import org.apache.commons.lang3.StringUtils;\n /**\n  *\n@@ -36,47 +35,48 @@ import org.apache.commons.lang3.StringUtils;\n \n public class DataAccess {\n \n-\tprivate static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n-\t\n-    public DataAccess() {\n+    private static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n \n-    };\n+    public DataAccess() {};\n \n     //Default to \"file\" is for tests only\n+\n     public static final String DEFAULT_STORAGE_DRIVER_IDENTIFIER = System.getProperty(\"dataverse.files.storage-driver-id\", \"file\");\n+\n     public static final String UNDEFINED_STORAGE_DRIVER_IDENTIFIER = \"undefined\"; //Used in dataverse.xhtml as a non-null selection option value (indicating a null driver/inheriting the default)\n     \n     // The getStorageIO() methods initialize StorageIO objects for\n     // datafiles that are already saved using one of the supported Dataverse\n     // DataAccess IO drivers.\n+\n     public static <T extends DvObject> StorageIO<T> getStorageIO(T dvObject) throws IOException {\n         return getStorageIO(dvObject, null);\n     }\n \n     //passing DVObject instead of a datafile to accomodate for use of datafiles as well as datasets\n-    public static <T extends DvObject> StorageIO<T> getStorageIO(T dvObject, DataAccessRequest req) throws IOException {\n \n-        if (dvObject == null\n-                || dvObject.getStorageIdentifier() == null\n-            || dvObject.getStorageIdentifier().isEmpty()) {\n+    public static <T extends DvObject> StorageIO<T> getStorageIO(T dvObject, DataAccessRequest req) throws IOException {\n+        if (dvObject == null || dvObject.getStorageIdentifier() == null || dvObject.getStorageIdentifier().isEmpty()) {\n             throw new IOException(\"getDataAccessObject: null or invalid datafile.\");\n         }\n+\n         String storageIdentifier = dvObject.getStorageIdentifier();\n         int separatorIndex = storageIdentifier.indexOf(\"://\");\n-    \tString storageDriverId = DEFAULT_STORAGE_DRIVER_IDENTIFIER; //default\n-        if(separatorIndex>0) {\n-        \tstorageDriverId = storageIdentifier.substring(0,separatorIndex);\n+        String storageDriverId = DEFAULT_STORAGE_DRIVER_IDENTIFIER; //default\n+        if (separatorIndex > 0) {\n+            storageDriverId = storageIdentifier.substring(0, separatorIndex);\n         }\n+\n         String storageType = getDriverType(storageDriverId);\n-        switch(storageType) {\n-        case \"file\":\n-            return new FileAccessIO<>(dvObject, req, storageDriverId);\n-        case \"s3\":\n-            return new S3AccessIO<>(dvObject, req, storageDriverId);\n-        case \"swift\":\n-            return new SwiftAccessIO<>(dvObject, req, storageDriverId);\n-        case \"tmp\":\n-        \tthrow new IOException(\"DataAccess IO attempted on a temporary file that hasn't been permanently saved yet.\");\n+        switch (storageType) {\n+            case \"file\":\n+                return new FileAccessIO<>(dvObject, req, storageDriverId);\n+            case \"s3\":\n+                return new S3AccessIO<>(dvObject, req, storageDriverId);\n+            case \"swift\":\n+                return new SwiftAccessIO<>(dvObject, req, storageDriverId);\n+            case \"tmp\":\n+                throw new IOException(\"DataAccess IO attempted on a temporary file that hasn't been permanently saved yet.\");\n         }\n \n         // TODO:\n@@ -84,7 +84,6 @@ public class DataAccess {\n         // available storage plugins by the storage tag embedded in the\n         // \"storage identifier\".\n         // -- L.A. 4.0.2\n-\n         logger.warning(\"Could not find storage driver for: \" + storageIdentifier);\n         throw new IOException(\"getDataAccessObject: Unsupported storage method.\");\n     }\n@@ -93,72 +92,69 @@ public class DataAccess {\n     // stored physical files that may not be associated with any DvObjects\n \n     public static StorageIO<DvObject> getDirectStorageIO(String fullStorageLocation) throws IOException {\n-    \tString[] response = getDriverIdAndStorageLocation(fullStorageLocation);\n-    \tString storageDriverId = response[0];\n-    \tString storageLocation=response[1];\n+        String[] response = getDriverIdAndStorageLocation(fullStorageLocation);\n+        String storageDriverId = response[0];\n+        String storageLocation = response[1];\n         String storageType = getDriverType(storageDriverId);\n-        switch(storageType) {\n-        case \"file\":\n-            return new FileAccessIO<>(storageLocation, storageDriverId);\n-        case \"s3\":\n-            return new S3AccessIO<>(storageLocation, storageDriverId);\n-        case \"swift\":\n-            return new SwiftAccessIO<>(storageLocation, storageDriverId);\n-        default:\n-        \tlogger.warning(\"Could not find storage driver for: \" + fullStorageLocation);\n-        \tthrow new IOException(\"getDirectStorageIO: Unsupported storage method.\");\n+        switch (storageType) {\n+            case \"file\":\n+                return new FileAccessIO<>(storageLocation, storageDriverId);\n+            case \"s3\":\n+                return new S3AccessIO<>(storageLocation, storageDriverId);\n+            case \"swift\":\n+                return new SwiftAccessIO<>(storageLocation, storageDriverId);\n+            default:\n+                logger.warning(\"Could not find storage driver for: \" + fullStorageLocation);\n+                throw new IOException(\"getDirectStorageIO: Unsupported storage method.\");\n         }\n     }\n-    \n+\n     public static String[] getDriverIdAndStorageLocation(String storageLocation) {\n-    \t//default if no prefix\n-    \tString storageIdentifier=storageLocation;\n+        //default if no prefix\n+        String storageIdentifier = storageLocation;\n         int separatorIndex = storageLocation.indexOf(\"://\");\n-    \tString storageDriverId = \"\"; //default\n-        if(separatorIndex>0) {\n-        \tstorageDriverId = storageLocation.substring(0,separatorIndex);\n-        \tstorageIdentifier = storageLocation.substring(separatorIndex + 3);\n+        String storageDriverId = \"\"; //default\n+        if (separatorIndex > 0) {\n+            storageDriverId = storageLocation.substring(0, separatorIndex);\n+            storageIdentifier = storageLocation.substring(separatorIndex + 3);\n         }\n-\t\treturn new String[]{storageDriverId, storageIdentifier};\n+        return new String[]{storageDriverId, storageIdentifier};\n     }\n-    \n+\n     public static String getStorarageIdFromLocation(String location) {\n-    \tif(location.contains(\"://\")) {\n-    \t\t//It's a full location with a driverId, so strip and reapply the driver id\n-    \t\t//NOte that this will strip the bucketname out (which s3 uses) but the S3IOStorage class knows to look at re-insert it\n-    \t\treturn location.substring(0,location.indexOf(\"://\") +3) + location.substring(location.lastIndexOf('/')+1); \n-    \t}\n-    \treturn location.substring(location.lastIndexOf('/')+1);\n+        if (location.contains(\"://\")) {\n+            //It's a full location with a driverId, so strip and reapply the driver id\n+            //NOte that this will strip the bucketname out (which s3 uses) but the S3IOStorage class knows to look at re-insert it\n+            return location.substring(0, location.indexOf(\"://\") + 3) + location.substring(location.lastIndexOf('/') + 1);\n+        }\n+        return location.substring(location.lastIndexOf('/') + 1);\n     }\n-    \n+\n     public static String getDriverType(String driverId) {\n-    \tif(driverId.isEmpty() || driverId.equals(\"tmp\")) {\n-    \t\treturn \"tmp\";\n-    \t}\n-    \treturn System.getProperty(\"dataverse.files.\" + driverId + \".type\", \"Undefined\");\n+        if (driverId.isEmpty() || driverId.equals(\"tmp\")) {\n+            return \"tmp\";\n+        }\n+        return System.getProperty(\"dataverse.files.\" + driverId + \".type\", \"Undefined\");\n     }\n \n     // createDataAccessObject() methods create a *new*, empty DataAccess objects,\n     // for saving new, not yet saved datafiles.\n+\n     public static <T extends DvObject> StorageIO<T> createNewStorageIO(T dvObject, String storageTag) throws IOException {\n-        if (dvObject == null\n-        \t\t|| dvObject.getDataverseContext()==null\n-                || storageTag == null\n-                || storageTag.isEmpty()) {\n+        if (dvObject == null || dvObject.getDataverseContext() == null\n+        || storageTag == null || storageTag.isEmpty()) {\n             throw new IOException(\"getDataAccessObject: null or invalid datafile.\");\n         }\n-                \n+\n         if (dvObject instanceof Dataset) {\n-            return createNewStorageIO(dvObject, storageTag, ((Dataset)dvObject).getEffectiveStorageDriverId());\n+            return createNewStorageIO(dvObject, storageTag, ((Dataset) dvObject).getEffectiveStorageDriverId());\n         } \n         // it's a DataFile:\n         return createNewStorageIO(dvObject, storageTag, dvObject.getOwner().getEffectiveStorageDriverId());\n     }\n \n     public static <T extends DvObject> StorageIO<T> createNewStorageIO(T dvObject, String storageTag, String storageDriverId) throws IOException {\n-        if (dvObject == null\n-                || storageTag == null\n-                || storageTag.isEmpty()) {\n+        if (dvObject == null || storageTag == null || storageTag.isEmpty()) {\n             throw new IOException(\"getDataAccessObject: null or invalid datafile.\");\n         }\n         \n@@ -167,31 +163,31 @@ public class DataAccess {\n          * This if will catch any cases where that's attempted.\n          */\n         // Tests send objects with no storageIdentifier set\n-        if((dvObject.getStorageIdentifier()!=null) && dvObject.getStorageIdentifier().contains(\"://\")) {\n-        \tthrow new IOException(\"Attempt to create new StorageIO for already stored object: \" + dvObject.getStorageIdentifier());\n+\n+        if ((dvObject.getStorageIdentifier() != null) && dvObject.getStorageIdentifier().contains(\"://\")) {\n+            throw new IOException(\"Attempt to create new StorageIO for already stored object: \" + dvObject.getStorageIdentifier());\n         }\n \n         StorageIO<T> storageIO = null;\n-        \n         dvObject.setStorageIdentifier(storageTag);\n-\n         if (StringUtils.isBlank(storageDriverId)) {\n-        \tstorageDriverId = DEFAULT_STORAGE_DRIVER_IDENTIFIER;\n+            storageDriverId = DEFAULT_STORAGE_DRIVER_IDENTIFIER;\n         }\n+\n         String storageType = getDriverType(storageDriverId);\n-        switch(storageType) {\n-        case \"file\":\n-        \tstorageIO = new FileAccessIO<>(dvObject, null, storageDriverId);\n-        \tbreak;\n-        case \"swift\":\n-        \tstorageIO = new SwiftAccessIO<>(dvObject, null, storageDriverId);\n-        \tbreak;\n-        case \"s3\":\n-        \tstorageIO = new S3AccessIO<>(dvObject, null, storageDriverId);\n-        \tbreak;\n-        default:\n-        \tlogger.warning(\"Could not find storage driver for: \" + storageTag);\n-        \tthrow new IOException(\"createDataAccessObject: Unsupported storage method \" + storageDriverId);\n+        switch (storageType) {\n+            case \"file\":\n+                storageIO = new FileAccessIO<>(dvObject, null, storageDriverId);\n+                break;\n+            case \"swift\":\n+                storageIO = new SwiftAccessIO<>(dvObject, null, storageDriverId);\n+                break;\n+            case \"s3\":\n+                storageIO = new S3AccessIO<>(dvObject, null, storageDriverId);\n+                break;\n+            default:\n+                logger.warning(\"Could not find storage driver for: \" + storageTag);\n+                throw new IOException(\"createDataAccessObject: Unsupported storage method \" + storageDriverId);\n         }\n         // Note: All storageIO classes must assure that dvObject instances' storageIdentifiers are prepended with \n         // the <driverId>:// + any additional storageIO type information required (e.g. the bucketname for s3/swift)\n@@ -201,53 +197,54 @@ public class DataAccess {\n     }\n \n     static HashMap<String, String> drivers = null;\n-    \n+\n     public static String getStorageDriverId(String driverLabel) {\n-    \tif (drivers==null) {\n-    \t\tpopulateDrivers();\n-    \t}\n-    \tif(!StringUtils.isBlank(driverLabel) && drivers.containsKey(driverLabel)) {\n-    \t\treturn drivers.get(driverLabel);\n-    \t} \n-    \treturn DEFAULT_STORAGE_DRIVER_IDENTIFIER;\n+        if (drivers == null) {\n+            populateDrivers();\n+        }\n+\n+        if (!StringUtils.isBlank(driverLabel) && drivers.containsKey(driverLabel)) {\n+            return drivers.get(driverLabel);\n+        }\n+        return DEFAULT_STORAGE_DRIVER_IDENTIFIER;\n     }\n \n     public static HashMap<String, String> getStorageDriverLabels() {\n-    \tif (drivers==null) {\n-    \t\tpopulateDrivers();\n-    \t}\n-    \treturn drivers;\n+        if (drivers == null) {\n+            populateDrivers();\n+        }\n+        return drivers;\n     }\n \n     private static void populateDrivers() {\n-    \tdrivers = new HashMap<String, String>();\n-    \tProperties p = System.getProperties();\n-    \tfor(String property: p.stringPropertyNames()) {\n-    \t\tif(property.startsWith(\"dataverse.files.\") && property.endsWith(\".label\")) {\n-    \t\t\tString driverId = property.substring(16); // \"dataverse.files.\".length\n-    \t\t\tdriverId=driverId.substring(0,driverId.indexOf('.'));\n-    \t\t\tlogger.info(\"Found Storage Driver: \" + driverId + \" for \" + p.get(property).toString());\n-    \t\t\tdrivers.put(p.get(property).toString(), driverId);\n-    \t\t}\n-    \t}\n+        drivers = new HashMap<String, String>();\n+        Properties p = System.getProperties();\n+        for (String property : p.stringPropertyNames()) {\n+            if (property.startsWith(\"dataverse.files.\") && property.endsWith(\".label\")) {\n+                String driverId = property.substring(16); // \"dataverse.files.\".length\n+                driverId = driverId.substring(0, driverId.indexOf('.'));\n+                logger.info(\"Found Storage Driver: \" + driverId + \" for \" + p.get(property).toString());\n+                drivers.put(p.get(property).toString(), driverId);\n+            }\n+        }\n     }\n \n     public static String getStorageDriverLabelFor(String storageDriverId) {\n-    \tString label = null;\n-    \tif(!StringUtils.isEmpty(storageDriverId)) {\n-    \t\tif (drivers==null) {\n-    \t\t\tpopulateDrivers();\n-    \t\t}\n-\n-    \t\tif(drivers.containsValue(storageDriverId)) {\n-    \t\t\tfor(String key: drivers.keySet()) {\n-    \t\t\t\tif(drivers.get(key).equals(storageDriverId)) {\n-    \t\t\t\t\tlabel = key;\n-    \t\t\t\t\tbreak;\n-    \t\t\t\t}\n-    \t\t\t}\n-    \t\t}\n-    \t}\n-    \treturn label;\n+        String label = null;\n+        if (!StringUtils.isEmpty(storageDriverId)) {\n+            if (drivers == null) {\n+                populateDrivers();\n+            }\n+\n+            if (drivers.containsValue(storageDriverId)) {\n+                for (String key : drivers.keySet()) {\n+                    if (drivers.get(key).equals(storageDriverId)) {\n+                        label = key;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return label;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 130
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "40",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/10/DataAccess.java\nindex a422a825259..8b120a36dcb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/10/DataAccess.java\n@@ -36,7 +36,7 @@ import org.apache.commons.lang3.StringUtils;\n \n public class DataAccess {\n \n-\tprivate static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n+private static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n \t\n     public DataAccess() {\n \n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "40",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/10/DataAccess.java\nindex a422a825259..3296f82ff44 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/10/DataAccess.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/10/DataAccess.java\n@@ -36,7 +36,7 @@ import org.apache.commons.lang3.StringUtils;\n \n public class DataAccess {\n \n-\tprivate static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n+    private static final Logger logger = Logger.getLogger(DataAccess.class.getCanonicalName());\n \t\n     public DataAccess() {\n \n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}