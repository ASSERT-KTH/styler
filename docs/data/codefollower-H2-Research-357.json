{
    "project_name": "codefollower-H2-Research",
    "error_id": "357",
    "information": {
        "errors": [
            {
                "line": "101",
                "column": "31",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "    private boolean canStop(int x) {\n        return (x & 127) == 0\n                && cost >= 0  // don't calculate for simple queries (no rows or so)\n                && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n    }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/357/Optimizer.java\nindex c823100ad58..85f078c7071 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/357/Optimizer.java\n@@ -98,8 +98,9 @@ class Optimizer {\n \n     private boolean canStop(int x) {\n         return (x & 127) == 0\n-                && cost >= 0  // don't calculate for simple queries (no rows or so)\n-                && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n+                && cost >= 0\n+                // don't calculate for simple queries (no rows or so)\n+                  && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n     }\n \n     private void calculateBruteForceAll() {\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "102",
                    "column": "23",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/357/Optimizer.java\nindex c823100ad58..895ad4e5e2f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/357/Optimizer.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.command.dml;\n \n import java.util.BitSet;\n@@ -22,243 +23,243 @@ import org.h2.util.Permutations;\n  */\n class Optimizer {\n \n-    private static final int MAX_BRUTE_FORCE_FILTERS = 7;\n-    private static final int MAX_BRUTE_FORCE = 2000;\n-    private static final int MAX_GENETIC = 500;\n-    private long startNs;\n-    private BitSet switched;\n+  private static final int MAX_BRUTE_FORCE_FILTERS = 7;\n+  private static final int MAX_BRUTE_FORCE = 2000;\n+  private static final int MAX_GENETIC = 500;\n+  private long startNs;\n+  private BitSet switched;\n \n-    //  possible plans for filters, if using brute force:\n-    //  1 filter 1 plan\n-    //  2 filters 2 plans\n-    //  3 filters 6 plans\n-    //  4 filters 24 plans\n-    //  5 filters 120 plans\n-    //  6 filters 720 plans\n-    //  7 filters 5040 plans\n-    //  8 filters 40320 plan\n-    //  9 filters 362880 plans\n-    // 10 filters 3628800 filters\n+  //  possible plans for filters, if using brute force:\n+  //  1 filter 1 plan\n+  //  2 filters 2 plans\n+  //  3 filters 6 plans\n+  //  4 filters 24 plans\n+  //  5 filters 120 plans\n+  //  6 filters 720 plans\n+  //  7 filters 5040 plans\n+  //  8 filters 40320 plan\n+  //  9 filters 362880 plans\n+  // 10 filters 3628800 filters\n \n-    private final TableFilter[] filters;\n-    private final Expression condition;\n-    private final Session session;\n+  private final TableFilter[] filters;\n+  private final Expression condition;\n+  private final Session session;\n \n-    private Plan bestPlan;\n-    private TableFilter topFilter;\n-    private double cost;\n-    private Random random;\n+  private Plan bestPlan;\n+  private TableFilter topFilter;\n+  private double cost;\n+  private Random random;\n \n-    Optimizer(TableFilter[] filters, Expression condition, Session session) {\n-        this.filters = filters;\n-        this.condition = condition;\n-        this.session = session;\n-    }\n+  Optimizer(TableFilter[] filters, Expression condition, Session session) {\n+    this.filters = filters;\n+    this.condition = condition;\n+    this.session = session;\n+  }\n \n-    /**\n-     * How many filter to calculate using brute force. The remaining filters are\n-     * selected using a greedy algorithm which has a runtime of (1 + 2 + ... +\n-     * n) = (n * (n-1) / 2) for n filters. The brute force algorithm has a\n-     * runtime of n * (n-1) * ... * (n-m) when calculating m brute force of n\n-     * total. The combined runtime is (brute force) * (greedy).\n-     *\n-     * @param filterCount the number of filters total\n-     * @return the number of filters to calculate using brute force\n-     */\n-    private static int getMaxBruteForceFilters(int filterCount) {\n-        int i = 0, j = filterCount, total = filterCount;\n-        while (j > 0 && total * (j * (j - 1) / 2) < MAX_BRUTE_FORCE) {\n-            j--;\n-            total *= j;\n-            i++;\n-        }\n-        return i;\n+  /**\n+   * How many filter to calculate using brute force. The remaining filters are\n+   * selected using a greedy algorithm which has a runtime of (1 + 2 + ... +\n+   * n) = (n * (n-1) / 2) for n filters. The brute force algorithm has a\n+   * runtime of n * (n-1) * ... * (n-m) when calculating m brute force of n\n+   * total. The combined runtime is (brute force) * (greedy).\n+   *\n+   * @param filterCount the number of filters total\n+   * @return the number of filters to calculate using brute force\n+   */\n+  private static int getMaxBruteForceFilters(int filterCount) {\n+    int i = 0, j = filterCount, total = filterCount;\n+    while (j > 0 && total * (j * (j - 1) / 2) < MAX_BRUTE_FORCE) {\n+      j--;\n+      total *= j;\n+      i++;\n     }\n+    return i;\n+  }\n \n-    private void calculateBestPlan() {\n-        cost = -1;\n-        if (filters.length == 1 || session.isForceJoinOrder()) {\n-            testPlan(filters);\n-        } else {\n-            startNs = System.nanoTime();\n-            if (filters.length <= MAX_BRUTE_FORCE_FILTERS) {\n-                calculateBruteForceAll();\n-            } else {\n-                calculateBruteForceSome();\n-                random = new Random(0);\n-                calculateGenetic();\n-            }\n-        }\n+  private void calculateBestPlan() {\n+    cost = -1;\n+    if (filters.length == 1 || session.isForceJoinOrder()) {\n+      testPlan(filters);\n+    } else {\n+      startNs = System.nanoTime();\n+      if (filters.length <= MAX_BRUTE_FORCE_FILTERS) {\n+        calculateBruteForceAll();\n+      } else {\n+        calculateBruteForceSome();\n+        random = new Random(0);\n+        calculateGenetic();\n+      }\n     }\n+  }\n \n-    private void calculateFakePlan() {\n-        cost = -1;\n-        bestPlan = new Plan(filters, filters.length, condition);\n-    }\n+  private void calculateFakePlan() {\n+    cost = -1;\n+    bestPlan = new Plan(filters, filters.length, condition);\n+  }\n \n-    private boolean canStop(int x) {\n-        return (x & 127) == 0\n-                && cost >= 0  // don't calculate for simple queries (no rows or so)\n-                && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n-    }\n+  private boolean canStop(int x) {\n+    return (x & 127) == 0\n+        && cost >= 0  // don't calculate for simple queries (no rows or so)\n+        && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n+  }\n \n-    private void calculateBruteForceAll() {\n-        TableFilter[] list = new TableFilter[filters.length];\n-        Permutations<TableFilter> p = Permutations.create(filters, list);\n-        for (int x = 0; !canStop(x) && p.next(); x++) {\n-            testPlan(list);\n-        }\n+  private void calculateBruteForceAll() {\n+    TableFilter[] list = new TableFilter[filters.length];\n+    Permutations<TableFilter> p = Permutations.create(filters, list);\n+    for (int x = 0; !canStop(x) && p.next(); x++) {\n+      testPlan(list);\n     }\n+  }\n \n-    private void calculateBruteForceSome() {\n-        int bruteForce = getMaxBruteForceFilters(filters.length);\n-        TableFilter[] list = new TableFilter[filters.length];\n-        Permutations<TableFilter> p = Permutations.create(filters, list, bruteForce);\n-        for (int x = 0; !canStop(x) && p.next(); x++) {\n-            // find out what filters are not used yet\n-            for (TableFilter f : filters) {\n-                f.setUsed(false);\n+  private void calculateBruteForceSome() {\n+    int bruteForce = getMaxBruteForceFilters(filters.length);\n+    TableFilter[] list = new TableFilter[filters.length];\n+    Permutations<TableFilter> p = Permutations.create(filters, list, bruteForce);\n+    for (int x = 0; !canStop(x) && p.next(); x++) {\n+      // find out what filters are not used yet\n+      for (TableFilter f : filters) {\n+        f.setUsed(false);\n+      }\n+      for (int i = 0; i < bruteForce; i++) {\n+        list[i].setUsed(true);\n+      }\n+      // fill the remaining elements with the unused elements (greedy)\n+      for (int i = bruteForce; i < filters.length; i++) {\n+        double costPart = -1.0;\n+        int bestPart = -1;\n+        for (int j = 0; j < filters.length; j++) {\n+          if (!filters[j].isUsed()) {\n+            if (i == filters.length - 1) {\n+              bestPart = j;\n+              break;\n             }\n-            for (int i = 0; i < bruteForce; i++) {\n-                list[i].setUsed(true);\n+            list[i] = filters[j];\n+            Plan part = new Plan(list, i + 1, condition);\n+            double costNow = part.calculateCost(session);\n+            if (costPart < 0 || costNow < costPart) {\n+              costPart = costNow;\n+              bestPart = j;\n             }\n-            // fill the remaining elements with the unused elements (greedy)\n-            for (int i = bruteForce; i < filters.length; i++) {\n-                double costPart = -1.0;\n-                int bestPart = -1;\n-                for (int j = 0; j < filters.length; j++) {\n-                    if (!filters[j].isUsed()) {\n-                        if (i == filters.length - 1) {\n-                            bestPart = j;\n-                            break;\n-                        }\n-                        list[i] = filters[j];\n-                        Plan part = new Plan(list, i+1, condition);\n-                        double costNow = part.calculateCost(session);\n-                        if (costPart < 0 || costNow < costPart) {\n-                            costPart = costNow;\n-                            bestPart = j;\n-                        }\n-                    }\n-                }\n-                filters[bestPart].setUsed(true);\n-                list[i] = filters[bestPart];\n-            }\n-            testPlan(list);\n+          }\n         }\n+        filters[bestPart].setUsed(true);\n+        list[i] = filters[bestPart];\n+      }\n+      testPlan(list);\n     }\n+  }\n \n-    private void calculateGenetic() {\n-        TableFilter[] best = new TableFilter[filters.length];\n-        TableFilter[] list = new TableFilter[filters.length];\n-        for (int x = 0; x < MAX_GENETIC; x++) {\n-            if (canStop(x)) {\n-                break;\n-            }\n-            boolean generateRandom = (x & 127) == 0;\n-            if (!generateRandom) {\n-                System.arraycopy(best, 0, list, 0, filters.length);\n-                if (!shuffleTwo(list)) {\n-                    generateRandom = true;\n-                }\n-            }\n-            if (generateRandom) {\n-                switched = new BitSet();\n-                System.arraycopy(filters, 0, best, 0, filters.length);\n-                shuffleAll(best);\n-                System.arraycopy(best, 0, list, 0, filters.length);\n-            }\n-            if (testPlan(list)) {\n-                switched = new BitSet();\n-                System.arraycopy(list, 0, best, 0, filters.length);\n-            }\n+  private void calculateGenetic() {\n+    TableFilter[] best = new TableFilter[filters.length];\n+    TableFilter[] list = new TableFilter[filters.length];\n+    for (int x = 0; x < MAX_GENETIC; x++) {\n+      if (canStop(x)) {\n+        break;\n+      }\n+      boolean generateRandom = (x & 127) == 0;\n+      if (!generateRandom) {\n+        System.arraycopy(best, 0, list, 0, filters.length);\n+        if (!shuffleTwo(list)) {\n+          generateRandom = true;\n         }\n+      }\n+      if (generateRandom) {\n+        switched = new BitSet();\n+        System.arraycopy(filters, 0, best, 0, filters.length);\n+        shuffleAll(best);\n+        System.arraycopy(best, 0, list, 0, filters.length);\n+      }\n+      if (testPlan(list)) {\n+        switched = new BitSet();\n+        System.arraycopy(list, 0, best, 0, filters.length);\n+      }\n     }\n+  }\n \n-    private boolean testPlan(TableFilter[] list) {\n-        Plan p = new Plan(list, list.length, condition);\n-        double costNow = p.calculateCost(session);\n-        if (cost < 0 || costNow < cost) {\n-            cost = costNow;\n-            bestPlan = p;\n-            return true;\n-        }\n-        return false;\n+  private boolean testPlan(TableFilter[] list) {\n+    Plan p = new Plan(list, list.length, condition);\n+    double costNow = p.calculateCost(session);\n+    if (cost < 0 || costNow < cost) {\n+      cost = costNow;\n+      bestPlan = p;\n+      return true;\n     }\n+    return false;\n+  }\n \n-    private void shuffleAll(TableFilter[] f) {\n-        for (int i = 0; i < f.length - 1; i++) {\n-            int j = i + random.nextInt(f.length - i);\n-            if (j != i) {\n-                TableFilter temp = f[i];\n-                f[i] = f[j];\n-                f[j] = temp;\n-            }\n-        }\n+  private void shuffleAll(TableFilter[] f) {\n+    for (int i = 0; i < f.length - 1; i++) {\n+      int j = i + random.nextInt(f.length - i);\n+      if (j != i) {\n+        TableFilter temp = f[i];\n+        f[i] = f[j];\n+        f[j] = temp;\n+      }\n     }\n+  }\n \n-    private boolean shuffleTwo(TableFilter[] f) {\n-        int a = 0, b = 0, i = 0;\n-        for (; i < 20; i++) {\n-            a = random.nextInt(f.length);\n-            b = random.nextInt(f.length);\n-            if (a == b) {\n-                continue;\n-            }\n-            if (a < b) {\n-                int temp = a;\n-                a = b;\n-                b = temp;\n-            }\n-            int s = a * f.length + b;\n-            if (switched.get(s)) {\n-                continue;\n-            }\n-            switched.set(s);\n-            break;\n-        }\n-        if (i == 20) {\n-            return false;\n-        }\n-        TableFilter temp = f[a];\n-        f[a] = f[b];\n-        f[b] = temp;\n-        return true;\n+  private boolean shuffleTwo(TableFilter[] f) {\n+    int a = 0, b = 0, i = 0;\n+    for (; i < 20; i++) {\n+      a = random.nextInt(f.length);\n+      b = random.nextInt(f.length);\n+      if (a == b) {\n+        continue;\n+      }\n+      if (a < b) {\n+        int temp = a;\n+        a = b;\n+        b = temp;\n+      }\n+      int s = a * f.length + b;\n+      if (switched.get(s)) {\n+        continue;\n+      }\n+      switched.set(s);\n+      break;\n     }\n-\n-    /**\n-     * Calculate the best query plan to use.\n-     *\n-     * @param parse If we do not need to really get the best plan because it is\n-     *            a view parsing stage.\n-     */\n-    void optimize(boolean parse) {\n-        if (parse) {\n-            calculateFakePlan();\n-        } else {\n-            calculateBestPlan();\n-            bestPlan.removeUnusableIndexConditions();\n-        }\n-        TableFilter[] f2 = bestPlan.getFilters();\n-        topFilter = f2[0];\n-        for (int i = 0; i < f2.length - 1; i++) {\n-            f2[i].addJoin(f2[i + 1], false, null);\n-        }\n-        if (parse) {\n-            return;\n-        }\n-        for (TableFilter f : f2) {\n-            PlanItem item = bestPlan.getItem(f);\n-            f.setPlanItem(item);\n-        }\n+    if (i == 20) {\n+      return false;\n     }\n+    TableFilter temp = f[a];\n+    f[a] = f[b];\n+    f[b] = temp;\n+    return true;\n+  }\n \n-    public TableFilter getTopFilter() {\n-        return topFilter;\n+  /**\n+   * Calculate the best query plan to use.\n+   *\n+   * @param parse If we do not need to really get the best plan because it is\n+   *              a view parsing stage.\n+   */\n+  void optimize(boolean parse) {\n+    if (parse) {\n+      calculateFakePlan();\n+    } else {\n+      calculateBestPlan();\n+      bestPlan.removeUnusableIndexConditions();\n     }\n-\n-    double getCost() {\n-        return cost;\n+    TableFilter[] f2 = bestPlan.getFilters();\n+    topFilter = f2[0];\n+    for (int i = 0; i < f2.length - 1; i++) {\n+      f2[i].addJoin(f2[i + 1], false, null);\n+    }\n+    if (parse) {\n+      return;\n     }\n+    for (TableFilter f : f2) {\n+      PlanItem item = bestPlan.getItem(f);\n+      f.setPlanItem(item);\n+    }\n+  }\n+\n+  public TableFilter getTopFilter() {\n+    return topFilter;\n+  }\n+\n+  double getCost() {\n+    return cost;\n+  }\n \n }\n",
            "diff_size": 282
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/357/Optimizer.java\nindex c823100ad58..1be1a4ebea0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/357/Optimizer.java\n@@ -98,7 +98,8 @@ class Optimizer {\n \n     private boolean canStop(int x) {\n         return (x & 127) == 0\n-                && cost >= 0  // don't calculate for simple queries (no rows or so)\n+                && cost >= 0\n+// don't calculate for simple queries (no rows or so)\n                 && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n     }\n \n@@ -261,4 +262,4 @@ class Optimizer {\n         return cost;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/357/Optimizer.java\nindex c823100ad58..85f078c7071 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/357/Optimizer.java\n@@ -98,8 +98,9 @@ class Optimizer {\n \n     private boolean canStop(int x) {\n         return (x & 127) == 0\n-                && cost >= 0  // don't calculate for simple queries (no rows or so)\n-                && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n+                && cost >= 0\n+                // don't calculate for simple queries (no rows or so)\n+                  && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n     }\n \n     private void calculateBruteForceAll() {\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/357/Optimizer.java\nindex c823100ad58..6e1494c6d19 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/357/Optimizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/357/Optimizer.java\n@@ -98,8 +98,9 @@ class Optimizer {\n \n     private boolean canStop(int x) {\n         return (x & 127) == 0\n-                && cost >= 0  // don't calculate for simple queries (no rows or so)\n-                && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n+                && cost >= 0\n+            // don't calculate for simple queries (no rows or so)\n+                  && 10 * (System.nanoTime() - startNs) > cost * TimeUnit.MILLISECONDS.toNanos(1);\n     }\n \n     private void calculateBruteForceAll() {\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}