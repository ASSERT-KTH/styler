{
    "project_name": "wso2-attic-commons",
    "error_id": "77",
    "information": {
        "errors": [
            {
                "line": "312",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 130).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "        } else {\n            ArrayList<String> code = new ArrayList<String>();\n            code.add(Status.STATUS_PROCESSING_ERROR);                                                                            ;\n            Status status = new Status(code);\n            return  new EvaluationResult(status);\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/77/XACML2EvaluationCtx.java\nindex 9fcaaf9d2a3..12bcebaa8cd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/77/XACML2EvaluationCtx.java\n@@ -309,8 +309,8 @@ public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n             return getEnvironmentAttribute(type, id, category, issuer);\n         } else {\n             ArrayList<String> code = new ArrayList<String>();\n-            code.add(Status.STATUS_PROCESSING_ERROR);                                                                            ;\n-            Status status = new Status(code);\n+            code.add(Status.STATUS_PROCESSING_ERROR);\n+            ; Status status = new Status(code);\n             return  new EvaluationResult(status);\n         }\n     }\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/77/XACML2EvaluationCtx.java\nindex 9fcaaf9d2a3..18371d71ddc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/77/XACML2EvaluationCtx.java\n@@ -49,454 +49,456 @@ import java.util.Set;\n public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n \n \n-    private Set<Attributes> attributesSet;\n+  private Set<Attributes> attributesSet;\n \n-    private int xacmlVersion;\n+  private int xacmlVersion;\n \n-    // the DOM root the original RequestContext document\n-    private Node requestRoot;\n+  // the DOM root the original RequestContext document\n+  private Node requestRoot;\n \n-    // the 4 maps that contain the attribute data\n-    private HashMap subjectMap;\n-    private HashMap resourceMap;\n-    private HashMap actionMap;\n-    private HashMap environmentMap;\n+  // the 4 maps that contain the attribute data\n+  private HashMap subjectMap;\n+  private HashMap resourceMap;\n+  private HashMap actionMap;\n+  private HashMap environmentMap;\n \n-    // the resource and its scope\n-    private AttributeValue resourceId;\n-    private int scope;\n+  // the resource and its scope\n+  private AttributeValue resourceId;\n+  private int scope;\n \n-    // the cached current date, time, and datetime, which we may or may\n-    // not be using depending on how this object was constructed\n-    private DateAttribute currentDate;\n-    private TimeAttribute currentTime;\n-    private DateTimeAttribute currentDateTime;\n-    private boolean useCachedEnvValues;\n+  // the cached current date, time, and datetime, which we may or may\n+  // not be using depending on how this object was constructed\n+  private DateAttribute currentDate;\n+  private TimeAttribute currentTime;\n+  private DateTimeAttribute currentDateTime;\n+  private boolean useCachedEnvValues;\n \n-    //private Set<ObligationResult>  obligationResults;\n+  //private Set<ObligationResult>  obligationResults;\n \n-    //private Set<Advice>  advices;\n+  //private Set<Advice>  advices;\n \n-    private MultipleCtxResult multipleCtxResult;\n+  private MultipleCtxResult multipleCtxResult;\n \n-    private RequestCtx requestCtx;\n+  private RequestCtx requestCtx;\n \n-    // the logger we'll use for all messages\n+  // the logger we'll use for all messages\n \n-    private static Log logger = LogFactory.getLog(XACML2EvaluationCtx.class);\n+  private static Log logger = LogFactory.getLog(XACML2EvaluationCtx.class);\n \n-    public XACML2EvaluationCtx() {\n-        \n-    }\n+  public XACML2EvaluationCtx() {\n \n-    public XACML2EvaluationCtx(RequestCtx requestCtx, PDPConfig pdpConfig) throws ParsingException {\n+  }\n \n-        // keep track of the finder\n-        this.pdpConfig = pdpConfig;\n+  public XACML2EvaluationCtx(RequestCtx requestCtx, PDPConfig pdpConfig) throws ParsingException {\n \n-        this.requestCtx = requestCtx;\n+    // keep track of the finder\n+    this.pdpConfig = pdpConfig;\n \n-        xacmlVersion = requestCtx.getXacmlVersion();\n+    this.requestCtx = requestCtx;\n \n-        // remember the root of the DOM tree for XPath queries\n-        requestRoot = requestCtx.getDocumentRoot();\n+    xacmlVersion = requestCtx.getXacmlVersion();\n \n-        attributesSet = requestCtx.getAttributesSet();\n-        // initialize the cached date/time values so it's clear we haven't\n-        // retrieved them yet\n-        this.useCachedEnvValues = false;\n-        currentDate = null;\n-        currentTime = null;\n-        currentDateTime = null;\n+    // remember the root of the DOM tree for XPath queries\n+    requestRoot = requestCtx.getDocumentRoot();\n \n-        // get the subjects, make sure they're correct, and setup tables\n-        subjectMap = new HashMap();\n-        setupSubjects(requestCtx.getSubjects());\n+    attributesSet = requestCtx.getAttributesSet();\n+    // initialize the cached date/time values so it's clear we haven't\n+    // retrieved them yet\n+    this.useCachedEnvValues = false;\n+    currentDate = null;\n+    currentTime = null;\n+    currentDateTime = null;\n \n-        // next look at the Resource data, which needs to be handled specially\n-        resourceMap = new HashMap();\n-        setupResource(requestCtx.getResource());\n+    // get the subjects, make sure they're correct, and setup tables\n+    subjectMap = new HashMap();\n+    setupSubjects(requestCtx.getSubjects());\n \n-        // setup the action data, which is generic\n-        actionMap = new HashMap();\n-        mapAttributes(requestCtx.getAction(), actionMap);\n+    // next look at the Resource data, which needs to be handled specially\n+    resourceMap = new HashMap();\n+    setupResource(requestCtx.getResource());\n \n-        // finally, set up the environment data, which is also generic\n-        environmentMap = new HashMap();\n-        mapAttributes(requestCtx.getEnvironmentAttributes(), environmentMap);\n+    // setup the action data, which is generic\n+    actionMap = new HashMap();\n+    mapAttributes(requestCtx.getAction(), actionMap);\n \n-    }\n+    // finally, set up the environment data, which is also generic\n+    environmentMap = new HashMap();\n+    mapAttributes(requestCtx.getEnvironmentAttributes(), environmentMap);\n \n-    /**\n-     * This is quick helper function to provide a little structure for the subject attributes so we\n-     * can search for them (somewhat) quickly. The basic idea is to have a map indexed by\n-     * SubjectCategory that keeps Maps that in turn are indexed by id and keep the unique\n-     * ctx.Attribute objects.\n-     */\n-    private void setupSubjects(Set subjects)  {\n-\n-        // now go through the subject attributes\n-        Iterator it = subjects.iterator();\n-        while (it.hasNext()) {\n-            Subject subject = (Subject) (it.next());\n-\n-            URI category = subject.getCategory();\n-            Map categoryMap = null;\n-\n-            // see if we've already got a map for the category\n-            if (subjectMap.containsKey(category)) {\n-                categoryMap = (Map) (subjectMap.get(category));\n-            } else {\n-                categoryMap = new HashMap();\n-                subjectMap.put(category, categoryMap);\n-            }\n-\n-            // iterate over the set of attributes\n-            Iterator attrIterator = subject.getAttributes().iterator();\n-\n-            while (attrIterator.hasNext()) {\n-                Attribute attr = (Attribute) (attrIterator.next());\n-                String id = attr.getId().toString();\n-\n-                if (categoryMap.containsKey(id)) {\n-                    // add to the existing set of Attributes w/this id\n-                    Set existingIds = (Set) (categoryMap.get(id));\n-                    existingIds.add(attr);\n-                } else {\n-                    // this is the first Attr w/this id\n-                    HashSet newIds = new HashSet();\n-                    newIds.add(attr);\n-                    categoryMap.put(id, newIds);\n-                }\n-            }\n-        }\n-    }\n+  }\n \n-    /**\n-     * This basically does the same thing that the other types need to do, except that we also look\n-     * for a resource-id attribute, not because we're going to use, but only to make sure that it's\n-     * actually there, and for the optional scope attribute, to see what the scope of the attribute\n-     * is\n-     */\n-    private void setupResource(Set resource) throws ParsingException {\n-        mapAttributes(resource, resourceMap);\n-\n-        // make sure there resource-id attribute was included\n-        if (!resourceMap.containsKey(XACMLConstants.RESOURCE_ID)) {\n-            logger.error(\"Resource must contain resource-id attr\");\n-            throw new ParsingException(\"resource missing resource-id\");\n-        } else {\n-            // make sure there's only one value for this\n-            Set set = (Set) (resourceMap.get(XACMLConstants.RESOURCE_ID));\n-            if (set.size() > 1) {\n-                logger.error(\"Resource may contain only one resource-id Attribute\");\n-                throw new ParsingException(\"too many resource-id attrs\");\n-            } else {\n-                // keep track of the resource-id attribute\n-                resourceId = ((Attribute) (set.iterator().next())).getValue();\n-            }\n-        }\n+  /**\n+   * This is quick helper function to provide a little structure for the subject attributes so we\n+   * can search for them (somewhat) quickly. The basic idea is to have a map indexed by\n+   * SubjectCategory that keeps Maps that in turn are indexed by id and keep the unique\n+   * ctx.Attribute objects.\n+   */\n+  private void setupSubjects(Set subjects) {\n \n-        // see if a resource-scope attribute was included\n-        if (resourceMap.containsKey(XACMLConstants.RESOURCE_SCOPE_1_0)) {\n-            Set set = (Set) (resourceMap.get(XACMLConstants.RESOURCE_SCOPE_1_0));\n-\n-            // make sure there's only one value for resource-scope\n-            if (set.size() > 1) {\n-                logger.error(\"Resource may contain only one resource-scope Attribute\");\n-                throw new ParsingException(\"too many resource-scope attrs\");\n-            }\n-\n-            Attribute attr = (Attribute) (set.iterator().next());\n-            AttributeValue attrValue = attr.getValue();\n-\n-            // scope must be a string, so throw an exception otherwise\n-            if (!attrValue.getType().toString().equals(StringAttribute.identifier)) {\n-                logger.error(\"scope attr must be a string\");\n-                throw new ParsingException(\"scope attr must be a string\");\n-            }\n-\n-            String value = ((StringAttribute) attrValue).getValue();\n-\n-            if (value.equals(\"Immediate\")) {\n-                scope = XACMLConstants.SCOPE_IMMEDIATE;\n-            } else if (value.equals(\"Children\")) {\n-                scope = XACMLConstants.SCOPE_CHILDREN;\n-            } else if (value.equals(\"Descendants\")) {\n-                scope = XACMLConstants.SCOPE_DESCENDANTS;\n-            } else {\n-                logger.error(\"Unknown scope type: \" + value);\n-                throw new ParsingException(\"invalid scope type: \" + value);\n-            }\n-        } else {\n-            // by default, the scope is always Immediate\n-            scope = XACMLConstants.SCOPE_IMMEDIATE;\n-        }\n-    }\n+    // now go through the subject attributes\n+    Iterator it = subjects.iterator();\n+    while (it.hasNext()) {\n+      Subject subject = (Subject) (it.next());\n \n-    /**\n-     * Generic routine for resource, attribute and environment attributes to build the lookup map\n-     * for each. The Form is a Map that is indexed by the String form of the attribute ids, and that\n-     * contains Sets at each entry with all attributes that have that id\n-     */\n-    private void mapAttributes(Set input, Map output) {\n-        Iterator it = input.iterator();\n-        while (it.hasNext()) {\n-            Attribute attr = (Attribute) (it.next());\n-            String id = attr.getId().toString();\n-\n-            if (output.containsKey(id)) {\n-                Set set = (Set) (output.get(id));\n-                set.add(attr);\n-            } else {\n-                Set set = new HashSet();\n-                set.add(attr);\n-                output.put(id, set);\n-            }\n-        }\n-    }\n+      URI category = subject.getCategory();\n+      Map categoryMap = null;\n \n-    /**\n-     * Returns the resource scope of the request, which will be one of the three fields denoting\n-     * Immediate, Children, or Descendants.\n-     *\n-     * @return the scope of the resource in the request\n-     */\n-    public int getScope() {\n-        return scope;\n-    }\n+      // see if we've already got a map for the category\n+      if (subjectMap.containsKey(category)) {\n+        categoryMap = (Map) (subjectMap.get(category));\n+      } else {\n+        categoryMap = new HashMap();\n+        subjectMap.put(category, categoryMap);\n+      }\n \n-    /**\n-     * Returns the resource named in the request as resource-id.\n-     *\n-     * @return the resource\n-     */\n-    public AttributeValue getResourceId() {\n-        return resourceId;\n-    }\n+      // iterate over the set of attributes\n+      Iterator attrIterator = subject.getAttributes().iterator();\n \n-    /**\n-     * Changes the value of the resource-id attribute in this context. This is useful when you have\n-     * multiple resources (ie, a scope other than IMMEDIATE), and you need to keep changing only the\n-     * resource-id to evaluate the different effective requests.\n-     *\n-     * @param resourceId the new resource-id value\n-     */\n-    public void setResourceId(AttributeValue resourceId, Set<Attributes> attributesSet) {\n-        this.resourceId = resourceId;\n-\n-        // there will always be exactly one value for this attribute\n-        Set attrSet = (Set) (resourceMap.get(XACMLConstants.RESOURCE_ID));\n-        Attribute attr = (Attribute) (attrSet.iterator().next());\n-\n-        // remove the old value...\n-        attrSet.remove(attr);\n-\n-        // ...and insert the new value\n-        attrSet.add(new Attribute(attr.getId(), attr.getIssuer(), attr.getIssueInstant(),\n-                resourceId,XACMLConstants.XACML_VERSION_2_0));\n-    }\n+      while (attrIterator.hasNext()) {\n+        Attribute attr = (Attribute) (attrIterator.next());\n+        String id = attr.getId().toString();\n \n-    public EvaluationResult getAttribute(URI type, URI id, String issuer, URI category) {\n-\n-        if(XACMLConstants.SUBJECT_CATEGORY.equals(category.toString())){\n-            return getSubjectAttribute(type, id, category, issuer);\n-        } else if(XACMLConstants.RESOURCE_CATEGORY.equals(category.toString())){\n-            return getResourceAttribute(type, id, category, issuer);\n-        } else if(XACMLConstants.ACTION_CATEGORY.equals(category.toString())){\n-            return getActionAttribute(type, id, category, issuer);\n-        } else if(XACMLConstants.ENT_CATEGORY.equals(category.toString())){\n-            return getEnvironmentAttribute(type, id, category, issuer);\n+        if (categoryMap.containsKey(id)) {\n+          // add to the existing set of Attributes w/this id\n+          Set existingIds = (Set) (categoryMap.get(id));\n+          existingIds.add(attr);\n         } else {\n-            ArrayList<String> code = new ArrayList<String>();\n-            code.add(Status.STATUS_PROCESSING_ERROR);                                                                            ;\n-            Status status = new Status(code);\n-            return  new EvaluationResult(status);\n+          // this is the first Attr w/this id\n+          HashSet newIds = new HashSet();\n+          newIds.add(attr);\n+          categoryMap.put(id, newIds);\n         }\n+      }\n     }\n-\n-    public int getXacmlVersion() {\n-        return xacmlVersion;\n+  }\n+\n+  /**\n+   * This basically does the same thing that the other types need to do, except that we also look\n+   * for a resource-id attribute, not because we're going to use, but only to make sure that it's\n+   * actually there, and for the optional scope attribute, to see what the scope of the attribute\n+   * is\n+   */\n+  private void setupResource(Set resource) throws ParsingException {\n+    mapAttributes(resource, resourceMap);\n+\n+    // make sure there resource-id attribute was included\n+    if (!resourceMap.containsKey(XACMLConstants.RESOURCE_ID)) {\n+      logger.error(\"Resource must contain resource-id attr\");\n+      throw new ParsingException(\"resource missing resource-id\");\n+    } else {\n+      // make sure there's only one value for this\n+      Set set = (Set) (resourceMap.get(XACMLConstants.RESOURCE_ID));\n+      if (set.size() > 1) {\n+        logger.error(\"Resource may contain only one resource-id Attribute\");\n+        throw new ParsingException(\"too many resource-id attrs\");\n+      } else {\n+        // keep track of the resource-id attribute\n+        resourceId = ((Attribute) (set.iterator().next())).getValue();\n+      }\n     }\n \n-    /**\n-     * Returns attribute value(s) from the subject section of the request.\n-     *\n-     * @param type     the type of the attribute value(s) to find\n-     * @param id       the id of the attribute value(s) to find\n-     * @param issuer   the issuer of the attribute value(s) to find or null\n-     * @param category the category the attribute value(s) must be in\n-     * @return a result containing a bag either empty because no values were found or containing at\n-     *         least one value, or status associated with an Indeterminate result\n-     */\n-    public EvaluationResult getSubjectAttribute(URI type, URI id, URI category, String issuer) {\n-        // This is the same as the other three lookups except that this\n-        // has an extra level of indirection that needs to be handled first\n-        Map map = (Map) (subjectMap.get(category));\n-\n-        if (map == null) {\n-            // the request didn't have that category, so we should try asking\n-            // the attribute finder\n-            return callHelper(type, id, issuer, category);\n-        }\n-\n-        return getGenericAttributes(type, id, category, issuer, map);\n+    // see if a resource-scope attribute was included\n+    if (resourceMap.containsKey(XACMLConstants.RESOURCE_SCOPE_1_0)) {\n+      Set set = (Set) (resourceMap.get(XACMLConstants.RESOURCE_SCOPE_1_0));\n+\n+      // make sure there's only one value for resource-scope\n+      if (set.size() > 1) {\n+        logger.error(\"Resource may contain only one resource-scope Attribute\");\n+        throw new ParsingException(\"too many resource-scope attrs\");\n+      }\n+\n+      Attribute attr = (Attribute) (set.iterator().next());\n+      AttributeValue attrValue = attr.getValue();\n+\n+      // scope must be a string, so throw an exception otherwise\n+      if (!attrValue.getType().toString().equals(StringAttribute.identifier)) {\n+        logger.error(\"scope attr must be a string\");\n+        throw new ParsingException(\"scope attr must be a string\");\n+      }\n+\n+      String value = ((StringAttribute) attrValue).getValue();\n+\n+      if (value.equals(\"Immediate\")) {\n+        scope = XACMLConstants.SCOPE_IMMEDIATE;\n+      } else if (value.equals(\"Children\")) {\n+        scope = XACMLConstants.SCOPE_CHILDREN;\n+      } else if (value.equals(\"Descendants\")) {\n+        scope = XACMLConstants.SCOPE_DESCENDANTS;\n+      } else {\n+        logger.error(\"Unknown scope type: \" + value);\n+        throw new ParsingException(\"invalid scope type: \" + value);\n+      }\n+    } else {\n+      // by default, the scope is always Immediate\n+      scope = XACMLConstants.SCOPE_IMMEDIATE;\n     }\n-\n-    /**\n-     * Returns attribute value(s) from the resource section of the request.\n-     *\n-     * @param type   the type of the attribute value(s) to find\n-     * @param id     the id of the attribute value(s) to find\n-     * @param issuer the issuer of the attribute value(s) to find or null\n-     * @return a result containing a bag either empty because no values were found or containing at\n-     *         least one value, or status associated with an Indeterminate result\n-     */\n-    public EvaluationResult getResourceAttribute(URI type, URI id, URI category, String issuer) {\n-        return getGenericAttributes(type, id, category, issuer, resourceMap);\n+  }\n+\n+  /**\n+   * Generic routine for resource, attribute and environment attributes to build the lookup map\n+   * for each. The Form is a Map that is indexed by the String form of the attribute ids, and that\n+   * contains Sets at each entry with all attributes that have that id\n+   */\n+  private void mapAttributes(Set input, Map output) {\n+    Iterator it = input.iterator();\n+    while (it.hasNext()) {\n+      Attribute attr = (Attribute) (it.next());\n+      String id = attr.getId().toString();\n+\n+      if (output.containsKey(id)) {\n+        Set set = (Set) (output.get(id));\n+        set.add(attr);\n+      } else {\n+        Set set = new HashSet();\n+        set.add(attr);\n+        output.put(id, set);\n+      }\n     }\n-\n-    /**\n-     * Returns attribute value(s) from the action section of the request.\n-     *\n-     * @param type   the type of the attribute value(s) to find\n-     * @param id     the id of the attribute value(s) to find\n-     * @param issuer the issuer of the attribute value(s) to find or null\n-     * @return a result containing a bag either empty because no values were found or containing at\n-     *         least one value, or status associated with an Indeterminate result\n-     */\n-    public EvaluationResult getActionAttribute(URI type, URI id, URI category, String issuer) {\n-        return getGenericAttributes(type, id, category, issuer, actionMap);\n+  }\n+\n+  /**\n+   * Returns the resource scope of the request, which will be one of the three fields denoting\n+   * Immediate, Children, or Descendants.\n+   *\n+   * @return the scope of the resource in the request\n+   */\n+  public int getScope() {\n+    return scope;\n+  }\n+\n+  /**\n+   * Returns the resource named in the request as resource-id.\n+   *\n+   * @return the resource\n+   */\n+  public AttributeValue getResourceId() {\n+    return resourceId;\n+  }\n+\n+  /**\n+   * Changes the value of the resource-id attribute in this context. This is useful when you have\n+   * multiple resources (ie, a scope other than IMMEDIATE), and you need to keep changing only the\n+   * resource-id to evaluate the different effective requests.\n+   *\n+   * @param resourceId the new resource-id value\n+   */\n+  public void setResourceId(AttributeValue resourceId, Set<Attributes> attributesSet) {\n+    this.resourceId = resourceId;\n+\n+    // there will always be exactly one value for this attribute\n+    Set attrSet = (Set) (resourceMap.get(XACMLConstants.RESOURCE_ID));\n+    Attribute attr = (Attribute) (attrSet.iterator().next());\n+\n+    // remove the old value...\n+    attrSet.remove(attr);\n+\n+    // ...and insert the new value\n+    attrSet.add(new Attribute(attr.getId(), attr.getIssuer(), attr.getIssueInstant(),\n+      resourceId, XACMLConstants.XACML_VERSION_2_0));\n+  }\n+\n+  public EvaluationResult getAttribute(URI type, URI id, String issuer, URI category) {\n+\n+    if (XACMLConstants.SUBJECT_CATEGORY.equals(category.toString())) {\n+      return getSubjectAttribute(type, id, category, issuer);\n+    } else if (XACMLConstants.RESOURCE_CATEGORY.equals(category.toString())) {\n+      return getResourceAttribute(type, id, category, issuer);\n+    } else if (XACMLConstants.ACTION_CATEGORY.equals(category.toString())) {\n+      return getActionAttribute(type, id, category, issuer);\n+    } else if (XACMLConstants.ENT_CATEGORY.equals(category.toString())) {\n+      return getEnvironmentAttribute(type, id, category, issuer);\n+    } else {\n+      ArrayList<String> code = new ArrayList<String>();\n+      code.add(Status.STATUS_PROCESSING_ERROR);\n+      ;\n+      Status status = new Status(code);\n+      return new EvaluationResult(status);\n     }\n-\n-    /**\n-     * Returns attribute value(s) from the environment section of the request.\n-     *\n-     * @param type   the type of the attribute value(s) to find\n-     * @param id     the id of the attribute value(s) to find\n-     * @param issuer the issuer of the attribute value(s) to find or null\n-     * @return a result containing a bag either empty because no values were found or containing at\n-     *         least one value, or status associated with an Indeterminate result\n-     */\n-    public EvaluationResult getEnvironmentAttribute(URI type, URI id, URI category, String issuer) {\n-        return getGenericAttributes(type, id, category, issuer, environmentMap);\n+  }\n+\n+  public int getXacmlVersion() {\n+    return xacmlVersion;\n+  }\n+\n+  /**\n+   * Returns attribute value(s) from the subject section of the request.\n+   *\n+   * @param type     the type of the attribute value(s) to find\n+   * @param id       the id of the attribute value(s) to find\n+   * @param issuer   the issuer of the attribute value(s) to find or null\n+   * @param category the category the attribute value(s) must be in\n+   * @return a result containing a bag either empty because no values were found or containing at\n+   * least one value, or status associated with an Indeterminate result\n+   */\n+  public EvaluationResult getSubjectAttribute(URI type, URI id, URI category, String issuer) {\n+    // This is the same as the other three lookups except that this\n+    // has an extra level of indirection that needs to be handled first\n+    Map map = (Map) (subjectMap.get(category));\n+\n+    if (map == null) {\n+      // the request didn't have that category, so we should try asking\n+      // the attribute finder\n+      return callHelper(type, id, issuer, category);\n     }\n \n-    /**\n-     * Helper function for the resource, action and environment methods to get an attribute.\n-     */\n-    private EvaluationResult getGenericAttributes(URI type, URI id, URI category, String issuer,\n-                                                                                        Map map) {\n-        // try to find the id\n-        Set attrSet = (Set) (map.get(id.toString()));\n-        if (attrSet == null) {\n-            // the request didn't have an attribute with that id, so we should\n-            // try asking the attribute finder\n-            return callHelper(type, id, issuer, category);\n-        }\n+    return getGenericAttributes(type, id, category, issuer, map);\n+  }\n+\n+  /**\n+   * Returns attribute value(s) from the resource section of the request.\n+   *\n+   * @param type   the type of the attribute value(s) to find\n+   * @param id     the id of the attribute value(s) to find\n+   * @param issuer the issuer of the attribute value(s) to find or null\n+   * @return a result containing a bag either empty because no values were found or containing at\n+   * least one value, or status associated with an Indeterminate result\n+   */\n+  public EvaluationResult getResourceAttribute(URI type, URI id, URI category, String issuer) {\n+    return getGenericAttributes(type, id, category, issuer, resourceMap);\n+  }\n+\n+  /**\n+   * Returns attribute value(s) from the action section of the request.\n+   *\n+   * @param type   the type of the attribute value(s) to find\n+   * @param id     the id of the attribute value(s) to find\n+   * @param issuer the issuer of the attribute value(s) to find or null\n+   * @return a result containing a bag either empty because no values were found or containing at\n+   * least one value, or status associated with an Indeterminate result\n+   */\n+  public EvaluationResult getActionAttribute(URI type, URI id, URI category, String issuer) {\n+    return getGenericAttributes(type, id, category, issuer, actionMap);\n+  }\n+\n+  /**\n+   * Returns attribute value(s) from the environment section of the request.\n+   *\n+   * @param type   the type of the attribute value(s) to find\n+   * @param id     the id of the attribute value(s) to find\n+   * @param issuer the issuer of the attribute value(s) to find or null\n+   * @return a result containing a bag either empty because no values were found or containing at\n+   * least one value, or status associated with an Indeterminate result\n+   */\n+  public EvaluationResult getEnvironmentAttribute(URI type, URI id, URI category, String issuer) {\n+    return getGenericAttributes(type, id, category, issuer, environmentMap);\n+  }\n+\n+  /**\n+   * Helper function for the resource, action and environment methods to get an attribute.\n+   */\n+  private EvaluationResult getGenericAttributes(URI type, URI id, URI category, String issuer,\n+                                                Map map) {\n+    // try to find the id\n+    Set attrSet = (Set) (map.get(id.toString()));\n+    if (attrSet == null) {\n+      // the request didn't have an attribute with that id, so we should\n+      // try asking the attribute finder\n+      return callHelper(type, id, issuer, category);\n+    }\n \n-        // now go through each, considering each Attribute object\n-        List attributes = new ArrayList();\n-        Iterator it = attrSet.iterator();\n+    // now go through each, considering each Attribute object\n+    List attributes = new ArrayList();\n+    Iterator it = attrSet.iterator();\n \n-        while (it.hasNext()) {\n-            Attribute attr = (Attribute) (it.next());\n+    while (it.hasNext()) {\n+      Attribute attr = (Attribute) (it.next());\n \n-            // make sure the type and issuer are correct\n-            if ((attr.getType().equals(type))\n-                    && ((issuer == null) || ((attr.getIssuer() != null) && (attr.getIssuer()\n-                    .equals(issuer.toString()))))) {\n+      // make sure the type and issuer are correct\n+      if ((attr.getType().equals(type))\n+        && ((issuer == null) || ((attr.getIssuer() != null) && (attr.getIssuer()\n+        .equals(issuer.toString()))))) {\n \n-                // if we got here, then we found a match, so we want to pull\n-                // out the values and put them in out list\n-                attributes.add(attr.getValue());\n-            }\n-        }\n-\n-        // see if we found any acceptable attributes\n-        if (attributes.size() == 0) {\n-            // we failed to find any that matched the type/issuer, or all the\n-            // Attribute types were empty...so ask the finder\n-            if (logger.isDebugEnabled())\n-                logger.debug(\"Attribute not in request: \" + id.toString()\n-                        + \" ... querying AttributeFinder\");\n+        // if we got here, then we found a match, so we want to pull\n+        // out the values and put them in out list\n+        attributes.add(attr.getValue());\n+      }\n+    }\n \n-            return callHelper(type, id, issuer, category);\n-        }\n+    // see if we found any acceptable attributes\n+    if (attributes.size() == 0) {\n+      // we failed to find any that matched the type/issuer, or all the\n+      // Attribute types were empty...so ask the finder\n+      if (logger.isDebugEnabled()) {\n+        logger.debug(\"Attribute not in request: \" + id.toString()\n+          + \" ... querying AttributeFinder\");\n+      }\n \n-        // if we got here, then we found at least one useful AttributeValue\n-        return new EvaluationResult(new BagAttribute(type, attributes));\n+      return callHelper(type, id, issuer, category);\n     }\n \n+    // if we got here, then we found at least one useful AttributeValue\n+    return new EvaluationResult(new BagAttribute(type, attributes));\n+  }\n \n-    public PDPConfig getPdpConfig() {\n-        return pdpConfig;\n-    }\n \n-    public AbstractRequestCtx getRequestCtx() {\n-        return requestCtx;\n-    }\n+  public PDPConfig getPdpConfig() {\n+    return pdpConfig;\n+  }\n \n-    public MultipleCtxResult getMultipleEvaluationCtx() {\n+  public AbstractRequestCtx getRequestCtx() {\n+    return requestCtx;\n+  }\n \n-        Set<EvaluationCtx> evaluationCtxSet = new HashSet<EvaluationCtx>();\n+  public MultipleCtxResult getMultipleEvaluationCtx() {\n \n-        if(scope != XACMLConstants.SCOPE_IMMEDIATE){\n-            MultipleCtxResult result = processHierarchicalAttributes(this);\n-            if(result.isIndeterminate()){\n-                return result;\n-            } else {\n-                evaluationCtxSet.addAll(result.getEvaluationCtxSet());\n-            }\n-        }\n-        \n-        if(evaluationCtxSet.size() > 0){\n-            return new MultipleCtxResult(evaluationCtxSet, null, false);\n-        } else {\n-            evaluationCtxSet.add(this);\n-            return new MultipleCtxResult(evaluationCtxSet, null, false);\n-        }\n-    }\n+    Set<EvaluationCtx> evaluationCtxSet = new HashSet<EvaluationCtx>();\n \n-    public int getResourceScope() {\n-        return scope;\n+    if (scope != XACMLConstants.SCOPE_IMMEDIATE) {\n+      MultipleCtxResult result = processHierarchicalAttributes(this);\n+      if (result.isIndeterminate()) {\n+        return result;\n+      } else {\n+        evaluationCtxSet.addAll(result.getEvaluationCtxSet());\n+      }\n     }\n \n-    private MultipleCtxResult processHierarchicalAttributes(XACML2EvaluationCtx evaluationCtx) {\n-\n-        ResourceFinderResult resourceResult = null;\n-        Set<EvaluationCtx> children = new HashSet<EvaluationCtx>();\n-        AttributeValue resourceId = evaluationCtx.getResourceId();\n-        int resourceScope = evaluationCtx.getResourceScope();\n-\n-        if(resourceId != null){\n-            if(resourceScope == XACMLConstants.SCOPE_CHILDREN){\n-                resourceResult = evaluationCtx.getPdpConfig().getResourceFinder().\n-                                                findChildResources(resourceId, evaluationCtx);\n-            } else if(resourceScope == XACMLConstants.SCOPE_DESCENDANTS) {\n-                resourceResult = evaluationCtx.getPdpConfig().getResourceFinder().\n-                                                findDescendantResources(resourceId, evaluationCtx);\n-            } else {\n-                logger.error(\"Unknown scope type: \" );\n-                //TODO\n-            }\n-        } else {\n-             logger.error(\"ResourceId Attribute is NULL: \" );\n-            // TODO\n-        }\n+    if (evaluationCtxSet.size() > 0) {\n+      return new MultipleCtxResult(evaluationCtxSet, null, false);\n+    } else {\n+      evaluationCtxSet.add(this);\n+      return new MultipleCtxResult(evaluationCtxSet, null, false);\n+    }\n+  }\n+\n+  public int getResourceScope() {\n+    return scope;\n+  }\n+\n+  private MultipleCtxResult processHierarchicalAttributes(XACML2EvaluationCtx evaluationCtx) {\n+\n+    ResourceFinderResult resourceResult = null;\n+    Set<EvaluationCtx> children = new HashSet<EvaluationCtx>();\n+    AttributeValue resourceId = evaluationCtx.getResourceId();\n+    int resourceScope = evaluationCtx.getResourceScope();\n+\n+    if (resourceId != null) {\n+      if (resourceScope == XACMLConstants.SCOPE_CHILDREN) {\n+        resourceResult = evaluationCtx.getPdpConfig().getResourceFinder().\n+          findChildResources(resourceId, evaluationCtx);\n+      } else if (resourceScope == XACMLConstants.SCOPE_DESCENDANTS) {\n+        resourceResult = evaluationCtx.getPdpConfig().getResourceFinder().\n+          findDescendantResources(resourceId, evaluationCtx);\n+      } else {\n+        logger.error(\"Unknown scope type: \");\n+        //TODO\n+      }\n+    } else {\n+      logger.error(\"ResourceId Attribute is NULL: \");\n+      // TODO\n+    }\n \n-        if(resourceResult == null || resourceResult.isEmpty()){\n-            logger.error(\"Resource Finder result is NULL: \" );\n-            // TODO\n-        } else {\n-            for (AttributeValue resource : resourceResult.getResources()) {\n-                evaluationCtx.setResourceId(resource, attributesSet);\n-                children.add(evaluationCtx);\n-            }\n-        }\n+    if (resourceResult == null || resourceResult.isEmpty()) {\n+      logger.error(\"Resource Finder result is NULL: \");\n+      // TODO\n+    } else {\n+      for (AttributeValue resource : resourceResult.getResources()) {\n+        evaluationCtx.setResourceId(resource, attributesSet);\n+        children.add(evaluationCtx);\n+      }\n+    }\n \n-        return new MultipleCtxResult(children, null, false);\n+    return new MultipleCtxResult(children, null, false);\n \n-    }\n+  }\n \n }\n",
            "diff_size": 570
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "472",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "474",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/77/XACML2EvaluationCtx.java\nindex 9fcaaf9d2a3..2d4f969bf88 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/77/XACML2EvaluationCtx.java\n@@ -133,7 +133,7 @@ public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n      * SubjectCategory that keeps Maps that in turn are indexed by id and keep the unique\n      * ctx.Attribute objects.\n      */\n-    private void setupSubjects(Set subjects)  {\n+    private void setupSubjects(Set subjects) {\n \n         // now go through the subject attributes\n         Iterator it = subjects.iterator();\n@@ -309,9 +309,9 @@ public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n             return getEnvironmentAttribute(type, id, category, issuer);\n         } else {\n             ArrayList<String> code = new ArrayList<String>();\n-            code.add(Status.STATUS_PROCESSING_ERROR);                                                                            ;\n+            code.add(Status.STATUS_PROCESSING_ERROR);;\n             Status status = new Status(code);\n-            return  new EvaluationResult(status);\n+            return new EvaluationResult(status);\n         }\n     }\n \n@@ -385,9 +385,8 @@ public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n     /**\n      * Helper function for the resource, action and environment methods to get an attribute.\n      */\n-    private EvaluationResult getGenericAttributes(URI type, URI id, URI category, String issuer,\n-                                                                                        Map map) {\n-        // try to find the id\n+    private EvaluationResult getGenericAttributes(URI type, URI id, URI category, String issuer, Map map) {\n+    // try to find the id\n         Set attrSet = (Set) (map.get(id.toString()));\n         if (attrSet == null) {\n             // the request didn't have an attribute with that id, so we should\n@@ -406,8 +405,7 @@ public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n             if ((attr.getType().equals(type))\n                     && ((issuer == null) || ((attr.getIssuer() != null) && (attr.getIssuer()\n                     .equals(issuer.toString()))))) {\n-\n-                // if we got here, then we found a match, so we want to pull\n+    // if we got here, then we found a match, so we want to pull\n                 // out the values and put them in out list\n                 attributes.add(attr.getValue());\n             }\n@@ -471,22 +469,19 @@ public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n \n         if(resourceId != null){\n             if(resourceScope == XACMLConstants.SCOPE_CHILDREN){\n-                resourceResult = evaluationCtx.getPdpConfig().getResourceFinder().\n-                                                findChildResources(resourceId, evaluationCtx);\n-            } else if(resourceScope == XACMLConstants.SCOPE_DESCENDANTS) {\n-                resourceResult = evaluationCtx.getPdpConfig().getResourceFinder().\n-                                                findDescendantResources(resourceId, evaluationCtx);\n-            } else {\n-                logger.error(\"Unknown scope type: \" );\n+                resourceResult = evaluationCtx.getPdpConfig().getResourceFinder().findChildResources(resourceId, evaluationCtx);\n+    } else if(resourceScope == XACMLConstants.SCOPE_DESCENDANTS) {\n+                resourceResult = evaluationCtx.getPdpConfig().getResourceFinder().findDescendantResources(resourceId, evaluationCtx);\n+    } else {\n+                logger.error(\"Unknown scope type: \");\n                 //TODO\n             }\n         } else {\n-             logger.error(\"ResourceId Attribute is NULL: \" );\n-            // TODO\n+             logger.error(\"ResourceId Attribute is NULL: \"); // TODO\n         }\n \n         if(resourceResult == null || resourceResult.isEmpty()){\n-            logger.error(\"Resource Finder result is NULL: \" );\n+            logger.error(\"Resource Finder result is NULL: \");\n             // TODO\n         } else {\n             for (AttributeValue resource : resourceResult.getResources()) {\n@@ -499,4 +494,4 @@ public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n \n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 19
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "314",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/77/XACML2EvaluationCtx.java\nindex 9fcaaf9d2a3..bf15522e480 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/77/XACML2EvaluationCtx.java\n@@ -309,8 +309,9 @@ public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n             return getEnvironmentAttribute(type, id, category, issuer);\n         } else {\n             ArrayList<String> code = new ArrayList<String>();\n-            code.add(Status.STATUS_PROCESSING_ERROR);                                                                            ;\n-            Status status = new Status(code);\n+            code.add(Status.STATUS_PROCESSING_ERROR);\n+  ;\n+                                                                                        Status status = new Status(code);\n             return  new EvaluationResult(status);\n         }\n     }\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/77/XACML2EvaluationCtx.java\nindex 9fcaaf9d2a3..12bcebaa8cd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/77/XACML2EvaluationCtx.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/77/XACML2EvaluationCtx.java\n@@ -309,8 +309,8 @@ public class XACML2EvaluationCtx extends BasicEvaluationCtx {\n             return getEnvironmentAttribute(type, id, category, issuer);\n         } else {\n             ArrayList<String> code = new ArrayList<String>();\n-            code.add(Status.STATUS_PROCESSING_ERROR);                                                                            ;\n-            Status status = new Status(code);\n+            code.add(Status.STATUS_PROCESSING_ERROR);\n+            ; Status status = new Status(code);\n             return  new EvaluationResult(status);\n         }\n     }\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}