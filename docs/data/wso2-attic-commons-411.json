{
    "project_name": "wso2-attic-commons",
    "error_id": "411",
    "information": {
        "errors": [
            {
                "line": "238",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 129).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                Long age = _instancesAge.get(id);\n                if (age != null && now-age > TIME_TO_LIVE) {\n                    __log.warn(\"Discarding in-memory instance \"+id+\" because it exceeded its time-to-live: \"+_instances.get(id));\n                    _instances.remove(id);\n                    _instancesAge.remove(id);\n                }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/411/ProcessDaoImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/411/ProcessDaoImpl.java\nindex e9f101d87cf..a5043c8beb7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/411/ProcessDaoImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/411/ProcessDaoImpl.java\n@@ -235,7 +235,8 @@ class ProcessDaoImpl extends DaoBaseImpl implements ProcessDAO {\n                 Long id = (Long) oldInstances[i];\n                 Long age = _instancesAge.get(id);\n                 if (age != null && now-age > TIME_TO_LIVE) {\n-                    __log.warn(\"Discarding in-memory instance \"+id+\" because it exceeded its time-to-live: \"+_instances.get(id));\n+                    __log.warn(\"Discarding in-memory instance \"+id+\" because it exceeded its time-to-live: \"\n+                            +_instances.get(id));\n                     _instances.remove(id);\n                     _instancesAge.remove(id);\n                 }\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/411/ProcessDaoImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/411/ProcessDaoImpl.java\nindex e9f101d87cf..5928ffb2ae7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/411/ProcessDaoImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/411/ProcessDaoImpl.java\n@@ -16,6 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n+\n package org.apache.ode.bpel.memdao;\n \n import java.util.ArrayList;\n@@ -41,205 +42,209 @@ import org.apache.ode.bpel.dao.ProcessInstanceDAO;\n  * A very simple, in-memory implementation of the {@link ProcessDAO} interface.\n  */\n class ProcessDaoImpl extends DaoBaseImpl implements ProcessDAO {\n-    private static final Log __log = LogFactory.getLog(ProcessDaoImpl.class);\n-    public static long TIME_TO_LIVE = 2*60*1000;\n-\n-    private QName _processId;\n-    private QName _type;\n-    private long _version;\n-    final Map<String, CorrelatorDaoImpl> _correlators = new ConcurrentHashMap<String, CorrelatorDaoImpl>();\n-    protected final Map<Long, ProcessInstanceDAO> _instances = new ConcurrentHashMap<Long, ProcessInstanceDAO>();\n-    protected final Map<Long, Long> _instancesAge = new ConcurrentHashMap<Long, Long>();\n-    protected final Map<Integer, PartnerLinkDAO> _plinks = new ConcurrentHashMap<Integer, PartnerLinkDAO>();\n-    private Map<QName, ProcessDaoImpl> _store;\n-    private BpelDAOConnectionImpl _conn;\n-    private int _executionCount = 0;\n-    private Collection<Long> _instancesToRemove = new ConcurrentLinkedQueue<Long>();\n-    private volatile long _lastRemoval = 0;\n-\n-    private String _guid;\n-\n-    public ProcessDaoImpl(BpelDAOConnectionImpl conn, Map<QName, ProcessDaoImpl> store,\n-                          QName processId, QName type, String guid, long version) {\n-        if (__log.isDebugEnabled()) {\n-            __log.debug(\"Creating ProcessDao object for process \\\"\" + processId + \"\\\".\");\n-        }\n-\n-        _guid = guid;\n-        _conn = conn;\n-        _store = store;\n-        _processId = processId;\n-        _type = type;\n-        _version = version;\n-    }\n-\n-    public QName getProcessId() {\n-        return _processId;\n-    }\n-\n-    public CorrelatorDAO getCorrelator(String cid) {\n-        CorrelatorDAO ret = _correlators.get(cid);\n-        if (ret == null) {\n-            throw new IllegalArgumentException(\"no such correlator: \" + cid);\n-        }\n-        return ret;\n-    }\n-\n-    public Collection<CorrelatorDAO> getCorrelators() {\n-        // Note: _correlators.values() is a Collection<CorrealatorDaoImpl>. We can't just return this object\n-        // since Collection<CorrelatorDAO> is /not/ assignment compatible with Collection<CorrelatorDaoImpl>. \n-        // However, a immutable Collection<CorrelationDAO> is assignment compatible with Collection<CorrelatorDaoImpl>,\n-        // but.... we need to introduce some ambiguity into the type hierarchy so that Java will infer the correct type.\n-        \n-        // Make an ambiguous collection.\n-        Collection<? extends CorrelatorDAO> foo =  _correlators.values();\n-\n-        // In order to get a collection of the super-type from a sub-type we must make the collection read-only. \n-        return Collections.unmodifiableCollection(foo);\n-    }\n-    \n-    public void removeRoutes(String routeId, ProcessInstanceDAO target) {\n-        for (CorrelatorDAO correlatorDAO : _correlators.values()) {\n-            correlatorDAO.removeRoutes(routeId, target);\n-        }\n-    }\n-\n-    public ProcessInstanceDAO createInstance(CorrelatorDAO correlator) {\n-        final ProcessInstanceDaoImpl newInstance = new ProcessInstanceDaoImpl(_conn, this, correlator);\n-        _conn.defer(new Runnable() {\n-            public void run() {\n-                _instances.put(newInstance.getInstanceId(), newInstance);\n-                _instancesAge.put(newInstance.getInstanceId(), System.currentTimeMillis());\n-            }\n-        });\n-\n-        discardOldInstances();\n-        \n-        // Removing right away on rollback\n-        final Long iid = newInstance.getInstanceId();\n-        _conn.onRollback(new Runnable() {\n-            public void run() {\n-                _instances.remove(iid);\n-                _instancesAge.remove(iid);\n-            }\n-        });\n-\n-        _executionCount++;\n-        return newInstance;\n-    }\n-\n-    public ProcessInstanceDAO getInstance(Long instanceId) {\n-        return _instances.get(instanceId);\n-    }\n-\n-    public Collection<ProcessInstanceDAO> findInstance(CorrelationKey key) {\n-        return findInstance(key, true);\n-    }\n-    \n-    public Collection<ProcessInstanceDAO> findInstance(CorrelationKey key, boolean wait) {\n-        ArrayList<ProcessInstanceDAO> result = new ArrayList<ProcessInstanceDAO>();\n-        for (ProcessInstanceDAO instance : _instances.values()) {\n-            for (CorrelationSetDAO corrSet : instance.getCorrelationSets()) {\n-                CorrelationKey value = corrSet.getValue();\n-                if (value != null) {\n-                    if (value.equals(key)) result.add(instance);\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    public void instanceCompleted(ProcessInstanceDAO instance) {\n-        // Cleaning up\n-        if (__log.isDebugEnabled())\n-          __log.debug(\"Removing completed process instance \" + instance.getInstanceId() + \" from in-memory store.\");\n-        _instancesAge.remove(instance.getInstanceId());\n-        ProcessInstanceDAO removed = _instances.remove(instance.getInstanceId());\n-        if (removed == null) {\n-            // Checking for leftover instances that should be removed\n-            ArrayList<Long> removals = new ArrayList<Long>(_instancesToRemove);\n-            for (Long iid : removals) {\n-                _instances.remove(iid);\n-            }\n-            _instancesToRemove.removeAll(removals);\n-\n-            // The instance can't be found probably because the transaction isn't committed yet and\n-            // it doesn't exist. Saving its id for later cleanup.\n-            _instancesToRemove.add(instance.getInstanceId());\n+  private static final Log __log = LogFactory.getLog(ProcessDaoImpl.class);\n+  public static long TIME_TO_LIVE = 2 * 60 * 1000;\n+\n+  private QName _processId;\n+  private QName _type;\n+  private long _version;\n+  final Map<String, CorrelatorDaoImpl> _correlators = new ConcurrentHashMap<String, CorrelatorDaoImpl>();\n+  protected final Map<Long, ProcessInstanceDAO> _instances = new ConcurrentHashMap<Long, ProcessInstanceDAO>();\n+  protected final Map<Long, Long> _instancesAge = new ConcurrentHashMap<Long, Long>();\n+  protected final Map<Integer, PartnerLinkDAO> _plinks = new ConcurrentHashMap<Integer, PartnerLinkDAO>();\n+  private Map<QName, ProcessDaoImpl> _store;\n+  private BpelDAOConnectionImpl _conn;\n+  private int _executionCount = 0;\n+  private Collection<Long> _instancesToRemove = new ConcurrentLinkedQueue<Long>();\n+  private volatile long _lastRemoval = 0;\n+\n+  private String _guid;\n+\n+  public ProcessDaoImpl(BpelDAOConnectionImpl conn, Map<QName, ProcessDaoImpl> store,\n+                        QName processId, QName type, String guid, long version) {\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(\"Creating ProcessDao object for process \\\"\" + processId + \"\\\".\");\n+    }\n+\n+    _guid = guid;\n+    _conn = conn;\n+    _store = store;\n+    _processId = processId;\n+    _type = type;\n+    _version = version;\n+  }\n+\n+  public QName getProcessId() {\n+    return _processId;\n+  }\n+\n+  public CorrelatorDAO getCorrelator(String cid) {\n+    CorrelatorDAO ret = _correlators.get(cid);\n+    if (ret == null) {\n+      throw new IllegalArgumentException(\"no such correlator: \" + cid);\n+    }\n+    return ret;\n+  }\n+\n+  public Collection<CorrelatorDAO> getCorrelators() {\n+    // Note: _correlators.values() is a Collection<CorrealatorDaoImpl>. We can't just return this object\n+    // since Collection<CorrelatorDAO> is /not/ assignment compatible with Collection<CorrelatorDaoImpl>.\n+    // However, a immutable Collection<CorrelationDAO> is assignment compatible with Collection<CorrelatorDaoImpl>,\n+    // but.... we need to introduce some ambiguity into the type hierarchy so that Java will infer the correct type.\n+\n+    // Make an ambiguous collection.\n+    Collection<? extends CorrelatorDAO> foo = _correlators.values();\n+\n+    // In order to get a collection of the super-type from a sub-type we must make the collection read-only.\n+    return Collections.unmodifiableCollection(foo);\n+  }\n+\n+  public void removeRoutes(String routeId, ProcessInstanceDAO target) {\n+    for (CorrelatorDAO correlatorDAO : _correlators.values()) {\n+      correlatorDAO.removeRoutes(routeId, target);\n+    }\n+  }\n+\n+  public ProcessInstanceDAO createInstance(CorrelatorDAO correlator) {\n+    final ProcessInstanceDaoImpl newInstance = new ProcessInstanceDaoImpl(_conn, this, correlator);\n+    _conn.defer(new Runnable() {\n+      public void run() {\n+        _instances.put(newInstance.getInstanceId(), newInstance);\n+        _instancesAge.put(newInstance.getInstanceId(), System.currentTimeMillis());\n+      }\n+    });\n+\n+    discardOldInstances();\n+\n+    // Removing right away on rollback\n+    final Long iid = newInstance.getInstanceId();\n+    _conn.onRollback(new Runnable() {\n+      public void run() {\n+        _instances.remove(iid);\n+        _instancesAge.remove(iid);\n+      }\n+    });\n+\n+    _executionCount++;\n+    return newInstance;\n+  }\n+\n+  public ProcessInstanceDAO getInstance(Long instanceId) {\n+    return _instances.get(instanceId);\n+  }\n+\n+  public Collection<ProcessInstanceDAO> findInstance(CorrelationKey key) {\n+    return findInstance(key, true);\n+  }\n+\n+  public Collection<ProcessInstanceDAO> findInstance(CorrelationKey key, boolean wait) {\n+    ArrayList<ProcessInstanceDAO> result = new ArrayList<ProcessInstanceDAO>();\n+    for (ProcessInstanceDAO instance : _instances.values()) {\n+      for (CorrelationSetDAO corrSet : instance.getCorrelationSets()) {\n+        CorrelationKey value = corrSet.getValue();\n+        if (value != null) {\n+          if (value.equals(key)) {\n+            result.add(instance);\n+          }\n         }\n-    }\n-\n-    public void delete() {\n-        _store.remove(_processId);\n-    }\n-\n-    public long getVersion() {\n-        return _version;\n-    }\n-\n-    public String getDeployer() {\n-        return \"nobody\";\n-    }\n-\n-    public QName getType() {\n-        return _type;\n-    }\n-\n-    public CorrelatorDAO addCorrelator(String correlator) {\n-        CorrelatorDaoImpl corr = new CorrelatorDaoImpl(correlator, _conn);\n-        _correlators.put(corr.getCorrelatorId(), corr);\n-        return corr;\n-    }\n-\n-    /**\n-     * Nothing to do.\n-     */\n-    public void update() {\n-        //TODO Check requirement for persisting.\n-    }\n-\n-    public int getNumInstances() {\n-        // Instances are removed after execution, using a counter instead\n-        return _executionCount;\n-    }\n-\n-    public ProcessInstanceDAO getInstanceWithLock(Long iid) {\n-        return getInstance(iid);\n-    }\n-\n-    public int getActivityFailureCount() {\n-        return 0;  \n-    }\n-\n-    public Date getActivityFailureDateTime() {\n-        return null;\n-    }\n-\n-    public String getGuid() {\n-        return _guid;\n-    }\n-    \n-    public void setGuid(String guid) {\n-        _guid = guid;\n-    }\n-\n-    /**\n-     * Discard in-memory instances that exceeded their time-to-live to prevent memory leaks\n-     */\n-    void discardOldInstances() {\n-        long now = System.currentTimeMillis();\n-        if (now > _lastRemoval + (TIME_TO_LIVE / 4)) {\n-            _lastRemoval = now;\n-            Object[] oldInstances = _instancesAge.keySet().toArray();\n-            for (int i=oldInstances.length-1; i>=0; i--) {\n-                Long id = (Long) oldInstances[i];\n-                Long age = _instancesAge.get(id);\n-                if (age != null && now-age > TIME_TO_LIVE) {\n-                    __log.warn(\"Discarding in-memory instance \"+id+\" because it exceeded its time-to-live: \"+_instances.get(id));\n-                    _instances.remove(id);\n-                    _instancesAge.remove(id);\n-                }\n-            }\n+      }\n+    }\n+    return result;\n+  }\n+\n+  public void instanceCompleted(ProcessInstanceDAO instance) {\n+    // Cleaning up\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(\"Removing completed process instance \" + instance.getInstanceId() + \" from in-memory store.\");\n+    }\n+    _instancesAge.remove(instance.getInstanceId());\n+    ProcessInstanceDAO removed = _instances.remove(instance.getInstanceId());\n+    if (removed == null) {\n+      // Checking for leftover instances that should be removed\n+      ArrayList<Long> removals = new ArrayList<Long>(_instancesToRemove);\n+      for (Long iid : removals) {\n+        _instances.remove(iid);\n+      }\n+      _instancesToRemove.removeAll(removals);\n+\n+      // The instance can't be found probably because the transaction isn't committed yet and\n+      // it doesn't exist. Saving its id for later cleanup.\n+      _instancesToRemove.add(instance.getInstanceId());\n+    }\n+  }\n+\n+  public void delete() {\n+    _store.remove(_processId);\n+  }\n+\n+  public long getVersion() {\n+    return _version;\n+  }\n+\n+  public String getDeployer() {\n+    return \"nobody\";\n+  }\n+\n+  public QName getType() {\n+    return _type;\n+  }\n+\n+  public CorrelatorDAO addCorrelator(String correlator) {\n+    CorrelatorDaoImpl corr = new CorrelatorDaoImpl(correlator, _conn);\n+    _correlators.put(corr.getCorrelatorId(), corr);\n+    return corr;\n+  }\n+\n+  /**\n+   * Nothing to do.\n+   */\n+  public void update() {\n+    //TODO Check requirement for persisting.\n+  }\n+\n+  public int getNumInstances() {\n+    // Instances are removed after execution, using a counter instead\n+    return _executionCount;\n+  }\n+\n+  public ProcessInstanceDAO getInstanceWithLock(Long iid) {\n+    return getInstance(iid);\n+  }\n+\n+  public int getActivityFailureCount() {\n+    return 0;\n+  }\n+\n+  public Date getActivityFailureDateTime() {\n+    return null;\n+  }\n+\n+  public String getGuid() {\n+    return _guid;\n+  }\n+\n+  public void setGuid(String guid) {\n+    _guid = guid;\n+  }\n+\n+  /**\n+   * Discard in-memory instances that exceeded their time-to-live to prevent memory leaks\n+   */\n+  void discardOldInstances() {\n+    long now = System.currentTimeMillis();\n+    if (now > _lastRemoval + (TIME_TO_LIVE / 4)) {\n+      _lastRemoval = now;\n+      Object[] oldInstances = _instancesAge.keySet().toArray();\n+      for (int i = oldInstances.length - 1; i >= 0; i--) {\n+        Long id = (Long) oldInstances[i];\n+        Long age = _instancesAge.get(id);\n+        if (age != null && now - age > TIME_TO_LIVE) {\n+          __log.warn(\n+            \"Discarding in-memory instance \" + id + \" because it exceeded its time-to-live: \" + _instances.get(id));\n+          _instances.remove(id);\n+          _instancesAge.remove(id);\n         }\n+      }\n     }\n+  }\n }\n",
            "diff_size": 224
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "62",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 145).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "237",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/411/ProcessDaoImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/411/ProcessDaoImpl.java\nindex e9f101d87cf..368bbb285c2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/411/ProcessDaoImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/411/ProcessDaoImpl.java\n@@ -59,9 +59,8 @@ class ProcessDaoImpl extends DaoBaseImpl implements ProcessDAO {\n \n     private String _guid;\n \n-    public ProcessDaoImpl(BpelDAOConnectionImpl conn, Map<QName, ProcessDaoImpl> store,\n-                          QName processId, QName type, String guid, long version) {\n-        if (__log.isDebugEnabled()) {\n+    public ProcessDaoImpl(BpelDAOConnectionImpl conn, Map<QName, ProcessDaoImpl> store, QName processId, QName type, String guid, long version) {\n+    if (__log.isDebugEnabled()) {\n             __log.debug(\"Creating ProcessDao object for process \\\"\" + processId + \"\\\".\");\n         }\n \n@@ -211,7 +210,7 @@ class ProcessDaoImpl extends DaoBaseImpl implements ProcessDAO {\n         return 0;  \n     }\n \n-    public Date getActivityFailureDateTime() {\n+public Date getActivityFailureDateTime() {\n         return null;\n     }\n \n@@ -242,4 +241,4 @@ class ProcessDaoImpl extends DaoBaseImpl implements ProcessDAO {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 5
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "238",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/411/ProcessDaoImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/411/ProcessDaoImpl.java\nindex e9f101d87cf..a5043c8beb7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/411/ProcessDaoImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/411/ProcessDaoImpl.java\n@@ -235,7 +235,8 @@ class ProcessDaoImpl extends DaoBaseImpl implements ProcessDAO {\n                 Long id = (Long) oldInstances[i];\n                 Long age = _instancesAge.get(id);\n                 if (age != null && now-age > TIME_TO_LIVE) {\n-                    __log.warn(\"Discarding in-memory instance \"+id+\" because it exceeded its time-to-live: \"+_instances.get(id));\n+                    __log.warn(\"Discarding in-memory instance \"+id+\" because it exceeded its time-to-live: \"\n+                            +_instances.get(id));\n                     _instances.remove(id);\n                     _instancesAge.remove(id);\n                 }\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}