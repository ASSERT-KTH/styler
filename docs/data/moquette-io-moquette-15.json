{
    "project_name": "moquette-io-moquette",
    "error_id": "15",
    "information": {
        "errors": [
            {
                "line": "70",
                "severity": "warning",
                "message": "Line is longer than 120 characters (found 122).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "    public void startServer() throws IOException {\n        File defaultConfigurationFile = defaultConfigFile();\n        LOG.info(\"Starting Moquette integration. Configuration file path={}\", defaultConfigurationFile.getAbsolutePath());\n        IResourceLoader filesystemLoader = new FileResourceLoader(defaultConfigurationFile);\n        final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n        startServer(config);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "70",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/15/Server.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/15/Server.java\nindex 8f1ec8252bf..9542535adc8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/15/Server.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/15/Server.java\n@@ -13,6 +13,7 @@\n  *\n  * You may elect to redistribute this code under either of these licenses.\n  */\n+\n package io.moquette.broker;\n \n import io.moquette.BrokerConstants;\n@@ -42,306 +43,306 @@ import static io.moquette.logging.LoggingUtils.getInterceptorIds;\n \n public class Server {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(io.moquette.broker.Server.class);\n-\n-    private ScheduledExecutorService scheduler;\n-    private NewNettyAcceptor acceptor;\n-    private volatile boolean initialized;\n-    private PostOffice dispatcher;\n-    private BrokerInterceptor interceptor;\n-    private H2Builder h2Builder;\n-    private SessionRegistry sessions;\n-\n-    public static void main(String[] args) throws IOException {\n-        final Server server = new Server();\n-        server.startServer();\n-        System.out.println(\"Server started, version 0.12.1-SNAPSHOT\");\n-        //Bind a shutdown hook\n-        Runtime.getRuntime().addShutdownHook(new Thread(server::stopServer));\n+  private static final Logger LOG = LoggerFactory.getLogger(io.moquette.broker.Server.class);\n+\n+  private ScheduledExecutorService scheduler;\n+  private NewNettyAcceptor acceptor;\n+  private volatile boolean initialized;\n+  private PostOffice dispatcher;\n+  private BrokerInterceptor interceptor;\n+  private H2Builder h2Builder;\n+  private SessionRegistry sessions;\n+\n+  public static void main(String[] args) throws IOException {\n+    final Server server = new Server();\n+    server.startServer();\n+    System.out.println(\"Server started, version 0.12.1-SNAPSHOT\");\n+    //Bind a shutdown hook\n+    Runtime.getRuntime().addShutdownHook(new Thread(server::stopServer));\n+  }\n+\n+  /**\n+   * Starts Moquette bringing the configuration from the file located at m_config/moquette.conf\n+   *\n+   * @throws IOException in case of any IO error.\n+   */\n+  public void startServer() throws IOException {\n+    File defaultConfigurationFile = defaultConfigFile();\n+    LOG.info(\"Starting Moquette integration. Configuration file path={}\", defaultConfigurationFile.getAbsolutePath());\n+    IResourceLoader filesystemLoader = new FileResourceLoader(defaultConfigurationFile);\n+    final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n+    startServer(config);\n+  }\n+\n+  private static File defaultConfigFile() {\n+    String configPath = System.getProperty(\"moquette.path\", null);\n+    return new File(configPath, IConfig.DEFAULT_CONFIG);\n+  }\n+\n+  /**\n+   * Starts Moquette bringing the configuration from the given file\n+   *\n+   * @param configFile text file that contains the configuration.\n+   * @throws IOException in case of any IO Error.\n+   */\n+  public void startServer(File configFile) throws IOException {\n+    LOG.info(\"Starting Moquette integration. Configuration file path: {}\", configFile.getAbsolutePath());\n+    IResourceLoader filesystemLoader = new FileResourceLoader(configFile);\n+    final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n+    startServer(config);\n+  }\n+\n+  /**\n+   * Starts the integration with the given properties.\n+   * <p>\n+   * Its suggested to at least have the following properties:\n+   * <ul>\n+   *  <li>port</li>\n+   *  <li>password_file</li>\n+   * </ul>\n+   *\n+   * @param configProps the properties map to use as configuration.\n+   * @throws IOException in case of any IO Error.\n+   */\n+  public void startServer(Properties configProps) throws IOException {\n+    LOG.debug(\"Starting Moquette integration using properties object\");\n+    final IConfig config = new MemoryConfig(configProps);\n+    startServer(config);\n+  }\n+\n+  /**\n+   * Starts Moquette bringing the configuration files from the given Config implementation.\n+   *\n+   * @param config the configuration to use to start the broker.\n+   * @throws IOException in case of any IO Error.\n+   */\n+  public void startServer(IConfig config) throws IOException {\n+    LOG.debug(\"Starting Moquette integration using IConfig instance\");\n+    startServer(config, null);\n+  }\n+\n+  /**\n+   * Starts Moquette with config provided by an implementation of IConfig class and with the set\n+   * of InterceptHandler.\n+   *\n+   * @param config   the configuration to use to start the broker.\n+   * @param handlers the handlers to install in the broker.\n+   * @throws IOException in case of any IO Error.\n+   */\n+  public void startServer(IConfig config, List<? extends InterceptHandler> handlers) throws IOException {\n+    LOG.debug(\"Starting moquette integration using IConfig instance and intercept handlers\");\n+    startServer(config, handlers, null, null, null);\n+  }\n+\n+  public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator,\n+                          IAuthenticator authenticator, IAuthorizatorPolicy authorizatorPolicy) {\n+    final long start = System.currentTimeMillis();\n+    if (handlers == null) {\n+      handlers = Collections.emptyList();\n     }\n+    LOG.trace(\"Starting Moquette Server. MQTT message interceptors={}\", getInterceptorIds(handlers));\n \n-    /**\n-     * Starts Moquette bringing the configuration from the file located at m_config/moquette.conf\n-     *\n-     * @throws IOException in case of any IO error.\n-     */\n-    public void startServer() throws IOException {\n-        File defaultConfigurationFile = defaultConfigFile();\n-        LOG.info(\"Starting Moquette integration. Configuration file path={}\", defaultConfigurationFile.getAbsolutePath());\n-        IResourceLoader filesystemLoader = new FileResourceLoader(defaultConfigurationFile);\n-        final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n-        startServer(config);\n-    }\n+    scheduler = Executors.newScheduledThreadPool(1);\n \n-    private static File defaultConfigFile() {\n-        String configPath = System.getProperty(\"moquette.path\", null);\n-        return new File(configPath, IConfig.DEFAULT_CONFIG);\n+    final String handlerProp = System.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n+    if (handlerProp != null) {\n+      config.setProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME, handlerProp);\n     }\n-\n-    /**\n-     * Starts Moquette bringing the configuration from the given file\n-     *\n-     * @param configFile text file that contains the configuration.\n-     * @throws IOException in case of any IO Error.\n-     */\n-    public void startServer(File configFile) throws IOException {\n-        LOG.info(\"Starting Moquette integration. Configuration file path: {}\", configFile.getAbsolutePath());\n-        IResourceLoader filesystemLoader = new FileResourceLoader(configFile);\n-        final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n-        startServer(config);\n-    }\n-\n-    /**\n-     * Starts the integration with the given properties.\n-     * <p>\n-     * Its suggested to at least have the following properties:\n-     * <ul>\n-     *  <li>port</li>\n-     *  <li>password_file</li>\n-     * </ul>\n-     *\n-     * @param configProps the properties map to use as configuration.\n-     * @throws IOException in case of any IO Error.\n-     */\n-    public void startServer(Properties configProps) throws IOException {\n-        LOG.debug(\"Starting Moquette integration using properties object\");\n-        final IConfig config = new MemoryConfig(configProps);\n-        startServer(config);\n+    final String persistencePath = config.getProperty(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME);\n+    LOG.debug(\"Configuring Using persistent store file, path: {}\", persistencePath);\n+    initInterceptors(config, handlers);\n+    LOG.debug(\"Initialized MQTT protocol processor\");\n+    if (sslCtxCreator == null) {\n+      LOG.info(\"Using default SSL context creator\");\n+      sslCtxCreator = new DefaultMoquetteSslContextCreator(config);\n     }\n-\n-    /**\n-     * Starts Moquette bringing the configuration files from the given Config implementation.\n-     *\n-     * @param config the configuration to use to start the broker.\n-     * @throws IOException in case of any IO Error.\n-     */\n-    public void startServer(IConfig config) throws IOException {\n-        LOG.debug(\"Starting Moquette integration using IConfig instance\");\n-        startServer(config, null);\n+    authenticator = initializeAuthenticator(authenticator, config);\n+    authorizatorPolicy = initializeAuthorizatorPolicy(authorizatorPolicy, config);\n+\n+    final ISubscriptionsRepository subscriptionsRepository;\n+    final IQueueRepository queueRepository;\n+    final IRetainedRepository retainedRepository;\n+    if (persistencePath != null && !persistencePath.isEmpty()) {\n+      LOG.trace(\"Configuring H2 subscriptions store to {}\", persistencePath);\n+      h2Builder = new H2Builder(config, scheduler).initStore();\n+      subscriptionsRepository = h2Builder.subscriptionsRepository();\n+      queueRepository = h2Builder.queueRepository();\n+      retainedRepository = h2Builder.retainedRepository();\n+    } else {\n+      LOG.trace(\"Configuring in-memory subscriptions store\");\n+      subscriptionsRepository = new MemorySubscriptionsRepository();\n+      queueRepository = new MemoryQueueRepository();\n+      retainedRepository = new MemoryRetainedRepository();\n     }\n \n-    /**\n-     * Starts Moquette with config provided by an implementation of IConfig class and with the set\n-     * of InterceptHandler.\n-     *\n-     * @param config   the configuration to use to start the broker.\n-     * @param handlers the handlers to install in the broker.\n-     * @throws IOException in case of any IO Error.\n-     */\n-    public void startServer(IConfig config, List<? extends InterceptHandler> handlers) throws IOException {\n-        LOG.debug(\"Starting moquette integration using IConfig instance and intercept handlers\");\n-        startServer(config, handlers, null, null, null);\n+    ISubscriptionsDirectory subscriptions = new CTrieSubscriptionDirectory();\n+    subscriptions.init(subscriptionsRepository);\n+    final Authorizator authorizator = new Authorizator(authorizatorPolicy);\n+    sessions = new SessionRegistry(subscriptions, queueRepository, authorizator);\n+    dispatcher = new PostOffice(subscriptions, retainedRepository, sessions, interceptor, authorizator);\n+    final BrokerConfiguration brokerConfig = new BrokerConfiguration(config);\n+    MQTTConnectionFactory connectionFactory = new MQTTConnectionFactory(brokerConfig, authenticator, sessions,\n+        dispatcher);\n+\n+    final NewNettyMQTTHandler mqttHandler = new NewNettyMQTTHandler(connectionFactory);\n+    acceptor = new NewNettyAcceptor();\n+    acceptor.initialize(mqttHandler, config, sslCtxCreator);\n+\n+    final long startTime = System.currentTimeMillis() - start;\n+    LOG.info(\"Moquette integration has been started successfully in {} ms\", startTime);\n+    initialized = true;\n+  }\n+\n+  private IAuthorizatorPolicy initializeAuthorizatorPolicy(IAuthorizatorPolicy authorizatorPolicy, IConfig props) {\n+    LOG.debug(\"Configuring MQTT authorizator policy\");\n+    String authorizatorClassName = props.getProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME, \"\");\n+    if (authorizatorPolicy == null && !authorizatorClassName.isEmpty()) {\n+      authorizatorPolicy = loadClass(authorizatorClassName, IAuthorizatorPolicy.class, IConfig.class, props);\n     }\n \n-    public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator,\n-                            IAuthenticator authenticator, IAuthorizatorPolicy authorizatorPolicy) {\n-        final long start = System.currentTimeMillis();\n-        if (handlers == null) {\n-            handlers = Collections.emptyList();\n-        }\n-        LOG.trace(\"Starting Moquette Server. MQTT message interceptors={}\", getInterceptorIds(handlers));\n-\n-        scheduler = Executors.newScheduledThreadPool(1);\n-\n-        final String handlerProp = System.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n-        if (handlerProp != null) {\n-            config.setProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME, handlerProp);\n-        }\n-        final String persistencePath = config.getProperty(BrokerConstants.PERSISTENT_STORE_PROPERTY_NAME);\n-        LOG.debug(\"Configuring Using persistent store file, path: {}\", persistencePath);\n-        initInterceptors(config, handlers);\n-        LOG.debug(\"Initialized MQTT protocol processor\");\n-        if (sslCtxCreator == null) {\n-            LOG.info(\"Using default SSL context creator\");\n-            sslCtxCreator = new DefaultMoquetteSslContextCreator(config);\n-        }\n-        authenticator = initializeAuthenticator(authenticator, config);\n-        authorizatorPolicy = initializeAuthorizatorPolicy(authorizatorPolicy, config);\n-\n-        final ISubscriptionsRepository subscriptionsRepository;\n-        final IQueueRepository queueRepository;\n-        final IRetainedRepository retainedRepository;\n-        if (persistencePath != null && !persistencePath.isEmpty()) {\n-            LOG.trace(\"Configuring H2 subscriptions store to {}\", persistencePath);\n-            h2Builder = new H2Builder(config, scheduler).initStore();\n-            subscriptionsRepository = h2Builder.subscriptionsRepository();\n-            queueRepository = h2Builder.queueRepository();\n-            retainedRepository = h2Builder.retainedRepository();\n-        } else {\n-            LOG.trace(\"Configuring in-memory subscriptions store\");\n-            subscriptionsRepository = new MemorySubscriptionsRepository();\n-            queueRepository = new MemoryQueueRepository();\n-            retainedRepository = new MemoryRetainedRepository();\n+    if (authorizatorPolicy == null) {\n+      String aclFilePath = props.getProperty(BrokerConstants.ACL_FILE_PROPERTY_NAME, \"\");\n+      if (aclFilePath != null && !aclFilePath.isEmpty()) {\n+        authorizatorPolicy = new DenyAllAuthorizatorPolicy();\n+        try {\n+          LOG.info(\"Parsing ACL file. Path = {}\", aclFilePath);\n+          IResourceLoader resourceLoader = props.getResourceLoader();\n+          authorizatorPolicy = ACLFileParser.parse(resourceLoader.loadResource(aclFilePath));\n+        } catch (ParseException pex) {\n+          LOG.error(\"Unable to parse ACL file. path = {}\", aclFilePath, pex);\n         }\n-\n-        ISubscriptionsDirectory subscriptions = new CTrieSubscriptionDirectory();\n-        subscriptions.init(subscriptionsRepository);\n-        final Authorizator authorizator = new Authorizator(authorizatorPolicy);\n-        sessions = new SessionRegistry(subscriptions, queueRepository, authorizator);\n-        dispatcher = new PostOffice(subscriptions, retainedRepository, sessions, interceptor, authorizator);\n-        final BrokerConfiguration brokerConfig = new BrokerConfiguration(config);\n-        MQTTConnectionFactory connectionFactory = new MQTTConnectionFactory(brokerConfig, authenticator, sessions,\n-                                                                            dispatcher);\n-\n-        final NewNettyMQTTHandler mqttHandler = new NewNettyMQTTHandler(connectionFactory);\n-        acceptor = new NewNettyAcceptor();\n-        acceptor.initialize(mqttHandler, config, sslCtxCreator);\n-\n-        final long startTime = System.currentTimeMillis() - start;\n-        LOG.info(\"Moquette integration has been started successfully in {} ms\", startTime);\n-        initialized = true;\n+      } else {\n+        authorizatorPolicy = new PermitAllAuthorizatorPolicy();\n+      }\n+      LOG.info(\"Authorizator policy {} instance will be used\", authorizatorPolicy.getClass().getName());\n     }\n+    return authorizatorPolicy;\n+  }\n \n-    private IAuthorizatorPolicy initializeAuthorizatorPolicy(IAuthorizatorPolicy authorizatorPolicy, IConfig props) {\n-        LOG.debug(\"Configuring MQTT authorizator policy\");\n-        String authorizatorClassName = props.getProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME, \"\");\n-        if (authorizatorPolicy == null && !authorizatorClassName.isEmpty()) {\n-            authorizatorPolicy = loadClass(authorizatorClassName, IAuthorizatorPolicy.class, IConfig.class, props);\n-        }\n+  private IAuthenticator initializeAuthenticator(IAuthenticator authenticator, IConfig props) {\n+    LOG.debug(\"Configuring MQTT authenticator\");\n+    String authenticatorClassName = props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, \"\");\n \n-        if (authorizatorPolicy == null) {\n-            String aclFilePath = props.getProperty(BrokerConstants.ACL_FILE_PROPERTY_NAME, \"\");\n-            if (aclFilePath != null && !aclFilePath.isEmpty()) {\n-                authorizatorPolicy = new DenyAllAuthorizatorPolicy();\n-                try {\n-                    LOG.info(\"Parsing ACL file. Path = {}\", aclFilePath);\n-                    IResourceLoader resourceLoader = props.getResourceLoader();\n-                    authorizatorPolicy = ACLFileParser.parse(resourceLoader.loadResource(aclFilePath));\n-                } catch (ParseException pex) {\n-                    LOG.error(\"Unable to parse ACL file. path = {}\", aclFilePath, pex);\n-                }\n-            } else {\n-                authorizatorPolicy = new PermitAllAuthorizatorPolicy();\n-            }\n-            LOG.info(\"Authorizator policy {} instance will be used\", authorizatorPolicy.getClass().getName());\n-        }\n-        return authorizatorPolicy;\n+    if (authenticator == null && !authenticatorClassName.isEmpty()) {\n+      authenticator = loadClass(authenticatorClassName, IAuthenticator.class, IConfig.class, props);\n     }\n \n-    private IAuthenticator initializeAuthenticator(IAuthenticator authenticator, IConfig props) {\n-        LOG.debug(\"Configuring MQTT authenticator\");\n-        String authenticatorClassName = props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, \"\");\n-\n-        if (authenticator == null && !authenticatorClassName.isEmpty()) {\n-            authenticator = loadClass(authenticatorClassName, IAuthenticator.class, IConfig.class, props);\n-        }\n-\n-        IResourceLoader resourceLoader = props.getResourceLoader();\n-        if (authenticator == null) {\n-            String passwdPath = props.getProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME, \"\");\n-            if (passwdPath.isEmpty()) {\n-                authenticator = new AcceptAllAuthenticator();\n-            } else {\n-                authenticator = new ResourceAuthenticator(resourceLoader, passwdPath);\n-            }\n-            LOG.info(\"An {} authenticator instance will be used\", authenticator.getClass().getName());\n-        }\n-        return authenticator;\n+    IResourceLoader resourceLoader = props.getResourceLoader();\n+    if (authenticator == null) {\n+      String passwdPath = props.getProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME, \"\");\n+      if (passwdPath.isEmpty()) {\n+        authenticator = new AcceptAllAuthenticator();\n+      } else {\n+        authenticator = new ResourceAuthenticator(resourceLoader, passwdPath);\n+      }\n+      LOG.info(\"An {} authenticator instance will be used\", authenticator.getClass().getName());\n     }\n-\n-    private void initInterceptors(IConfig props, List<? extends InterceptHandler> embeddedObservers) {\n-        LOG.info(\"Configuring message interceptors...\");\n-\n-        List<InterceptHandler> observers = new ArrayList<>(embeddedObservers);\n-        String interceptorClassName = props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n-        if (interceptorClassName != null && !interceptorClassName.isEmpty()) {\n-            InterceptHandler handler = loadClass(interceptorClassName, InterceptHandler.class,\n-                                                 io.moquette.broker.Server.class, this);\n-            if (handler != null) {\n-                observers.add(handler);\n-            }\n-        }\n-        interceptor = new BrokerInterceptor(props, observers);\n+    return authenticator;\n+  }\n+\n+  private void initInterceptors(IConfig props, List<? extends InterceptHandler> embeddedObservers) {\n+    LOG.info(\"Configuring message interceptors...\");\n+\n+    List<InterceptHandler> observers = new ArrayList<>(embeddedObservers);\n+    String interceptorClassName = props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n+    if (interceptorClassName != null && !interceptorClassName.isEmpty()) {\n+      InterceptHandler handler = loadClass(interceptorClassName, InterceptHandler.class,\n+          io.moquette.broker.Server.class, this);\n+      if (handler != null) {\n+        observers.add(handler);\n+      }\n     }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private <T, U> T loadClass(String className, Class<T> intrface, Class<U> constructorArgClass, U props) {\n-        T instance = null;\n-        try {\n-            // check if constructor with constructor arg class parameter\n-            // exists\n-            LOG.info(\"Invoking constructor with {} argument. ClassName={}, interfaceName={}\",\n-                     constructorArgClass.getName(), className, intrface.getName());\n-            instance = this.getClass().getClassLoader()\n-                .loadClass(className)\n-                .asSubclass(intrface)\n-                .getConstructor(constructorArgClass)\n-                .newInstance(props);\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException ex) {\n-            LOG.warn(\"Unable to invoke constructor with {} argument. ClassName={}, interfaceName={}, cause={}, \" +\n-                     \"errorMessage={}\", constructorArgClass.getName(), className, intrface.getName(), ex.getCause(),\n-                     ex.getMessage());\n-            return null;\n-        } catch (NoSuchMethodException | InvocationTargetException e) {\n-            try {\n-                LOG.info(\"Invoking default constructor. ClassName={}, interfaceName={}\", className, intrface.getName());\n-                // fallback to default constructor\n-                instance = this.getClass().getClassLoader()\n-                    .loadClass(className)\n-                    .asSubclass(intrface)\n-                    .getDeclaredConstructor().newInstance();\n-            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n-                NoSuchMethodException | InvocationTargetException ex) {\n-                LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n-                          \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n-                return null;\n-            }\n-        }\n-\n-        return instance;\n+    interceptor = new BrokerInterceptor(props, observers);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T, U> T loadClass(String className, Class<T> intrface, Class<U> constructorArgClass, U props) {\n+    T instance = null;\n+    try {\n+      // check if constructor with constructor arg class parameter\n+      // exists\n+      LOG.info(\"Invoking constructor with {} argument. ClassName={}, interfaceName={}\",\n+          constructorArgClass.getName(), className, intrface.getName());\n+      instance = this.getClass().getClassLoader()\n+          .loadClass(className)\n+          .asSubclass(intrface)\n+          .getConstructor(constructorArgClass)\n+          .newInstance(props);\n+    } catch (InstantiationException | IllegalAccessException | ClassNotFoundException ex) {\n+      LOG.warn(\"Unable to invoke constructor with {} argument. ClassName={}, interfaceName={}, cause={}, \" +\n+              \"errorMessage={}\", constructorArgClass.getName(), className, intrface.getName(), ex.getCause(),\n+          ex.getMessage());\n+      return null;\n+    } catch (NoSuchMethodException | InvocationTargetException e) {\n+      try {\n+        LOG.info(\"Invoking default constructor. ClassName={}, interfaceName={}\", className, intrface.getName());\n+        // fallback to default constructor\n+        instance = this.getClass().getClassLoader()\n+            .loadClass(className)\n+            .asSubclass(intrface)\n+            .getDeclaredConstructor().newInstance();\n+      } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n+          NoSuchMethodException | InvocationTargetException ex) {\n+        LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n+            \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n+        return null;\n+      }\n     }\n \n-    /**\n-     * Use the broker to publish a message. It's intended for embedding applications. It can be used\n-     * only after the integration is correctly started with startServer.\n-     *\n-     * @param msg      the message to forward.\n-     * @param clientId the id of the sending integration.\n-     * @throws IllegalStateException if the integration is not yet started\n-     */\n-    public void internalPublish(MqttPublishMessage msg, final String clientId) {\n-        final int messageID = msg.variableHeader().packetId();\n-        if (!initialized) {\n-            LOG.error(\"Moquette is not started, internal message cannot be published. CId: {}, messageId: {}\", clientId,\n-                      messageID);\n-            throw new IllegalStateException(\"Can't publish on a integration is not yet started\");\n-        }\n-        LOG.trace(\"Internal publishing message CId: {}, messageId: {}\", clientId, messageID);\n-        dispatcher.internalPublish(msg);\n+    return instance;\n+  }\n+\n+  /**\n+   * Use the broker to publish a message. It's intended for embedding applications. It can be used\n+   * only after the integration is correctly started with startServer.\n+   *\n+   * @param msg      the message to forward.\n+   * @param clientId the id of the sending integration.\n+   * @throws IllegalStateException if the integration is not yet started\n+   */\n+  public void internalPublish(MqttPublishMessage msg, final String clientId) {\n+    final int messageID = msg.variableHeader().packetId();\n+    if (!initialized) {\n+      LOG.error(\"Moquette is not started, internal message cannot be published. CId: {}, messageId: {}\", clientId,\n+          messageID);\n+      throw new IllegalStateException(\"Can't publish on a integration is not yet started\");\n     }\n-\n-    public void stopServer() {\n-        LOG.info(\"Unbinding integration from the configured ports\");\n-        acceptor.close();\n-        LOG.trace(\"Stopping MQTT protocol processor\");\n-        initialized = false;\n-\n-        // calling shutdown() does not actually stop tasks that are not cancelled,\n-        // and SessionsRepository does not stop its tasks. Thus shutdownNow().\n-        scheduler.shutdownNow();\n-\n-        if (h2Builder != null) {\n-            LOG.trace(\"Shutting down H2 persistence {}\");\n-            h2Builder.closeStore();\n-        }\n-\n-        LOG.info(\"Moquette integration has been stopped.\");\n+    LOG.trace(\"Internal publishing message CId: {}, messageId: {}\", clientId, messageID);\n+    dispatcher.internalPublish(msg);\n+  }\n+\n+  public void stopServer() {\n+    LOG.info(\"Unbinding integration from the configured ports\");\n+    acceptor.close();\n+    LOG.trace(\"Stopping MQTT protocol processor\");\n+    initialized = false;\n+\n+    // calling shutdown() does not actually stop tasks that are not cancelled,\n+    // and SessionsRepository does not stop its tasks. Thus shutdownNow().\n+    scheduler.shutdownNow();\n+\n+    if (h2Builder != null) {\n+      LOG.trace(\"Shutting down H2 persistence {}\");\n+      h2Builder.closeStore();\n     }\n \n-    public int getPort() {\n-        return acceptor.getPort();\n-    }\n+    LOG.info(\"Moquette integration has been stopped.\");\n+  }\n \n-    public int getSslPort() {\n-        return acceptor.getSslPort();\n-    }\n+  public int getPort() {\n+    return acceptor.getPort();\n+  }\n \n-    /**\n-     * SPI method used by Broker embedded applications to get list of subscribers. Returns null if\n-     * the broker is not started.\n-     *\n-     * @return list of subscriptions.\n-     */\n+  public int getSslPort() {\n+    return acceptor.getSslPort();\n+  }\n+\n+  /**\n+   * SPI method used by Broker embedded applications to get list of subscribers. Returns null if\n+   * the broker is not started.\n+   *\n+   * @return list of subscriptions.\n+   */\n // TODO reimplement this\n //    public List<Subscription> getSubscriptions() {\n //        if (m_processorBootstrapper == null) {\n@@ -350,40 +351,40 @@ public class Server {\n //        return this.subscriptionsStore.listAllSubscriptions();\n //    }\n \n-    /**\n-     * SPI method used by Broker embedded applications to add intercept handlers.\n-     *\n-     * @param interceptHandler the handler to add.\n-     */\n-    public void addInterceptHandler(InterceptHandler interceptHandler) {\n-        if (!initialized) {\n-            LOG.error(\"Moquette is not started, MQTT message interceptor cannot be added. InterceptorId={}\",\n-                interceptHandler.getID());\n-            throw new IllegalStateException(\"Can't register interceptors on a integration that is not yet started\");\n-        }\n-        LOG.info(\"Adding MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\n-        interceptor.addInterceptHandler(interceptHandler);\n+  /**\n+   * SPI method used by Broker embedded applications to add intercept handlers.\n+   *\n+   * @param interceptHandler the handler to add.\n+   */\n+  public void addInterceptHandler(InterceptHandler interceptHandler) {\n+    if (!initialized) {\n+      LOG.error(\"Moquette is not started, MQTT message interceptor cannot be added. InterceptorId={}\",\n+          interceptHandler.getID());\n+      throw new IllegalStateException(\"Can't register interceptors on a integration that is not yet started\");\n     }\n-\n-    /**\n-     * SPI method used by Broker embedded applications to remove intercept handlers.\n-     *\n-     * @param interceptHandler the handler to remove.\n-     */\n-    public void removeInterceptHandler(InterceptHandler interceptHandler) {\n-        if (!initialized) {\n-            LOG.error(\"Moquette is not started, MQTT message interceptor cannot be removed. InterceptorId={}\",\n-                interceptHandler.getID());\n-            throw new IllegalStateException(\"Can't deregister interceptors from a integration that is not yet started\");\n-        }\n-        LOG.info(\"Removing MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\n-        interceptor.removeInterceptHandler(interceptHandler);\n-    }\n-\n-    /**\n-     * Return a list of descriptors of connected clients.\n-     * */\n-    public Collection<ClientDescriptor> listConnectedClients() {\n-        return sessions.listConnectedClients();\n+    LOG.info(\"Adding MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\n+    interceptor.addInterceptHandler(interceptHandler);\n+  }\n+\n+  /**\n+   * SPI method used by Broker embedded applications to remove intercept handlers.\n+   *\n+   * @param interceptHandler the handler to remove.\n+   */\n+  public void removeInterceptHandler(InterceptHandler interceptHandler) {\n+    if (!initialized) {\n+      LOG.error(\"Moquette is not started, MQTT message interceptor cannot be removed. InterceptorId={}\",\n+          interceptHandler.getID());\n+      throw new IllegalStateException(\"Can't deregister interceptors from a integration that is not yet started\");\n     }\n+    LOG.info(\"Removing MQTT message interceptor. InterceptorId={}\", interceptHandler.getID());\n+    interceptor.removeInterceptHandler(interceptHandler);\n+  }\n+\n+  /**\n+   * Return a list of descriptors of connected clients.\n+   */\n+  public Collection<ClientDescriptor> listConnectedClients() {\n+    return sessions.listConnectedClients();\n+  }\n }\n",
            "diff_size": 427
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "70",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "136",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 192).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "182",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "245",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "279",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 151).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "300",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/15/Server.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/15/Server.java\nindex 8f1ec8252bf..de6a0d13e4c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/15/Server.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/15/Server.java\n@@ -133,9 +133,8 @@ public class Server {\n         startServer(config, handlers, null, null, null);\n     }\n \n-    public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator,\n-                            IAuthenticator authenticator, IAuthorizatorPolicy authorizatorPolicy) {\n-        final long start = System.currentTimeMillis();\n+    public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator, IAuthenticator authenticator, IAuthorizatorPolicy authorizatorPolicy) {\n+    final long start = System.currentTimeMillis();\n         if (handlers == null) {\n             handlers = Collections.emptyList();\n         }\n@@ -180,10 +179,8 @@ public class Server {\n         sessions = new SessionRegistry(subscriptions, queueRepository, authorizator);\n         dispatcher = new PostOffice(subscriptions, retainedRepository, sessions, interceptor, authorizator);\n         final BrokerConfiguration brokerConfig = new BrokerConfiguration(config);\n-        MQTTConnectionFactory connectionFactory = new MQTTConnectionFactory(brokerConfig, authenticator, sessions,\n-                                                                            dispatcher);\n-\n-        final NewNettyMQTTHandler mqttHandler = new NewNettyMQTTHandler(connectionFactory);\n+        MQTTConnectionFactory connectionFactory = new MQTTConnectionFactory(brokerConfig, authenticator, sessions, dispatcher);\n+final NewNettyMQTTHandler mqttHandler = new NewNettyMQTTHandler(connectionFactory);\n         acceptor = new NewNettyAcceptor();\n         acceptor.initialize(mqttHandler, config, sslCtxCreator);\n \n@@ -245,9 +242,8 @@ public class Server {\n         List<InterceptHandler> observers = new ArrayList<>(embeddedObservers);\n         String interceptorClassName = props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n         if (interceptorClassName != null && !interceptorClassName.isEmpty()) {\n-            InterceptHandler handler = loadClass(interceptorClassName, InterceptHandler.class,\n-                                                 io.moquette.broker.Server.class, this);\n-            if (handler != null) {\n+            InterceptHandler handler = loadClass(interceptorClassName, InterceptHandler.class, io.moquette.broker.Server.class, this);\n+if (handler != null) {\n                 observers.add(handler);\n             }\n         }\n@@ -262,7 +258,7 @@ public class Server {\n             // exists\n             LOG.info(\"Invoking constructor with {} argument. ClassName={}, interfaceName={}\",\n                      constructorArgClass.getName(), className, intrface.getName());\n-            instance = this.getClass().getClassLoader()\n+instance = this.getClass().getClassLoader()\n                 .loadClass(className)\n                 .asSubclass(intrface)\n                 .getConstructor(constructorArgClass)\n@@ -280,11 +276,10 @@ public class Server {\n                     .loadClass(className)\n                     .asSubclass(intrface)\n                     .getDeclaredConstructor().newInstance();\n-            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n-                NoSuchMethodException | InvocationTargetException ex) {\n-                LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n+            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InvocationTargetException ex) {\n+    LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n                           \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n-                return null;\n+return null;\n             }\n         }\n \n@@ -302,9 +297,8 @@ public class Server {\n     public void internalPublish(MqttPublishMessage msg, final String clientId) {\n         final int messageID = msg.variableHeader().packetId();\n         if (!initialized) {\n-            LOG.error(\"Moquette is not started, internal message cannot be published. CId: {}, messageId: {}\", clientId,\n-                      messageID);\n-            throw new IllegalStateException(\"Can't publish on a integration is not yet started\");\n+            LOG.error(\"Moquette is not started, internal message cannot be published. CId: {}, messageId: {}\", clientId, messageID);\n+throw new IllegalStateException(\"Can't publish on a integration is not yet started\");\n         }\n         LOG.trace(\"Internal publishing message CId: {}, messageId: {}\", clientId, messageID);\n         dispatcher.internalPublish(msg);\n@@ -342,15 +336,9 @@ public class Server {\n      *\n      * @return list of subscriptions.\n      */\n-// TODO reimplement this\n-//    public List<Subscription> getSubscriptions() {\n-//        if (m_processorBootstrapper == null) {\n-//            return null;\n-//        }\n-//        return this.subscriptionsStore.listAllSubscriptions();\n-//    }\n+// TODO reimp\n \n-    /**\n+/**\n      * SPI method used by Broker embedded applications to add intercept handlers.\n      *\n      * @param interceptHandler the handler to add.\n@@ -386,4 +374,4 @@ public class Server {\n     public Collection<ClientDescriptor> listConnectedClients() {\n         return sessions.listConnectedClients();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 27
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "140",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 192).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "183",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "243",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 134).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "268",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 228).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "280",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 151).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "281",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 193).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/15/Server.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/15/Server.java\nindex 8f1ec8252bf..e483e823378 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/15/Server.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/15/Server.java\n@@ -29,7 +29,6 @@ import io.moquette.broker.security.IAuthorizatorPolicy;\n import io.netty.handler.codec.mqtt.MqttPublishMessage;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import java.io.File;\n import java.io.IOException;\n import java.lang.reflect.InvocationTargetException;\n@@ -43,7 +42,6 @@ import static io.moquette.logging.LoggingUtils.getInterceptorIds;\n public class Server {\n \n     private static final Logger LOG = LoggerFactory.getLogger(io.moquette.broker.Server.class);\n-\n     private ScheduledExecutorService scheduler;\n     private NewNettyAcceptor acceptor;\n     private volatile boolean initialized;\n@@ -65,9 +63,11 @@ public class Server {\n      *\n      * @throws IOException in case of any IO error.\n      */\n+\n     public void startServer() throws IOException {\n         File defaultConfigurationFile = defaultConfigFile();\n-        LOG.info(\"Starting Moquette integration. Configuration file path={}\", defaultConfigurationFile.getAbsolutePath());\n+        LOG.info(\"Starting Moquette integration. Configuration file path={}\",\n+            defaultConfigurationFile.getAbsolutePath());\n         IResourceLoader filesystemLoader = new FileResourceLoader(defaultConfigurationFile);\n         final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n         startServer(config);\n@@ -84,6 +84,7 @@ public class Server {\n      * @param configFile text file that contains the configuration.\n      * @throws IOException in case of any IO Error.\n      */\n+\n     public void startServer(File configFile) throws IOException {\n         LOG.info(\"Starting Moquette integration. Configuration file path: {}\", configFile.getAbsolutePath());\n         IResourceLoader filesystemLoader = new FileResourceLoader(configFile);\n@@ -103,6 +104,7 @@ public class Server {\n      * @param configProps the properties map to use as configuration.\n      * @throws IOException in case of any IO Error.\n      */\n+\n     public void startServer(Properties configProps) throws IOException {\n         LOG.debug(\"Starting Moquette integration using properties object\");\n         final IConfig config = new MemoryConfig(configProps);\n@@ -115,6 +117,7 @@ public class Server {\n      * @param config the configuration to use to start the broker.\n      * @throws IOException in case of any IO Error.\n      */\n+\n     public void startServer(IConfig config) throws IOException {\n         LOG.debug(\"Starting Moquette integration using IConfig instance\");\n         startServer(config, null);\n@@ -128,21 +131,19 @@ public class Server {\n      * @param handlers the handlers to install in the broker.\n      * @throws IOException in case of any IO Error.\n      */\n+\n     public void startServer(IConfig config, List<? extends InterceptHandler> handlers) throws IOException {\n         LOG.debug(\"Starting moquette integration using IConfig instance and intercept handlers\");\n         startServer(config, handlers, null, null, null);\n     }\n \n-    public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator,\n-                            IAuthenticator authenticator, IAuthorizatorPolicy authorizatorPolicy) {\n+    public void startServer(IConfig config, List<? extends InterceptHandler> handlers, ISslContextCreator sslCtxCreator, IAuthenticator authenticator, IAuthorizatorPolicy authorizatorPolicy) {\n         final long start = System.currentTimeMillis();\n         if (handlers == null) {\n             handlers = Collections.emptyList();\n         }\n         LOG.trace(\"Starting Moquette Server. MQTT message interceptors={}\", getInterceptorIds(handlers));\n-\n         scheduler = Executors.newScheduledThreadPool(1);\n-\n         final String handlerProp = System.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n         if (handlerProp != null) {\n             config.setProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME, handlerProp);\n@@ -157,7 +158,6 @@ public class Server {\n         }\n         authenticator = initializeAuthenticator(authenticator, config);\n         authorizatorPolicy = initializeAuthorizatorPolicy(authorizatorPolicy, config);\n-\n         final ISubscriptionsRepository subscriptionsRepository;\n         final IQueueRepository queueRepository;\n         final IRetainedRepository retainedRepository;\n@@ -180,13 +180,10 @@ public class Server {\n         sessions = new SessionRegistry(subscriptions, queueRepository, authorizator);\n         dispatcher = new PostOffice(subscriptions, retainedRepository, sessions, interceptor, authorizator);\n         final BrokerConfiguration brokerConfig = new BrokerConfiguration(config);\n-        MQTTConnectionFactory connectionFactory = new MQTTConnectionFactory(brokerConfig, authenticator, sessions,\n-                                                                            dispatcher);\n-\n+        MQTTConnectionFactory connectionFactory = new MQTTConnectionFactory(brokerConfig, authenticator, sessions, dispatcher);\n         final NewNettyMQTTHandler mqttHandler = new NewNettyMQTTHandler(connectionFactory);\n         acceptor = new NewNettyAcceptor();\n         acceptor.initialize(mqttHandler, config, sslCtxCreator);\n-\n         final long startTime = System.currentTimeMillis() - start;\n         LOG.info(\"Moquette integration has been started successfully in {} ms\", startTime);\n         initialized = true;\n@@ -221,7 +218,6 @@ public class Server {\n     private IAuthenticator initializeAuthenticator(IAuthenticator authenticator, IConfig props) {\n         LOG.debug(\"Configuring MQTT authenticator\");\n         String authenticatorClassName = props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, \"\");\n-\n         if (authenticator == null && !authenticatorClassName.isEmpty()) {\n             authenticator = loadClass(authenticatorClassName, IAuthenticator.class, IConfig.class, props);\n         }\n@@ -241,12 +237,10 @@ public class Server {\n \n     private void initInterceptors(IConfig props, List<? extends InterceptHandler> embeddedObservers) {\n         LOG.info(\"Configuring message interceptors...\");\n-\n         List<InterceptHandler> observers = new ArrayList<>(embeddedObservers);\n         String interceptorClassName = props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n         if (interceptorClassName != null && !interceptorClassName.isEmpty()) {\n-            InterceptHandler handler = loadClass(interceptorClassName, InterceptHandler.class,\n-                                                 io.moquette.broker.Server.class, this);\n+            InterceptHandler handler = loadClass(interceptorClassName, InterceptHandler.class, io.moquette.broker.Server.class, this);\n             if (handler != null) {\n                 observers.add(handler);\n             }\n@@ -261,33 +255,33 @@ public class Server {\n             // check if constructor with constructor arg class parameter\n             // exists\n             LOG.info(\"Invoking constructor with {} argument. ClassName={}, interfaceName={}\",\n-                     constructorArgClass.getName(), className, intrface.getName());\n-            instance = this.getClass().getClassLoader()\n-                .loadClass(className)\n-                .asSubclass(intrface)\n-                .getConstructor(constructorArgClass)\n-                .newInstance(props);\n+                constructorArgClass.getName(),\n+                className,\n+                intrface.getName());\n+            instance = this.getClass()\n+.getClassLoader()\n+.loadClass(className)\n+.asSubclass(intrface)\n+.getConstructor(constructorArgClass)\n+.newInstance(props);\n         } catch (InstantiationException | IllegalAccessException | ClassNotFoundException ex) {\n-            LOG.warn(\"Unable to invoke constructor with {} argument. ClassName={}, interfaceName={}, cause={}, \" +\n-                     \"errorMessage={}\", constructorArgClass.getName(), className, intrface.getName(), ex.getCause(),\n-                     ex.getMessage());\n+            LOG.warn(\"Unable to invoke constructor with {} argument. ClassName={}, interfaceName={}, cause={}, \" + \"errorMessage={}\", constructorArgClass.getName(), className, intrface.getName(), ex.getCause(), ex.getMessage());\n             return null;\n         } catch (NoSuchMethodException | InvocationTargetException e) {\n             try {\n                 LOG.info(\"Invoking default constructor. ClassName={}, interfaceName={}\", className, intrface.getName());\n                 // fallback to default constructor\n-                instance = this.getClass().getClassLoader()\n-                    .loadClass(className)\n-                    .asSubclass(intrface)\n-                    .getDeclaredConstructor().newInstance();\n-            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n-                NoSuchMethodException | InvocationTargetException ex) {\n-                LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n-                          \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n+                instance = this.getClass()\n+.getClassLoader()\n+.loadClass(className)\n+.asSubclass(intrface)\n+.getDeclaredConstructor()\n+.newInstance();\n+            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InvocationTargetException ex) {\n+                LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" + \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n                 return null;\n             }\n         }\n-\n         return instance;\n     }\n \n@@ -299,11 +293,13 @@ public class Server {\n      * @param clientId the id of the sending integration.\n      * @throws IllegalStateException if the integration is not yet started\n      */\n+\n     public void internalPublish(MqttPublishMessage msg, final String clientId) {\n         final int messageID = msg.variableHeader().packetId();\n         if (!initialized) {\n-            LOG.error(\"Moquette is not started, internal message cannot be published. CId: {}, messageId: {}\", clientId,\n-                      messageID);\n+            LOG.error(\"Moquette is not started, internal message cannot be published. CId: {}, messageId: {}\",\n+                clientId,\n+                messageID);\n             throw new IllegalStateException(\"Can't publish on a integration is not yet started\");\n         }\n         LOG.trace(\"Internal publishing message CId: {}, messageId: {}\", clientId, messageID);\n@@ -319,12 +315,10 @@ public class Server {\n         // calling shutdown() does not actually stop tasks that are not cancelled,\n         // and SessionsRepository does not stop its tasks. Thus shutdownNow().\n         scheduler.shutdownNow();\n-\n         if (h2Builder != null) {\n             LOG.trace(\"Shutting down H2 persistence {}\");\n             h2Builder.closeStore();\n         }\n-\n         LOG.info(\"Moquette integration has been stopped.\");\n     }\n \n@@ -355,6 +349,7 @@ public class Server {\n      *\n      * @param interceptHandler the handler to add.\n      */\n+\n     public void addInterceptHandler(InterceptHandler interceptHandler) {\n         if (!initialized) {\n             LOG.error(\"Moquette is not started, MQTT message interceptor cannot be added. InterceptorId={}\",\n@@ -370,6 +365,7 @@ public class Server {\n      *\n      * @param interceptHandler the handler to remove.\n      */\n+\n     public void removeInterceptHandler(InterceptHandler interceptHandler) {\n         if (!initialized) {\n             LOG.error(\"Moquette is not started, MQTT message interceptor cannot be removed. InterceptorId={}\",\n@@ -383,7 +379,8 @@ public class Server {\n     /**\n      * Return a list of descriptors of connected clients.\n      * */\n+\n     public Collection<ClientDescriptor> listConnectedClients() {\n         return sessions.listConnectedClients();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 53
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "70",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "70",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "70",
                    "column": "124",
                    "severity": "warning",
                    "message": "';' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/15/Server.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_three_grams/15/Server.java\nindex 8f1ec8252bf..ef28102d440 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/15/Server.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_three_grams/15/Server.java\n@@ -67,8 +67,8 @@ public class Server {\n      */\n     public void startServer() throws IOException {\n         File defaultConfigurationFile = defaultConfigFile();\n-        LOG.info(\"Starting Moquette integration. Configuration file path={}\", defaultConfigurationFile.getAbsolutePath());\n-        IResourceLoader filesystemLoader = new FileResourceLoader(defaultConfigurationFile);\n+        LOG.info(\"Starting Moquette integration. Configuration file path={}\", defaultConfigurationFile . getAbsolutePath());IResourceLoader\n+        filesystemLoader = new FileResourceLoader(defaultConfigurationFile);\n         final IConfig config = new ResourceLoaderConfig(filesystemLoader);\n         startServer(config);\n     }\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}