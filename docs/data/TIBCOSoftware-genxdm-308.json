{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "308",
    "information": {
        "errors": [
            {
                "line": "25",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "abstract class Graph<D, V extends Vertex<D, V>>\n{\n\tprotected final V m_initialState; // of the state machine\n\n\tpublic Graph(final V initialState)\n\t{",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "27",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/308/Graph.java\nindex 4ee737471c5..7ddec9588d5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/308/Graph.java\n@@ -22,7 +22,7 @@ import java.util.Stack;\n \n abstract class Graph<D, V extends Vertex<D, V>>\n {\n-\tprotected final V m_initialState; // of the state machine\n+protected final V m_initialState; // of the state machine\n \n \tpublic Graph(final V initialState)\n \t{\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/308/Graph.java\nindex 4ee737471c5..22f306e7e75 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/308/Graph.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.regex.impl.nfa;\n \n import java.util.HashMap;\n@@ -20,211 +21,168 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Stack;\n \n-abstract class Graph<D, V extends Vertex<D, V>>\n-{\n-\tprotected final V m_initialState; // of the state machine\n-\n-\tpublic Graph(final V initialState)\n-\t{\n-\t\tm_initialState = initialState;\n-\t}\n-\n-\t@Override\n-\tpublic String toString()\n-\t{\n-\t\tfinal StringBuilder sb = new StringBuilder();\n-\n-\t\tfinal HashMap<V, Integer> index = new HashMap<V, Integer>();\n-\t\tfinal Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n-\n-\t\tint i = 0;\n-\t\tstack.push(new Edge<D, V>(null, m_initialState));\n-\t\tindex.put(m_initialState, i++);\n-\n-\t\twhile (!stack.isEmpty())\n-\t\t{\n-\t\t\tfinal V k = stack.pop().to;\n-\n-\t\t\tsb.append(\"#\").append(index.get(k)).append(\" \");\n-\t\t\tif (k.getTerm() != null)\n-\t\t\t{\n-\t\t\t\tsb.append(k.getTerm().toString());\n-\t\t\t}\n-\t\t\tsb.append(\" ==> \");\n-\n-\t\t\tfor (final V t : k.nextStates())\n-\t\t\t{\n-\t\t\t\tif (!index.containsKey(t))\n-\t\t\t\t{\n-\t\t\t\t\tstack.push(new Edge<D, V>(k, t));\n-\t\t\t\t\tsb.append(\" \").append(i);\n-\t\t\t\t\tindex.put(t, i++);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tsb.append(\" \").append(index.get(t));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tsb.append('\\n');\n-\t\t}\n-\n-\t\tfor (final Edge<D, V> edge : deadEdges(m_initialState))\n-\t\t{\n-\t\t\tsb.append(\"dead(\").append(index.get(edge.from)).append(\",\").append(index.get(edge.to)).append(\")\").append('\\n');\n-\t\t}\n-\n-\t\treturn sb.toString();\n-\t}\n-\n-\tprivate void cleanup()\n-\t{\n-\t\tfinal HashMap<V, Boolean> visited = new HashMap<V, Boolean>();\n-\t\tfinal Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n-\n-\t\tstack.push(new Edge<D, V>(null, m_initialState));\n-\t\tvisited.put(m_initialState, Boolean.TRUE);\n-\n-\t\twhile (!stack.isEmpty())\n-\t\t{\n-\t\t\tfinal Edge<D, V> edge = stack.pop();\n-\t\t\tfinal V vertex = edge.to;\n-\n-\t\t\tboolean more = true;\n-\t\t\tif (edge.from == null)\n-\t\t\t{\n-\t\t\t\t// Must be the start vertex.\n-\t\t\t}\n-\t\t\telse if (vertex.isEnd())\n-\t\t\t{\n-\t\t\t\t// Must be the end vertex!\n-\t\t\t\tmore = false;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tfinal V target = collapseOut(vertex);\n-\t\t\t\tif (null != target)\n-\t\t\t\t{\n-\t\t\t\t\tif (!target.isEnd())\n-\t\t\t\t\t{\n-\t\t\t\t\t\tvertex.nextStates().clear();\n-\t\t\t\t\t\tvertex.nextStates().addAll(target.nextStates());\n-\t\t\t\t\t\t// Push this edge\n-\t\t\t\t\t\tstack.push(edge);\n-\t\t\t\t\t\tmore = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (more)\n-\t\t\t{\n-\t\t\t\tfor (final V to : vertex.nextStates())\n-\t\t\t\t{\n-\t\t\t\t\tif (!visited.containsKey(to))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tstack.push(new Edge<D, V>(vertex, to));\n-\t\t\t\t\t\tvisited.put(to, Boolean.TRUE);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate V collapseOut(final V vertex)\n-\t{\n-\t\tV target = null;\n-\t\tint unconditional = 0;\n-\t\tint conditional = 0;\n-\t\tfor (final V next : vertex.nextStates())\n-\t\t{\n-\t\t\tif (null != next.getTerm())\n-\t\t\t{\n-\t\t\t\tconditional++;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tunconditional++;\n-\t\t\t\ttarget = next;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (1 == unconditional)\n-\t\t{\n-\t\t\tif (0 == conditional)\n-\t\t\t{\n-\t\t\t\treturn target;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new IllegalStateException(\"Must run dead path removal first.\");\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Remove unreachable transitions and short-circuit unconditional transitions.\n-\t */\n-\t// TODO:(\"Can't use this yet. e.g. a*b doesn't work.\")\n-\tpublic void optimize()\n-\t{\n-\t\tfor (final Edge<D, V> edge : deadEdges(m_initialState))\n-\t\t{\n-\t\t\tedge.from.nextStates().remove(edge.to);\n-\t\t}\n-\n-\t\tcleanup();\n-\t}\n-\n-\tprivate Iterable<Edge<D, V>> deadEdges(final V initialState)\n-\t{\n-\t\tfinal List<Edge<D, V>> deadCode = new LinkedList<Edge<D, V>>();\n-\n-\t\tfinal HashMap<V, Boolean> visited = new HashMap<V, Boolean>();\n-\t\tfinal Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n-\n-\t\tstack.push(new Edge<D, V>(null, initialState));\n-\t\tvisited.put(initialState, Boolean.TRUE);\n-\n-\t\twhile (!stack.isEmpty())\n-\t\t{\n-\t\t\tfinal Edge<D, V> edge = stack.pop();\n-\t\t\tfinal V from = edge.to;\n-\n-\t\t\tfor (final V to : from.nextStates())\n-\t\t\t{\n-\t\t\t\tif (!visited.containsKey(to))\n-\t\t\t\t{\n-\t\t\t\t\tstack.push(new Edge<D, V>(from, to));\n-\t\t\t\t\tvisited.put(to, Boolean.TRUE);\n-\t\t\t\t}\n-\n-\t\t\t\tif (deadEdge(from, to))\n-\t\t\t\t{\n-\t\t\t\t\tdeadCode.add(new Edge<D, V>(from, to));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn deadCode;\n-\t}\n-\n-\tpublic static boolean deadEdge(final Vertex<?, ?> from, final Vertex<?, ?> to)\n-\t{\n-\t\tif (null == to.getTerm())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tfor (final Vertex<?, ?> t : from.nextStates())\n-\t\t{\n-\t\t\tif (null == t.getTerm())\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n+abstract class Graph<D, V extends Vertex<D, V>> {\n+    protected final V m_initialState; // of the state machine\n+\n+    public Graph(final V initialState) {\n+        m_initialState = initialState;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+\n+        final HashMap<V, Integer> index = new HashMap<V, Integer>();\n+        final Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n+\n+        int i = 0;\n+        stack.push(new Edge<D, V>(null, m_initialState));\n+        index.put(m_initialState, i++);\n+\n+        while (!stack.isEmpty()) {\n+            final V k = stack.pop().to;\n+\n+            sb.append(\"#\").append(index.get(k)).append(\" \");\n+            if (k.getTerm() != null) {\n+                sb.append(k.getTerm().toString());\n+            }\n+            sb.append(\" ==> \");\n+\n+            for (final V t : k.nextStates()) {\n+                if (!index.containsKey(t)) {\n+                    stack.push(new Edge<D, V>(k, t));\n+                    sb.append(\" \").append(i);\n+                    index.put(t, i++);\n+                } else {\n+                    sb.append(\" \").append(index.get(t));\n+                }\n+            }\n+            sb.append('\\n');\n+        }\n+\n+        for (final Edge<D, V> edge : deadEdges(m_initialState)) {\n+            sb.append(\"dead(\").append(index.get(edge.from)).append(\",\").append(index.get(edge.to))\n+                .append(\")\").append('\\n');\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private void cleanup() {\n+        final HashMap<V, Boolean> visited = new HashMap<V, Boolean>();\n+        final Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n+\n+        stack.push(new Edge<D, V>(null, m_initialState));\n+        visited.put(m_initialState, Boolean.TRUE);\n+\n+        while (!stack.isEmpty()) {\n+            final Edge<D, V> edge = stack.pop();\n+            final V vertex = edge.to;\n+\n+            boolean more = true;\n+            if (edge.from == null) {\n+                // Must be the start vertex.\n+            } else if (vertex.isEnd()) {\n+                // Must be the end vertex!\n+                more = false;\n+            } else {\n+                final V target = collapseOut(vertex);\n+                if (null != target) {\n+                    if (!target.isEnd()) {\n+                        vertex.nextStates().clear();\n+                        vertex.nextStates().addAll(target.nextStates());\n+                        // Push this edge\n+                        stack.push(edge);\n+                        more = false;\n+                    }\n+                }\n+            }\n+            if (more) {\n+                for (final V to : vertex.nextStates()) {\n+                    if (!visited.containsKey(to)) {\n+                        stack.push(new Edge<D, V>(vertex, to));\n+                        visited.put(to, Boolean.TRUE);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private V collapseOut(final V vertex) {\n+        V target = null;\n+        int unconditional = 0;\n+        int conditional = 0;\n+        for (final V next : vertex.nextStates()) {\n+            if (null != next.getTerm()) {\n+                conditional++;\n+            } else {\n+                unconditional++;\n+                target = next;\n+            }\n+        }\n+\n+        if (1 == unconditional) {\n+            if (0 == conditional) {\n+                return target;\n+            } else {\n+                throw new IllegalStateException(\"Must run dead path removal first.\");\n+            }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Remove unreachable transitions and short-circuit unconditional transitions.\n+     */\n+    // TODO:(\"Can't use this yet. e.g. a*b doesn't work.\")\n+    public void optimize() {\n+        for (final Edge<D, V> edge : deadEdges(m_initialState)) {\n+            edge.from.nextStates().remove(edge.to);\n+        }\n+\n+        cleanup();\n+    }\n+\n+    private Iterable<Edge<D, V>> deadEdges(final V initialState) {\n+        final List<Edge<D, V>> deadCode = new LinkedList<Edge<D, V>>();\n+\n+        final HashMap<V, Boolean> visited = new HashMap<V, Boolean>();\n+        final Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n+\n+        stack.push(new Edge<D, V>(null, initialState));\n+        visited.put(initialState, Boolean.TRUE);\n+\n+        while (!stack.isEmpty()) {\n+            final Edge<D, V> edge = stack.pop();\n+            final V from = edge.to;\n+\n+            for (final V to : from.nextStates()) {\n+                if (!visited.containsKey(to)) {\n+                    stack.push(new Edge<D, V>(from, to));\n+                    visited.put(to, Boolean.TRUE);\n+                }\n+\n+                if (deadEdge(from, to)) {\n+                    deadCode.add(new Edge<D, V>(from, to));\n+                }\n+            }\n+        }\n+\n+        return deadCode;\n+    }\n+\n+    public static boolean deadEdge(final Vertex<?, ?> from, final Vertex<?, ?> to) {\n+        if (null == to.getTerm()) {\n+            return false;\n+        }\n+\n+        for (final Vertex<?, ?> t : from.nextStates()) {\n+            if (null == t.getTerm()) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n }\n",
            "diff_size": 212
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/308/Graph.java\nindex 4ee737471c5..2256b475ebb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/308/Graph.java\n@@ -22,209 +22,191 @@ import java.util.Stack;\n \n abstract class Graph<D, V extends Vertex<D, V>>\n {\n-\tprotected final V m_initialState; // of the state machine\n-\n-\tpublic Graph(final V initialState)\n-\t{\n-\t\tm_initialState = initialState;\n-\t}\n-\n-\t@Override\n-\tpublic String toString()\n-\t{\n-\t\tfinal StringBuilder sb = new StringBuilder();\n-\n-\t\tfinal HashMap<V, Integer> index = new HashMap<V, Integer>();\n-\t\tfinal Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n-\n-\t\tint i = 0;\n-\t\tstack.push(new Edge<D, V>(null, m_initialState));\n-\t\tindex.put(m_initialState, i++);\n-\n-\t\twhile (!stack.isEmpty())\n-\t\t{\n-\t\t\tfinal V k = stack.pop().to;\n-\n-\t\t\tsb.append(\"#\").append(index.get(k)).append(\" \");\n-\t\t\tif (k.getTerm() != null)\n-\t\t\t{\n-\t\t\t\tsb.append(k.getTerm().toString());\n-\t\t\t}\n-\t\t\tsb.append(\" ==> \");\n-\n-\t\t\tfor (final V t : k.nextStates())\n-\t\t\t{\n-\t\t\t\tif (!index.containsKey(t))\n-\t\t\t\t{\n-\t\t\t\t\tstack.push(new Edge<D, V>(k, t));\n-\t\t\t\t\tsb.append(\" \").append(i);\n-\t\t\t\t\tindex.put(t, i++);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tsb.append(\" \").append(index.get(t));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tsb.append('\\n');\n-\t\t}\n-\n-\t\tfor (final Edge<D, V> edge : deadEdges(m_initialState))\n-\t\t{\n-\t\t\tsb.append(\"dead(\").append(index.get(edge.from)).append(\",\").append(index.get(edge.to)).append(\")\").append('\\n');\n-\t\t}\n-\n-\t\treturn sb.toString();\n-\t}\n-\n-\tprivate void cleanup()\n-\t{\n-\t\tfinal HashMap<V, Boolean> visited = new HashMap<V, Boolean>();\n-\t\tfinal Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n-\n-\t\tstack.push(new Edge<D, V>(null, m_initialState));\n-\t\tvisited.put(m_initialState, Boolean.TRUE);\n-\n-\t\twhile (!stack.isEmpty())\n-\t\t{\n-\t\t\tfinal Edge<D, V> edge = stack.pop();\n-\t\t\tfinal V vertex = edge.to;\n-\n-\t\t\tboolean more = true;\n-\t\t\tif (edge.from == null)\n-\t\t\t{\n-\t\t\t\t// Must be the start vertex.\n-\t\t\t}\n-\t\t\telse if (vertex.isEnd())\n-\t\t\t{\n-\t\t\t\t// Must be the end vertex!\n-\t\t\t\tmore = false;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tfinal V target = collapseOut(vertex);\n-\t\t\t\tif (null != target)\n-\t\t\t\t{\n-\t\t\t\t\tif (!target.isEnd())\n-\t\t\t\t\t{\n-\t\t\t\t\t\tvertex.nextStates().clear();\n-\t\t\t\t\t\tvertex.nextStates().addAll(target.nextStates());\n-\t\t\t\t\t\t// Push this edge\n-\t\t\t\t\t\tstack.push(edge);\n-\t\t\t\t\t\tmore = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (more)\n-\t\t\t{\n-\t\t\t\tfor (final V to : vertex.nextStates())\n-\t\t\t\t{\n-\t\t\t\t\tif (!visited.containsKey(to))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tstack.push(new Edge<D, V>(vertex, to));\n-\t\t\t\t\t\tvisited.put(to, Boolean.TRUE);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate V collapseOut(final V vertex)\n-\t{\n-\t\tV target = null;\n-\t\tint unconditional = 0;\n-\t\tint conditional = 0;\n-\t\tfor (final V next : vertex.nextStates())\n-\t\t{\n-\t\t\tif (null != next.getTerm())\n-\t\t\t{\n-\t\t\t\tconditional++;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tunconditional++;\n-\t\t\t\ttarget = next;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (1 == unconditional)\n-\t\t{\n-\t\t\tif (0 == conditional)\n-\t\t\t{\n-\t\t\t\treturn target;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new IllegalStateException(\"Must run dead path removal first.\");\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Remove unreachable transitions and short-circuit unconditional transitions.\n-\t */\n-\t// TODO:(\"Can't use this yet. e.g. a*b doesn't work.\")\n-\tpublic void optimize()\n-\t{\n-\t\tfor (final Edge<D, V> edge : deadEdges(m_initialState))\n-\t\t{\n-\t\t\tedge.from.nextStates().remove(edge.to);\n-\t\t}\n-\n-\t\tcleanup();\n-\t}\n-\n-\tprivate Iterable<Edge<D, V>> deadEdges(final V initialState)\n-\t{\n-\t\tfinal List<Edge<D, V>> deadCode = new LinkedList<Edge<D, V>>();\n-\n-\t\tfinal HashMap<V, Boolean> visited = new HashMap<V, Boolean>();\n-\t\tfinal Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n-\n-\t\tstack.push(new Edge<D, V>(null, initialState));\n-\t\tvisited.put(initialState, Boolean.TRUE);\n-\n-\t\twhile (!stack.isEmpty())\n-\t\t{\n-\t\t\tfinal Edge<D, V> edge = stack.pop();\n-\t\t\tfinal V from = edge.to;\n-\n-\t\t\tfor (final V to : from.nextStates())\n-\t\t\t{\n-\t\t\t\tif (!visited.containsKey(to))\n-\t\t\t\t{\n-\t\t\t\t\tstack.push(new Edge<D, V>(from, to));\n-\t\t\t\t\tvisited.put(to, Boolean.TRUE);\n-\t\t\t\t}\n-\n-\t\t\t\tif (deadEdge(from, to))\n-\t\t\t\t{\n-\t\t\t\t\tdeadCode.add(new Edge<D, V>(from, to));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn deadCode;\n-\t}\n-\n-\tpublic static boolean deadEdge(final Vertex<?, ?> from, final Vertex<?, ?> to)\n-\t{\n-\t\tif (null == to.getTerm())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tfor (final Vertex<?, ?> t : from.nextStates())\n-\t\t{\n-\t\t\tif (null == t.getTerm())\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-}\n+    protected final V m_initialState; // of the state machine\n+\n+    public Graph(final V initialState)\n+    {\n+        m_initialState = initialState;\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        final StringBuilder sb = new StringBuilder();\n+        final HashMap<V, Integer> index = new HashMap<V, Integer>();\n+        final Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n+        int i = 0;\n+        stack.push(new Edge<D, V>(null, m_initialState));\n+        index.put(m_initialState, i++);\n+        while (!stack.isEmpty())\n+        {\n+            final V k = stack.pop().to;\n+            sb.append(\"#\").append(index.get(k)).append(\" \");\n+            if (k.getTerm() != null)\n+            {\n+                sb.append(k.getTerm().toString());\n+            }\n+            sb.append(\" ==> \");\n+            for (final V t : k.nextStates())\n+            {\n+                if (!index.containsKey(t))\n+                {\n+                    stack.push(new Edge<D, V>(k, t));\n+                    sb.append(\" \").append(i);\n+                    index.put(t, i++);\n+                }\n+                else\n+                {\n+                    sb.append(\" \").append(index.get(t));\n+                }\n+            }\n+            sb.append('\\n');\n+        }\n+        for (final Edge<D, V> edge : deadEdges(m_initialState))\n+        {\n+            sb.append(\"dead(\").append(index.get(edge.from)).append(\",\").append(index.get(edge.to)).append(\")\").append('\\n');\n+        }\n+        return sb.toString();\n+    }\n+\n+    private void cleanup()\n+    {\n+        final HashMap<V, Boolean> visited = new HashMap<V, Boolean>();\n+        final Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n+        stack.push(new Edge<D, V>(null, m_initialState));\n+        visited.put(m_initialState, Boolean.TRUE);\n+        while (!stack.isEmpty())\n+        {\n+            final Edge<D, V> edge = stack.pop();\n+            final V vertex = edge.to;\n+            boolean more = true;\n+            if (edge.from == null)\n+            {\n+                // Must be the start vertex.\n+\n+            }\n+            else if (vertex.isEnd())\n+            {\n+                // Must be the end vertex!\n+                more = false;\n+            }\n+            else\n+            {\n+                final V target = collapseOut(vertex);\n+                if (null != target)\n+                {\n+                    if (!target.isEnd())\n+                    {\n+                        vertex.nextStates().clear();\n+                        vertex.nextStates().addAll(target.nextStates());\n+                        // Push this edge\n+                        stack.push(edge);\n+                        more = false;\n+                    }\n+                }\n+            }\n+            if (more)\n+            {\n+                for (final V to : vertex.nextStates())\n+                {\n+                    if (!visited.containsKey(to))\n+                    {\n+                        stack.push(new Edge<D, V>(vertex, to));\n+                        visited.put(to, Boolean.TRUE);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private V collapseOut(final V vertex)\n+    {\n+        V target = null;\n+        int unconditional = 0;\n+        int conditional = 0;\n+        for (final V next : vertex.nextStates())\n+        {\n+            if (null != next.getTerm())\n+            {\n+                conditional++;\n+            }\n+            else\n+            {\n+                unconditional++;\n+                target = next;\n+            }\n+        }\n+        if (1 == unconditional)\n+        {\n+            if (0 == conditional)\n+            {\n+                return target;\n+            }\n+            else\n+            {\n+                throw new IllegalStateException(\"Must run dead path removal first.\");\n+            }\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Remove unreachable transitions and short-circuit unconditional transitions.\n+     */\n+    // TODO:(\"Can't use this yet. e.g. a*b doesn't work.\")\n+\n+    public void optimize()\n+    {\n+        for (final Edge<D, V> edge : deadEdges(m_initialState))\n+        {\n+            edge.from.nextStates().remove(edge.to);\n+        }\n+        cleanup();\n+    }\n+\n+    private Iterable<Edge<D, V>> deadEdges(final V initialState)\n+    {\n+        final List<Edge<D, V>> deadCode = new LinkedList<Edge<D, V>>();\n+        final HashMap<V, Boolean> visited = new HashMap<V, Boolean>();\n+        final Stack<Edge<D, V>> stack = new Stack<Edge<D, V>>();\n+        stack.push(new Edge<D, V>(null, initialState));\n+        visited.put(initialState, Boolean.TRUE);\n+        while (!stack.isEmpty())\n+        {\n+            final Edge<D, V> edge = stack.pop();\n+            final V from = edge.to;\n+            for (final V to : from.nextStates())\n+            {\n+                if (!visited.containsKey(to))\n+                {\n+                    stack.push(new Edge<D, V>(from, to));\n+                    visited.put(to, Boolean.TRUE);\n+                }\n+                if (deadEdge(from, to))\n+                {\n+                    deadCode.add(new Edge<D, V>(from, to));\n+                }\n+            }\n+        }\n+        return deadCode;\n+    }\n+\n+    public static boolean deadEdge(final Vertex<?, ?> from, final Vertex<?, ?> to)\n+    {\n+        if (null == to.getTerm())\n+        {\n+            return false;\n+        }\n+        for (final Vertex<?, ?> t : from.nextStates())\n+        {\n+            if (null == t.getTerm())\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 206
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "27",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/308/Graph.java\nindex 4ee737471c5..7ddec9588d5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/308/Graph.java\n@@ -22,7 +22,7 @@ import java.util.Stack;\n \n abstract class Graph<D, V extends Vertex<D, V>>\n {\n-\tprotected final V m_initialState; // of the state machine\n+protected final V m_initialState; // of the state machine\n \n \tpublic Graph(final V initialState)\n \t{\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "27",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/308/Graph.java\nindex 4ee737471c5..4c5f5dac9da 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/308/Graph.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/308/Graph.java\n@@ -22,7 +22,7 @@ import java.util.Stack;\n \n abstract class Graph<D, V extends Vertex<D, V>>\n {\n-\tprotected final V m_initialState; // of the state machine\n+    protected final V m_initialState; // of the state machine\n \n \tpublic Graph(final V initialState)\n \t{\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}