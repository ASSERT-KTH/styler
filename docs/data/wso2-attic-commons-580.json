{
    "project_name": "wso2-attic-commons",
    "error_id": "580",
    "information": {
        "errors": [
            {
                "line": "195",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 122).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "     *           if one occurs while compiling.\n     */\n    public void compile(final Process process, String outputPath, long version) throws CompilationException, IOException {\n        if (process == null)\n            throw new NullPointerException(\"Attempt to compile NULL process.\");\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/580/BpelC.java\nindex bdc848cb75a..e8e6c631d99 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/580/BpelC.java\n@@ -192,8 +192,9 @@ public class BpelC {\n      * @throws CompilationException\n      *           if one occurs while compiling.\n      */\n-    public void compile(final Process process, String outputPath, long version) throws CompilationException, IOException {\n-        if (process == null)\n+    public void compile(final Process\n+      process, String outputPath, long version) throws CompilationException, IOException {\n+         if (process == null)\n             throw new NullPointerException(\"Attempt to compile NULL process.\");\n \n         logCompilationMessage(__cmsgs.infCompilingProcess());\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/580/BpelC.java\nindex bdc848cb75a..df0317b2c70 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/580/BpelC.java\n@@ -16,6 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n+\n package org.apache.ode.bpel.compiler;\n \n import java.io.BufferedOutputStream;\n@@ -51,343 +52,356 @@ import org.xml.sax.InputSource;\n  * Wrapper for {@link org.apache.ode.bpel.compiler.BpelCompiler} implementations,\n  * providing basic utility methods and auto-detection of BPEL version.\n  * </p>\n-s */\n+ * s\n+ */\n public class BpelC {\n-    private static final Log __log = LogFactory.getLog(BpelC.class);\n-    private static final CommonCompilationMessages __cmsgs =\n-            MessageBundle.getMessages(CommonCompilationMessages.class);\n-\n-    public static final String PROCESS_CUSTOM_PROPERTIES = \"customProps\";\n-\n-    private CompileListener _compileListener;\n-    public OutputStream _outputStream = null;\n-\n-    private File _bpelFile;\n-    private File _suDir;\n-    private ResourceFinder _wsdlFinder;\n-    private URI _bpel11wsdl;\n-    private Map<String,Object> _compileProperties;\n-    private Map<QName, ExtensionValidator> _extensionValidators;\n-    private boolean _dryRun = false;\n-\n-    public static BpelC newBpelCompiler() {\n-        return new BpelC();\n+  private static final Log __log = LogFactory.getLog(BpelC.class);\n+  private static final CommonCompilationMessages __cmsgs =\n+    MessageBundle.getMessages(CommonCompilationMessages.class);\n+\n+  public static final String PROCESS_CUSTOM_PROPERTIES = \"customProps\";\n+\n+  private CompileListener _compileListener;\n+  public OutputStream _outputStream = null;\n+\n+  private File _bpelFile;\n+  private File _suDir;\n+  private ResourceFinder _wsdlFinder;\n+  private URI _bpel11wsdl;\n+  private Map<String, Object> _compileProperties;\n+  private Map<QName, ExtensionValidator> _extensionValidators;\n+  private boolean _dryRun = false;\n+\n+  public static BpelC newBpelCompiler() {\n+    return new BpelC();\n+  }\n+\n+  private BpelC() {\n+  }\n+\n+  protected void finalize() throws Throwable {\n+    this.invalidate();\n+    super.finalize();\n+  }\n+\n+  private void invalidate() {\n+    this.setResourceFinder(null);\n+    this.setCompileListener(null);\n+    this.setOutputStream(null);\n+    XslTransformHandler.getInstance().setErrorListener(new net.sf.saxon.lib.StandardErrorListener());\n+  }\n+\n+  /**\n+   * <p>\n+   * Set a non-default target {@link CompileListener} implementation.\n+   * </p>\n+   *\n+   * @param cl the listener.\n+   */\n+  public void setCompileListener(CompileListener cl) {\n+    _compileListener = cl;\n+  }\n+\n+  /**\n+   * Configures the compiler to run a dry compilation, doesn't generate the produced\n+   * compiled process.\n+   *\n+   * @param dryRun\n+   */\n+  public void setDryRun(boolean dryRun) {\n+    _dryRun = dryRun;\n+  }\n+\n+  /**\n+   * <p>\n+   * Tell the compiler how to locate WSDL imports for a BPEL process.  Setting this\n+   * to <code>null</code> will cause the default behavior.\n+   * </p>\n+   *\n+   * @param finder the {@link ResourceFinder} implementation to use.\n+   */\n+  public void setResourceFinder(ResourceFinder finder) {\n+    _wsdlFinder = finder;\n+  }\n+\n+\n+  /**\n+   * Register a \"global\" WSDL import for compilation. This is used to specify WSDL\n+   * imports for BPEL 1.1 processes that do not support the <code>&lt;import&gt;</code>\n+   * BPEL construct.\n+   *\n+   * @param wsdl the WSDL URI (resolvable against the resource repository)\n+   */\n+  public void setProcessWSDL(URI wsdl) {\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(\"Adding WSDL import: \\\"\" + wsdl.toASCIIString() + \"\\\".\");\n     }\n-\n-    private BpelC() {\n+    _bpel11wsdl = wsdl;\n+  }\n+\n+  /**\n+   * Compilation properties eventually retrieved by the compiler\n+   *\n+   * @param compileProperties\n+   */\n+  public void setCompileProperties(Map<String, Object> compileProperties) {\n+    _compileProperties = compileProperties;\n+  }\n+\n+  /**\n+   * Registers extension validators to eventually validate the content of extensibility\n+   * elements.\n+   *\n+   * @param extensionValidators\n+   */\n+  public void setExtensionValidators(Map<QName, ExtensionValidator> extensionValidators) {\n+    _extensionValidators = extensionValidators;\n+  }\n+\n+  /**\n+   * Set the output stream to which the compiled representation will be generated.\n+   *\n+   * @param os compiled representation output stream\n+   */\n+  public void setOutputStream(OutputStream os) {\n+    if (_outputStream != null) {\n+      try {\n+        _outputStream.close();\n+      } catch (IOException ioex) {\n+        // ignore\n+      }\n     }\n \n-    protected void finalize() throws Throwable\n-    {\n-        this.invalidate();\n-        super.finalize();\n-    }\n+    _outputStream = os;\n \n-    private void invalidate() {\n-        this.setResourceFinder(null);\n-        this.setCompileListener(null);\n-        this.setOutputStream(null);\n-        XslTransformHandler.getInstance().setErrorListener( new net.sf.saxon.lib.StandardErrorListener() );\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(\"Sett output to stream \" + os);\n     }\n+  }\n \n-    /**\n-     * <p>\n-     * Set a non-default target {@link CompileListener} implementation.\n-     * </p>\n-     * @param cl the listener.\n-     */\n-    public void setCompileListener(CompileListener cl) {\n-        _compileListener = cl;\n+  public void setBaseDirectory(File baseDir) {\n+    if (baseDir == null) {\n+      throw new IllegalArgumentException(\"Argument 'baseDir' is null\");\n     }\n-\n-    /**\n-     * Configures the compiler to run a dry compilation, doesn't generate the produced\n-     * compiled process.\n-     * @param dryRun\n-     */\n-    public void setDryRun(boolean dryRun) {\n-        _dryRun = dryRun;\n+    if (!baseDir.exists()) {\n+      throw new IllegalArgumentException(\"Directory \" + baseDir + \" does not exist\");\n     }\n-\n-    /**\n-     * <p>\n-     * Tell the compiler how to locate WSDL imports for a BPEL process.  Setting this\n-     * to <code>null</code> will cause the default behavior.\n-     * </p>\n-     * @param finder the {@link ResourceFinder} implementation to use.\n-     */\n-    public void setResourceFinder(ResourceFinder finder) {\n-        _wsdlFinder = finder;\n+    _suDir = baseDir;\n+  }\n+\n+  /**\n+   * <p>\n+   * Compile a BPEL process from a BOM {@link Process} object.\n+   * </p>\n+   *\n+   * @param process the BOM <code>Process</code> to compile.\n+   * @throws IOException          if one occurs while processing (e.g., getting imports) or writing\n+   *                              output.\n+   * @throws CompilationException if one occurs while compiling.\n+   */\n+  public void compile(final Process process, String outputPath, long version) throws CompilationException, IOException {\n+    if (process == null) {\n+      throw new NullPointerException(\"Attempt to compile NULL process.\");\n     }\n \n+    logCompilationMessage(__cmsgs.infCompilingProcess());\n \n-    /**\n-     * Register a \"global\" WSDL import for compilation. This is used to specify WSDL\n-     * imports for BPEL 1.1 processes that do not support the <code>&lt;import&gt;</code>\n-     * BPEL construct.\n-     * @param wsdl the WSDL URI (resolvable against the resource repository)\n-     */\n-    public void setProcessWSDL(URI wsdl) {\n-        if (__log.isDebugEnabled()) {\n-            __log.debug(\"Adding WSDL import: \\\"\" + wsdl.toASCIIString() + \"\\\".\");\n-        }\n-        _bpel11wsdl = wsdl;\n-    }\n-\n-    /**\n-     * Compilation properties eventually retrieved by the compiler\n-     * @param compileProperties\n-     */\n-    public void setCompileProperties(Map<String, Object> compileProperties) {\n-        _compileProperties = compileProperties;\n-    }\n+    BpelCompiler compiler;\n+    ResourceFinder wf;\n \n-    /**\n-     * Registers extension validators to eventually validate the content of extensibility\n-     * elements.\n-     * @param extensionValidators\n-     */\n-    public void setExtensionValidators(Map<QName, ExtensionValidator> extensionValidators) {\n-        _extensionValidators = extensionValidators;\n+    if (_wsdlFinder != null) {\n+      wf = _wsdlFinder;\n+    } else {\n+      File suDir = _suDir != null ? _suDir : _bpelFile.getParentFile();\n+      wf = new DefaultResourceFinder(_bpelFile.getAbsoluteFile().getParentFile(), suDir.getAbsoluteFile());\n     }\n \n-    /**\n-     * Set the output stream to which the compiled representation will be generated.\n-     * @param os compiled representation output stream\n-     */\n-    public void setOutputStream(OutputStream os) {\n-        if (_outputStream != null) {\n-            try {\n-                _outputStream.close();\n-            }\n-            catch (IOException ioex) {\n-                // ignore\n-            }\n+    CompileListener clistener = new CompileListener() {\n+      public void onCompilationMessage(CompilationMessage compilationMessage) {\n+        SourceLocation location = compilationMessage.source;\n+        if (location == null) {\n+          compilationMessage.source = process;\n         }\n-\n-        _outputStream = os;\n-\n-        if (__log.isDebugEnabled()) {\n-            __log.debug(\"Sett output to stream \" + os);\n+        logCompilationMessage(compilationMessage);\n+      }\n+    };\n+\n+    try {\n+      switch (process.getBpelVersion()) {\n+      case BPEL20:\n+        compiler = new BpelCompiler20();\n+        compiler.setResourceFinder(wf);\n+        if (_bpel11wsdl != null) {\n+          CompilationMessage cmsg = __cmsgs.warnWsdlUriIgnoredFor20Process();\n+          logCompilationMessage(cmsg);\n         }\n-    }\n-\n-    public void setBaseDirectory(File baseDir) {\n-        if (baseDir == null) throw new IllegalArgumentException(\"Argument 'baseDir' is null\");\n-        if (!baseDir.exists()) throw new IllegalArgumentException(\"Directory \"+baseDir+\" does not exist\");\n-        _suDir = baseDir;\n-    }\n-\n-    /**\n-     * <p>\n-     * Compile a BPEL process from a BOM {@link Process} object.\n-     * </p>\n-     *\n-     * @param process\n-     *          the BOM <code>Process</code> to compile.\n-     *\n-     * @throws IOException\n-     *           if one occurs while processing (e.g., getting imports) or writing\n-     *           output.\n-     * @throws CompilationException\n-     *           if one occurs while compiling.\n-     */\n-    public void compile(final Process process, String outputPath, long version) throws CompilationException, IOException {\n-        if (process == null)\n-            throw new NullPointerException(\"Attempt to compile NULL process.\");\n-\n-        logCompilationMessage(__cmsgs.infCompilingProcess());\n-\n-        BpelCompiler compiler;\n-        ResourceFinder wf;\n-\n-        if (_wsdlFinder != null) {\n-            wf = _wsdlFinder;\n-        } else {\n-            File suDir = _suDir != null ? _suDir : _bpelFile.getParentFile();\n-            wf = new DefaultResourceFinder(_bpelFile.getAbsoluteFile().getParentFile(), suDir.getAbsoluteFile());\n-        }\n-\n-        CompileListener clistener = new CompileListener() {\n-            public void onCompilationMessage(CompilationMessage compilationMessage) {\n-                SourceLocation location = compilationMessage.source;\n-                if (location == null) {\n-                    compilationMessage.source = process;\n-                }\n-                logCompilationMessage(compilationMessage);\n-            }\n-        };\n-\n-        try {\n-            switch (process.getBpelVersion()) {\n-                case BPEL20:\n-                    compiler = new BpelCompiler20();\n-                    compiler.setResourceFinder(wf);\n-                    if (_bpel11wsdl != null) {\n-                        CompilationMessage cmsg = __cmsgs.warnWsdlUriIgnoredFor20Process();\n-                        logCompilationMessage(cmsg);\n-                    }\n-                    break;\n-                case BPEL20_DRAFT:\n-                    compiler = new BpelCompiler20Draft();\n-                    compiler.setResourceFinder(wf);\n-                    if (_bpel11wsdl != null) {\n-                        CompilationMessage cmsg = __cmsgs.warnWsdlUriIgnoredFor20Process();\n-                        logCompilationMessage(cmsg);\n-                    }\n-                    break;\n-                case BPEL11:\n-                    compiler = new BpelCompiler11();\n-                    compiler.setResourceFinder(wf);\n-                    if (_bpel11wsdl != null) {\n-                        compiler.addWsdlImport(new URI(_bpelFile.getName()), _bpel11wsdl,null);\n-                    } else {\n-                        CompilationMessage cmsg = __cmsgs.errBpel11RequiresWsdl();\n-                        logCompilationMessage(cmsg);\n-                        this.invalidate();\n-                        throw new CompilationException(cmsg);\n-                    }\n-                    break;\n-                default:\n-                    CompilationMessage cmsg = __cmsgs.errUnrecognizedBpelVersion();\n-                    logCompilationMessage(cmsg);\n-                    this.invalidate();\n-                    throw new CompilationException(cmsg);\n-            }\n-            compiler.setCompileListener(clistener);\n-            if (_compileProperties != null) {\n-                if (_compileProperties.get(PROCESS_CUSTOM_PROPERTIES) != null)\n-                    compiler.setCustomProperties((Map<QName, Node>) _compileProperties.get(PROCESS_CUSTOM_PROPERTIES));\n-            }\n-\n-            if (_extensionValidators != null) {\n-            \tcompiler.setExtensionValidators(_extensionValidators);\n-            }\n-        } catch (CompilationException ce) {\n-            this.invalidate();\n-            throw ce;\n-        } catch (Exception ex) {\n-            CompilationMessage cmsg = __cmsgs.errBpelParseErr();\n-            logCompilationMessage(cmsg);\n-            this.invalidate();\n-            throw new CompilationException(cmsg,ex);\n+        break;\n+      case BPEL20_DRAFT:\n+        compiler = new BpelCompiler20Draft();\n+        compiler.setResourceFinder(wf);\n+        if (_bpel11wsdl != null) {\n+          CompilationMessage cmsg = __cmsgs.warnWsdlUriIgnoredFor20Process();\n+          logCompilationMessage(cmsg);\n         }\n-\n-        OProcess oprocess;\n-        try {\n-            oprocess = compiler.compile(process,wf,version);\n-        }\n-        catch (CompilationException cex) {\n-            this.invalidate();\n-            throw cex;\n+        break;\n+      case BPEL11:\n+        compiler = new BpelCompiler11();\n+        compiler.setResourceFinder(wf);\n+        if (_bpel11wsdl != null) {\n+          compiler.addWsdlImport(new URI(_bpelFile.getName()), _bpel11wsdl, null);\n+        } else {\n+          CompilationMessage cmsg = __cmsgs.errBpel11RequiresWsdl();\n+          logCompilationMessage(cmsg);\n+          this.invalidate();\n+          throw new CompilationException(cmsg);\n         }\n-\n-        if (!_dryRun) {\n-            if (outputPath != null) {\n-                this.setOutputStream(new BufferedOutputStream(new FileOutputStream(outputPath)));\n-                if (__log.isDebugEnabled()) {\n-                    __log.debug(\"Writing compilation results to \" + outputPath);\n-                }\n-            } else if (_outputStream != null) {\n-                if (__log.isDebugEnabled()) {\n-                    __log.debug(\"Writing compilation results to \" + _outputStream.getClass().getName());\n-                }\n-            } else {\n-                throw new IllegalStateException(\"must setOutputStream() or setOutputDirectory()!\");\n-            }\n-\n-            try {\n-                Serializer fileHeader = new Serializer(System.currentTimeMillis());\n-                fileHeader.writeOProcess(oprocess, _outputStream);\n-            } finally {\n-                // close & mark myself invalid\n-                this.invalidate();\n-            }\n+        break;\n+      default:\n+        CompilationMessage cmsg = __cmsgs.errUnrecognizedBpelVersion();\n+        logCompilationMessage(cmsg);\n+        this.invalidate();\n+        throw new CompilationException(cmsg);\n+      }\n+      compiler.setCompileListener(clistener);\n+      if (_compileProperties != null) {\n+        if (_compileProperties.get(PROCESS_CUSTOM_PROPERTIES) != null) {\n+          compiler.setCustomProperties((Map<QName, Node>) _compileProperties.get(PROCESS_CUSTOM_PROPERTIES));\n         }\n+      }\n+\n+      if (_extensionValidators != null) {\n+        compiler.setExtensionValidators(_extensionValidators);\n+      }\n+    } catch (CompilationException ce) {\n+      this.invalidate();\n+      throw ce;\n+    } catch (Exception ex) {\n+      CompilationMessage cmsg = __cmsgs.errBpelParseErr();\n+      logCompilationMessage(cmsg);\n+      this.invalidate();\n+      throw new CompilationException(cmsg, ex);\n     }\n \n-    /**\n-     * <p>\n-     * Compile a BPEL process from a file.  This method uses a {@link BpelObjectFactory}\n-     * to parse the XML and then calls {@link #compile(Process,String)}.\n-     * </p>\n-     * @param bpelFile the file of the BPEL process to be compiled.\n-     * @throws IOException if one occurs while reading the BPEL process or writing the\n-     * output.\n-     * @throws CompilationException if one occurs while compiling the process.\n-     * @deprecated use compile(File bpelFile, long version) instead\n-     */\n-    public void compile(File bpelFile) throws CompilationException, IOException {\n-       compile(bpelFile, 0);\n+    OProcess oprocess;\n+    try {\n+      oprocess = compiler.compile(process, wf, version);\n+    } catch (CompilationException cex) {\n+      this.invalidate();\n+      throw cex;\n     }\n \n-    /**\n-     * <p>\n-     * Compile a BPEL process from a file.  This method uses a {@link BpelObjectFactory}\n-     * to parse the XML and then calls {@link #compile(Process,String)}.\n-     * </p>\n-     * @param bpelFile the file of the BPEL process to be compiled.\n-     * @param version the version of the BPEL file.\n-     * @throws IOException if one occurs while reading the BPEL process or writing the\n-     * output.\n-     * @throws CompilationException if one occurs while compiling the process.\n-     */\n-    public void compile(File bpelFile, long version) throws CompilationException, IOException {\n+    if (!_dryRun) {\n+      if (outputPath != null) {\n+        this.setOutputStream(new BufferedOutputStream(new FileOutputStream(outputPath)));\n         if (__log.isDebugEnabled()) {\n-            __log.debug(\"compile(URL)\");\n+          __log.debug(\"Writing compilation results to \" + outputPath);\n         }\n-\n-        if (bpelFile == null) {\n-            this.invalidate();\n-            throw new IllegalArgumentException(\"Null bpelFile\");\n-        }\n-\n-        _bpelFile = bpelFile;\n-        Process process;\n-        try {\n-            InputSource isrc = new InputSource(new ByteArrayInputStream(StreamUtils.read(bpelFile.toURL())));\n-            isrc.setSystemId(bpelFile.getAbsolutePath());\n-\n-            process = BpelObjectFactory.getInstance().parse(isrc,_bpelFile.toURI());\n-        } catch (Exception e) {\n-            CompilationMessage cmsg = __cmsgs.errBpelParseErr().setSource(new SourceLocationImpl(bpelFile.toURI()));\n-            this.invalidate();\n-            throw new CompilationException(cmsg, e);\n+      } else if (_outputStream != null) {\n+        if (__log.isDebugEnabled()) {\n+          __log.debug(\"Writing compilation results to \" + _outputStream.getClass().getName());\n         }\n-\n-        assert process != null;\n-\n-        // Output file = bpel file with a cbp extension\n-        String bpelPath = bpelFile.getAbsolutePath();\n-        String cbpPath = bpelPath.substring(0, bpelPath.lastIndexOf(\".\")) + \".cbp\";\n-\n-        compile(process, cbpPath, version);\n+      } else {\n+        throw new IllegalStateException(\"must setOutputStream() or setOutputDirectory()!\");\n+      }\n+\n+      try {\n+        Serializer fileHeader = new Serializer(System.currentTimeMillis());\n+        fileHeader.writeOProcess(oprocess, _outputStream);\n+      } finally {\n+        // close & mark myself invalid\n         this.invalidate();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * <p>\n+   * Compile a BPEL process from a file.  This method uses a {@link BpelObjectFactory}\n+   * to parse the XML and then calls {@link #compile(Process, String)}.\n+   * </p>\n+   *\n+   * @param bpelFile the file of the BPEL process to be compiled.\n+   * @throws IOException          if one occurs while reading the BPEL process or writing the\n+   *                              output.\n+   * @throws CompilationException if one occurs while compiling the process.\n+   * @deprecated use compile(File bpelFile, long version) instead\n+   */\n+  public void compile(File bpelFile) throws CompilationException, IOException {\n+    compile(bpelFile, 0);\n+  }\n+\n+  /**\n+   * <p>\n+   * Compile a BPEL process from a file.  This method uses a {@link BpelObjectFactory}\n+   * to parse the XML and then calls {@link #compile(Process, String)}.\n+   * </p>\n+   *\n+   * @param bpelFile the file of the BPEL process to be compiled.\n+   * @param version  the version of the BPEL file.\n+   * @throws IOException          if one occurs while reading the BPEL process or writing the\n+   *                              output.\n+   * @throws CompilationException if one occurs while compiling the process.\n+   */\n+  public void compile(File bpelFile, long version) throws CompilationException, IOException {\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(\"compile(URL)\");\n     }\n \n+    if (bpelFile == null) {\n+      this.invalidate();\n+      throw new IllegalArgumentException(\"Null bpelFile\");\n+    }\n \n-    /**\n-     * Log a compilation message, both to the log, and to the listener (if any).\n-     * @param cmsg\n-     */\n-    private void logCompilationMessage(CompilationMessage cmsg) {\n-        if (_compileListener != null) {\n-            _compileListener.onCompilationMessage(cmsg);\n-        } else {\n-            switch (cmsg.severity) {\n-                case CompilationMessage.ERROR:\n-                    if (__log.isErrorEnabled())\n-                        __log.error(cmsg.toErrorString());\n-                    break;\n-                case CompilationMessage.INFO:\n-                    if (__log.isInfoEnabled())\n-                        __log.info(cmsg.toErrorString());\n-                    break;\n-                case CompilationMessage.WARN:\n-                    if (__log.isWarnEnabled())\n-                        __log.warn(cmsg.toErrorString());\n-            }\n+    _bpelFile = bpelFile;\n+    Process process;\n+    try {\n+      InputSource isrc = new InputSource(new ByteArrayInputStream(StreamUtils.read(bpelFile.toURL())));\n+      isrc.setSystemId(bpelFile.getAbsolutePath());\n+\n+      process = BpelObjectFactory.getInstance().parse(isrc, _bpelFile.toURI());\n+    } catch (Exception e) {\n+      CompilationMessage cmsg = __cmsgs.errBpelParseErr().setSource(new SourceLocationImpl(bpelFile.toURI()));\n+      this.invalidate();\n+      throw new CompilationException(cmsg, e);\n+    }\n+\n+    assert process != null;\n+\n+    // Output file = bpel file with a cbp extension\n+    String bpelPath = bpelFile.getAbsolutePath();\n+    String cbpPath = bpelPath.substring(0, bpelPath.lastIndexOf(\".\")) + \".cbp\";\n+\n+    compile(process, cbpPath, version);\n+    this.invalidate();\n+  }\n+\n+\n+  /**\n+   * Log a compilation message, both to the log, and to the listener (if any).\n+   *\n+   * @param cmsg\n+   */\n+  private void logCompilationMessage(CompilationMessage cmsg) {\n+    if (_compileListener != null) {\n+      _compileListener.onCompilationMessage(cmsg);\n+    } else {\n+      switch (cmsg.severity) {\n+      case CompilationMessage.ERROR:\n+        if (__log.isErrorEnabled()) {\n+          __log.error(cmsg.toErrorString());\n+        }\n+        break;\n+      case CompilationMessage.INFO:\n+        if (__log.isInfoEnabled()) {\n+          __log.info(cmsg.toErrorString());\n+        }\n+        break;\n+      case CompilationMessage.WARN:\n+        if (__log.isWarnEnabled()) {\n+          __log.warn(cmsg.toErrorString());\n         }\n+      }\n     }\n+  }\n \n }\n",
            "diff_size": 499
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "195",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 122).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/580/BpelC.java\nindex bdc848cb75a..7653e196c1f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/580/BpelC.java\n@@ -390,4 +390,4 @@ public class BpelC {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/580/BpelC.java\nindex bdc848cb75a..e8e6c631d99 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/580/BpelC.java\n@@ -192,8 +192,9 @@ public class BpelC {\n      * @throws CompilationException\n      *           if one occurs while compiling.\n      */\n-    public void compile(final Process process, String outputPath, long version) throws CompilationException, IOException {\n-        if (process == null)\n+    public void compile(final Process\n+      process, String outputPath, long version) throws CompilationException, IOException {\n+         if (process == null)\n             throw new NullPointerException(\"Attempt to compile NULL process.\");\n \n         logCompilationMessage(__cmsgs.infCompilingProcess());\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/580/BpelC.java\nindex bdc848cb75a..d389d6c62f3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/580/BpelC.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/580/BpelC.java\n@@ -192,8 +192,9 @@ public class BpelC {\n      * @throws CompilationException\n      *           if one occurs while compiling.\n      */\n-    public void compile(final Process process, String outputPath, long version) throws CompilationException, IOException {\n-        if (process == null)\n+    public void compile(final Process process, String outputPath, long version)\n+        throws CompilationException, IOException {\n+         if (process == null)\n             throw new NullPointerException(\"Attempt to compile NULL process.\");\n \n         logCompilationMessage(__cmsgs.infCompilingProcess());\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}