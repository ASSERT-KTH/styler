{
    "project_name": "IQSS-dataverse",
    "error_id": "11",
    "information": {
        "errors": [
            {
                "line": "201",
                "column": "9",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "\n        if (persistentId != null) {\n        \t// always show url format\n            citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html)); \n        }\n        citationList.add(formatString(publisher, html));",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "614",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/11/DataCitation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/11/DataCitation.java\nindex 4dcfbc035a5..9b0f41cca9e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/11/DataCitation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/11/DataCitation.java\n@@ -198,8 +198,8 @@ public class DataCitation {\n         }\n \n         if (persistentId != null) {\n-        \t// always show url format\n-            citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html)); \n+        // always show url format citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html));\n+     citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html)); \n         }\n         citationList.add(formatString(publisher, html));\n         citationList.add(version);\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/11/DataCitation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/11/DataCitation.java\nindex 4dcfbc035a5..cab2eb0541b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/11/DataCitation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/11/DataCitation.java\n@@ -3,6 +3,7 @@\n  * To change this template file, choose Tools | Templates\n  * and open the template in the editor.\n  */\n+\n package edu.harvard.iq.dataverse;\n \n import edu.harvard.iq.dataverse.branding.BrandingUtil;\n@@ -37,480 +38,479 @@ import org.apache.commons.text.StringEscapeUtils;\n import org.apache.commons.lang3.StringUtils;\n \n /**\n- *\n  * @author gdurand, qqmyers\n  */\n public class DataCitation {\n \n-    private static final Logger logger = Logger.getLogger(DataCitation.class.getCanonicalName());\n-\n-    private List<String> authors = new ArrayList<String>();\n-    private List<String> producers = new ArrayList<String>();\n-    private String title;\n-    private String fileTitle = null;\n-    private String year;\n-    private Date date;\n-    private GlobalId persistentId;\n-    private String version;\n-    private String UNF = null;\n-    private String publisher;\n-    private boolean direct;\n-    private List<String> funders;\n-    private String seriesTitle;\n-    private String description;\n-    private List<String> datesOfCollection;\n-    private List<String> keywords;\n-    private List<String> kindsOfData;\n-    private List<String> languages;\n-    private List<String> spatialCoverages;\n-\n-    private List<DatasetField> optionalValues = new ArrayList<>();\n-    private int optionalURLcount = 0; \n-\n-    public DataCitation(DatasetVersion dsv) {\n-        this(dsv, false);\n-    }\n-\n-\n-    public DataCitation(DatasetVersion dsv, boolean direct) {\n-        this.direct = direct;\n-        getCommonValuesFrom(dsv);\n-\n-        // The Global Identifier: \n-        // It is always part of the citation for the local datasets; \n-        // And for *some* harvested datasets. \n-        persistentId = getPIDFrom(dsv, dsv.getDataset());\n-\n-        // UNF\n-        UNF = dsv.getUNF();\n-\n-        // optional values\n-        for (DatasetFieldType dsfType : dsv.getDataset().getOwner().getCitationDatasetFieldTypes()) {\n-            DatasetField dsf = dsv.getDatasetField(dsfType);\n-            if (dsf != null) {\n-                optionalValues.add(dsf);\n-                \n-                if (dsf.getDatasetFieldType().getFieldType().equals(DatasetFieldType.FieldType.URL)) {\n-                    optionalURLcount++;\n-                }\n-            }\n-        }\n-    }\n-    \n-    public DataCitation(FileMetadata fm) {\n-        this(fm, false);\n-    }\n-\n-    public DataCitation(FileMetadata fm, boolean direct) {\n-        this.direct = direct;\n-        DatasetVersion dsv = fm.getDatasetVersion();\n-\n-        getCommonValuesFrom(dsv);\n-\n-        // file Title for direct File citation\n-        fileTitle = fm.getLabel();\n-        DataFile df = fm.getDataFile();\n-\n-        // File description\n-        description = fm.getDescription();\n-\n-        // The Global Identifier of the Datafile (if published and isDirect==true) or Dataset as appropriate\n-        persistentId = getPIDFrom(dsv, df);\n-\n-        // UNF\n-        if (df.isTabularData() && df.getUnf() != null && !df.getUnf().isEmpty()) {\n-            UNF = df.getUnf();\n-        }\n-    }\n-\n-    private void getCommonValuesFrom(DatasetVersion dsv) {\n-\n-        getAuthorsAndProducersFrom(dsv);\n-        funders = dsv.getUniqueGrantAgencyValues();\n-        kindsOfData = dsv.getKindOfData();\n-        // publication year\n-        date = getDateFrom(dsv);\n-        year = new SimpleDateFormat(\"yyyy\").format(date);\n-\n-        datesOfCollection = dsv.getDatesOfCollection();\n-        title = dsv.getTitle();\n-        seriesTitle = dsv.getSeriesTitle();\n-        keywords = dsv.getKeywords();\n-        languages = dsv.getLanguages();\n-        spatialCoverages = dsv.getSpatialCoverages();\n-        publisher = getPublisherFrom(dsv);\n-        version = getVersionFrom(dsv);\n-    }\n-\n-    public String getAuthorsString() {\n-        return String.join(\"; \", authors);\n-    }\n-\n-    public String getTitle() {\n-        return title;\n-    }\n-\n-    public String getFileTitle() {\n-        return fileTitle;\n-    }\n-\n-    public boolean isDirect() {\n-        return direct;\n-    }\n-\n-    \n-    public String getYear() {\n-        return year;\n-    }\n-\n-    public GlobalId getPersistentId() {\n-        return persistentId;\n-    }\n-\n-    public String getVersion() {\n-        return version;\n-    }\n+  private static final Logger logger = Logger.getLogger(DataCitation.class.getCanonicalName());\n+\n+  private List<String> authors = new ArrayList<String>();\n+  private List<String> producers = new ArrayList<String>();\n+  private String title;\n+  private String fileTitle = null;\n+  private String year;\n+  private Date date;\n+  private GlobalId persistentId;\n+  private String version;\n+  private String UNF = null;\n+  private String publisher;\n+  private boolean direct;\n+  private List<String> funders;\n+  private String seriesTitle;\n+  private String description;\n+  private List<String> datesOfCollection;\n+  private List<String> keywords;\n+  private List<String> kindsOfData;\n+  private List<String> languages;\n+  private List<String> spatialCoverages;\n \n-    public String getUNF() {\n-        return UNF;\n-    }\n+  private List<DatasetField> optionalValues = new ArrayList<>();\n+  private int optionalURLcount = 0;\n \n-    public String getPublisher() {\n-        return publisher;\n-    }\n+  public DataCitation(DatasetVersion dsv) {\n+    this(dsv, false);\n+  }\n \n-    @Override\n-    public String toString() {\n-        return toString(false);\n-    }\n-\n-    public String toString(boolean html) {\n-        // first add comma separated parts        \n-        String separator = \", \";\n-        List<String> citationList = new ArrayList<>();\n-        citationList.add(formatString(getAuthorsString(), html));\n-        citationList.add(year);\n-        if ((fileTitle != null) && isDirect()) {\n-            citationList.add(formatString(fileTitle, html, \"\\\"\"));\n-            citationList.add(formatString(title, html, \"<em>\", \"</em>\"));\n-        } else {\n-        citationList.add(formatString(title, html, \"\\\"\"));\n-        }\n \n-        if (persistentId != null) {\n-        \t// always show url format\n-            citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html)); \n-        }\n-        citationList.add(formatString(publisher, html));\n-        citationList.add(version);\n+  public DataCitation(DatasetVersion dsv, boolean direct) {\n+    this.direct = direct;\n+    getCommonValuesFrom(dsv);\n \n-        StringBuilder citation = new StringBuilder(citationList.stream().filter(value -> !StringUtils.isEmpty(value))\n-                .collect(Collectors.joining(separator)));\n+    // The Global Identifier:\n+    // It is always part of the citation for the local datasets;\n+    // And for *some* harvested datasets.\n+    persistentId = getPIDFrom(dsv, dsv.getDataset());\n+\n+    // UNF\n+    UNF = dsv.getUNF();\n \n-        if ((fileTitle != null) && !isDirect()) {\n-            citation.append(\"; \" + formatString(fileTitle, html, \"\") + \" [fileName]\");\n-        }\n-        // append UNF\n-        if (!StringUtils.isEmpty(UNF)) {\n-            citation.append(separator).append(UNF).append(\" [fileUNF]\");\n-        }\n+    // optional values\n+    for (DatasetFieldType dsfType : dsv.getDataset().getOwner().getCitationDatasetFieldTypes()) {\n+      DatasetField dsf = dsv.getDatasetField(dsfType);\n+      if (dsf != null) {\n+        optionalValues.add(dsf);\n+\n+        if (dsf.getDatasetFieldType().getFieldType().equals(DatasetFieldType.FieldType.URL)) {\n+          optionalURLcount++;\n+        }\n+      }\n+    }\n+  }\n+\n+  public DataCitation(FileMetadata fm) {\n+    this(fm, false);\n+  }\n+\n+  public DataCitation(FileMetadata fm, boolean direct) {\n+    this.direct = direct;\n+    DatasetVersion dsv = fm.getDatasetVersion();\n+\n+    getCommonValuesFrom(dsv);\n+\n+    // file Title for direct File citation\n+    fileTitle = fm.getLabel();\n+    DataFile df = fm.getDataFile();\n+\n+    // File description\n+    description = fm.getDescription();\n+\n+    // The Global Identifier of the Datafile (if published and isDirect==true) or Dataset as appropriate\n+    persistentId = getPIDFrom(dsv, df);\n+\n+    // UNF\n+    if (df.isTabularData() && df.getUnf() != null && !df.getUnf().isEmpty()) {\n+      UNF = df.getUnf();\n+    }\n+  }\n+\n+  private void getCommonValuesFrom(DatasetVersion dsv) {\n+\n+    getAuthorsAndProducersFrom(dsv);\n+    funders = dsv.getUniqueGrantAgencyValues();\n+    kindsOfData = dsv.getKindOfData();\n+    // publication year\n+    date = getDateFrom(dsv);\n+    year = new SimpleDateFormat(\"yyyy\").format(date);\n \n-        for (DatasetField dsf : optionalValues) {\n-            String displayName = dsf.getDatasetFieldType().getDisplayName();\n-            String displayValue;\n-            \n-            if (dsf.getDatasetFieldType().getFieldType().equals(DatasetFieldType.FieldType.URL)) {\n-                displayValue = formatURL(dsf.getDisplayValue(), dsf.getDisplayValue(), html);\n-                if (optionalURLcount == 1) {\n-                    displayName = \"URL\";\n-                }\n-            } else {\n-                displayValue = formatString(dsf.getDisplayValue(), html);\n-            }\n-            citation.append(\" [\").append(displayName).append(\": \").append(displayValue).append(\"]\");\n-        }\n-        return citation.toString();\n+    datesOfCollection = dsv.getDatesOfCollection();\n+    title = dsv.getTitle();\n+    seriesTitle = dsv.getSeriesTitle();\n+    keywords = dsv.getKeywords();\n+    languages = dsv.getLanguages();\n+    spatialCoverages = dsv.getSpatialCoverages();\n+    publisher = getPublisherFrom(dsv);\n+    version = getVersionFrom(dsv);\n+  }\n+\n+  public String getAuthorsString() {\n+    return String.join(\"; \", authors);\n+  }\n+\n+  public String getTitle() {\n+    return title;\n+  }\n+\n+  public String getFileTitle() {\n+    return fileTitle;\n+  }\n+\n+  public boolean isDirect() {\n+    return direct;\n+  }\n+\n+\n+  public String getYear() {\n+    return year;\n+  }\n+\n+  public GlobalId getPersistentId() {\n+    return persistentId;\n+  }\n+\n+  public String getVersion() {\n+    return version;\n+  }\n+\n+  public String getUNF() {\n+    return UNF;\n+  }\n+\n+  public String getPublisher() {\n+    return publisher;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return toString(false);\n+  }\n+\n+  public String toString(boolean html) {\n+    // first add comma separated parts\n+    String separator = \", \";\n+    List<String> citationList = new ArrayList<>();\n+    citationList.add(formatString(getAuthorsString(), html));\n+    citationList.add(year);\n+    if ((fileTitle != null) && isDirect()) {\n+      citationList.add(formatString(fileTitle, html, \"\\\"\"));\n+      citationList.add(formatString(title, html, \"<em>\", \"</em>\"));\n+    } else {\n+      citationList.add(formatString(title, html, \"\\\"\"));\n+    }\n+\n+    if (persistentId != null) {\n+      // always show url format\n+      citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html));\n+    }\n+    citationList.add(formatString(publisher, html));\n+    citationList.add(version);\n+\n+    StringBuilder citation = new StringBuilder(citationList.stream().filter(value -> !StringUtils.isEmpty(value))\n+      .collect(Collectors.joining(separator)));\n+\n+    if ((fileTitle != null) && !isDirect()) {\n+      citation.append(\"; \" + formatString(fileTitle, html, \"\") + \" [fileName]\");\n+    }\n+    // append UNF\n+    if (!StringUtils.isEmpty(UNF)) {\n+      citation.append(separator).append(UNF).append(\" [fileUNF]\");\n+    }\n+\n+    for (DatasetField dsf : optionalValues) {\n+      String displayName = dsf.getDatasetFieldType().getDisplayName();\n+      String displayValue;\n+\n+      if (dsf.getDatasetFieldType().getFieldType().equals(DatasetFieldType.FieldType.URL)) {\n+        displayValue = formatURL(dsf.getDisplayValue(), dsf.getDisplayValue(), html);\n+        if (optionalURLcount == 1) {\n+          displayName = \"URL\";\n+        }\n+      } else {\n+        displayValue = formatString(dsf.getDisplayValue(), html);\n+      }\n+      citation.append(\" [\").append(displayName).append(\": \").append(displayValue).append(\"]\");\n+    }\n+    return citation.toString();\n+  }\n+\n+  public String toBibtexString() {\n+    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+    try {\n+      writeAsBibtexCitation(buffer);\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    //Use UTF-8?\n+    return buffer.toString();\n+  }\n+\n+  public void writeAsBibtexCitation(OutputStream os) throws IOException {\n+    // Use UTF-8\n+    Writer out = new BufferedWriter(new OutputStreamWriter(os, \"utf-8\"));\n+    if (getFileTitle() != null && isDirect()) {\n+      out.write(\"@incollection{\");\n+    } else {\n+      out.write(\"@data{\");\n+    }\n+    out.write(persistentId.getIdentifier() + \"_\" + year + \",\" + \"\\r\\n\");\n+    out.write(\"author = {\");\n+    out.write(String.join(\" and \", authors));\n+    out.write(\"},\\r\\n\");\n+    out.write(\"publisher = {\");\n+    out.write(publisher);\n+    out.write(\"},\\r\\n\");\n+    if (getFileTitle() != null && isDirect()) {\n+      out.write(\"title = {\");\n+      out.write(fileTitle);\n+      out.write(\"},\\r\\n\");\n+      out.write(\"booktitle = {\");\n+      out.write(title);\n+      out.write(\"},\\r\\n\");\n+    } else {\n+      out.write(\"title = {{\");\n+      String doubleQ = \"\\\"\";\n+      String doubleTick = \"``\";\n+      String doubleAp = \"''\";\n+      out.write(title.replaceFirst(doubleQ, doubleTick).replaceFirst(doubleQ, doubleAp));\n+      out.write(\"}},\\r\\n\");\n+    }\n+    if (UNF != null) {\n+      out.write(\"UNF = {\");\n+      out.write(UNF);\n+      out.write(\"},\\r\\n\");\n+    }\n+    out.write(\"year = {\");\n+    out.write(year);\n+    out.write(\"},\\r\\n\");\n+    out.write(\"version = {\");\n+    out.write(version);\n+    out.write(\"},\\r\\n\");\n+    out.write(\"doi = {\");\n+    out.write(persistentId.getAuthority());\n+    out.write(\"/\");\n+    out.write(persistentId.getIdentifier());\n+    out.write(\"},\\r\\n\");\n+    out.write(\"url = {\");\n+    out.write(persistentId.toURL().toString());\n+    out.write(\"}\\r\\n\");\n+    out.write(\"}\\r\\n\");\n+    out.flush();\n+  }\n+\n+  public String toRISString() {\n+    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+    try {\n+      writeAsRISCitation(buffer);\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    //Use UTF-8?\n+    return buffer.toString();\n+  }\n+\n+  public void writeAsRISCitation(OutputStream os) throws IOException {\n+    // Use UTF-8\n+    Writer out = new BufferedWriter(new OutputStreamWriter(os, \"utf-8\"));\n+    out.write(\"Provider: \" + publisher + \"\\r\\n\");\n+    out.write(\"Content: text/plain; charset=\\\"utf-8\\\"\" + \"\\r\\n\");\n+    // Using type \"DATA\" - see https://github.com/IQSS/dataverse/issues/4816\n+\n+    if ((getFileTitle() != null) && isDirect()) {\n+      out.write(\"TY  - DATA\" + \"\\r\\n\");\n+      out.write(\"T1  - \" + getFileTitle() + \"\\r\\n\");\n+      out.write(\"T2  - \" + getTitle() + \"\\r\\n\");\n+    } else {\n+      out.write(\"TY  - DATA\" + \"\\r\\n\");\n+      out.write(\"T1  - \" + getTitle() + \"\\r\\n\");\n+    }\n+    if (seriesTitle != null) {\n+      out.write(\"T3  - \" + seriesTitle + \"\\r\\n\");\n     }\n-\n-    public String toBibtexString() {\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        try {\n-            writeAsBibtexCitation(buffer);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-        //Use UTF-8?\n-        return buffer.toString();\n-    }\n-    \n-    public void writeAsBibtexCitation(OutputStream os) throws IOException {\n-        // Use UTF-8\n-        Writer out = new BufferedWriter(new OutputStreamWriter(os, \"utf-8\"));\n-        if(getFileTitle() !=null && isDirect()) {\n-            out.write(\"@incollection{\");\n-        } else {\n-            out.write(\"@data{\");\n-        }\n-        out.write(persistentId.getIdentifier() + \"_\" + year + \",\" + \"\\r\\n\");\n-        out.write(\"author = {\");\n-        out.write(String.join(\" and \", authors));\n-        out.write(\"},\\r\\n\");\n-        out.write(\"publisher = {\");\n-        out.write(publisher);\n-        out.write(\"},\\r\\n\");\n-        if(getFileTitle() !=null && isDirect()) {\n-            out.write(\"title = {\");\n-            out.write(fileTitle);\n-            out.write(\"},\\r\\n\");\n-            out.write(\"booktitle = {\");\n-            out.write(title);\n-            out.write(\"},\\r\\n\");\n-        } else {\n-            out.write(\"title = {{\");\n-            String doubleQ = \"\\\"\";\n-            String doubleTick = \"``\";\n-            String doubleAp = \"''\";\n-            out.write(title.replaceFirst(doubleQ, doubleTick).replaceFirst(doubleQ, doubleAp));\n-            out.write(\"}},\\r\\n\");\n-        }\n-        if(UNF != null){\n-            out.write(\"UNF = {\");\n-            out.write(UNF);\n-            out.write(\"},\\r\\n\");\n-        }\n-        out.write(\"year = {\");\n-        out.write(year);\n-        out.write(\"},\\r\\n\");\n-        out.write(\"version = {\");\n-        out.write(version);\n-        out.write(\"},\\r\\n\");\n-        out.write(\"doi = {\");\n-        out.write(persistentId.getAuthority());\n-        out.write(\"/\");\n-        out.write(persistentId.getIdentifier());\n-        out.write(\"},\\r\\n\");\n-        out.write(\"url = {\");\n-        out.write(persistentId.toURL().toString());\n-        out.write(\"}\\r\\n\");\n-        out.write(\"}\\r\\n\");\n-        out.flush();\n-    }\n-\n-    public String toRISString() {\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        try {\n-            writeAsRISCitation(buffer);\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-        //Use UTF-8?\n-        return buffer.toString();\n-    }\n-\n-    public void writeAsRISCitation(OutputStream os) throws IOException {\n-        // Use UTF-8\n-        Writer out = new BufferedWriter(new OutputStreamWriter(os, \"utf-8\"));\n-        out.write(\"Provider: \" + publisher + \"\\r\\n\");\n-        out.write(\"Content: text/plain; charset=\\\"utf-8\\\"\" + \"\\r\\n\");\n-        // Using type \"DATA\" - see https://github.com/IQSS/dataverse/issues/4816\n-        \n-        if ((getFileTitle()!=null)&&isDirect()) {\n-            out.write(\"TY  - DATA\" + \"\\r\\n\");\n-            out.write(\"T1  - \" + getFileTitle() + \"\\r\\n\");\n-            out.write(\"T2  - \" + getTitle() + \"\\r\\n\");\n-        } else {\n-            out.write(\"TY  - DATA\" + \"\\r\\n\");\n-            out.write(\"T1  - \" + getTitle() + \"\\r\\n\");\n-        }\n-        if (seriesTitle != null) {\n-            out.write(\"T3  - \" + seriesTitle + \"\\r\\n\");\n-        }\n         /* Removing abstract/description per Request from G. King in #3759\n         if(description!=null) {\n             out.write(\"AB  - \" + flattenHtml(description) + \"\\r\\n\");\n         } */\n-        for (String author : authors) {\n-            out.write(\"AU  - \" + author + \"\\r\\n\");\n-        }\n-        \n-        if (!producers.isEmpty()) {\n-            for (String author : producers) {\n-                out.write(\"A2  - \" + author + \"\\r\\n\");\n-            }\n-        }\n-        if (!funders.isEmpty()) {\n-            for (String author : funders) {\n-                out.write(\"A4  - \" + author + \"\\r\\n\");\n-            }\n-        }\n-        if (!kindsOfData.isEmpty()) {\n-            for (String kod : kindsOfData) {\n-                out.write(\"C3  - \" + kod + \"\\r\\n\");\n-            }\n-        }    \n-        if (!datesOfCollection.isEmpty()) {\n-            for (String dateRange : datesOfCollection) {\n-                out.write(\"DA  - \" + dateRange + \"\\r\\n\");\n-            }\n-        }\n-\n-        if (persistentId != null) {\n-            out.write(\"DO  - \" + persistentId.toString() + \"\\r\\n\");\n-        }\n-        out.write(\"ET  - \" + version + \"\\r\\n\");\n-        if (!keywords.isEmpty()) {\n-            for (String keyword : keywords) {\n-                out.write(\"KW  - \" + keyword + \"\\r\\n\");\n-            }\n-        }\n-        if (!languages.isEmpty()) {\n-            for (String lang : languages) {\n-                out.write(\"LA  - \" + lang + \"\\r\\n\");\n-            }\n-        }\n-\n-        out.write(\"PY  - \" + year + \"\\r\\n\");\n-        \n-        if (!spatialCoverages.isEmpty()) {\n-            for (String coverage : spatialCoverages) {\n-                out.write(\"RI  - \" + coverage + \"\\r\\n\");\n-            }\n-        }\n-        \n-        out.write(\"SE  - \" + date + \"\\r\\n\");\n-\n-        out.write(\"UR  - \" + persistentId.toURL().toString() + \"\\r\\n\");\n-        out.write(\"PB  - \" + publisher + \"\\r\\n\");\n-\n-        // a DataFile citation also includes filename und UNF, if applicable:\n-        if (getFileTitle() != null) {\n-            if(!isDirect()) {\n-                out.write(\"C1  - \" + getFileTitle() + \"\\r\\n\");\n-            }\n-            if (getUNF() != null) {\n-                out.write(\"C2  - \" + getUNF() + \"\\r\\n\");\n-            }\n-        }\n-        // closing element:\n-        out.write(\"ER  - \\r\\n\");\n-        out.flush();\n-    }\n-\n-    private XMLOutputFactory xmlOutputFactory = null;\n-\n-    public String toEndNoteString() {\n-        ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n-        writeAsEndNoteCitation(outStream);\n-        String xml = outStream.toString();\n-        return xml; \n-    } \n-    \n-    public void writeAsEndNoteCitation(OutputStream os) {\n-\n-        xmlOutputFactory = javax.xml.stream.XMLOutputFactory.newInstance();\n-        XMLStreamWriter xmlw = null;\n-        try {\n-            xmlw = xmlOutputFactory.createXMLStreamWriter(os);\n-            xmlw.writeStartDocument();\n-            createEndNoteXML(xmlw);\n-            xmlw.writeEndDocument();\n-        } catch (XMLStreamException ex) {\n-            Logger.getLogger(\"global\").log(Level.SEVERE, null, ex);\n-            throw new EJBException(\"ERROR occurred during creating endnote xml.\", ex);\n-        } finally {\n-            try {\n-                if (xmlw != null) {\n-                    xmlw.close();\n-                }\n-            } catch (XMLStreamException ex) {\n-            }\n-        }\n+    for (String author : authors) {\n+      out.write(\"AU  - \" + author + \"\\r\\n\");\n     }\n-    \n-    private void createEndNoteXML(XMLStreamWriter xmlw) throws XMLStreamException {\n-\n-        xmlw.writeStartElement(\"xml\");\n-        xmlw.writeStartElement(\"records\");\n-\n-        xmlw.writeStartElement(\"record\");\n-\n-        // \"Ref-type\" indicates which of the (numerous!) available EndNote\n-        // schemas this record will be interpreted as. \n-        // This is relatively important. Certain fields with generic \n-        // names like \"custom1\" and \"custom2\" become very specific things\n-        // in specific schemas; for example, custom1 shows as \"legal notice\"\n-        // in \"Journal Article\" (ref-type 84), or as \"year published\" in \n-        // \"Government Document\". \n-        // We don't want the UNF to show as a \"legal notice\"! \n-        // We have found a ref-type that works ok for our purposes - \n-        // \"Dataset\" (type 59). In this one, the fields Custom1\n-        // and Custom2 are not translated and just show as is. \n-        // And \"Custom1\" still beats \"legal notice\". \n-        // -- L.A. 12.12.2014 beta 10\n-        // and see https://github.com/IQSS/dataverse/issues/4816\n-        \n-        xmlw.writeStartElement(\"ref-type\");\n-        xmlw.writeAttribute(\"name\", \"Dataset\");\n-        xmlw.writeCharacters(\"59\");\n-        xmlw.writeEndElement(); // ref-type\n-\n-        xmlw.writeStartElement(\"contributors\");\n-        if (!authors.isEmpty()) {\n-        xmlw.writeStartElement(\"authors\");\n-        for (String author : authors) {\n-            xmlw.writeStartElement(\"author\");\n-            xmlw.writeCharacters(author);\n-            xmlw.writeEndElement(); // author                    \n-        }\n-        xmlw.writeEndElement(); // authors \n-        }\n-        if (!producers.isEmpty()) {\n-            xmlw.writeStartElement(\"secondary-authors\");\n-            for (String producer : producers) {\n-                xmlw.writeStartElement(\"author\");\n-                xmlw.writeCharacters(producer);\n-                xmlw.writeEndElement(); // author\n-            }\n-            xmlw.writeEndElement(); // secondary-authors\n-        }\n-        if (!funders.isEmpty()) {\n-            xmlw.writeStartElement(\"subsidiary-authors\");\n-            for (String funder : funders) {\n-                xmlw.writeStartElement(\"author\");\n-                xmlw.writeCharacters(funder);\n-                xmlw.writeEndElement(); // author\n-            }\n-            xmlw.writeEndElement(); // subsidiary-authors\n-        }\n-        xmlw.writeEndElement(); // contributors \n-\n-        xmlw.writeStartElement(\"titles\");\n-        if ((fileTitle != null) && isDirect()) {\n-            xmlw.writeStartElement(\"title\");\n-            xmlw.writeCharacters(fileTitle);\n-            xmlw.writeEndElement(); // title\n-            xmlw.writeStartElement(\"secondary-title\");\n-            xmlw.writeCharacters(title);\n-            xmlw.writeEndElement(); // secondary-title\n-        } else {\n-        xmlw.writeStartElement(\"title\");\n-        xmlw.writeCharacters(title);\n-        xmlw.writeEndElement(); // title\n-        }\n-        \n-        if (seriesTitle != null) {\n-            xmlw.writeStartElement(\"tertiary-title\");\n-            xmlw.writeCharacters(seriesTitle);\n-            xmlw.writeEndElement(); // tertiary-title\n-        }\n-        xmlw.writeEndElement(); // titles\n \n-        xmlw.writeStartElement(\"section\");\n-        String sectionString;\n-        sectionString = new SimpleDateFormat(\"yyyy-MM-dd\").format(date);\n-\n-        xmlw.writeCharacters(sectionString);\n-        xmlw.writeEndElement(); // section\n+    if (!producers.isEmpty()) {\n+      for (String author : producers) {\n+        out.write(\"A2  - \" + author + \"\\r\\n\");\n+      }\n+    }\n+    if (!funders.isEmpty()) {\n+      for (String author : funders) {\n+        out.write(\"A4  - \" + author + \"\\r\\n\");\n+      }\n+    }\n+    if (!kindsOfData.isEmpty()) {\n+      for (String kod : kindsOfData) {\n+        out.write(\"C3  - \" + kod + \"\\r\\n\");\n+      }\n+    }\n+    if (!datesOfCollection.isEmpty()) {\n+      for (String dateRange : datesOfCollection) {\n+        out.write(\"DA  - \" + dateRange + \"\\r\\n\");\n+      }\n+    }\n+\n+    if (persistentId != null) {\n+      out.write(\"DO  - \" + persistentId.toString() + \"\\r\\n\");\n+    }\n+    out.write(\"ET  - \" + version + \"\\r\\n\");\n+    if (!keywords.isEmpty()) {\n+      for (String keyword : keywords) {\n+        out.write(\"KW  - \" + keyword + \"\\r\\n\");\n+      }\n+    }\n+    if (!languages.isEmpty()) {\n+      for (String lang : languages) {\n+        out.write(\"LA  - \" + lang + \"\\r\\n\");\n+      }\n+    }\n+\n+    out.write(\"PY  - \" + year + \"\\r\\n\");\n+\n+    if (!spatialCoverages.isEmpty()) {\n+      for (String coverage : spatialCoverages) {\n+        out.write(\"RI  - \" + coverage + \"\\r\\n\");\n+      }\n+    }\n+\n+    out.write(\"SE  - \" + date + \"\\r\\n\");\n+\n+    out.write(\"UR  - \" + persistentId.toURL().toString() + \"\\r\\n\");\n+    out.write(\"PB  - \" + publisher + \"\\r\\n\");\n+\n+    // a DataFile citation also includes filename und UNF, if applicable:\n+    if (getFileTitle() != null) {\n+      if (!isDirect()) {\n+        out.write(\"C1  - \" + getFileTitle() + \"\\r\\n\");\n+      }\n+      if (getUNF() != null) {\n+        out.write(\"C2  - \" + getUNF() + \"\\r\\n\");\n+      }\n+    }\n+    // closing element:\n+    out.write(\"ER  - \\r\\n\");\n+    out.flush();\n+  }\n+\n+  private XMLOutputFactory xmlOutputFactory = null;\n+\n+  public String toEndNoteString() {\n+    ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n+    writeAsEndNoteCitation(outStream);\n+    String xml = outStream.toString();\n+    return xml;\n+  }\n+\n+  public void writeAsEndNoteCitation(OutputStream os) {\n+\n+    xmlOutputFactory = javax.xml.stream.XMLOutputFactory.newInstance();\n+    XMLStreamWriter xmlw = null;\n+    try {\n+      xmlw = xmlOutputFactory.createXMLStreamWriter(os);\n+      xmlw.writeStartDocument();\n+      createEndNoteXML(xmlw);\n+      xmlw.writeEndDocument();\n+    } catch (XMLStreamException ex) {\n+      Logger.getLogger(\"global\").log(Level.SEVERE, null, ex);\n+      throw new EJBException(\"ERROR occurred during creating endnote xml.\", ex);\n+    } finally {\n+      try {\n+        if (xmlw != null) {\n+          xmlw.close();\n+        }\n+      } catch (XMLStreamException ex) {\n+      }\n+    }\n+  }\n+\n+  private void createEndNoteXML(XMLStreamWriter xmlw) throws XMLStreamException {\n+\n+    xmlw.writeStartElement(\"xml\");\n+    xmlw.writeStartElement(\"records\");\n+\n+    xmlw.writeStartElement(\"record\");\n+\n+    // \"Ref-type\" indicates which of the (numerous!) available EndNote\n+    // schemas this record will be interpreted as.\n+    // This is relatively important. Certain fields with generic\n+    // names like \"custom1\" and \"custom2\" become very specific things\n+    // in specific schemas; for example, custom1 shows as \"legal notice\"\n+    // in \"Journal Article\" (ref-type 84), or as \"year published\" in\n+    // \"Government Document\".\n+    // We don't want the UNF to show as a \"legal notice\"!\n+    // We have found a ref-type that works ok for our purposes -\n+    // \"Dataset\" (type 59). In this one, the fields Custom1\n+    // and Custom2 are not translated and just show as is.\n+    // And \"Custom1\" still beats \"legal notice\".\n+    // -- L.A. 12.12.2014 beta 10\n+    // and see https://github.com/IQSS/dataverse/issues/4816\n+\n+    xmlw.writeStartElement(\"ref-type\");\n+    xmlw.writeAttribute(\"name\", \"Dataset\");\n+    xmlw.writeCharacters(\"59\");\n+    xmlw.writeEndElement(); // ref-type\n+\n+    xmlw.writeStartElement(\"contributors\");\n+    if (!authors.isEmpty()) {\n+      xmlw.writeStartElement(\"authors\");\n+      for (String author : authors) {\n+        xmlw.writeStartElement(\"author\");\n+        xmlw.writeCharacters(author);\n+        xmlw.writeEndElement(); // author\n+      }\n+      xmlw.writeEndElement(); // authors\n+    }\n+    if (!producers.isEmpty()) {\n+      xmlw.writeStartElement(\"secondary-authors\");\n+      for (String producer : producers) {\n+        xmlw.writeStartElement(\"author\");\n+        xmlw.writeCharacters(producer);\n+        xmlw.writeEndElement(); // author\n+      }\n+      xmlw.writeEndElement(); // secondary-authors\n+    }\n+    if (!funders.isEmpty()) {\n+      xmlw.writeStartElement(\"subsidiary-authors\");\n+      for (String funder : funders) {\n+        xmlw.writeStartElement(\"author\");\n+        xmlw.writeCharacters(funder);\n+        xmlw.writeEndElement(); // author\n+      }\n+      xmlw.writeEndElement(); // subsidiary-authors\n+    }\n+    xmlw.writeEndElement(); // contributors\n+\n+    xmlw.writeStartElement(\"titles\");\n+    if ((fileTitle != null) && isDirect()) {\n+      xmlw.writeStartElement(\"title\");\n+      xmlw.writeCharacters(fileTitle);\n+      xmlw.writeEndElement(); // title\n+      xmlw.writeStartElement(\"secondary-title\");\n+      xmlw.writeCharacters(title);\n+      xmlw.writeEndElement(); // secondary-title\n+    } else {\n+      xmlw.writeStartElement(\"title\");\n+      xmlw.writeCharacters(title);\n+      xmlw.writeEndElement(); // title\n+    }\n+\n+    if (seriesTitle != null) {\n+      xmlw.writeStartElement(\"tertiary-title\");\n+      xmlw.writeCharacters(seriesTitle);\n+      xmlw.writeEndElement(); // tertiary-title\n+    }\n+    xmlw.writeEndElement(); // titles\n+\n+    xmlw.writeStartElement(\"section\");\n+    String sectionString;\n+    sectionString = new SimpleDateFormat(\"yyyy-MM-dd\").format(date);\n+\n+    xmlw.writeCharacters(sectionString);\n+    xmlw.writeEndElement(); // section\n /* Removing abstract/description per Request from G. King in #3759\n         xmlw.writeStartElement(\"abstract\");\n         if(description!=null) {\n@@ -519,276 +519,277 @@ public class DataCitation {\n         xmlw.writeEndElement(); // abstract\n          */\n \n-        xmlw.writeStartElement(\"dates\");\n-        xmlw.writeStartElement(\"year\");\n-        xmlw.writeCharacters(year);\n-        xmlw.writeEndElement(); // year\n-        if (!datesOfCollection.isEmpty()) {\n-            xmlw.writeStartElement(\"pub-dates\");\n-            for (String dateRange : datesOfCollection) {\n-                xmlw.writeStartElement(\"date\");\n-                xmlw.writeCharacters(dateRange);\n-                xmlw.writeEndElement(); // date\n-            }\n-            xmlw.writeEndElement(); // pub-dates\n-        }\n-        xmlw.writeEndElement(); // dates\n-\n-        xmlw.writeStartElement(\"edition\");\n-        xmlw.writeCharacters(version);\n-        xmlw.writeEndElement(); // edition\n-\n-        if (!keywords.isEmpty()) {\n-            xmlw.writeStartElement(\"keywords\");\n-            for (String keyword : keywords) {\n-                xmlw.writeStartElement(\"keyword\");\n-                xmlw.writeCharacters(keyword);\n-                xmlw.writeEndElement(); // keyword\n-            }\n-            xmlw.writeEndElement(); // keywords\n-        }\n-        if (!kindsOfData.isEmpty()) {\n-            for (String kod : kindsOfData) {\n-                xmlw.writeStartElement(\"custom3\");\n-                xmlw.writeCharacters(kod);\n-                xmlw.writeEndElement(); // custom3\n-            }\n-        }\n-        if (!languages.isEmpty()) {\n-            for (String lang : languages) {\n-                xmlw.writeStartElement(\"language\");\n-                xmlw.writeCharacters(lang);\n-                xmlw.writeEndElement(); // language\n-            }\n-        }\n-        xmlw.writeStartElement(\"publisher\");\n-        xmlw.writeCharacters(publisher);\n-        xmlw.writeEndElement(); // publisher\n-\n-        if (!spatialCoverages.isEmpty()) {\n-            for (String coverage : spatialCoverages) {\n-                xmlw.writeStartElement(\"reviewed-item\");\n-                xmlw.writeCharacters(coverage);\n-                xmlw.writeEndElement(); // reviewed-item\n-            }\n-        }\n-\n-        xmlw.writeStartElement(\"urls\");\n-        xmlw.writeStartElement(\"related-urls\");\n-        xmlw.writeStartElement(\"url\");\n-        xmlw.writeCharacters(getPersistentId().toURL().toString());\n-        xmlw.writeEndElement(); // url\n-        xmlw.writeEndElement(); // related-urls\n-        xmlw.writeEndElement(); // urls\n-        \n-        // a DataFile citation also includes the filename and (for Tabular\n-        // files) the UNF signature, that we put into the custom1 and custom2 \n-        // fields respectively:\n-        \n-        if (getFileTitle() != null) {\n-            xmlw.writeStartElement(\"custom1\");\n-            xmlw.writeCharacters(fileTitle);\n-            xmlw.writeEndElement(); // custom1\n-            \n-                if (getUNF() != null) {\n-                    xmlw.writeStartElement(\"custom2\");\n-                    xmlw.writeCharacters(getUNF());\n-                    xmlw.writeEndElement(); // custom2\n-            }\n-        }\n-        if (persistentId != null) {\n-            xmlw.writeStartElement(\"electronic-resource-num\");\n-            String electResourceNum = persistentId.getProtocol() + \"/\" + persistentId.getAuthority() + \"/\"\n-                    + persistentId.getIdentifier();\n-            xmlw.writeCharacters(electResourceNum);\n-            xmlw.writeEndElement();\n-        }\n-        //<electronic-resource-num>10.3886/ICPSR03259.v1</electronic-resource-num>                  \n-        xmlw.writeEndElement(); // record\n-\n-        xmlw.writeEndElement(); // records\n-        xmlw.writeEndElement(); // xml\n-\n-    }\n-\n-\tpublic Map<String, String> getDataCiteMetadata() {\n-        Map<String, String> metadata = new HashMap<>();\n-        String authorString = getAuthorsString();\n-\n-        if (authorString.isEmpty()) {\n-            authorString = AbstractGlobalIdServiceBean.UNAVAILABLE;\n-    }\n-        String producerString = getPublisher();\n-\n-        if (producerString.isEmpty()) {\n-            producerString =  AbstractGlobalIdServiceBean.UNAVAILABLE;\n-        }\n-\n-        metadata.put(\"datacite.creator\", authorString);\n-        metadata.put(\"datacite.title\", getTitle());\n-        metadata.put(\"datacite.publisher\", producerString);\n-        metadata.put(\"datacite.publicationyear\", getYear());\n-        return metadata;\n-\t}\n-\n-\t\n-    // helper methods   \n-    private String formatString(String value, boolean escapeHtml) {\n-        return formatString(value, escapeHtml, \"\");\n-    }\n-\n-    private String formatString(String value, boolean escapeHtml, String wrapperFront) {\n-        return formatString(value, escapeHtml, wrapperFront, wrapperFront);\n-    }\n-\n-    private String formatString(String value, boolean escapeHtml, String wrapperStart, String wrapperEnd) {\n-        if (!StringUtils.isEmpty(value)) {\n-            return new StringBuilder(wrapperStart).append(escapeHtml ? StringEscapeUtils.escapeHtml4(value) : value)\n-                    .append(wrapperEnd).toString();\n-        }\n-        return null;\n-    }\n-\n-    private String formatURL(String text, String url, boolean html) {\n-        if (text == null) {\n-            return null;\n-        }\n-\n-        if (html && url != null) {\n-            return \"<a href=\\\"\" + url + \"\\\" target=\\\"_blank\\\">\" + StringEscapeUtils.escapeHtml4(text) + \"</a>\";\n-        } else {\n-            return text;\n-        }\n-    }\n-\n-    /** This method flattens html for the textual export formats.\n-     * It removes <b> and <i> tags, replaces <br>, <p> and headers <hX> with \n-     * line breaks, converts lists to form where items start with an indented '*  ',\n-     * and converts links to simple text showing the label and, if different, \n-     * the url in parenthesis after it. Since these operations may create\n-     * multiple line breaks, a final step limits the changes and compacts multiple \n-     * line breaks into one.  \n-     *\n-     * @param html input string\n-     * @return the flattened text output\n-     */\n-    private String flattenHtml(String html) {\n-        html = html.replaceAll(\"<[pP]>\", \"\\r\\n\");\n-        html = html.replaceAll(\"<\\\\/[pP]>\", \"\\r\\n\");\n-        html = html.replaceAll(\"<[hH]\\\\d>\", \"\\r\\n\");\n-        html = html.replaceAll(\"<\\\\/[hH]\\\\d>\", \"\\r\\n\");\n-        html = html.replaceAll(\"<[\\\\/]?[bB]>\", \"\");\n-        html = html.replaceAll(\"<[\\\\/]?[iI]>\", \"\\r\\n\");\n-        \n-        html = html.replaceAll(\"<[bB][rR][\\\\/]?>\", \"\\r\\n\");\n-        html = html.replaceAll(\"<[uU][lL]>\", \"\\r\\n\");\n-        html = html.replaceAll(\"<\\\\/[uU][lL]>\", \"\\r\\n\");\n-        html = html.replaceAll(\"<[lL][iI]>\", \"\\t*  \");\n-        html = html.replaceAll(\"<\\\\/[lL][iI]>\", \"\\r\\n\");\n-        Pattern p = Pattern.compile(\"<a\\\\W+href=\\\\\\\"(.*?)\\\\\\\".*?>(.*?)<\\\\/a>\");\n-        Matcher m = p.matcher(html);\n-        String url = null;\n-        String label = null;\n-        while(m.find()) {\n-            url = m.group(1); // this variable should contain the link URL\n-            label = m.group(2); // this variable should contain the label\n-            //display either the label or label(url)\n-            if(!url.equals(label)) {\n-                label = label + \"(\" + url +\")\";\n-            }\n-            html = html.replaceFirst(\"<a\\\\W+href=\\\\\\\"(.*?)\\\\\\\".*?>(.*?)<\\\\/a>\", label);\n-        }\n-        //Note, this does not affect single '\\n' chars originally in the text\n-        html=html.replaceAll(\"(\\\\r\\\\n?)+\", \"\\r\\n\");\n-        \n-        return html;\n-    }\n-\n-    private Date getDateFrom(DatasetVersion dsv) {\n-        Date citationDate = null;\n-        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy\");\n-        if (!dsv.getDataset().isHarvested()) {\n-            citationDate = dsv.getCitationDate();\n-            if (citationDate == null) {\n-                if (dsv.getDataset().getPublicationDate() != null) {\n-                    citationDate = dsv.getDataset().getPublicationDate();\n-                } else { // for drafts\n-                    citationDate = dsv.getLastUpdateTime();\n-                }\n-            }\n-        } else {\n-            try {\n-                citationDate= sdf.parse(dsv.getDistributionDate());\n-            } catch (ParseException ex) {\n-                // ignore\n-            } catch (Exception ex) {\n-                // ignore\n-            }\n-        }\n-        if (citationDate == null) {\n-            //As a last resort, pick the current date\n-            logger.warning(\"Unable to find citation date for datasetversion: \" + dsv.getId());\n-            citationDate = new Date();\n-        }\n-        return citationDate;\n-    }\n-\n-    private void getAuthorsAndProducersFrom(DatasetVersion dsv) {\n-\n-        dsv.getDatasetAuthors().stream().forEach((author) -> {\n-            if (!author.isEmpty()) {\n-                String an = author.getName().getDisplayValue().trim();\n-                authors.add(an);\n-            }\n-        });\n-        producers = dsv.getDatasetProducerNames();\n-    }\n-\n-    private String getPublisherFrom(DatasetVersion dsv) {\n-        if (!dsv.getDataset().isHarvested()) {\n-            return BrandingUtil.getInstallationBrandName();\n-        } else {\n-            return dsv.getDistributorName();\n-            // remove += [distributor] SEK 8-18-2016\n-        }\n-    }\n-\n-    private String getVersionFrom(DatasetVersion dsv) {\n-        String version = \"\";\n-        if (!dsv.getDataset().isHarvested()) {\n-            if (dsv.isDraft()) {\n-                version = BundleUtil.getStringFromBundle(\"draftversion\");\n-            } else if (dsv.getVersionNumber() != null) {\n-                version = \"V\" + dsv.getVersionNumber();\n-                if (dsv.isDeaccessioned()) {\n-                    version += \", \"+ BundleUtil.getStringFromBundle(\"deaccessionedversion\");\n-                }\n-            }\n-        }\n-        return version;\n-    }\n-\n-    private GlobalId getPIDFrom(DatasetVersion dsv, DvObject dv) {\n-        if (!dsv.getDataset().isHarvested()\n-                || HarvestingClient.HARVEST_STYLE_VDC.equals(dsv.getDataset().getHarvestedFrom().getHarvestStyle())\n-                || HarvestingClient.HARVEST_STYLE_ICPSR.equals(dsv.getDataset().getHarvestedFrom().getHarvestStyle())\n-                || HarvestingClient.HARVEST_STYLE_DATAVERSE\n-                        .equals(dsv.getDataset().getHarvestedFrom().getHarvestStyle())) {\n-                // creating a global id like this:\n-                // persistentId = new GlobalId(dv.getGlobalId());\n-                // you end up doing new GlobalId((New GlobalId(dv)).toString())\n-                // - doing an extra formatting-and-parsing-again\n-                // This achieves the same thing:\n-                if(!isDirect()) {\n-                if (!StringUtils.isEmpty(dsv.getDataset().getIdentifier())) {\n-                    return new GlobalId(dsv.getDataset());\n-                }\n-                } else {\n-                if (!StringUtils.isEmpty(dv.getIdentifier())) {\n-                    return new GlobalId(dv);\n-                }\n-            }\n-        }\n-        return null;\n-    }\n+    xmlw.writeStartElement(\"dates\");\n+    xmlw.writeStartElement(\"year\");\n+    xmlw.writeCharacters(year);\n+    xmlw.writeEndElement(); // year\n+    if (!datesOfCollection.isEmpty()) {\n+      xmlw.writeStartElement(\"pub-dates\");\n+      for (String dateRange : datesOfCollection) {\n+        xmlw.writeStartElement(\"date\");\n+        xmlw.writeCharacters(dateRange);\n+        xmlw.writeEndElement(); // date\n+      }\n+      xmlw.writeEndElement(); // pub-dates\n+    }\n+    xmlw.writeEndElement(); // dates\n+\n+    xmlw.writeStartElement(\"edition\");\n+    xmlw.writeCharacters(version);\n+    xmlw.writeEndElement(); // edition\n+\n+    if (!keywords.isEmpty()) {\n+      xmlw.writeStartElement(\"keywords\");\n+      for (String keyword : keywords) {\n+        xmlw.writeStartElement(\"keyword\");\n+        xmlw.writeCharacters(keyword);\n+        xmlw.writeEndElement(); // keyword\n+      }\n+      xmlw.writeEndElement(); // keywords\n+    }\n+    if (!kindsOfData.isEmpty()) {\n+      for (String kod : kindsOfData) {\n+        xmlw.writeStartElement(\"custom3\");\n+        xmlw.writeCharacters(kod);\n+        xmlw.writeEndElement(); // custom3\n+      }\n+    }\n+    if (!languages.isEmpty()) {\n+      for (String lang : languages) {\n+        xmlw.writeStartElement(\"language\");\n+        xmlw.writeCharacters(lang);\n+        xmlw.writeEndElement(); // language\n+      }\n+    }\n+    xmlw.writeStartElement(\"publisher\");\n+    xmlw.writeCharacters(publisher);\n+    xmlw.writeEndElement(); // publisher\n+\n+    if (!spatialCoverages.isEmpty()) {\n+      for (String coverage : spatialCoverages) {\n+        xmlw.writeStartElement(\"reviewed-item\");\n+        xmlw.writeCharacters(coverage);\n+        xmlw.writeEndElement(); // reviewed-item\n+      }\n+    }\n+\n+    xmlw.writeStartElement(\"urls\");\n+    xmlw.writeStartElement(\"related-urls\");\n+    xmlw.writeStartElement(\"url\");\n+    xmlw.writeCharacters(getPersistentId().toURL().toString());\n+    xmlw.writeEndElement(); // url\n+    xmlw.writeEndElement(); // related-urls\n+    xmlw.writeEndElement(); // urls\n+\n+    // a DataFile citation also includes the filename and (for Tabular\n+    // files) the UNF signature, that we put into the custom1 and custom2\n+    // fields respectively:\n+\n+    if (getFileTitle() != null) {\n+      xmlw.writeStartElement(\"custom1\");\n+      xmlw.writeCharacters(fileTitle);\n+      xmlw.writeEndElement(); // custom1\n+\n+      if (getUNF() != null) {\n+        xmlw.writeStartElement(\"custom2\");\n+        xmlw.writeCharacters(getUNF());\n+        xmlw.writeEndElement(); // custom2\n+      }\n+    }\n+    if (persistentId != null) {\n+      xmlw.writeStartElement(\"electronic-resource-num\");\n+      String electResourceNum = persistentId.getProtocol() + \"/\" + persistentId.getAuthority() + \"/\"\n+        + persistentId.getIdentifier();\n+      xmlw.writeCharacters(electResourceNum);\n+      xmlw.writeEndElement();\n+    }\n+    //<electronic-resource-num>10.3886/ICPSR03259.v1</electronic-resource-num>\n+    xmlw.writeEndElement(); // record\n+\n+    xmlw.writeEndElement(); // records\n+    xmlw.writeEndElement(); // xml\n+\n+  }\n+\n+  public Map<String, String> getDataCiteMetadata() {\n+    Map<String, String> metadata = new HashMap<>();\n+    String authorString = getAuthorsString();\n+\n+    if (authorString.isEmpty()) {\n+      authorString = AbstractGlobalIdServiceBean.UNAVAILABLE;\n+    }\n+    String producerString = getPublisher();\n+\n+    if (producerString.isEmpty()) {\n+      producerString = AbstractGlobalIdServiceBean.UNAVAILABLE;\n+    }\n+\n+    metadata.put(\"datacite.creator\", authorString);\n+    metadata.put(\"datacite.title\", getTitle());\n+    metadata.put(\"datacite.publisher\", producerString);\n+    metadata.put(\"datacite.publicationyear\", getYear());\n+    return metadata;\n+  }\n+\n+\n+  // helper methods\n+  private String formatString(String value, boolean escapeHtml) {\n+    return formatString(value, escapeHtml, \"\");\n+  }\n+\n+  private String formatString(String value, boolean escapeHtml, String wrapperFront) {\n+    return formatString(value, escapeHtml, wrapperFront, wrapperFront);\n+  }\n+\n+  private String formatString(String value, boolean escapeHtml, String wrapperStart, String wrapperEnd) {\n+    if (!StringUtils.isEmpty(value)) {\n+      return new StringBuilder(wrapperStart).append(escapeHtml ? StringEscapeUtils.escapeHtml4(value) : value)\n+        .append(wrapperEnd).toString();\n+    }\n+    return null;\n+  }\n+\n+  private String formatURL(String text, String url, boolean html) {\n+    if (text == null) {\n+      return null;\n+    }\n+\n+    if (html && url != null) {\n+      return \"<a href=\\\"\" + url + \"\\\" target=\\\"_blank\\\">\" + StringEscapeUtils.escapeHtml4(text) + \"</a>\";\n+    } else {\n+      return text;\n+    }\n+  }\n+\n+  /**\n+   * This method flattens html for the textual export formats.\n+   * It removes <b> and <i> tags, replaces <br>, <p> and headers <hX> with\n+   * line breaks, converts lists to form where items start with an indented '*  ',\n+   * and converts links to simple text showing the label and, if different,\n+   * the url in parenthesis after it. Since these operations may create\n+   * multiple line breaks, a final step limits the changes and compacts multiple\n+   * line breaks into one.\n+   *\n+   * @param html input string\n+   * @return the flattened text output\n+   */\n+  private String flattenHtml(String html) {\n+    html = html.replaceAll(\"<[pP]>\", \"\\r\\n\");\n+    html = html.replaceAll(\"<\\\\/[pP]>\", \"\\r\\n\");\n+    html = html.replaceAll(\"<[hH]\\\\d>\", \"\\r\\n\");\n+    html = html.replaceAll(\"<\\\\/[hH]\\\\d>\", \"\\r\\n\");\n+    html = html.replaceAll(\"<[\\\\/]?[bB]>\", \"\");\n+    html = html.replaceAll(\"<[\\\\/]?[iI]>\", \"\\r\\n\");\n+\n+    html = html.replaceAll(\"<[bB][rR][\\\\/]?>\", \"\\r\\n\");\n+    html = html.replaceAll(\"<[uU][lL]>\", \"\\r\\n\");\n+    html = html.replaceAll(\"<\\\\/[uU][lL]>\", \"\\r\\n\");\n+    html = html.replaceAll(\"<[lL][iI]>\", \"\\t*  \");\n+    html = html.replaceAll(\"<\\\\/[lL][iI]>\", \"\\r\\n\");\n+    Pattern p = Pattern.compile(\"<a\\\\W+href=\\\\\\\"(.*?)\\\\\\\".*?>(.*?)<\\\\/a>\");\n+    Matcher m = p.matcher(html);\n+    String url = null;\n+    String label = null;\n+    while (m.find()) {\n+      url = m.group(1); // this variable should contain the link URL\n+      label = m.group(2); // this variable should contain the label\n+      //display either the label or label(url)\n+      if (!url.equals(label)) {\n+        label = label + \"(\" + url + \")\";\n+      }\n+      html = html.replaceFirst(\"<a\\\\W+href=\\\\\\\"(.*?)\\\\\\\".*?>(.*?)<\\\\/a>\", label);\n+    }\n+    //Note, this does not affect single '\\n' chars originally in the text\n+    html = html.replaceAll(\"(\\\\r\\\\n?)+\", \"\\r\\n\");\n+\n+    return html;\n+  }\n+\n+  private Date getDateFrom(DatasetVersion dsv) {\n+    Date citationDate = null;\n+    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy\");\n+    if (!dsv.getDataset().isHarvested()) {\n+      citationDate = dsv.getCitationDate();\n+      if (citationDate == null) {\n+        if (dsv.getDataset().getPublicationDate() != null) {\n+          citationDate = dsv.getDataset().getPublicationDate();\n+        } else { // for drafts\n+          citationDate = dsv.getLastUpdateTime();\n+        }\n+      }\n+    } else {\n+      try {\n+        citationDate = sdf.parse(dsv.getDistributionDate());\n+      } catch (ParseException ex) {\n+        // ignore\n+      } catch (Exception ex) {\n+        // ignore\n+      }\n+    }\n+    if (citationDate == null) {\n+      //As a last resort, pick the current date\n+      logger.warning(\"Unable to find citation date for datasetversion: \" + dsv.getId());\n+      citationDate = new Date();\n+    }\n+    return citationDate;\n+  }\n+\n+  private void getAuthorsAndProducersFrom(DatasetVersion dsv) {\n+\n+    dsv.getDatasetAuthors().stream().forEach((author) -> {\n+      if (!author.isEmpty()) {\n+        String an = author.getName().getDisplayValue().trim();\n+        authors.add(an);\n+      }\n+    });\n+    producers = dsv.getDatasetProducerNames();\n+  }\n+\n+  private String getPublisherFrom(DatasetVersion dsv) {\n+    if (!dsv.getDataset().isHarvested()) {\n+      return BrandingUtil.getInstallationBrandName();\n+    } else {\n+      return dsv.getDistributorName();\n+      // remove += [distributor] SEK 8-18-2016\n+    }\n+  }\n+\n+  private String getVersionFrom(DatasetVersion dsv) {\n+    String version = \"\";\n+    if (!dsv.getDataset().isHarvested()) {\n+      if (dsv.isDraft()) {\n+        version = BundleUtil.getStringFromBundle(\"draftversion\");\n+      } else if (dsv.getVersionNumber() != null) {\n+        version = \"V\" + dsv.getVersionNumber();\n+        if (dsv.isDeaccessioned()) {\n+          version += \", \" + BundleUtil.getStringFromBundle(\"deaccessionedversion\");\n+        }\n+      }\n+    }\n+    return version;\n+  }\n+\n+  private GlobalId getPIDFrom(DatasetVersion dsv, DvObject dv) {\n+    if (!dsv.getDataset().isHarvested()\n+      || HarvestingClient.HARVEST_STYLE_VDC.equals(dsv.getDataset().getHarvestedFrom().getHarvestStyle())\n+      || HarvestingClient.HARVEST_STYLE_ICPSR.equals(dsv.getDataset().getHarvestedFrom().getHarvestStyle())\n+      || HarvestingClient.HARVEST_STYLE_DATAVERSE\n+      .equals(dsv.getDataset().getHarvestedFrom().getHarvestStyle())) {\n+      // creating a global id like this:\n+      // persistentId = new GlobalId(dv.getGlobalId());\n+      // you end up doing new GlobalId((New GlobalId(dv)).toString())\n+      // - doing an extra formatting-and-parsing-again\n+      // This achieves the same thing:\n+      if (!isDirect()) {\n+        if (!StringUtils.isEmpty(dsv.getDataset().getIdentifier())) {\n+          return new GlobalId(dsv.getDataset());\n+        }\n+      } else {\n+        if (!StringUtils.isEmpty(dv.getIdentifier())) {\n+          return new GlobalId(dv);\n+        }\n+      }\n+    }\n+    return null;\n+  }\n }\n",
            "diff_size": 1124
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "614",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/11/DataCitation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/11/DataCitation.java\nindex 4dcfbc035a5..9b0f41cca9e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/11/DataCitation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/11/DataCitation.java\n@@ -198,8 +198,8 @@ public class DataCitation {\n         }\n \n         if (persistentId != null) {\n-        \t// always show url format\n-            citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html)); \n+        // always show url format citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html));\n+     citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html)); \n         }\n         citationList.add(formatString(publisher, html));\n         citationList.add(version);\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "614",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/11/DataCitation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/11/DataCitation.java\nindex 4dcfbc035a5..77df14344c6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/11/DataCitation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/11/DataCitation.java\n@@ -198,8 +198,8 @@ public class DataCitation {\n         }\n \n         if (persistentId != null) {\n-        \t// always show url format\n-            citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html)); \n+            // always show url format\n+        citationList.add(formatURL(persistentId.toURL().toString(), persistentId.toURL().toString(), html)); \n         }\n         citationList.add(formatString(publisher, html));\n         citationList.add(version);\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}