{
    "project_name": "codefollower-H2-Research",
    "error_id": "241",
    "information": {
        "errors": [
            {
                "line": "129",
                "column": "26",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                } else if (clientVersion <= Constants.TCP_PROTOCOL_VERSION_15) {\n                    hasSynonyms = false;\n                } else { // 1.4.194-1.4.196\n                    CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n                    ResultInterface result = c.executeQuery(0, false);\n                    result.next();",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/241/JdbcDatabaseMetaData.java\nindex 693383340bd..73fd2a9d3ef 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/241/JdbcDatabaseMetaData.java\n@@ -126,8 +126,9 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n                     hasSynonyms = true;\n                 } else if (clientVersion <= Constants.TCP_PROTOCOL_VERSION_15) {\n                     hasSynonyms = false;\n-                } else { // 1.4.194-1.4.196\n-                    CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n+                } else {\n+                    // 1.4.194-1.4.196\n+                CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n                     ResultInterface result = c.executeQuery(0, false);\n                     result.next();\n                     String s = result.currentRow()[0].getString();\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "130",
                    "column": "18",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/241/JdbcDatabaseMetaData.java\nindex 693383340bd..f788138ff4b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/241/JdbcDatabaseMetaData.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.jdbc;\n \n import java.sql.Connection;\n@@ -32,3259 +33,3260 @@ import org.h2.util.StringUtils;\n  * Represents the meta data for a database.\n  */\n public class JdbcDatabaseMetaData extends TraceObject implements\n-        DatabaseMetaData, JdbcDatabaseMetaDataBackwardsCompat {\n-\n-    private final JdbcConnection conn;\n-\n-    /**\n-     * Whether database has support for synonyms ({@code null} if not yet known).\n-     */\n-    private Boolean hasSynonyms;\n-\n-    JdbcDatabaseMetaData(JdbcConnection conn, Trace trace, int id) {\n-        setTrace(trace, TraceObject.DATABASE_META_DATA, id);\n-        this.conn = conn;\n-    }\n-\n-    /**\n-     * Returns the major version of this driver.\n-     *\n-     * @return the major version number\n-     */\n-    @Override\n-    public int getDriverMajorVersion() {\n-        debugCodeCall(\"getDriverMajorVersion\");\n-        return Constants.VERSION_MAJOR;\n-    }\n-\n-    /**\n-     * Returns the minor version of this driver.\n-     *\n-     * @return the minor version number\n-     */\n-    @Override\n-    public int getDriverMinorVersion() {\n-        debugCodeCall(\"getDriverMinorVersion\");\n-        return Constants.VERSION_MINOR;\n-    }\n-\n-    /**\n-     * Gets the database product name.\n-     *\n-     * @return the product name (\"H2\")\n-     */\n-    @Override\n-    public String getDatabaseProductName() {\n-        debugCodeCall(\"getDatabaseProductName\");\n-        // This value must stay like that, see\n-        // http://opensource.atlassian.com/projects/hibernate/browse/HHH-2682\n-        return \"H2\";\n-    }\n-\n-    /**\n-     * Gets the product version of the database.\n-     *\n-     * @return the product version\n-     */\n-    @Override\n-    public String getDatabaseProductVersion() {\n-        debugCodeCall(\"getDatabaseProductVersion\");\n-        return Constants.getFullVersion();\n-    }\n-\n-    /**\n-     * Gets the name of the JDBC driver.\n-     *\n-     * @return the driver name (\"H2 JDBC Driver\")\n-     */\n-    @Override\n-    public String getDriverName() {\n-        debugCodeCall(\"getDriverName\");\n-        return \"H2 JDBC Driver\";\n-    }\n-\n-    /**\n-     * Gets the version number of the driver. The format is\n-     * [MajorVersion].[MinorVersion].\n-     *\n-     * @return the version number\n-     */\n-    @Override\n-    public String getDriverVersion() {\n-        debugCodeCall(\"getDriverVersion\");\n-        return Constants.getFullVersion();\n-    }\n-\n-    private boolean hasSynonyms() {\n-        Boolean hasSynonyms = this.hasSynonyms;\n-        if (hasSynonyms == null) {\n-            SessionInterface si = conn.getSession();\n-            if (si instanceof SessionRemote) {\n-                SessionRemote sr = (SessionRemote) si;\n-                int clientVersion = sr.getClientVersion();\n-                if (clientVersion >= Constants.TCP_PROTOCOL_VERSION_17) {\n-                    hasSynonyms = true;\n-                } else if (clientVersion <= Constants.TCP_PROTOCOL_VERSION_15) {\n-                    hasSynonyms = false;\n-                } else { // 1.4.194-1.4.196\n-                    CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n-                    ResultInterface result = c.executeQuery(0, false);\n-                    result.next();\n-                    String s = result.currentRow()[0].getString();\n-                    result.close();\n-                    hasSynonyms = \"1.4.196\".equals(s);\n-                }\n-            } else {\n-                hasSynonyms = true;\n-            }\n-            this.hasSynonyms = hasSynonyms;\n-        }\n-        return hasSynonyms;\n-    }\n-\n-    /**\n-     * Gets the list of tables in the database. The result set is sorted by\n-     * TABLE_TYPE, TABLE_SCHEM, and TABLE_NAME.\n-     *\n-     * <ul>\n-     * <li>1 TABLE_CAT (String) table catalog </li>\n-     * <li>2 TABLE_SCHEM (String) table schema </li>\n-     * <li>3 TABLE_NAME (String) table name </li>\n-     * <li>4 TABLE_TYPE (String) table type </li>\n-     * <li>5 REMARKS (String) comment </li>\n-     * <li>6 TYPE_CAT (String) always null </li>\n-     * <li>7 TYPE_SCHEM (String) always null </li>\n-     * <li>8 TYPE_NAME (String) always null </li>\n-     * <li>9 SELF_REFERENCING_COL_NAME (String) always null </li>\n-     * <li>10 REF_GENERATION (String) always null </li>\n-     * <li>11 SQL (String) the create table statement or NULL for systems tables\n-     * </li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null (to get all objects) or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param tableNamePattern null (to get all objects) or a table name\n-     *            (uppercase for unquoted names)\n-     * @param types null or a list of table types\n-     * @return the list of columns\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getTables(String catalogPattern, String schemaPattern,\n-            String tableNamePattern, String[] types) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getTables(\" + quote(catalogPattern) + \", \" +\n-                        quote(schemaPattern) + \", \" + quote(tableNamePattern) +\n-                        \", \" + quoteArray(types) + \");\");\n-            }\n-            checkClosed();\n-            int typesLength = types != null ? types.length : 0;\n-            boolean includeSynonyms = hasSynonyms() && (types == null || Arrays.asList(types).contains(\"SYNONYM\"));\n-\n-            // (1024 - 16) is enough for the most cases\n-            StringBuilder select = new StringBuilder(1008);\n-            if (includeSynonyms) {\n-                select.append(\"SELECT \"\n-                        + \"TABLE_CAT, \"\n-                        + \"TABLE_SCHEM, \"\n-                        + \"TABLE_NAME, \"\n-                        + \"TABLE_TYPE, \"\n-                        + \"REMARKS, \"\n-                        + \"TYPE_CAT, \"\n-                        + \"TYPE_SCHEM, \"\n-                        + \"TYPE_NAME, \"\n-                        + \"SELF_REFERENCING_COL_NAME, \"\n-                        + \"REF_GENERATION, \"\n-                        + \"SQL \"\n-                        + \"FROM (\"\n-                        + \"SELECT \"\n-                        + \"SYNONYM_CATALOG TABLE_CAT, \"\n-                        + \"SYNONYM_SCHEMA TABLE_SCHEM, \"\n-                        + \"SYNONYM_NAME as TABLE_NAME, \"\n-                        + \"TYPE_NAME AS TABLE_TYPE, \"\n-                        + \"REMARKS, \"\n-                        + \"TYPE_NAME TYPE_CAT, \"\n-                        + \"TYPE_NAME TYPE_SCHEM, \"\n-                        + \"TYPE_NAME AS TYPE_NAME, \"\n-                        + \"TYPE_NAME SELF_REFERENCING_COL_NAME, \"\n-                        + \"TYPE_NAME REF_GENERATION, \"\n-                        + \"NULL AS SQL \"\n-                        + \"FROM INFORMATION_SCHEMA.SYNONYMS \"\n-                        + \"WHERE SYNONYM_CATALOG LIKE ?1 ESCAPE ?4 \"\n-                        + \"AND SYNONYM_SCHEMA LIKE ?2 ESCAPE ?4 \"\n-                        + \"AND SYNONYM_NAME LIKE ?3 ESCAPE ?4 \"\n-                        + \"UNION \");\n-            }\n-            select.append(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"TABLE_TYPE, \"\n-                    + \"REMARKS, \"\n-                    + \"TYPE_NAME TYPE_CAT, \"\n-                    + \"TYPE_NAME TYPE_SCHEM, \"\n-                    + \"TYPE_NAME, \"\n-                    + \"TYPE_NAME SELF_REFERENCING_COL_NAME, \"\n-                    + \"TYPE_NAME REF_GENERATION, \"\n-                    + \"SQL \"\n-                    + \"FROM INFORMATION_SCHEMA.TABLES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ?1 ESCAPE ?4 \"\n-                    + \"AND TABLE_SCHEMA LIKE ?2 ESCAPE ?4 \"\n-                    + \"AND TABLE_NAME LIKE ?3 ESCAPE ?4\");\n-            if (typesLength > 0) {\n-                select.append(\" AND TABLE_TYPE IN(\");\n-                for (int i = 0; i < typesLength; i++) {\n-                    if (i > 0) {\n-                        select.append(\", \");\n-                    }\n-                    select.append('?').append(i + 5);\n-                }\n-                select.append(')');\n-            }\n-            if (includeSynonyms) {\n-                select.append(')');\n-            }\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\n-                    select.append(\" ORDER BY TABLE_TYPE, TABLE_SCHEM, TABLE_NAME\").toString());\n-            prep.setString(1, getCatalogPattern(catalogPattern));\n-            prep.setString(2, getSchemaPattern(schemaPattern));\n-            prep.setString(3, getPattern(tableNamePattern));\n-            prep.setString(4, \"\\\\\");\n-            for (int i = 0; i < typesLength; i++) {\n-                prep.setString(5 + i, types[i]);\n-            }\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of columns. The result set is sorted by TABLE_SCHEM,\n-     * TABLE_NAME, and ORDINAL_POSITION.\n-     *\n-     * <ul>\n-     * <li>1 TABLE_CAT (String) table catalog </li>\n-     * <li>2 TABLE_SCHEM (String) table schema </li>\n-     * <li>3 TABLE_NAME (String) table name </li>\n-     * <li>4 COLUMN_NAME (String) column name </li>\n-     * <li>5 DATA_TYPE (short) data type (see java.sql.Types) </li>\n-     * <li>6 TYPE_NAME (String) data type name (\"INTEGER\", \"VARCHAR\",...) </li>\n-     * <li>7 COLUMN_SIZE (int) precision\n-     *         (values larger than 2 GB are returned as 2 GB)</li>\n-     * <li>8 BUFFER_LENGTH (int) unused </li>\n-     * <li>9 DECIMAL_DIGITS (int) scale (0 for INTEGER and VARCHAR) </li>\n-     * <li>10 NUM_PREC_RADIX (int) radix (always 10) </li>\n-     * <li>11 NULLABLE (int) columnNoNulls or columnNullable</li>\n-     * <li>12 REMARKS (String) comment (always empty) </li>\n-     * <li>13 COLUMN_DEF (String) default value </li>\n-     * <li>14 SQL_DATA_TYPE (int) unused </li>\n-     * <li>15 SQL_DATETIME_SUB (int) unused </li>\n-     * <li>16 CHAR_OCTET_LENGTH (int) unused </li>\n-     * <li>17 ORDINAL_POSITION (int) the column index (1,2,...) </li>\n-     * <li>18 IS_NULLABLE (String) \"NO\" or \"YES\" </li>\n-     * <li>19 SCOPE_CATALOG (String) always null </li>\n-     * <li>20 SCOPE_SCHEMA (String) always null </li>\n-     * <li>21 SCOPE_TABLE (String) always null </li>\n-     * <li>22 SOURCE_DATA_TYPE (short) null </li>\n-     * <li>23 IS_AUTOINCREMENT (String) \"NO\" or \"YES\" </li>\n-     * <li>24 SCOPE_CATLOG (String) always null (the typo is on purpose,\n-     * for compatibility with the JDBC specification prior to 4.1)</li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null (to get all objects) or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param tableNamePattern null (to get all objects) or a table name\n-     *            (uppercase for unquoted names)\n-     * @param columnNamePattern null (to get all objects) or a column name\n-     *            (uppercase for unquoted names)\n-     * @return the list of columns\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getColumns(String catalogPattern, String schemaPattern,\n-            String tableNamePattern, String columnNamePattern)\n-            throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getColumns(\" + quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableNamePattern)+\", \"\n-                        +quote(columnNamePattern)+\");\");\n-            }\n-            checkClosed();\n-            boolean includeSynonyms = hasSynonyms();\n-\n-            StringBuilder select = new StringBuilder(2432);\n-            if (includeSynonyms) {\n-                select.append(\"SELECT \"\n-                        + \"TABLE_CAT, \"\n-                        + \"TABLE_SCHEM, \"\n-                        + \"TABLE_NAME, \"\n-                        + \"COLUMN_NAME, \"\n-                        + \"DATA_TYPE, \"\n-                        + \"TYPE_NAME, \"\n-                        + \"COLUMN_SIZE, \"\n-                        + \"BUFFER_LENGTH, \"\n-                        + \"DECIMAL_DIGITS, \"\n-                        + \"NUM_PREC_RADIX, \"\n-                        + \"NULLABLE, \"\n-                        + \"REMARKS, \"\n-                        + \"COLUMN_DEF, \"\n-                        + \"SQL_DATA_TYPE, \"\n-                        + \"SQL_DATETIME_SUB, \"\n-                        + \"CHAR_OCTET_LENGTH, \"\n-                        + \"ORDINAL_POSITION, \"\n-                        + \"IS_NULLABLE, \"\n-                        + \"SCOPE_CATALOG, \"\n-                        + \"SCOPE_SCHEMA, \"\n-                        + \"SCOPE_TABLE, \"\n-                        + \"SOURCE_DATA_TYPE, \"\n-                        + \"IS_AUTOINCREMENT, \"\n-                        + \"SCOPE_CATLOG \"\n-                        + \"FROM (\"\n-                        + \"SELECT \"\n-                        + \"s.SYNONYM_CATALOG TABLE_CAT, \"\n-                        + \"s.SYNONYM_SCHEMA TABLE_SCHEM, \"\n-                        + \"s.SYNONYM_NAME TABLE_NAME, \"\n-                        + \"c.COLUMN_NAME, \"\n-                        + \"c.DATA_TYPE, \"\n-                        + \"c.TYPE_NAME, \"\n-                        + \"c.CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n-                        + \"c.CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n-                        + \"c.NUMERIC_SCALE DECIMAL_DIGITS, \"\n-                        + \"c.NUMERIC_PRECISION_RADIX NUM_PREC_RADIX, \"\n-                        + \"c.NULLABLE, \"\n-                        + \"c.REMARKS, \"\n-                        + \"c.COLUMN_DEFAULT COLUMN_DEF, \"\n-                        + \"c.DATA_TYPE SQL_DATA_TYPE, \"\n-                        + \"ZERO() SQL_DATETIME_SUB, \"\n-                        + \"c.CHARACTER_OCTET_LENGTH CHAR_OCTET_LENGTH, \"\n-                        + \"c.ORDINAL_POSITION, \"\n-                        + \"c.IS_NULLABLE IS_NULLABLE, \"\n-                        + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATALOG, \"\n-                        + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_SCHEMA, \"\n-                        + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_TABLE, \"\n-                        + \"c.SOURCE_DATA_TYPE, \"\n-                        + \"CASE WHEN c.SEQUENCE_NAME IS NULL THEN \"\n-                        + \"CAST(?1 AS VARCHAR) ELSE CAST(?2 AS VARCHAR) END IS_AUTOINCREMENT, \"\n-                        + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATLOG \"\n-                        + \"FROM INFORMATION_SCHEMA.COLUMNS c JOIN INFORMATION_SCHEMA.SYNONYMS s ON \"\n-                        + \"s.SYNONYM_FOR = c.TABLE_NAME \"\n-                        + \"AND s.SYNONYM_FOR_SCHEMA = c.TABLE_SCHEMA \"\n-                        + \"WHERE s.SYNONYM_CATALOG LIKE ?3 ESCAPE ?7 \"\n-                        + \"AND s.SYNONYM_SCHEMA LIKE ?4 ESCAPE ?7 \"\n-                        + \"AND s.SYNONYM_NAME LIKE ?5 ESCAPE ?7 \"\n-                        + \"AND c.COLUMN_NAME LIKE ?6 ESCAPE ?7 \"\n-                        + \"UNION \");\n-            }\n-            select.append(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"DATA_TYPE, \"\n-                    + \"TYPE_NAME, \"\n-                    + \"CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n-                    + \"CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n-                    + \"NUMERIC_SCALE DECIMAL_DIGITS, \"\n-                    + \"NUMERIC_PRECISION_RADIX NUM_PREC_RADIX, \"\n-                    + \"NULLABLE, \"\n-                    + \"REMARKS, \"\n-                    + \"COLUMN_DEFAULT COLUMN_DEF, \"\n-                    + \"DATA_TYPE SQL_DATA_TYPE, \"\n-                    + \"ZERO() SQL_DATETIME_SUB, \"\n-                    + \"CHARACTER_OCTET_LENGTH CHAR_OCTET_LENGTH, \"\n-                    + \"ORDINAL_POSITION, \"\n-                    + \"IS_NULLABLE IS_NULLABLE, \"\n-                    + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATALOG, \"\n-                    + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_SCHEMA, \"\n-                    + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_TABLE, \"\n-                    + \"SOURCE_DATA_TYPE, \"\n-                    + \"CASE WHEN SEQUENCE_NAME IS NULL THEN \"\n-                    + \"CAST(?1 AS VARCHAR) ELSE CAST(?2 AS VARCHAR) END IS_AUTOINCREMENT, \"\n-                    + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATLOG \"\n-                    + \"FROM INFORMATION_SCHEMA.COLUMNS \"\n-                    + \"WHERE TABLE_CATALOG LIKE ?3 ESCAPE ?7 \"\n-                    + \"AND TABLE_SCHEMA LIKE ?4 ESCAPE ?7 \"\n-                    + \"AND TABLE_NAME LIKE ?5 ESCAPE ?7 \"\n-                    + \"AND COLUMN_NAME LIKE ?6 ESCAPE ?7\");\n-            if (includeSynonyms) {\n-                select.append(')');\n-            }\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\n-                    select.append(\" ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION\").toString());\n-            prep.setString(1, \"NO\");\n-            prep.setString(2, \"YES\");\n-            prep.setString(3, getCatalogPattern(catalogPattern));\n-            prep.setString(4, getSchemaPattern(schemaPattern));\n-            prep.setString(5, getPattern(tableNamePattern));\n-            prep.setString(6, getPattern(columnNamePattern));\n-            prep.setString(7, \"\\\\\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of indexes for this database. The primary key index (if\n-     * there is one) is also listed, with the name PRIMARY_KEY. The result set\n-     * is sorted by NON_UNIQUE ('false' first), TYPE, TABLE_SCHEM, INDEX_NAME,\n-     * and ORDINAL_POSITION.\n-     *\n-     * <ul>\n-     * <li>1 TABLE_CAT (String) table catalog </li>\n-     * <li>2 TABLE_SCHEM (String) table schema </li>\n-     * <li>3 TABLE_NAME (String) table name </li>\n-     * <li>4 NON_UNIQUE (boolean) 'true' if non-unique</li>\n-     * <li>5 INDEX_QUALIFIER (String) index catalog </li>\n-     * <li>6 INDEX_NAME (String) index name </li>\n-     * <li>7 TYPE (short) the index type (always tableIndexOther) </li>\n-     * <li>8 ORDINAL_POSITION (short) column index (1, 2, ...) </li>\n-     * <li>9 COLUMN_NAME (String) column name </li>\n-     * <li>10 ASC_OR_DESC (String) ascending or descending (always 'A') </li>\n-     * <li>11 CARDINALITY (int) numbers of unique values </li>\n-     * <li>12 PAGES (int) number of pages use (always 0) </li>\n-     * <li>13 FILTER_CONDITION (String) filter condition (always empty) </li>\n-     * <li>14 SORT_TYPE (int) the sort type bit map: 1=DESCENDING,\n-     * 2=NULLS_FIRST, 4=NULLS_LAST </li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param tableName table name (must be specified)\n-     * @param unique only unique indexes\n-     * @param approximate is ignored\n-     * @return the list of indexes and columns\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getIndexInfo(String catalogPattern, String schemaPattern,\n-            String tableName, boolean unique, boolean approximate)\n-            throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getIndexInfo(\" + quote(catalogPattern) + \", \" +\n-                        quote(schemaPattern) + \", \" + quote(tableName) + \", \" +\n-                        unique + \", \" + approximate + \");\");\n-            }\n-            String uniqueCondition;\n-            if (unique) {\n-                uniqueCondition = \"NON_UNIQUE=FALSE\";\n-            } else {\n-                uniqueCondition = \"TRUE\";\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"NON_UNIQUE, \"\n-                    + \"TABLE_CATALOG INDEX_QUALIFIER, \"\n-                    + \"INDEX_NAME, \"\n-                    + \"INDEX_TYPE TYPE, \"\n-                    + \"ORDINAL_POSITION, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"ASC_OR_DESC, \"\n-                    // TODO meta data for number of unique values in an index\n-                    + \"CARDINALITY, \"\n-                    + \"PAGES, \"\n-                    + \"FILTER_CONDITION, \"\n-                    + \"SORT_TYPE \"\n-                    + \"FROM INFORMATION_SCHEMA.INDEXES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND (\" + uniqueCondition + \") \"\n-                    + \"AND TABLE_NAME = ? \"\n-                    + \"ORDER BY NON_UNIQUE, TYPE, TABLE_SCHEM, INDEX_NAME, ORDINAL_POSITION\");\n-            prep.setString(1, getCatalogPattern(catalogPattern));\n-            prep.setString(2, \"\\\\\");\n-            prep.setString(3, getSchemaPattern(schemaPattern));\n-            prep.setString(4, \"\\\\\");\n-            prep.setString(5, tableName);\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the primary key columns for a table. The result set is sorted by\n-     * TABLE_SCHEM, and COLUMN_NAME (and not by KEY_SEQ).\n-     *\n-     * <ul>\n-     * <li>1 TABLE_CAT (String) table catalog</li>\n-     * <li>2 TABLE_SCHEM (String) table schema</li>\n-     * <li>3 TABLE_NAME (String) table name</li>\n-     * <li>4 COLUMN_NAME (String) column name</li>\n-     * <li>5 KEY_SEQ (short) the column index of this column (1,2,...)</li>\n-     * <li>6 PK_NAME (String) the name of the primary key index</li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param tableName table name (must be specified)\n-     * @return the list of primary key columns\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getPrimaryKeys(String catalogPattern,\n-            String schemaPattern, String tableName) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getPrimaryKeys(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableName)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"ORDINAL_POSITION KEY_SEQ, \"\n-                    + \"IFNULL(CONSTRAINT_NAME, INDEX_NAME) PK_NAME \"\n-                    + \"FROM INFORMATION_SCHEMA.INDEXES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_NAME = ? \"\n-                    + \"AND PRIMARY_KEY = TRUE \"\n-                    + \"ORDER BY COLUMN_NAME\");\n-            prep.setString(1, getCatalogPattern(catalogPattern));\n-            prep.setString(2, \"\\\\\");\n-            prep.setString(3, getSchemaPattern(schemaPattern));\n-            prep.setString(4, \"\\\\\");\n-            prep.setString(5, tableName);\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Checks if all procedures callable.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean allProceduresAreCallable() {\n-        debugCodeCall(\"allProceduresAreCallable\");\n-        return true;\n-    }\n-\n-    /**\n-     * Checks if it possible to query all tables returned by getTables.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean allTablesAreSelectable() {\n-        debugCodeCall(\"allTablesAreSelectable\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns the database URL for this connection.\n-     *\n-     * @return the url\n-     */\n-    @Override\n-    public String getURL() throws SQLException {\n-        try {\n-            debugCodeCall(\"getURL\");\n-            return conn.getURL();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Returns the user name as passed to DriverManager.getConnection(url, user,\n-     * password).\n-     *\n-     * @return the user name\n-     */\n-    @Override\n-    public String getUserName() throws SQLException {\n-        try {\n-            debugCodeCall(\"getUserName\");\n-            return conn.getUser();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Returns the same as Connection.isReadOnly().\n-     *\n-     * @return if read only optimization is switched on\n-     */\n-    @Override\n-    public boolean isReadOnly() throws SQLException {\n-        try {\n-            debugCodeCall(\"isReadOnly\");\n-            return conn.isReadOnly();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Checks if NULL is sorted high (bigger than anything that is not null).\n-     *\n-     * @return false by default; true if the system property h2.sortNullsHigh is\n-     *         set to true\n-     */\n-    @Override\n-    public boolean nullsAreSortedHigh() {\n-        debugCodeCall(\"nullsAreSortedHigh\");\n-        return SysProperties.SORT_NULLS_HIGH;\n-    }\n-\n-    /**\n-     * Checks if NULL is sorted low (smaller than anything that is not null).\n-     *\n-     * @return true by default; false if the system property h2.sortNullsHigh is\n-     *         set to true\n-     */\n-    @Override\n-    public boolean nullsAreSortedLow() {\n-        debugCodeCall(\"nullsAreSortedLow\");\n-        return !SysProperties.SORT_NULLS_HIGH;\n-    }\n-\n-    /**\n-     * Checks if NULL is sorted at the beginning (no matter if ASC or DESC is\n-     * used).\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean nullsAreSortedAtStart() {\n-        debugCodeCall(\"nullsAreSortedAtStart\");\n-        return false;\n-    }\n-\n-    /**\n-     * Checks if NULL is sorted at the end (no matter if ASC or DESC is used).\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean nullsAreSortedAtEnd() {\n-        debugCodeCall(\"nullsAreSortedAtEnd\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns the connection that created this object.\n-     *\n-     * @return the connection\n-     */\n-    @Override\n-    public Connection getConnection() {\n-        debugCodeCall(\"getConnection\");\n-        return conn;\n-    }\n-\n-    /**\n-     * Gets the list of procedures. The result set is sorted by PROCEDURE_SCHEM,\n-     * PROCEDURE_NAME, and NUM_INPUT_PARAMS. There are potentially multiple\n-     * procedures with the same name, each with a different number of input\n-     * parameters.\n-     *\n-     * <ul>\n-     * <li>1 PROCEDURE_CAT (String) catalog </li>\n-     * <li>2 PROCEDURE_SCHEM (String) schema </li>\n-     * <li>3 PROCEDURE_NAME (String) name </li>\n-     * <li>4 NUM_INPUT_PARAMS (int) the number of arguments </li>\n-     * <li>5 NUM_OUTPUT_PARAMS (int) for future use, always 0 </li>\n-     * <li>6 NUM_RESULT_SETS (int) for future use, always 0 </li>\n-     * <li>7 REMARKS (String) description </li>\n-     * <li>8 PROCEDURE_TYPE (short) if this procedure returns a result\n-     * (procedureNoResult or procedureReturnsResult) </li>\n-     * <li>9 SPECIFIC_NAME (String) name </li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param procedureNamePattern the procedure name pattern\n-     * @return the procedures\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getProcedures(String catalogPattern, String schemaPattern,\n-            String procedureNamePattern) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getProcedures(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(procedureNamePattern)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"ALIAS_CATALOG PROCEDURE_CAT, \"\n-                    + \"ALIAS_SCHEMA PROCEDURE_SCHEM, \"\n-                    + \"ALIAS_NAME PROCEDURE_NAME, \"\n-                    + \"COLUMN_COUNT NUM_INPUT_PARAMS, \"\n-                    + \"ZERO() NUM_OUTPUT_PARAMS, \"\n-                    + \"ZERO() NUM_RESULT_SETS, \"\n-                    + \"REMARKS, \"\n-                    + \"RETURNS_RESULT PROCEDURE_TYPE, \"\n-                    + \"ALIAS_NAME SPECIFIC_NAME \"\n-                    + \"FROM INFORMATION_SCHEMA.FUNCTION_ALIASES \"\n-                    + \"WHERE ALIAS_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND ALIAS_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND ALIAS_NAME LIKE ? ESCAPE ? \"\n-                    + \"ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, NUM_INPUT_PARAMS\");\n-            prep.setString(1, getCatalogPattern(catalogPattern));\n-            prep.setString(2, \"\\\\\");\n-            prep.setString(3, getSchemaPattern(schemaPattern));\n-            prep.setString(4, \"\\\\\");\n-            prep.setString(5, getPattern(procedureNamePattern));\n-            prep.setString(6, \"\\\\\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of procedure columns. The result set is sorted by\n-     * PROCEDURE_SCHEM, PROCEDURE_NAME, NUM_INPUT_PARAMS, and POS.\n-     * There are potentially multiple procedures with the same name, each with a\n-     * different number of input parameters.\n-     *\n-     * <ul>\n-     * <li>1 PROCEDURE_CAT (String) catalog </li>\n-     * <li>2 PROCEDURE_SCHEM (String) schema </li>\n-     * <li>3 PROCEDURE_NAME (String) name </li>\n-     * <li>4 COLUMN_NAME (String) column name </li>\n-     * <li>5 COLUMN_TYPE (short) column type\n-     * (always DatabaseMetaData.procedureColumnIn)</li>\n-     * <li>6 DATA_TYPE (short) sql type </li>\n-     * <li>7 TYPE_NAME (String) type name </li>\n-     * <li>8 PRECISION (int) precision </li>\n-     * <li>9 LENGTH (int) length </li>\n-     * <li>10 SCALE (short) scale </li>\n-     * <li>11 RADIX (int) always 10 </li>\n-     * <li>12 NULLABLE (short) nullable\n-     * (DatabaseMetaData.columnNoNulls for primitive data types,\n-     * DatabaseMetaData.columnNullable otherwise)</li>\n-     * <li>13 REMARKS (String) description </li>\n-     * <li>14 COLUMN_DEF (String) always null </li>\n-     * <li>15 SQL_DATA_TYPE (int) for future use, always 0 </li>\n-     * <li>16 SQL_DATETIME_SUB (int) for future use, always 0 </li>\n-     * <li>17 CHAR_OCTET_LENGTH (int) always null </li>\n-     * <li>18 ORDINAL_POSITION (int) the parameter index\n-     * starting from 1 (0 is the return value) </li>\n-     * <li>19 IS_NULLABLE (String) always \"YES\" </li>\n-     * <li>20 SPECIFIC_NAME (String) name </li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param procedureNamePattern the procedure name pattern\n-     * @param columnNamePattern the procedure name pattern\n-     * @return the procedure columns\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getProcedureColumns(String catalogPattern,\n-            String schemaPattern, String procedureNamePattern,\n-            String columnNamePattern) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getProcedureColumns(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(procedureNamePattern)+\", \"\n-                        +quote(columnNamePattern)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"ALIAS_CATALOG PROCEDURE_CAT, \"\n-                    + \"ALIAS_SCHEMA PROCEDURE_SCHEM, \"\n-                    + \"ALIAS_NAME PROCEDURE_NAME, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"COLUMN_TYPE, \"\n-                    + \"DATA_TYPE, \"\n-                    + \"TYPE_NAME, \"\n-                    + \"PRECISION, \"\n-                    + \"PRECISION LENGTH, \"\n-                    + \"SCALE, \"\n-                    + \"RADIX, \"\n-                    + \"NULLABLE, \"\n-                    + \"REMARKS, \"\n-                    + \"COLUMN_DEFAULT COLUMN_DEF, \"\n-                    + \"ZERO() SQL_DATA_TYPE, \"\n-                    + \"ZERO() SQL_DATETIME_SUB, \"\n-                    + \"ZERO() CHAR_OCTET_LENGTH, \"\n-                    + \"POS ORDINAL_POSITION, \"\n-                    + \"? IS_NULLABLE, \"\n-                    + \"ALIAS_NAME SPECIFIC_NAME \"\n-                    + \"FROM INFORMATION_SCHEMA.FUNCTION_COLUMNS \"\n-                    + \"WHERE ALIAS_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND ALIAS_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND ALIAS_NAME LIKE ? ESCAPE ? \"\n-                    + \"AND COLUMN_NAME LIKE ? ESCAPE ? \"\n-                    + \"ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, ORDINAL_POSITION\");\n-            prep.setString(1, \"YES\");\n-            prep.setString(2, getCatalogPattern(catalogPattern));\n-            prep.setString(3, \"\\\\\");\n-            prep.setString(4, getSchemaPattern(schemaPattern));\n-            prep.setString(5, \"\\\\\");\n-            prep.setString(6, getPattern(procedureNamePattern));\n-            prep.setString(7, \"\\\\\");\n-            prep.setString(8, getPattern(columnNamePattern));\n-            prep.setString(9, \"\\\\\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of schemas.\n-     * The result set is sorted by TABLE_SCHEM.\n-     *\n-     * <ul>\n-     * <li>1 TABLE_SCHEM (String) schema name\n-     * </li><li>2 TABLE_CATALOG (String) catalog name\n-     * </li><li>3 IS_DEFAULT (boolean) if this is the default schema\n-     * </li></ul>\n-     *\n-     * @return the schema list\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getSchemas() throws SQLException {\n-        try {\n-            debugCodeCall(\"getSchemas\");\n-            checkClosed();\n-            PreparedStatement prep = conn\n-                    .prepareAutoCloseStatement(\"SELECT \"\n-                            + \"SCHEMA_NAME TABLE_SCHEM, \"\n-                            + \"CATALOG_NAME TABLE_CATALOG, \"\n-                            +\" IS_DEFAULT \"\n-                            + \"FROM INFORMATION_SCHEMA.SCHEMATA \"\n-                            + \"ORDER BY SCHEMA_NAME\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of catalogs.\n-     * The result set is sorted by TABLE_CAT.\n-     *\n-     * <ul>\n-     * <li>1 TABLE_CAT (String) catalog name\n-     * </li></ul>\n-     *\n-     * @return the catalog list\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getCatalogs() throws SQLException {\n-        try {\n-            debugCodeCall(\"getCatalogs\");\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\n-                    \"SELECT CATALOG_NAME TABLE_CAT \"\n-                    + \"FROM INFORMATION_SCHEMA.CATALOGS\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of table types. This call returns a result set with five\n-     * records: \"SYSTEM TABLE\", \"TABLE\", \"VIEW\", \"TABLE LINK\" and \"EXTERNAL\".\n-     * <ul>\n-     * <li>1 TABLE_TYPE (String) table type\n-     * </li></ul>\n-     *\n-     * @return the table types\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getTableTypes() throws SQLException {\n-        try {\n-            debugCodeCall(\"getTableTypes\");\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TYPE TABLE_TYPE \"\n-                    + \"FROM INFORMATION_SCHEMA.TABLE_TYPES \"\n-                    + \"ORDER BY TABLE_TYPE\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of column privileges. The result set is sorted by\n-     * COLUMN_NAME and PRIVILEGE\n-     *\n-     * <ul>\n-     * <li>1 TABLE_CAT (String) table catalog</li>\n-     * <li>2 TABLE_SCHEM (String) table schema</li>\n-     * <li>3 TABLE_NAME (String) table name</li>\n-     * <li>4 COLUMN_NAME (String) column name</li>\n-     * <li>5 GRANTOR (String) grantor of access</li>\n-     * <li>6 GRANTEE (String) grantee of access</li>\n-     * <li>7 PRIVILEGE (String) SELECT, INSERT, UPDATE, DELETE or REFERENCES\n-     * (only one per row)</li>\n-     * <li>8 IS_GRANTABLE (String) YES means the grantee can grant access to\n-     * others</li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null (to get all objects) or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param table a table name (uppercase for unquoted names)\n-     * @param columnNamePattern null (to get all objects) or a column name\n-     *            (uppercase for unquoted names)\n-     * @return the list of privileges\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getColumnPrivileges(String catalogPattern,\n-            String schemaPattern, String table, String columnNamePattern)\n-            throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getColumnPrivileges(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(table)+\", \"\n-                        +quote(columnNamePattern)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"GRANTOR, \"\n-                    + \"GRANTEE, \"\n-                    + \"PRIVILEGE_TYPE PRIVILEGE, \"\n-                    + \"IS_GRANTABLE \"\n-                    + \"FROM INFORMATION_SCHEMA.COLUMN_PRIVILEGES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_NAME = ? \"\n-                    + \"AND COLUMN_NAME LIKE ? ESCAPE ? \"\n-                    + \"ORDER BY COLUMN_NAME, PRIVILEGE\");\n-            prep.setString(1, getCatalogPattern(catalogPattern));\n-            prep.setString(2, \"\\\\\");\n-            prep.setString(3, getSchemaPattern(schemaPattern));\n-            prep.setString(4, \"\\\\\");\n-            prep.setString(5, table);\n-            prep.setString(6, getPattern(columnNamePattern));\n-            prep.setString(7, \"\\\\\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of table privileges. The result set is sorted by\n-     * TABLE_SCHEM, TABLE_NAME, and PRIVILEGE.\n-     *\n-     * <ul>\n-     * <li>1 TABLE_CAT (String) table catalog </li>\n-     * <li>2 TABLE_SCHEM (String) table schema </li>\n-     * <li>3 TABLE_NAME (String) table name </li>\n-     * <li>4 GRANTOR (String) grantor of access </li>\n-     * <li>5 GRANTEE (String) grantee of access </li>\n-     * <li>6 PRIVILEGE (String) SELECT, INSERT, UPDATE, DELETE or REFERENCES\n-     * (only one per row) </li>\n-     * <li>7 IS_GRANTABLE (String) YES means the grantee can grant access to\n-     * others </li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null (to get all objects) or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param tableNamePattern null (to get all objects) or a table name\n-     *            (uppercase for unquoted names)\n-     * @return the list of privileges\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getTablePrivileges(String catalogPattern,\n-            String schemaPattern, String tableNamePattern) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getTablePrivileges(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableNamePattern)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"GRANTOR, \"\n-                    + \"GRANTEE, \"\n-                    + \"PRIVILEGE_TYPE PRIVILEGE, \"\n-                    + \"IS_GRANTABLE \"\n-                    + \"FROM INFORMATION_SCHEMA.TABLE_PRIVILEGES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_NAME LIKE ? ESCAPE ? \"\n-                    + \"ORDER BY TABLE_SCHEM, TABLE_NAME, PRIVILEGE\");\n-            prep.setString(1, getCatalogPattern(catalogPattern));\n-            prep.setString(2, \"\\\\\");\n-            prep.setString(3, getSchemaPattern(schemaPattern));\n-            prep.setString(4, \"\\\\\");\n-            prep.setString(5, getPattern(tableNamePattern));\n-            prep.setString(6, \"\\\\\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of columns that best identifier a row in a table.\n-     * The list is ordered by SCOPE.\n-     *\n-     * <ul>\n-     * <li>1 SCOPE (short) scope of result (always bestRowSession)\n-     * </li><li>2 COLUMN_NAME (String) column name\n-     * </li><li>3 DATA_TYPE (short) SQL data type, see also java.sql.Types\n-     * </li><li>4 TYPE_NAME (String) type name\n-     * </li><li>5 COLUMN_SIZE (int) precision\n-     *         (values larger than 2 GB are returned as 2 GB)\n-     * </li><li>6 BUFFER_LENGTH (int) unused\n-     * </li><li>7 DECIMAL_DIGITS (short) scale\n-     * </li><li>8 PSEUDO_COLUMN (short) (always bestRowNotPseudo)\n-     * </li></ul>\n-     *\n-     * @param catalogPattern null (to get all objects) or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param tableName table name (must be specified)\n-     * @param scope ignored\n-     * @param nullable ignored\n-     * @return the primary key index\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getBestRowIdentifier(String catalogPattern,\n-            String schemaPattern, String tableName, int scope, boolean nullable)\n-            throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getBestRowIdentifier(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableName)+\", \"\n-                        +scope+\", \"+nullable+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"CAST(? AS SMALLINT) SCOPE, \"\n-                    + \"C.COLUMN_NAME, \"\n-                    + \"C.DATA_TYPE, \"\n-                    + \"C.TYPE_NAME, \"\n-                    + \"C.CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n-                    + \"C.CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n-                    + \"CAST(C.NUMERIC_SCALE AS SMALLINT) DECIMAL_DIGITS, \"\n-                    + \"CAST(? AS SMALLINT) PSEUDO_COLUMN \"\n-                    + \"FROM INFORMATION_SCHEMA.INDEXES I, \"\n-                    +\" INFORMATION_SCHEMA.COLUMNS C \"\n-                    + \"WHERE C.TABLE_NAME = I.TABLE_NAME \"\n-                    + \"AND C.COLUMN_NAME = I.COLUMN_NAME \"\n-                    + \"AND C.TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND C.TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND C.TABLE_NAME = ? \"\n-                    + \"AND I.PRIMARY_KEY = TRUE \"\n-                    + \"ORDER BY SCOPE\");\n-            // SCOPE\n-            prep.setInt(1, DatabaseMetaData.bestRowSession);\n-            // PSEUDO_COLUMN\n-            prep.setInt(2, DatabaseMetaData.bestRowNotPseudo);\n-            prep.setString(3, getCatalogPattern(catalogPattern));\n-            prep.setString(4, \"\\\\\");\n-            prep.setString(5, getSchemaPattern(schemaPattern));\n-            prep.setString(6, \"\\\\\");\n-            prep.setString(7, tableName);\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n+    DatabaseMetaData, JdbcDatabaseMetaDataBackwardsCompat {\n+\n+  private final JdbcConnection conn;\n+\n+  /**\n+   * Whether database has support for synonyms ({@code null} if not yet known).\n+   */\n+  private Boolean hasSynonyms;\n+\n+  JdbcDatabaseMetaData(JdbcConnection conn, Trace trace, int id) {\n+    setTrace(trace, TraceObject.DATABASE_META_DATA, id);\n+    this.conn = conn;\n+  }\n+\n+  /**\n+   * Returns the major version of this driver.\n+   *\n+   * @return the major version number\n+   */\n+  @Override\n+  public int getDriverMajorVersion() {\n+    debugCodeCall(\"getDriverMajorVersion\");\n+    return Constants.VERSION_MAJOR;\n+  }\n+\n+  /**\n+   * Returns the minor version of this driver.\n+   *\n+   * @return the minor version number\n+   */\n+  @Override\n+  public int getDriverMinorVersion() {\n+    debugCodeCall(\"getDriverMinorVersion\");\n+    return Constants.VERSION_MINOR;\n+  }\n+\n+  /**\n+   * Gets the database product name.\n+   *\n+   * @return the product name (\"H2\")\n+   */\n+  @Override\n+  public String getDatabaseProductName() {\n+    debugCodeCall(\"getDatabaseProductName\");\n+    // This value must stay like that, see\n+    // http://opensource.atlassian.com/projects/hibernate/browse/HHH-2682\n+    return \"H2\";\n+  }\n+\n+  /**\n+   * Gets the product version of the database.\n+   *\n+   * @return the product version\n+   */\n+  @Override\n+  public String getDatabaseProductVersion() {\n+    debugCodeCall(\"getDatabaseProductVersion\");\n+    return Constants.getFullVersion();\n+  }\n+\n+  /**\n+   * Gets the name of the JDBC driver.\n+   *\n+   * @return the driver name (\"H2 JDBC Driver\")\n+   */\n+  @Override\n+  public String getDriverName() {\n+    debugCodeCall(\"getDriverName\");\n+    return \"H2 JDBC Driver\";\n+  }\n+\n+  /**\n+   * Gets the version number of the driver. The format is\n+   * [MajorVersion].[MinorVersion].\n+   *\n+   * @return the version number\n+   */\n+  @Override\n+  public String getDriverVersion() {\n+    debugCodeCall(\"getDriverVersion\");\n+    return Constants.getFullVersion();\n+  }\n+\n+  private boolean hasSynonyms() {\n+    Boolean hasSynonyms = this.hasSynonyms;\n+    if (hasSynonyms == null) {\n+      SessionInterface si = conn.getSession();\n+      if (si instanceof SessionRemote) {\n+        SessionRemote sr = (SessionRemote) si;\n+        int clientVersion = sr.getClientVersion();\n+        if (clientVersion >= Constants.TCP_PROTOCOL_VERSION_17) {\n+          hasSynonyms = true;\n+        } else if (clientVersion <= Constants.TCP_PROTOCOL_VERSION_15) {\n+          hasSynonyms = false;\n+        } else { // 1.4.194-1.4.196\n+          CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n+          ResultInterface result = c.executeQuery(0, false);\n+          result.next();\n+          String s = result.currentRow()[0].getString();\n+          result.close();\n+          hasSynonyms = \"1.4.196\".equals(s);\n         }\n-    }\n-\n-    /**\n-     * Get the list of columns that are update when any value is updated.\n-     * The result set is always empty.\n-     *\n-     * <ul>\n-     * <li>1 SCOPE (int) not used\n-     * </li><li>2 COLUMN_NAME (String) column name\n-     * </li><li>3 DATA_TYPE (int) SQL data type - see also java.sql.Types\n-     * </li><li>4 TYPE_NAME (String) data type name\n-     * </li><li>5 COLUMN_SIZE (int) precision\n-     *         (values larger than 2 GB are returned as 2 GB)\n-     * </li><li>6 BUFFER_LENGTH (int) length (bytes)\n-     * </li><li>7 DECIMAL_DIGITS (int) scale\n-     * </li><li>8 PSEUDO_COLUMN (int) is this column a pseudo column\n-     * </li></ul>\n-     *\n-     * @param catalog null (to get all objects) or the catalog name\n-     * @param schema null (to get all objects) or a schema name\n-     * @param tableName table name (must be specified)\n-     * @return an empty result set\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getVersionColumns(String catalog, String schema,\n-            String tableName) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getVersionColumns(\"\n-                        +quote(catalog)+\", \"\n-                        +quote(schema)+\", \"\n-                        +quote(tableName)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"ZERO() SCOPE, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"CAST(DATA_TYPE AS INT) DATA_TYPE, \"\n-                    + \"TYPE_NAME, \"\n-                    + \"NUMERIC_PRECISION COLUMN_SIZE, \"\n-                    + \"NUMERIC_PRECISION BUFFER_LENGTH, \"\n-                    + \"NUMERIC_PRECISION DECIMAL_DIGITS, \"\n-                    + \"ZERO() PSEUDO_COLUMN \"\n-                    + \"FROM INFORMATION_SCHEMA.COLUMNS \"\n-                    + \"WHERE FALSE\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of primary key columns that are referenced by a table. The\n-     * result set is sorted by PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME,\n-     * FK_NAME, KEY_SEQ.\n-     *\n-     * <ul>\n-     * <li>1 PKTABLE_CAT (String) primary catalog </li>\n-     * <li>2 PKTABLE_SCHEM (String) primary schema </li>\n-     * <li>3 PKTABLE_NAME (String) primary table </li>\n-     * <li>4 PKCOLUMN_NAME (String) primary column </li>\n-     * <li>5 FKTABLE_CAT (String) foreign catalog </li>\n-     * <li>6 FKTABLE_SCHEM (String) foreign schema </li>\n-     * <li>7 FKTABLE_NAME (String) foreign table </li>\n-     * <li>8 FKCOLUMN_NAME (String) foreign column </li>\n-     * <li>9 KEY_SEQ (short) sequence number (1, 2, ...) </li>\n-     * <li>10 UPDATE_RULE (short) action on update (see\n-     * DatabaseMetaData.importedKey...) </li>\n-     * <li>11 DELETE_RULE (short) action on delete (see\n-     * DatabaseMetaData.importedKey...) </li>\n-     * <li>12 FK_NAME (String) foreign key name </li>\n-     * <li>13 PK_NAME (String) primary key name </li>\n-     * <li>14 DEFERRABILITY (short) deferrable or not (always\n-     * importedKeyNotDeferrable) </li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null (to get all objects) or the catalog name\n-     * @param schemaPattern the schema name of the foreign table\n-     * @param tableName the name of the foreign table\n-     * @return the result set\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getImportedKeys(String catalogPattern,\n-            String schemaPattern, String tableName) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getImportedKeys(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableName)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n-                    + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n-                    + \"PKTABLE_NAME PKTABLE_NAME, \"\n-                    + \"PKCOLUMN_NAME, \"\n-                    + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n-                    + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n-                    + \"FKTABLE_NAME, \"\n-                    + \"FKCOLUMN_NAME, \"\n-                    + \"ORDINAL_POSITION KEY_SEQ, \"\n-                    + \"UPDATE_RULE, \"\n-                    + \"DELETE_RULE, \"\n-                    + \"FK_NAME, \"\n-                    + \"PK_NAME, \"\n-                    + \"DEFERRABILITY \"\n-                    + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n-                    + \"WHERE FKTABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND FKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND FKTABLE_NAME = ? \"\n-                    + \"ORDER BY PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME, FK_NAME, KEY_SEQ\");\n-            prep.setString(1, getCatalogPattern(catalogPattern));\n-            prep.setString(2, \"\\\\\");\n-            prep.setString(3, getSchemaPattern(schemaPattern));\n-            prep.setString(4, \"\\\\\");\n-            prep.setString(5, tableName);\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of foreign key columns that reference a table. The result\n-     * set is sorted by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME,\n-     * KEY_SEQ.\n-     *\n-     * <ul>\n-     * <li>1 PKTABLE_CAT (String) primary catalog </li>\n-     * <li>2 PKTABLE_SCHEM (String) primary schema </li>\n-     * <li>3 PKTABLE_NAME (String) primary table </li>\n-     * <li>4 PKCOLUMN_NAME (String) primary column </li>\n-     * <li>5 FKTABLE_CAT (String) foreign catalog </li>\n-     * <li>6 FKTABLE_SCHEM (String) foreign schema </li>\n-     * <li>7 FKTABLE_NAME (String) foreign table </li>\n-     * <li>8 FKCOLUMN_NAME (String) foreign column </li>\n-     * <li>9 KEY_SEQ (short) sequence number (1,2,...) </li>\n-     * <li>10 UPDATE_RULE (short) action on update (see\n-     * DatabaseMetaData.importedKey...) </li>\n-     * <li>11 DELETE_RULE (short) action on delete (see\n-     * DatabaseMetaData.importedKey...) </li>\n-     * <li>12 FK_NAME (String) foreign key name </li>\n-     * <li>13 PK_NAME (String) primary key name </li>\n-     * <li>14 DEFERRABILITY (short) deferrable or not (always\n-     * importedKeyNotDeferrable) </li>\n-     * </ul>\n-     *\n-     * @param catalogPattern null or the catalog name\n-     * @param schemaPattern the schema name of the primary table\n-     * @param tableName the name of the primary table\n-     * @return the result set\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getExportedKeys(String catalogPattern,\n-            String schemaPattern, String tableName) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getExportedKeys(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableName)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n-                    + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n-                    + \"PKTABLE_NAME PKTABLE_NAME, \"\n-                    + \"PKCOLUMN_NAME, \"\n-                    + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n-                    + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n-                    + \"FKTABLE_NAME, \"\n-                    + \"FKCOLUMN_NAME, \"\n-                    + \"ORDINAL_POSITION KEY_SEQ, \"\n-                    + \"UPDATE_RULE, \"\n-                    + \"DELETE_RULE, \"\n-                    + \"FK_NAME, \"\n-                    + \"PK_NAME, \"\n-                    + \"DEFERRABILITY \"\n-                    + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n-                    + \"WHERE PKTABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND PKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND PKTABLE_NAME = ? \"\n-                    + \"ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME, KEY_SEQ\");\n-            prep.setString(1, getCatalogPattern(catalogPattern));\n-            prep.setString(2, \"\\\\\");\n-            prep.setString(3, getSchemaPattern(schemaPattern));\n-            prep.setString(4, \"\\\\\");\n-            prep.setString(5, tableName);\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of foreign key columns that references a table, as well as\n-     * the list of primary key columns that are references by a table. The\n-     * result set is sorted by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME,\n-     * FK_NAME, KEY_SEQ.\n-     *\n-     * <ul>\n-     * <li>1 PKTABLE_CAT (String) primary catalog </li>\n-     * <li>2 PKTABLE_SCHEM (String) primary schema </li>\n-     * <li>3 PKTABLE_NAME (String) primary table </li>\n-     * <li>4 PKCOLUMN_NAME (String) primary column </li>\n-     * <li>5 FKTABLE_CAT (String) foreign catalog </li>\n-     * <li>6 FKTABLE_SCHEM (String) foreign schema </li>\n-     * <li>7 FKTABLE_NAME (String) foreign table </li>\n-     * <li>8 FKCOLUMN_NAME (String) foreign column </li>\n-     * <li>9 KEY_SEQ (short) sequence number (1,2,...) </li>\n-     * <li>10 UPDATE_RULE (short) action on update (see\n-     * DatabaseMetaData.importedKey...) </li>\n-     * <li>11 DELETE_RULE (short) action on delete (see\n-     * DatabaseMetaData.importedKey...) </li>\n-     * <li>12 FK_NAME (String) foreign key name </li>\n-     * <li>13 PK_NAME (String) primary key name </li>\n-     * <li>14 DEFERRABILITY (short) deferrable or not (always\n-     * importedKeyNotDeferrable) </li>\n-     * </ul>\n-     *\n-     * @param primaryCatalogPattern null or the catalog name\n-     * @param primarySchemaPattern the schema name of the primary table\n-     *          (optional)\n-     * @param primaryTable the name of the primary table (must be specified)\n-     * @param foreignCatalogPattern null or the catalog name\n-     * @param foreignSchemaPattern the schema name of the foreign table\n-     *          (optional)\n-     * @param foreignTable the name of the foreign table (must be specified)\n-     * @return the result set\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getCrossReference(String primaryCatalogPattern,\n-            String primarySchemaPattern, String primaryTable, String foreignCatalogPattern,\n-            String foreignSchemaPattern, String foreignTable) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getCrossReference(\"\n-                        +quote(primaryCatalogPattern)+\", \"\n-                        +quote(primarySchemaPattern)+\", \"\n-                        +quote(primaryTable)+\", \"\n-                        +quote(foreignCatalogPattern)+\", \"\n-                        +quote(foreignSchemaPattern)+\", \"\n-                        +quote(foreignTable)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n-                    + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n-                    + \"PKTABLE_NAME PKTABLE_NAME, \"\n-                    + \"PKCOLUMN_NAME, \"\n-                    + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n-                    + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n-                    + \"FKTABLE_NAME, \"\n-                    + \"FKCOLUMN_NAME, \"\n-                    + \"ORDINAL_POSITION KEY_SEQ, \"\n-                    + \"UPDATE_RULE, \"\n-                    + \"DELETE_RULE, \"\n-                    + \"FK_NAME, \"\n-                    + \"PK_NAME, \"\n-                    + \"DEFERRABILITY \"\n-                    + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n-                    + \"WHERE PKTABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND PKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND PKTABLE_NAME = ? \"\n-                    + \"AND FKTABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND FKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND FKTABLE_NAME = ? \"\n-                    + \"ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME, KEY_SEQ\");\n-            prep.setString(1, getCatalogPattern(primaryCatalogPattern));\n-            prep.setString(2, \"\\\\\");\n-            prep.setString(3, getSchemaPattern(primarySchemaPattern));\n-            prep.setString(4, \"\\\\\");\n-            prep.setString(5, primaryTable);\n-            prep.setString(6, getCatalogPattern(foreignCatalogPattern));\n-            prep.setString(7, \"\\\\\");\n-            prep.setString(8, getSchemaPattern(foreignSchemaPattern));\n-            prep.setString(9, \"\\\\\");\n-            prep.setString(10, foreignTable);\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of user-defined data types.\n-     * This call returns an empty result set.\n-     *\n-     * <ul>\n-     * <li>1 TYPE_CAT (String) catalog\n-     * </li><li>2 TYPE_SCHEM (String) schema\n-     * </li><li>3 TYPE_NAME (String) type name\n-     * </li><li>4 CLASS_NAME (String) Java class\n-     * </li><li>5 DATA_TYPE (short) SQL Type - see also java.sql.Types\n-     * </li><li>6 REMARKS (String) description\n-     * </li><li>7 BASE_TYPE (short) base type - see also java.sql.Types\n-     * </li></ul>\n-     *\n-     * @param catalog ignored\n-     * @param schemaPattern ignored\n-     * @param typeNamePattern ignored\n-     * @param types ignored\n-     * @return an empty result set\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getUDTs(String catalog, String schemaPattern,\n-            String typeNamePattern, int[] types) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getUDTs(\"\n-                        +quote(catalog)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(typeNamePattern)+\", \"\n-                        +quoteIntArray(types)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"CAST(NULL AS VARCHAR) TYPE_CAT, \"\n-                    + \"CAST(NULL AS VARCHAR) TYPE_SCHEM, \"\n-                    + \"CAST(NULL AS VARCHAR) TYPE_NAME, \"\n-                    + \"CAST(NULL AS VARCHAR) CLASS_NAME, \"\n-                    + \"CAST(NULL AS SMALLINT) DATA_TYPE, \"\n-                    + \"CAST(NULL AS VARCHAR) REMARKS, \"\n-                    + \"CAST(NULL AS SMALLINT) BASE_TYPE \"\n-                    + \"FROM DUAL WHERE FALSE\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Gets the list of data types. The result set is sorted by DATA_TYPE and\n-     * afterwards by how closely the data type maps to the corresponding JDBC\n-     * SQL type (best match first).\n-     *\n-     * <ul>\n-     * <li>1 TYPE_NAME (String) type name </li>\n-     * <li>2 DATA_TYPE (short) SQL data type - see also java.sql.Types </li>\n-     * <li>3 PRECISION (int) maximum precision </li>\n-     * <li>4 LITERAL_PREFIX (String) prefix used to quote a literal </li>\n-     * <li>5 LITERAL_SUFFIX (String) suffix used to quote a literal </li>\n-     * <li>6 CREATE_PARAMS (String) parameters used (may be null) </li>\n-     * <li>7 NULLABLE (short) typeNoNulls (NULL not allowed) or typeNullable\n-     * </li>\n-     * <li>8 CASE_SENSITIVE (boolean) case sensitive </li>\n-     * <li>9 SEARCHABLE (short) typeSearchable </li>\n-     * <li>10 UNSIGNED_ATTRIBUTE (boolean) unsigned </li>\n-     * <li>11 FIXED_PREC_SCALE (boolean) fixed precision </li>\n-     * <li>12 AUTO_INCREMENT (boolean) auto increment </li>\n-     * <li>13 LOCAL_TYPE_NAME (String) localized version of the data type </li>\n-     * <li>14 MINIMUM_SCALE (short) minimum scale </li>\n-     * <li>15 MAXIMUM_SCALE (short) maximum scale </li>\n-     * <li>16 SQL_DATA_TYPE (int) unused </li>\n-     * <li>17 SQL_DATETIME_SUB (int) unused </li>\n-     * <li>18 NUM_PREC_RADIX (int) 2 for binary, 10 for decimal </li>\n-     * </ul>\n-     *\n-     * @return the list of data types\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getTypeInfo() throws SQLException {\n-        try {\n-            debugCodeCall(\"getTypeInfo\");\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TYPE_NAME, \"\n-                    + \"DATA_TYPE, \"\n-                    + \"PRECISION, \"\n-                    + \"PREFIX LITERAL_PREFIX, \"\n-                    + \"SUFFIX LITERAL_SUFFIX, \"\n-                    + \"PARAMS CREATE_PARAMS, \"\n-                    + \"NULLABLE, \"\n-                    + \"CASE_SENSITIVE, \"\n-                    + \"SEARCHABLE, \"\n-                    + \"FALSE UNSIGNED_ATTRIBUTE, \"\n-                    + \"FALSE FIXED_PREC_SCALE, \"\n-                    + \"AUTO_INCREMENT, \"\n-                    + \"TYPE_NAME LOCAL_TYPE_NAME, \"\n-                    + \"MINIMUM_SCALE, \"\n-                    + \"MAXIMUM_SCALE, \"\n-                    + \"DATA_TYPE SQL_DATA_TYPE, \"\n-                    + \"ZERO() SQL_DATETIME_SUB, \"\n-                    + \"RADIX NUM_PREC_RADIX \"\n-                    + \"FROM INFORMATION_SCHEMA.TYPE_INFO \"\n-                    + \"ORDER BY DATA_TYPE, POS\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Checks if this database store data in local files.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean usesLocalFiles() {\n-        debugCodeCall(\"usesLocalFiles\");\n-        return true;\n-    }\n-\n-    /**\n-     * Checks if this database use one file per table.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean usesLocalFilePerTable() {\n-        debugCodeCall(\"usesLocalFilePerTable\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns the string used to quote identifiers.\n-     *\n-     * @return a double quote\n-     */\n-    @Override\n-    public String getIdentifierQuoteString() {\n-        debugCodeCall(\"getIdentifierQuoteString\");\n-        return \"\\\"\";\n-    }\n-\n-    /**\n-     * Gets the comma-separated list of all SQL keywords that are not supported\n-     * as table/column/index name, in addition to the SQL-2003 keywords. The list\n-     * returned is:\n-     * <pre>\n-     * LIMIT,MINUS,OFFSET,ROWNUM,SYSDATE,SYSTIME,SYSTIMESTAMP,TODAY\n-     * </pre>\n-     * The complete list of keywords (including SQL-2003 keywords) is:\n-     * <pre>\n-     * ALL, CHECK, CONSTRAINT, CROSS, CURRENT_DATE, CURRENT_TIME,\n-     * CURRENT_TIMESTAMP, DISTINCT, EXCEPT, EXISTS, FALSE, FETCH, FOR, FOREIGN,\n-     * FROM, FULL, GROUP, HAVING, INNER, INTERSECT, IS, JOIN, LIKE, LIMIT,\n-     * MINUS, NATURAL, NOT, NULL, OFFSET, ON, ORDER, PRIMARY, ROWNUM, SELECT,\n-     * SYSDATE, SYSTIME, SYSTIMESTAMP, TODAY, TRUE, UNION, UNIQUE, WHERE, WITH\n-     * </pre>\n-     *\n-     * @return a list of additional the keywords\n-     */\n-    @Override\n-    public String getSQLKeywords() {\n-        debugCodeCall(\"getSQLKeywords\");\n-        return \"LIMIT,MINUS,OFFSET,ROWNUM,SYSDATE,SYSTIME,SYSTIMESTAMP,TODAY\";\n-    }\n-\n-    /**\n-     * Returns the list of numeric functions supported by this database.\n-     *\n-     * @return the list\n-     */\n-    @Override\n-    public String getNumericFunctions() throws SQLException {\n-        debugCodeCall(\"getNumericFunctions\");\n-        return getFunctions(\"Functions (Numeric)\");\n-    }\n-\n-    /**\n-     * Returns the list of string functions supported by this database.\n-     *\n-     * @return the list\n-     */\n-    @Override\n-    public String getStringFunctions() throws SQLException {\n-        debugCodeCall(\"getStringFunctions\");\n-        return getFunctions(\"Functions (String)\");\n-    }\n-\n-    /**\n-     * Returns the list of system functions supported by this database.\n-     *\n-     * @return the list\n-     */\n-    @Override\n-    public String getSystemFunctions() throws SQLException {\n-        debugCodeCall(\"getSystemFunctions\");\n-        return getFunctions(\"Functions (System)\");\n-    }\n-\n-    /**\n-     * Returns the list of date and time functions supported by this database.\n-     *\n-     * @return the list\n-     */\n-    @Override\n-    public String getTimeDateFunctions() throws SQLException {\n-        debugCodeCall(\"getTimeDateFunctions\");\n-        return getFunctions(\"Functions (Time and Date)\");\n-    }\n-\n-    private String getFunctions(String section) throws SQLException {\n-        try {\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT TOPIC \"\n-                    + \"FROM INFORMATION_SCHEMA.HELP WHERE SECTION = ?\");\n-            prep.setString(1, section);\n-            ResultSet rs = prep.executeQuery();\n-            StatementBuilder buff = new StatementBuilder();\n-            while (rs.next()) {\n-                String s = rs.getString(1).trim();\n-                String[] array = StringUtils.arraySplit(s, ',', true);\n-                for (String a : array) {\n-                    buff.appendExceptFirst(\",\");\n-                    String f = a.trim();\n-                    if (f.indexOf(' ') >= 0) {\n-                        // remove 'Function' from 'INSERT Function'\n-                        f = f.substring(0, f.indexOf(' ')).trim();\n-                    }\n-                    buff.append(f);\n-                }\n-            }\n-            rs.close();\n-            prep.close();\n-            return buff.toString();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n+      } else {\n+        hasSynonyms = true;\n+      }\n+      this.hasSynonyms = hasSynonyms;\n+    }\n+    return hasSynonyms;\n+  }\n+\n+  /**\n+   * Gets the list of tables in the database. The result set is sorted by\n+   * TABLE_TYPE, TABLE_SCHEM, and TABLE_NAME.\n+   *\n+   * <ul>\n+   * <li>1 TABLE_CAT (String) table catalog </li>\n+   * <li>2 TABLE_SCHEM (String) table schema </li>\n+   * <li>3 TABLE_NAME (String) table name </li>\n+   * <li>4 TABLE_TYPE (String) table type </li>\n+   * <li>5 REMARKS (String) comment </li>\n+   * <li>6 TYPE_CAT (String) always null </li>\n+   * <li>7 TYPE_SCHEM (String) always null </li>\n+   * <li>8 TYPE_NAME (String) always null </li>\n+   * <li>9 SELF_REFERENCING_COL_NAME (String) always null </li>\n+   * <li>10 REF_GENERATION (String) always null </li>\n+   * <li>11 SQL (String) the create table statement or NULL for systems tables\n+   * </li>\n+   * </ul>\n+   *\n+   * @param catalogPattern   null (to get all objects) or the catalog name\n+   * @param schemaPattern    null (to get all objects) or a schema name\n+   *                         (uppercase for unquoted names)\n+   * @param tableNamePattern null (to get all objects) or a table name\n+   *                         (uppercase for unquoted names)\n+   * @param types            null or a list of table types\n+   * @return the list of columns\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getTables(String catalogPattern, String schemaPattern,\n+                             String tableNamePattern, String[] types) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getTables(\" + quote(catalogPattern) + \", \" +\n+            quote(schemaPattern) + \", \" + quote(tableNamePattern) +\n+            \", \" + quoteArray(types) + \");\");\n+      }\n+      checkClosed();\n+      int typesLength = types != null ? types.length : 0;\n+      boolean includeSynonyms = hasSynonyms() && (types == null || Arrays.asList(types).contains(\"SYNONYM\"));\n+\n+      // (1024 - 16) is enough for the most cases\n+      StringBuilder select = new StringBuilder(1008);\n+      if (includeSynonyms) {\n+        select.append(\"SELECT \"\n+            + \"TABLE_CAT, \"\n+            + \"TABLE_SCHEM, \"\n+            + \"TABLE_NAME, \"\n+            + \"TABLE_TYPE, \"\n+            + \"REMARKS, \"\n+            + \"TYPE_CAT, \"\n+            + \"TYPE_SCHEM, \"\n+            + \"TYPE_NAME, \"\n+            + \"SELF_REFERENCING_COL_NAME, \"\n+            + \"REF_GENERATION, \"\n+            + \"SQL \"\n+            + \"FROM (\"\n+            + \"SELECT \"\n+            + \"SYNONYM_CATALOG TABLE_CAT, \"\n+            + \"SYNONYM_SCHEMA TABLE_SCHEM, \"\n+            + \"SYNONYM_NAME as TABLE_NAME, \"\n+            + \"TYPE_NAME AS TABLE_TYPE, \"\n+            + \"REMARKS, \"\n+            + \"TYPE_NAME TYPE_CAT, \"\n+            + \"TYPE_NAME TYPE_SCHEM, \"\n+            + \"TYPE_NAME AS TYPE_NAME, \"\n+            + \"TYPE_NAME SELF_REFERENCING_COL_NAME, \"\n+            + \"TYPE_NAME REF_GENERATION, \"\n+            + \"NULL AS SQL \"\n+            + \"FROM INFORMATION_SCHEMA.SYNONYMS \"\n+            + \"WHERE SYNONYM_CATALOG LIKE ?1 ESCAPE ?4 \"\n+            + \"AND SYNONYM_SCHEMA LIKE ?2 ESCAPE ?4 \"\n+            + \"AND SYNONYM_NAME LIKE ?3 ESCAPE ?4 \"\n+            + \"UNION \");\n+      }\n+      select.append(\"SELECT \"\n+          + \"TABLE_CATALOG TABLE_CAT, \"\n+          + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+          + \"TABLE_NAME, \"\n+          + \"TABLE_TYPE, \"\n+          + \"REMARKS, \"\n+          + \"TYPE_NAME TYPE_CAT, \"\n+          + \"TYPE_NAME TYPE_SCHEM, \"\n+          + \"TYPE_NAME, \"\n+          + \"TYPE_NAME SELF_REFERENCING_COL_NAME, \"\n+          + \"TYPE_NAME REF_GENERATION, \"\n+          + \"SQL \"\n+          + \"FROM INFORMATION_SCHEMA.TABLES \"\n+          + \"WHERE TABLE_CATALOG LIKE ?1 ESCAPE ?4 \"\n+          + \"AND TABLE_SCHEMA LIKE ?2 ESCAPE ?4 \"\n+          + \"AND TABLE_NAME LIKE ?3 ESCAPE ?4\");\n+      if (typesLength > 0) {\n+        select.append(\" AND TABLE_TYPE IN(\");\n+        for (int i = 0; i < typesLength; i++) {\n+          if (i > 0) {\n+            select.append(\", \");\n+          }\n+          select.append('?').append(i + 5);\n         }\n-    }\n-\n-    /**\n-     * Returns the default escape character for DatabaseMetaData search\n-     * patterns.\n-     *\n-     * @return the default escape character (always '\\', independent on the\n-     *         mode)\n-     */\n-    @Override\n-    public String getSearchStringEscape() {\n-        debugCodeCall(\"getSearchStringEscape\");\n-        return \"\\\\\";\n-    }\n-\n-    /**\n-     * Returns the characters that are allowed for identifiers in addiction to\n-     * A-Z, a-z, 0-9 and '_'.\n-     *\n-     * @return an empty String (\"\")\n-     */\n-    @Override\n-    public String getExtraNameCharacters() {\n-        debugCodeCall(\"getExtraNameCharacters\");\n-        return \"\";\n-    }\n-\n-    /**\n-     * Returns whether alter table with add column is supported.\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsAlterTableWithAddColumn() {\n-        debugCodeCall(\"supportsAlterTableWithAddColumn\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether alter table with drop column is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsAlterTableWithDropColumn() {\n-        debugCodeCall(\"supportsAlterTableWithDropColumn\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether column aliasing is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsColumnAliasing() {\n-        debugCodeCall(\"supportsColumnAliasing\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether NULL+1 is NULL or not.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean nullPlusNonNullIsNull() {\n-        debugCodeCall(\"nullPlusNonNullIsNull\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether CONVERT is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsConvert() {\n-        debugCodeCall(\"supportsConvert\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether CONVERT is supported for one datatype to another.\n-     *\n-     * @param fromType the source SQL type\n-     * @param toType the target SQL type\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsConvert(int fromType, int toType) {\n-        if (isDebugEnabled()) {\n-            debugCode(\"supportsConvert(\"+fromType+\", \"+fromType+\");\");\n+        select.append(')');\n+      }\n+      if (includeSynonyms) {\n+        select.append(')');\n+      }\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\n+          select.append(\" ORDER BY TABLE_TYPE, TABLE_SCHEM, TABLE_NAME\").toString());\n+      prep.setString(1, getCatalogPattern(catalogPattern));\n+      prep.setString(2, getSchemaPattern(schemaPattern));\n+      prep.setString(3, getPattern(tableNamePattern));\n+      prep.setString(4, \"\\\\\");\n+      for (int i = 0; i < typesLength; i++) {\n+        prep.setString(5 + i, types[i]);\n+      }\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of columns. The result set is sorted by TABLE_SCHEM,\n+   * TABLE_NAME, and ORDINAL_POSITION.\n+   *\n+   * <ul>\n+   * <li>1 TABLE_CAT (String) table catalog </li>\n+   * <li>2 TABLE_SCHEM (String) table schema </li>\n+   * <li>3 TABLE_NAME (String) table name </li>\n+   * <li>4 COLUMN_NAME (String) column name </li>\n+   * <li>5 DATA_TYPE (short) data type (see java.sql.Types) </li>\n+   * <li>6 TYPE_NAME (String) data type name (\"INTEGER\", \"VARCHAR\",...) </li>\n+   * <li>7 COLUMN_SIZE (int) precision\n+   *         (values larger than 2 GB are returned as 2 GB)</li>\n+   * <li>8 BUFFER_LENGTH (int) unused </li>\n+   * <li>9 DECIMAL_DIGITS (int) scale (0 for INTEGER and VARCHAR) </li>\n+   * <li>10 NUM_PREC_RADIX (int) radix (always 10) </li>\n+   * <li>11 NULLABLE (int) columnNoNulls or columnNullable</li>\n+   * <li>12 REMARKS (String) comment (always empty) </li>\n+   * <li>13 COLUMN_DEF (String) default value </li>\n+   * <li>14 SQL_DATA_TYPE (int) unused </li>\n+   * <li>15 SQL_DATETIME_SUB (int) unused </li>\n+   * <li>16 CHAR_OCTET_LENGTH (int) unused </li>\n+   * <li>17 ORDINAL_POSITION (int) the column index (1,2,...) </li>\n+   * <li>18 IS_NULLABLE (String) \"NO\" or \"YES\" </li>\n+   * <li>19 SCOPE_CATALOG (String) always null </li>\n+   * <li>20 SCOPE_SCHEMA (String) always null </li>\n+   * <li>21 SCOPE_TABLE (String) always null </li>\n+   * <li>22 SOURCE_DATA_TYPE (short) null </li>\n+   * <li>23 IS_AUTOINCREMENT (String) \"NO\" or \"YES\" </li>\n+   * <li>24 SCOPE_CATLOG (String) always null (the typo is on purpose,\n+   * for compatibility with the JDBC specification prior to 4.1)</li>\n+   * </ul>\n+   *\n+   * @param catalogPattern    null (to get all objects) or the catalog name\n+   * @param schemaPattern     null (to get all objects) or a schema name\n+   *                          (uppercase for unquoted names)\n+   * @param tableNamePattern  null (to get all objects) or a table name\n+   *                          (uppercase for unquoted names)\n+   * @param columnNamePattern null (to get all objects) or a column name\n+   *                          (uppercase for unquoted names)\n+   * @return the list of columns\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getColumns(String catalogPattern, String schemaPattern,\n+                              String tableNamePattern, String columnNamePattern)\n+      throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getColumns(\" + quote(catalogPattern) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(tableNamePattern) + \", \"\n+            + quote(columnNamePattern) + \");\");\n+      }\n+      checkClosed();\n+      boolean includeSynonyms = hasSynonyms();\n+\n+      StringBuilder select = new StringBuilder(2432);\n+      if (includeSynonyms) {\n+        select.append(\"SELECT \"\n+            + \"TABLE_CAT, \"\n+            + \"TABLE_SCHEM, \"\n+            + \"TABLE_NAME, \"\n+            + \"COLUMN_NAME, \"\n+            + \"DATA_TYPE, \"\n+            + \"TYPE_NAME, \"\n+            + \"COLUMN_SIZE, \"\n+            + \"BUFFER_LENGTH, \"\n+            + \"DECIMAL_DIGITS, \"\n+            + \"NUM_PREC_RADIX, \"\n+            + \"NULLABLE, \"\n+            + \"REMARKS, \"\n+            + \"COLUMN_DEF, \"\n+            + \"SQL_DATA_TYPE, \"\n+            + \"SQL_DATETIME_SUB, \"\n+            + \"CHAR_OCTET_LENGTH, \"\n+            + \"ORDINAL_POSITION, \"\n+            + \"IS_NULLABLE, \"\n+            + \"SCOPE_CATALOG, \"\n+            + \"SCOPE_SCHEMA, \"\n+            + \"SCOPE_TABLE, \"\n+            + \"SOURCE_DATA_TYPE, \"\n+            + \"IS_AUTOINCREMENT, \"\n+            + \"SCOPE_CATLOG \"\n+            + \"FROM (\"\n+            + \"SELECT \"\n+            + \"s.SYNONYM_CATALOG TABLE_CAT, \"\n+            + \"s.SYNONYM_SCHEMA TABLE_SCHEM, \"\n+            + \"s.SYNONYM_NAME TABLE_NAME, \"\n+            + \"c.COLUMN_NAME, \"\n+            + \"c.DATA_TYPE, \"\n+            + \"c.TYPE_NAME, \"\n+            + \"c.CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n+            + \"c.CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n+            + \"c.NUMERIC_SCALE DECIMAL_DIGITS, \"\n+            + \"c.NUMERIC_PRECISION_RADIX NUM_PREC_RADIX, \"\n+            + \"c.NULLABLE, \"\n+            + \"c.REMARKS, \"\n+            + \"c.COLUMN_DEFAULT COLUMN_DEF, \"\n+            + \"c.DATA_TYPE SQL_DATA_TYPE, \"\n+            + \"ZERO() SQL_DATETIME_SUB, \"\n+            + \"c.CHARACTER_OCTET_LENGTH CHAR_OCTET_LENGTH, \"\n+            + \"c.ORDINAL_POSITION, \"\n+            + \"c.IS_NULLABLE IS_NULLABLE, \"\n+            + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATALOG, \"\n+            + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_SCHEMA, \"\n+            + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_TABLE, \"\n+            + \"c.SOURCE_DATA_TYPE, \"\n+            + \"CASE WHEN c.SEQUENCE_NAME IS NULL THEN \"\n+            + \"CAST(?1 AS VARCHAR) ELSE CAST(?2 AS VARCHAR) END IS_AUTOINCREMENT, \"\n+            + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATLOG \"\n+            + \"FROM INFORMATION_SCHEMA.COLUMNS c JOIN INFORMATION_SCHEMA.SYNONYMS s ON \"\n+            + \"s.SYNONYM_FOR = c.TABLE_NAME \"\n+            + \"AND s.SYNONYM_FOR_SCHEMA = c.TABLE_SCHEMA \"\n+            + \"WHERE s.SYNONYM_CATALOG LIKE ?3 ESCAPE ?7 \"\n+            + \"AND s.SYNONYM_SCHEMA LIKE ?4 ESCAPE ?7 \"\n+            + \"AND s.SYNONYM_NAME LIKE ?5 ESCAPE ?7 \"\n+            + \"AND c.COLUMN_NAME LIKE ?6 ESCAPE ?7 \"\n+            + \"UNION \");\n+      }\n+      select.append(\"SELECT \"\n+          + \"TABLE_CATALOG TABLE_CAT, \"\n+          + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+          + \"TABLE_NAME, \"\n+          + \"COLUMN_NAME, \"\n+          + \"DATA_TYPE, \"\n+          + \"TYPE_NAME, \"\n+          + \"CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n+          + \"CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n+          + \"NUMERIC_SCALE DECIMAL_DIGITS, \"\n+          + \"NUMERIC_PRECISION_RADIX NUM_PREC_RADIX, \"\n+          + \"NULLABLE, \"\n+          + \"REMARKS, \"\n+          + \"COLUMN_DEFAULT COLUMN_DEF, \"\n+          + \"DATA_TYPE SQL_DATA_TYPE, \"\n+          + \"ZERO() SQL_DATETIME_SUB, \"\n+          + \"CHARACTER_OCTET_LENGTH CHAR_OCTET_LENGTH, \"\n+          + \"ORDINAL_POSITION, \"\n+          + \"IS_NULLABLE IS_NULLABLE, \"\n+          + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATALOG, \"\n+          + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_SCHEMA, \"\n+          + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_TABLE, \"\n+          + \"SOURCE_DATA_TYPE, \"\n+          + \"CASE WHEN SEQUENCE_NAME IS NULL THEN \"\n+          + \"CAST(?1 AS VARCHAR) ELSE CAST(?2 AS VARCHAR) END IS_AUTOINCREMENT, \"\n+          + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATLOG \"\n+          + \"FROM INFORMATION_SCHEMA.COLUMNS \"\n+          + \"WHERE TABLE_CATALOG LIKE ?3 ESCAPE ?7 \"\n+          + \"AND TABLE_SCHEMA LIKE ?4 ESCAPE ?7 \"\n+          + \"AND TABLE_NAME LIKE ?5 ESCAPE ?7 \"\n+          + \"AND COLUMN_NAME LIKE ?6 ESCAPE ?7\");\n+      if (includeSynonyms) {\n+        select.append(')');\n+      }\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\n+          select.append(\" ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION\").toString());\n+      prep.setString(1, \"NO\");\n+      prep.setString(2, \"YES\");\n+      prep.setString(3, getCatalogPattern(catalogPattern));\n+      prep.setString(4, getSchemaPattern(schemaPattern));\n+      prep.setString(5, getPattern(tableNamePattern));\n+      prep.setString(6, getPattern(columnNamePattern));\n+      prep.setString(7, \"\\\\\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of indexes for this database. The primary key index (if\n+   * there is one) is also listed, with the name PRIMARY_KEY. The result set\n+   * is sorted by NON_UNIQUE ('false' first), TYPE, TABLE_SCHEM, INDEX_NAME,\n+   * and ORDINAL_POSITION.\n+   *\n+   * <ul>\n+   * <li>1 TABLE_CAT (String) table catalog </li>\n+   * <li>2 TABLE_SCHEM (String) table schema </li>\n+   * <li>3 TABLE_NAME (String) table name </li>\n+   * <li>4 NON_UNIQUE (boolean) 'true' if non-unique</li>\n+   * <li>5 INDEX_QUALIFIER (String) index catalog </li>\n+   * <li>6 INDEX_NAME (String) index name </li>\n+   * <li>7 TYPE (short) the index type (always tableIndexOther) </li>\n+   * <li>8 ORDINAL_POSITION (short) column index (1, 2, ...) </li>\n+   * <li>9 COLUMN_NAME (String) column name </li>\n+   * <li>10 ASC_OR_DESC (String) ascending or descending (always 'A') </li>\n+   * <li>11 CARDINALITY (int) numbers of unique values </li>\n+   * <li>12 PAGES (int) number of pages use (always 0) </li>\n+   * <li>13 FILTER_CONDITION (String) filter condition (always empty) </li>\n+   * <li>14 SORT_TYPE (int) the sort type bit map: 1=DESCENDING,\n+   * 2=NULLS_FIRST, 4=NULLS_LAST </li>\n+   * </ul>\n+   *\n+   * @param catalogPattern null or the catalog name\n+   * @param schemaPattern  null (to get all objects) or a schema name\n+   *                       (uppercase for unquoted names)\n+   * @param tableName      table name (must be specified)\n+   * @param unique         only unique indexes\n+   * @param approximate    is ignored\n+   * @return the list of indexes and columns\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getIndexInfo(String catalogPattern, String schemaPattern,\n+                                String tableName, boolean unique, boolean approximate)\n+      throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getIndexInfo(\" + quote(catalogPattern) + \", \" +\n+            quote(schemaPattern) + \", \" + quote(tableName) + \", \" +\n+            unique + \", \" + approximate + \");\");\n+      }\n+      String uniqueCondition;\n+      if (unique) {\n+        uniqueCondition = \"NON_UNIQUE=FALSE\";\n+      } else {\n+        uniqueCondition = \"TRUE\";\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"TABLE_CATALOG TABLE_CAT, \"\n+          + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+          + \"TABLE_NAME, \"\n+          + \"NON_UNIQUE, \"\n+          + \"TABLE_CATALOG INDEX_QUALIFIER, \"\n+          + \"INDEX_NAME, \"\n+          + \"INDEX_TYPE TYPE, \"\n+          + \"ORDINAL_POSITION, \"\n+          + \"COLUMN_NAME, \"\n+          + \"ASC_OR_DESC, \"\n+          // TODO meta data for number of unique values in an index\n+          + \"CARDINALITY, \"\n+          + \"PAGES, \"\n+          + \"FILTER_CONDITION, \"\n+          + \"SORT_TYPE \"\n+          + \"FROM INFORMATION_SCHEMA.INDEXES \"\n+          + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND (\" + uniqueCondition + \") \"\n+          + \"AND TABLE_NAME = ? \"\n+          + \"ORDER BY NON_UNIQUE, TYPE, TABLE_SCHEM, INDEX_NAME, ORDINAL_POSITION\");\n+      prep.setString(1, getCatalogPattern(catalogPattern));\n+      prep.setString(2, \"\\\\\");\n+      prep.setString(3, getSchemaPattern(schemaPattern));\n+      prep.setString(4, \"\\\\\");\n+      prep.setString(5, tableName);\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the primary key columns for a table. The result set is sorted by\n+   * TABLE_SCHEM, and COLUMN_NAME (and not by KEY_SEQ).\n+   *\n+   * <ul>\n+   * <li>1 TABLE_CAT (String) table catalog</li>\n+   * <li>2 TABLE_SCHEM (String) table schema</li>\n+   * <li>3 TABLE_NAME (String) table name</li>\n+   * <li>4 COLUMN_NAME (String) column name</li>\n+   * <li>5 KEY_SEQ (short) the column index of this column (1,2,...)</li>\n+   * <li>6 PK_NAME (String) the name of the primary key index</li>\n+   * </ul>\n+   *\n+   * @param catalogPattern null or the catalog name\n+   * @param schemaPattern  null (to get all objects) or a schema name\n+   *                       (uppercase for unquoted names)\n+   * @param tableName      table name (must be specified)\n+   * @return the list of primary key columns\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getPrimaryKeys(String catalogPattern,\n+                                  String schemaPattern, String tableName) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getPrimaryKeys(\"\n+            + quote(catalogPattern) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(tableName) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"TABLE_CATALOG TABLE_CAT, \"\n+          + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+          + \"TABLE_NAME, \"\n+          + \"COLUMN_NAME, \"\n+          + \"ORDINAL_POSITION KEY_SEQ, \"\n+          + \"IFNULL(CONSTRAINT_NAME, INDEX_NAME) PK_NAME \"\n+          + \"FROM INFORMATION_SCHEMA.INDEXES \"\n+          + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND TABLE_NAME = ? \"\n+          + \"AND PRIMARY_KEY = TRUE \"\n+          + \"ORDER BY COLUMN_NAME\");\n+      prep.setString(1, getCatalogPattern(catalogPattern));\n+      prep.setString(2, \"\\\\\");\n+      prep.setString(3, getSchemaPattern(schemaPattern));\n+      prep.setString(4, \"\\\\\");\n+      prep.setString(5, tableName);\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Checks if all procedures callable.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean allProceduresAreCallable() {\n+    debugCodeCall(\"allProceduresAreCallable\");\n+    return true;\n+  }\n+\n+  /**\n+   * Checks if it possible to query all tables returned by getTables.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean allTablesAreSelectable() {\n+    debugCodeCall(\"allTablesAreSelectable\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns the database URL for this connection.\n+   *\n+   * @return the url\n+   */\n+  @Override\n+  public String getURL() throws SQLException {\n+    try {\n+      debugCodeCall(\"getURL\");\n+      return conn.getURL();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Returns the user name as passed to DriverManager.getConnection(url, user,\n+   * password).\n+   *\n+   * @return the user name\n+   */\n+  @Override\n+  public String getUserName() throws SQLException {\n+    try {\n+      debugCodeCall(\"getUserName\");\n+      return conn.getUser();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Returns the same as Connection.isReadOnly().\n+   *\n+   * @return if read only optimization is switched on\n+   */\n+  @Override\n+  public boolean isReadOnly() throws SQLException {\n+    try {\n+      debugCodeCall(\"isReadOnly\");\n+      return conn.isReadOnly();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Checks if NULL is sorted high (bigger than anything that is not null).\n+   *\n+   * @return false by default; true if the system property h2.sortNullsHigh is\n+   * set to true\n+   */\n+  @Override\n+  public boolean nullsAreSortedHigh() {\n+    debugCodeCall(\"nullsAreSortedHigh\");\n+    return SysProperties.SORT_NULLS_HIGH;\n+  }\n+\n+  /**\n+   * Checks if NULL is sorted low (smaller than anything that is not null).\n+   *\n+   * @return true by default; false if the system property h2.sortNullsHigh is\n+   * set to true\n+   */\n+  @Override\n+  public boolean nullsAreSortedLow() {\n+    debugCodeCall(\"nullsAreSortedLow\");\n+    return !SysProperties.SORT_NULLS_HIGH;\n+  }\n+\n+  /**\n+   * Checks if NULL is sorted at the beginning (no matter if ASC or DESC is\n+   * used).\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean nullsAreSortedAtStart() {\n+    debugCodeCall(\"nullsAreSortedAtStart\");\n+    return false;\n+  }\n+\n+  /**\n+   * Checks if NULL is sorted at the end (no matter if ASC or DESC is used).\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean nullsAreSortedAtEnd() {\n+    debugCodeCall(\"nullsAreSortedAtEnd\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns the connection that created this object.\n+   *\n+   * @return the connection\n+   */\n+  @Override\n+  public Connection getConnection() {\n+    debugCodeCall(\"getConnection\");\n+    return conn;\n+  }\n+\n+  /**\n+   * Gets the list of procedures. The result set is sorted by PROCEDURE_SCHEM,\n+   * PROCEDURE_NAME, and NUM_INPUT_PARAMS. There are potentially multiple\n+   * procedures with the same name, each with a different number of input\n+   * parameters.\n+   *\n+   * <ul>\n+   * <li>1 PROCEDURE_CAT (String) catalog </li>\n+   * <li>2 PROCEDURE_SCHEM (String) schema </li>\n+   * <li>3 PROCEDURE_NAME (String) name </li>\n+   * <li>4 NUM_INPUT_PARAMS (int) the number of arguments </li>\n+   * <li>5 NUM_OUTPUT_PARAMS (int) for future use, always 0 </li>\n+   * <li>6 NUM_RESULT_SETS (int) for future use, always 0 </li>\n+   * <li>7 REMARKS (String) description </li>\n+   * <li>8 PROCEDURE_TYPE (short) if this procedure returns a result\n+   * (procedureNoResult or procedureReturnsResult) </li>\n+   * <li>9 SPECIFIC_NAME (String) name </li>\n+   * </ul>\n+   *\n+   * @param catalogPattern       null or the catalog name\n+   * @param schemaPattern        null (to get all objects) or a schema name\n+   *                             (uppercase for unquoted names)\n+   * @param procedureNamePattern the procedure name pattern\n+   * @return the procedures\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getProcedures(String catalogPattern, String schemaPattern,\n+                                 String procedureNamePattern) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getProcedures(\"\n+            + quote(catalogPattern) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(procedureNamePattern) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"ALIAS_CATALOG PROCEDURE_CAT, \"\n+          + \"ALIAS_SCHEMA PROCEDURE_SCHEM, \"\n+          + \"ALIAS_NAME PROCEDURE_NAME, \"\n+          + \"COLUMN_COUNT NUM_INPUT_PARAMS, \"\n+          + \"ZERO() NUM_OUTPUT_PARAMS, \"\n+          + \"ZERO() NUM_RESULT_SETS, \"\n+          + \"REMARKS, \"\n+          + \"RETURNS_RESULT PROCEDURE_TYPE, \"\n+          + \"ALIAS_NAME SPECIFIC_NAME \"\n+          + \"FROM INFORMATION_SCHEMA.FUNCTION_ALIASES \"\n+          + \"WHERE ALIAS_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND ALIAS_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND ALIAS_NAME LIKE ? ESCAPE ? \"\n+          + \"ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, NUM_INPUT_PARAMS\");\n+      prep.setString(1, getCatalogPattern(catalogPattern));\n+      prep.setString(2, \"\\\\\");\n+      prep.setString(3, getSchemaPattern(schemaPattern));\n+      prep.setString(4, \"\\\\\");\n+      prep.setString(5, getPattern(procedureNamePattern));\n+      prep.setString(6, \"\\\\\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of procedure columns. The result set is sorted by\n+   * PROCEDURE_SCHEM, PROCEDURE_NAME, NUM_INPUT_PARAMS, and POS.\n+   * There are potentially multiple procedures with the same name, each with a\n+   * different number of input parameters.\n+   *\n+   * <ul>\n+   * <li>1 PROCEDURE_CAT (String) catalog </li>\n+   * <li>2 PROCEDURE_SCHEM (String) schema </li>\n+   * <li>3 PROCEDURE_NAME (String) name </li>\n+   * <li>4 COLUMN_NAME (String) column name </li>\n+   * <li>5 COLUMN_TYPE (short) column type\n+   * (always DatabaseMetaData.procedureColumnIn)</li>\n+   * <li>6 DATA_TYPE (short) sql type </li>\n+   * <li>7 TYPE_NAME (String) type name </li>\n+   * <li>8 PRECISION (int) precision </li>\n+   * <li>9 LENGTH (int) length </li>\n+   * <li>10 SCALE (short) scale </li>\n+   * <li>11 RADIX (int) always 10 </li>\n+   * <li>12 NULLABLE (short) nullable\n+   * (DatabaseMetaData.columnNoNulls for primitive data types,\n+   * DatabaseMetaData.columnNullable otherwise)</li>\n+   * <li>13 REMARKS (String) description </li>\n+   * <li>14 COLUMN_DEF (String) always null </li>\n+   * <li>15 SQL_DATA_TYPE (int) for future use, always 0 </li>\n+   * <li>16 SQL_DATETIME_SUB (int) for future use, always 0 </li>\n+   * <li>17 CHAR_OCTET_LENGTH (int) always null </li>\n+   * <li>18 ORDINAL_POSITION (int) the parameter index\n+   * starting from 1 (0 is the return value) </li>\n+   * <li>19 IS_NULLABLE (String) always \"YES\" </li>\n+   * <li>20 SPECIFIC_NAME (String) name </li>\n+   * </ul>\n+   *\n+   * @param catalogPattern       null or the catalog name\n+   * @param schemaPattern        null (to get all objects) or a schema name\n+   *                             (uppercase for unquoted names)\n+   * @param procedureNamePattern the procedure name pattern\n+   * @param columnNamePattern    the procedure name pattern\n+   * @return the procedure columns\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getProcedureColumns(String catalogPattern,\n+                                       String schemaPattern, String procedureNamePattern,\n+                                       String columnNamePattern) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getProcedureColumns(\"\n+            + quote(catalogPattern) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(procedureNamePattern) + \", \"\n+            + quote(columnNamePattern) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"ALIAS_CATALOG PROCEDURE_CAT, \"\n+          + \"ALIAS_SCHEMA PROCEDURE_SCHEM, \"\n+          + \"ALIAS_NAME PROCEDURE_NAME, \"\n+          + \"COLUMN_NAME, \"\n+          + \"COLUMN_TYPE, \"\n+          + \"DATA_TYPE, \"\n+          + \"TYPE_NAME, \"\n+          + \"PRECISION, \"\n+          + \"PRECISION LENGTH, \"\n+          + \"SCALE, \"\n+          + \"RADIX, \"\n+          + \"NULLABLE, \"\n+          + \"REMARKS, \"\n+          + \"COLUMN_DEFAULT COLUMN_DEF, \"\n+          + \"ZERO() SQL_DATA_TYPE, \"\n+          + \"ZERO() SQL_DATETIME_SUB, \"\n+          + \"ZERO() CHAR_OCTET_LENGTH, \"\n+          + \"POS ORDINAL_POSITION, \"\n+          + \"? IS_NULLABLE, \"\n+          + \"ALIAS_NAME SPECIFIC_NAME \"\n+          + \"FROM INFORMATION_SCHEMA.FUNCTION_COLUMNS \"\n+          + \"WHERE ALIAS_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND ALIAS_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND ALIAS_NAME LIKE ? ESCAPE ? \"\n+          + \"AND COLUMN_NAME LIKE ? ESCAPE ? \"\n+          + \"ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, ORDINAL_POSITION\");\n+      prep.setString(1, \"YES\");\n+      prep.setString(2, getCatalogPattern(catalogPattern));\n+      prep.setString(3, \"\\\\\");\n+      prep.setString(4, getSchemaPattern(schemaPattern));\n+      prep.setString(5, \"\\\\\");\n+      prep.setString(6, getPattern(procedureNamePattern));\n+      prep.setString(7, \"\\\\\");\n+      prep.setString(8, getPattern(columnNamePattern));\n+      prep.setString(9, \"\\\\\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of schemas.\n+   * The result set is sorted by TABLE_SCHEM.\n+   *\n+   * <ul>\n+   * <li>1 TABLE_SCHEM (String) schema name\n+   * </li><li>2 TABLE_CATALOG (String) catalog name\n+   * </li><li>3 IS_DEFAULT (boolean) if this is the default schema\n+   * </li></ul>\n+   *\n+   * @return the schema list\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getSchemas() throws SQLException {\n+    try {\n+      debugCodeCall(\"getSchemas\");\n+      checkClosed();\n+      PreparedStatement prep = conn\n+          .prepareAutoCloseStatement(\"SELECT \"\n+              + \"SCHEMA_NAME TABLE_SCHEM, \"\n+              + \"CATALOG_NAME TABLE_CATALOG, \"\n+              + \" IS_DEFAULT \"\n+              + \"FROM INFORMATION_SCHEMA.SCHEMATA \"\n+              + \"ORDER BY SCHEMA_NAME\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of catalogs.\n+   * The result set is sorted by TABLE_CAT.\n+   *\n+   * <ul>\n+   * <li>1 TABLE_CAT (String) catalog name\n+   * </li></ul>\n+   *\n+   * @return the catalog list\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getCatalogs() throws SQLException {\n+    try {\n+      debugCodeCall(\"getCatalogs\");\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\n+          \"SELECT CATALOG_NAME TABLE_CAT \"\n+              + \"FROM INFORMATION_SCHEMA.CATALOGS\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of table types. This call returns a result set with five\n+   * records: \"SYSTEM TABLE\", \"TABLE\", \"VIEW\", \"TABLE LINK\" and \"EXTERNAL\".\n+   * <ul>\n+   * <li>1 TABLE_TYPE (String) table type\n+   * </li></ul>\n+   *\n+   * @return the table types\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getTableTypes() throws SQLException {\n+    try {\n+      debugCodeCall(\"getTableTypes\");\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"TYPE TABLE_TYPE \"\n+          + \"FROM INFORMATION_SCHEMA.TABLE_TYPES \"\n+          + \"ORDER BY TABLE_TYPE\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of column privileges. The result set is sorted by\n+   * COLUMN_NAME and PRIVILEGE\n+   *\n+   * <ul>\n+   * <li>1 TABLE_CAT (String) table catalog</li>\n+   * <li>2 TABLE_SCHEM (String) table schema</li>\n+   * <li>3 TABLE_NAME (String) table name</li>\n+   * <li>4 COLUMN_NAME (String) column name</li>\n+   * <li>5 GRANTOR (String) grantor of access</li>\n+   * <li>6 GRANTEE (String) grantee of access</li>\n+   * <li>7 PRIVILEGE (String) SELECT, INSERT, UPDATE, DELETE or REFERENCES\n+   * (only one per row)</li>\n+   * <li>8 IS_GRANTABLE (String) YES means the grantee can grant access to\n+   * others</li>\n+   * </ul>\n+   *\n+   * @param catalogPattern    null (to get all objects) or the catalog name\n+   * @param schemaPattern     null (to get all objects) or a schema name\n+   *                          (uppercase for unquoted names)\n+   * @param table             a table name (uppercase for unquoted names)\n+   * @param columnNamePattern null (to get all objects) or a column name\n+   *                          (uppercase for unquoted names)\n+   * @return the list of privileges\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getColumnPrivileges(String catalogPattern,\n+                                       String schemaPattern, String table, String columnNamePattern)\n+      throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getColumnPrivileges(\"\n+            + quote(catalogPattern) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(table) + \", \"\n+            + quote(columnNamePattern) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"TABLE_CATALOG TABLE_CAT, \"\n+          + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+          + \"TABLE_NAME, \"\n+          + \"COLUMN_NAME, \"\n+          + \"GRANTOR, \"\n+          + \"GRANTEE, \"\n+          + \"PRIVILEGE_TYPE PRIVILEGE, \"\n+          + \"IS_GRANTABLE \"\n+          + \"FROM INFORMATION_SCHEMA.COLUMN_PRIVILEGES \"\n+          + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND TABLE_NAME = ? \"\n+          + \"AND COLUMN_NAME LIKE ? ESCAPE ? \"\n+          + \"ORDER BY COLUMN_NAME, PRIVILEGE\");\n+      prep.setString(1, getCatalogPattern(catalogPattern));\n+      prep.setString(2, \"\\\\\");\n+      prep.setString(3, getSchemaPattern(schemaPattern));\n+      prep.setString(4, \"\\\\\");\n+      prep.setString(5, table);\n+      prep.setString(6, getPattern(columnNamePattern));\n+      prep.setString(7, \"\\\\\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of table privileges. The result set is sorted by\n+   * TABLE_SCHEM, TABLE_NAME, and PRIVILEGE.\n+   *\n+   * <ul>\n+   * <li>1 TABLE_CAT (String) table catalog </li>\n+   * <li>2 TABLE_SCHEM (String) table schema </li>\n+   * <li>3 TABLE_NAME (String) table name </li>\n+   * <li>4 GRANTOR (String) grantor of access </li>\n+   * <li>5 GRANTEE (String) grantee of access </li>\n+   * <li>6 PRIVILEGE (String) SELECT, INSERT, UPDATE, DELETE or REFERENCES\n+   * (only one per row) </li>\n+   * <li>7 IS_GRANTABLE (String) YES means the grantee can grant access to\n+   * others </li>\n+   * </ul>\n+   *\n+   * @param catalogPattern   null (to get all objects) or the catalog name\n+   * @param schemaPattern    null (to get all objects) or a schema name\n+   *                         (uppercase for unquoted names)\n+   * @param tableNamePattern null (to get all objects) or a table name\n+   *                         (uppercase for unquoted names)\n+   * @return the list of privileges\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getTablePrivileges(String catalogPattern,\n+                                      String schemaPattern, String tableNamePattern) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getTablePrivileges(\"\n+            + quote(catalogPattern) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(tableNamePattern) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"TABLE_CATALOG TABLE_CAT, \"\n+          + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+          + \"TABLE_NAME, \"\n+          + \"GRANTOR, \"\n+          + \"GRANTEE, \"\n+          + \"PRIVILEGE_TYPE PRIVILEGE, \"\n+          + \"IS_GRANTABLE \"\n+          + \"FROM INFORMATION_SCHEMA.TABLE_PRIVILEGES \"\n+          + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND TABLE_NAME LIKE ? ESCAPE ? \"\n+          + \"ORDER BY TABLE_SCHEM, TABLE_NAME, PRIVILEGE\");\n+      prep.setString(1, getCatalogPattern(catalogPattern));\n+      prep.setString(2, \"\\\\\");\n+      prep.setString(3, getSchemaPattern(schemaPattern));\n+      prep.setString(4, \"\\\\\");\n+      prep.setString(5, getPattern(tableNamePattern));\n+      prep.setString(6, \"\\\\\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of columns that best identifier a row in a table.\n+   * The list is ordered by SCOPE.\n+   *\n+   * <ul>\n+   * <li>1 SCOPE (short) scope of result (always bestRowSession)\n+   * </li><li>2 COLUMN_NAME (String) column name\n+   * </li><li>3 DATA_TYPE (short) SQL data type, see also java.sql.Types\n+   * </li><li>4 TYPE_NAME (String) type name\n+   * </li><li>5 COLUMN_SIZE (int) precision\n+   *         (values larger than 2 GB are returned as 2 GB)\n+   * </li><li>6 BUFFER_LENGTH (int) unused\n+   * </li><li>7 DECIMAL_DIGITS (short) scale\n+   * </li><li>8 PSEUDO_COLUMN (short) (always bestRowNotPseudo)\n+   * </li></ul>\n+   *\n+   * @param catalogPattern null (to get all objects) or the catalog name\n+   * @param schemaPattern  null (to get all objects) or a schema name\n+   *                       (uppercase for unquoted names)\n+   * @param tableName      table name (must be specified)\n+   * @param scope          ignored\n+   * @param nullable       ignored\n+   * @return the primary key index\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getBestRowIdentifier(String catalogPattern,\n+                                        String schemaPattern, String tableName, int scope, boolean nullable)\n+      throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getBestRowIdentifier(\"\n+            + quote(catalogPattern) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(tableName) + \", \"\n+            + scope + \", \" + nullable + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"CAST(? AS SMALLINT) SCOPE, \"\n+          + \"C.COLUMN_NAME, \"\n+          + \"C.DATA_TYPE, \"\n+          + \"C.TYPE_NAME, \"\n+          + \"C.CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n+          + \"C.CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n+          + \"CAST(C.NUMERIC_SCALE AS SMALLINT) DECIMAL_DIGITS, \"\n+          + \"CAST(? AS SMALLINT) PSEUDO_COLUMN \"\n+          + \"FROM INFORMATION_SCHEMA.INDEXES I, \"\n+          + \" INFORMATION_SCHEMA.COLUMNS C \"\n+          + \"WHERE C.TABLE_NAME = I.TABLE_NAME \"\n+          + \"AND C.COLUMN_NAME = I.COLUMN_NAME \"\n+          + \"AND C.TABLE_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND C.TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND C.TABLE_NAME = ? \"\n+          + \"AND I.PRIMARY_KEY = TRUE \"\n+          + \"ORDER BY SCOPE\");\n+      // SCOPE\n+      prep.setInt(1, DatabaseMetaData.bestRowSession);\n+      // PSEUDO_COLUMN\n+      prep.setInt(2, DatabaseMetaData.bestRowNotPseudo);\n+      prep.setString(3, getCatalogPattern(catalogPattern));\n+      prep.setString(4, \"\\\\\");\n+      prep.setString(5, getSchemaPattern(schemaPattern));\n+      prep.setString(6, \"\\\\\");\n+      prep.setString(7, tableName);\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Get the list of columns that are update when any value is updated.\n+   * The result set is always empty.\n+   *\n+   * <ul>\n+   * <li>1 SCOPE (int) not used\n+   * </li><li>2 COLUMN_NAME (String) column name\n+   * </li><li>3 DATA_TYPE (int) SQL data type - see also java.sql.Types\n+   * </li><li>4 TYPE_NAME (String) data type name\n+   * </li><li>5 COLUMN_SIZE (int) precision\n+   *         (values larger than 2 GB are returned as 2 GB)\n+   * </li><li>6 BUFFER_LENGTH (int) length (bytes)\n+   * </li><li>7 DECIMAL_DIGITS (int) scale\n+   * </li><li>8 PSEUDO_COLUMN (int) is this column a pseudo column\n+   * </li></ul>\n+   *\n+   * @param catalog   null (to get all objects) or the catalog name\n+   * @param schema    null (to get all objects) or a schema name\n+   * @param tableName table name (must be specified)\n+   * @return an empty result set\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getVersionColumns(String catalog, String schema,\n+                                     String tableName) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getVersionColumns(\"\n+            + quote(catalog) + \", \"\n+            + quote(schema) + \", \"\n+            + quote(tableName) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"ZERO() SCOPE, \"\n+          + \"COLUMN_NAME, \"\n+          + \"CAST(DATA_TYPE AS INT) DATA_TYPE, \"\n+          + \"TYPE_NAME, \"\n+          + \"NUMERIC_PRECISION COLUMN_SIZE, \"\n+          + \"NUMERIC_PRECISION BUFFER_LENGTH, \"\n+          + \"NUMERIC_PRECISION DECIMAL_DIGITS, \"\n+          + \"ZERO() PSEUDO_COLUMN \"\n+          + \"FROM INFORMATION_SCHEMA.COLUMNS \"\n+          + \"WHERE FALSE\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of primary key columns that are referenced by a table. The\n+   * result set is sorted by PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME,\n+   * FK_NAME, KEY_SEQ.\n+   *\n+   * <ul>\n+   * <li>1 PKTABLE_CAT (String) primary catalog </li>\n+   * <li>2 PKTABLE_SCHEM (String) primary schema </li>\n+   * <li>3 PKTABLE_NAME (String) primary table </li>\n+   * <li>4 PKCOLUMN_NAME (String) primary column </li>\n+   * <li>5 FKTABLE_CAT (String) foreign catalog </li>\n+   * <li>6 FKTABLE_SCHEM (String) foreign schema </li>\n+   * <li>7 FKTABLE_NAME (String) foreign table </li>\n+   * <li>8 FKCOLUMN_NAME (String) foreign column </li>\n+   * <li>9 KEY_SEQ (short) sequence number (1, 2, ...) </li>\n+   * <li>10 UPDATE_RULE (short) action on update (see\n+   * DatabaseMetaData.importedKey...) </li>\n+   * <li>11 DELETE_RULE (short) action on delete (see\n+   * DatabaseMetaData.importedKey...) </li>\n+   * <li>12 FK_NAME (String) foreign key name </li>\n+   * <li>13 PK_NAME (String) primary key name </li>\n+   * <li>14 DEFERRABILITY (short) deferrable or not (always\n+   * importedKeyNotDeferrable) </li>\n+   * </ul>\n+   *\n+   * @param catalogPattern null (to get all objects) or the catalog name\n+   * @param schemaPattern  the schema name of the foreign table\n+   * @param tableName      the name of the foreign table\n+   * @return the result set\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getImportedKeys(String catalogPattern,\n+                                   String schemaPattern, String tableName) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getImportedKeys(\"\n+            + quote(catalogPattern) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(tableName) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n+          + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n+          + \"PKTABLE_NAME PKTABLE_NAME, \"\n+          + \"PKCOLUMN_NAME, \"\n+          + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n+          + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n+          + \"FKTABLE_NAME, \"\n+          + \"FKCOLUMN_NAME, \"\n+          + \"ORDINAL_POSITION KEY_SEQ, \"\n+          + \"UPDATE_RULE, \"\n+          + \"DELETE_RULE, \"\n+          + \"FK_NAME, \"\n+          + \"PK_NAME, \"\n+          + \"DEFERRABILITY \"\n+          + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n+          + \"WHERE FKTABLE_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND FKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND FKTABLE_NAME = ? \"\n+          + \"ORDER BY PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME, FK_NAME, KEY_SEQ\");\n+      prep.setString(1, getCatalogPattern(catalogPattern));\n+      prep.setString(2, \"\\\\\");\n+      prep.setString(3, getSchemaPattern(schemaPattern));\n+      prep.setString(4, \"\\\\\");\n+      prep.setString(5, tableName);\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of foreign key columns that reference a table. The result\n+   * set is sorted by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME,\n+   * KEY_SEQ.\n+   *\n+   * <ul>\n+   * <li>1 PKTABLE_CAT (String) primary catalog </li>\n+   * <li>2 PKTABLE_SCHEM (String) primary schema </li>\n+   * <li>3 PKTABLE_NAME (String) primary table </li>\n+   * <li>4 PKCOLUMN_NAME (String) primary column </li>\n+   * <li>5 FKTABLE_CAT (String) foreign catalog </li>\n+   * <li>6 FKTABLE_SCHEM (String) foreign schema </li>\n+   * <li>7 FKTABLE_NAME (String) foreign table </li>\n+   * <li>8 FKCOLUMN_NAME (String) foreign column </li>\n+   * <li>9 KEY_SEQ (short) sequence number (1,2,...) </li>\n+   * <li>10 UPDATE_RULE (short) action on update (see\n+   * DatabaseMetaData.importedKey...) </li>\n+   * <li>11 DELETE_RULE (short) action on delete (see\n+   * DatabaseMetaData.importedKey...) </li>\n+   * <li>12 FK_NAME (String) foreign key name </li>\n+   * <li>13 PK_NAME (String) primary key name </li>\n+   * <li>14 DEFERRABILITY (short) deferrable or not (always\n+   * importedKeyNotDeferrable) </li>\n+   * </ul>\n+   *\n+   * @param catalogPattern null or the catalog name\n+   * @param schemaPattern  the schema name of the primary table\n+   * @param tableName      the name of the primary table\n+   * @return the result set\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getExportedKeys(String catalogPattern,\n+                                   String schemaPattern, String tableName) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getExportedKeys(\"\n+            + quote(catalogPattern) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(tableName) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n+          + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n+          + \"PKTABLE_NAME PKTABLE_NAME, \"\n+          + \"PKCOLUMN_NAME, \"\n+          + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n+          + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n+          + \"FKTABLE_NAME, \"\n+          + \"FKCOLUMN_NAME, \"\n+          + \"ORDINAL_POSITION KEY_SEQ, \"\n+          + \"UPDATE_RULE, \"\n+          + \"DELETE_RULE, \"\n+          + \"FK_NAME, \"\n+          + \"PK_NAME, \"\n+          + \"DEFERRABILITY \"\n+          + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n+          + \"WHERE PKTABLE_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND PKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND PKTABLE_NAME = ? \"\n+          + \"ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME, KEY_SEQ\");\n+      prep.setString(1, getCatalogPattern(catalogPattern));\n+      prep.setString(2, \"\\\\\");\n+      prep.setString(3, getSchemaPattern(schemaPattern));\n+      prep.setString(4, \"\\\\\");\n+      prep.setString(5, tableName);\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of foreign key columns that references a table, as well as\n+   * the list of primary key columns that are references by a table. The\n+   * result set is sorted by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME,\n+   * FK_NAME, KEY_SEQ.\n+   *\n+   * <ul>\n+   * <li>1 PKTABLE_CAT (String) primary catalog </li>\n+   * <li>2 PKTABLE_SCHEM (String) primary schema </li>\n+   * <li>3 PKTABLE_NAME (String) primary table </li>\n+   * <li>4 PKCOLUMN_NAME (String) primary column </li>\n+   * <li>5 FKTABLE_CAT (String) foreign catalog </li>\n+   * <li>6 FKTABLE_SCHEM (String) foreign schema </li>\n+   * <li>7 FKTABLE_NAME (String) foreign table </li>\n+   * <li>8 FKCOLUMN_NAME (String) foreign column </li>\n+   * <li>9 KEY_SEQ (short) sequence number (1,2,...) </li>\n+   * <li>10 UPDATE_RULE (short) action on update (see\n+   * DatabaseMetaData.importedKey...) </li>\n+   * <li>11 DELETE_RULE (short) action on delete (see\n+   * DatabaseMetaData.importedKey...) </li>\n+   * <li>12 FK_NAME (String) foreign key name </li>\n+   * <li>13 PK_NAME (String) primary key name </li>\n+   * <li>14 DEFERRABILITY (short) deferrable or not (always\n+   * importedKeyNotDeferrable) </li>\n+   * </ul>\n+   *\n+   * @param primaryCatalogPattern null or the catalog name\n+   * @param primarySchemaPattern  the schema name of the primary table\n+   *                              (optional)\n+   * @param primaryTable          the name of the primary table (must be specified)\n+   * @param foreignCatalogPattern null or the catalog name\n+   * @param foreignSchemaPattern  the schema name of the foreign table\n+   *                              (optional)\n+   * @param foreignTable          the name of the foreign table (must be specified)\n+   * @return the result set\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getCrossReference(String primaryCatalogPattern,\n+                                     String primarySchemaPattern, String primaryTable, String foreignCatalogPattern,\n+                                     String foreignSchemaPattern, String foreignTable) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getCrossReference(\"\n+            + quote(primaryCatalogPattern) + \", \"\n+            + quote(primarySchemaPattern) + \", \"\n+            + quote(primaryTable) + \", \"\n+            + quote(foreignCatalogPattern) + \", \"\n+            + quote(foreignSchemaPattern) + \", \"\n+            + quote(foreignTable) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n+          + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n+          + \"PKTABLE_NAME PKTABLE_NAME, \"\n+          + \"PKCOLUMN_NAME, \"\n+          + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n+          + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n+          + \"FKTABLE_NAME, \"\n+          + \"FKCOLUMN_NAME, \"\n+          + \"ORDINAL_POSITION KEY_SEQ, \"\n+          + \"UPDATE_RULE, \"\n+          + \"DELETE_RULE, \"\n+          + \"FK_NAME, \"\n+          + \"PK_NAME, \"\n+          + \"DEFERRABILITY \"\n+          + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n+          + \"WHERE PKTABLE_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND PKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND PKTABLE_NAME = ? \"\n+          + \"AND FKTABLE_CATALOG LIKE ? ESCAPE ? \"\n+          + \"AND FKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n+          + \"AND FKTABLE_NAME = ? \"\n+          + \"ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME, KEY_SEQ\");\n+      prep.setString(1, getCatalogPattern(primaryCatalogPattern));\n+      prep.setString(2, \"\\\\\");\n+      prep.setString(3, getSchemaPattern(primarySchemaPattern));\n+      prep.setString(4, \"\\\\\");\n+      prep.setString(5, primaryTable);\n+      prep.setString(6, getCatalogPattern(foreignCatalogPattern));\n+      prep.setString(7, \"\\\\\");\n+      prep.setString(8, getSchemaPattern(foreignSchemaPattern));\n+      prep.setString(9, \"\\\\\");\n+      prep.setString(10, foreignTable);\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of user-defined data types.\n+   * This call returns an empty result set.\n+   *\n+   * <ul>\n+   * <li>1 TYPE_CAT (String) catalog\n+   * </li><li>2 TYPE_SCHEM (String) schema\n+   * </li><li>3 TYPE_NAME (String) type name\n+   * </li><li>4 CLASS_NAME (String) Java class\n+   * </li><li>5 DATA_TYPE (short) SQL Type - see also java.sql.Types\n+   * </li><li>6 REMARKS (String) description\n+   * </li><li>7 BASE_TYPE (short) base type - see also java.sql.Types\n+   * </li></ul>\n+   *\n+   * @param catalog         ignored\n+   * @param schemaPattern   ignored\n+   * @param typeNamePattern ignored\n+   * @param types           ignored\n+   * @return an empty result set\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getUDTs(String catalog, String schemaPattern,\n+                           String typeNamePattern, int[] types) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getUDTs(\"\n+            + quote(catalog) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(typeNamePattern) + \", \"\n+            + quoteIntArray(types) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"CAST(NULL AS VARCHAR) TYPE_CAT, \"\n+          + \"CAST(NULL AS VARCHAR) TYPE_SCHEM, \"\n+          + \"CAST(NULL AS VARCHAR) TYPE_NAME, \"\n+          + \"CAST(NULL AS VARCHAR) CLASS_NAME, \"\n+          + \"CAST(NULL AS SMALLINT) DATA_TYPE, \"\n+          + \"CAST(NULL AS VARCHAR) REMARKS, \"\n+          + \"CAST(NULL AS SMALLINT) BASE_TYPE \"\n+          + \"FROM DUAL WHERE FALSE\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Gets the list of data types. The result set is sorted by DATA_TYPE and\n+   * afterwards by how closely the data type maps to the corresponding JDBC\n+   * SQL type (best match first).\n+   *\n+   * <ul>\n+   * <li>1 TYPE_NAME (String) type name </li>\n+   * <li>2 DATA_TYPE (short) SQL data type - see also java.sql.Types </li>\n+   * <li>3 PRECISION (int) maximum precision </li>\n+   * <li>4 LITERAL_PREFIX (String) prefix used to quote a literal </li>\n+   * <li>5 LITERAL_SUFFIX (String) suffix used to quote a literal </li>\n+   * <li>6 CREATE_PARAMS (String) parameters used (may be null) </li>\n+   * <li>7 NULLABLE (short) typeNoNulls (NULL not allowed) or typeNullable\n+   * </li>\n+   * <li>8 CASE_SENSITIVE (boolean) case sensitive </li>\n+   * <li>9 SEARCHABLE (short) typeSearchable </li>\n+   * <li>10 UNSIGNED_ATTRIBUTE (boolean) unsigned </li>\n+   * <li>11 FIXED_PREC_SCALE (boolean) fixed precision </li>\n+   * <li>12 AUTO_INCREMENT (boolean) auto increment </li>\n+   * <li>13 LOCAL_TYPE_NAME (String) localized version of the data type </li>\n+   * <li>14 MINIMUM_SCALE (short) minimum scale </li>\n+   * <li>15 MAXIMUM_SCALE (short) maximum scale </li>\n+   * <li>16 SQL_DATA_TYPE (int) unused </li>\n+   * <li>17 SQL_DATETIME_SUB (int) unused </li>\n+   * <li>18 NUM_PREC_RADIX (int) 2 for binary, 10 for decimal </li>\n+   * </ul>\n+   *\n+   * @return the list of data types\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getTypeInfo() throws SQLException {\n+    try {\n+      debugCodeCall(\"getTypeInfo\");\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"TYPE_NAME, \"\n+          + \"DATA_TYPE, \"\n+          + \"PRECISION, \"\n+          + \"PREFIX LITERAL_PREFIX, \"\n+          + \"SUFFIX LITERAL_SUFFIX, \"\n+          + \"PARAMS CREATE_PARAMS, \"\n+          + \"NULLABLE, \"\n+          + \"CASE_SENSITIVE, \"\n+          + \"SEARCHABLE, \"\n+          + \"FALSE UNSIGNED_ATTRIBUTE, \"\n+          + \"FALSE FIXED_PREC_SCALE, \"\n+          + \"AUTO_INCREMENT, \"\n+          + \"TYPE_NAME LOCAL_TYPE_NAME, \"\n+          + \"MINIMUM_SCALE, \"\n+          + \"MAXIMUM_SCALE, \"\n+          + \"DATA_TYPE SQL_DATA_TYPE, \"\n+          + \"ZERO() SQL_DATETIME_SUB, \"\n+          + \"RADIX NUM_PREC_RADIX \"\n+          + \"FROM INFORMATION_SCHEMA.TYPE_INFO \"\n+          + \"ORDER BY DATA_TYPE, POS\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Checks if this database store data in local files.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean usesLocalFiles() {\n+    debugCodeCall(\"usesLocalFiles\");\n+    return true;\n+  }\n+\n+  /**\n+   * Checks if this database use one file per table.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean usesLocalFilePerTable() {\n+    debugCodeCall(\"usesLocalFilePerTable\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns the string used to quote identifiers.\n+   *\n+   * @return a double quote\n+   */\n+  @Override\n+  public String getIdentifierQuoteString() {\n+    debugCodeCall(\"getIdentifierQuoteString\");\n+    return \"\\\"\";\n+  }\n+\n+  /**\n+   * Gets the comma-separated list of all SQL keywords that are not supported\n+   * as table/column/index name, in addition to the SQL-2003 keywords. The list\n+   * returned is:\n+   * <pre>\n+   * LIMIT,MINUS,OFFSET,ROWNUM,SYSDATE,SYSTIME,SYSTIMESTAMP,TODAY\n+   * </pre>\n+   * The complete list of keywords (including SQL-2003 keywords) is:\n+   * <pre>\n+   * ALL, CHECK, CONSTRAINT, CROSS, CURRENT_DATE, CURRENT_TIME,\n+   * CURRENT_TIMESTAMP, DISTINCT, EXCEPT, EXISTS, FALSE, FETCH, FOR, FOREIGN,\n+   * FROM, FULL, GROUP, HAVING, INNER, INTERSECT, IS, JOIN, LIKE, LIMIT,\n+   * MINUS, NATURAL, NOT, NULL, OFFSET, ON, ORDER, PRIMARY, ROWNUM, SELECT,\n+   * SYSDATE, SYSTIME, SYSTIMESTAMP, TODAY, TRUE, UNION, UNIQUE, WHERE, WITH\n+   * </pre>\n+   *\n+   * @return a list of additional the keywords\n+   */\n+  @Override\n+  public String getSQLKeywords() {\n+    debugCodeCall(\"getSQLKeywords\");\n+    return \"LIMIT,MINUS,OFFSET,ROWNUM,SYSDATE,SYSTIME,SYSTIMESTAMP,TODAY\";\n+  }\n+\n+  /**\n+   * Returns the list of numeric functions supported by this database.\n+   *\n+   * @return the list\n+   */\n+  @Override\n+  public String getNumericFunctions() throws SQLException {\n+    debugCodeCall(\"getNumericFunctions\");\n+    return getFunctions(\"Functions (Numeric)\");\n+  }\n+\n+  /**\n+   * Returns the list of string functions supported by this database.\n+   *\n+   * @return the list\n+   */\n+  @Override\n+  public String getStringFunctions() throws SQLException {\n+    debugCodeCall(\"getStringFunctions\");\n+    return getFunctions(\"Functions (String)\");\n+  }\n+\n+  /**\n+   * Returns the list of system functions supported by this database.\n+   *\n+   * @return the list\n+   */\n+  @Override\n+  public String getSystemFunctions() throws SQLException {\n+    debugCodeCall(\"getSystemFunctions\");\n+    return getFunctions(\"Functions (System)\");\n+  }\n+\n+  /**\n+   * Returns the list of date and time functions supported by this database.\n+   *\n+   * @return the list\n+   */\n+  @Override\n+  public String getTimeDateFunctions() throws SQLException {\n+    debugCodeCall(\"getTimeDateFunctions\");\n+    return getFunctions(\"Functions (Time and Date)\");\n+  }\n+\n+  private String getFunctions(String section) throws SQLException {\n+    try {\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT TOPIC \"\n+          + \"FROM INFORMATION_SCHEMA.HELP WHERE SECTION = ?\");\n+      prep.setString(1, section);\n+      ResultSet rs = prep.executeQuery();\n+      StatementBuilder buff = new StatementBuilder();\n+      while (rs.next()) {\n+        String s = rs.getString(1).trim();\n+        String[] array = StringUtils.arraySplit(s, ',', true);\n+        for (String a : array) {\n+          buff.appendExceptFirst(\",\");\n+          String f = a.trim();\n+          if (f.indexOf(' ') >= 0) {\n+            // remove 'Function' from 'INSERT Function'\n+            f = f.substring(0, f.indexOf(' ')).trim();\n+          }\n+          buff.append(f);\n         }\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether table correlation names (table alias) are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsTableCorrelationNames() {\n-        debugCodeCall(\"supportsTableCorrelationNames\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether table correlation names (table alias) are restricted to\n-     * be different than table names.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsDifferentTableCorrelationNames() {\n-        debugCodeCall(\"supportsDifferentTableCorrelationNames\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether expression in ORDER BY are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsExpressionsInOrderBy() {\n-        debugCodeCall(\"supportsExpressionsInOrderBy\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether ORDER BY is supported if the column is not in the SELECT\n-     * list.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsOrderByUnrelated() {\n-        debugCodeCall(\"supportsOrderByUnrelated\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether GROUP BY is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsGroupBy() {\n-        debugCodeCall(\"supportsGroupBy\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether GROUP BY is supported if the column is not in the SELECT\n-     * list.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsGroupByUnrelated() {\n-        debugCodeCall(\"supportsGroupByUnrelated\");\n-        return true;\n-    }\n-\n-    /**\n-     * Checks whether a GROUP BY clause can use columns that are not in the\n-     * SELECT clause, provided that it specifies all the columns in the SELECT\n-     * clause.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsGroupByBeyondSelect() {\n-        debugCodeCall(\"supportsGroupByBeyondSelect\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether LIKE... ESCAPE is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsLikeEscapeClause() {\n-        debugCodeCall(\"supportsLikeEscapeClause\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether multiple result sets are supported.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsMultipleResultSets() {\n-        debugCodeCall(\"supportsMultipleResultSets\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether multiple transactions (on different connections) are\n-     * supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsMultipleTransactions() {\n-        debugCodeCall(\"supportsMultipleTransactions\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether columns with NOT NULL are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsNonNullableColumns() {\n-        debugCodeCall(\"supportsNonNullableColumns\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether ODBC Minimum SQL grammar is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsMinimumSQLGrammar() {\n-        debugCodeCall(\"supportsMinimumSQLGrammar\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether ODBC Core SQL grammar is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsCoreSQLGrammar() {\n-        debugCodeCall(\"supportsCoreSQLGrammar\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether ODBC Extended SQL grammar is supported.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsExtendedSQLGrammar() {\n-        debugCodeCall(\"supportsExtendedSQLGrammar\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether SQL-92 entry level grammar is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsANSI92EntryLevelSQL() {\n-        debugCodeCall(\"supportsANSI92EntryLevelSQL\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether SQL-92 intermediate level grammar is supported.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsANSI92IntermediateSQL() {\n-        debugCodeCall(\"supportsANSI92IntermediateSQL\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether SQL-92 full level grammar is supported.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsANSI92FullSQL() {\n-        debugCodeCall(\"supportsANSI92FullSQL\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether referential integrity is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsIntegrityEnhancementFacility() {\n-        debugCodeCall(\"supportsIntegrityEnhancementFacility\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether outer joins are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsOuterJoins() {\n-        debugCodeCall(\"supportsOuterJoins\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether full outer joins are supported.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsFullOuterJoins() {\n-        debugCodeCall(\"supportsFullOuterJoins\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether limited outer joins are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsLimitedOuterJoins() {\n-        debugCodeCall(\"supportsLimitedOuterJoins\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns the term for \"schema\".\n-     *\n-     * @return \"schema\"\n-     */\n-    @Override\n-    public String getSchemaTerm() {\n-        debugCodeCall(\"getSchemaTerm\");\n-        return \"schema\";\n-    }\n-\n-    /**\n-     * Returns the term for \"procedure\".\n-     *\n-     * @return \"procedure\"\n-     */\n-    @Override\n-    public String getProcedureTerm() {\n-        debugCodeCall(\"getProcedureTerm\");\n-        return \"procedure\";\n-    }\n-\n-    /**\n-     * Returns the term for \"catalog\".\n-     *\n-     * @return \"catalog\"\n-     */\n-    @Override\n-    public String getCatalogTerm() {\n-        debugCodeCall(\"getCatalogTerm\");\n-        return \"catalog\";\n-    }\n-\n-    /**\n-     * Returns whether the catalog is at the beginning.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean isCatalogAtStart() {\n-        debugCodeCall(\"isCatalogAtStart\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns the catalog separator.\n-     *\n-     * @return \".\"\n-     */\n-    @Override\n-    public String getCatalogSeparator() {\n-        debugCodeCall(\"getCatalogSeparator\");\n-        return \".\";\n-    }\n-\n-    /**\n-     * Returns whether the schema name in INSERT, UPDATE, DELETE is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSchemasInDataManipulation() {\n-        debugCodeCall(\"supportsSchemasInDataManipulation\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether the schema name in procedure calls is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSchemasInProcedureCalls() {\n-        debugCodeCall(\"supportsSchemasInProcedureCalls\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether the schema name in CREATE TABLE is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSchemasInTableDefinitions() {\n-        debugCodeCall(\"supportsSchemasInTableDefinitions\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether the schema name in CREATE INDEX is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSchemasInIndexDefinitions() {\n-        debugCodeCall(\"supportsSchemasInIndexDefinitions\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether the schema name in GRANT is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSchemasInPrivilegeDefinitions() {\n-        debugCodeCall(\"supportsSchemasInPrivilegeDefinitions\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether the catalog name in INSERT, UPDATE, DELETE is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsCatalogsInDataManipulation() {\n-        debugCodeCall(\"supportsCatalogsInDataManipulation\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether the catalog name in procedure calls is supported.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsCatalogsInProcedureCalls() {\n-        debugCodeCall(\"supportsCatalogsInProcedureCalls\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether the catalog name in CREATE TABLE is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsCatalogsInTableDefinitions() {\n-        debugCodeCall(\"supportsCatalogsInTableDefinitions\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether the catalog name in CREATE INDEX is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsCatalogsInIndexDefinitions() {\n-        debugCodeCall(\"supportsCatalogsInIndexDefinitions\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether the catalog name in GRANT is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsCatalogsInPrivilegeDefinitions() {\n-        debugCodeCall(\"supportsCatalogsInPrivilegeDefinitions\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether positioned deletes are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsPositionedDelete() {\n-        debugCodeCall(\"supportsPositionedDelete\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether positioned updates are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsPositionedUpdate() {\n-        debugCodeCall(\"supportsPositionedUpdate\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether SELECT ... FOR UPDATE is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSelectForUpdate() {\n-        debugCodeCall(\"supportsSelectForUpdate\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether stored procedures are supported.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsStoredProcedures() {\n-        debugCodeCall(\"supportsStoredProcedures\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether subqueries (SELECT) in comparisons are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSubqueriesInComparisons() {\n-        debugCodeCall(\"supportsSubqueriesInComparisons\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether SELECT in EXISTS is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSubqueriesInExists() {\n-        debugCodeCall(\"supportsSubqueriesInExists\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether IN(SELECT...) is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSubqueriesInIns() {\n-        debugCodeCall(\"supportsSubqueriesInIns\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether subqueries in quantified expression are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSubqueriesInQuantifieds() {\n-        debugCodeCall(\"supportsSubqueriesInQuantifieds\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether correlated subqueries are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsCorrelatedSubqueries() {\n-        debugCodeCall(\"supportsCorrelatedSubqueries\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether UNION SELECT is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsUnion() {\n-        debugCodeCall(\"supportsUnion\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether UNION ALL SELECT is supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsUnionAll() {\n-        debugCodeCall(\"supportsUnionAll\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether open result sets across commits are supported.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsOpenCursorsAcrossCommit() {\n-        debugCodeCall(\"supportsOpenCursorsAcrossCommit\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether open result sets across rollback are supported.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsOpenCursorsAcrossRollback() {\n-        debugCodeCall(\"supportsOpenCursorsAcrossRollback\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether open statements across commit are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsOpenStatementsAcrossCommit() {\n-        debugCodeCall(\"supportsOpenStatementsAcrossCommit\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether open statements across rollback are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsOpenStatementsAcrossRollback() {\n-        debugCodeCall(\"supportsOpenStatementsAcrossRollback\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether transactions are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsTransactions() {\n-        debugCodeCall(\"supportsTransactions\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether a specific transaction isolation level is supported.\n-     *\n-     * @param level the transaction isolation level (Connection.TRANSACTION_*)\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsTransactionIsolationLevel(int level) throws SQLException {\n-        debugCodeCall(\"supportsTransactionIsolationLevel\");\n-        if (level == Connection.TRANSACTION_READ_UNCOMMITTED) {\n-            // currently the combination of LOCK_MODE=0 and MULTI_THREADED\n-            // is not supported, also see code in Database#setLockMode(int)\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\n-                    \"SELECT VALUE FROM INFORMATION_SCHEMA.SETTINGS WHERE NAME=?\");\n-            prep.setString(1, \"MULTI_THREADED\");\n-            ResultSet rs = prep.executeQuery();\n-            return !rs.next() || !rs.getString(1).equals(\"1\");\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether data manipulation and CREATE/DROP is supported in\n-     * transactions.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsDataDefinitionAndDataManipulationTransactions() {\n-        debugCodeCall(\"supportsDataDefinitionAndDataManipulationTransactions\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether only data manipulations are supported in transactions.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsDataManipulationTransactionsOnly() {\n-        debugCodeCall(\"supportsDataManipulationTransactionsOnly\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether CREATE/DROP commit an open transaction.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean dataDefinitionCausesTransactionCommit() {\n-        debugCodeCall(\"dataDefinitionCausesTransactionCommit\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether CREATE/DROP do not affect transactions.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean dataDefinitionIgnoredInTransactions() {\n-        debugCodeCall(\"dataDefinitionIgnoredInTransactions\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether a specific result set type is supported.\n-     * ResultSet.TYPE_SCROLL_SENSITIVE is not supported.\n-     *\n-     * @param type the result set type\n-     * @return true for all types except ResultSet.TYPE_FORWARD_ONLY\n-     */\n-    @Override\n-    public boolean supportsResultSetType(int type) {\n-        debugCodeCall(\"supportsResultSetType\", type);\n-        return type != ResultSet.TYPE_SCROLL_SENSITIVE;\n-    }\n-\n-    /**\n-     * Returns whether a specific result set concurrency is supported.\n-     * ResultSet.TYPE_SCROLL_SENSITIVE is not supported.\n-     *\n-     * @param type the result set type\n-     * @param concurrency the result set concurrency\n-     * @return true if the type is not ResultSet.TYPE_SCROLL_SENSITIVE\n-     */\n-    @Override\n-    public boolean supportsResultSetConcurrency(int type, int concurrency) {\n-        if (isDebugEnabled()) {\n-            debugCode(\"supportsResultSetConcurrency(\"+type+\", \"+concurrency+\");\");\n-        }\n-        return type != ResultSet.TYPE_SCROLL_SENSITIVE;\n-    }\n-\n-    /**\n-     * Returns whether own updates are visible.\n-     *\n-     * @param type the result set type\n-     * @return true\n-     */\n-    @Override\n-    public boolean ownUpdatesAreVisible(int type) {\n-        debugCodeCall(\"ownUpdatesAreVisible\", type);\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether own deletes are visible.\n-     *\n-     * @param type the result set type\n-     * @return false\n-     */\n-    @Override\n-    public boolean ownDeletesAreVisible(int type) {\n-        debugCodeCall(\"ownDeletesAreVisible\", type);\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether own inserts are visible.\n-     *\n-     * @param type the result set type\n-     * @return false\n-     */\n-    @Override\n-    public boolean ownInsertsAreVisible(int type) {\n-        debugCodeCall(\"ownInsertsAreVisible\", type);\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether other updates are visible.\n-     *\n-     * @param type the result set type\n-     * @return false\n-     */\n-    @Override\n-    public boolean othersUpdatesAreVisible(int type) {\n-        debugCodeCall(\"othersUpdatesAreVisible\", type);\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether other deletes are visible.\n-     *\n-     * @param type the result set type\n-     * @return false\n-     */\n-    @Override\n-    public boolean othersDeletesAreVisible(int type) {\n-        debugCodeCall(\"othersDeletesAreVisible\", type);\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether other inserts are visible.\n-     *\n-     * @param type the result set type\n-     * @return false\n-     */\n-    @Override\n-    public boolean othersInsertsAreVisible(int type) {\n-        debugCodeCall(\"othersInsertsAreVisible\", type);\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether updates are detected.\n-     *\n-     * @param type the result set type\n-     * @return false\n-     */\n-    @Override\n-    public boolean updatesAreDetected(int type) {\n-        debugCodeCall(\"updatesAreDetected\", type);\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether deletes are detected.\n-     *\n-     * @param type the result set type\n-     * @return false\n-     */\n-    @Override\n-    public boolean deletesAreDetected(int type) {\n-        debugCodeCall(\"deletesAreDetected\", type);\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether inserts are detected.\n-     *\n-     * @param type the result set type\n-     * @return false\n-     */\n-    @Override\n-    public boolean insertsAreDetected(int type) {\n-        debugCodeCall(\"insertsAreDetected\", type);\n-        return false;\n-    }\n-\n-    /**\n-     * Returns whether batch updates are supported.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsBatchUpdates() {\n-        debugCodeCall(\"supportsBatchUpdates\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether the maximum row size includes blobs.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean doesMaxRowSizeIncludeBlobs() {\n-        debugCodeCall(\"doesMaxRowSizeIncludeBlobs\");\n-        return false;\n-    }\n-\n-    /**\n-     * Returns the default transaction isolation level.\n-     *\n-     * @return Connection.TRANSACTION_READ_COMMITTED\n-     */\n-    @Override\n-    public int getDefaultTransactionIsolation() {\n-        debugCodeCall(\"getDefaultTransactionIsolation\");\n-        return Connection.TRANSACTION_READ_COMMITTED;\n-    }\n-\n-    /**\n-     * Checks if for CREATE TABLE Test(ID INT), getTables returns Test as the\n-     * table name.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsMixedCaseIdentifiers() {\n-        debugCodeCall(\"supportsMixedCaseIdentifiers\");\n-        return false;\n-    }\n-\n-    /**\n-     * Checks if a table created with CREATE TABLE \"Test\"(ID INT) is a different\n-     * table than a table created with CREATE TABLE TEST(ID INT).\n-     *\n-     * @return true usually, and false in MySQL mode\n-     */\n-    @Override\n-    public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\n-        debugCodeCall(\"supportsMixedCaseQuotedIdentifiers\");\n-        String m = conn.getMode();\n-        return !m.equals(\"MySQL\");\n-    }\n-\n-    /**\n-     * Checks if for CREATE TABLE Test(ID INT), getTables returns TEST as the\n-     * table name.\n-     *\n-     * @return true usually, and false in MySQL mode\n-     */\n-    @Override\n-    public boolean storesUpperCaseIdentifiers() throws SQLException {\n-        debugCodeCall(\"storesUpperCaseIdentifiers\");\n-        String m = conn.getMode();\n-        return !m.equals(\"MySQL\");\n-    }\n-\n-    /**\n-     * Checks if for CREATE TABLE Test(ID INT), getTables returns test as the\n-     * table name.\n-     *\n-     * @return false usually, and true in MySQL mode\n-     */\n-    @Override\n-    public boolean storesLowerCaseIdentifiers() throws SQLException {\n-        debugCodeCall(\"storesLowerCaseIdentifiers\");\n-        String m = conn.getMode();\n-        return m.equals(\"MySQL\");\n-    }\n-\n-    /**\n-     * Checks if for CREATE TABLE Test(ID INT), getTables returns Test as the\n-     * table name.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean storesMixedCaseIdentifiers() {\n-        debugCodeCall(\"storesMixedCaseIdentifiers\");\n-        return false;\n-    }\n-\n-    /**\n-     * Checks if for CREATE TABLE \"Test\"(ID INT), getTables returns TEST as the\n-     * table name.\n-     *\n-     * @return false usually, and true in MySQL mode\n-     */\n-    @Override\n-    public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {\n-        debugCodeCall(\"storesUpperCaseQuotedIdentifiers\");\n-        String m = conn.getMode();\n-        return m.equals(\"MySQL\");\n-    }\n-\n-    /**\n-     * Checks if for CREATE TABLE \"Test\"(ID INT), getTables returns test as the\n-     * table name.\n-     *\n-     * @return false usually, and true in MySQL mode\n-     */\n-    @Override\n-    public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {\n-        debugCodeCall(\"storesLowerCaseQuotedIdentifiers\");\n-        String m = conn.getMode();\n-        return m.equals(\"MySQL\");\n-    }\n-\n-    /**\n-     * Checks if for CREATE TABLE \"Test\"(ID INT), getTables returns Test as the\n-     * table name.\n-     *\n-     * @return true usually, and false in MySQL mode\n-     */\n-    @Override\n-    public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {\n-        debugCodeCall(\"storesMixedCaseQuotedIdentifiers\");\n-        String m = conn.getMode();\n-        return !m.equals(\"MySQL\");\n-    }\n-\n-    /**\n-     * Returns the maximum length for hex values (characters).\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxBinaryLiteralLength() {\n-        debugCodeCall(\"getMaxBinaryLiteralLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length for literals.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxCharLiteralLength() {\n-        debugCodeCall(\"getMaxCharLiteralLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length for column names.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxColumnNameLength() {\n-        debugCodeCall(\"getMaxColumnNameLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum number of columns in GROUP BY.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxColumnsInGroupBy() {\n-        debugCodeCall(\"getMaxColumnsInGroupBy\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum number of columns in CREATE INDEX.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxColumnsInIndex() {\n-        debugCodeCall(\"getMaxColumnsInIndex\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum number of columns in ORDER BY.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxColumnsInOrderBy() {\n-        debugCodeCall(\"getMaxColumnsInOrderBy\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum number of columns in SELECT.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxColumnsInSelect() {\n-        debugCodeCall(\"getMaxColumnsInSelect\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum number of columns in CREATE TABLE.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxColumnsInTable() {\n-        debugCodeCall(\"getMaxColumnsInTable\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum number of open connection.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxConnections() {\n-        debugCodeCall(\"getMaxConnections\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length for a cursor name.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxCursorNameLength() {\n-        debugCodeCall(\"getMaxCursorNameLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length for an index (in bytes).\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxIndexLength() {\n-        debugCodeCall(\"getMaxIndexLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length for a schema name.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxSchemaNameLength() {\n-        debugCodeCall(\"getMaxSchemaNameLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length for a procedure name.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxProcedureNameLength() {\n-        debugCodeCall(\"getMaxProcedureNameLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length for a catalog name.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxCatalogNameLength() {\n-        debugCodeCall(\"getMaxCatalogNameLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum size of a row (in bytes).\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxRowSize() {\n-        debugCodeCall(\"getMaxRowSize\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length of a statement.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxStatementLength() {\n-        debugCodeCall(\"getMaxStatementLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum number of open statements.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxStatements() {\n-        debugCodeCall(\"getMaxStatements\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length for a table name.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxTableNameLength() {\n-        debugCodeCall(\"getMaxTableNameLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum number of tables in a SELECT.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxTablesInSelect() {\n-        debugCodeCall(\"getMaxTablesInSelect\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Returns the maximum length for a user name.\n-     *\n-     * @return 0 for limit is unknown\n-     */\n-    @Override\n-    public int getMaxUserNameLength() {\n-        debugCodeCall(\"getMaxUserNameLength\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Does the database support savepoints.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsSavepoints() {\n-        debugCodeCall(\"supportsSavepoints\");\n-        return true;\n-    }\n-\n-    /**\n-     * Does the database support named parameters.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsNamedParameters() {\n-        debugCodeCall(\"supportsNamedParameters\");\n-        return false;\n-    }\n-\n-    /**\n-     * Does the database support multiple open result sets.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsMultipleOpenResults() {\n-        debugCodeCall(\"supportsMultipleOpenResults\");\n-        return true;\n-    }\n-\n-    /**\n-     * Does the database support getGeneratedKeys.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsGetGeneratedKeys() {\n-        debugCodeCall(\"supportsGetGeneratedKeys\");\n-        return true;\n-    }\n-\n-    /**\n-     * [Not supported]\n-     */\n-    @Override\n-    public ResultSet getSuperTypes(String catalog, String schemaPattern,\n-            String typeNamePattern) throws SQLException {\n-        throw unsupported(\"superTypes\");\n-    }\n-\n-    /**\n-     * Get the list of super tables of a table. This method currently returns an\n-     * empty result set.\n-     * <ul>\n-     * <li>1 TABLE_CAT (String) table catalog</li>\n-     * <li>2 TABLE_SCHEM (String) table schema</li>\n-     * <li>3 TABLE_NAME (String) table name</li>\n-     * <li>4 SUPERTABLE_NAME (String) the name of the super table</li>\n-     * </ul>\n-     *\n-     * @param catalog null (to get all objects) or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param tableNamePattern null (to get all objects) or a table name pattern\n-     *            (uppercase for unquoted names)\n-     * @return an empty result set\n-     */\n-    @Override\n-    public ResultSet getSuperTables(String catalog, String schemaPattern,\n-            String tableNamePattern) throws SQLException {\n-        try {\n-            if (isDebugEnabled()) {\n-                debugCode(\"getSuperTables(\"\n-                        +quote(catalog)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableNamePattern)+\");\");\n-            }\n-            checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"CATALOG_NAME TABLE_CAT, \"\n-                    + \"CATALOG_NAME TABLE_SCHEM, \"\n-                    + \"CATALOG_NAME TABLE_NAME, \"\n-                    + \"CATALOG_NAME SUPERTABLE_NAME \"\n-                    + \"FROM INFORMATION_SCHEMA.CATALOGS \"\n-                    + \"WHERE FALSE\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * [Not supported]\n-     */\n-    @Override\n-    public ResultSet getAttributes(String catalog, String schemaPattern,\n-            String typeNamePattern, String attributeNamePattern)\n-            throws SQLException {\n-        throw unsupported(\"attributes\");\n-    }\n-\n-    /**\n-     * Does this database supports a result set holdability.\n-     *\n-     * @param holdability ResultSet.HOLD_CURSORS_OVER_COMMIT or\n-     *            CLOSE_CURSORS_AT_COMMIT\n-     * @return true if the holdability is ResultSet.CLOSE_CURSORS_AT_COMMIT\n-     */\n-    @Override\n-    public boolean supportsResultSetHoldability(int holdability) {\n-        debugCodeCall(\"supportsResultSetHoldability\", holdability);\n-        return holdability == ResultSet.CLOSE_CURSORS_AT_COMMIT;\n-    }\n-\n-    /**\n-     * Gets the result set holdability.\n-     *\n-     * @return ResultSet.CLOSE_CURSORS_AT_COMMIT\n-     */\n-    @Override\n-    public int getResultSetHoldability() {\n-        debugCodeCall(\"getResultSetHoldability\");\n-        return ResultSet.CLOSE_CURSORS_AT_COMMIT;\n-    }\n-\n-    /**\n-     * Gets the major version of the database.\n-     *\n-     * @return the major version\n-     */\n-    @Override\n-    public int getDatabaseMajorVersion() {\n-        debugCodeCall(\"getDatabaseMajorVersion\");\n-        return Constants.VERSION_MAJOR;\n-    }\n-\n-    /**\n-     * Gets the minor version of the database.\n-     *\n-     * @return the minor version\n-     */\n-    @Override\n-    public int getDatabaseMinorVersion() {\n-        debugCodeCall(\"getDatabaseMinorVersion\");\n-        return Constants.VERSION_MINOR;\n-    }\n-\n-    /**\n-     * Gets the major version of the supported JDBC API.\n-     *\n-     * @return the major version (4)\n-     */\n-    @Override\n-    public int getJDBCMajorVersion() {\n-        debugCodeCall(\"getJDBCMajorVersion\");\n-        return 4;\n-    }\n-\n-    /**\n-     * Gets the minor version of the supported JDBC API.\n-     *\n-     * @return the minor version (0)\n-     */\n-    @Override\n-    public int getJDBCMinorVersion() {\n-        debugCodeCall(\"getJDBCMinorVersion\");\n-        return 0;\n-    }\n-\n-    /**\n-     * Gets the SQL State type.\n-     *\n-     * @return DatabaseMetaData.sqlStateSQL99\n-     */\n-    @Override\n-    public int getSQLStateType() {\n-        debugCodeCall(\"getSQLStateType\");\n-        return DatabaseMetaData.sqlStateSQL99;\n-    }\n-\n-    /**\n-     * Does the database make a copy before updating.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean locatorsUpdateCopy() {\n-        debugCodeCall(\"locatorsUpdateCopy\");\n-        return false;\n-    }\n-\n-    /**\n-     * Does the database support statement pooling.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean supportsStatementPooling() {\n-        debugCodeCall(\"supportsStatementPooling\");\n-        return false;\n-    }\n-\n-    // =============================================================\n-\n-    private void checkClosed() {\n-        conn.checkClosed();\n-    }\n-\n-    private static String getPattern(String pattern) {\n-        return pattern == null ? \"%\" : pattern;\n-    }\n-\n-    private static String getSchemaPattern(String pattern) {\n-        return pattern == null ? \"%\" : pattern.length() == 0 ?\n-                Constants.SCHEMA_MAIN : pattern;\n-    }\n-\n-    private static String getCatalogPattern(String catalogPattern) {\n-        // Workaround for OpenOffice: getColumns is called with \"\" as the\n-        // catalog\n-        return catalogPattern == null || catalogPattern.length() == 0 ?\n-                \"%\" : catalogPattern;\n-    }\n-\n-    /**\n-     * Get the lifetime of a rowid.\n-     *\n-     * @return ROWID_UNSUPPORTED\n-     */\n-    @Override\n-    public RowIdLifetime getRowIdLifetime() {\n-        debugCodeCall(\"getRowIdLifetime\");\n-        return RowIdLifetime.ROWID_UNSUPPORTED;\n-    }\n-\n-    /**\n-     * Gets the list of schemas in the database.\n-     * The result set is sorted by TABLE_SCHEM.\n-     *\n-     * <ul>\n-     * <li>1 TABLE_SCHEM (String) schema name\n-     * </li><li>2 TABLE_CATALOG (String) catalog name\n-     * </li><li>3 IS_DEFAULT (boolean) if this is the default schema\n-     * </li></ul>\n-     *\n-     * @param catalogPattern null (to get all objects) or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @return the schema list\n-     * @throws SQLException if the connection is closed\n-     */\n-    @Override\n-    public ResultSet getSchemas(String catalogPattern, String schemaPattern)\n-            throws SQLException {\n-        try {\n-            debugCodeCall(\"getSchemas(String,String)\");\n-            checkClosed();\n-            PreparedStatement prep = conn\n-                    .prepareAutoCloseStatement(\"SELECT \"\n-                            + \"SCHEMA_NAME TABLE_SCHEM, \"\n-                            + \"CATALOG_NAME TABLE_CATALOG, \"\n-                            +\" IS_DEFAULT \"\n-                            + \"FROM INFORMATION_SCHEMA.SCHEMATA \"\n-                            + \"WHERE CATALOG_NAME LIKE ? ESCAPE ? \"\n-                            + \"AND SCHEMA_NAME LIKE ? ESCAPE ? \"\n-                            + \"ORDER BY SCHEMA_NAME\");\n-            prep.setString(1, getCatalogPattern(catalogPattern));\n-            prep.setString(2, \"\\\\\");\n-            prep.setString(3, getSchemaPattern(schemaPattern));\n-            prep.setString(4, \"\\\\\");\n-            return prep.executeQuery();\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Returns whether the database supports calling functions using the call\n-     * syntax.\n-     *\n-     * @return true\n-     */\n-    @Override\n-    public boolean supportsStoredFunctionsUsingCallSyntax() {\n-        debugCodeCall(\"supportsStoredFunctionsUsingCallSyntax\");\n-        return true;\n-    }\n-\n-    /**\n-     * Returns whether an exception while auto commit is on closes all result\n-     * sets.\n-     *\n-     * @return false\n-     */\n-    @Override\n-    public boolean autoCommitFailureClosesAllResultSets() {\n-        debugCodeCall(\"autoCommitFailureClosesAllResultSets\");\n-        return false;\n-    }\n-\n-    @Override\n-    public ResultSet getClientInfoProperties() throws SQLException {\n-        Properties clientInfo = conn.getClientInfo();\n-        SimpleResultSet result = new SimpleResultSet();\n-        result.addColumn(\"Name\", Types.VARCHAR, 0, 0);\n-        result.addColumn(\"Value\", Types.VARCHAR, 0, 0);\n-        for (Object key : clientInfo.keySet()) {\n-            result.addRow(key, clientInfo.get(key));\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * Return an object of this class if possible.\n-     *\n-     * @param iface the class\n-     * @return this\n-     */\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T unwrap(Class<T> iface) throws SQLException {\n-        try {\n-            if (isWrapperFor(iface)) {\n-                return (T) this;\n-            }\n-            throw DbException.getInvalidValueException(\"iface\", iface);\n-        } catch (Exception e) {\n-            throw logAndConvert(e);\n-        }\n-    }\n-\n-    /**\n-     * Checks if unwrap can return an object of this class.\n-     *\n-     * @param iface the class\n-     * @return whether or not the interface is assignable from this class\n-     */\n-    @Override\n-    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n-        return iface != null && iface.isAssignableFrom(getClass());\n-    }\n-\n-    /**\n-     * [Not supported] Gets the list of function columns.\n-     */\n-    @Override\n-    public ResultSet getFunctionColumns(String catalog, String schemaPattern,\n-            String functionNamePattern, String columnNamePattern)\n-            throws SQLException {\n-        throw unsupported(\"getFunctionColumns\");\n-    }\n-\n-    /**\n-     * [Not supported] Gets the list of functions.\n-     */\n-    @Override\n-    public ResultSet getFunctions(String catalog, String schemaPattern,\n-            String functionNamePattern) throws SQLException {\n-        throw unsupported(\"getFunctions\");\n-    }\n-\n-    /**\n-     * [Not supported]\n-     */\n-    @Override\n-    public boolean generatedKeyAlwaysReturned() {\n-        return true;\n-    }\n-\n-    /**\n-     * [Not supported]\n-     *\n-     * @param catalog null (to get all objects) or the catalog name\n-     * @param schemaPattern null (to get all objects) or a schema name\n-     *            (uppercase for unquoted names)\n-     * @param tableNamePattern null (to get all objects) or a table name\n-     *            (uppercase for unquoted names)\n-     * @param columnNamePattern null (to get all objects) or a column name\n-     *            (uppercase for unquoted names)\n-     */\n-    @Override\n-    public ResultSet getPseudoColumns(String catalog, String schemaPattern,\n-            String tableNamePattern, String columnNamePattern) {\n-        return null;\n-    }\n-\n-    /**\n-     * INTERNAL\n-     */\n-    @Override\n-    public String toString() {\n-        return getTraceObjectName() + \": \" + conn;\n-    }\n+      }\n+      rs.close();\n+      prep.close();\n+      return buff.toString();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Returns the default escape character for DatabaseMetaData search\n+   * patterns.\n+   *\n+   * @return the default escape character (always '\\', independent on the\n+   * mode)\n+   */\n+  @Override\n+  public String getSearchStringEscape() {\n+    debugCodeCall(\"getSearchStringEscape\");\n+    return \"\\\\\";\n+  }\n+\n+  /**\n+   * Returns the characters that are allowed for identifiers in addiction to\n+   * A-Z, a-z, 0-9 and '_'.\n+   *\n+   * @return an empty String (\"\")\n+   */\n+  @Override\n+  public String getExtraNameCharacters() {\n+    debugCodeCall(\"getExtraNameCharacters\");\n+    return \"\";\n+  }\n+\n+  /**\n+   * Returns whether alter table with add column is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsAlterTableWithAddColumn() {\n+    debugCodeCall(\"supportsAlterTableWithAddColumn\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether alter table with drop column is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsAlterTableWithDropColumn() {\n+    debugCodeCall(\"supportsAlterTableWithDropColumn\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether column aliasing is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsColumnAliasing() {\n+    debugCodeCall(\"supportsColumnAliasing\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether NULL+1 is NULL or not.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean nullPlusNonNullIsNull() {\n+    debugCodeCall(\"nullPlusNonNullIsNull\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether CONVERT is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsConvert() {\n+    debugCodeCall(\"supportsConvert\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether CONVERT is supported for one datatype to another.\n+   *\n+   * @param fromType the source SQL type\n+   * @param toType   the target SQL type\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsConvert(int fromType, int toType) {\n+    if (isDebugEnabled()) {\n+      debugCode(\"supportsConvert(\" + fromType + \", \" + fromType + \");\");\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether table correlation names (table alias) are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsTableCorrelationNames() {\n+    debugCodeCall(\"supportsTableCorrelationNames\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether table correlation names (table alias) are restricted to\n+   * be different than table names.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsDifferentTableCorrelationNames() {\n+    debugCodeCall(\"supportsDifferentTableCorrelationNames\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether expression in ORDER BY are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsExpressionsInOrderBy() {\n+    debugCodeCall(\"supportsExpressionsInOrderBy\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether ORDER BY is supported if the column is not in the SELECT\n+   * list.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsOrderByUnrelated() {\n+    debugCodeCall(\"supportsOrderByUnrelated\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether GROUP BY is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsGroupBy() {\n+    debugCodeCall(\"supportsGroupBy\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether GROUP BY is supported if the column is not in the SELECT\n+   * list.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsGroupByUnrelated() {\n+    debugCodeCall(\"supportsGroupByUnrelated\");\n+    return true;\n+  }\n+\n+  /**\n+   * Checks whether a GROUP BY clause can use columns that are not in the\n+   * SELECT clause, provided that it specifies all the columns in the SELECT\n+   * clause.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsGroupByBeyondSelect() {\n+    debugCodeCall(\"supportsGroupByBeyondSelect\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether LIKE... ESCAPE is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsLikeEscapeClause() {\n+    debugCodeCall(\"supportsLikeEscapeClause\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether multiple result sets are supported.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsMultipleResultSets() {\n+    debugCodeCall(\"supportsMultipleResultSets\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether multiple transactions (on different connections) are\n+   * supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsMultipleTransactions() {\n+    debugCodeCall(\"supportsMultipleTransactions\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether columns with NOT NULL are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsNonNullableColumns() {\n+    debugCodeCall(\"supportsNonNullableColumns\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether ODBC Minimum SQL grammar is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsMinimumSQLGrammar() {\n+    debugCodeCall(\"supportsMinimumSQLGrammar\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether ODBC Core SQL grammar is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsCoreSQLGrammar() {\n+    debugCodeCall(\"supportsCoreSQLGrammar\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether ODBC Extended SQL grammar is supported.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsExtendedSQLGrammar() {\n+    debugCodeCall(\"supportsExtendedSQLGrammar\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether SQL-92 entry level grammar is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsANSI92EntryLevelSQL() {\n+    debugCodeCall(\"supportsANSI92EntryLevelSQL\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether SQL-92 intermediate level grammar is supported.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsANSI92IntermediateSQL() {\n+    debugCodeCall(\"supportsANSI92IntermediateSQL\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether SQL-92 full level grammar is supported.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsANSI92FullSQL() {\n+    debugCodeCall(\"supportsANSI92FullSQL\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether referential integrity is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsIntegrityEnhancementFacility() {\n+    debugCodeCall(\"supportsIntegrityEnhancementFacility\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether outer joins are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsOuterJoins() {\n+    debugCodeCall(\"supportsOuterJoins\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether full outer joins are supported.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsFullOuterJoins() {\n+    debugCodeCall(\"supportsFullOuterJoins\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether limited outer joins are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsLimitedOuterJoins() {\n+    debugCodeCall(\"supportsLimitedOuterJoins\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns the term for \"schema\".\n+   *\n+   * @return \"schema\"\n+   */\n+  @Override\n+  public String getSchemaTerm() {\n+    debugCodeCall(\"getSchemaTerm\");\n+    return \"schema\";\n+  }\n+\n+  /**\n+   * Returns the term for \"procedure\".\n+   *\n+   * @return \"procedure\"\n+   */\n+  @Override\n+  public String getProcedureTerm() {\n+    debugCodeCall(\"getProcedureTerm\");\n+    return \"procedure\";\n+  }\n+\n+  /**\n+   * Returns the term for \"catalog\".\n+   *\n+   * @return \"catalog\"\n+   */\n+  @Override\n+  public String getCatalogTerm() {\n+    debugCodeCall(\"getCatalogTerm\");\n+    return \"catalog\";\n+  }\n+\n+  /**\n+   * Returns whether the catalog is at the beginning.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean isCatalogAtStart() {\n+    debugCodeCall(\"isCatalogAtStart\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns the catalog separator.\n+   *\n+   * @return \".\"\n+   */\n+  @Override\n+  public String getCatalogSeparator() {\n+    debugCodeCall(\"getCatalogSeparator\");\n+    return \".\";\n+  }\n+\n+  /**\n+   * Returns whether the schema name in INSERT, UPDATE, DELETE is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSchemasInDataManipulation() {\n+    debugCodeCall(\"supportsSchemasInDataManipulation\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the schema name in procedure calls is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSchemasInProcedureCalls() {\n+    debugCodeCall(\"supportsSchemasInProcedureCalls\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the schema name in CREATE TABLE is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSchemasInTableDefinitions() {\n+    debugCodeCall(\"supportsSchemasInTableDefinitions\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the schema name in CREATE INDEX is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSchemasInIndexDefinitions() {\n+    debugCodeCall(\"supportsSchemasInIndexDefinitions\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the schema name in GRANT is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSchemasInPrivilegeDefinitions() {\n+    debugCodeCall(\"supportsSchemasInPrivilegeDefinitions\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the catalog name in INSERT, UPDATE, DELETE is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsCatalogsInDataManipulation() {\n+    debugCodeCall(\"supportsCatalogsInDataManipulation\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the catalog name in procedure calls is supported.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsCatalogsInProcedureCalls() {\n+    debugCodeCall(\"supportsCatalogsInProcedureCalls\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the catalog name in CREATE TABLE is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsCatalogsInTableDefinitions() {\n+    debugCodeCall(\"supportsCatalogsInTableDefinitions\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the catalog name in CREATE INDEX is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsCatalogsInIndexDefinitions() {\n+    debugCodeCall(\"supportsCatalogsInIndexDefinitions\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the catalog name in GRANT is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsCatalogsInPrivilegeDefinitions() {\n+    debugCodeCall(\"supportsCatalogsInPrivilegeDefinitions\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether positioned deletes are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsPositionedDelete() {\n+    debugCodeCall(\"supportsPositionedDelete\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether positioned updates are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsPositionedUpdate() {\n+    debugCodeCall(\"supportsPositionedUpdate\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether SELECT ... FOR UPDATE is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSelectForUpdate() {\n+    debugCodeCall(\"supportsSelectForUpdate\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether stored procedures are supported.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsStoredProcedures() {\n+    debugCodeCall(\"supportsStoredProcedures\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether subqueries (SELECT) in comparisons are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSubqueriesInComparisons() {\n+    debugCodeCall(\"supportsSubqueriesInComparisons\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether SELECT in EXISTS is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSubqueriesInExists() {\n+    debugCodeCall(\"supportsSubqueriesInExists\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether IN(SELECT...) is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSubqueriesInIns() {\n+    debugCodeCall(\"supportsSubqueriesInIns\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether subqueries in quantified expression are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSubqueriesInQuantifieds() {\n+    debugCodeCall(\"supportsSubqueriesInQuantifieds\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether correlated subqueries are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsCorrelatedSubqueries() {\n+    debugCodeCall(\"supportsCorrelatedSubqueries\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether UNION SELECT is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsUnion() {\n+    debugCodeCall(\"supportsUnion\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether UNION ALL SELECT is supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsUnionAll() {\n+    debugCodeCall(\"supportsUnionAll\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether open result sets across commits are supported.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsOpenCursorsAcrossCommit() {\n+    debugCodeCall(\"supportsOpenCursorsAcrossCommit\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether open result sets across rollback are supported.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsOpenCursorsAcrossRollback() {\n+    debugCodeCall(\"supportsOpenCursorsAcrossRollback\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether open statements across commit are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsOpenStatementsAcrossCommit() {\n+    debugCodeCall(\"supportsOpenStatementsAcrossCommit\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether open statements across rollback are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsOpenStatementsAcrossRollback() {\n+    debugCodeCall(\"supportsOpenStatementsAcrossRollback\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether transactions are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsTransactions() {\n+    debugCodeCall(\"supportsTransactions\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether a specific transaction isolation level is supported.\n+   *\n+   * @param level the transaction isolation level (Connection.TRANSACTION_*)\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsTransactionIsolationLevel(int level) throws SQLException {\n+    debugCodeCall(\"supportsTransactionIsolationLevel\");\n+    if (level == Connection.TRANSACTION_READ_UNCOMMITTED) {\n+      // currently the combination of LOCK_MODE=0 and MULTI_THREADED\n+      // is not supported, also see code in Database#setLockMode(int)\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\n+          \"SELECT VALUE FROM INFORMATION_SCHEMA.SETTINGS WHERE NAME=?\");\n+      prep.setString(1, \"MULTI_THREADED\");\n+      ResultSet rs = prep.executeQuery();\n+      return !rs.next() || !rs.getString(1).equals(\"1\");\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether data manipulation and CREATE/DROP is supported in\n+   * transactions.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsDataDefinitionAndDataManipulationTransactions() {\n+    debugCodeCall(\"supportsDataDefinitionAndDataManipulationTransactions\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether only data manipulations are supported in transactions.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsDataManipulationTransactionsOnly() {\n+    debugCodeCall(\"supportsDataManipulationTransactionsOnly\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether CREATE/DROP commit an open transaction.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean dataDefinitionCausesTransactionCommit() {\n+    debugCodeCall(\"dataDefinitionCausesTransactionCommit\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether CREATE/DROP do not affect transactions.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean dataDefinitionIgnoredInTransactions() {\n+    debugCodeCall(\"dataDefinitionIgnoredInTransactions\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether a specific result set type is supported.\n+   * ResultSet.TYPE_SCROLL_SENSITIVE is not supported.\n+   *\n+   * @param type the result set type\n+   * @return true for all types except ResultSet.TYPE_FORWARD_ONLY\n+   */\n+  @Override\n+  public boolean supportsResultSetType(int type) {\n+    debugCodeCall(\"supportsResultSetType\", type);\n+    return type != ResultSet.TYPE_SCROLL_SENSITIVE;\n+  }\n+\n+  /**\n+   * Returns whether a specific result set concurrency is supported.\n+   * ResultSet.TYPE_SCROLL_SENSITIVE is not supported.\n+   *\n+   * @param type        the result set type\n+   * @param concurrency the result set concurrency\n+   * @return true if the type is not ResultSet.TYPE_SCROLL_SENSITIVE\n+   */\n+  @Override\n+  public boolean supportsResultSetConcurrency(int type, int concurrency) {\n+    if (isDebugEnabled()) {\n+      debugCode(\"supportsResultSetConcurrency(\" + type + \", \" + concurrency + \");\");\n+    }\n+    return type != ResultSet.TYPE_SCROLL_SENSITIVE;\n+  }\n+\n+  /**\n+   * Returns whether own updates are visible.\n+   *\n+   * @param type the result set type\n+   * @return true\n+   */\n+  @Override\n+  public boolean ownUpdatesAreVisible(int type) {\n+    debugCodeCall(\"ownUpdatesAreVisible\", type);\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether own deletes are visible.\n+   *\n+   * @param type the result set type\n+   * @return false\n+   */\n+  @Override\n+  public boolean ownDeletesAreVisible(int type) {\n+    debugCodeCall(\"ownDeletesAreVisible\", type);\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether own inserts are visible.\n+   *\n+   * @param type the result set type\n+   * @return false\n+   */\n+  @Override\n+  public boolean ownInsertsAreVisible(int type) {\n+    debugCodeCall(\"ownInsertsAreVisible\", type);\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether other updates are visible.\n+   *\n+   * @param type the result set type\n+   * @return false\n+   */\n+  @Override\n+  public boolean othersUpdatesAreVisible(int type) {\n+    debugCodeCall(\"othersUpdatesAreVisible\", type);\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether other deletes are visible.\n+   *\n+   * @param type the result set type\n+   * @return false\n+   */\n+  @Override\n+  public boolean othersDeletesAreVisible(int type) {\n+    debugCodeCall(\"othersDeletesAreVisible\", type);\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether other inserts are visible.\n+   *\n+   * @param type the result set type\n+   * @return false\n+   */\n+  @Override\n+  public boolean othersInsertsAreVisible(int type) {\n+    debugCodeCall(\"othersInsertsAreVisible\", type);\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether updates are detected.\n+   *\n+   * @param type the result set type\n+   * @return false\n+   */\n+  @Override\n+  public boolean updatesAreDetected(int type) {\n+    debugCodeCall(\"updatesAreDetected\", type);\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether deletes are detected.\n+   *\n+   * @param type the result set type\n+   * @return false\n+   */\n+  @Override\n+  public boolean deletesAreDetected(int type) {\n+    debugCodeCall(\"deletesAreDetected\", type);\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether inserts are detected.\n+   *\n+   * @param type the result set type\n+   * @return false\n+   */\n+  @Override\n+  public boolean insertsAreDetected(int type) {\n+    debugCodeCall(\"insertsAreDetected\", type);\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether batch updates are supported.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsBatchUpdates() {\n+    debugCodeCall(\"supportsBatchUpdates\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the maximum row size includes blobs.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean doesMaxRowSizeIncludeBlobs() {\n+    debugCodeCall(\"doesMaxRowSizeIncludeBlobs\");\n+    return false;\n+  }\n+\n+  /**\n+   * Returns the default transaction isolation level.\n+   *\n+   * @return Connection.TRANSACTION_READ_COMMITTED\n+   */\n+  @Override\n+  public int getDefaultTransactionIsolation() {\n+    debugCodeCall(\"getDefaultTransactionIsolation\");\n+    return Connection.TRANSACTION_READ_COMMITTED;\n+  }\n+\n+  /**\n+   * Checks if for CREATE TABLE Test(ID INT), getTables returns Test as the\n+   * table name.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsMixedCaseIdentifiers() {\n+    debugCodeCall(\"supportsMixedCaseIdentifiers\");\n+    return false;\n+  }\n+\n+  /**\n+   * Checks if a table created with CREATE TABLE \"Test\"(ID INT) is a different\n+   * table than a table created with CREATE TABLE TEST(ID INT).\n+   *\n+   * @return true usually, and false in MySQL mode\n+   */\n+  @Override\n+  public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\n+    debugCodeCall(\"supportsMixedCaseQuotedIdentifiers\");\n+    String m = conn.getMode();\n+    return !m.equals(\"MySQL\");\n+  }\n+\n+  /**\n+   * Checks if for CREATE TABLE Test(ID INT), getTables returns TEST as the\n+   * table name.\n+   *\n+   * @return true usually, and false in MySQL mode\n+   */\n+  @Override\n+  public boolean storesUpperCaseIdentifiers() throws SQLException {\n+    debugCodeCall(\"storesUpperCaseIdentifiers\");\n+    String m = conn.getMode();\n+    return !m.equals(\"MySQL\");\n+  }\n+\n+  /**\n+   * Checks if for CREATE TABLE Test(ID INT), getTables returns test as the\n+   * table name.\n+   *\n+   * @return false usually, and true in MySQL mode\n+   */\n+  @Override\n+  public boolean storesLowerCaseIdentifiers() throws SQLException {\n+    debugCodeCall(\"storesLowerCaseIdentifiers\");\n+    String m = conn.getMode();\n+    return m.equals(\"MySQL\");\n+  }\n+\n+  /**\n+   * Checks if for CREATE TABLE Test(ID INT), getTables returns Test as the\n+   * table name.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean storesMixedCaseIdentifiers() {\n+    debugCodeCall(\"storesMixedCaseIdentifiers\");\n+    return false;\n+  }\n+\n+  /**\n+   * Checks if for CREATE TABLE \"Test\"(ID INT), getTables returns TEST as the\n+   * table name.\n+   *\n+   * @return false usually, and true in MySQL mode\n+   */\n+  @Override\n+  public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {\n+    debugCodeCall(\"storesUpperCaseQuotedIdentifiers\");\n+    String m = conn.getMode();\n+    return m.equals(\"MySQL\");\n+  }\n+\n+  /**\n+   * Checks if for CREATE TABLE \"Test\"(ID INT), getTables returns test as the\n+   * table name.\n+   *\n+   * @return false usually, and true in MySQL mode\n+   */\n+  @Override\n+  public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {\n+    debugCodeCall(\"storesLowerCaseQuotedIdentifiers\");\n+    String m = conn.getMode();\n+    return m.equals(\"MySQL\");\n+  }\n+\n+  /**\n+   * Checks if for CREATE TABLE \"Test\"(ID INT), getTables returns Test as the\n+   * table name.\n+   *\n+   * @return true usually, and false in MySQL mode\n+   */\n+  @Override\n+  public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {\n+    debugCodeCall(\"storesMixedCaseQuotedIdentifiers\");\n+    String m = conn.getMode();\n+    return !m.equals(\"MySQL\");\n+  }\n+\n+  /**\n+   * Returns the maximum length for hex values (characters).\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxBinaryLiteralLength() {\n+    debugCodeCall(\"getMaxBinaryLiteralLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length for literals.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxCharLiteralLength() {\n+    debugCodeCall(\"getMaxCharLiteralLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length for column names.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxColumnNameLength() {\n+    debugCodeCall(\"getMaxColumnNameLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum number of columns in GROUP BY.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxColumnsInGroupBy() {\n+    debugCodeCall(\"getMaxColumnsInGroupBy\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum number of columns in CREATE INDEX.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxColumnsInIndex() {\n+    debugCodeCall(\"getMaxColumnsInIndex\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum number of columns in ORDER BY.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxColumnsInOrderBy() {\n+    debugCodeCall(\"getMaxColumnsInOrderBy\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum number of columns in SELECT.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxColumnsInSelect() {\n+    debugCodeCall(\"getMaxColumnsInSelect\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum number of columns in CREATE TABLE.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxColumnsInTable() {\n+    debugCodeCall(\"getMaxColumnsInTable\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum number of open connection.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxConnections() {\n+    debugCodeCall(\"getMaxConnections\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length for a cursor name.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxCursorNameLength() {\n+    debugCodeCall(\"getMaxCursorNameLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length for an index (in bytes).\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxIndexLength() {\n+    debugCodeCall(\"getMaxIndexLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length for a schema name.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxSchemaNameLength() {\n+    debugCodeCall(\"getMaxSchemaNameLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length for a procedure name.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxProcedureNameLength() {\n+    debugCodeCall(\"getMaxProcedureNameLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length for a catalog name.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxCatalogNameLength() {\n+    debugCodeCall(\"getMaxCatalogNameLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum size of a row (in bytes).\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxRowSize() {\n+    debugCodeCall(\"getMaxRowSize\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length of a statement.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxStatementLength() {\n+    debugCodeCall(\"getMaxStatementLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum number of open statements.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxStatements() {\n+    debugCodeCall(\"getMaxStatements\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length for a table name.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxTableNameLength() {\n+    debugCodeCall(\"getMaxTableNameLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum number of tables in a SELECT.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxTablesInSelect() {\n+    debugCodeCall(\"getMaxTablesInSelect\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Returns the maximum length for a user name.\n+   *\n+   * @return 0 for limit is unknown\n+   */\n+  @Override\n+  public int getMaxUserNameLength() {\n+    debugCodeCall(\"getMaxUserNameLength\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Does the database support savepoints.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsSavepoints() {\n+    debugCodeCall(\"supportsSavepoints\");\n+    return true;\n+  }\n+\n+  /**\n+   * Does the database support named parameters.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsNamedParameters() {\n+    debugCodeCall(\"supportsNamedParameters\");\n+    return false;\n+  }\n+\n+  /**\n+   * Does the database support multiple open result sets.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsMultipleOpenResults() {\n+    debugCodeCall(\"supportsMultipleOpenResults\");\n+    return true;\n+  }\n+\n+  /**\n+   * Does the database support getGeneratedKeys.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsGetGeneratedKeys() {\n+    debugCodeCall(\"supportsGetGeneratedKeys\");\n+    return true;\n+  }\n+\n+  /**\n+   * [Not supported]\n+   */\n+  @Override\n+  public ResultSet getSuperTypes(String catalog, String schemaPattern,\n+                                 String typeNamePattern) throws SQLException {\n+    throw unsupported(\"superTypes\");\n+  }\n+\n+  /**\n+   * Get the list of super tables of a table. This method currently returns an\n+   * empty result set.\n+   * <ul>\n+   * <li>1 TABLE_CAT (String) table catalog</li>\n+   * <li>2 TABLE_SCHEM (String) table schema</li>\n+   * <li>3 TABLE_NAME (String) table name</li>\n+   * <li>4 SUPERTABLE_NAME (String) the name of the super table</li>\n+   * </ul>\n+   *\n+   * @param catalog          null (to get all objects) or the catalog name\n+   * @param schemaPattern    null (to get all objects) or a schema name\n+   *                         (uppercase for unquoted names)\n+   * @param tableNamePattern null (to get all objects) or a table name pattern\n+   *                         (uppercase for unquoted names)\n+   * @return an empty result set\n+   */\n+  @Override\n+  public ResultSet getSuperTables(String catalog, String schemaPattern,\n+                                  String tableNamePattern) throws SQLException {\n+    try {\n+      if (isDebugEnabled()) {\n+        debugCode(\"getSuperTables(\"\n+            + quote(catalog) + \", \"\n+            + quote(schemaPattern) + \", \"\n+            + quote(tableNamePattern) + \");\");\n+      }\n+      checkClosed();\n+      PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n+          + \"CATALOG_NAME TABLE_CAT, \"\n+          + \"CATALOG_NAME TABLE_SCHEM, \"\n+          + \"CATALOG_NAME TABLE_NAME, \"\n+          + \"CATALOG_NAME SUPERTABLE_NAME \"\n+          + \"FROM INFORMATION_SCHEMA.CATALOGS \"\n+          + \"WHERE FALSE\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * [Not supported]\n+   */\n+  @Override\n+  public ResultSet getAttributes(String catalog, String schemaPattern,\n+                                 String typeNamePattern, String attributeNamePattern)\n+      throws SQLException {\n+    throw unsupported(\"attributes\");\n+  }\n+\n+  /**\n+   * Does this database supports a result set holdability.\n+   *\n+   * @param holdability ResultSet.HOLD_CURSORS_OVER_COMMIT or\n+   *                    CLOSE_CURSORS_AT_COMMIT\n+   * @return true if the holdability is ResultSet.CLOSE_CURSORS_AT_COMMIT\n+   */\n+  @Override\n+  public boolean supportsResultSetHoldability(int holdability) {\n+    debugCodeCall(\"supportsResultSetHoldability\", holdability);\n+    return holdability == ResultSet.CLOSE_CURSORS_AT_COMMIT;\n+  }\n+\n+  /**\n+   * Gets the result set holdability.\n+   *\n+   * @return ResultSet.CLOSE_CURSORS_AT_COMMIT\n+   */\n+  @Override\n+  public int getResultSetHoldability() {\n+    debugCodeCall(\"getResultSetHoldability\");\n+    return ResultSet.CLOSE_CURSORS_AT_COMMIT;\n+  }\n+\n+  /**\n+   * Gets the major version of the database.\n+   *\n+   * @return the major version\n+   */\n+  @Override\n+  public int getDatabaseMajorVersion() {\n+    debugCodeCall(\"getDatabaseMajorVersion\");\n+    return Constants.VERSION_MAJOR;\n+  }\n+\n+  /**\n+   * Gets the minor version of the database.\n+   *\n+   * @return the minor version\n+   */\n+  @Override\n+  public int getDatabaseMinorVersion() {\n+    debugCodeCall(\"getDatabaseMinorVersion\");\n+    return Constants.VERSION_MINOR;\n+  }\n+\n+  /**\n+   * Gets the major version of the supported JDBC API.\n+   *\n+   * @return the major version (4)\n+   */\n+  @Override\n+  public int getJDBCMajorVersion() {\n+    debugCodeCall(\"getJDBCMajorVersion\");\n+    return 4;\n+  }\n+\n+  /**\n+   * Gets the minor version of the supported JDBC API.\n+   *\n+   * @return the minor version (0)\n+   */\n+  @Override\n+  public int getJDBCMinorVersion() {\n+    debugCodeCall(\"getJDBCMinorVersion\");\n+    return 0;\n+  }\n+\n+  /**\n+   * Gets the SQL State type.\n+   *\n+   * @return DatabaseMetaData.sqlStateSQL99\n+   */\n+  @Override\n+  public int getSQLStateType() {\n+    debugCodeCall(\"getSQLStateType\");\n+    return DatabaseMetaData.sqlStateSQL99;\n+  }\n+\n+  /**\n+   * Does the database make a copy before updating.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean locatorsUpdateCopy() {\n+    debugCodeCall(\"locatorsUpdateCopy\");\n+    return false;\n+  }\n+\n+  /**\n+   * Does the database support statement pooling.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean supportsStatementPooling() {\n+    debugCodeCall(\"supportsStatementPooling\");\n+    return false;\n+  }\n+\n+  // =============================================================\n+\n+  private void checkClosed() {\n+    conn.checkClosed();\n+  }\n+\n+  private static String getPattern(String pattern) {\n+    return pattern == null ? \"%\" : pattern;\n+  }\n+\n+  private static String getSchemaPattern(String pattern) {\n+    return pattern == null ? \"%\" : pattern.length() == 0 ?\n+        Constants.SCHEMA_MAIN : pattern;\n+  }\n+\n+  private static String getCatalogPattern(String catalogPattern) {\n+    // Workaround for OpenOffice: getColumns is called with \"\" as the\n+    // catalog\n+    return catalogPattern == null || catalogPattern.length() == 0 ?\n+        \"%\" : catalogPattern;\n+  }\n+\n+  /**\n+   * Get the lifetime of a rowid.\n+   *\n+   * @return ROWID_UNSUPPORTED\n+   */\n+  @Override\n+  public RowIdLifetime getRowIdLifetime() {\n+    debugCodeCall(\"getRowIdLifetime\");\n+    return RowIdLifetime.ROWID_UNSUPPORTED;\n+  }\n+\n+  /**\n+   * Gets the list of schemas in the database.\n+   * The result set is sorted by TABLE_SCHEM.\n+   *\n+   * <ul>\n+   * <li>1 TABLE_SCHEM (String) schema name\n+   * </li><li>2 TABLE_CATALOG (String) catalog name\n+   * </li><li>3 IS_DEFAULT (boolean) if this is the default schema\n+   * </li></ul>\n+   *\n+   * @param catalogPattern null (to get all objects) or the catalog name\n+   * @param schemaPattern  null (to get all objects) or a schema name\n+   *                       (uppercase for unquoted names)\n+   * @return the schema list\n+   * @throws SQLException if the connection is closed\n+   */\n+  @Override\n+  public ResultSet getSchemas(String catalogPattern, String schemaPattern)\n+      throws SQLException {\n+    try {\n+      debugCodeCall(\"getSchemas(String,String)\");\n+      checkClosed();\n+      PreparedStatement prep = conn\n+          .prepareAutoCloseStatement(\"SELECT \"\n+              + \"SCHEMA_NAME TABLE_SCHEM, \"\n+              + \"CATALOG_NAME TABLE_CATALOG, \"\n+              + \" IS_DEFAULT \"\n+              + \"FROM INFORMATION_SCHEMA.SCHEMATA \"\n+              + \"WHERE CATALOG_NAME LIKE ? ESCAPE ? \"\n+              + \"AND SCHEMA_NAME LIKE ? ESCAPE ? \"\n+              + \"ORDER BY SCHEMA_NAME\");\n+      prep.setString(1, getCatalogPattern(catalogPattern));\n+      prep.setString(2, \"\\\\\");\n+      prep.setString(3, getSchemaPattern(schemaPattern));\n+      prep.setString(4, \"\\\\\");\n+      return prep.executeQuery();\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Returns whether the database supports calling functions using the call\n+   * syntax.\n+   *\n+   * @return true\n+   */\n+  @Override\n+  public boolean supportsStoredFunctionsUsingCallSyntax() {\n+    debugCodeCall(\"supportsStoredFunctionsUsingCallSyntax\");\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether an exception while auto commit is on closes all result\n+   * sets.\n+   *\n+   * @return false\n+   */\n+  @Override\n+  public boolean autoCommitFailureClosesAllResultSets() {\n+    debugCodeCall(\"autoCommitFailureClosesAllResultSets\");\n+    return false;\n+  }\n+\n+  @Override\n+  public ResultSet getClientInfoProperties() throws SQLException {\n+    Properties clientInfo = conn.getClientInfo();\n+    SimpleResultSet result = new SimpleResultSet();\n+    result.addColumn(\"Name\", Types.VARCHAR, 0, 0);\n+    result.addColumn(\"Value\", Types.VARCHAR, 0, 0);\n+    for (Object key : clientInfo.keySet()) {\n+      result.addRow(key, clientInfo.get(key));\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Return an object of this class if possible.\n+   *\n+   * @param iface the class\n+   * @return this\n+   */\n+  @Override\n+  @SuppressWarnings(\"unchecked\")\n+  public <T> T unwrap(Class<T> iface) throws SQLException {\n+    try {\n+      if (isWrapperFor(iface)) {\n+        return (T) this;\n+      }\n+      throw DbException.getInvalidValueException(\"iface\", iface);\n+    } catch (Exception e) {\n+      throw logAndConvert(e);\n+    }\n+  }\n+\n+  /**\n+   * Checks if unwrap can return an object of this class.\n+   *\n+   * @param iface the class\n+   * @return whether or not the interface is assignable from this class\n+   */\n+  @Override\n+  public boolean isWrapperFor(Class<?> iface) throws SQLException {\n+    return iface != null && iface.isAssignableFrom(getClass());\n+  }\n+\n+  /**\n+   * [Not supported] Gets the list of function columns.\n+   */\n+  @Override\n+  public ResultSet getFunctionColumns(String catalog, String schemaPattern,\n+                                      String functionNamePattern, String columnNamePattern)\n+      throws SQLException {\n+    throw unsupported(\"getFunctionColumns\");\n+  }\n+\n+  /**\n+   * [Not supported] Gets the list of functions.\n+   */\n+  @Override\n+  public ResultSet getFunctions(String catalog, String schemaPattern,\n+                                String functionNamePattern) throws SQLException {\n+    throw unsupported(\"getFunctions\");\n+  }\n+\n+  /**\n+   * [Not supported]\n+   */\n+  @Override\n+  public boolean generatedKeyAlwaysReturned() {\n+    return true;\n+  }\n+\n+  /**\n+   * [Not supported]\n+   *\n+   * @param catalog           null (to get all objects) or the catalog name\n+   * @param schemaPattern     null (to get all objects) or a schema name\n+   *                          (uppercase for unquoted names)\n+   * @param tableNamePattern  null (to get all objects) or a table name\n+   *                          (uppercase for unquoted names)\n+   * @param columnNamePattern null (to get all objects) or a column name\n+   *                          (uppercase for unquoted names)\n+   */\n+  @Override\n+  public ResultSet getPseudoColumns(String catalog, String schemaPattern,\n+                                    String tableNamePattern, String columnNamePattern) {\n+    return null;\n+  }\n+\n+  /**\n+   * INTERNAL\n+   */\n+  @Override\n+  public String toString() {\n+    return getTraceObjectName() + \": \" + conn;\n+  }\n \n }\n",
            "diff_size": 4670
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "135",
                    "column": "55",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/241/JdbcDatabaseMetaData.java\nindex 693383340bd..16419a71ec5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/241/JdbcDatabaseMetaData.java\n@@ -14,7 +14,6 @@ import java.sql.SQLException;\n import java.sql.Types;\n import java.util.Arrays;\n import java.util.Properties;\n-\n import org.h2.command.CommandInterface;\n import org.h2.engine.Constants;\n import org.h2.engine.SessionInterface;\n@@ -31,8 +30,9 @@ import org.h2.util.StringUtils;\n /**\n  * Represents the meta data for a database.\n  */\n-public class JdbcDatabaseMetaData extends TraceObject implements\n-        DatabaseMetaData, JdbcDatabaseMetaDataBackwardsCompat {\n+\n+\n+public class JdbcDatabaseMetaData extends TraceObject implements DatabaseMetaData, JdbcDatabaseMetaDataBackwardsCompat {\n \n     private final JdbcConnection conn;\n \n@@ -51,6 +51,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the major version number\n      */\n+\n     @Override\n     public int getDriverMajorVersion() {\n         debugCodeCall(\"getDriverMajorVersion\");\n@@ -62,6 +63,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the minor version number\n      */\n+\n     @Override\n     public int getDriverMinorVersion() {\n         debugCodeCall(\"getDriverMinorVersion\");\n@@ -73,6 +75,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the product name (\"H2\")\n      */\n+\n     @Override\n     public String getDatabaseProductName() {\n         debugCodeCall(\"getDatabaseProductName\");\n@@ -86,6 +89,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the product version\n      */\n+\n     @Override\n     public String getDatabaseProductVersion() {\n         debugCodeCall(\"getDatabaseProductVersion\");\n@@ -97,6 +101,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the driver name (\"H2 JDBC Driver\")\n      */\n+\n     @Override\n     public String getDriverName() {\n         debugCodeCall(\"getDriverName\");\n@@ -109,6 +114,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the version number\n      */\n+\n     @Override\n     public String getDriverVersion() {\n         debugCodeCall(\"getDriverVersion\");\n@@ -126,7 +132,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n                     hasSynonyms = true;\n                 } else if (clientVersion <= Constants.TCP_PROTOCOL_VERSION_15) {\n                     hasSynonyms = false;\n-                } else { // 1.4.194-1.4.196\n+                                             } else { // 1.4.194-1.4.196\n                     CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n                     ResultInterface result = c.executeQuery(0, false);\n                     result.next();\n@@ -170,14 +176,15 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the list of columns\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getTables(String catalogPattern, String schemaPattern,\n-            String tableNamePattern, String[] types) throws SQLException {\n+    public ResultSet getTables(String catalogPattern, String schemaPattern, String tableNamePattern, String[] types) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getTables(\" + quote(catalogPattern) + \", \" +\n-                        quote(schemaPattern) + \", \" + quote(tableNamePattern) +\n-                        \", \" + quoteArray(types) + \");\");\n+                debugCode(\"getTables(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(tableNamePattern) + \", \"\n+                + quoteArray(types) + \");\");\n             }\n             checkClosed();\n             int typesLength = types != null ? types.length : 0;\n@@ -186,53 +193,49 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n             // (1024 - 16) is enough for the most cases\n             StringBuilder select = new StringBuilder(1008);\n             if (includeSynonyms) {\n-                select.append(\"SELECT \"\n-                        + \"TABLE_CAT, \"\n-                        + \"TABLE_SCHEM, \"\n-                        + \"TABLE_NAME, \"\n-                        + \"TABLE_TYPE, \"\n-                        + \"REMARKS, \"\n-                        + \"TYPE_CAT, \"\n-                        + \"TYPE_SCHEM, \"\n-                        + \"TYPE_NAME, \"\n-                        + \"SELF_REFERENCING_COL_NAME, \"\n-                        + \"REF_GENERATION, \"\n-                        + \"SQL \"\n-                        + \"FROM (\"\n-                        + \"SELECT \"\n-                        + \"SYNONYM_CATALOG TABLE_CAT, \"\n-                        + \"SYNONYM_SCHEMA TABLE_SCHEM, \"\n-                        + \"SYNONYM_NAME as TABLE_NAME, \"\n-                        + \"TYPE_NAME AS TABLE_TYPE, \"\n-                        + \"REMARKS, \"\n-                        + \"TYPE_NAME TYPE_CAT, \"\n-                        + \"TYPE_NAME TYPE_SCHEM, \"\n-                        + \"TYPE_NAME AS TYPE_NAME, \"\n-                        + \"TYPE_NAME SELF_REFERENCING_COL_NAME, \"\n-                        + \"TYPE_NAME REF_GENERATION, \"\n-                        + \"NULL AS SQL \"\n-                        + \"FROM INFORMATION_SCHEMA.SYNONYMS \"\n-                        + \"WHERE SYNONYM_CATALOG LIKE ?1 ESCAPE ?4 \"\n-                        + \"AND SYNONYM_SCHEMA LIKE ?2 ESCAPE ?4 \"\n-                        + \"AND SYNONYM_NAME LIKE ?3 ESCAPE ?4 \"\n-                        + \"UNION \");\n+                select.append(\"SELECT \" + \"TABLE_CAT, \"\n+                + \"TABLE_SCHEM, \"\n+                + \"TABLE_NAME, \"\n+                + \"TABLE_TYPE, \"\n+                + \"REMARKS, \"\n+                + \"TYPE_CAT, \"\n+                + \"TYPE_SCHEM, \"\n+                + \"TYPE_NAME, \"\n+                + \"SELF_REFERENCING_COL_NAME, \"\n+                + \"REF_GENERATION, \"\n+                + \"SQL \"\n+                + \"FROM (\"\n+                + \"SELECT \"\n+                + \"SYNONYM_CATALOG TABLE_CAT, \"\n+                + \"SYNONYM_SCHEMA TABLE_SCHEM, \"\n+                + \"SYNONYM_NAME as TABLE_NAME, \"\n+                + \"TYPE_NAME AS TABLE_TYPE, \"\n+                + \"REMARKS, \"\n+                + \"TYPE_NAME TYPE_CAT, \"\n+                + \"TYPE_NAME TYPE_SCHEM, \"\n+                + \"TYPE_NAME AS TYPE_NAME, \"\n+                + \"TYPE_NAME SELF_REFERENCING_COL_NAME, \"\n+                + \"TYPE_NAME REF_GENERATION, \"\n+                + \"NULL AS SQL \"\n+                + \"FROM INFORMATION_SCHEMA.SYNONYMS \"\n+                + \"WHERE SYNONYM_CATALOG LIKE ?1 ESCAPE ?4 \"\n+                + \"AND SYNONYM_SCHEMA LIKE ?2 ESCAPE ?4 \"\n+                + \"AND SYNONYM_NAME LIKE ?3 ESCAPE ?4 \" + \"UNION \");\n             }\n-            select.append(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"TABLE_TYPE, \"\n-                    + \"REMARKS, \"\n-                    + \"TYPE_NAME TYPE_CAT, \"\n-                    + \"TYPE_NAME TYPE_SCHEM, \"\n-                    + \"TYPE_NAME, \"\n-                    + \"TYPE_NAME SELF_REFERENCING_COL_NAME, \"\n-                    + \"TYPE_NAME REF_GENERATION, \"\n-                    + \"SQL \"\n-                    + \"FROM INFORMATION_SCHEMA.TABLES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ?1 ESCAPE ?4 \"\n-                    + \"AND TABLE_SCHEMA LIKE ?2 ESCAPE ?4 \"\n-                    + \"AND TABLE_NAME LIKE ?3 ESCAPE ?4\");\n+            select.append(\"SELECT \" + \"TABLE_CATALOG TABLE_CAT, \"\n+            + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+            + \"TABLE_NAME, \"\n+            + \"TABLE_TYPE, \"\n+            + \"REMARKS, \"\n+            + \"TYPE_NAME TYPE_CAT, \"\n+            + \"TYPE_NAME TYPE_SCHEM, \"\n+            + \"TYPE_NAME, \"\n+            + \"TYPE_NAME SELF_REFERENCING_COL_NAME, \"\n+            + \"TYPE_NAME REF_GENERATION, \"\n+            + \"SQL \"\n+            + \"FROM INFORMATION_SCHEMA.TABLES \"\n+            + \"WHERE TABLE_CATALOG LIKE ?1 ESCAPE ?4 \"\n+            + \"AND TABLE_SCHEMA LIKE ?2 ESCAPE ?4 \" + \"AND TABLE_NAME LIKE ?3 ESCAPE ?4\");\n             if (typesLength > 0) {\n                 select.append(\" AND TABLE_TYPE IN(\");\n                 for (int i = 0; i < typesLength; i++) {\n@@ -246,8 +249,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n             if (includeSynonyms) {\n                 select.append(')');\n             }\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\n-                    select.append(\" ORDER BY TABLE_TYPE, TABLE_SCHEM, TABLE_NAME\").toString());\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(select.append(\" ORDER BY TABLE_TYPE, TABLE_SCHEM, TABLE_NAME\").toString());\n             prep.setString(1, getCatalogPattern(catalogPattern));\n             prep.setString(2, getSchemaPattern(schemaPattern));\n             prep.setString(3, getPattern(tableNamePattern));\n@@ -304,119 +306,112 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the list of columns\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getColumns(String catalogPattern, String schemaPattern,\n-            String tableNamePattern, String columnNamePattern)\n-            throws SQLException {\n+    public ResultSet getColumns(String catalogPattern, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getColumns(\" + quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableNamePattern)+\", \"\n-                        +quote(columnNamePattern)+\");\");\n+                debugCode(\"getColumns(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(tableNamePattern) + \", \"\n+                + quote(columnNamePattern) + \");\");\n             }\n             checkClosed();\n             boolean includeSynonyms = hasSynonyms();\n-\n             StringBuilder select = new StringBuilder(2432);\n             if (includeSynonyms) {\n-                select.append(\"SELECT \"\n-                        + \"TABLE_CAT, \"\n-                        + \"TABLE_SCHEM, \"\n-                        + \"TABLE_NAME, \"\n-                        + \"COLUMN_NAME, \"\n-                        + \"DATA_TYPE, \"\n-                        + \"TYPE_NAME, \"\n-                        + \"COLUMN_SIZE, \"\n-                        + \"BUFFER_LENGTH, \"\n-                        + \"DECIMAL_DIGITS, \"\n-                        + \"NUM_PREC_RADIX, \"\n-                        + \"NULLABLE, \"\n-                        + \"REMARKS, \"\n-                        + \"COLUMN_DEF, \"\n-                        + \"SQL_DATA_TYPE, \"\n-                        + \"SQL_DATETIME_SUB, \"\n-                        + \"CHAR_OCTET_LENGTH, \"\n-                        + \"ORDINAL_POSITION, \"\n-                        + \"IS_NULLABLE, \"\n-                        + \"SCOPE_CATALOG, \"\n-                        + \"SCOPE_SCHEMA, \"\n-                        + \"SCOPE_TABLE, \"\n-                        + \"SOURCE_DATA_TYPE, \"\n-                        + \"IS_AUTOINCREMENT, \"\n-                        + \"SCOPE_CATLOG \"\n-                        + \"FROM (\"\n-                        + \"SELECT \"\n-                        + \"s.SYNONYM_CATALOG TABLE_CAT, \"\n-                        + \"s.SYNONYM_SCHEMA TABLE_SCHEM, \"\n-                        + \"s.SYNONYM_NAME TABLE_NAME, \"\n-                        + \"c.COLUMN_NAME, \"\n-                        + \"c.DATA_TYPE, \"\n-                        + \"c.TYPE_NAME, \"\n-                        + \"c.CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n-                        + \"c.CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n-                        + \"c.NUMERIC_SCALE DECIMAL_DIGITS, \"\n-                        + \"c.NUMERIC_PRECISION_RADIX NUM_PREC_RADIX, \"\n-                        + \"c.NULLABLE, \"\n-                        + \"c.REMARKS, \"\n-                        + \"c.COLUMN_DEFAULT COLUMN_DEF, \"\n-                        + \"c.DATA_TYPE SQL_DATA_TYPE, \"\n-                        + \"ZERO() SQL_DATETIME_SUB, \"\n-                        + \"c.CHARACTER_OCTET_LENGTH CHAR_OCTET_LENGTH, \"\n-                        + \"c.ORDINAL_POSITION, \"\n-                        + \"c.IS_NULLABLE IS_NULLABLE, \"\n-                        + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATALOG, \"\n-                        + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_SCHEMA, \"\n-                        + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_TABLE, \"\n-                        + \"c.SOURCE_DATA_TYPE, \"\n-                        + \"CASE WHEN c.SEQUENCE_NAME IS NULL THEN \"\n-                        + \"CAST(?1 AS VARCHAR) ELSE CAST(?2 AS VARCHAR) END IS_AUTOINCREMENT, \"\n-                        + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATLOG \"\n-                        + \"FROM INFORMATION_SCHEMA.COLUMNS c JOIN INFORMATION_SCHEMA.SYNONYMS s ON \"\n-                        + \"s.SYNONYM_FOR = c.TABLE_NAME \"\n-                        + \"AND s.SYNONYM_FOR_SCHEMA = c.TABLE_SCHEMA \"\n-                        + \"WHERE s.SYNONYM_CATALOG LIKE ?3 ESCAPE ?7 \"\n-                        + \"AND s.SYNONYM_SCHEMA LIKE ?4 ESCAPE ?7 \"\n-                        + \"AND s.SYNONYM_NAME LIKE ?5 ESCAPE ?7 \"\n-                        + \"AND c.COLUMN_NAME LIKE ?6 ESCAPE ?7 \"\n-                        + \"UNION \");\n+                select.append(\"SELECT \" + \"TABLE_CAT, \"\n+                + \"TABLE_SCHEM, \"\n+                + \"TABLE_NAME, \"\n+                + \"COLUMN_NAME, \"\n+                + \"DATA_TYPE, \"\n+                + \"TYPE_NAME, \"\n+                + \"COLUMN_SIZE, \"\n+                + \"BUFFER_LENGTH, \"\n+                + \"DECIMAL_DIGITS, \"\n+                + \"NUM_PREC_RADIX, \"\n+                + \"NULLABLE, \"\n+                + \"REMARKS, \"\n+                + \"COLUMN_DEF, \"\n+                + \"SQL_DATA_TYPE, \"\n+                + \"SQL_DATETIME_SUB, \"\n+                + \"CHAR_OCTET_LENGTH, \"\n+                + \"ORDINAL_POSITION, \"\n+                + \"IS_NULLABLE, \"\n+                + \"SCOPE_CATALOG, \"\n+                + \"SCOPE_SCHEMA, \"\n+                + \"SCOPE_TABLE, \"\n+                + \"SOURCE_DATA_TYPE, \"\n+                + \"IS_AUTOINCREMENT, \"\n+                + \"SCOPE_CATLOG \"\n+                + \"FROM (\"\n+                + \"SELECT \"\n+                + \"s.SYNONYM_CATALOG TABLE_CAT, \"\n+                + \"s.SYNONYM_SCHEMA TABLE_SCHEM, \"\n+                + \"s.SYNONYM_NAME TABLE_NAME, \"\n+                + \"c.COLUMN_NAME, \"\n+                + \"c.DATA_TYPE, \"\n+                + \"c.TYPE_NAME, \"\n+                + \"c.CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n+                + \"c.CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n+                + \"c.NUMERIC_SCALE DECIMAL_DIGITS, \"\n+                + \"c.NUMERIC_PRECISION_RADIX NUM_PREC_RADIX, \"\n+                + \"c.NULLABLE, \"\n+                + \"c.REMARKS, \"\n+                + \"c.COLUMN_DEFAULT COLUMN_DEF, \"\n+                + \"c.DATA_TYPE SQL_DATA_TYPE, \"\n+                + \"ZERO() SQL_DATETIME_SUB, \"\n+                + \"c.CHARACTER_OCTET_LENGTH CHAR_OCTET_LENGTH, \"\n+                + \"c.ORDINAL_POSITION, \"\n+                + \"c.IS_NULLABLE IS_NULLABLE, \"\n+                + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATALOG, \"\n+                + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_SCHEMA, \"\n+                + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_TABLE, \"\n+                + \"c.SOURCE_DATA_TYPE, \"\n+                + \"CASE WHEN c.SEQUENCE_NAME IS NULL THEN \"\n+                + \"CAST(?1 AS VARCHAR) ELSE CAST(?2 AS VARCHAR) END IS_AUTOINCREMENT, \"\n+                + \"CAST(c.SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATLOG \"\n+                + \"FROM INFORMATION_SCHEMA.COLUMNS c JOIN INFORMATION_SCHEMA.SYNONYMS s ON \"\n+                + \"s.SYNONYM_FOR = c.TABLE_NAME \"\n+                + \"AND s.SYNONYM_FOR_SCHEMA = c.TABLE_SCHEMA \"\n+                + \"WHERE s.SYNONYM_CATALOG LIKE ?3 ESCAPE ?7 \"\n+                + \"AND s.SYNONYM_SCHEMA LIKE ?4 ESCAPE ?7 \"\n+                + \"AND s.SYNONYM_NAME LIKE ?5 ESCAPE ?7 \"\n+                + \"AND c.COLUMN_NAME LIKE ?6 ESCAPE ?7 \" + \"UNION \");\n             }\n-            select.append(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"DATA_TYPE, \"\n-                    + \"TYPE_NAME, \"\n-                    + \"CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n-                    + \"CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n-                    + \"NUMERIC_SCALE DECIMAL_DIGITS, \"\n-                    + \"NUMERIC_PRECISION_RADIX NUM_PREC_RADIX, \"\n-                    + \"NULLABLE, \"\n-                    + \"REMARKS, \"\n-                    + \"COLUMN_DEFAULT COLUMN_DEF, \"\n-                    + \"DATA_TYPE SQL_DATA_TYPE, \"\n-                    + \"ZERO() SQL_DATETIME_SUB, \"\n-                    + \"CHARACTER_OCTET_LENGTH CHAR_OCTET_LENGTH, \"\n-                    + \"ORDINAL_POSITION, \"\n-                    + \"IS_NULLABLE IS_NULLABLE, \"\n-                    + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATALOG, \"\n-                    + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_SCHEMA, \"\n-                    + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_TABLE, \"\n-                    + \"SOURCE_DATA_TYPE, \"\n-                    + \"CASE WHEN SEQUENCE_NAME IS NULL THEN \"\n-                    + \"CAST(?1 AS VARCHAR) ELSE CAST(?2 AS VARCHAR) END IS_AUTOINCREMENT, \"\n-                    + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATLOG \"\n-                    + \"FROM INFORMATION_SCHEMA.COLUMNS \"\n-                    + \"WHERE TABLE_CATALOG LIKE ?3 ESCAPE ?7 \"\n-                    + \"AND TABLE_SCHEMA LIKE ?4 ESCAPE ?7 \"\n-                    + \"AND TABLE_NAME LIKE ?5 ESCAPE ?7 \"\n-                    + \"AND COLUMN_NAME LIKE ?6 ESCAPE ?7\");\n+            select.append(\"SELECT \" + \"TABLE_CATALOG TABLE_CAT, \"\n+            + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+            + \"TABLE_NAME, \"\n+            + \"COLUMN_NAME, \"\n+            + \"DATA_TYPE, \"\n+            + \"TYPE_NAME, \"\n+            + \"CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n+            + \"CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n+            + \"NUMERIC_SCALE DECIMAL_DIGITS, \"\n+            + \"NUMERIC_PRECISION_RADIX NUM_PREC_RADIX, \"\n+            + \"NULLABLE, \"\n+            + \"REMARKS, \"\n+            + \"COLUMN_DEFAULT COLUMN_DEF, \"\n+            + \"DATA_TYPE SQL_DATA_TYPE, \"\n+            + \"ZERO() SQL_DATETIME_SUB, \"\n+            + \"CHARACTER_OCTET_LENGTH CHAR_OCTET_LENGTH, \"\n+            + \"ORDINAL_POSITION, \"\n+            + \"IS_NULLABLE IS_NULLABLE, \"\n+            + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATALOG, \"\n+            + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_SCHEMA, \"\n+            + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_TABLE, \"\n+            + \"SOURCE_DATA_TYPE, \"\n+            + \"CASE WHEN SEQUENCE_NAME IS NULL THEN \"\n+            + \"CAST(?1 AS VARCHAR) ELSE CAST(?2 AS VARCHAR) END IS_AUTOINCREMENT, \"\n+            + \"CAST(SOURCE_DATA_TYPE AS VARCHAR) SCOPE_CATLOG \"\n+            + \"FROM INFORMATION_SCHEMA.COLUMNS \"\n+            + \"WHERE TABLE_CATALOG LIKE ?3 ESCAPE ?7 \"\n+            + \"AND TABLE_SCHEMA LIKE ?4 ESCAPE ?7 \"\n+            + \"AND TABLE_NAME LIKE ?5 ESCAPE ?7 \" + \"AND COLUMN_NAME LIKE ?6 ESCAPE ?7\");\n             if (includeSynonyms) {\n                 select.append(')');\n             }\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\n-                    select.append(\" ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION\").toString());\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(select.append(\" ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION\").toString());\n             prep.setString(1, \"NO\");\n             prep.setString(2, \"YES\");\n             prep.setString(3, getCatalogPattern(catalogPattern));\n@@ -463,15 +458,16 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the list of indexes and columns\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getIndexInfo(String catalogPattern, String schemaPattern,\n-            String tableName, boolean unique, boolean approximate)\n-            throws SQLException {\n+    public ResultSet getIndexInfo(String catalogPattern, String schemaPattern, String tableName, boolean unique, boolean approximate) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getIndexInfo(\" + quote(catalogPattern) + \", \" +\n-                        quote(schemaPattern) + \", \" + quote(tableName) + \", \" +\n-                        unique + \", \" + approximate + \");\");\n+                debugCode(\"getIndexInfo(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(tableName) + \", \"\n+                + unique + \", \"\n+                + approximate + \");\");\n             }\n             String uniqueCondition;\n             if (unique) {\n@@ -480,28 +476,27 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n                 uniqueCondition = \"TRUE\";\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"NON_UNIQUE, \"\n-                    + \"TABLE_CATALOG INDEX_QUALIFIER, \"\n-                    + \"INDEX_NAME, \"\n-                    + \"INDEX_TYPE TYPE, \"\n-                    + \"ORDINAL_POSITION, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"ASC_OR_DESC, \"\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"TABLE_CATALOG TABLE_CAT, \"\n+            + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+            + \"TABLE_NAME, \"\n+            + \"NON_UNIQUE, \"\n+            + \"TABLE_CATALOG INDEX_QUALIFIER, \"\n+            + \"INDEX_NAME, \"\n+            + \"INDEX_TYPE TYPE, \"\n+            + \"ORDINAL_POSITION, \"\n+            + \"COLUMN_NAME, \"\n+            + \"ASC_OR_DESC, \"\n                     // TODO meta data for number of unique values in an index\n-                    + \"CARDINALITY, \"\n-                    + \"PAGES, \"\n-                    + \"FILTER_CONDITION, \"\n-                    + \"SORT_TYPE \"\n-                    + \"FROM INFORMATION_SCHEMA.INDEXES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND (\" + uniqueCondition + \") \"\n-                    + \"AND TABLE_NAME = ? \"\n-                    + \"ORDER BY NON_UNIQUE, TYPE, TABLE_SCHEM, INDEX_NAME, ORDINAL_POSITION\");\n+            + \"CARDINALITY, \"\n+            + \"PAGES, \"\n+            + \"FILTER_CONDITION, \"\n+            + \"SORT_TYPE \"\n+            + \"FROM INFORMATION_SCHEMA.INDEXES \"\n+            + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND (\"\n+            + uniqueCondition + \") \"\n+            + \"AND TABLE_NAME = ? \" + \"ORDER BY NON_UNIQUE, TYPE, TABLE_SCHEM, INDEX_NAME, ORDINAL_POSITION\");\n             prep.setString(1, getCatalogPattern(catalogPattern));\n             prep.setString(2, \"\\\\\");\n             prep.setString(3, getSchemaPattern(schemaPattern));\n@@ -533,30 +528,28 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the list of primary key columns\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n     public ResultSet getPrimaryKeys(String catalogPattern,\n-            String schemaPattern, String tableName) throws SQLException {\n+        String schemaPattern, String tableName) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getPrimaryKeys(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableName)+\");\");\n+                debugCode(\"getPrimaryKeys(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(tableName) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"ORDINAL_POSITION KEY_SEQ, \"\n-                    + \"IFNULL(CONSTRAINT_NAME, INDEX_NAME) PK_NAME \"\n-                    + \"FROM INFORMATION_SCHEMA.INDEXES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_NAME = ? \"\n-                    + \"AND PRIMARY_KEY = TRUE \"\n-                    + \"ORDER BY COLUMN_NAME\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"TABLE_CATALOG TABLE_CAT, \"\n+            + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+            + \"TABLE_NAME, \"\n+            + \"COLUMN_NAME, \"\n+            + \"ORDINAL_POSITION KEY_SEQ, \"\n+            + \"IFNULL(CONSTRAINT_NAME, INDEX_NAME) PK_NAME \"\n+            + \"FROM INFORMATION_SCHEMA.INDEXES \"\n+            + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND TABLE_NAME = ? \"\n+            + \"AND PRIMARY_KEY = TRUE \" + \"ORDER BY COLUMN_NAME\");\n             prep.setString(1, getCatalogPattern(catalogPattern));\n             prep.setString(2, \"\\\\\");\n             prep.setString(3, getSchemaPattern(schemaPattern));\n@@ -573,6 +566,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean allProceduresAreCallable() {\n         debugCodeCall(\"allProceduresAreCallable\");\n@@ -584,6 +578,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean allTablesAreSelectable() {\n         debugCodeCall(\"allTablesAreSelectable\");\n@@ -595,6 +590,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the url\n      */\n+\n     @Override\n     public String getURL() throws SQLException {\n         try {\n@@ -611,6 +607,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the user name\n      */\n+\n     @Override\n     public String getUserName() throws SQLException {\n         try {\n@@ -626,6 +623,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return if read only optimization is switched on\n      */\n+\n     @Override\n     public boolean isReadOnly() throws SQLException {\n         try {\n@@ -642,6 +640,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return false by default; true if the system property h2.sortNullsHigh is\n      *         set to true\n      */\n+\n     @Override\n     public boolean nullsAreSortedHigh() {\n         debugCodeCall(\"nullsAreSortedHigh\");\n@@ -654,6 +653,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return true by default; false if the system property h2.sortNullsHigh is\n      *         set to true\n      */\n+\n     @Override\n     public boolean nullsAreSortedLow() {\n         debugCodeCall(\"nullsAreSortedLow\");\n@@ -666,6 +666,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean nullsAreSortedAtStart() {\n         debugCodeCall(\"nullsAreSortedAtStart\");\n@@ -677,6 +678,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean nullsAreSortedAtEnd() {\n         debugCodeCall(\"nullsAreSortedAtEnd\");\n@@ -688,6 +690,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the connection\n      */\n+\n     @Override\n     public Connection getConnection() {\n         debugCodeCall(\"getConnection\");\n@@ -720,32 +723,30 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the procedures\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getProcedures(String catalogPattern, String schemaPattern,\n-            String procedureNamePattern) throws SQLException {\n+    public ResultSet getProcedures(String catalogPattern,\n+        String schemaPattern, String procedureNamePattern) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getProcedures(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(procedureNamePattern)+\");\");\n+                debugCode(\"getProcedures(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(procedureNamePattern) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"ALIAS_CATALOG PROCEDURE_CAT, \"\n-                    + \"ALIAS_SCHEMA PROCEDURE_SCHEM, \"\n-                    + \"ALIAS_NAME PROCEDURE_NAME, \"\n-                    + \"COLUMN_COUNT NUM_INPUT_PARAMS, \"\n-                    + \"ZERO() NUM_OUTPUT_PARAMS, \"\n-                    + \"ZERO() NUM_RESULT_SETS, \"\n-                    + \"REMARKS, \"\n-                    + \"RETURNS_RESULT PROCEDURE_TYPE, \"\n-                    + \"ALIAS_NAME SPECIFIC_NAME \"\n-                    + \"FROM INFORMATION_SCHEMA.FUNCTION_ALIASES \"\n-                    + \"WHERE ALIAS_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND ALIAS_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND ALIAS_NAME LIKE ? ESCAPE ? \"\n-                    + \"ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, NUM_INPUT_PARAMS\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"ALIAS_CATALOG PROCEDURE_CAT, \"\n+            + \"ALIAS_SCHEMA PROCEDURE_SCHEM, \"\n+            + \"ALIAS_NAME PROCEDURE_NAME, \"\n+            + \"COLUMN_COUNT NUM_INPUT_PARAMS, \"\n+            + \"ZERO() NUM_OUTPUT_PARAMS, \"\n+            + \"ZERO() NUM_RESULT_SETS, \"\n+            + \"REMARKS, \"\n+            + \"RETURNS_RESULT PROCEDURE_TYPE, \"\n+            + \"ALIAS_NAME SPECIFIC_NAME \"\n+            + \"FROM INFORMATION_SCHEMA.FUNCTION_ALIASES \"\n+            + \"WHERE ALIAS_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND ALIAS_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND ALIAS_NAME LIKE ? ESCAPE ? \" + \"ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, NUM_INPUT_PARAMS\");\n             prep.setString(1, getCatalogPattern(catalogPattern));\n             prep.setString(2, \"\\\\\");\n             prep.setString(3, getSchemaPattern(schemaPattern));\n@@ -799,46 +800,42 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the procedure columns\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getProcedureColumns(String catalogPattern,\n-            String schemaPattern, String procedureNamePattern,\n-            String columnNamePattern) throws SQLException {\n+    public ResultSet getProcedureColumns(String catalogPattern, String schemaPattern, String procedureNamePattern, String columnNamePattern) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getProcedureColumns(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(procedureNamePattern)+\", \"\n-                        +quote(columnNamePattern)+\");\");\n+                debugCode(\"getProcedureColumns(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(procedureNamePattern) + \", \"\n+                + quote(columnNamePattern) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"ALIAS_CATALOG PROCEDURE_CAT, \"\n-                    + \"ALIAS_SCHEMA PROCEDURE_SCHEM, \"\n-                    + \"ALIAS_NAME PROCEDURE_NAME, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"COLUMN_TYPE, \"\n-                    + \"DATA_TYPE, \"\n-                    + \"TYPE_NAME, \"\n-                    + \"PRECISION, \"\n-                    + \"PRECISION LENGTH, \"\n-                    + \"SCALE, \"\n-                    + \"RADIX, \"\n-                    + \"NULLABLE, \"\n-                    + \"REMARKS, \"\n-                    + \"COLUMN_DEFAULT COLUMN_DEF, \"\n-                    + \"ZERO() SQL_DATA_TYPE, \"\n-                    + \"ZERO() SQL_DATETIME_SUB, \"\n-                    + \"ZERO() CHAR_OCTET_LENGTH, \"\n-                    + \"POS ORDINAL_POSITION, \"\n-                    + \"? IS_NULLABLE, \"\n-                    + \"ALIAS_NAME SPECIFIC_NAME \"\n-                    + \"FROM INFORMATION_SCHEMA.FUNCTION_COLUMNS \"\n-                    + \"WHERE ALIAS_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND ALIAS_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND ALIAS_NAME LIKE ? ESCAPE ? \"\n-                    + \"AND COLUMN_NAME LIKE ? ESCAPE ? \"\n-                    + \"ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, ORDINAL_POSITION\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"ALIAS_CATALOG PROCEDURE_CAT, \"\n+            + \"ALIAS_SCHEMA PROCEDURE_SCHEM, \"\n+            + \"ALIAS_NAME PROCEDURE_NAME, \"\n+            + \"COLUMN_NAME, \"\n+            + \"COLUMN_TYPE, \"\n+            + \"DATA_TYPE, \"\n+            + \"TYPE_NAME, \"\n+            + \"PRECISION, \"\n+            + \"PRECISION LENGTH, \"\n+            + \"SCALE, \"\n+            + \"RADIX, \"\n+            + \"NULLABLE, \"\n+            + \"REMARKS, \"\n+            + \"COLUMN_DEFAULT COLUMN_DEF, \"\n+            + \"ZERO() SQL_DATA_TYPE, \"\n+            + \"ZERO() SQL_DATETIME_SUB, \"\n+            + \"ZERO() CHAR_OCTET_LENGTH, \"\n+            + \"POS ORDINAL_POSITION, \"\n+            + \"? IS_NULLABLE, \"\n+            + \"ALIAS_NAME SPECIFIC_NAME \"\n+            + \"FROM INFORMATION_SCHEMA.FUNCTION_COLUMNS \"\n+            + \"WHERE ALIAS_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND ALIAS_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND ALIAS_NAME LIKE ? ESCAPE ? \"\n+            + \"AND COLUMN_NAME LIKE ? ESCAPE ? \" + \"ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, ORDINAL_POSITION\");\n             prep.setString(1, \"YES\");\n             prep.setString(2, getCatalogPattern(catalogPattern));\n             prep.setString(3, \"\\\\\");\n@@ -867,18 +864,16 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the schema list\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n     public ResultSet getSchemas() throws SQLException {\n         try {\n             debugCodeCall(\"getSchemas\");\n             checkClosed();\n-            PreparedStatement prep = conn\n-                    .prepareAutoCloseStatement(\"SELECT \"\n-                            + \"SCHEMA_NAME TABLE_SCHEM, \"\n-                            + \"CATALOG_NAME TABLE_CATALOG, \"\n-                            +\" IS_DEFAULT \"\n-                            + \"FROM INFORMATION_SCHEMA.SCHEMATA \"\n-                            + \"ORDER BY SCHEMA_NAME\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"SCHEMA_NAME TABLE_SCHEM, \"\n+            + \"CATALOG_NAME TABLE_CATALOG, \"\n+            + \" IS_DEFAULT \"\n+            + \"FROM INFORMATION_SCHEMA.SCHEMATA \" + \"ORDER BY SCHEMA_NAME\");\n             return prep.executeQuery();\n         } catch (Exception e) {\n             throw logAndConvert(e);\n@@ -896,14 +891,13 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the catalog list\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n     public ResultSet getCatalogs() throws SQLException {\n         try {\n             debugCodeCall(\"getCatalogs\");\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\n-                    \"SELECT CATALOG_NAME TABLE_CAT \"\n-                    + \"FROM INFORMATION_SCHEMA.CATALOGS\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT CATALOG_NAME TABLE_CAT \" + \"FROM INFORMATION_SCHEMA.CATALOGS\");\n             return prep.executeQuery();\n         } catch (Exception e) {\n             throw logAndConvert(e);\n@@ -920,15 +914,14 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the table types\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n     public ResultSet getTableTypes() throws SQLException {\n         try {\n             debugCodeCall(\"getTableTypes\");\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TYPE TABLE_TYPE \"\n-                    + \"FROM INFORMATION_SCHEMA.TABLE_TYPES \"\n-                    + \"ORDER BY TABLE_TYPE\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"TYPE TABLE_TYPE \"\n+            + \"FROM INFORMATION_SCHEMA.TABLE_TYPES \" + \"ORDER BY TABLE_TYPE\");\n             return prep.executeQuery();\n         } catch (Exception e) {\n             throw logAndConvert(e);\n@@ -961,34 +954,30 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the list of privileges\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getColumnPrivileges(String catalogPattern,\n-            String schemaPattern, String table, String columnNamePattern)\n-            throws SQLException {\n+    public ResultSet getColumnPrivileges(String catalogPattern, String schemaPattern, String table, String columnNamePattern) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getColumnPrivileges(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(table)+\", \"\n-                        +quote(columnNamePattern)+\");\");\n+                debugCode(\"getColumnPrivileges(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(table) + \", \"\n+                + quote(columnNamePattern) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"GRANTOR, \"\n-                    + \"GRANTEE, \"\n-                    + \"PRIVILEGE_TYPE PRIVILEGE, \"\n-                    + \"IS_GRANTABLE \"\n-                    + \"FROM INFORMATION_SCHEMA.COLUMN_PRIVILEGES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_NAME = ? \"\n-                    + \"AND COLUMN_NAME LIKE ? ESCAPE ? \"\n-                    + \"ORDER BY COLUMN_NAME, PRIVILEGE\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"TABLE_CATALOG TABLE_CAT, \"\n+            + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+            + \"TABLE_NAME, \"\n+            + \"COLUMN_NAME, \"\n+            + \"GRANTOR, \"\n+            + \"GRANTEE, \"\n+            + \"PRIVILEGE_TYPE PRIVILEGE, \"\n+            + \"IS_GRANTABLE \"\n+            + \"FROM INFORMATION_SCHEMA.COLUMN_PRIVILEGES \"\n+            + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND TABLE_NAME = ? \"\n+            + \"AND COLUMN_NAME LIKE ? ESCAPE ? \" + \"ORDER BY COLUMN_NAME, PRIVILEGE\");\n             prep.setString(1, getCatalogPattern(catalogPattern));\n             prep.setString(2, \"\\\\\");\n             prep.setString(3, getSchemaPattern(schemaPattern));\n@@ -1026,30 +1015,28 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the list of privileges\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n     public ResultSet getTablePrivileges(String catalogPattern,\n-            String schemaPattern, String tableNamePattern) throws SQLException {\n+        String schemaPattern, String tableNamePattern) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getTablePrivileges(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableNamePattern)+\");\");\n+                debugCode(\"getTablePrivileges(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(tableNamePattern) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TABLE_CATALOG TABLE_CAT, \"\n-                    + \"TABLE_SCHEMA TABLE_SCHEM, \"\n-                    + \"TABLE_NAME, \"\n-                    + \"GRANTOR, \"\n-                    + \"GRANTEE, \"\n-                    + \"PRIVILEGE_TYPE PRIVILEGE, \"\n-                    + \"IS_GRANTABLE \"\n-                    + \"FROM INFORMATION_SCHEMA.TABLE_PRIVILEGES \"\n-                    + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND TABLE_NAME LIKE ? ESCAPE ? \"\n-                    + \"ORDER BY TABLE_SCHEM, TABLE_NAME, PRIVILEGE\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"TABLE_CATALOG TABLE_CAT, \"\n+            + \"TABLE_SCHEMA TABLE_SCHEM, \"\n+            + \"TABLE_NAME, \"\n+            + \"GRANTOR, \"\n+            + \"GRANTEE, \"\n+            + \"PRIVILEGE_TYPE PRIVILEGE, \"\n+            + \"IS_GRANTABLE \"\n+            + \"FROM INFORMATION_SCHEMA.TABLE_PRIVILEGES \"\n+            + \"WHERE TABLE_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND TABLE_NAME LIKE ? ESCAPE ? \" + \"ORDER BY TABLE_SCHEM, TABLE_NAME, PRIVILEGE\");\n             prep.setString(1, getCatalogPattern(catalogPattern));\n             prep.setString(2, \"\\\\\");\n             prep.setString(3, getSchemaPattern(schemaPattern));\n@@ -1087,37 +1074,34 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the primary key index\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getBestRowIdentifier(String catalogPattern,\n-            String schemaPattern, String tableName, int scope, boolean nullable)\n-            throws SQLException {\n+    public ResultSet getBestRowIdentifier(String catalogPattern, String schemaPattern, String tableName, int scope, boolean nullable) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getBestRowIdentifier(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableName)+\", \"\n-                        +scope+\", \"+nullable+\");\");\n+                debugCode(\"getBestRowIdentifier(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(tableName) + \", \"\n+                + scope + \", \"\n+                + nullable + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"CAST(? AS SMALLINT) SCOPE, \"\n-                    + \"C.COLUMN_NAME, \"\n-                    + \"C.DATA_TYPE, \"\n-                    + \"C.TYPE_NAME, \"\n-                    + \"C.CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n-                    + \"C.CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n-                    + \"CAST(C.NUMERIC_SCALE AS SMALLINT) DECIMAL_DIGITS, \"\n-                    + \"CAST(? AS SMALLINT) PSEUDO_COLUMN \"\n-                    + \"FROM INFORMATION_SCHEMA.INDEXES I, \"\n-                    +\" INFORMATION_SCHEMA.COLUMNS C \"\n-                    + \"WHERE C.TABLE_NAME = I.TABLE_NAME \"\n-                    + \"AND C.COLUMN_NAME = I.COLUMN_NAME \"\n-                    + \"AND C.TABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND C.TABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND C.TABLE_NAME = ? \"\n-                    + \"AND I.PRIMARY_KEY = TRUE \"\n-                    + \"ORDER BY SCOPE\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"CAST(? AS SMALLINT) SCOPE, \"\n+            + \"C.COLUMN_NAME, \"\n+            + \"C.DATA_TYPE, \"\n+            + \"C.TYPE_NAME, \"\n+            + \"C.CHARACTER_MAXIMUM_LENGTH COLUMN_SIZE, \"\n+            + \"C.CHARACTER_MAXIMUM_LENGTH BUFFER_LENGTH, \"\n+            + \"CAST(C.NUMERIC_SCALE AS SMALLINT) DECIMAL_DIGITS, \"\n+            + \"CAST(? AS SMALLINT) PSEUDO_COLUMN \"\n+            + \"FROM INFORMATION_SCHEMA.INDEXES I, \"\n+            + \" INFORMATION_SCHEMA.COLUMNS C \"\n+            + \"WHERE C.TABLE_NAME = I.TABLE_NAME \"\n+            + \"AND C.COLUMN_NAME = I.COLUMN_NAME \"\n+            + \"AND C.TABLE_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND C.TABLE_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND C.TABLE_NAME = ? \"\n+            + \"AND I.PRIMARY_KEY = TRUE \" + \"ORDER BY SCOPE\");\n             // SCOPE\n             prep.setInt(1, DatabaseMetaData.bestRowSession);\n             // PSEUDO_COLUMN\n@@ -1155,28 +1139,25 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return an empty result set\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getVersionColumns(String catalog, String schema,\n-            String tableName) throws SQLException {\n+    public ResultSet getVersionColumns(String catalog, String schema, String tableName) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getVersionColumns(\"\n-                        +quote(catalog)+\", \"\n-                        +quote(schema)+\", \"\n-                        +quote(tableName)+\");\");\n+                debugCode(\"getVersionColumns(\" + quote(catalog) + \", \"\n+                + quote(schema) + \", \"\n+                + quote(tableName) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"ZERO() SCOPE, \"\n-                    + \"COLUMN_NAME, \"\n-                    + \"CAST(DATA_TYPE AS INT) DATA_TYPE, \"\n-                    + \"TYPE_NAME, \"\n-                    + \"NUMERIC_PRECISION COLUMN_SIZE, \"\n-                    + \"NUMERIC_PRECISION BUFFER_LENGTH, \"\n-                    + \"NUMERIC_PRECISION DECIMAL_DIGITS, \"\n-                    + \"ZERO() PSEUDO_COLUMN \"\n-                    + \"FROM INFORMATION_SCHEMA.COLUMNS \"\n-                    + \"WHERE FALSE\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"ZERO() SCOPE, \"\n+            + \"COLUMN_NAME, \"\n+            + \"CAST(DATA_TYPE AS INT) DATA_TYPE, \"\n+            + \"TYPE_NAME, \"\n+            + \"NUMERIC_PRECISION COLUMN_SIZE, \"\n+            + \"NUMERIC_PRECISION BUFFER_LENGTH, \"\n+            + \"NUMERIC_PRECISION DECIMAL_DIGITS, \"\n+            + \"ZERO() PSEUDO_COLUMN \"\n+            + \"FROM INFORMATION_SCHEMA.COLUMNS \" + \"WHERE FALSE\");\n             return prep.executeQuery();\n         } catch (Exception e) {\n             throw logAndConvert(e);\n@@ -1214,37 +1195,35 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the result set\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n     public ResultSet getImportedKeys(String catalogPattern,\n-            String schemaPattern, String tableName) throws SQLException {\n+        String schemaPattern, String tableName) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getImportedKeys(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableName)+\");\");\n+                debugCode(\"getImportedKeys(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(tableName) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n-                    + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n-                    + \"PKTABLE_NAME PKTABLE_NAME, \"\n-                    + \"PKCOLUMN_NAME, \"\n-                    + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n-                    + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n-                    + \"FKTABLE_NAME, \"\n-                    + \"FKCOLUMN_NAME, \"\n-                    + \"ORDINAL_POSITION KEY_SEQ, \"\n-                    + \"UPDATE_RULE, \"\n-                    + \"DELETE_RULE, \"\n-                    + \"FK_NAME, \"\n-                    + \"PK_NAME, \"\n-                    + \"DEFERRABILITY \"\n-                    + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n-                    + \"WHERE FKTABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND FKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND FKTABLE_NAME = ? \"\n-                    + \"ORDER BY PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME, FK_NAME, KEY_SEQ\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n+            + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n+            + \"PKTABLE_NAME PKTABLE_NAME, \"\n+            + \"PKCOLUMN_NAME, \"\n+            + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n+            + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n+            + \"FKTABLE_NAME, \"\n+            + \"FKCOLUMN_NAME, \"\n+            + \"ORDINAL_POSITION KEY_SEQ, \"\n+            + \"UPDATE_RULE, \"\n+            + \"DELETE_RULE, \"\n+            + \"FK_NAME, \"\n+            + \"PK_NAME, \"\n+            + \"DEFERRABILITY \"\n+            + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n+            + \"WHERE FKTABLE_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND FKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND FKTABLE_NAME = ? \" + \"ORDER BY PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME, FK_NAME, KEY_SEQ\");\n             prep.setString(1, getCatalogPattern(catalogPattern));\n             prep.setString(2, \"\\\\\");\n             prep.setString(3, getSchemaPattern(schemaPattern));\n@@ -1287,37 +1266,35 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the result set\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n     public ResultSet getExportedKeys(String catalogPattern,\n-            String schemaPattern, String tableName) throws SQLException {\n+        String schemaPattern, String tableName) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getExportedKeys(\"\n-                        +quote(catalogPattern)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableName)+\");\");\n+                debugCode(\"getExportedKeys(\" + quote(catalogPattern) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(tableName) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n-                    + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n-                    + \"PKTABLE_NAME PKTABLE_NAME, \"\n-                    + \"PKCOLUMN_NAME, \"\n-                    + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n-                    + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n-                    + \"FKTABLE_NAME, \"\n-                    + \"FKCOLUMN_NAME, \"\n-                    + \"ORDINAL_POSITION KEY_SEQ, \"\n-                    + \"UPDATE_RULE, \"\n-                    + \"DELETE_RULE, \"\n-                    + \"FK_NAME, \"\n-                    + \"PK_NAME, \"\n-                    + \"DEFERRABILITY \"\n-                    + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n-                    + \"WHERE PKTABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND PKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND PKTABLE_NAME = ? \"\n-                    + \"ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME, KEY_SEQ\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n+            + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n+            + \"PKTABLE_NAME PKTABLE_NAME, \"\n+            + \"PKCOLUMN_NAME, \"\n+            + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n+            + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n+            + \"FKTABLE_NAME, \"\n+            + \"FKCOLUMN_NAME, \"\n+            + \"ORDINAL_POSITION KEY_SEQ, \"\n+            + \"UPDATE_RULE, \"\n+            + \"DELETE_RULE, \"\n+            + \"FK_NAME, \"\n+            + \"PK_NAME, \"\n+            + \"DEFERRABILITY \"\n+            + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n+            + \"WHERE PKTABLE_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND PKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND PKTABLE_NAME = ? \" + \"ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME, KEY_SEQ\");\n             prep.setString(1, getCatalogPattern(catalogPattern));\n             prep.setString(2, \"\\\\\");\n             prep.setString(3, getSchemaPattern(schemaPattern));\n@@ -1366,44 +1343,40 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the result set\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getCrossReference(String primaryCatalogPattern,\n-            String primarySchemaPattern, String primaryTable, String foreignCatalogPattern,\n-            String foreignSchemaPattern, String foreignTable) throws SQLException {\n+    public ResultSet getCrossReference(String primaryCatalogPattern, String primarySchemaPattern, String primaryTable, String foreignCatalogPattern, String foreignSchemaPattern, String foreignTable) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getCrossReference(\"\n-                        +quote(primaryCatalogPattern)+\", \"\n-                        +quote(primarySchemaPattern)+\", \"\n-                        +quote(primaryTable)+\", \"\n-                        +quote(foreignCatalogPattern)+\", \"\n-                        +quote(foreignSchemaPattern)+\", \"\n-                        +quote(foreignTable)+\");\");\n+                debugCode(\"getCrossReference(\" + quote(primaryCatalogPattern) + \", \"\n+                + quote(primarySchemaPattern) + \", \"\n+                + quote(primaryTable) + \", \"\n+                + quote(foreignCatalogPattern) + \", \"\n+                + quote(foreignSchemaPattern) + \", \"\n+                + quote(foreignTable) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n-                    + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n-                    + \"PKTABLE_NAME PKTABLE_NAME, \"\n-                    + \"PKCOLUMN_NAME, \"\n-                    + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n-                    + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n-                    + \"FKTABLE_NAME, \"\n-                    + \"FKCOLUMN_NAME, \"\n-                    + \"ORDINAL_POSITION KEY_SEQ, \"\n-                    + \"UPDATE_RULE, \"\n-                    + \"DELETE_RULE, \"\n-                    + \"FK_NAME, \"\n-                    + \"PK_NAME, \"\n-                    + \"DEFERRABILITY \"\n-                    + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n-                    + \"WHERE PKTABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND PKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND PKTABLE_NAME = ? \"\n-                    + \"AND FKTABLE_CATALOG LIKE ? ESCAPE ? \"\n-                    + \"AND FKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n-                    + \"AND FKTABLE_NAME = ? \"\n-                    + \"ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME, KEY_SEQ\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"PKTABLE_CATALOG PKTABLE_CAT, \"\n+            + \"PKTABLE_SCHEMA PKTABLE_SCHEM, \"\n+            + \"PKTABLE_NAME PKTABLE_NAME, \"\n+            + \"PKCOLUMN_NAME, \"\n+            + \"FKTABLE_CATALOG FKTABLE_CAT, \"\n+            + \"FKTABLE_SCHEMA FKTABLE_SCHEM, \"\n+            + \"FKTABLE_NAME, \"\n+            + \"FKCOLUMN_NAME, \"\n+            + \"ORDINAL_POSITION KEY_SEQ, \"\n+            + \"UPDATE_RULE, \"\n+            + \"DELETE_RULE, \"\n+            + \"FK_NAME, \"\n+            + \"PK_NAME, \"\n+            + \"DEFERRABILITY \"\n+            + \"FROM INFORMATION_SCHEMA.CROSS_REFERENCES \"\n+            + \"WHERE PKTABLE_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND PKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND PKTABLE_NAME = ? \"\n+            + \"AND FKTABLE_CATALOG LIKE ? ESCAPE ? \"\n+            + \"AND FKTABLE_SCHEMA LIKE ? ESCAPE ? \"\n+            + \"AND FKTABLE_NAME = ? \" + \"ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME, KEY_SEQ\");\n             prep.setString(1, getCatalogPattern(primaryCatalogPattern));\n             prep.setString(2, \"\\\\\");\n             prep.setString(3, getSchemaPattern(primarySchemaPattern));\n@@ -1441,27 +1414,24 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return an empty result set\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getUDTs(String catalog, String schemaPattern,\n-            String typeNamePattern, int[] types) throws SQLException {\n+    public ResultSet getUDTs(String catalog, String schemaPattern, String typeNamePattern, int[] types) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getUDTs(\"\n-                        +quote(catalog)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(typeNamePattern)+\", \"\n-                        +quoteIntArray(types)+\");\");\n+                debugCode(\"getUDTs(\" + quote(catalog) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(typeNamePattern) + \", \"\n+                + quoteIntArray(types) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"CAST(NULL AS VARCHAR) TYPE_CAT, \"\n-                    + \"CAST(NULL AS VARCHAR) TYPE_SCHEM, \"\n-                    + \"CAST(NULL AS VARCHAR) TYPE_NAME, \"\n-                    + \"CAST(NULL AS VARCHAR) CLASS_NAME, \"\n-                    + \"CAST(NULL AS SMALLINT) DATA_TYPE, \"\n-                    + \"CAST(NULL AS VARCHAR) REMARKS, \"\n-                    + \"CAST(NULL AS SMALLINT) BASE_TYPE \"\n-                    + \"FROM DUAL WHERE FALSE\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"CAST(NULL AS VARCHAR) TYPE_CAT, \"\n+            + \"CAST(NULL AS VARCHAR) TYPE_SCHEM, \"\n+            + \"CAST(NULL AS VARCHAR) TYPE_NAME, \"\n+            + \"CAST(NULL AS VARCHAR) CLASS_NAME, \"\n+            + \"CAST(NULL AS SMALLINT) DATA_TYPE, \"\n+            + \"CAST(NULL AS VARCHAR) REMARKS, \"\n+            + \"CAST(NULL AS SMALLINT) BASE_TYPE \" + \"FROM DUAL WHERE FALSE\");\n             return prep.executeQuery();\n         } catch (Exception e) {\n             throw logAndConvert(e);\n@@ -1498,32 +1468,31 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the list of data types\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n     public ResultSet getTypeInfo() throws SQLException {\n         try {\n             debugCodeCall(\"getTypeInfo\");\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"TYPE_NAME, \"\n-                    + \"DATA_TYPE, \"\n-                    + \"PRECISION, \"\n-                    + \"PREFIX LITERAL_PREFIX, \"\n-                    + \"SUFFIX LITERAL_SUFFIX, \"\n-                    + \"PARAMS CREATE_PARAMS, \"\n-                    + \"NULLABLE, \"\n-                    + \"CASE_SENSITIVE, \"\n-                    + \"SEARCHABLE, \"\n-                    + \"FALSE UNSIGNED_ATTRIBUTE, \"\n-                    + \"FALSE FIXED_PREC_SCALE, \"\n-                    + \"AUTO_INCREMENT, \"\n-                    + \"TYPE_NAME LOCAL_TYPE_NAME, \"\n-                    + \"MINIMUM_SCALE, \"\n-                    + \"MAXIMUM_SCALE, \"\n-                    + \"DATA_TYPE SQL_DATA_TYPE, \"\n-                    + \"ZERO() SQL_DATETIME_SUB, \"\n-                    + \"RADIX NUM_PREC_RADIX \"\n-                    + \"FROM INFORMATION_SCHEMA.TYPE_INFO \"\n-                    + \"ORDER BY DATA_TYPE, POS\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"TYPE_NAME, \"\n+            + \"DATA_TYPE, \"\n+            + \"PRECISION, \"\n+            + \"PREFIX LITERAL_PREFIX, \"\n+            + \"SUFFIX LITERAL_SUFFIX, \"\n+            + \"PARAMS CREATE_PARAMS, \"\n+            + \"NULLABLE, \"\n+            + \"CASE_SENSITIVE, \"\n+            + \"SEARCHABLE, \"\n+            + \"FALSE UNSIGNED_ATTRIBUTE, \"\n+            + \"FALSE FIXED_PREC_SCALE, \"\n+            + \"AUTO_INCREMENT, \"\n+            + \"TYPE_NAME LOCAL_TYPE_NAME, \"\n+            + \"MINIMUM_SCALE, \"\n+            + \"MAXIMUM_SCALE, \"\n+            + \"DATA_TYPE SQL_DATA_TYPE, \"\n+            + \"ZERO() SQL_DATETIME_SUB, \"\n+            + \"RADIX NUM_PREC_RADIX \"\n+            + \"FROM INFORMATION_SCHEMA.TYPE_INFO \" + \"ORDER BY DATA_TYPE, POS\");\n             return prep.executeQuery();\n         } catch (Exception e) {\n             throw logAndConvert(e);\n@@ -1535,6 +1504,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean usesLocalFiles() {\n         debugCodeCall(\"usesLocalFiles\");\n@@ -1546,6 +1516,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean usesLocalFilePerTable() {\n         debugCodeCall(\"usesLocalFilePerTable\");\n@@ -1557,6 +1528,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return a double quote\n      */\n+\n     @Override\n     public String getIdentifierQuoteString() {\n         debugCodeCall(\"getIdentifierQuoteString\");\n@@ -1581,6 +1553,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return a list of additional the keywords\n      */\n+\n     @Override\n     public String getSQLKeywords() {\n         debugCodeCall(\"getSQLKeywords\");\n@@ -1592,6 +1565,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the list\n      */\n+\n     @Override\n     public String getNumericFunctions() throws SQLException {\n         debugCodeCall(\"getNumericFunctions\");\n@@ -1603,6 +1577,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the list\n      */\n+\n     @Override\n     public String getStringFunctions() throws SQLException {\n         debugCodeCall(\"getStringFunctions\");\n@@ -1614,6 +1589,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the list\n      */\n+\n     @Override\n     public String getSystemFunctions() throws SQLException {\n         debugCodeCall(\"getSystemFunctions\");\n@@ -1625,6 +1601,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the list\n      */\n+\n     @Override\n     public String getTimeDateFunctions() throws SQLException {\n         debugCodeCall(\"getTimeDateFunctions\");\n@@ -1634,8 +1611,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n     private String getFunctions(String section) throws SQLException {\n         try {\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT TOPIC \"\n-                    + \"FROM INFORMATION_SCHEMA.HELP WHERE SECTION = ?\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT TOPIC \" + \"FROM INFORMATION_SCHEMA.HELP WHERE SECTION = ?\");\n             prep.setString(1, section);\n             ResultSet rs = prep.executeQuery();\n             StatementBuilder buff = new StatementBuilder();\n@@ -1667,6 +1643,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the default escape character (always '\\', independent on the\n      *         mode)\n      */\n+\n     @Override\n     public String getSearchStringEscape() {\n         debugCodeCall(\"getSearchStringEscape\");\n@@ -1679,6 +1656,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return an empty String (\"\")\n      */\n+\n     @Override\n     public String getExtraNameCharacters() {\n         debugCodeCall(\"getExtraNameCharacters\");\n@@ -1689,6 +1667,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * Returns whether alter table with add column is supported.\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsAlterTableWithAddColumn() {\n         debugCodeCall(\"supportsAlterTableWithAddColumn\");\n@@ -1700,6 +1679,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsAlterTableWithDropColumn() {\n         debugCodeCall(\"supportsAlterTableWithDropColumn\");\n@@ -1711,6 +1691,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsColumnAliasing() {\n         debugCodeCall(\"supportsColumnAliasing\");\n@@ -1722,6 +1703,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean nullPlusNonNullIsNull() {\n         debugCodeCall(\"nullPlusNonNullIsNull\");\n@@ -1733,6 +1715,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsConvert() {\n         debugCodeCall(\"supportsConvert\");\n@@ -1746,10 +1729,12 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param toType the target SQL type\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsConvert(int fromType, int toType) {\n         if (isDebugEnabled()) {\n-            debugCode(\"supportsConvert(\"+fromType+\", \"+fromType+\");\");\n+            debugCode(\"supportsConvert(\" + fromType + \", \"\n+            + fromType + \");\");\n         }\n         return true;\n     }\n@@ -1759,6 +1744,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsTableCorrelationNames() {\n         debugCodeCall(\"supportsTableCorrelationNames\");\n@@ -1771,6 +1757,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsDifferentTableCorrelationNames() {\n         debugCodeCall(\"supportsDifferentTableCorrelationNames\");\n@@ -1782,6 +1769,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsExpressionsInOrderBy() {\n         debugCodeCall(\"supportsExpressionsInOrderBy\");\n@@ -1794,6 +1782,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsOrderByUnrelated() {\n         debugCodeCall(\"supportsOrderByUnrelated\");\n@@ -1805,6 +1794,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsGroupBy() {\n         debugCodeCall(\"supportsGroupBy\");\n@@ -1817,6 +1807,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsGroupByUnrelated() {\n         debugCodeCall(\"supportsGroupByUnrelated\");\n@@ -1830,6 +1821,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsGroupByBeyondSelect() {\n         debugCodeCall(\"supportsGroupByBeyondSelect\");\n@@ -1841,6 +1833,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsLikeEscapeClause() {\n         debugCodeCall(\"supportsLikeEscapeClause\");\n@@ -1852,6 +1845,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsMultipleResultSets() {\n         debugCodeCall(\"supportsMultipleResultSets\");\n@@ -1864,6 +1858,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsMultipleTransactions() {\n         debugCodeCall(\"supportsMultipleTransactions\");\n@@ -1875,6 +1870,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsNonNullableColumns() {\n         debugCodeCall(\"supportsNonNullableColumns\");\n@@ -1886,6 +1882,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsMinimumSQLGrammar() {\n         debugCodeCall(\"supportsMinimumSQLGrammar\");\n@@ -1897,6 +1894,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsCoreSQLGrammar() {\n         debugCodeCall(\"supportsCoreSQLGrammar\");\n@@ -1908,6 +1906,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsExtendedSQLGrammar() {\n         debugCodeCall(\"supportsExtendedSQLGrammar\");\n@@ -1919,6 +1918,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsANSI92EntryLevelSQL() {\n         debugCodeCall(\"supportsANSI92EntryLevelSQL\");\n@@ -1930,6 +1930,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsANSI92IntermediateSQL() {\n         debugCodeCall(\"supportsANSI92IntermediateSQL\");\n@@ -1941,6 +1942,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsANSI92FullSQL() {\n         debugCodeCall(\"supportsANSI92FullSQL\");\n@@ -1952,6 +1954,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsIntegrityEnhancementFacility() {\n         debugCodeCall(\"supportsIntegrityEnhancementFacility\");\n@@ -1963,6 +1966,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsOuterJoins() {\n         debugCodeCall(\"supportsOuterJoins\");\n@@ -1974,6 +1978,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsFullOuterJoins() {\n         debugCodeCall(\"supportsFullOuterJoins\");\n@@ -1985,6 +1990,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsLimitedOuterJoins() {\n         debugCodeCall(\"supportsLimitedOuterJoins\");\n@@ -1996,6 +2002,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return \"schema\"\n      */\n+\n     @Override\n     public String getSchemaTerm() {\n         debugCodeCall(\"getSchemaTerm\");\n@@ -2007,6 +2014,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return \"procedure\"\n      */\n+\n     @Override\n     public String getProcedureTerm() {\n         debugCodeCall(\"getProcedureTerm\");\n@@ -2018,6 +2026,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return \"catalog\"\n      */\n+\n     @Override\n     public String getCatalogTerm() {\n         debugCodeCall(\"getCatalogTerm\");\n@@ -2029,6 +2038,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean isCatalogAtStart() {\n         debugCodeCall(\"isCatalogAtStart\");\n@@ -2040,6 +2050,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return \".\"\n      */\n+\n     @Override\n     public String getCatalogSeparator() {\n         debugCodeCall(\"getCatalogSeparator\");\n@@ -2051,6 +2062,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSchemasInDataManipulation() {\n         debugCodeCall(\"supportsSchemasInDataManipulation\");\n@@ -2062,6 +2074,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSchemasInProcedureCalls() {\n         debugCodeCall(\"supportsSchemasInProcedureCalls\");\n@@ -2073,6 +2086,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSchemasInTableDefinitions() {\n         debugCodeCall(\"supportsSchemasInTableDefinitions\");\n@@ -2084,6 +2098,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSchemasInIndexDefinitions() {\n         debugCodeCall(\"supportsSchemasInIndexDefinitions\");\n@@ -2095,6 +2110,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSchemasInPrivilegeDefinitions() {\n         debugCodeCall(\"supportsSchemasInPrivilegeDefinitions\");\n@@ -2106,6 +2122,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsCatalogsInDataManipulation() {\n         debugCodeCall(\"supportsCatalogsInDataManipulation\");\n@@ -2117,6 +2134,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsCatalogsInProcedureCalls() {\n         debugCodeCall(\"supportsCatalogsInProcedureCalls\");\n@@ -2128,6 +2146,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsCatalogsInTableDefinitions() {\n         debugCodeCall(\"supportsCatalogsInTableDefinitions\");\n@@ -2139,6 +2158,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsCatalogsInIndexDefinitions() {\n         debugCodeCall(\"supportsCatalogsInIndexDefinitions\");\n@@ -2150,6 +2170,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsCatalogsInPrivilegeDefinitions() {\n         debugCodeCall(\"supportsCatalogsInPrivilegeDefinitions\");\n@@ -2161,6 +2182,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsPositionedDelete() {\n         debugCodeCall(\"supportsPositionedDelete\");\n@@ -2172,6 +2194,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsPositionedUpdate() {\n         debugCodeCall(\"supportsPositionedUpdate\");\n@@ -2183,6 +2206,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSelectForUpdate() {\n         debugCodeCall(\"supportsSelectForUpdate\");\n@@ -2194,6 +2218,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsStoredProcedures() {\n         debugCodeCall(\"supportsStoredProcedures\");\n@@ -2205,6 +2230,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSubqueriesInComparisons() {\n         debugCodeCall(\"supportsSubqueriesInComparisons\");\n@@ -2216,6 +2242,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSubqueriesInExists() {\n         debugCodeCall(\"supportsSubqueriesInExists\");\n@@ -2227,6 +2254,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSubqueriesInIns() {\n         debugCodeCall(\"supportsSubqueriesInIns\");\n@@ -2238,6 +2266,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSubqueriesInQuantifieds() {\n         debugCodeCall(\"supportsSubqueriesInQuantifieds\");\n@@ -2249,6 +2278,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsCorrelatedSubqueries() {\n         debugCodeCall(\"supportsCorrelatedSubqueries\");\n@@ -2260,6 +2290,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsUnion() {\n         debugCodeCall(\"supportsUnion\");\n@@ -2271,6 +2302,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsUnionAll() {\n         debugCodeCall(\"supportsUnionAll\");\n@@ -2282,6 +2314,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsOpenCursorsAcrossCommit() {\n         debugCodeCall(\"supportsOpenCursorsAcrossCommit\");\n@@ -2293,6 +2326,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsOpenCursorsAcrossRollback() {\n         debugCodeCall(\"supportsOpenCursorsAcrossRollback\");\n@@ -2304,6 +2338,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsOpenStatementsAcrossCommit() {\n         debugCodeCall(\"supportsOpenStatementsAcrossCommit\");\n@@ -2315,6 +2350,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsOpenStatementsAcrossRollback() {\n         debugCodeCall(\"supportsOpenStatementsAcrossRollback\");\n@@ -2326,6 +2362,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsTransactions() {\n         debugCodeCall(\"supportsTransactions\");\n@@ -2338,14 +2375,14 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param level the transaction isolation level (Connection.TRANSACTION_*)\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsTransactionIsolationLevel(int level) throws SQLException {\n         debugCodeCall(\"supportsTransactionIsolationLevel\");\n         if (level == Connection.TRANSACTION_READ_UNCOMMITTED) {\n             // currently the combination of LOCK_MODE=0 and MULTI_THREADED\n             // is not supported, also see code in Database#setLockMode(int)\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\n-                    \"SELECT VALUE FROM INFORMATION_SCHEMA.SETTINGS WHERE NAME=?\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT VALUE FROM INFORMATION_SCHEMA.SETTINGS WHERE NAME=?\");\n             prep.setString(1, \"MULTI_THREADED\");\n             ResultSet rs = prep.executeQuery();\n             return !rs.next() || !rs.getString(1).equals(\"1\");\n@@ -2359,6 +2396,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsDataDefinitionAndDataManipulationTransactions() {\n         debugCodeCall(\"supportsDataDefinitionAndDataManipulationTransactions\");\n@@ -2370,6 +2408,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsDataManipulationTransactionsOnly() {\n         debugCodeCall(\"supportsDataManipulationTransactionsOnly\");\n@@ -2381,6 +2420,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean dataDefinitionCausesTransactionCommit() {\n         debugCodeCall(\"dataDefinitionCausesTransactionCommit\");\n@@ -2392,6 +2432,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean dataDefinitionIgnoredInTransactions() {\n         debugCodeCall(\"dataDefinitionIgnoredInTransactions\");\n@@ -2405,6 +2446,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return true for all types except ResultSet.TYPE_FORWARD_ONLY\n      */\n+\n     @Override\n     public boolean supportsResultSetType(int type) {\n         debugCodeCall(\"supportsResultSetType\", type);\n@@ -2419,10 +2461,12 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param concurrency the result set concurrency\n      * @return true if the type is not ResultSet.TYPE_SCROLL_SENSITIVE\n      */\n+\n     @Override\n     public boolean supportsResultSetConcurrency(int type, int concurrency) {\n         if (isDebugEnabled()) {\n-            debugCode(\"supportsResultSetConcurrency(\"+type+\", \"+concurrency+\");\");\n+            debugCode(\"supportsResultSetConcurrency(\" + type + \", \"\n+            + concurrency + \");\");\n         }\n         return type != ResultSet.TYPE_SCROLL_SENSITIVE;\n     }\n@@ -2433,6 +2477,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return true\n      */\n+\n     @Override\n     public boolean ownUpdatesAreVisible(int type) {\n         debugCodeCall(\"ownUpdatesAreVisible\", type);\n@@ -2445,6 +2490,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return false\n      */\n+\n     @Override\n     public boolean ownDeletesAreVisible(int type) {\n         debugCodeCall(\"ownDeletesAreVisible\", type);\n@@ -2457,6 +2503,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return false\n      */\n+\n     @Override\n     public boolean ownInsertsAreVisible(int type) {\n         debugCodeCall(\"ownInsertsAreVisible\", type);\n@@ -2469,6 +2516,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return false\n      */\n+\n     @Override\n     public boolean othersUpdatesAreVisible(int type) {\n         debugCodeCall(\"othersUpdatesAreVisible\", type);\n@@ -2481,6 +2529,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return false\n      */\n+\n     @Override\n     public boolean othersDeletesAreVisible(int type) {\n         debugCodeCall(\"othersDeletesAreVisible\", type);\n@@ -2493,6 +2542,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return false\n      */\n+\n     @Override\n     public boolean othersInsertsAreVisible(int type) {\n         debugCodeCall(\"othersInsertsAreVisible\", type);\n@@ -2505,6 +2555,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return false\n      */\n+\n     @Override\n     public boolean updatesAreDetected(int type) {\n         debugCodeCall(\"updatesAreDetected\", type);\n@@ -2517,6 +2568,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return false\n      */\n+\n     @Override\n     public boolean deletesAreDetected(int type) {\n         debugCodeCall(\"deletesAreDetected\", type);\n@@ -2529,6 +2581,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param type the result set type\n      * @return false\n      */\n+\n     @Override\n     public boolean insertsAreDetected(int type) {\n         debugCodeCall(\"insertsAreDetected\", type);\n@@ -2540,6 +2593,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsBatchUpdates() {\n         debugCodeCall(\"supportsBatchUpdates\");\n@@ -2551,6 +2605,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean doesMaxRowSizeIncludeBlobs() {\n         debugCodeCall(\"doesMaxRowSizeIncludeBlobs\");\n@@ -2562,6 +2617,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return Connection.TRANSACTION_READ_COMMITTED\n      */\n+\n     @Override\n     public int getDefaultTransactionIsolation() {\n         debugCodeCall(\"getDefaultTransactionIsolation\");\n@@ -2574,6 +2630,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsMixedCaseIdentifiers() {\n         debugCodeCall(\"supportsMixedCaseIdentifiers\");\n@@ -2586,6 +2643,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true usually, and false in MySQL mode\n      */\n+\n     @Override\n     public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\n         debugCodeCall(\"supportsMixedCaseQuotedIdentifiers\");\n@@ -2599,6 +2657,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true usually, and false in MySQL mode\n      */\n+\n     @Override\n     public boolean storesUpperCaseIdentifiers() throws SQLException {\n         debugCodeCall(\"storesUpperCaseIdentifiers\");\n@@ -2612,6 +2671,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false usually, and true in MySQL mode\n      */\n+\n     @Override\n     public boolean storesLowerCaseIdentifiers() throws SQLException {\n         debugCodeCall(\"storesLowerCaseIdentifiers\");\n@@ -2625,6 +2685,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean storesMixedCaseIdentifiers() {\n         debugCodeCall(\"storesMixedCaseIdentifiers\");\n@@ -2637,6 +2698,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false usually, and true in MySQL mode\n      */\n+\n     @Override\n     public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {\n         debugCodeCall(\"storesUpperCaseQuotedIdentifiers\");\n@@ -2650,6 +2712,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false usually, and true in MySQL mode\n      */\n+\n     @Override\n     public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {\n         debugCodeCall(\"storesLowerCaseQuotedIdentifiers\");\n@@ -2663,6 +2726,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true usually, and false in MySQL mode\n      */\n+\n     @Override\n     public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {\n         debugCodeCall(\"storesMixedCaseQuotedIdentifiers\");\n@@ -2675,6 +2739,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxBinaryLiteralLength() {\n         debugCodeCall(\"getMaxBinaryLiteralLength\");\n@@ -2686,6 +2751,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxCharLiteralLength() {\n         debugCodeCall(\"getMaxCharLiteralLength\");\n@@ -2697,6 +2763,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxColumnNameLength() {\n         debugCodeCall(\"getMaxColumnNameLength\");\n@@ -2708,6 +2775,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxColumnsInGroupBy() {\n         debugCodeCall(\"getMaxColumnsInGroupBy\");\n@@ -2719,6 +2787,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxColumnsInIndex() {\n         debugCodeCall(\"getMaxColumnsInIndex\");\n@@ -2730,6 +2799,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxColumnsInOrderBy() {\n         debugCodeCall(\"getMaxColumnsInOrderBy\");\n@@ -2741,6 +2811,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxColumnsInSelect() {\n         debugCodeCall(\"getMaxColumnsInSelect\");\n@@ -2752,6 +2823,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxColumnsInTable() {\n         debugCodeCall(\"getMaxColumnsInTable\");\n@@ -2763,6 +2835,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxConnections() {\n         debugCodeCall(\"getMaxConnections\");\n@@ -2774,6 +2847,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxCursorNameLength() {\n         debugCodeCall(\"getMaxCursorNameLength\");\n@@ -2785,6 +2859,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxIndexLength() {\n         debugCodeCall(\"getMaxIndexLength\");\n@@ -2796,6 +2871,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxSchemaNameLength() {\n         debugCodeCall(\"getMaxSchemaNameLength\");\n@@ -2807,6 +2883,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxProcedureNameLength() {\n         debugCodeCall(\"getMaxProcedureNameLength\");\n@@ -2818,6 +2895,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxCatalogNameLength() {\n         debugCodeCall(\"getMaxCatalogNameLength\");\n@@ -2829,6 +2907,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxRowSize() {\n         debugCodeCall(\"getMaxRowSize\");\n@@ -2840,6 +2919,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxStatementLength() {\n         debugCodeCall(\"getMaxStatementLength\");\n@@ -2851,6 +2931,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxStatements() {\n         debugCodeCall(\"getMaxStatements\");\n@@ -2862,6 +2943,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxTableNameLength() {\n         debugCodeCall(\"getMaxTableNameLength\");\n@@ -2873,6 +2955,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxTablesInSelect() {\n         debugCodeCall(\"getMaxTablesInSelect\");\n@@ -2884,6 +2967,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return 0 for limit is unknown\n      */\n+\n     @Override\n     public int getMaxUserNameLength() {\n         debugCodeCall(\"getMaxUserNameLength\");\n@@ -2895,6 +2979,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsSavepoints() {\n         debugCodeCall(\"supportsSavepoints\");\n@@ -2906,6 +2991,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsNamedParameters() {\n         debugCodeCall(\"supportsNamedParameters\");\n@@ -2917,6 +3003,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsMultipleOpenResults() {\n         debugCodeCall(\"supportsMultipleOpenResults\");\n@@ -2928,6 +3015,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsGetGeneratedKeys() {\n         debugCodeCall(\"supportsGetGeneratedKeys\");\n@@ -2937,9 +3025,9 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n     /**\n      * [Not supported]\n      */\n+\n     @Override\n-    public ResultSet getSuperTypes(String catalog, String schemaPattern,\n-            String typeNamePattern) throws SQLException {\n+    public ResultSet getSuperTypes(String catalog, String schemaPattern, String typeNamePattern) throws SQLException {\n         throw unsupported(\"superTypes\");\n     }\n \n@@ -2960,24 +3048,21 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *            (uppercase for unquoted names)\n      * @return an empty result set\n      */\n+\n     @Override\n-    public ResultSet getSuperTables(String catalog, String schemaPattern,\n-            String tableNamePattern) throws SQLException {\n+    public ResultSet getSuperTables(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {\n         try {\n             if (isDebugEnabled()) {\n-                debugCode(\"getSuperTables(\"\n-                        +quote(catalog)+\", \"\n-                        +quote(schemaPattern)+\", \"\n-                        +quote(tableNamePattern)+\");\");\n+                debugCode(\"getSuperTables(\" + quote(catalog) + \", \"\n+                + quote(schemaPattern) + \", \"\n+                + quote(tableNamePattern) + \");\");\n             }\n             checkClosed();\n-            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \"\n-                    + \"CATALOG_NAME TABLE_CAT, \"\n-                    + \"CATALOG_NAME TABLE_SCHEM, \"\n-                    + \"CATALOG_NAME TABLE_NAME, \"\n-                    + \"CATALOG_NAME SUPERTABLE_NAME \"\n-                    + \"FROM INFORMATION_SCHEMA.CATALOGS \"\n-                    + \"WHERE FALSE\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"CATALOG_NAME TABLE_CAT, \"\n+            + \"CATALOG_NAME TABLE_SCHEM, \"\n+            + \"CATALOG_NAME TABLE_NAME, \"\n+            + \"CATALOG_NAME SUPERTABLE_NAME \"\n+            + \"FROM INFORMATION_SCHEMA.CATALOGS \" + \"WHERE FALSE\");\n             return prep.executeQuery();\n         } catch (Exception e) {\n             throw logAndConvert(e);\n@@ -2987,10 +3072,9 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n     /**\n      * [Not supported]\n      */\n+\n     @Override\n-    public ResultSet getAttributes(String catalog, String schemaPattern,\n-            String typeNamePattern, String attributeNamePattern)\n-            throws SQLException {\n+    public ResultSet getAttributes(String catalog, String schemaPattern, String typeNamePattern, String attributeNamePattern) throws SQLException {\n         throw unsupported(\"attributes\");\n     }\n \n@@ -3001,6 +3085,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *            CLOSE_CURSORS_AT_COMMIT\n      * @return true if the holdability is ResultSet.CLOSE_CURSORS_AT_COMMIT\n      */\n+\n     @Override\n     public boolean supportsResultSetHoldability(int holdability) {\n         debugCodeCall(\"supportsResultSetHoldability\", holdability);\n@@ -3012,6 +3097,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return ResultSet.CLOSE_CURSORS_AT_COMMIT\n      */\n+\n     @Override\n     public int getResultSetHoldability() {\n         debugCodeCall(\"getResultSetHoldability\");\n@@ -3023,6 +3109,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the major version\n      */\n+\n     @Override\n     public int getDatabaseMajorVersion() {\n         debugCodeCall(\"getDatabaseMajorVersion\");\n@@ -3034,6 +3121,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the minor version\n      */\n+\n     @Override\n     public int getDatabaseMinorVersion() {\n         debugCodeCall(\"getDatabaseMinorVersion\");\n@@ -3045,6 +3133,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the major version (4)\n      */\n+\n     @Override\n     public int getJDBCMajorVersion() {\n         debugCodeCall(\"getJDBCMajorVersion\");\n@@ -3056,6 +3145,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return the minor version (0)\n      */\n+\n     @Override\n     public int getJDBCMinorVersion() {\n         debugCodeCall(\"getJDBCMinorVersion\");\n@@ -3067,6 +3157,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return DatabaseMetaData.sqlStateSQL99\n      */\n+\n     @Override\n     public int getSQLStateType() {\n         debugCodeCall(\"getSQLStateType\");\n@@ -3078,6 +3169,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean locatorsUpdateCopy() {\n         debugCodeCall(\"locatorsUpdateCopy\");\n@@ -3089,6 +3181,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean supportsStatementPooling() {\n         debugCodeCall(\"supportsStatementPooling\");\n@@ -3106,15 +3199,13 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n     }\n \n     private static String getSchemaPattern(String pattern) {\n-        return pattern == null ? \"%\" : pattern.length() == 0 ?\n-                Constants.SCHEMA_MAIN : pattern;\n+        return pattern == null ? \"%\" : pattern.length() == 0 ? Constants.SCHEMA_MAIN : pattern;\n     }\n \n     private static String getCatalogPattern(String catalogPattern) {\n         // Workaround for OpenOffice: getColumns is called with \"\" as the\n         // catalog\n-        return catalogPattern == null || catalogPattern.length() == 0 ?\n-                \"%\" : catalogPattern;\n+        return catalogPattern == null || catalogPattern.length() == 0 ? \"%\" : catalogPattern;\n     }\n \n     /**\n@@ -3122,6 +3213,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return ROWID_UNSUPPORTED\n      */\n+\n     @Override\n     public RowIdLifetime getRowIdLifetime() {\n         debugCodeCall(\"getRowIdLifetime\");\n@@ -3144,21 +3236,18 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @return the schema list\n      * @throws SQLException if the connection is closed\n      */\n+\n     @Override\n-    public ResultSet getSchemas(String catalogPattern, String schemaPattern)\n-            throws SQLException {\n+    public ResultSet getSchemas(String catalogPattern, String schemaPattern) throws SQLException {\n         try {\n             debugCodeCall(\"getSchemas(String,String)\");\n             checkClosed();\n-            PreparedStatement prep = conn\n-                    .prepareAutoCloseStatement(\"SELECT \"\n-                            + \"SCHEMA_NAME TABLE_SCHEM, \"\n-                            + \"CATALOG_NAME TABLE_CATALOG, \"\n-                            +\" IS_DEFAULT \"\n-                            + \"FROM INFORMATION_SCHEMA.SCHEMATA \"\n-                            + \"WHERE CATALOG_NAME LIKE ? ESCAPE ? \"\n-                            + \"AND SCHEMA_NAME LIKE ? ESCAPE ? \"\n-                            + \"ORDER BY SCHEMA_NAME\");\n+            PreparedStatement prep = conn.prepareAutoCloseStatement(\"SELECT \" + \"SCHEMA_NAME TABLE_SCHEM, \"\n+            + \"CATALOG_NAME TABLE_CATALOG, \"\n+            + \" IS_DEFAULT \"\n+            + \"FROM INFORMATION_SCHEMA.SCHEMATA \"\n+            + \"WHERE CATALOG_NAME LIKE ? ESCAPE ? \"\n+            + \"AND SCHEMA_NAME LIKE ? ESCAPE ? \" + \"ORDER BY SCHEMA_NAME\");\n             prep.setString(1, getCatalogPattern(catalogPattern));\n             prep.setString(2, \"\\\\\");\n             prep.setString(3, getSchemaPattern(schemaPattern));\n@@ -3175,6 +3264,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return true\n      */\n+\n     @Override\n     public boolean supportsStoredFunctionsUsingCallSyntax() {\n         debugCodeCall(\"supportsStoredFunctionsUsingCallSyntax\");\n@@ -3187,6 +3277,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      *\n      * @return false\n      */\n+\n     @Override\n     public boolean autoCommitFailureClosesAllResultSets() {\n         debugCodeCall(\"autoCommitFailureClosesAllResultSets\");\n@@ -3211,6 +3302,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param iface the class\n      * @return this\n      */\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T> T unwrap(Class<T> iface) throws SQLException {\n@@ -3230,6 +3322,7 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param iface the class\n      * @return whether or not the interface is assignable from this class\n      */\n+\n     @Override\n     public boolean isWrapperFor(Class<?> iface) throws SQLException {\n         return iface != null && iface.isAssignableFrom(getClass());\n@@ -3238,25 +3331,25 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n     /**\n      * [Not supported] Gets the list of function columns.\n      */\n+\n     @Override\n-    public ResultSet getFunctionColumns(String catalog, String schemaPattern,\n-            String functionNamePattern, String columnNamePattern)\n-            throws SQLException {\n+    public ResultSet getFunctionColumns(String catalog, String schemaPattern, String functionNamePattern, String columnNamePattern) throws SQLException {\n         throw unsupported(\"getFunctionColumns\");\n     }\n \n     /**\n      * [Not supported] Gets the list of functions.\n      */\n+\n     @Override\n-    public ResultSet getFunctions(String catalog, String schemaPattern,\n-            String functionNamePattern) throws SQLException {\n+    public ResultSet getFunctions(String catalog, String schemaPattern, String functionNamePattern) throws SQLException {\n         throw unsupported(\"getFunctions\");\n     }\n \n     /**\n      * [Not supported]\n      */\n+\n     @Override\n     public boolean generatedKeyAlwaysReturned() {\n         return true;\n@@ -3273,18 +3366,19 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n      * @param columnNamePattern null (to get all objects) or a column name\n      *            (uppercase for unquoted names)\n      */\n+\n     @Override\n-    public ResultSet getPseudoColumns(String catalog, String schemaPattern,\n-            String tableNamePattern, String columnNamePattern) {\n+    public ResultSet getPseudoColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) {\n         return null;\n     }\n \n     /**\n      * INTERNAL\n      */\n+\n     @Override\n     public String toString() {\n         return getTraceObjectName() + \": \" + conn;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 706
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/241/JdbcDatabaseMetaData.java\nindex 693383340bd..73fd2a9d3ef 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/241/JdbcDatabaseMetaData.java\n@@ -126,8 +126,9 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n                     hasSynonyms = true;\n                 } else if (clientVersion <= Constants.TCP_PROTOCOL_VERSION_15) {\n                     hasSynonyms = false;\n-                } else { // 1.4.194-1.4.196\n-                    CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n+                } else {\n+                    // 1.4.194-1.4.196\n+                CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n                     ResultInterface result = c.executeQuery(0, false);\n                     result.next();\n                     String s = result.currentRow()[0].getString();\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/241/JdbcDatabaseMetaData.java\nindex 693383340bd..61acedd4f1f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/241/JdbcDatabaseMetaData.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/241/JdbcDatabaseMetaData.java\n@@ -126,8 +126,9 @@ public class JdbcDatabaseMetaData extends TraceObject implements\n                     hasSynonyms = true;\n                 } else if (clientVersion <= Constants.TCP_PROTOCOL_VERSION_15) {\n                     hasSynonyms = false;\n-                } else { // 1.4.194-1.4.196\n-                    CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n+                } else {\n+                // 1.4.194-1.4.196 CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n+                 CommandInterface c = sr.prepareCommand(\"CALL H2VERSION()\", Integer.MAX_VALUE);\n                     ResultInterface result = c.executeQuery(0, false);\n                     result.next();\n                     String s = result.currentRow()[0].getString();\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff"
    ]
}