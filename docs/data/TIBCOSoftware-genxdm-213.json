{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "213",
    "information": {
        "errors": [
            {
                "line": "35",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class IdentitySelector\n{\n\tpublic static final boolean DEBUG = false;\n\n\t// We will callback the scope to indicate that the selector has matched.\n\t// We issue one event for the start and one event for the end in a pair.",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "37",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/213/IdentitySelector.java\nindex 27db22c9cdf..395a4df861c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/213/IdentitySelector.java\n@@ -32,7 +32,7 @@ import org.genxdm.xs.exceptions.AbortException;\n  */\n final class IdentitySelector\n {\n-\tpublic static final boolean DEBUG = false;\n+public static final boolean DEBUG = false;\n \n \t// We will callback the scope to indicate that the selector has matched.\n \t// We issue one event for the start and one event for the end in a pair.\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/213/IdentitySelector.java\nindex 27db22c9cdf..74f0a5f260b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/213/IdentitySelector.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.lang.reflect.Array;\n@@ -30,185 +31,156 @@ import org.genxdm.xs.exceptions.AbortException;\n  * Provides a streaming evaluation of a restricted XPath expression. <br/>\n  * When certain conditions are met, a match handler is called\n  */\n-final class IdentitySelector\n-{\n-\tpublic static final boolean DEBUG = false;\n-\n-\t// We will callback the scope to indicate that the selector has matched.\n-\t// We issue one event for the start and one event for the end in a pair.\n-\tprivate final IdentityScope m_scope;\n-\n-\t// a List of branches, representing a parsed identity (selector or field)\n-\t// XPath expression\n-\tprivate final RestrictedXPath m_xpath[];\n-\n-\t/**\n-\t * The possibility of having \"//\" in the XPath expression means that a single XPath expression may have many\n-\t * simultaneous evaluations. We keep track of these with a list of status objects. The outer index is again for\n-\t * alternate XPath expressions.\n-\t */\n-\tprivate final ArrayList<LinkedList<IdentitySelectorEvaluation>> m_evals;\n-\n-\t// true if that branch started with \".//\"\n-\tprivate final boolean[] m_relocatable;\n-\n-\tprivate int m_depth = -1;\n-\n-\t/**\n-\t * @param xpath\n-\t *            representing the parsed attribute xpath\n-\t */\n-\tpublic IdentitySelector(final IdentityScope scope, final RestrictedXPath xpath)\n-\t{\n-\t\tm_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n-\n-\t\t// Count the number of branches, that is, the number of XPath\n-\t\t// expressions separated by \"|\".\n-\t\tint size = 0;\n-\t\tfor (RestrictedXPath branch = xpath; branch != null; branch = branch.getAlternate())\n-\t\t{\n-\t\t\t// System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n-\t\t\t// branch);\n-\t\t\tsize++;\n-\t\t}\n-\n-\t\tm_relocatable = new boolean[size];\n-\t\tm_xpath = (RestrictedXPath[])Array.newInstance(RestrictedXPath.class, size);\n-\t\tm_evals = new ArrayList<LinkedList<IdentitySelectorEvaluation>>(size);\n-\t\tRestrictedXPath branch = xpath;\n-\t\tfor (int i = size - 1; i >= 0; i--)\n-\t\t{\n-\t\t\t// put them backwards\n-\t\t\tif (null == branch)\n-\t\t\t{\n-\t\t\t\tthrow new RuntimeException();\n-\t\t\t}\n-\t\t\tm_xpath[i] = branch;\n-\t\t\tm_relocatable[i] = branch.isRelocatable();\n-\t\t\tbranch = branch.getAlternate();\n-\t\t}\n-\t\tfor (int i = 0; i < size; i++)\n-\t\t{\n-\t\t\tfinal LinkedList<IdentitySelectorEvaluation> e = new LinkedList<IdentitySelectorEvaluation>();\n-\t\t\te.add(new IdentitySelectorEvaluation(m_xpath[i], false));\n-\t\t\tm_evals.add(e);\n-\t\t}\n-\t}\n-\n-\tpublic void startElement(final QName elementName, final int elementIndex)\n-\t{\n-\t\tm_depth++;\n-\n-\t\tfor (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without getting a concurrent modification exception\n-\t\t\t// (would happen through the list).\n-\t\t\tfinal Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n-\t\t\twhile (it.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentitySelectorEvaluation xps = it.next();\n-\n-\t\t\t\txps.advance();\n-\n-\t\t\t\tif (xps.inBounds())\n-\t\t\t\t{\n-\t\t\t\t\tif (xps.matchesElement(elementName))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.onLastStep())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_scope.startSelectorElement(elementName, elementIndex);\n-\t\t\t\t\t\t\txps.setSelecting(true);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// TODO: The following code pertains to relocation.\n-\t\t\tif (m_depth > 0 && m_relocatable[unionIdx])\n-\t\t\t{\n-\t\t\t\tif (matchesElement(m_xpath[unionIdx], 0, elementName))\n-\t\t\t\t{\n-\t\t\t\t\tfinal IdentitySelectorEvaluation xps = new IdentitySelectorEvaluation(m_xpath[unionIdx], true);\n-\t\t\t\t\tif (xps.onLastStep())\n-\t\t\t\t\t{\n-\t\t\t\t\t\tm_scope.startSelectorElement(elementName, elementIndex);\n-\t\t\t\t\t\txps.setSelecting(true);\n-\t\t\t\t\t}\n-\t\t\t\t\tm_evals.get(unionIdx).add(xps);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void endElement(final QName elementName, final int elementIndex, final Locatable location) throws AbortException\n-\t{\n-\t\tm_depth--;\n-\t\tfor (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without\n-\t\t\t// getting a concurrent modification exception (would happen through\n-\t\t\t// the list).\n-\t\t\tfinal Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n-\t\t\twhile (it.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentitySelectorEvaluation xps = it.next();\n-\t\t\t\tif (xps.inBounds())\n-\t\t\t\t{\n-\t\t\t\t\t// Use the flag to avoid checking for a match and last step.\n-\t\t\t\t\tif (xps.isSelecting())\n-\t\t\t\t\t{\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_scope.endSelectorElement(elementName, elementIndex, location);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tfinally\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\txps.setSelecting(false);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\txps.retreat();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate boolean matchesElement(final RestrictedXPath xpath, final int idxStep, final QName elementName)\n-\t{\n-\t\tif (xpath.isAttribute())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (xpath.isContextNode(idxStep))\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal String stepLN = xpath.getStepLocalName(idxStep);\n-\t\t\tfinal String stepNS = xpath.getStepNamespace(idxStep);\n-\n-\t\t\tif (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(elementName.getNamespaceURI())))\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn elementName.getLocalPart().equals(stepLN) && elementName.getNamespaceURI().equals(stepNS);\n-\t\t\t}\n-\t\t}\n-\t}\n+final class IdentitySelector {\n+    public static final boolean DEBUG = false;\n+\n+    // We will callback the scope to indicate that the selector has matched.\n+    // We issue one event for the start and one event for the end in a pair.\n+    private final IdentityScope m_scope;\n+\n+    // a List of branches, representing a parsed identity (selector or field)\n+    // XPath expression\n+    private final RestrictedXPath m_xpath[];\n+\n+    /**\n+     * The possibility of having \"//\" in the XPath expression means that a single XPath expression may have many\n+     * simultaneous evaluations. We keep track of these with a list of status objects. The outer index is again for\n+     * alternate XPath expressions.\n+     */\n+    private final ArrayList<LinkedList<IdentitySelectorEvaluation>> m_evals;\n+\n+    // true if that branch started with \".//\"\n+    private final boolean[] m_relocatable;\n+\n+    private int m_depth = -1;\n+\n+    /**\n+     * @param xpath\n+     *            representing the parsed attribute xpath\n+     */\n+    public IdentitySelector(final IdentityScope scope, final RestrictedXPath xpath) {\n+        m_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n+\n+        // Count the number of branches, that is, the number of XPath\n+        // expressions separated by \"|\".\n+        int size = 0;\n+        for (RestrictedXPath branch = xpath; branch != null; branch = branch.getAlternate()) {\n+            // System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n+            // branch);\n+            size++;\n+        }\n+\n+        m_relocatable = new boolean[size];\n+        m_xpath = (RestrictedXPath[]) Array.newInstance(RestrictedXPath.class, size);\n+        m_evals = new ArrayList<LinkedList<IdentitySelectorEvaluation>>(size);\n+        RestrictedXPath branch = xpath;\n+        for (int i = size - 1; i >= 0; i--) {\n+            // put them backwards\n+            if (null == branch) {\n+                throw new RuntimeException();\n+            }\n+            m_xpath[i] = branch;\n+            m_relocatable[i] = branch.isRelocatable();\n+            branch = branch.getAlternate();\n+        }\n+        for (int i = 0; i < size; i++) {\n+            final LinkedList<IdentitySelectorEvaluation> e =\n+                new LinkedList<IdentitySelectorEvaluation>();\n+            e.add(new IdentitySelectorEvaluation(m_xpath[i], false));\n+            m_evals.add(e);\n+        }\n+    }\n+\n+    public void startElement(final QName elementName, final int elementIndex) {\n+        m_depth++;\n+\n+        for (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--) {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without getting a concurrent modification exception\n+            // (would happen through the list).\n+            final Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n+            while (it.hasNext()) {\n+                final IdentitySelectorEvaluation xps = it.next();\n+\n+                xps.advance();\n+\n+                if (xps.inBounds()) {\n+                    if (xps.matchesElement(elementName)) {\n+                        if (xps.onLastStep()) {\n+                            m_scope.startSelectorElement(elementName, elementIndex);\n+                            xps.setSelecting(true);\n+                        }\n+                    } else {\n+                        if (xps.removable) {\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // TODO: The following code pertains to relocation.\n+            if (m_depth > 0 && m_relocatable[unionIdx]) {\n+                if (matchesElement(m_xpath[unionIdx], 0, elementName)) {\n+                    final IdentitySelectorEvaluation xps =\n+                        new IdentitySelectorEvaluation(m_xpath[unionIdx], true);\n+                    if (xps.onLastStep()) {\n+                        m_scope.startSelectorElement(elementName, elementIndex);\n+                        xps.setSelecting(true);\n+                    }\n+                    m_evals.get(unionIdx).add(xps);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void endElement(final QName elementName, final int elementIndex,\n+                           final Locatable location) throws AbortException {\n+        m_depth--;\n+        for (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--) {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without\n+            // getting a concurrent modification exception (would happen through\n+            // the list).\n+            final Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n+            while (it.hasNext()) {\n+                final IdentitySelectorEvaluation xps = it.next();\n+                if (xps.inBounds()) {\n+                    // Use the flag to avoid checking for a match and last step.\n+                    if (xps.isSelecting()) {\n+                        try {\n+                            m_scope.endSelectorElement(elementName, elementIndex, location);\n+                        } finally {\n+                            xps.setSelecting(false);\n+                        }\n+                    }\n+                    if (xps.removable) {\n+                        it.remove();\n+                    }\n+                }\n+                xps.retreat();\n+            }\n+        }\n+    }\n+\n+    private boolean matchesElement(final RestrictedXPath xpath, final int idxStep,\n+                                   final QName elementName) {\n+        if (xpath.isAttribute()) {\n+            return false;\n+        }\n+\n+        if (xpath.isContextNode(idxStep)) {\n+            return true;\n+        } else {\n+            final String stepLN = xpath.getStepLocalName(idxStep);\n+            final String stepNS = xpath.getStepNamespace(idxStep);\n+\n+            if (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) ||\n+                stepNS.equals(elementName.getNamespaceURI()))) {\n+                return true;\n+            } else {\n+                return elementName.getLocalPart().equals(stepLN) &&\n+                    elementName.getNamespaceURI().equals(stepNS);\n+            }\n+        }\n+    }\n }\n",
            "diff_size": 186
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "37",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/213/IdentitySelector.java\nindex 27db22c9cdf..2acf6559c59 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/213/IdentitySelector.java\n@@ -32,7 +32,7 @@ import org.genxdm.xs.exceptions.AbortException;\n  */\n final class IdentitySelector\n {\n-\tpublic static final boolean DEBUG = false;\n+    public static final boolean DEBUG = false;\n \n \t// We will callback the scope to indicate that the selector has matched.\n \t// We issue one event for the start and one event for the end in a pair.\n@@ -60,17 +60,17 @@ final class IdentitySelector\n \t */\n \tpublic IdentitySelector(final IdentityScope scope, final RestrictedXPath xpath)\n \t{\n-\t\tm_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n+    m_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n \n \t\t// Count the number of branches, that is, the number of XPath\n \t\t// expressions separated by \"|\".\n \t\tint size = 0;\n \t\tfor (RestrictedXPath branch = xpath; branch != null; branch = branch.getAlternate())\n \t\t{\n-\t\t\t// System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n+    // System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n \t\t\t// branch);\n \t\t\tsize++;\n-\t\t}\n+    }\n \n \t\tm_relocatable = new boolean[size];\n \t\tm_xpath = (RestrictedXPath[])Array.newInstance(RestrictedXPath.class, size);\n@@ -78,137 +78,137 @@ final class IdentitySelector\n \t\tRestrictedXPath branch = xpath;\n \t\tfor (int i = size - 1; i >= 0; i--)\n \t\t{\n-\t\t\t// put them backwards\n+    // put them backwards\n \t\t\tif (null == branch)\n \t\t\t{\n-\t\t\t\tthrow new RuntimeException();\n-\t\t\t}\n+    throw new RuntimeException();\n+    }\n \t\t\tm_xpath[i] = branch;\n \t\t\tm_relocatable[i] = branch.isRelocatable();\n \t\t\tbranch = branch.getAlternate();\n-\t\t}\n+    }\n \t\tfor (int i = 0; i < size; i++)\n \t\t{\n-\t\t\tfinal LinkedList<IdentitySelectorEvaluation> e = new LinkedList<IdentitySelectorEvaluation>();\n+    final LinkedList<IdentitySelectorEvaluation> e = new LinkedList<IdentitySelectorEvaluation>();\n \t\t\te.add(new IdentitySelectorEvaluation(m_xpath[i], false));\n \t\t\tm_evals.add(e);\n-\t\t}\n-\t}\n+    }\n+    }\n \n \tpublic void startElement(final QName elementName, final int elementIndex)\n \t{\n-\t\tm_depth++;\n+    m_depth++;\n \n \t\tfor (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--)\n \t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n+    // Note: Use an Iterator here so that we can remove (through the\n \t\t\t// iterator) without getting a concurrent modification exception\n \t\t\t// (would happen through the list).\n \t\t\tfinal Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n \t\t\twhile (it.hasNext())\n \t\t\t{\n-\t\t\t\tfinal IdentitySelectorEvaluation xps = it.next();\n+    final IdentitySelectorEvaluation xps = it.next();\n \n \t\t\t\txps.advance();\n \n \t\t\t\tif (xps.inBounds())\n \t\t\t\t{\n-\t\t\t\t\tif (xps.matchesElement(elementName))\n+    if (xps.matchesElement(elementName))\n \t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.onLastStep())\n+    if (xps.onLastStep())\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_scope.startSelectorElement(elementName, elementIndex);\n+    m_scope.startSelectorElement(elementName, elementIndex);\n \t\t\t\t\t\t\txps.setSelecting(true);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+    }\n+    }\n \t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.removable)\n+    if (xps.removable)\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+    it.remove();\n+    }\n+    }\n+    }\n+    }\n \n \t\t\t// TODO: The following code pertains to relocation.\n \t\t\tif (m_depth > 0 && m_relocatable[unionIdx])\n \t\t\t{\n-\t\t\t\tif (matchesElement(m_xpath[unionIdx], 0, elementName))\n+    if (matchesElement(m_xpath[unionIdx], 0, elementName))\n \t\t\t\t{\n-\t\t\t\t\tfinal IdentitySelectorEvaluation xps = new IdentitySelectorEvaluation(m_xpath[unionIdx], true);\n+    final IdentitySelectorEvaluation xps = new IdentitySelectorEvaluation(m_xpath[unionIdx], true);\n \t\t\t\t\tif (xps.onLastStep())\n \t\t\t\t\t{\n-\t\t\t\t\t\tm_scope.startSelectorElement(elementName, elementIndex);\n+    m_scope.startSelectorElement(elementName, elementIndex);\n \t\t\t\t\t\txps.setSelecting(true);\n-\t\t\t\t\t}\n+    }\n \t\t\t\t\tm_evals.get(unionIdx).add(xps);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n+    }\n+    }\n+    }\n+    }\n \n \tpublic void endElement(final QName elementName, final int elementIndex, final Locatable location) throws AbortException\n \t{\n-\t\tm_depth--;\n+    m_depth--;\n \t\tfor (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--)\n \t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n+    // Note: Use an Iterator here so that we can remove (through the\n \t\t\t// iterator) without\n \t\t\t// getting a concurrent modification exception (would happen through\n \t\t\t// the list).\n \t\t\tfinal Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n \t\t\twhile (it.hasNext())\n \t\t\t{\n-\t\t\t\tfinal IdentitySelectorEvaluation xps = it.next();\n+    final IdentitySelectorEvaluation xps = it.next();\n \t\t\t\tif (xps.inBounds())\n \t\t\t\t{\n-\t\t\t\t\t// Use the flag to avoid checking for a match and last step.\n+    // Use the flag to avoid checking for a match and last step.\n \t\t\t\t\tif (xps.isSelecting())\n \t\t\t\t\t{\n-\t\t\t\t\t\ttry\n+    try\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_scope.endSelectorElement(elementName, elementIndex, location);\n-\t\t\t\t\t\t}\n+    m_scope.endSelectorElement(elementName, elementIndex, location);\n+    }\n \t\t\t\t\t\tfinally\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\txps.setSelecting(false);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+    xps.setSelecting(false);\n+    }\n+    }\n \t\t\t\t\tif (xps.removable)\n \t\t\t\t\t{\n-\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n+    it.remove();\n+    }\n+    }\n \t\t\t\txps.retreat();\n-\t\t\t}\n-\t\t}\n-\t}\n+    }\n+    }\n+    }\n \n \tprivate boolean matchesElement(final RestrictedXPath xpath, final int idxStep, final QName elementName)\n \t{\n-\t\tif (xpath.isAttribute())\n+    if (xpath.isAttribute())\n \t\t{\n-\t\t\treturn false;\n-\t\t}\n+    return false;\n+    }\n \n \t\tif (xpath.isContextNode(idxStep))\n \t\t{\n-\t\t\treturn true;\n-\t\t}\n+    return true;\n+    }\n \t\telse\n \t\t{\n-\t\t\tfinal String stepLN = xpath.getStepLocalName(idxStep);\n+    final String stepLN = xpath.getStepLocalName(idxStep);\n \t\t\tfinal String stepNS = xpath.getStepNamespace(idxStep);\n \n \t\t\tif (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(elementName.getNamespaceURI())))\n \t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n+    return true;\n+    }\n \t\t\telse\n \t\t\t{\n-\t\t\t\treturn elementName.getLocalPart().equals(stepLN) && elementName.getNamespaceURI().equals(stepNS);\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n+    return elementName.getLocalPart().equals(stepLN) && elementName.getNamespaceURI().equals(stepNS);\n+    }\n+    }\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 62
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/213/IdentitySelector.java\nindex 27db22c9cdf..e9be10f3c16 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/213/IdentitySelector.java\n@@ -19,9 +19,7 @@ import java.lang.reflect.Array;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedList;\n-\n import javax.xml.namespace.QName;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.xs.constraints.RestrictedXPath;\n import org.genxdm.xs.exceptions.AbortException;\n@@ -30,185 +28,182 @@ import org.genxdm.xs.exceptions.AbortException;\n  * Provides a streaming evaluation of a restricted XPath expression. <br/>\n  * When certain conditions are met, a match handler is called\n  */\n+\n final class IdentitySelector\n {\n-\tpublic static final boolean DEBUG = false;\n-\n-\t// We will callback the scope to indicate that the selector has matched.\n-\t// We issue one event for the start and one event for the end in a pair.\n-\tprivate final IdentityScope m_scope;\n-\n-\t// a List of branches, representing a parsed identity (selector or field)\n-\t// XPath expression\n-\tprivate final RestrictedXPath m_xpath[];\n-\n-\t/**\n-\t * The possibility of having \"//\" in the XPath expression means that a single XPath expression may have many\n-\t * simultaneous evaluations. We keep track of these with a list of status objects. The outer index is again for\n-\t * alternate XPath expressions.\n-\t */\n-\tprivate final ArrayList<LinkedList<IdentitySelectorEvaluation>> m_evals;\n-\n-\t// true if that branch started with \".//\"\n-\tprivate final boolean[] m_relocatable;\n-\n-\tprivate int m_depth = -1;\n-\n-\t/**\n-\t * @param xpath\n-\t *            representing the parsed attribute xpath\n-\t */\n-\tpublic IdentitySelector(final IdentityScope scope, final RestrictedXPath xpath)\n-\t{\n-\t\tm_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n-\n-\t\t// Count the number of branches, that is, the number of XPath\n-\t\t// expressions separated by \"|\".\n-\t\tint size = 0;\n-\t\tfor (RestrictedXPath branch = xpath; branch != null; branch = branch.getAlternate())\n-\t\t{\n-\t\t\t// System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n-\t\t\t// branch);\n-\t\t\tsize++;\n-\t\t}\n-\n-\t\tm_relocatable = new boolean[size];\n-\t\tm_xpath = (RestrictedXPath[])Array.newInstance(RestrictedXPath.class, size);\n-\t\tm_evals = new ArrayList<LinkedList<IdentitySelectorEvaluation>>(size);\n-\t\tRestrictedXPath branch = xpath;\n-\t\tfor (int i = size - 1; i >= 0; i--)\n-\t\t{\n-\t\t\t// put them backwards\n-\t\t\tif (null == branch)\n-\t\t\t{\n-\t\t\t\tthrow new RuntimeException();\n-\t\t\t}\n-\t\t\tm_xpath[i] = branch;\n-\t\t\tm_relocatable[i] = branch.isRelocatable();\n-\t\t\tbranch = branch.getAlternate();\n-\t\t}\n-\t\tfor (int i = 0; i < size; i++)\n-\t\t{\n-\t\t\tfinal LinkedList<IdentitySelectorEvaluation> e = new LinkedList<IdentitySelectorEvaluation>();\n-\t\t\te.add(new IdentitySelectorEvaluation(m_xpath[i], false));\n-\t\t\tm_evals.add(e);\n-\t\t}\n-\t}\n-\n-\tpublic void startElement(final QName elementName, final int elementIndex)\n-\t{\n-\t\tm_depth++;\n-\n-\t\tfor (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without getting a concurrent modification exception\n-\t\t\t// (would happen through the list).\n-\t\t\tfinal Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n-\t\t\twhile (it.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentitySelectorEvaluation xps = it.next();\n-\n-\t\t\t\txps.advance();\n-\n-\t\t\t\tif (xps.inBounds())\n-\t\t\t\t{\n-\t\t\t\t\tif (xps.matchesElement(elementName))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.onLastStep())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_scope.startSelectorElement(elementName, elementIndex);\n-\t\t\t\t\t\t\txps.setSelecting(true);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// TODO: The following code pertains to relocation.\n-\t\t\tif (m_depth > 0 && m_relocatable[unionIdx])\n-\t\t\t{\n-\t\t\t\tif (matchesElement(m_xpath[unionIdx], 0, elementName))\n-\t\t\t\t{\n-\t\t\t\t\tfinal IdentitySelectorEvaluation xps = new IdentitySelectorEvaluation(m_xpath[unionIdx], true);\n-\t\t\t\t\tif (xps.onLastStep())\n-\t\t\t\t\t{\n-\t\t\t\t\t\tm_scope.startSelectorElement(elementName, elementIndex);\n-\t\t\t\t\t\txps.setSelecting(true);\n-\t\t\t\t\t}\n-\t\t\t\t\tm_evals.get(unionIdx).add(xps);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void endElement(final QName elementName, final int elementIndex, final Locatable location) throws AbortException\n-\t{\n-\t\tm_depth--;\n-\t\tfor (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without\n-\t\t\t// getting a concurrent modification exception (would happen through\n-\t\t\t// the list).\n-\t\t\tfinal Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n-\t\t\twhile (it.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentitySelectorEvaluation xps = it.next();\n-\t\t\t\tif (xps.inBounds())\n-\t\t\t\t{\n-\t\t\t\t\t// Use the flag to avoid checking for a match and last step.\n-\t\t\t\t\tif (xps.isSelecting())\n-\t\t\t\t\t{\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_scope.endSelectorElement(elementName, elementIndex, location);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tfinally\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\txps.setSelecting(false);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\txps.retreat();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate boolean matchesElement(final RestrictedXPath xpath, final int idxStep, final QName elementName)\n-\t{\n-\t\tif (xpath.isAttribute())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (xpath.isContextNode(idxStep))\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal String stepLN = xpath.getStepLocalName(idxStep);\n-\t\t\tfinal String stepNS = xpath.getStepNamespace(idxStep);\n-\n-\t\t\tif (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(elementName.getNamespaceURI())))\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn elementName.getLocalPart().equals(stepLN) && elementName.getNamespaceURI().equals(stepNS);\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n+    public static final boolean DEBUG = false;\n+\n+    // We will callback the scope to indicate that the selector has matched.\n+    // We issue one event for the start and one event for the end in a pair.\n+    private final IdentityScope m_scope;\n+\n+    // a List of branches, representing a parsed identity (selector or field)\n+    // XPath expression\n+    private final RestrictedXPath m_xpath[];\n+\n+    /**\n+     * The possibility of having \"//\" in the XPath expression means that a single XPath expression may have many\n+     * simultaneous evaluations. We keep track of these with a list of status objects. The outer index is again for\n+     * alternate XPath expressions.\n+     */\n+    private final ArrayList<LinkedList<IdentitySelectorEvaluation>> m_evals;\n+\n+    // true if that branch started with \".//\"\n+    private final boolean[] m_relocatable;\n+    private int m_depth = -1;\n+\n+    /**\n+     * @param xpath\n+     *            representing the parsed attribute xpath\n+     */\n+\n+    public IdentitySelector(final IdentityScope scope, final RestrictedXPath xpath)\n+    {\n+        m_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n+\n+        // Count the number of branches, that is, the number of XPath\n+        // expressions separated by \"|\".\n+\n+        int size = 0;\n+        for (RestrictedXPath branch = xpath; branch != null; branch = branch.getAlternate())\n+        {\n+            // System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n+            // branch);\n+            size++;\n+        }\n+        m_relocatable = new boolean[size];\n+        m_xpath = (RestrictedXPath[])Array.newInstance(RestrictedXPath.class, size);\n+        m_evals = new ArrayList<LinkedList<IdentitySelectorEvaluation>>(size);\n+        RestrictedXPath branch = xpath;\n+        for (int i = size - 1; i >= 0; i--)\n+        {\n+            // put them backwards\n+            if (null == branch)\n+            {\n+                throw new RuntimeException();\n+            }\n+            m_xpath[i] = branch;\n+            m_relocatable[i] = branch.isRelocatable();\n+            branch = branch.getAlternate();\n+        }\n+        for (int i = 0; i < size; i++)\n+        {\n+            final LinkedList<IdentitySelectorEvaluation> e = new LinkedList<IdentitySelectorEvaluation>();\n+            e.add(new IdentitySelectorEvaluation(m_xpath[i], false));\n+            m_evals.add(e);\n+        }\n+    }\n+\n+    public void startElement(final QName elementName, final int elementIndex)\n+    {\n+        m_depth++;\n+        for (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--)\n+        {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without getting a concurrent modification exception\n+            // (would happen through the list).\n+            final Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n+            while (it.hasNext())\n+            {\n+                final IdentitySelectorEvaluation xps = it.next();\n+                xps.advance();\n+                if (xps.inBounds())\n+                {\n+                    if (xps.matchesElement(elementName))\n+                    {\n+                        if (xps.onLastStep())\n+                        {\n+                            m_scope.startSelectorElement(elementName, elementIndex);\n+                            xps.setSelecting(true);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        if (xps.removable)\n+                        {\n+                            it.remove();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // TODO: The following code pertains to relocation.\n+            if (m_depth > 0 && m_relocatable[unionIdx])\n+            {\n+                if (matchesElement(m_xpath[unionIdx], 0, elementName))\n+                {\n+                    final IdentitySelectorEvaluation xps = new IdentitySelectorEvaluation(m_xpath[unionIdx], true);\n+                    if (xps.onLastStep())\n+                    {\n+                        m_scope.startSelectorElement(elementName, elementIndex);\n+                        xps.setSelecting(true);\n+                    }\n+                    m_evals.get(unionIdx).add(xps);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void endElement(final QName elementName, final int elementIndex, final Locatable location)\n+        throws AbortException\n+    {\n+        m_depth--;\n+        for (int unionIdx = m_xpath.length - 1; unionIdx >= 0; unionIdx--)\n+        {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without\n+            // getting a concurrent modification exception (would happen through\n+            // the list).\n+            final Iterator<IdentitySelectorEvaluation> it = m_evals.get(unionIdx).iterator();\n+            while (it.hasNext())\n+            {\n+                final IdentitySelectorEvaluation xps = it.next();\n+                if (xps.inBounds())\n+                {\n+                    // Use the flag to avoid checking for a match and last step.\n+                    if (xps.isSelecting())\n+                    {\n+                        try\n+                        {\n+                            m_scope.endSelectorElement(elementName, elementIndex, location);\n+                        }\n+                        finally\n+                        {\n+                            xps.setSelecting(false);\n+                        }\n+                    }\n+                    if (xps.removable)\n+                    {\n+                        it.remove();\n+                    }\n+                }\n+                xps.retreat();\n+            }\n+        }\n+    }\n+\n+    private boolean matchesElement(final RestrictedXPath xpath, final int idxStep, final QName elementName)\n+    {\n+        if (xpath.isAttribute())\n+        {\n+            return false;\n+        }\n+        if (xpath.isContextNode(idxStep))\n+        {\n+            return true;\n+        }\n+        else\n+        {\n+            final String stepLN = xpath.getStepLocalName(idxStep);\n+            final String stepNS = xpath.getStepNamespace(idxStep);\n+            if (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(elementName.getNamespaceURI())))\n+            {\n+                return true;\n+            }\n+            else\n+            {\n+                return elementName.getLocalPart().equals(stepLN) && elementName.getNamespaceURI().equals(stepNS);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 183
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "37",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/213/IdentitySelector.java\nindex 27db22c9cdf..395a4df861c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/213/IdentitySelector.java\n@@ -32,7 +32,7 @@ import org.genxdm.xs.exceptions.AbortException;\n  */\n final class IdentitySelector\n {\n-\tpublic static final boolean DEBUG = false;\n+public static final boolean DEBUG = false;\n \n \t// We will callback the scope to indicate that the selector has matched.\n \t// We issue one event for the start and one event for the end in a pair.\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "37",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/213/IdentitySelector.java\nindex 27db22c9cdf..1dd66a46141 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/213/IdentitySelector.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/213/IdentitySelector.java\n@@ -32,7 +32,7 @@ import org.genxdm.xs.exceptions.AbortException;\n  */\n final class IdentitySelector\n {\n-\tpublic static final boolean DEBUG = false;\n+    public static final boolean DEBUG = false;\n \n \t// We will callback the scope to indicate that the selector has matched.\n \t// We issue one event for the start and one event for the end in a pair.\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}