{
    "project_name": "IQSS-dataverse",
    "error_id": "38",
    "information": {
        "errors": [
            {
                "line": "62",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "        try {\n            return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class)\n\t\t\t\t\t.setParameter(\"nickName\", nickName.toLowerCase())\n\t\t\t\t\t.getSingleResult();\n        } catch ( NoResultException|NonUniqueResultException ex ) {\n            logger.fine(\"Unable to find a single harvesting client by nickname \\\"\" + nickName + \"\\\": \" + ex);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "63",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/38/HarvestingClientServiceBean.java\nindex 0af73550190..74ac1115173 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/38/HarvestingClientServiceBean.java\n@@ -59,7 +59,7 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n     public HarvestingClient findByNickname(String nickName) {\n         try {\n             return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class)\n-\t\t\t\t\t.setParameter(\"nickName\", nickName.toLowerCase())\n+    .setParameter(\"nickName\", nickName.toLowerCase())\n \t\t\t\t\t.getSingleResult();\n         } catch ( NoResultException|NonUniqueResultException ex ) {\n             logger.fine(\"Unable to find a single harvesting client by nickname \\\"\" + nickName + \"\\\": \" + ex);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/38/HarvestingClientServiceBean.java\nindex 0af73550190..b15b8de040b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/38/HarvestingClientServiceBean.java\n@@ -26,204 +26,205 @@ import javax.persistence.NonUniqueResultException;\n import javax.persistence.PersistenceContext;\n \n /**\n- *\n  * @author Leonid Andreev\n- * \n+ * <p>\n  * Dedicated service for managing Harvesting Client Configurations\n  */\n @Stateless\n @Named\n public class HarvestingClientServiceBean implements java.io.Serializable {\n-    @EJB\n-    DataverseServiceBean dataverseService;\n-    @EJB\n-    EjbDataverseEngine engineService;\n-    @EJB\n-    DataFileServiceBean dataFileService;\n-    @Inject\n-    DataverseRequestServiceBean dvRequestService;\n-    @EJB\n-    IndexServiceBean indexService;\n-    @EJB\n-    DataverseTimerServiceBean dataverseTimerService;\n-    \n-    @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n-    private EntityManager em;\n-    \n-    private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.harvest.client.HarvestingClinetServiceBean\");\n-    \n-    public HarvestingClient find(Object pk) {\n-        return em.find(HarvestingClient.class, pk);\n-    }\n-    \n-    public HarvestingClient findByNickname(String nickName) {\n-        try {\n-            return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class)\n-\t\t\t\t\t.setParameter(\"nickName\", nickName.toLowerCase())\n-\t\t\t\t\t.getSingleResult();\n-        } catch ( NoResultException|NonUniqueResultException ex ) {\n-            logger.fine(\"Unable to find a single harvesting client by nickname \\\"\" + nickName + \"\\\": \" + ex);\n-            return null;\n-        }\n-    }\n-    \n-    public List<HarvestingClient> getAllHarvestingClients() {\n-        try {\n-            return em.createQuery(\"SELECT object(c) FROM HarvestingClient AS c WHERE c.harvestType='oai' ORDER BY c.name\", HarvestingClient.class).getResultList();\n-        } catch (Exception ex) {\n-            logger.warning(\"Unknown exception caught while looking up configured Harvesting Clients: \"+ex.getMessage());\n-        }\n-        return null; \n-    }\n-    \n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    public void resetHarvestInProgress(Long hcId) {\n-        HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n-        if (harvestingClient == null) {\n-            return;\n-        }\n-        em.refresh(harvestingClient);\n-        harvestingClient.setHarvestingNow(false);\n-        \n-        // And if there is an unfinished RunResult object, we'll\n-        // just mark it as a failure:\n-        if (harvestingClient.getLastRun() != null \n-                && harvestingClient.getLastRun().isInProgress()) {\n-            harvestingClient.getLastRun().setFailed();\n-        }\n-       \n-    }\n-    \n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    public void setHarvestInProgress(Long hcId, Date startTime) {\n-        HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n-        if (harvestingClient == null) {\n-            return;\n-        }\n-        em.refresh(harvestingClient);\n-        harvestingClient.setHarvestingNow(true);\n-        if (harvestingClient.getRunHistory() == null) {\n-            harvestingClient.setRunHistory(new ArrayList<>());\n-        }\n-        ClientHarvestRun currentRun = new ClientHarvestRun();\n-        currentRun.setHarvestingClient(harvestingClient);\n-        currentRun.setStartTime(startTime);\n-        currentRun.setInProgress();\n-        harvestingClient.getRunHistory().add(currentRun);\n-    }\n-    \n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    public void setDeleteInProgress(Long hcId) {\n-        HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n-        if (harvestingClient == null) {\n-            return;\n-        }\n-        em.refresh(harvestingClient); // why are we doing this?\n-        harvestingClient.setDeleteInProgress(true);\n-    }\n-    \n-    // Deleting a client, with all the associated content, can take a while - \n-    // hence it's an async action: \n-    // TOFIGUREOUT:\n-    // for whatever reason I cannot call the DeleteHarvestingClientCommand from\n-    // inside this method; something to do with it being asynchronous?\n-    @Asynchronous\n-    public void deleteClient(Long clientId) {\n-        String errorMessage = null;\n-        HarvestingClient victim = find(clientId);\n-\n-        if (victim == null) {\n-            return;\n-        }\n-\n-        try {\n-            //engineService.submit(new DeleteHarvestingClientCommand(dvRequestService.getDataverseRequest(), victim));\n-            HarvestingClient merged = em.merge(victim);\n-\n-            // if this was a scheduled harvester, make sure the timer is deleted:\n-            dataverseTimerService.removeHarvestTimer(victim);\n-                \n-            // purge indexed objects:\n-            indexService.deleteHarvestedDocuments(victim);\n-            // All the datasets harvested by this client will be cleanly deleted \n-            // through the defined cascade. Cascaded delete does not work for harvested \n-            // files, however. So they need to be removed explicitly; before we \n-            // proceed removing the client itself. \n-            for (DataFile harvestedFile : dataFileService.findHarvestedFilesByClient(merged)) {\n-                DataFile mergedFile = em.merge(harvestedFile);\n-                em.remove(mergedFile);\n-                harvestedFile = null;\n-            }\n-\n-            em.remove(merged);\n-        } catch (Exception e) {\n-            errorMessage = \"Failed to delete cleint. Unknown exception: \" + e.getMessage();\n-        }\n-\n-        if (errorMessage != null) {\n-            logger.warning(errorMessage);\n-        }\n-    }\n-    \n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    public void setHarvestSuccess(Long hcId, Date currentTime, int harvestedCount, int failedCount, int deletedCount) {\n-        HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n-        if (harvestingClient == null) {\n-            return;\n-        }\n-        em.refresh(harvestingClient);\n-        \n-        ClientHarvestRun currentRun = harvestingClient.getLastRun();\n-        \n-        if (currentRun != null && currentRun.isInProgress()) {\n-            // TODO: what if there's no current run in progress? should we just\n-            // give up quietly, or should we make a noise of some kind? -- L.A. 4.4      \n-            \n-            currentRun.setSuccess();\n-            currentRun.setFinishTime(currentTime);\n-            currentRun.setHarvestedDatasetCount(new Long(harvestedCount));\n-            currentRun.setFailedDatasetCount(new Long(failedCount));\n-            currentRun.setDeletedDatasetCount(new Long(deletedCount));\n-        }\n-    }\n-\n-    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n-    public void setHarvestFailure(Long hcId, Date currentTime) {\n-        HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n-        if (harvestingClient == null) {\n-            return;\n-        }\n-        em.refresh(harvestingClient);\n-        \n-        ClientHarvestRun currentRun = harvestingClient.getLastRun();\n-        \n-        if (currentRun != null && currentRun.isInProgress()) {\n-            // TODO: what if there's no current run in progress? should we just\n-            // give up quietly, or should we make a noise of some kind? -- L.A. 4.4      \n-            \n-            currentRun.setFailed();\n-            currentRun.setFinishTime(currentTime);\n-        }\n-    }  \n-    \n-    public Long getNumberOfHarvestedDatasetByClients(List<HarvestingClient> clients) {\n-        String dvs = null; \n-        for (HarvestingClient client: clients) {\n-            if (dvs == null) {\n-                dvs = client.getDataverse().getId().toString();\n-            } else {\n-                dvs = dvs.concat(\",\"+client.getDataverse().getId().toString());\n-            }\n-        }\n-        \n-        try {\n-            return (Long) em.createNativeQuery(\"SELECT count(d.id) FROM dataset d, \"\n-                    + \" dvobject o WHERE d.id = o.id AND o.owner_id in (\" \n-                    + dvs + \")\").getSingleResult();\n-\n-        } catch (Exception ex) {\n-            logger.info(\"Warning: exception trying to count harvested datasets by clients: \" + ex.getMessage());\n-            return 0L;\n-        }\n+  @EJB\n+  DataverseServiceBean dataverseService;\n+  @EJB\n+  EjbDataverseEngine engineService;\n+  @EJB\n+  DataFileServiceBean dataFileService;\n+  @Inject\n+  DataverseRequestServiceBean dvRequestService;\n+  @EJB\n+  IndexServiceBean indexService;\n+  @EJB\n+  DataverseTimerServiceBean dataverseTimerService;\n+\n+  @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n+  private EntityManager em;\n+\n+  private static final Logger logger =\n+    Logger.getLogger(\"edu.harvard.iq.dataverse.harvest.client.HarvestingClinetServiceBean\");\n+\n+  public HarvestingClient find(Object pk) {\n+    return em.find(HarvestingClient.class, pk);\n+  }\n+\n+  public HarvestingClient findByNickname(String nickName) {\n+    try {\n+      return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class)\n+        .setParameter(\"nickName\", nickName.toLowerCase())\n+        .getSingleResult();\n+    } catch (NoResultException | NonUniqueResultException ex) {\n+      logger.fine(\"Unable to find a single harvesting client by nickname \\\"\" + nickName + \"\\\": \" + ex);\n+      return null;\n+    }\n+  }\n+\n+  public List<HarvestingClient> getAllHarvestingClients() {\n+    try {\n+      return em.createQuery(\"SELECT object(c) FROM HarvestingClient AS c WHERE c.harvestType='oai' ORDER BY c.name\",\n+        HarvestingClient.class).getResultList();\n+    } catch (Exception ex) {\n+      logger.warning(\"Unknown exception caught while looking up configured Harvesting Clients: \" + ex.getMessage());\n+    }\n+    return null;\n+  }\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  public void resetHarvestInProgress(Long hcId) {\n+    HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n+    if (harvestingClient == null) {\n+      return;\n+    }\n+    em.refresh(harvestingClient);\n+    harvestingClient.setHarvestingNow(false);\n+\n+    // And if there is an unfinished RunResult object, we'll\n+    // just mark it as a failure:\n+    if (harvestingClient.getLastRun() != null\n+      && harvestingClient.getLastRun().isInProgress()) {\n+      harvestingClient.getLastRun().setFailed();\n+    }\n+\n+  }\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  public void setHarvestInProgress(Long hcId, Date startTime) {\n+    HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n+    if (harvestingClient == null) {\n+      return;\n+    }\n+    em.refresh(harvestingClient);\n+    harvestingClient.setHarvestingNow(true);\n+    if (harvestingClient.getRunHistory() == null) {\n+      harvestingClient.setRunHistory(new ArrayList<>());\n+    }\n+    ClientHarvestRun currentRun = new ClientHarvestRun();\n+    currentRun.setHarvestingClient(harvestingClient);\n+    currentRun.setStartTime(startTime);\n+    currentRun.setInProgress();\n+    harvestingClient.getRunHistory().add(currentRun);\n+  }\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  public void setDeleteInProgress(Long hcId) {\n+    HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n+    if (harvestingClient == null) {\n+      return;\n+    }\n+    em.refresh(harvestingClient); // why are we doing this?\n+    harvestingClient.setDeleteInProgress(true);\n+  }\n+\n+  // Deleting a client, with all the associated content, can take a while -\n+  // hence it's an async action:\n+  // TOFIGUREOUT:\n+  // for whatever reason I cannot call the DeleteHarvestingClientCommand from\n+  // inside this method; something to do with it being asynchronous?\n+  @Asynchronous\n+  public void deleteClient(Long clientId) {\n+    String errorMessage = null;\n+    HarvestingClient victim = find(clientId);\n+\n+    if (victim == null) {\n+      return;\n+    }\n+\n+    try {\n+      //engineService.submit(new DeleteHarvestingClientCommand(dvRequestService.getDataverseRequest(), victim));\n+      HarvestingClient merged = em.merge(victim);\n+\n+      // if this was a scheduled harvester, make sure the timer is deleted:\n+      dataverseTimerService.removeHarvestTimer(victim);\n+\n+      // purge indexed objects:\n+      indexService.deleteHarvestedDocuments(victim);\n+      // All the datasets harvested by this client will be cleanly deleted\n+      // through the defined cascade. Cascaded delete does not work for harvested\n+      // files, however. So they need to be removed explicitly; before we\n+      // proceed removing the client itself.\n+      for (DataFile harvestedFile : dataFileService.findHarvestedFilesByClient(merged)) {\n+        DataFile mergedFile = em.merge(harvestedFile);\n+        em.remove(mergedFile);\n+        harvestedFile = null;\n+      }\n+\n+      em.remove(merged);\n+    } catch (Exception e) {\n+      errorMessage = \"Failed to delete cleint. Unknown exception: \" + e.getMessage();\n+    }\n+\n+    if (errorMessage != null) {\n+      logger.warning(errorMessage);\n+    }\n+  }\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  public void setHarvestSuccess(Long hcId, Date currentTime, int harvestedCount, int failedCount, int deletedCount) {\n+    HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n+    if (harvestingClient == null) {\n+      return;\n+    }\n+    em.refresh(harvestingClient);\n+\n+    ClientHarvestRun currentRun = harvestingClient.getLastRun();\n+\n+    if (currentRun != null && currentRun.isInProgress()) {\n+      // TODO: what if there's no current run in progress? should we just\n+      // give up quietly, or should we make a noise of some kind? -- L.A. 4.4\n+\n+      currentRun.setSuccess();\n+      currentRun.setFinishTime(currentTime);\n+      currentRun.setHarvestedDatasetCount(new Long(harvestedCount));\n+      currentRun.setFailedDatasetCount(new Long(failedCount));\n+      currentRun.setDeletedDatasetCount(new Long(deletedCount));\n+    }\n+  }\n+\n+  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n+  public void setHarvestFailure(Long hcId, Date currentTime) {\n+    HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n+    if (harvestingClient == null) {\n+      return;\n+    }\n+    em.refresh(harvestingClient);\n+\n+    ClientHarvestRun currentRun = harvestingClient.getLastRun();\n+\n+    if (currentRun != null && currentRun.isInProgress()) {\n+      // TODO: what if there's no current run in progress? should we just\n+      // give up quietly, or should we make a noise of some kind? -- L.A. 4.4\n+\n+      currentRun.setFailed();\n+      currentRun.setFinishTime(currentTime);\n+    }\n+  }\n+\n+  public Long getNumberOfHarvestedDatasetByClients(List<HarvestingClient> clients) {\n+    String dvs = null;\n+    for (HarvestingClient client : clients) {\n+      if (dvs == null) {\n+        dvs = client.getDataverse().getId().toString();\n+      } else {\n+        dvs = dvs.concat(\",\" + client.getDataverse().getId().toString());\n+      }\n+    }\n+\n+    try {\n+      return (Long) em.createNativeQuery(\"SELECT count(d.id) FROM dataset d, \"\n+        + \" dvobject o WHERE d.id = o.id AND o.owner_id in (\"\n+        + dvs + \")\").getSingleResult();\n+\n+    } catch (Exception ex) {\n+      logger.info(\"Warning: exception trying to count harvested datasets by clients: \" + ex.getMessage());\n+      return 0L;\n     }\n+  }\n }\n",
            "diff_size": 195
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "62",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/naturalize/38/HarvestingClientServiceBean.java\nindex 0af73550190..113486a757e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/naturalize/38/HarvestingClientServiceBean.java\n@@ -58,10 +58,9 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n     \n     public HarvestingClient findByNickname(String nickName) {\n         try {\n-            return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class)\n-\t\t\t\t\t.setParameter(\"nickName\", nickName.toLowerCase())\n+            return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class).setParameter(\"nickName\", nickName.toLowerCase())\n \t\t\t\t\t.getSingleResult();\n-        } catch ( NoResultException|NonUniqueResultException ex ) {\n+    } catch ( NoResultException|NonUniqueResultException ex ) {\n             logger.fine(\"Unable to find a single harvesting client by nickname \\\"\" + nickName + \"\\\": \" + ex);\n             return null;\n         }\n@@ -87,8 +86,7 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n         \n         // And if there is an unfinished RunResult object, we'll\n         // just mark it as a failure:\n-        if (harvestingClient.getLastRun() != null \n-                && harvestingClient.getLastRun().isInProgress()) {\n+        if (harvestingClient.getLastRun() != null && harvestingClient.getLastRun().isInProgress()) {\n             harvestingClient.getLastRun().setFailed();\n         }\n        \n@@ -204,10 +202,10 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n             currentRun.setFailed();\n             currentRun.setFinishTime(currentTime);\n         }\n-    }  \n-    \n-    public Long getNumberOfHarvestedDatasetByClients(List<HarvestingClient> clients) {\n-        String dvs = null; \n+    }\n+\n+public Long getNumberOfHarvestedDatasetByClients(List<HarvestingClient> clients) {\n+    String dvs = null; \n         for (HarvestingClient client: clients) {\n             if (dvs == null) {\n                 dvs = client.getDataverse().getId().toString();\n@@ -218,12 +216,10 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n         \n         try {\n             return (Long) em.createNativeQuery(\"SELECT count(d.id) FROM dataset d, \"\n-                    + \" dvobject o WHERE d.id = o.id AND o.owner_id in (\" \n-                    + dvs + \")\").getSingleResult();\n-\n-        } catch (Exception ex) {\n+                    + \" dvobject o WHERE d.id = o.id AND o.owner_id in (\" + dvs + \")\").getSingleResult();\n+    } catch (Exception ex) {\n             logger.info(\"Warning: exception trying to count harvested datasets by clients: \" + ex.getMessage());\n             return 0L;\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 14
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/38/HarvestingClientServiceBean.java\nindex 0af73550190..a58bf404359 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/38/HarvestingClientServiceBean.java\n@@ -31,51 +31,57 @@ import javax.persistence.PersistenceContext;\n  * \n  * Dedicated service for managing Harvesting Client Configurations\n  */\n+\n+\n @Stateless\n @Named\n public class HarvestingClientServiceBean implements java.io.Serializable {\n+\n     @EJB\n     DataverseServiceBean dataverseService;\n+\n     @EJB\n     EjbDataverseEngine engineService;\n+\n     @EJB\n     DataFileServiceBean dataFileService;\n+\n     @Inject\n     DataverseRequestServiceBean dvRequestService;\n+\n     @EJB\n     IndexServiceBean indexService;\n+\n     @EJB\n     DataverseTimerServiceBean dataverseTimerService;\n-    \n+\n     @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n     private EntityManager em;\n-    \n     private static final Logger logger = Logger.getLogger(\"edu.harvard.iq.dataverse.harvest.client.HarvestingClinetServiceBean\");\n-    \n+\n     public HarvestingClient find(Object pk) {\n         return em.find(HarvestingClient.class, pk);\n     }\n-    \n+\n     public HarvestingClient findByNickname(String nickName) {\n         try {\n-            return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class)\n-\t\t\t\t\t.setParameter(\"nickName\", nickName.toLowerCase())\n-\t\t\t\t\t.getSingleResult();\n-        } catch ( NoResultException|NonUniqueResultException ex ) {\n+            return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class).setParameter(\"nickName\", nickName.toLowerCase()).getSingleResult();\n+        } catch (NoResultException | NonUniqueResultException ex) {\n             logger.fine(\"Unable to find a single harvesting client by nickname \\\"\" + nickName + \"\\\": \" + ex);\n             return null;\n         }\n     }\n-    \n+\n     public List<HarvestingClient> getAllHarvestingClients() {\n         try {\n-            return em.createQuery(\"SELECT object(c) FROM HarvestingClient AS c WHERE c.harvestType='oai' ORDER BY c.name\", HarvestingClient.class).getResultList();\n+            return em.createQuery(\"SELECT object(c) FROM HarvestingClient AS c WHERE c.harvestType='oai' ORDER BY c.name\",\n+                                  HarvestingClient.class).getResultList();\n         } catch (Exception ex) {\n-            logger.warning(\"Unknown exception caught while looking up configured Harvesting Clients: \"+ex.getMessage());\n+            logger.warning(\"Unknown exception caught while looking up configured Harvesting Clients: \" + ex.getMessage());\n         }\n-        return null; \n+        return null;\n     }\n-    \n+\n     @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n     public void resetHarvestInProgress(Long hcId) {\n         HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n@@ -87,13 +93,11 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n         \n         // And if there is an unfinished RunResult object, we'll\n         // just mark it as a failure:\n-        if (harvestingClient.getLastRun() != null \n-                && harvestingClient.getLastRun().isInProgress()) {\n+        if (harvestingClient.getLastRun() != null && harvestingClient.getLastRun().isInProgress()) {\n             harvestingClient.getLastRun().setFailed();\n         }\n-       \n     }\n-    \n+\n     @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n     public void setHarvestInProgress(Long hcId, Date startTime) {\n         HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n@@ -105,13 +109,14 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n         if (harvestingClient.getRunHistory() == null) {\n             harvestingClient.setRunHistory(new ArrayList<>());\n         }\n+\n         ClientHarvestRun currentRun = new ClientHarvestRun();\n         currentRun.setHarvestingClient(harvestingClient);\n         currentRun.setStartTime(startTime);\n         currentRun.setInProgress();\n         harvestingClient.getRunHistory().add(currentRun);\n     }\n-    \n+\n     @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n     public void setDeleteInProgress(Long hcId) {\n         HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n@@ -127,15 +132,14 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n     // TOFIGUREOUT:\n     // for whatever reason I cannot call the DeleteHarvestingClientCommand from\n     // inside this method; something to do with it being asynchronous?\n+\n     @Asynchronous\n     public void deleteClient(Long clientId) {\n         String errorMessage = null;\n         HarvestingClient victim = find(clientId);\n-\n         if (victim == null) {\n             return;\n         }\n-\n         try {\n             //engineService.submit(new DeleteHarvestingClientCommand(dvRequestService.getDataverseRequest(), victim));\n             HarvestingClient merged = em.merge(victim);\n@@ -149,12 +153,12 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n             // through the defined cascade. Cascaded delete does not work for harvested \n             // files, however. So they need to be removed explicitly; before we \n             // proceed removing the client itself. \n+\n             for (DataFile harvestedFile : dataFileService.findHarvestedFilesByClient(merged)) {\n                 DataFile mergedFile = em.merge(harvestedFile);\n                 em.remove(mergedFile);\n                 harvestedFile = null;\n             }\n-\n             em.remove(merged);\n         } catch (Exception e) {\n             errorMessage = \"Failed to delete cleint. Unknown exception: \" + e.getMessage();\n@@ -164,7 +168,7 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n             logger.warning(errorMessage);\n         }\n     }\n-    \n+\n     @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n     public void setHarvestSuccess(Long hcId, Date currentTime, int harvestedCount, int failedCount, int deletedCount) {\n         HarvestingClient harvestingClient = em.find(HarvestingClient.class, hcId);\n@@ -172,13 +176,10 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n             return;\n         }\n         em.refresh(harvestingClient);\n-        \n         ClientHarvestRun currentRun = harvestingClient.getLastRun();\n-        \n         if (currentRun != null && currentRun.isInProgress()) {\n             // TODO: what if there's no current run in progress? should we just\n             // give up quietly, or should we make a noise of some kind? -- L.A. 4.4      \n-            \n             currentRun.setSuccess();\n             currentRun.setFinishTime(currentTime);\n             currentRun.setHarvestedDatasetCount(new Long(harvestedCount));\n@@ -194,36 +195,29 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n             return;\n         }\n         em.refresh(harvestingClient);\n-        \n         ClientHarvestRun currentRun = harvestingClient.getLastRun();\n-        \n         if (currentRun != null && currentRun.isInProgress()) {\n             // TODO: what if there's no current run in progress? should we just\n             // give up quietly, or should we make a noise of some kind? -- L.A. 4.4      \n-            \n             currentRun.setFailed();\n             currentRun.setFinishTime(currentTime);\n         }\n-    }  \n-    \n+    }\n+\n     public Long getNumberOfHarvestedDatasetByClients(List<HarvestingClient> clients) {\n-        String dvs = null; \n-        for (HarvestingClient client: clients) {\n+        String dvs = null;\n+        for (HarvestingClient client : clients) {\n             if (dvs == null) {\n                 dvs = client.getDataverse().getId().toString();\n             } else {\n-                dvs = dvs.concat(\",\"+client.getDataverse().getId().toString());\n+                dvs = dvs.concat(\",\" + client.getDataverse().getId().toString());\n             }\n         }\n-        \n         try {\n-            return (Long) em.createNativeQuery(\"SELECT count(d.id) FROM dataset d, \"\n-                    + \" dvobject o WHERE d.id = o.id AND o.owner_id in (\" \n-                    + dvs + \")\").getSingleResult();\n-\n+            return (Long) em.createNativeQuery(\"SELECT count(d.id) FROM dataset d, \" + \" dvobject o WHERE d.id = o.id AND o.owner_id in (\" + dvs + \")\").getSingleResult();\n         } catch (Exception ex) {\n             logger.info(\"Warning: exception trying to count harvested datasets by clients: \" + ex.getMessage());\n             return 0L;\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 51
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "63",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/38/HarvestingClientServiceBean.java\nindex 0af73550190..74ac1115173 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/38/HarvestingClientServiceBean.java\n@@ -59,7 +59,7 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n     public HarvestingClient findByNickname(String nickName) {\n         try {\n             return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class)\n-\t\t\t\t\t.setParameter(\"nickName\", nickName.toLowerCase())\n+    .setParameter(\"nickName\", nickName.toLowerCase())\n \t\t\t\t\t.getSingleResult();\n         } catch ( NoResultException|NonUniqueResultException ex ) {\n             logger.fine(\"Unable to find a single harvesting client by nickname \\\"\" + nickName + \"\\\": \" + ex);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "63",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/38/HarvestingClientServiceBean.java\nindex 0af73550190..6d750ad1794 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/38/HarvestingClientServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/38/HarvestingClientServiceBean.java\n@@ -59,7 +59,7 @@ public class HarvestingClientServiceBean implements java.io.Serializable {\n     public HarvestingClient findByNickname(String nickName) {\n         try {\n             return em.createNamedQuery(\"HarvestingClient.findByNickname\", HarvestingClient.class)\n-\t\t\t\t\t.setParameter(\"nickName\", nickName.toLowerCase())\n+            .setParameter(\"nickName\", nickName.toLowerCase())\n \t\t\t\t\t.getSingleResult();\n         } catch ( NoResultException|NonUniqueResultException ex ) {\n             logger.fine(\"Unable to find a single harvesting client by nickname \\\"\" + nickName + \"\\\": \" + ex);\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}