{
    "project_name": "IQSS-dataverse",
    "error_id": "2",
    "information": {
        "errors": [
            {
                "line": "1736",
                "column": "21",
                "severity": "error",
                "message": "'{' at column 21 should have line break after.",
                "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
            }
        ]
    },
    "source_code": "        } finally {\n            if (labelsFileReader != null) {\n                try {labelsFileReader.close();}catch(Exception x){};\n            }\n        }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/2/PORFileReader.java\nindex c90b0ea6950..7f6f9cff717 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/2/PORFileReader.java\n@@ -1733,7 +1733,8 @@ public class PORFileReader  extends TabularDataFileReader{\n             return null;\n         } finally {\n             if (labelsFileReader != null) {\n-                try {labelsFileReader.close();}catch(Exception x){};\n+                try {\n+                  labelsFileReader.close();}catch(Exception x){};\n             }\n         }\n \n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/2/PORFileReader.java\nindex c90b0ea6950..c0ba9b1c680 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/2/PORFileReader.java\n@@ -17,6 +17,7 @@\n    Developed at the Institute for Quantitative Social Science, Harvard University.\n    Version 3.0.\n */\n+\n package edu.harvard.iq.dataverse.ingest.tabulardata.impl.plugins.por;\n \n import java.io.BufferedInputStream;\n@@ -72,291 +73,293 @@ import edu.harvard.iq.dataverse.ingest.tabulardata.impl.plugins.sav.SPSSConstant\n \n /**\n  * ingest plugin for SPSS/POR (\"portable\") file format.\n- *\n+ * <p>\n  * This reader plugin has been fully re-implemented for the DVN 4.0;\n- * It is still borrows heavily from, and builds on the basis of the \n- * old implementation by Akio Sone, that was in use in the versions \n+ * It is still borrows heavily from, and builds on the basis of the\n+ * old implementation by Akio Sone, that was in use in the versions\n  * 2-3 of the DVN.\n- * \n+ *\n  * @author Akio Sone at UNC-Odum\n  * @author Leonid Andreev\n  */\n \n-public class PORFileReader  extends TabularDataFileReader{\n-    // static fields ---------------------------------------------------------//\n-    private static final String MissingValueForTextDataFile = \"\";\n-\n-    private TabularDataIngest ingesteddata = new TabularDataIngest();\n-    private DataTable dataTable = new DataTable(); \n-    \n-    private static final int POR_HEADER_SIZE = 500;   \n-    private static final int POR_MARK_POSITION_DEFAULT = 461;\n-    private static final String POR_MARK = \"SPSSPORT\";\n-    private static final int LENGTH_SECTION_HEADER = 1;\n-    private static final int LENGTH_SECTION_2 = 19;        \n-    private static final String MIME_TYPE = \"application/x-spss-por\";\n-    private static Pattern pattern4positiveInteger = Pattern.compile(\"[0-9A-T]+\");\n-    private static Pattern pattern4Integer = Pattern.compile(\"[-]?[0-9A-T]+\");\n-    private static Calendar GCO = new GregorianCalendar();\n-    static {\n-        // set the origin of GCO to 1582-10-15\n-        GCO.set(1, 1582);// year\n-        GCO.set(2, 9); // month\n-        GCO.set(5, 15);// day of month\n-        GCO.set(9, 0);// AM(0) or PM(1)\n-        GCO.set(10, 0);// hh\n-        GCO.set(12, 0);// mm\n-        GCO.set(13, 0);// ss\n-        GCO.set(14, 0); // SS millisecond\n-        GCO.set(15, 0);// z\n-        \n+public class PORFileReader extends TabularDataFileReader {\n+  // static fields ---------------------------------------------------------//\n+  private static final String MissingValueForTextDataFile = \"\";\n+\n+  private TabularDataIngest ingesteddata = new TabularDataIngest();\n+  private DataTable dataTable = new DataTable();\n+\n+  private static final int POR_HEADER_SIZE = 500;\n+  private static final int POR_MARK_POSITION_DEFAULT = 461;\n+  private static final String POR_MARK = \"SPSSPORT\";\n+  private static final int LENGTH_SECTION_HEADER = 1;\n+  private static final int LENGTH_SECTION_2 = 19;\n+  private static final String MIME_TYPE = \"application/x-spss-por\";\n+  private static Pattern pattern4positiveInteger = Pattern.compile(\"[0-9A-T]+\");\n+  private static Pattern pattern4Integer = Pattern.compile(\"[-]?[0-9A-T]+\");\n+  private static Calendar GCO = new GregorianCalendar();\n+\n+  static {\n+    // set the origin of GCO to 1582-10-15\n+    GCO.set(1, 1582);// year\n+    GCO.set(2, 9); // month\n+    GCO.set(5, 15);// day of month\n+    GCO.set(9, 0);// AM(0) or PM(1)\n+    GCO.set(10, 0);// hh\n+    GCO.set(12, 0);// mm\n+    GCO.set(13, 0);// ss\n+    GCO.set(14, 0); // SS millisecond\n+    GCO.set(15, 0);// z\n+\n+  }\n+\n+  private static final long SPSS_DATE_BIAS = 60 * 60 * 24 * 1000;\n+  private static final long SPSS_DATE_OFFSET = SPSS_DATE_BIAS + Math.abs(GCO.getTimeInMillis());\n+\n+\n+  // instance fields -------------------------------------------------------//\n+\n+  private static Logger dbgLog = Logger.getLogger(PORFileReader.class.getPackage().getName());\n+\n+  private boolean isCurrentVariableString = false;\n+  private String currentVariableName = null;\n+\n+  private int caseQnty = 0;\n+  private int varQnty = 0;\n+\n+  private Map<String, Integer> variableTypeTable = new LinkedHashMap<>();\n+  private List<Integer> variableTypelList = new ArrayList<>();\n+  private List<Integer> printFormatList = new ArrayList<>();\n+  private Map<String, String> printFormatTable = new LinkedHashMap<>();\n+  private Map<String, String> printFormatNameTable = new LinkedHashMap<>();\n+  private Map<String, String> formatCategoryTable = new LinkedHashMap<>();\n+  private Map<String, Map<String, String>> valueLabelTable = new LinkedHashMap<>();\n+  private Map<String, String> valueVariableMappingTable = new LinkedHashMap<>();\n+  private List<String> variableNameList = new ArrayList<>();\n+  private Map<String, String> variableLabelMap = new LinkedHashMap<>();\n+  // missing value table: string/numeric data are stored  => String\n+  // the number of missing values are unknown beforehand => List\n+  private Map<String, List<String>> missingValueTable = new LinkedHashMap<>();\n+  // variableName=> missingValue type[field code]\n+  private Map<String, List<String>> missingValueCodeTable = new LinkedHashMap<>();\n+  private Map<String, InvalidData> invalidDataTable = new LinkedHashMap<>();\n+  private Set<Integer> decimalVariableSet = new HashSet<>();\n+  private List<Integer> formatDecimalPointPositionList = new ArrayList<>();\n+\n+\n+  // date/time data format\n+  private SimpleDateFormat sdf_ymd = new SimpleDateFormat(\"yyyy-MM-dd\");\n+  private SimpleDateFormat sdf_ymdhms = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n+  private SimpleDateFormat sdf_dhms = new SimpleDateFormat(\"DDD HH:mm:ss\");\n+  private SimpleDateFormat sdf_hms = new SimpleDateFormat(\"HH:mm:ss\");\n+\n+  // DecimalFormat for doubles\n+  // may need more setXXXX() to handle scientific data\n+  private NumberFormat doubleNumberFormatter = new DecimalFormat();\n+\n+  private String[] variableFormatTypeList;\n+  private String[] dateFormatList;\n+\n+  private Map<String, String> extendedLabels;\n+\n+  // Constructor -----------------------------------------------------------//\n+\n+  public PORFileReader(TabularDataFileReaderSpi originator) {\n+    super(originator);\n+  }\n+\n+\n+  private void init() throws IOException {\n+\n+    sdf_ymd.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+    sdf_ymdhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+    sdf_dhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+    sdf_hms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+\n+    doubleNumberFormatter.setGroupingUsed(false);\n+    doubleNumberFormatter.setMaximumFractionDigits(340); // TODO: 340?? -- L.A. 4.0 beta\n+  }\n+\n+  @Override\n+  public TabularDataIngest read(BufferedInputStream stream, File additionalData) throws IOException {\n+    dbgLog.fine(\"PORFileReader: read() start\");\n+\n+    if (additionalData != null) {\n+      //throw new IOException (\"this plugin does not support external raw data files\");\n+      dbgLog.fine(\"Using extended variable labels from file \" + additionalData.getName());\n+\n+      extendedLabels = createLabelMap(additionalData);\n     }\n-    private static final long SPSS_DATE_BIAS = 60*60*24*1000;\n-    private static final long SPSS_DATE_OFFSET = SPSS_DATE_BIAS + Math.abs(GCO.getTimeInMillis());\n-    \n \n-    // instance fields -------------------------------------------------------//\n \n-    private static Logger dbgLog = Logger.getLogger(PORFileReader.class.getPackage().getName());\n+    File tempPORfile = decodeHeader(stream);\n+    BufferedReader bfReader = null;\n \n-    private boolean isCurrentVariableString = false;\n-    private String currentVariableName = null;\n+    try {\n+      bfReader =\n+        new BufferedReader(new InputStreamReader(new FileInputStream(tempPORfile.getAbsolutePath()), \"US-ASCII\"));\n+      if (bfReader == null) {\n+        dbgLog.fine(\"bfReader is null\");\n+        throw new IOException(\"bufferedReader is null\");\n+      }\n \n-    private int caseQnty=0;\n-    private int varQnty=0;\n+      decodeSec2(bfReader);\n \n-    private Map<String, Integer> variableTypeTable = new LinkedHashMap<>();\n-    private List<Integer> variableTypelList = new ArrayList<>();\n-    private List<Integer> printFormatList = new ArrayList<>();\n-    private Map<String, String> printFormatTable = new LinkedHashMap<>();\n-    private Map<String, String> printFormatNameTable = new LinkedHashMap<>();\n-    private Map<String, String> formatCategoryTable = new LinkedHashMap<>();\n-    private Map<String, Map<String, String>> valueLabelTable = new LinkedHashMap<>();\n-    private Map<String, String> valueVariableMappingTable = new LinkedHashMap<>();\n-    private List<String> variableNameList = new ArrayList<>();\n-    private Map<String, String> variableLabelMap = new LinkedHashMap<>();\n-    // missing value table: string/numeric data are stored  => String\n-    // the number of missing values are unknown beforehand => List\n-    private Map<String, List<String>> missingValueTable = new LinkedHashMap<>();\n-    // variableName=> missingValue type[field code]\n-    private Map<String, List<String>> missingValueCodeTable = new LinkedHashMap<>();\n-    private Map<String, InvalidData> invalidDataTable = new LinkedHashMap<>();\n-    private Set<Integer> decimalVariableSet = new HashSet<>();\n-    private List<Integer> formatDecimalPointPositionList= new ArrayList<>();\n+      while (true) {\n \n+        char[] header = new char[LENGTH_SECTION_HEADER]; // 1 byte\n+        bfReader.read(header);\n+        String headerId = Character.toString(header[0]);\n \n+        dbgLog.fine(\"////////////////////// headerId=\" + headerId + \"//////////////////////\");\n \n-    // date/time data format\n-    private SimpleDateFormat sdf_ymd    = new SimpleDateFormat(\"yyyy-MM-dd\");\n-    private SimpleDateFormat sdf_ymdhms = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n-    private SimpleDateFormat sdf_dhms   = new SimpleDateFormat(\"DDD HH:mm:ss\");\n-    private SimpleDateFormat sdf_hms    = new SimpleDateFormat(\"HH:mm:ss\");\n+        if (headerId.equals(\"Z\")) {\n+          throw new IOException(\"reading failure: wrong headerId(Z) here\");\n+        }\n \n-    // DecimalFormat for doubles\n-    // may need more setXXXX() to handle scientific data\n-    private NumberFormat doubleNumberFormatter = new DecimalFormat();\n+        if (headerId.equals(\"F\")) {\n+          // missing value\n+          if ((missingValueTable != null) && (missingValueTable.size() > 0)) {\n+            processMissingValueData();\n+          }\n+        }\n \n-    private String[] variableFormatTypeList;\n-    private String[] dateFormatList;\n+        if (headerId.equals(\"8\") && isCurrentVariableString) {\n+          headerId = \"8S\";\n+        }\n \n-    private Map<String,String> extendedLabels;\n+        decode(headerId, bfReader);\n \n-    // Constructor -----------------------------------------------------------//\n \n-    public PORFileReader(TabularDataFileReaderSpi originator){\n-        super(originator);\n-    }\n+        // for last iteration\n+        if (headerId.equals(\"F\")) {\n+          // finished the last block (F == data)\n+          // without reaching the end of this file.\n+          break;\n+        }\n+      }\n \n-    \n-    private void init() throws IOException {\n-        \n-        sdf_ymd.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-        sdf_ymdhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-        sdf_dhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-        sdf_hms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-    \n-        doubleNumberFormatter.setGroupingUsed(false);\n-        doubleNumberFormatter.setMaximumFractionDigits(340); // TODO: 340?? -- L.A. 4.0 beta\n-    }\n-    \n-    @Override\n-    public TabularDataIngest read(BufferedInputStream stream, File additionalData) throws IOException{\n-        dbgLog.fine(\"PORFileReader: read() start\");\n-        \n-        if (additionalData != null) {\n-            //throw new IOException (\"this plugin does not support external raw data files\");\n-            dbgLog.fine(\"Using extended variable labels from file \"+additionalData.getName());\n-            \n-            extendedLabels = createLabelMap(additionalData);\n+\n+    } finally {\n+      try {\n+        if (bfReader != null) {\n+          bfReader.close();\n         }\n-        \n-        \n-        File tempPORfile = decodeHeader(stream);\n-        BufferedReader bfReader = null;\n-        \n-        try {            \n-            bfReader = new BufferedReader(new InputStreamReader(new FileInputStream(tempPORfile.getAbsolutePath()), \"US-ASCII\"));\n-            if (bfReader == null){\n-                dbgLog.fine(\"bfReader is null\");\n-                throw new IOException(\"bufferedReader is null\");\n-            }\n-            \n-            decodeSec2(bfReader);\n-            \n-            while(true){\n-\n-                char[] header = new char[LENGTH_SECTION_HEADER]; // 1 byte\n-                bfReader.read(header);\n-                String headerId = Character.toString(header[0]);\n-                \n-                dbgLog.fine(\"////////////////////// headerId=\"+headerId+ \"//////////////////////\");\n-                \n-                if (headerId.equals(\"Z\")){\n-                    throw new IOException(\"reading failure: wrong headerId(Z) here\");\n-                }\n-                \n-                if (headerId.equals(\"F\")) {\n-                    // missing value\n-                    if ((missingValueTable !=null) && (missingValueTable.size()>0)){\n-                        processMissingValueData();\n-                    }\n-                }\n-                                \n-                if (headerId.equals(\"8\") && isCurrentVariableString){\n-                    headerId = \"8S\";\n-                }\n+      } catch (IOException ex) {\n+        ex.printStackTrace();\n+      }\n \n-                decode(headerId, bfReader);\n+      if (tempPORfile.exists()) {\n+        tempPORfile.delete();\n+      }\n+    }\n \n-                \n-                // for last iteration\n-                if (headerId.equals(\"F\")){\n-                    // finished the last block (F == data) \n-                    // without reaching the end of this file.\n-                    break;\n-                }\n+    dbgLog.fine(\"done parsing headers and decoding;\");\n+\n+    List<DataVariable> variableList = new ArrayList<>();\n+\n+    for (int indx = 0; indx < variableTypelList.size(); indx++) {\n+\n+      DataVariable dv = new DataVariable(indx, dataTable);\n+      String varName = variableNameList.get(indx);\n+      dv.setName(varName);\n+      String varLabel = variableLabelMap.get(varName);\n+      if (varLabel != null && varLabel.length() > 255) {\n+        varLabel = varLabel.substring(0, 255);\n+      }\n+      // TODO: do we still need to enforce the 255 byte limit on\n+      // labels? is that enough to store whatever they have\n+      // in their POR files at ODUM?\n+      // -- L.A. 4.0, beta11\n+      if (extendedLabels != null && extendedLabels.get(varName) != null) {\n+        dv.setLabel(extendedLabels.get(varName));\n+      } else {\n+        dv.setLabel(varLabel);\n+      }\n+\n+      variableList.add(dv);\n+\n+      int simpleType = 0;\n+      if (variableTypelList.get(indx) != null) {\n+        simpleType = variableTypelList.get(indx);\n+      }\n+\n+      if (simpleType <= 0) {\n+        // We need to make one last type adjustment:\n+        // Dates and Times will be stored as character values in the\n+        // dataverse tab files; even though they are not typed as\n+        // strings at this point:\n+        // TODO:\n+        // Make sure the date/time format is properly preserved!\n+        // (see the setFormatCategory below... but double-check!)\n+        // -- L.A. 4.0 alpha\n+        String variableFormatType = variableFormatTypeList[indx];\n+\n+        if (variableFormatType != null) {\n+          if (variableFormatType.equals(\"time\")\n+            || variableFormatType.equals(\"date\")) {\n+            simpleType = 1;\n+\n+            String formatCategory = formatCategoryTable.get(varName);\n+\n+            if (formatCategory != null) {\n+              if (dateFormatList[indx] != null) {\n+                dbgLog.fine(\"setting format category to \" + formatCategory);\n+                variableList.get(indx).setFormatCategory(formatCategory);\n+                dbgLog.fine(\"setting formatschemaname to \" + dateFormatList[indx]);\n+                variableList.get(indx).setFormat(dateFormatList[indx]);\n+              }\n             }\n-            \n-                    \n-        } finally {\n-            try {\n-                if (bfReader!= null){\n-                    bfReader.close();\n-                }\n-            } catch (IOException ex){\n-                ex.printStackTrace();\n-            }\n-\n-            if (tempPORfile.exists()){\n-                tempPORfile.delete();\n+          } else if (variableFormatType.equals(\"other\")) {\n+            dbgLog.fine(\"Variable of format type \\\"other\\\"; type adjustment may be needed\");\n+            dbgLog.fine(\"SPSS print format: \" + printFormatTable.get(variableList.get(indx).getName()));\n+\n+            if (printFormatTable.get(variableList.get(indx).getName()).equals(\"WKDAY\")\n+              || printFormatTable.get(variableList.get(indx).getName()).equals(\"MONTH\")) {\n+              // week day or month;\n+              // These are not treated as time/date values (meaning, we\n+              // don't define time/date formats for them; there's likely\n+              // no valid ISO time/date format for just a month or a day\n+              // of week). However, the\n+              // values will be stored in the TAB files as strings,\n+              // and not as numerics - as they were stored in the\n+              // SAV file. So we need to adjust the type here.\n+              // -- L.A.\n+\n+              simpleType = 1;\n             }\n+          }\n         }\n-        \n-        dbgLog.fine(\"done parsing headers and decoding;\");\n \n-        List<DataVariable> variableList = new ArrayList<>();\n-        \n-        for (int indx = 0; indx < variableTypelList.size(); indx++) {\n-            \n-            DataVariable dv = new DataVariable(indx, dataTable);\n-            String varName = variableNameList.get(indx); \n-            dv.setName(varName);\n-            String varLabel = variableLabelMap.get(varName);\n-            if (varLabel != null && varLabel.length() > 255) {\n-                varLabel = varLabel.substring(0, 255);\n-            } \n-            // TODO: do we still need to enforce the 255 byte limit on \n-            // labels? is that enough to store whatever they have \n-            // in their POR files at ODUM?\n-            // -- L.A. 4.0, beta11\n-            if (extendedLabels != null && extendedLabels.get(varName) != null) {\n-                dv.setLabel(extendedLabels.get(varName));\n-            } else {\n-                dv.setLabel(varLabel);\n-            }\n-            \n-            variableList.add(dv);            \n-            \n-            int simpleType = 0;\n-            if (variableTypelList.get(indx) != null) {\n-                simpleType = variableTypelList.get(indx);\n-            }\n+      }\n \n-            if (simpleType <= 0) {\n-                // We need to make one last type adjustment:\n-                // Dates and Times will be stored as character values in the \n-                // dataverse tab files; even though they are not typed as \n-                // strings at this point:\n-                // TODO: \n-                // Make sure the date/time format is properly preserved!\n-                // (see the setFormatCategory below... but double-check!)\n-                // -- L.A. 4.0 alpha\n-                String variableFormatType = variableFormatTypeList[indx];\n-                \n-                if (variableFormatType != null) {\n-                    if (variableFormatType.equals(\"time\")\n-                        || variableFormatType.equals(\"date\")) {\n-                        simpleType = 1; \n-                    \n-                        String formatCategory = formatCategoryTable.get(varName);\n-\n-                        if (formatCategory != null) {\n-                            if (dateFormatList[indx] != null) {\n-                                dbgLog.fine(\"setting format category to \"+formatCategory);\n-                                variableList.get(indx).setFormatCategory(formatCategory);\n-                                dbgLog.fine(\"setting formatschemaname to \"+dateFormatList[indx]);\n-                                variableList.get(indx).setFormat(dateFormatList[indx]);\n-                            }\n-                        }\n-                    } else if (variableFormatType.equals(\"other\")) {\n-                        dbgLog.fine(\"Variable of format type \\\"other\\\"; type adjustment may be needed\");\n-                        dbgLog.fine(\"SPSS print format: \"+printFormatTable.get(variableList.get(indx).getName()));\n-                        \n-                        if (printFormatTable.get(variableList.get(indx).getName()).equals(\"WKDAY\")\n-                            || printFormatTable.get(variableList.get(indx).getName()).equals(\"MONTH\")) {\n-                            // week day or month; \n-                            // These are not treated as time/date values (meaning, we \n-                            // don't define time/date formats for them; there's likely \n-                            // no valid ISO time/date format for just a month or a day \n-                            // of week). However, the\n-                            // values will be stored in the TAB files as strings, \n-                            // and not as numerics - as they were stored in the \n-                            // SAV file. So we need to adjust the type here.\n-                            // -- L.A. \n-                            \n-                            simpleType = 1;\n-                        }\n-                    }\n-                }\n-                \n-            }\n-            \n-            dbgLog.fine(\"Finished creating variable \"+indx+\", \"+varName);\n-            \n-            // OK, we can now assign the types: \n-            \n-            if (simpleType > 0) {\n-                // String: \n-                variableList.get(indx).setTypeCharacter();\n-                variableList.get(indx).setIntervalDiscrete();\n-            } else {\n-                // Numeric: \n-                variableList.get(indx).setTypeNumeric();\n-                // discrete or continuous?\n-                // \"decimal variables\" become dataverse data variables of interval type \"continuous\":\n-        \n-                if (decimalVariableSet.contains(indx)) {\n-                    variableList.get(indx).setIntervalContinuous();\n-                } else {\n-                    variableList.get(indx).setIntervalDiscrete();\n-                }\n-                \n-            }\n-            dbgLog.fine(\"Finished configuring variable type information.\");\n+      dbgLog.fine(\"Finished creating variable \" + indx + \", \" + varName);\n+\n+      // OK, we can now assign the types:\n+\n+      if (simpleType > 0) {\n+        // String:\n+        variableList.get(indx).setTypeCharacter();\n+        variableList.get(indx).setIntervalDiscrete();\n+      } else {\n+        // Numeric:\n+        variableList.get(indx).setTypeNumeric();\n+        // discrete or continuous?\n+        // \"decimal variables\" become dataverse data variables of interval type \"continuous\":\n+\n+        if (decimalVariableSet.contains(indx)) {\n+          variableList.get(indx).setIntervalContinuous();\n+        } else {\n+          variableList.get(indx).setIntervalDiscrete();\n         }\n-        \n-        \n-        dbgLog.fine(\"done configuring variables;\");\n+\n+      }\n+      dbgLog.fine(\"Finished configuring variable type information.\");\n+    }\n+\n+\n+    dbgLog.fine(\"done configuring variables;\");\n         \n         /* \n          * From the original (3.6) code: \n@@ -369,1029 +372,1047 @@ public class PORFileReader  extends TabularDataFileReader{\n          * double-check that it's all being taken care of by the new plugin!\n          * (for variable format and formatName, consult the SAV plugin)\n          */\n-        \n-        dataTable.setDataVariables(variableList);\n-        \n-        // Assign value labels: \n-        \n-        assignValueLabels(valueLabelTable);\n-        \n-        ingesteddata.setDataTable(dataTable);\n-        \n-        dbgLog.info(\"PORFileReader: read() end\");\n-        return ingesteddata;\n-    }\n-    \n-    private void decode(String headerId, BufferedReader reader) throws IOException{\n-        if (headerId.equals(\"1\")) decodeProductName(reader);\n-        else if (headerId.equals(\"2\")) decodeLicensee(reader);\n-        else if (headerId.equals(\"3\")) decodeFileLabel(reader);\n-        else if (headerId.equals(\"4\")) decodeNumberOfVariables(reader);\n-        else if (headerId.equals(\"5\")) decodeFieldNo5(reader);\n-        else if (headerId.equals(\"6\")) decodeWeightVariable(reader);\n-        else if (headerId.equals(\"7\")) decodeVariableInformation(reader);\n-        else if (headerId.equals(\"8\")) decodeMissValuePointNumeric(reader);\n-        else if (headerId.equals(\"8S\")) decodeMissValuePointString(reader);\n-        else if (headerId.equals(\"9\")) decodeMissValueRangeLow(reader);\n-        else if (headerId.equals(\"A\")) decodeMissValueRangeHigh(reader);\n-        else if (headerId.equals(\"B\")) decodeMissValueRange(reader);\n-        else if (headerId.equals(\"C\")) decodeVariableLabel(reader);\n-        else if (headerId.equals(\"D\")) decodeValueLabel(reader);\n-        else if (headerId.equals(\"E\")) decodeDocument(reader);\n-        else if (headerId.equals(\"F\")) decodeData(reader);\n-    }\n-    \n-\n-    private File decodeHeader(BufferedInputStream stream) throws IOException {\n-        dbgLog.fine(\"decodeHeader(): start\");\n-        File tempPORfile = null;\n-\n-        if (stream  == null){\n-            throw new IllegalArgumentException(\"file == null!\");\n-        }\n-        \n-        byte[] headerByes = new byte[POR_HEADER_SIZE];\n \n-        if (stream.markSupported()){\n-            stream.mark(1000);\n-        }\n-        int nbytes = stream.read(headerByes, 0, POR_HEADER_SIZE);\n-\n-        //printHexDump(headerByes, \"hex dump of the byte-array\");\n-\n-        if (nbytes == 0){\n-            throw new IOException(\"decodeHeader: reading failure\");\n-        } else if ( nbytes < 491) {\n-           // Size test: by defnition, it must have at least\n-            // 491-byte header, i.e., the file size less than this threshold\n-            // is not a POR file\n-           dbgLog.fine(\"this file is NOT spss-por type\");\n-           throw new IllegalArgumentException(\"file is not spss-por type\");\n-        }\n-        // rewind the current reading position back to the beginning\n-        if (stream.markSupported()){\n-            stream.reset();\n-        }\n+    dataTable.setDataVariables(variableList);\n+\n+    // Assign value labels:\n+\n+    assignValueLabels(valueLabelTable);\n+\n+    ingesteddata.setDataTable(dataTable);\n+\n+    dbgLog.info(\"PORFileReader: read() end\");\n+    return ingesteddata;\n+  }\n+\n+  private void decode(String headerId, BufferedReader reader) throws IOException {\n+    if (headerId.equals(\"1\")) {\n+      decodeProductName(reader);\n+    } else if (headerId.equals(\"2\")) {\n+      decodeLicensee(reader);\n+    } else if (headerId.equals(\"3\")) {\n+      decodeFileLabel(reader);\n+    } else if (headerId.equals(\"4\")) {\n+      decodeNumberOfVariables(reader);\n+    } else if (headerId.equals(\"5\")) {\n+      decodeFieldNo5(reader);\n+    } else if (headerId.equals(\"6\")) {\n+      decodeWeightVariable(reader);\n+    } else if (headerId.equals(\"7\")) {\n+      decodeVariableInformation(reader);\n+    } else if (headerId.equals(\"8\")) {\n+      decodeMissValuePointNumeric(reader);\n+    } else if (headerId.equals(\"8S\")) {\n+      decodeMissValuePointString(reader);\n+    } else if (headerId.equals(\"9\")) {\n+      decodeMissValueRangeLow(reader);\n+    } else if (headerId.equals(\"A\")) {\n+      decodeMissValueRangeHigh(reader);\n+    } else if (headerId.equals(\"B\")) {\n+      decodeMissValueRange(reader);\n+    } else if (headerId.equals(\"C\")) {\n+      decodeVariableLabel(reader);\n+    } else if (headerId.equals(\"D\")) {\n+      decodeValueLabel(reader);\n+    } else if (headerId.equals(\"E\")) {\n+      decodeDocument(reader);\n+    } else if (headerId.equals(\"F\")) {\n+      decodeData(reader);\n+    }\n+  }\n \n-        // line-terminating characters are usually one or two by defnition\n-        // however, a POR file saved by a genuine SPSS for Windows\n-        // had a three-character line terminator, i.e., failed to remove the\n-        // original file's one-character terminator when it was opened, and\n-        // saved it with the default two-character terminator without\n-        // removing original terminators. So we have to expect such a rare\n-        // case\n-        //\n-        // terminator\n-        // windows [0D0A]=>   [1310] = [CR/LF]\n-        // unix    [0A]  =>   [10]\n-        // mac     [0D]  =>   [13]\n-        // 3char  [0D0D0A]=> [131310] spss for windows rel 15\n-        //\n-        // terminating characters should be found at the following\n-        //                             column positions[counting from 0]:\n-        // unix    case: [0A]   : [80], [161], [242], [323], [404], [485]\n-        // windows case: [0D0A] : [81], [163], [245], [327], [409], [491]\n-        //           : [0D0D0A] : [82], [165], [248], [331], [414], [495]\n-        \n-        // convert b into a ByteBuffer\n-        \n-        ByteBuffer buff = ByteBuffer.wrap(headerByes);\n-        byte[] nlch = new byte[36];\n-        int pos1;\n-        int pos2;\n-        int pos3;\n-        int ucase = 0;\n-        int wcase = 0;\n-        int mcase = 0;\n-        int three = 0;\n-        int nolines = 6;\n-        int nocols = 80;\n-        for (int i = 0; i < nolines; ++i) {\n-            int baseBias = nocols * (i + 1);\n-            // 1-char case\n-            pos1 = baseBias + i;\n-            buff.position(pos1);\n-            dbgLog.finer(\"\\tposition(1)=\" + buff.position());\n-            int j = 6 * i;\n-            nlch[j] = buff.get();\n-\n-            if (nlch[j] == 10) {\n-                ucase++;\n-            } else if (nlch[j] == 13) {\n-                mcase++;\n-            }\n \n-            // 2-char case\n-            pos2 = baseBias + 2 * i;\n-            buff.position(pos2);\n-            dbgLog.finer(\"\\tposition(2)=\" + buff.position());\n-            \n-            nlch[j + 1] = buff.get();\n-            nlch[j + 2] = buff.get();\n-\n-            // 3-char case\n-            pos3 = baseBias + 3 * i;\n-            buff.position(pos3);\n-            dbgLog.finer(\"\\tposition(3)=\" + buff.position());\n-            \n-            nlch[j + 3] = buff.get();\n-            nlch[j + 4] = buff.get();\n-            nlch[j + 5] = buff.get();\n-\n-            dbgLog.finer(i + \"-th iteration position =\" +\n-                    nlch[j] + \"\\t\" + nlch[j + 1] + \"\\t\" + nlch[j + 2]);\n-            dbgLog.finer(i + \"-th iteration position =\" +\n-                    nlch[j + 3] + \"\\t\" + nlch[j + 4] + \"\\t\" + nlch[j + 5]);\n-            \n-            if ((nlch[j + 3] == 13) &&\n-                (nlch[j + 4] == 13) &&\n-                (nlch[j + 5] == 10)) {\n-                three++;\n-            } else if ((nlch[j + 1] == 13) && (nlch[j + 2] == 10)) {\n-                wcase++;\n-            }\n+  private File decodeHeader(BufferedInputStream stream) throws IOException {\n+    dbgLog.fine(\"decodeHeader(): start\");\n+    File tempPORfile = null;\n \n-            buff.rewind();\n-        }\n-        \n-        boolean windowsNewLine = true;\n-        if (three == nolines) {\n-            windowsNewLine = false; // lineTerminator = \"0D0D0A\"\n-        } else if ((ucase == nolines) && (wcase < nolines)) {\n-            windowsNewLine = false; // lineTerminator = \"0A\"\n-        } else if ((ucase < nolines) && (wcase == nolines)) {\n-            windowsNewLine = true; //lineTerminator = \"0D0A\"\n-        } else if ((mcase == nolines) && (wcase < nolines)) {\n-            windowsNewLine = false; //lineTerminator = \"0D\"\n-        }\n+    if (stream == null) {\n+      throw new IllegalArgumentException(\"file == null!\");\n+    }\n \n+    byte[] headerByes = new byte[POR_HEADER_SIZE];\n+\n+    if (stream.markSupported()) {\n+      stream.mark(1000);\n+    }\n+    int nbytes = stream.read(headerByes, 0, POR_HEADER_SIZE);\n+\n+    //printHexDump(headerByes, \"hex dump of the byte-array\");\n+\n+    if (nbytes == 0) {\n+      throw new IOException(\"decodeHeader: reading failure\");\n+    } else if (nbytes < 491) {\n+      // Size test: by defnition, it must have at least\n+      // 491-byte header, i.e., the file size less than this threshold\n+      // is not a POR file\n+      dbgLog.fine(\"this file is NOT spss-por type\");\n+      throw new IllegalArgumentException(\"file is not spss-por type\");\n+    }\n+    // rewind the current reading position back to the beginning\n+    if (stream.markSupported()) {\n+      stream.reset();\n+    }\n+\n+    // line-terminating characters are usually one or two by defnition\n+    // however, a POR file saved by a genuine SPSS for Windows\n+    // had a three-character line terminator, i.e., failed to remove the\n+    // original file's one-character terminator when it was opened, and\n+    // saved it with the default two-character terminator without\n+    // removing original terminators. So we have to expect such a rare\n+    // case\n+    //\n+    // terminator\n+    // windows [0D0A]=>   [1310] = [CR/LF]\n+    // unix    [0A]  =>   [10]\n+    // mac     [0D]  =>   [13]\n+    // 3char  [0D0D0A]=> [131310] spss for windows rel 15\n+    //\n+    // terminating characters should be found at the following\n+    //                             column positions[counting from 0]:\n+    // unix    case: [0A]   : [80], [161], [242], [323], [404], [485]\n+    // windows case: [0D0A] : [81], [163], [245], [327], [409], [491]\n+    //           : [0D0D0A] : [82], [165], [248], [331], [414], [495]\n+\n+    // convert b into a ByteBuffer\n+\n+    ByteBuffer buff = ByteBuffer.wrap(headerByes);\n+    byte[] nlch = new byte[36];\n+    int pos1;\n+    int pos2;\n+    int pos3;\n+    int ucase = 0;\n+    int wcase = 0;\n+    int mcase = 0;\n+    int three = 0;\n+    int nolines = 6;\n+    int nocols = 80;\n+    for (int i = 0; i < nolines; ++i) {\n+      int baseBias = nocols * (i + 1);\n+      // 1-char case\n+      pos1 = baseBias + i;\n+      buff.position(pos1);\n+      dbgLog.finer(\"\\tposition(1)=\" + buff.position());\n+      int j = 6 * i;\n+      nlch[j] = buff.get();\n+\n+      if (nlch[j] == 10) {\n+        ucase++;\n+      } else if (nlch[j] == 13) {\n+        mcase++;\n+      }\n+\n+      // 2-char case\n+      pos2 = baseBias + 2 * i;\n+      buff.position(pos2);\n+      dbgLog.finer(\"\\tposition(2)=\" + buff.position());\n+\n+      nlch[j + 1] = buff.get();\n+      nlch[j + 2] = buff.get();\n+\n+      // 3-char case\n+      pos3 = baseBias + 3 * i;\n+      buff.position(pos3);\n+      dbgLog.finer(\"\\tposition(3)=\" + buff.position());\n+\n+      nlch[j + 3] = buff.get();\n+      nlch[j + 4] = buff.get();\n+      nlch[j + 5] = buff.get();\n+\n+      dbgLog.finer(i + \"-th iteration position =\" +\n+        nlch[j] + \"\\t\" + nlch[j + 1] + \"\\t\" + nlch[j + 2]);\n+      dbgLog.finer(i + \"-th iteration position =\" +\n+        nlch[j + 3] + \"\\t\" + nlch[j + 4] + \"\\t\" + nlch[j + 5]);\n+\n+      if ((nlch[j + 3] == 13) &&\n+        (nlch[j + 4] == 13) &&\n+        (nlch[j + 5] == 10)) {\n+        three++;\n+      } else if ((nlch[j + 1] == 13) && (nlch[j + 2] == 10)) {\n+        wcase++;\n+      }\n+\n+      buff.rewind();\n+    }\n+\n+    boolean windowsNewLine = true;\n+    if (three == nolines) {\n+      windowsNewLine = false; // lineTerminator = \"0D0D0A\"\n+    } else if ((ucase == nolines) && (wcase < nolines)) {\n+      windowsNewLine = false; // lineTerminator = \"0A\"\n+    } else if ((ucase < nolines) && (wcase == nolines)) {\n+      windowsNewLine = true; //lineTerminator = \"0D0A\"\n+    } else if ((mcase == nolines) && (wcase < nolines)) {\n+      windowsNewLine = false; //lineTerminator = \"0D\"\n+    }\n \n-        buff.rewind();\n-        int PORmarkPosition = POR_MARK_POSITION_DEFAULT;\n-        if (windowsNewLine) {\n-            PORmarkPosition = PORmarkPosition + 5;\n-        } else if (three == nolines) {\n-            PORmarkPosition = PORmarkPosition + 10;\n-        }\n \n-        byte[] pormark = new byte[8];\n-        buff.position(PORmarkPosition);\n-        buff.get(pormark, 0, 8);\n-        String pormarks = new String(pormark);\n+    buff.rewind();\n+    int PORmarkPosition = POR_MARK_POSITION_DEFAULT;\n+    if (windowsNewLine) {\n+      PORmarkPosition = PORmarkPosition + 5;\n+    } else if (three == nolines) {\n+      PORmarkPosition = PORmarkPosition + 10;\n+    }\n+\n+    byte[] pormark = new byte[8];\n+    buff.position(PORmarkPosition);\n+    buff.get(pormark, 0, 8);\n+    String pormarks = new String(pormark);\n+\n+    //dbgLog.fine(\"pormark =>\" + pormarks + \"<-\");\n+    dbgLog.fine(\"pormark[hex: 53 50 53 53 50 4F 52 54 == SPSSPORT] =>\" +\n+      new String(Hex.encodeHex(pormark)) + \"<-\");\n \n-        //dbgLog.fine(\"pormark =>\" + pormarks + \"<-\");\n-        dbgLog.fine(\"pormark[hex: 53 50 53 53 50 4F 52 54 == SPSSPORT] =>\" +\n-                new String(Hex.encodeHex(pormark)) + \"<-\");\n+    if (pormarks.equals(POR_MARK)) {\n+      dbgLog.fine(\"POR ID toke test: Passed\");\n+      init();\n+\n+      dataTable.setOriginalFileFormat(MIME_TYPE);\n+      dataTable.setUnf(\"UNF:6:NOTCALCULATED\");\n+\n+    } else {\n+      dbgLog.fine(\"this file is NOT spss-por type\");\n+      throw new IllegalArgumentException(\n+        \"decodeHeader: POR ID token was not found\");\n+    }\n \n-        if (pormarks.equals(POR_MARK)) {\n-            dbgLog.fine(\"POR ID toke test: Passed\");\n-            init();\n-                        \n-            dataTable.setOriginalFileFormat(MIME_TYPE);\n-            dataTable.setUnf(\"UNF:6:NOTCALCULATED\");\n+    // save the POR file without new line characters\n \n+    FileOutputStream fileOutPOR = null;\n+    Writer fileWriter = null;\n+\n+    // Scanner class can handle three-character line-terminator\n+    Scanner porScanner = null;\n+\n+    try {\n+      tempPORfile = File.createTempFile(\"tempPORfile.\", \".por\");\n+      fileOutPOR = new FileOutputStream(tempPORfile);\n+      fileWriter = new BufferedWriter(new OutputStreamWriter(fileOutPOR, \"utf8\"));\n+      porScanner = new Scanner(stream);\n+\n+      // Because 64-bit and 32-bit machines decode POR's first 40-byte\n+      // sequence differently, the first 5 leader lines are skipped from\n+      // the new-line-stripped file\n+\n+      int lineCounter = 0;\n+      while (porScanner.hasNextLine()) {\n+        lineCounter++;\n+        if (lineCounter <= 5) {\n+          String line = porScanner.nextLine();\n+          dbgLog.fine(\"line=\" + lineCounter + \":\" + line.length() + \":\" + line);\n         } else {\n-            dbgLog.fine(\"this file is NOT spss-por type\");\n-            throw new IllegalArgumentException(\n-                \"decodeHeader: POR ID token was not found\");\n+          fileWriter.write(porScanner.nextLine());\n+        }\n+      }\n+    } finally {\n+      try {\n+        if (fileWriter != null) {\n+          fileWriter.close();\n         }\n+      } catch (IOException ex) {\n+        ex.printStackTrace();\n+      }\n \n-        // save the POR file without new line characters\n+      if (porScanner != null) {\n+        porScanner.close();\n+      }\n+    }\n \n-        FileOutputStream fileOutPOR = null;\n-        Writer fileWriter = null;\n+    return tempPORfile;\n+  }\n \n-        // Scanner class can handle three-character line-terminator\n-        Scanner porScanner = null;\n-        \n-        try {\n-            tempPORfile = File.createTempFile(\"tempPORfile.\", \".por\");\n-            fileOutPOR = new FileOutputStream(tempPORfile);\n-            fileWriter = new BufferedWriter(new OutputStreamWriter(fileOutPOR, \"utf8\"));\n-            porScanner = new Scanner(stream);\n-\n-            // Because 64-bit and 32-bit machines decode POR's first 40-byte\n-            // sequence differently, the first 5 leader lines are skipped from\n-            // the new-line-stripped file\n-\n-            int lineCounter= 0;\n-            while(porScanner.hasNextLine()){\n-                lineCounter++;\n-                if (lineCounter<=5){\n-                    String line = porScanner.nextLine();\n-                    dbgLog.fine(\"line=\"+lineCounter+\":\"+line.length()+\":\"+line);\n-                } else {\n-                    fileWriter.write(porScanner.nextLine());\n-                }\n-            }\n-        } finally {\n-            try{\n-                if (fileWriter != null){\n-                    fileWriter.close();\n-                }\n-            } catch (IOException ex){\n-                ex.printStackTrace();\n-            }\n \n-            if (porScanner != null){\n-                porScanner.close();\n-            }\n-        }\n+  private void decodeSec2(BufferedReader reader) throws IOException {\n+    dbgLog.fine(\"decodeSec2(): start\");\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeSec2: stream == null!\");\n+    }\n+\n+    // Because a 64-bit machine may not save the first 40\n+    // bytes of a POR file in a way as a 32-bit machine does,\n+    // the first 5 lines of a POR file is excluded from the read-back\n+    // file and the new 1st line contains the format mark \"SPSSPORT\"\n+    // somewhere in it.\n \n-        return tempPORfile;\n+    // mark the start position for the later rewind\n+    if (reader.markSupported()) {\n+      reader.mark(100000);\n     }\n \n \n+    char[] sixthLineCharArray = new char[80];\n+    int nbytes_sixthLine = reader.read(sixthLineCharArray);\n \n-    private void decodeSec2(BufferedReader reader) throws IOException {\n-        dbgLog.fine(\"decodeSec2(): start\");\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeSec2: stream == null!\");\n-        }\n+    String sixthLine = new String(sixthLineCharArray);\n+    dbgLog.fine(\"sixthLineCharArray=\" +\n+      Arrays.deepToString(ArrayUtils.toObject(sixthLineCharArray)));\n+    int signatureLocation = sixthLine.indexOf(POR_MARK);\n \n-        // Because a 64-bit machine may not save the first 40\n-        // bytes of a POR file in a way as a 32-bit machine does,\n-        // the first 5 lines of a POR file is excluded from the read-back\n-        // file and the new 1st line contains the format mark \"SPSSPORT\"\n-        // somewhere in it.\n+    if (signatureLocation >= 0) {\n+      dbgLog.fine(\"format signature was found at:\" + signatureLocation);\n+    } else {\n+      dbgLog.severe(\"signature string was not found\");\n+      throw new IOException(\"signature string was not found\");\n+    }\n \n-        // mark the start position for the later rewind\n-        if (reader.markSupported()){\n-            reader.mark(100000);\n-        }\n+    // rewind the position to the beginning\n+    reader.reset();\n \n+    // skip bytes up to the signature string\n+    long skippedBytes = reader.skip(signatureLocation);\n \n-        char[] sixthLineCharArray = new char[80];\n-        int nbytes_sixthLine = reader.read(sixthLineCharArray);\n+    char[] sec2_leader = new char[POR_MARK.length()];\n+    int nbytes_sec2_leader = reader.read(sec2_leader);\n \n-        String sixthLine = new String(sixthLineCharArray);\n-        dbgLog.fine(\"sixthLineCharArray=\"+\n-            Arrays.deepToString(ArrayUtils.toObject(sixthLineCharArray)));\n-        int signatureLocation = sixthLine.indexOf(POR_MARK);\n+    String leader_string = new String(sec2_leader);\n \n-        if (signatureLocation >= 0){\n-            dbgLog.fine(\"format signature was found at:\"+signatureLocation);\n-        } else {\n-            dbgLog.severe(\"signature string was not found\");\n-            throw new IOException(\"signature string was not found\");\n-        }\n+    dbgLog.fine(\"format signature [SPSSPORT] detected=\" + leader_string);\n \n-        // rewind the position to the beginning\n-        reader.reset();\n \n-        // skip bytes up to the signature string\n-        long skippedBytes = reader.skip(signatureLocation);\n+    if (leader_string.equals(\"SPSSPORT\")) {\n+      dbgLog.fine(\"signature was correctly detected\");\n \n-        char[] sec2_leader = new char[POR_MARK.length()];\n-        int nbytes_sec2_leader = reader.read(sec2_leader);\n+    } else {\n+      dbgLog.severe(\n+        \"the format signature is not found at the previously located column\");\n+      throw new IOException(\"decodeSec2: failed to find the signature string\");\n+    }\n \n-        String leader_string = new String(sec2_leader);\n+    int length_section_2 = LENGTH_SECTION_2;\n \n-        dbgLog.fine(\"format signature [SPSSPORT] detected=\"+leader_string);\n+    char[] Sec2_bytes = new char[length_section_2];\n \n+    int nbytes_sec2 = reader.read(Sec2_bytes);\n \n-        if (leader_string.equals(\"SPSSPORT\")){\n-            dbgLog.fine(\"signature was correctly detected\");\n+    if (nbytes_sec2 == 0) {\n+      dbgLog.severe(\"decodeSec2: reading error\");\n+      throw new IOException(\"decodeSec2: reading error\");\n+    } else {\n+      dbgLog.fine(\"bytes read=\" + nbytes_sec2);\n+    }\n \n-        } else {\n-            dbgLog.severe(\n-            \"the format signature is not found at the previously located column\");\n-            throw new IOException(\"decodeSec2: failed to find the signature string\");\n-        }\n+    String sec2 = new String(Sec2_bytes);\n+    dbgLog.fine(\"sec2[creation date/time]=\" + sec2);\n \n-        int length_section_2 = LENGTH_SECTION_2;\n+    // sec2\n+    //       0123456789012345678\n+    //       A8/YYYYMMDD6/HHMMSS\n+    // thus\n+    // section2 should has 3 elements\n \n-        char[] Sec2_bytes = new char[length_section_2];\n+    String[] section2 = StringUtils.split(sec2, '/');\n \n-        int nbytes_sec2 = reader.read(Sec2_bytes);\n+    dbgLog.fine(\"section2=\" + StringUtils.join(section2, \"|\"));\n \n-        if (nbytes_sec2 == 0){\n-            dbgLog.severe(\"decodeSec2: reading error\");\n-            throw new IOException(\"decodeSec2: reading error\");\n-        } else {\n-            dbgLog.fine(\"bytes read=\"+nbytes_sec2);\n-        }\n+    String fileCreationDate = null;\n+    String fileCreationTime = null;\n+    if ((section2.length == 3) && (section2[0].startsWith(\"A\"))) {\n+      fileCreationDate = section2[1].substring(0, 7);\n+      fileCreationTime = section2[2];\n+    } else {\n+      dbgLog.severe(\"decodeSec2: file creation date/time were not correctly detected\");\n+      throw new IOException(\"decodeSec2: file creation date/time were not correctly detected\");\n+    }\n+    dbgLog.fine(\"fileCreationDate=\" + fileCreationDate);\n+    dbgLog.fine(\"fileCreationTime=\" + fileCreationTime);\n+    ///smd.getFileInformation().put(\"fileCreationDate\", fileCreationDate);\n+    ///smd.getFileInformation().put(\"fileCreationTime\", fileCreationTime);\n+    ///smd.getFileInformation().put(\"varFormat_schema\", \"SPSS\");\n+    dbgLog.fine(\"decodeSec2(): end\");\n+  }\n+\n+\n+  private void decodeProductName(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeProductName: reader == null!\");\n+    }\n+\n+    String productName = parseStringField(reader);\n+    ///smd.getFileInformation().put(\"productName\", productName);\n+  }\n \n-        String sec2 = new String(Sec2_bytes);\n-        dbgLog.fine(\"sec2[creation date/time]=\"+sec2);\n \n-        // sec2\n-        //       0123456789012345678\n-        //       A8/YYYYMMDD6/HHMMSS\n-        // thus\n-        // section2 should has 3 elements\n+  private void decodeLicensee(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeLicensee: reader == null!\");\n+    }\n \n-        String[] section2 = StringUtils.split(sec2, '/');\n+    String licenseeName = parseStringField(reader);\n+    ///smd.getFileInformation().put(\"licenseeName\", licenseeName);\n+  }\n \n-        dbgLog.fine(\"section2=\"+StringUtils.join(section2, \"|\"));\n \n-        String fileCreationDate =null;\n-        String fileCreationTime = null;\n-        if ((section2.length == 3)&& (section2[0].startsWith(\"A\"))){\n-            fileCreationDate = section2[1].substring(0,7);\n-            fileCreationTime = section2[2];\n-        } else {\n-            dbgLog.severe(\"decodeSec2: file creation date/time were not correctly detected\");\n-            throw new IOException(\"decodeSec2: file creation date/time were not correctly detected\");\n-        }\n-        dbgLog.fine(\"fileCreationDate=\"+fileCreationDate);\n-        dbgLog.fine(\"fileCreationTime=\"+fileCreationTime);\n-        ///smd.getFileInformation().put(\"fileCreationDate\", fileCreationDate);\n-        ///smd.getFileInformation().put(\"fileCreationTime\", fileCreationTime);\n-        ///smd.getFileInformation().put(\"varFormat_schema\", \"SPSS\");\n-        dbgLog.fine(\"decodeSec2(): end\");\n+  private void decodeFileLabel(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeFileLabel: reader == null!\");\n     }\n \n+    String fileLabel = parseStringField(reader);\n+    // TODO: is this \"file label\" potentially useful? -- L.A. 4.0 beta\n+    ///smd.getFileInformation().put(\"fileLabel\", fileLabel);\n+  }\n \n-    private void decodeProductName(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeProductName: reader == null!\");\n-        }\n \n-        String productName = parseStringField(reader);\n-        ///smd.getFileInformation().put(\"productName\", productName);\n+  private void decodeNumberOfVariables(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeNumberOfVariables: reader == null!\");\n     }\n \n+    String temp = null;\n+    char[] tmp = new char[1];\n+    StringBuilder sb = new StringBuilder();\n+\n+    while (reader.read(tmp) > 0) {\n+      temp = Character.toString(tmp[0]);\n+      if (temp.equals(\"/\")) {\n+        break;\n+      } else {\n+        sb.append(temp);\n+      }\n+    }\n \n-    private void decodeLicensee(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeLicensee: reader == null!\");\n-        }\n+    String rawNumberOfVariables = sb.toString();\n+    int rawLength = rawNumberOfVariables.length();\n \n-        String licenseeName = parseStringField(reader);\n-        ///smd.getFileInformation().put(\"licenseeName\", licenseeName);\n+    String numberOfVariables = StringUtils.stripStart((StringUtils.strip(rawNumberOfVariables)), \"0\");\n+\n+    if ((numberOfVariables.equals(\"\")) && (numberOfVariables.length() == rawLength)) {\n+      numberOfVariables = \"0\";\n     }\n \n+    varQnty = Integer.valueOf(numberOfVariables, 30);\n+    dataTable.setVarQuantity(Long.valueOf(numberOfVariables, 30));\n+  }\n \n-    private void decodeFileLabel(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeFileLabel: reader == null!\");\n-        }\n \n-        String fileLabel = parseStringField(reader);     \n-        // TODO: is this \"file label\" potentially useful? -- L.A. 4.0 beta\n-        ///smd.getFileInformation().put(\"fileLabel\", fileLabel);\n+  private void decodeFieldNo5(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeFieldNo5: reader == null!\");\n     }\n \n+    int field5 = parseNumericField(reader);\n+  }\n \n-    private void decodeNumberOfVariables(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeNumberOfVariables: reader == null!\");\n-        }\n-        \n-        String temp = null;\n-        char[] tmp = new char[1];\n-        StringBuilder sb = new StringBuilder();\n \n-        while (reader.read(tmp) > 0) {\n-            temp = Character.toString(tmp[0]);\n-            if (temp.equals(\"/\")) {\n-                break;\n-            } else {\n-                sb.append(temp);\n-            }\n-        }\n+  private void decodeWeightVariable(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeWeightVariable: reader == null!\");\n+    }\n \n-        String rawNumberOfVariables = sb.toString();\n-        int rawLength = rawNumberOfVariables.length();\n+    String weightVariableName = parseStringField(reader);\n+    // TODO: make sure case weight variables are properly handled!\n+    // -- L.A. 4.0 beta\n+    ///smd.getFileInformation().put(\"caseWeightVariableName\", weightVariableName);\n+    ///smd.setCaseWeightVariableName(weightVariableName);\n+  }\n \n-        String numberOfVariables = StringUtils.stripStart((StringUtils.strip(rawNumberOfVariables)), \"0\");\n-        \n-        if ((numberOfVariables.equals(\"\")) && (numberOfVariables.length() == rawLength)){\n-            numberOfVariables =\"0\";\n-        }\n \n-        varQnty = Integer.valueOf(numberOfVariables, 30);\n-        dataTable.setVarQuantity(Long.valueOf(numberOfVariables, 30));\n+  private void decodeVariableInformation(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeVariableInformation: reader == null!\");\n     }\n \n+    // step 1: variable type\n+    int variableType = parseNumericField(reader);\n+    variableTypelList.add(variableType);\n+    isCurrentVariableString = (variableType > 0);\n \n-    private void decodeFieldNo5(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeFieldNo5: reader == null!\");\n-        }    \n-        \n-        int field5 = parseNumericField(reader);\n+\n+    // step 2: variable name\n+    String variableName = parseStringField(reader);\n+    currentVariableName = variableName;\n+    variableNameList.add(variableName);\n+    variableTypeTable.put(variableName, variableType);\n+\n+    // step 3: format(print/write)\n+    int[] printWriteFormatTable = new int[6];\n+    for (int i = 0; i < 6; i++) {\n+      printWriteFormatTable[i] = parseNumericField(reader);\n     }\n \n+    int formatCode = printWriteFormatTable[0];\n+    int formatWidth = printWriteFormatTable[1];\n+    int formatDecimalPointPosition = printWriteFormatTable[2];\n \n-    private void decodeWeightVariable(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeWeightVariable: reader == null!\");\n-        }    \n-        \n-        String weightVariableName = parseStringField(reader);\n-        // TODO: make sure case weight variables are properly handled! \n-        // -- L.A. 4.0 beta\n-        ///smd.getFileInformation().put(\"caseWeightVariableName\", weightVariableName);\n-        ///smd.setCaseWeightVariableName(weightVariableName);\n-    }\n-\n-\n-    private void decodeVariableInformation(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeVariableInformation: reader == null!\");\n-        } \n-\n-        // step 1: variable type\n-        int variableType = parseNumericField(reader);\n-        variableTypelList.add(variableType);\n-        isCurrentVariableString = (variableType > 0);\n-            \n-            \n-        // step 2: variable name            \n-        String variableName = parseStringField(reader);\n-        currentVariableName = variableName;\n-        variableNameList.add(variableName);\n-        variableTypeTable.put(variableName,variableType);\n-           \n-        // step 3: format(print/write)\n-        int[] printWriteFormatTable = new int[6];\n-        for (int i=0; i < 6; i++){\n-            printWriteFormatTable[i]= parseNumericField(reader);\n-        }\n+    formatDecimalPointPositionList.add(formatDecimalPointPosition);\n+    if (!SPSSConstants.FORMAT_CODE_TABLE_POR.containsKey(formatCode)) {\n+      throw new IOException(\"Unknown format code was found = \" + formatCode);\n+    } else {\n+      printFormatList.add(printWriteFormatTable[0]);\n+    }\n \n-        int formatCode = printWriteFormatTable[0];\n-        int formatWidth = printWriteFormatTable[1];\n-        int formatDecimalPointPosition = printWriteFormatTable[2];\n+    if (!SPSSConstants.ORDINARY_FORMAT_CODE_SET.contains(formatCode)) {\n+      StringBuilder sb = new StringBuilder(SPSSConstants.FORMAT_CODE_TABLE_POR.get(formatCode) + formatWidth);\n+      if (formatDecimalPointPosition > 0) {\n+        sb.append(\".\" + formatDecimalPointPosition);\n+      }\n+      printFormatNameTable.put(variableName, sb.toString());\n+    }\n \n-        formatDecimalPointPositionList.add(formatDecimalPointPosition);\n-        if (!SPSSConstants.FORMAT_CODE_TABLE_POR.containsKey(formatCode)){\n-                throw new IOException(\"Unknown format code was found = \" + formatCode);\n-        } else {\n-            printFormatList.add(printWriteFormatTable[0]);\n-        }\n+    printFormatTable.put(variableName, SPSSConstants.FORMAT_CODE_TABLE_POR.get(formatCode));\n+  }\n \n-        if (!SPSSConstants.ORDINARY_FORMAT_CODE_SET.contains(formatCode)){\n-            StringBuilder sb = new StringBuilder(SPSSConstants.FORMAT_CODE_TABLE_POR.get(formatCode) + formatWidth);\n-            if (formatDecimalPointPosition > 0){\n-                sb.append(\".\"+ formatDecimalPointPosition);\n-            }\n-            printFormatNameTable.put(variableName, sb.toString());\n-        }\n \n-        printFormatTable.put(variableName, SPSSConstants.FORMAT_CODE_TABLE_POR.get(formatCode));\n+  private void decodeMissValuePointNumeric(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeMissValuePointNumeric: reader == null!\");\n     }\n \n+    if (missingValueCodeTable.containsKey(currentVariableName)) {\n+      missingValueCodeTable.get(currentVariableName).add(\"8\");\n+    } else {\n+      List<String> mvc = new ArrayList<>();\n+      mvc.add(\"8\");\n+      missingValueCodeTable.put(currentVariableName, mvc);\n+    }\n \n-    private void decodeMissValuePointNumeric(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeMissValuePointNumeric: reader == null!\");\n-        }\n-        \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n-            missingValueCodeTable.get(currentVariableName).add(\"8\");\n-        } else {\n-            List<String> mvc = new ArrayList<>();\n-            mvc.add(\"8\");\n-            missingValueCodeTable.put(currentVariableName, mvc);\n-        }\n+    String missingValuePoint = null;\n \n-        String missingValuePoint=null;\n+    // missing values are not always integers\n+    String base30value = getNumericFieldAsRawString(reader);\n+    if (base30value.contains(\".\")) {\n+      missingValuePoint = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n+    } else {\n+      missingValuePoint = Integer.valueOf(base30value, 30).toString();\n+    }\n \n-        // missing values are not always integers\n-        String base30value = getNumericFieldAsRawString(reader);\n-        if (base30value.contains(\".\")){\n-            missingValuePoint = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n-        } else {\n-            missingValuePoint= Integer.valueOf(base30value, 30).toString();\n-        }\n+    if (missingValueTable.containsKey(currentVariableName)) {\n+      // already stored\n+      (missingValueTable.get(currentVariableName)).add(missingValuePoint);\n+    } else {\n+      // no missing value stored\n+      List<String> mv = new ArrayList<>();\n+      mv.add(missingValuePoint);\n+      missingValueTable.put(currentVariableName, mv);\n+    }\n+  }\n \n-        if (missingValueTable.containsKey(currentVariableName)){\n-            // already stored\n-            (missingValueTable.get(currentVariableName)).add(missingValuePoint);\n-        } else {\n-            // no missing value stored\n-            List<String> mv = new ArrayList<>();\n-            mv.add(missingValuePoint);\n-            missingValueTable.put(currentVariableName, mv);\n-        }\n+\n+  private void decodeMissValuePointString(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeMissValuePointString: reader == null!\");\n     }\n \n+    if (missingValueCodeTable.containsKey(currentVariableName)) {\n+      missingValueCodeTable.get(currentVariableName).add(\"8\");\n+    } else {\n+      List<String> mvc = new ArrayList<>();\n+      mvc.add(\"8\");\n+      missingValueCodeTable.put(currentVariableName, mvc);\n+    }\n \n-    private void decodeMissValuePointString(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeMissValuePointString: reader == null!\");\n-        }    \n-        \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n-            missingValueCodeTable.get(currentVariableName).add(\"8\");\n-        } else {\n-            List<String> mvc = new ArrayList<>();\n-            mvc.add(\"8\");\n-            missingValueCodeTable.put(currentVariableName, mvc);\n-        }\n-        \n-        String missingValuePointString  = parseStringField(reader);\n-        \n-        if (missingValueTable.containsKey(currentVariableName)){\n-            // already stored\n-            (missingValueTable.get(currentVariableName)).add(missingValuePointString);\n-        } else {\n-            // no missing value stored\n-            List<String> mv = new ArrayList<>();\n-            mv.add(missingValuePointString);\n-            missingValueTable.put(currentVariableName, mv);\n-        }\n+    String missingValuePointString = parseStringField(reader);\n+\n+    if (missingValueTable.containsKey(currentVariableName)) {\n+      // already stored\n+      (missingValueTable.get(currentVariableName)).add(missingValuePointString);\n+    } else {\n+      // no missing value stored\n+      List<String> mv = new ArrayList<>();\n+      mv.add(missingValuePointString);\n+      missingValueTable.put(currentVariableName, mv);\n     }\n+  }\n \n \n-    private void decodeMissValueRangeLow(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeMissValueRangeLow: reader == null!\");\n-        }\n-        \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n-            missingValueCodeTable.get(currentVariableName).add(\"9\");\n-        } else {\n-            List<String> mvc = new ArrayList<>();\n-            mvc.add(\"9\");\n-            missingValueCodeTable.put(currentVariableName, mvc);\n-        }\n+  private void decodeMissValueRangeLow(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeMissValueRangeLow: reader == null!\");\n+    }\n \n-        String missingValueRangeLOtype=null;\n+    if (missingValueCodeTable.containsKey(currentVariableName)) {\n+      missingValueCodeTable.get(currentVariableName).add(\"9\");\n+    } else {\n+      List<String> mvc = new ArrayList<>();\n+      mvc.add(\"9\");\n+      missingValueCodeTable.put(currentVariableName, mvc);\n+    }\n \n-        // missing values are not always integers\n-        String base30value = getNumericFieldAsRawString(reader);\n+    String missingValueRangeLOtype = null;\n \n-        if (base30value.contains(\".\")){\n-            missingValueRangeLOtype = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n-        } else {\n-            missingValueRangeLOtype= Integer.valueOf(base30value, 30).toString();\n-        }\n-        \n-        if (missingValueTable.containsKey(currentVariableName)){\n-            // already stored\n-            (missingValueTable.get(currentVariableName)).add(\"LOWEST\");\n-            (missingValueTable.get(currentVariableName)).add(missingValueRangeLOtype);\n-        } else {\n-            // no missing value stored\n-            List<String> mv = new ArrayList<>();\n-            mv.add(\"LOWEST\");\n-            mv.add(missingValueRangeLOtype);\n-            missingValueTable.put(currentVariableName, mv);\n-        }\n+    // missing values are not always integers\n+    String base30value = getNumericFieldAsRawString(reader);\n+\n+    if (base30value.contains(\".\")) {\n+      missingValueRangeLOtype = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n+    } else {\n+      missingValueRangeLOtype = Integer.valueOf(base30value, 30).toString();\n     }\n \n+    if (missingValueTable.containsKey(currentVariableName)) {\n+      // already stored\n+      (missingValueTable.get(currentVariableName)).add(\"LOWEST\");\n+      (missingValueTable.get(currentVariableName)).add(missingValueRangeLOtype);\n+    } else {\n+      // no missing value stored\n+      List<String> mv = new ArrayList<>();\n+      mv.add(\"LOWEST\");\n+      mv.add(missingValueRangeLOtype);\n+      missingValueTable.put(currentVariableName, mv);\n+    }\n+  }\n \n-    private void decodeMissValueRangeHigh(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeMissValueRangeHigh: reader == null!\");\n-        }\n-        \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n-            missingValueCodeTable.get(currentVariableName).add(\"A\");\n-        } else {\n-            List<String> mvc = new ArrayList<>();\n-            mvc.add(\"A\");\n-            missingValueCodeTable.put(currentVariableName, mvc);\n-        }\n \n-        String missingValueRangeHItype = null;\n+  private void decodeMissValueRangeHigh(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeMissValueRangeHigh: reader == null!\");\n+    }\n \n-        // missing values are not always integers\n-        String base30value = getNumericFieldAsRawString(reader);\n+    if (missingValueCodeTable.containsKey(currentVariableName)) {\n+      missingValueCodeTable.get(currentVariableName).add(\"A\");\n+    } else {\n+      List<String> mvc = new ArrayList<>();\n+      mvc.add(\"A\");\n+      missingValueCodeTable.put(currentVariableName, mvc);\n+    }\n \n-        if (base30value.contains(\".\")){\n-            missingValueRangeHItype = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n-        } else {\n-            missingValueRangeHItype= Integer.valueOf(base30value, 30).toString();\n-        }\n+    String missingValueRangeHItype = null;\n \n-        if (missingValueTable.containsKey(currentVariableName)){\n-            // already stored\n-            (missingValueTable.get(currentVariableName)).add(missingValueRangeHItype);\n-            (missingValueTable.get(currentVariableName)).add(\"HIGHEST\");\n-        } else {\n-            // no missing value stored\n-           List<String> mv = new ArrayList<>();\n-           mv.add(missingValueRangeHItype);\n-           mv.add(\"HIGHEST\");\n-           missingValueTable.put(currentVariableName, mv);\n-        }\n+    // missing values are not always integers\n+    String base30value = getNumericFieldAsRawString(reader);\n+\n+    if (base30value.contains(\".\")) {\n+      missingValueRangeHItype = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n+    } else {\n+      missingValueRangeHItype = Integer.valueOf(base30value, 30).toString();\n     }\n-    \n-    \n-    private void decodeMissValueRange(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeMissValueRange: reader == null!\");\n-        }\n \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n-            missingValueCodeTable.get(currentVariableName).add(\"B\");\n-        } else {\n-            List<String> mvc = new ArrayList<>();\n-            mvc.add(\"B\");\n-            missingValueCodeTable.put(currentVariableName, mvc);\n-        }\n-        \n-        String[] missingValueRange = new String[2];\n+    if (missingValueTable.containsKey(currentVariableName)) {\n+      // already stored\n+      (missingValueTable.get(currentVariableName)).add(missingValueRangeHItype);\n+      (missingValueTable.get(currentVariableName)).add(\"HIGHEST\");\n+    } else {\n+      // no missing value stored\n+      List<String> mv = new ArrayList<>();\n+      mv.add(missingValueRangeHItype);\n+      mv.add(\"HIGHEST\");\n+      missingValueTable.put(currentVariableName, mv);\n+    }\n+  }\n \n-       // missing values are not always integers\n-        String base30value0 = getNumericFieldAsRawString(reader);\n \n-        if (base30value0.contains(\".\")){\n-            missingValueRange[0] = doubleNumberFormatter.format(base30Tobase10Conversion(base30value0));\n-        } else {\n-            missingValueRange[0]= Integer.valueOf(base30value0, 30).toString();\n-        }\n+  private void decodeMissValueRange(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeMissValueRange: reader == null!\");\n+    }\n \n-        String base30value1 = getNumericFieldAsRawString(reader);\n+    if (missingValueCodeTable.containsKey(currentVariableName)) {\n+      missingValueCodeTable.get(currentVariableName).add(\"B\");\n+    } else {\n+      List<String> mvc = new ArrayList<>();\n+      mvc.add(\"B\");\n+      missingValueCodeTable.put(currentVariableName, mvc);\n+    }\n \n-        if (base30value1.contains(\".\")){\n-            missingValueRange[1] = doubleNumberFormatter.format(base30Tobase10Conversion(base30value1));\n-        } else {\n-            missingValueRange[1]= Integer.valueOf(base30value1, 30).toString();\n-        }\n+    String[] missingValueRange = new String[2];\n+\n+    // missing values are not always integers\n+    String base30value0 = getNumericFieldAsRawString(reader);\n+\n+    if (base30value0.contains(\".\")) {\n+      missingValueRange[0] = doubleNumberFormatter.format(base30Tobase10Conversion(base30value0));\n+    } else {\n+      missingValueRange[0] = Integer.valueOf(base30value0, 30).toString();\n+    }\n+\n+    String base30value1 = getNumericFieldAsRawString(reader);\n+\n+    if (base30value1.contains(\".\")) {\n+      missingValueRange[1] = doubleNumberFormatter.format(base30Tobase10Conversion(base30value1));\n+    } else {\n+      missingValueRange[1] = Integer.valueOf(base30value1, 30).toString();\n+    }\n+\n+    if (missingValueTable.containsKey(currentVariableName)) {\n+      // already stored\n+      (missingValueTable.get(currentVariableName)).add(missingValueRange[0]);\n+      (missingValueTable.get(currentVariableName)).add(missingValueRange[1]);\n+    } else {\n+      // no missing value stored\n+      List<String> mv = new ArrayList<>();\n+      mv.add(missingValueRange[0]);\n+      mv.add(missingValueRange[1]);\n+      missingValueTable.put(currentVariableName, mv);\n+    }\n+  }\n \n-        if (missingValueTable.containsKey(currentVariableName)){\n-            // already stored\n-            (missingValueTable.get(currentVariableName)).add(missingValueRange[0]);\n-            (missingValueTable.get(currentVariableName)).add(missingValueRange[1]);\n+\n+  private void decodeVariableLabel(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeVariableLabel: reader == null!\");\n+    }\n+\n+    String variableLabel = parseStringField(reader);\n+    variableLabelMap.put(currentVariableName, variableLabel);\n+    // note: not all variables have their variable label; therefore,\n+    // saving them to the metatadata object is done within read() method\n+\n+  }\n+\n+\n+  private void decodeValueLabel(BufferedReader reader) throws IOException {\n+    Map<String, String> valueLabelSet = new LinkedHashMap<>();\n+\n+    int numberOfVariables = parseNumericField(reader);\n+    String[] variableNames = new String[numberOfVariables];\n+\n+    for (int i = 0; i < numberOfVariables; i++) {\n+      variableNames[i] = parseStringField(reader);\n+    }\n+\n+    int numberOfvalueLabelSets = parseNumericField(reader);\n+    boolean isStringType = variableTypeTable.get(variableNames[0]) > 0;\n+\n+    for (int i = 0; i < numberOfvalueLabelSets; i++) {\n+      String[] tempValueLabel = new String[2];\n+      if (isStringType) {\n+        // String case\n+        tempValueLabel[0] = parseStringField(reader);\n+      } else {\n+        // Numeric case\n+        // values may not be always integers\n+        String base30value = getNumericFieldAsRawString(reader);\n+\n+        Matcher matcher = pattern4Integer.matcher(base30value);\n+\n+        if (matcher.matches()) {\n+          // integer case\n+          tempValueLabel[0] = Long.valueOf(base30value, 30).toString();\n         } else {\n-            // no missing value stored\n-           List<String> mv = new ArrayList<>();\n-           mv.add(missingValueRange[0]);\n-           mv.add(missingValueRange[1]);\n-           missingValueTable.put(currentVariableName, mv);\n+          // double case\n+          tempValueLabel[0] = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n         }\n+      }\n+\n+\n+      tempValueLabel[1] = parseStringField(reader);\n+      valueLabelSet.put(tempValueLabel[0], tempValueLabel[1]);\n     }\n-    \n+    // save the value-label mapping list\n+    // use the first variable name as the key\n+    valueLabelTable.put(variableNames[0], valueLabelSet);\n \n-    private void decodeVariableLabel(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeVariableLabel: reader == null!\");\n-        }    \n+    // create a mapping table that finds the key variable for this mapping table\n+    for (String vn : variableNames) {\n+      valueVariableMappingTable.put(vn, variableNames[0]);\n+    }\n+  }\n \n-        String variableLabel = parseStringField(reader);\n-        variableLabelMap.put(currentVariableName, variableLabel);\n-        // note: not all variables have their variable label; therefore,\n-        // saving them to the metatadata object is done within read() method\n \n+  private void decodeDocument(BufferedReader reader) throws IOException {\n+    if (reader == null) {\n+      throw new IllegalArgumentException(\"decodeVariableLabel: reader == null!\");\n     }\n-    \n-    \n-    private void decodeValueLabel(BufferedReader reader) throws IOException {\n-        Map<String, String> valueLabelSet = new LinkedHashMap<>();\n-        \n-        int numberOfVariables = parseNumericField(reader);\n-        String[] variableNames = new String[numberOfVariables];\n \n-        for (int i= 0; i< numberOfVariables; i++){\n-            variableNames[i] = parseStringField(reader);\n-        }\n+    int noOfdocumentLines = parseNumericField(reader);\n+    String[] document = new String[noOfdocumentLines];\n \n-        int numberOfvalueLabelSets = parseNumericField(reader);\n-        boolean isStringType = variableTypeTable.get(variableNames[0]) > 0;\n+    for (int i = 0; i < noOfdocumentLines; i++) {\n+      document[i] = parseStringField(reader);\n+    }\n \n-        for (int i=0; i<numberOfvalueLabelSets ;i++){\n-            String[] tempValueLabel = new String[2];\n-            if (isStringType){\n-                // String case\n-                tempValueLabel[0] = parseStringField(reader);\n-            } else {\n-                // Numeric case\n-                // values may not be always integers\n-                String base30value = getNumericFieldAsRawString(reader);\n-\n-                Matcher matcher = pattern4Integer.matcher(base30value);\n-\n-                if (matcher.matches()) {\n-                    // integer case\n-                    tempValueLabel[0] = Long.valueOf(base30value, 30).toString();\n-                } else {\n-                    // double case\n-                    tempValueLabel[0] = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n+    // TODO:\n+    // verify if this \"document\" is any useful potentially.\n+    // -- L.A. 4.0 beta\n+    ///smd.getFileInformation().put(\"document\", StringUtils.join(document,\" \" ));\n+  }\n+\n+\n+  private void decodeData(BufferedReader reader) throws IOException {\n+    dbgLog.fine(\"decodeData(): start\");\n+    // TODO: get rid of this \"variableTypeFinal\"; -- L.A. 4.0 beta\n+    int[] variableTypeFinal = new int[varQnty];\n+    dateFormatList = new String[varQnty];\n+\n+    // create a File object to save the tab-delimited data file\n+    File tabDelimitedDataFile = File.createTempFile(\"tempTabfile.\", \".tab\");\n+    ingesteddata.setTabDelimitedFile(tabDelimitedDataFile);\n+\n+\n+    FileOutputStream fileOutTab = null;\n+    PrintWriter pwout = null;\n+\n+    try {\n+      fileOutTab = new FileOutputStream(tabDelimitedDataFile);\n+      pwout = new PrintWriter(new OutputStreamWriter(fileOutTab, \"utf8\"), true);\n+\n+      variableFormatTypeList = new String[varQnty];\n+      for (int i = 0; i < varQnty; i++) {\n+        variableFormatTypeList[i] =\n+          SPSSConstants.FORMAT_CATEGORY_TABLE.get(printFormatTable.get(variableNameList.get(i)));\n+        formatCategoryTable.put(variableNameList.get(i), variableFormatTypeList[i]);\n+      }\n+\n+      // contents (variable) checker concering decimals\n+      Arrays.fill(variableTypeFinal, 0);\n+\n+      // raw-case counter\n+      int j = 0; // case\n+\n+      // use while instead for because the number of cases (observations) is usually unknown\n+      FBLOCK:\n+      while (true) {\n+        j++;\n+\n+        // case(row)-wise storage object; to be updated after each row-reading\n+\n+        String[] casewiseRecordForTabFile = new String[varQnty];\n+        // warning: the above object is later shallow-copied to the\n+        // data object for calculating a UNF value/summary statistics\n+        //\n+\n+        for (int i = 0; i < varQnty; i++) {\n+          // check the type of this variable\n+          boolean isStringType = variableTypeTable.get(variableNameList.get(i)) > 0;\n+\n+          if (isStringType) {\n+            // String case\n+            variableTypeFinal[i] = -1;\n+\n+            StringBuilder sb_StringLengthBase30 = new StringBuilder(\"\");\n+            int stringLengthBase10 = 0;\n+            String buffer = \"\";\n+            char[] tmp = new char[1];\n+\n+            int nint;\n+            while ((nint = reader.read(tmp)) > 0) {\n+              buffer = Character.toString(tmp[0]);\n+              if (buffer.equals(\"/\")) {\n+                break;\n+              } else if (buffer.equals(\"Z\")) {\n+                if (i == 0) {\n+                  // the reader has passed the last case; subtract 1 from the j counter\n+                  caseQnty = j - 1;\n+                  break FBLOCK;\n                 }\n+              } else {\n+                sb_StringLengthBase30.append(buffer);\n+              }\n+\n+\n             }\n \n+            if (nint == 0) {\n+              // no more data to be read (reached the eof)\n+              caseQnty = j - 1;\n+              break FBLOCK;\n+            }\n \n-            tempValueLabel[1] = parseStringField(reader);\n-            valueLabelSet.put(tempValueLabel[0],tempValueLabel[1]);\n-        }\n-        // save the value-label mapping list\n-        // use the first variable name as the key\n-        valueLabelTable.put(variableNames[0], valueLabelSet);\n \n-        // create a mapping table that finds the key variable for this mapping table\n-        for (String vn : variableNames){\n-            valueVariableMappingTable.put(vn, variableNames[0]);\n-        }\n-    }\n+            dbgLog.finer(j + \"-th case \" + i + \"=th var:datum length=\" + sb_StringLengthBase30.toString());\n \n+            // this length value should be a positive integer\n+            Matcher mtr = pattern4positiveInteger.matcher(sb_StringLengthBase30.toString());\n+            if (mtr.matches()) {\n+              stringLengthBase10 = Integer.valueOf(sb_StringLengthBase30.toString(), 30);\n+            } else {\n+              // reading error case\n+              throw new IOException(\"reading F(data) section: string: length is not integer\");\n+            }\n \n-    private void decodeDocument(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n-            throw new IllegalArgumentException(\"decodeVariableLabel: reader == null!\");\n-        }    \n-        \n-        int noOfdocumentLines = parseNumericField(reader);\n-        String[] document = new String[noOfdocumentLines];\n+            // read this string-variable's contents after \"/\"\n+            char[] char_datumString = new char[stringLengthBase10];\n+            reader.read(char_datumString);\n+\n+            String datum = new String(char_datumString);\n+            casewiseRecordForTabFile[i] = \"\\\"\" + datum.replaceAll(\"\\\"\", Matcher.quoteReplacement(\"\\\\\\\"\")) + \"\\\"\";\n+            // end of string case\n+          } else {\n+\n+            // numeric case\n+            StringBuilder sb_datumNumericBase30 = new StringBuilder(\"\");\n+            boolean isMissingValue = false;\n+            String datum = null;\n+            String datumForTabFile = null;\n+            String datumDateFormat = null;\n+\n+            String buffer = \"\";\n+            char[] tmp = new char[1];\n+            int nint;\n+            while ((nint = reader.read(tmp)) > 0) {\n+              sb_datumNumericBase30.append(buffer);\n+              buffer = Character.toString(tmp[0]);\n+\n+              if (buffer.equals(\"/\")) {\n+                break;\n+              } else if (buffer.equals(\"Z\")) {\n+                if (i == 0) {\n+                  // the reader has passed the last case\n+                  // subtract 1 from the j counter\n+                  dbgLog.fine(\"Z-mark was detected\");\n+                  caseQnty = j - 1;\n+                  break FBLOCK;\n+                }\n+              } else if (buffer.equals(\"*\")) {\n+                // '*' is the first character of the system missing value\n+                datumForTabFile = MissingValueForTextDataFile;\n+                datum = null;\n+                isMissingValue = true;\n+\n+                // read next char '.' as part of the missing value\n+                reader.read(tmp);\n+                buffer = Character.toString(tmp[0]);\n+                break;\n+              }\n \n-        for (int i= 0; i< noOfdocumentLines; i++){\n-            document[i] = parseStringField(reader);\n-        }\n+            }\n+            if (nint == 0) {\n+              // no more data to be read; reached the eof\n+              caseQnty = j - 1;\n+              break FBLOCK;\n+            }\n \n-        // TODO: \n-        // verify if this \"document\" is any useful potentially. \n-        // -- L.A. 4.0 beta\n-        ///smd.getFileInformation().put(\"document\", StringUtils.join(document,\" \" ));\n-    }\n+            // follow-up process for non-missing-values\n+            if (!isMissingValue) {\n+              // decode a numeric datum as String\n+              String datumNumericBase30 = sb_datumNumericBase30.toString();\n+              Matcher matcher = pattern4Integer.matcher(datumNumericBase30);\n+\n+              if (matcher.matches()) {\n+                // integer case\n+                datum = Long.valueOf(datumNumericBase30, 30).toString();\n+              } else {\n+                // double case\n+                datum = doubleNumberFormatter.format(base30Tobase10Conversion(datumNumericBase30));\n+              }\n+\n+              // now check format (if date or time)\n+              String variableFormatType = variableFormatTypeList[i];\n+\n+              if (variableFormatType.equals(\"date\")) {\n+                variableTypeFinal[i] = -1;\n+                long dateDatum = Long.parseLong(datum) * 1000L - SPSS_DATE_OFFSET;\n+                datum = sdf_ymd.format(new Date(dateDatum));\n+                datumDateFormat = sdf_ymd.toPattern();\n+\n+              } else if (variableFormatType.equals(\"time\")) {\n+                variableTypeFinal[i] = -1;\n+                int formatDecimalPointPosition = formatDecimalPointPositionList.get(i);\n+\n+                if (printFormatTable.get(variableNameList.get(i)).equals(\"DTIME\")) {\n+\n+                  if (datum.indexOf(\".\") < 0) {\n+                    long dateDatum = Long.parseLong(datum) * 1000L - SPSS_DATE_BIAS;\n+                    datum = sdf_dhms.format(new Date(dateDatum));\n+                    // don't save date format for dtime\n+                  } else {\n+                    // decimal point included\n+                    String[] timeData = datum.split(\"\\\\.\");\n+                    long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_BIAS;\n+                    StringBuilder sb_time = new StringBuilder(sdf_dhms.format(new Date(dateDatum)));\n+\n+                    if (formatDecimalPointPosition > 0) {\n+                      sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                    }\n \n+                    datum = sb_time.toString();\n+                    // DTIME is weird date/time format that no one uses outside of\n+                    // SPSS; so we are not even going to bother trying to save\n+                    // this variable as a datetime.\n+                  }\n+\n+                } else if (printFormatTable.get(variableNameList.get(i)).equals(\"DATETIME\")) {\n+                  // TODO:\n+                  // (for both datetime and \"dateless\" time)\n+                  // keep the longest of the matching formats - i.e., if there are *some*\n+                  // values in the vector that have thousands of a second, that should be\n+                  // part of the saved format!\n+                  //  -- L.A. Aug. 12 2014\n+\n+                  if (!datum.contains(\".\")) {\n+                    long dateDatum = Long.parseLong(datum) * 1000L - SPSS_DATE_OFFSET;\n+                    datum = sdf_ymdhms.format(new Date(dateDatum));\n+                    datumDateFormat = sdf_ymdhms.toPattern();\n+                  } else {\n+                    // decimal point included\n+                    String[] timeData = datum.split(\"\\\\.\");\n+                    long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_OFFSET;\n+                    StringBuilder sb_time = new StringBuilder(sdf_ymdhms.format(new Date(dateDatum)));\n+\n+                    if (formatDecimalPointPosition > 0) {\n+                      sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                    }\n \n-    private void decodeData(BufferedReader reader) throws IOException {\n-        dbgLog.fine(\"decodeData(): start\");\n-        // TODO: get rid of this \"variableTypeFinal\"; -- L.A. 4.0 beta\n-        int[] variableTypeFinal= new int[varQnty];\n-        dateFormatList = new String[varQnty];\n+                    datum = sb_time.toString();\n+                    datumDateFormat = sdf_ymdhms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\");\n+                  }\n \n-        // create a File object to save the tab-delimited data file\n-        File tabDelimitedDataFile = File.createTempFile(\"tempTabfile.\", \".tab\");\n-        ingesteddata.setTabDelimitedFile(tabDelimitedDataFile);\n-        \n+                } else if (printFormatTable.get(variableNameList.get(i)).equals(\"TIME\")) {\n \n-        FileOutputStream fileOutTab = null;\n-        PrintWriter pwout = null;\n+                  if (!datum.contains(\".\")) {\n+                    long dateDatum = Long.parseLong(datum) * 1000L;\n+                    datum = sdf_hms.format(new Date(dateDatum));\n+                    datumDateFormat = sdf_hms.toPattern();\n+                  } else {\n+                    // decimal point included\n+                    String[] timeData = datum.split(\"\\\\.\");\n+                    long dateDatum = Long.parseLong(timeData[0]) * 1000L;\n+                    StringBuilder sb_time = new StringBuilder(sdf_hms.format(new Date(dateDatum)));\n \n-        try {\n-            fileOutTab = new FileOutputStream(tabDelimitedDataFile);\n-            pwout = new PrintWriter(new OutputStreamWriter(fileOutTab, \"utf8\"), true);\n+                    if (formatDecimalPointPosition > 0) {\n+                      sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                    }\n+\n+                    datum = sb_time.toString();\n+                    datumDateFormat = sdf_hms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\");\n+                  }\n+                }\n+\n+              } else if (variableFormatType.equals(\"other\")) {\n+\n+                if (printFormatTable.get(variableNameList.get(i)).equals(\"WKDAY\")) {\n+                  // day of week\n+                  variableTypeFinal[i] = -1;\n+                  datum = SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(datum) - 1);\n+\n+                } else if (printFormatTable.get(variableNameList.get(i)).equals(\"MONTH\")) {\n+                  // month\n+                  variableTypeFinal[i] = -1;\n+                  datum = SPSSConstants.MONTH_LIST.get(Integer.valueOf(datum) - 1);\n+                }\n+              }\n \n-            variableFormatTypeList = new String[varQnty];\n-            for (int i = 0; i < varQnty; i++) {\n-                variableFormatTypeList[i] = SPSSConstants.FORMAT_CATEGORY_TABLE.get(printFormatTable.get(variableNameList.get(i)));\n-                formatCategoryTable.put(variableNameList.get(i), variableFormatTypeList[i]);\n+              // since value is not missing, set both values to be the same\n+              datumForTabFile = datum;\n+\n+              // decimal-point check (variable is integer or not)\n+              if (variableTypeFinal[i] == 0) {\n+                if (datum.contains(\".\")) {\n+                  variableTypeFinal[i] = 1;\n+                  decimalVariableSet.add(i);\n+                }\n+              }\n             }\n \n-            // contents (variable) checker concering decimals\n-            Arrays.fill(variableTypeFinal, 0);\n-\n-            // raw-case counter\n-            int j = 0; // case\n-\n-            // use while instead for because the number of cases (observations) is usually unknown\n-            FBLOCK: while(true){\n-                j++;\n-\n-                // case(row)-wise storage object; to be updated after each row-reading\n-\n-                String[] casewiseRecordForTabFile = new String[varQnty];\n-                // warning: the above object is later shallow-copied to the\n-                // data object for calculating a UNF value/summary statistics\n-                //\n-\n-                for (int i=0; i<varQnty; i++){\n-                    // check the type of this variable\n-                    boolean isStringType = variableTypeTable.get(variableNameList.get(i)) > 0;\n-\n-                    if (isStringType){\n-                        // String case\n-                        variableTypeFinal[i]=-1;\n-\n-                        StringBuilder sb_StringLengthBase30 = new StringBuilder(\"\");\n-                        int stringLengthBase10 = 0;\n-                        String buffer = \"\";\n-                        char[] tmp = new char[1];\n-\n-                        int nint;\n-                        while((nint = reader.read(tmp))>0){\n-                            buffer =  Character.toString(tmp[0]);\n-                            if (buffer.equals(\"/\")){\n-                                break;\n-                            } else if (buffer.equals(\"Z\")){\n-                                if (i == 0){\n-                                    // the reader has passed the last case; subtract 1 from the j counter\n-                                    caseQnty = j-1;\n-                                    break FBLOCK;\n-                                }\n-                            } else {\n-                                sb_StringLengthBase30.append(buffer);\n-                            }\n-\n-\n-                        }\n-\n-                        if (nint == 0){\n-                            // no more data to be read (reached the eof)\n-                            caseQnty = j - 1;\n-                            break FBLOCK;\n-                        }\n-\n-\n-                        dbgLog.finer(j+\"-th case \"+i+\"=th var:datum length=\" +sb_StringLengthBase30.toString());\n-\n-                        // this length value should be a positive integer\n-                        Matcher mtr = pattern4positiveInteger.matcher(sb_StringLengthBase30.toString());\n-                        if (mtr.matches()){\n-                            stringLengthBase10 = Integer.valueOf(sb_StringLengthBase30.toString(), 30);\n-                        } else{\n-                            // reading error case\n-                            throw new IOException(\"reading F(data) section: string: length is not integer\");\n-                        }\n-\n-                        // read this string-variable's contents after \"/\"\n-                        char[] char_datumString = new char[stringLengthBase10];\n-                        reader.read(char_datumString);\n-\n-                        String datum = new String(char_datumString);\n-                        casewiseRecordForTabFile[i] =  \"\\\"\" + datum.replaceAll(\"\\\"\",Matcher.quoteReplacement(\"\\\\\\\"\")) + \"\\\"\";\n-                        // end of string case\n-                    } else {\n-\n-                        // numeric case\n-                        StringBuilder sb_datumNumericBase30 = new StringBuilder(\"\");\n-                        boolean isMissingValue = false;\n-                        String datum = null;\n-                        String datumForTabFile = null;\n-                        String datumDateFormat = null;\n-\n-                        String buffer = \"\";\n-                        char[] tmp = new char[1];\n-                        int nint;\n-                        while((nint = reader.read(tmp))>0){\n-                            sb_datumNumericBase30.append(buffer);\n-                            buffer = Character.toString(tmp[0]);\n-\n-                            if (buffer.equals(\"/\")){\n-                                break;\n-                            } else if (buffer.equals(\"Z\")){\n-                                if (i == 0){\n-                                    // the reader has passed the last case\n-                                    // subtract 1 from the j counter\n-                                    dbgLog.fine(\"Z-mark was detected\");\n-                                    caseQnty = j-1;\n-                                    break FBLOCK;\n-                                }\n-                            } else if (buffer.equals(\"*\")) {\n-                                // '*' is the first character of the system missing value\n-                                datumForTabFile = MissingValueForTextDataFile;\n-                                datum = null;\n-                                isMissingValue = true;\n-\n-                               // read next char '.' as part of the missing value\n-                                reader.read(tmp);\n-                                buffer = Character.toString(tmp[0]);\n-                                break;\n-                            }\n-\n-                        }\n-                        if (nint == 0){\n-                            // no more data to be read; reached the eof\n-                            caseQnty = j - 1;\n-                            break FBLOCK;\n-                        }\n-\n-                        // follow-up process for non-missing-values\n-                        if (!isMissingValue) {\n-                            // decode a numeric datum as String\n-                            String datumNumericBase30 = sb_datumNumericBase30.toString();\n-                            Matcher matcher = pattern4Integer.matcher(datumNumericBase30);\n-\n-                            if (matcher.matches()){\n-                                // integer case\n-                                datum = Long.valueOf(datumNumericBase30, 30).toString();\n-                            } else {\n-                                // double case\n-                                datum = doubleNumberFormatter.format(base30Tobase10Conversion(datumNumericBase30));\n-                            }\n-\n-                            // now check format (if date or time)\n-                            String variableFormatType = variableFormatTypeList[i];\n-\n-                            if (variableFormatType.equals(\"date\")){\n-                                variableTypeFinal[i]=-1;\n-                                long dateDatum = Long.parseLong(datum)*1000L- SPSS_DATE_OFFSET;\n-                                datum = sdf_ymd.format(new Date(dateDatum));\n-                                datumDateFormat = sdf_ymd.toPattern();\n-\n-                            } else if (variableFormatType.equals(\"time\")) {\n-                                variableTypeFinal[i]=-1;\n-                                int formatDecimalPointPosition = formatDecimalPointPositionList.get(i);\n-\n-                                if (printFormatTable.get(variableNameList.get(i)).equals(\"DTIME\")){\n-\n-                                    if (datum.indexOf(\".\") < 0){\n-                                        long dateDatum  = Long.parseLong(datum)*1000L - SPSS_DATE_BIAS;\n-                                        datum = sdf_dhms.format(new Date(dateDatum));\n-                                        // don't save date format for dtime\n-                                    } else {\n-                                        // decimal point included\n-                                        String[] timeData = datum.split(\"\\\\.\");\n-                                        long dateDatum = Long.parseLong(timeData[0])*1000L - SPSS_DATE_BIAS;\n-                                        StringBuilder sb_time = new StringBuilder(sdf_dhms.format(new Date(dateDatum)));\n-\n-                                        if (formatDecimalPointPosition > 0){\n-                                            sb_time.append(\".\"+timeData[1].substring(0,formatDecimalPointPosition));\n-                                        }\n-\n-                                        datum = sb_time.toString();\n-                                        // DTIME is weird date/time format that no one uses outside of \n-                                        // SPSS; so we are not even going to bother trying to save\n-                                        // this variable as a datetime. \n-                                    }\n-\n-                                } else if (printFormatTable.get(variableNameList.get(i)).equals(\"DATETIME\")){\n-                                    // TODO: \n-                                    // (for both datetime and \"dateless\" time)\n-                                    // keep the longest of the matching formats - i.e., if there are *some*\n-                                    // values in the vector that have thousands of a second, that should be \n-                                    // part of the saved format!\n-                                    //  -- L.A. Aug. 12 2014 \n-\n-                                    if (!datum.contains(\".\")){\n-                                        long dateDatum  = Long.parseLong(datum)*1000L - SPSS_DATE_OFFSET;\n-                                        datum = sdf_ymdhms.format(new Date(dateDatum));\n-                                        datumDateFormat = sdf_ymdhms.toPattern();\n-                                    } else {\n-                                        // decimal point included\n-                                        String[] timeData = datum.split(\"\\\\.\");\n-                                        long dateDatum = Long.parseLong(timeData[0])*1000L- SPSS_DATE_OFFSET;\n-                                        StringBuilder sb_time = new StringBuilder(sdf_ymdhms.format(new Date(dateDatum)));\n-\n-                                        if (formatDecimalPointPosition > 0){\n-                                            sb_time.append(\".\"+timeData[1].substring(0,formatDecimalPointPosition));\n-                                        }\n-\n-                                        datum = sb_time.toString();\n-                                        datumDateFormat = sdf_ymdhms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\" );\n-                                    }\n-\n-                                } else if (printFormatTable.get(variableNameList.get(i)).equals(\"TIME\")){\n-\n-                                    if (!datum.contains(\".\")){\n-                                        long dateDatum = Long.parseLong(datum)*1000L;\n-                                        datum = sdf_hms.format(new Date(dateDatum));\n-                                        datumDateFormat = sdf_hms.toPattern();\n-                                    } else {\n-                                        // decimal point included\n-                                        String[] timeData = datum.split(\"\\\\.\");\n-                                        long dateDatum = Long.parseLong(timeData[0])*1000L;\n-                                        StringBuilder sb_time = new StringBuilder(sdf_hms.format(new Date(dateDatum)));\n-\n-                                        if (formatDecimalPointPosition > 0){\n-                                            sb_time.append(\".\"+timeData[1].substring(0,formatDecimalPointPosition));\n-                                        }\n-\n-                                        datum = sb_time.toString();\n-                                        datumDateFormat = sdf_hms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\" );\n-                                    }\n-                                }\n-\n-                            } else if (variableFormatType.equals(\"other\")){\n-\n-                                if (printFormatTable.get(variableNameList.get(i)).equals(\"WKDAY\")){\n-                                    // day of week\n-                                    variableTypeFinal[i]=-1;\n-                                    datum = SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(datum)-1);\n-\n-                                } else if (printFormatTable.get(variableNameList.get(i)).equals(\"MONTH\")){\n-                                    // month\n-                                    variableTypeFinal[i]=-1;\n-                                    datum = SPSSConstants.MONTH_LIST.get(Integer.valueOf(datum)-1);\n-                                }\n-                            }\n-\n-                            // since value is not missing, set both values to be the same\n-                            datumForTabFile = datum;\n-\n-                            // decimal-point check (variable is integer or not)\n-                            if (variableTypeFinal[i]==0){\n-                                if (datum.contains(\".\")){\n-                                    variableTypeFinal[i] = 1;\n-                                    decimalVariableSet.add(i);\n-                                }\n-                            }\n-                        }\n-\n-                        if (datumDateFormat != null) {\n-                            dateFormatList[i] = datumDateFormat;\n-                        }\n-                        casewiseRecordForTabFile[i]= datumForTabFile;\n-\n-                    } // end: if: string vs numeric variable\n-\n-                } // end:for-loop-i (variable-wise loop)\n-\n-\n-                // print the i-th case; use casewiseRecord to dump the current case to the tab-delimited file\n-                pwout.println(StringUtils.join(casewiseRecordForTabFile, \"\\t\"));\n-\n-            } // end: while-block\n-        } finally {\n-            // close the print writer\n-            if (pwout != null) {\n-                pwout.close();\n+            if (datumDateFormat != null) {\n+              dateFormatList[i] = datumDateFormat;\n             }\n-        }\n+            casewiseRecordForTabFile[i] = datumForTabFile;\n+\n+          } // end: if: string vs numeric variable\n+\n+        } // end:for-loop-i (variable-wise loop)\n+\n \n-        ///smd.setDecimalVariables(decimalVariableSet);\n-        dataTable.setCaseQuantity(new Long(caseQnty));\n+        // print the i-th case; use casewiseRecord to dump the current case to the tab-delimited file\n+        pwout.println(StringUtils.join(casewiseRecordForTabFile, \"\\t\"));\n \n-        dbgLog.fine(\"decodeData(): end\");\n+      } // end: while-block\n+    } finally {\n+      // close the print writer\n+      if (pwout != null) {\n+        pwout.close();\n+      }\n     }\n-    \n-    \n-    private void processMissingValueData(){\n+\n+    ///smd.setDecimalVariables(decimalVariableSet);\n+    dataTable.setCaseQuantity(new Long(caseQnty));\n+\n+    dbgLog.fine(\"decodeData(): end\");\n+  }\n+\n+\n+  private void processMissingValueData() {\n         /*\n \n          POR's missing-value storage differs form the counterpart of SAV;\n@@ -1414,332 +1435,334 @@ public class PORFileReader  extends TabularDataFileReader{\n \n          */\n \n-        dbgLog.fine(\"missingValueCodeTable=\"+missingValueCodeTable);\n-        Set<Map.Entry<String,List<String>>> msvlc = missingValueCodeTable.entrySet();\n-        for (Map.Entry<String, List<String>> et : msvlc) {\n-            String variable = et.getKey();\n-            dbgLog.fine(\"variable=\"+variable);\n-            List<String> codeList = et.getValue();\n-            List<String> valueList = missingValueTable.get(variable);\n-            dbgLog.fine(\"codeList=\"+codeList);\n-            dbgLog.fine(\"valueList=\"+valueList);\n-            int type;\n-            InvalidData invalidDataInfo = null;\n-            if (valueList.size() == 3){\n-                if (codeList.get(0).equals(\"8\") && codeList.get(1).equals(\"8\") &&\n-                        codeList.get(2).equals(\"8\") ){\n-                    type = 3;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidValues(valueList);\n-                } else if (codeList.get(0).equals(\"9\") && codeList.get(1).equals(\"8\")){\n-                    type = -3;\n-\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-\n-                } else if (codeList.get(0).equals(\"A\") && codeList.get(1).equals(\"8\")){\n-                    type = -3;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-                } else if (codeList.get(0).equals(\"B\") && codeList.get(1).equals(\"8\")){\n-                    type = -3;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-                } else {\n-                   dbgLog.severe(\"unkown missing-value combination(3 values)\");\n-                }\n-                \n-            } else if (valueList.size() == 2){\n-                if (codeList.get(0).equals(\"8\") && codeList.get(1).equals(\"8\")){\n-                    type = 2;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidValues(valueList);\n-\n-                } else if (codeList.get(0).equals(\"9\")){\n-                    type = -2;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-\n-                } else if (codeList.get(0).equals(\"A\")){\n-                    type = -2;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-                } else if (codeList.get(0).equals(\"B\")){\n-                    type = -2;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-\n-                } else {\n-                    dbgLog.severe(\"unknown missing value combination(2 values)\");\n-                }\n-            } else if (valueList.size() == 1){\n-                if (codeList.get(0).equals(\"8\")){\n-                    type = 1;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidValues(valueList);\n-                } else {\n-                    dbgLog.severe(\"unknown missing value combination(2 values)\");\n-                }\n-            }\n-            invalidDataTable.put(variable, invalidDataInfo);\n+    dbgLog.fine(\"missingValueCodeTable=\" + missingValueCodeTable);\n+    Set<Map.Entry<String, List<String>>> msvlc = missingValueCodeTable.entrySet();\n+    for (Map.Entry<String, List<String>> et : msvlc) {\n+      String variable = et.getKey();\n+      dbgLog.fine(\"variable=\" + variable);\n+      List<String> codeList = et.getValue();\n+      List<String> valueList = missingValueTable.get(variable);\n+      dbgLog.fine(\"codeList=\" + codeList);\n+      dbgLog.fine(\"valueList=\" + valueList);\n+      int type;\n+      InvalidData invalidDataInfo = null;\n+      if (valueList.size() == 3) {\n+        if (codeList.get(0).equals(\"8\") && codeList.get(1).equals(\"8\") &&\n+          codeList.get(2).equals(\"8\")) {\n+          type = 3;\n+          invalidDataInfo = new InvalidData(type);\n+          invalidDataInfo.setInvalidValues(valueList);\n+        } else if (codeList.get(0).equals(\"9\") && codeList.get(1).equals(\"8\")) {\n+          type = -3;\n+\n+          invalidDataInfo = new InvalidData(type);\n+          invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n+          invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n+\n+        } else if (codeList.get(0).equals(\"A\") && codeList.get(1).equals(\"8\")) {\n+          type = -3;\n+          invalidDataInfo = new InvalidData(type);\n+          invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n+          invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n+        } else if (codeList.get(0).equals(\"B\") && codeList.get(1).equals(\"8\")) {\n+          type = -3;\n+          invalidDataInfo = new InvalidData(type);\n+          invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n+          invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n+        } else {\n+          dbgLog.severe(\"unkown missing-value combination(3 values)\");\n         }\n \n-        dbgLog.fine(\"invalidDataTable=\"+invalidDataTable);\n-\n+      } else if (valueList.size() == 2) {\n+        if (codeList.get(0).equals(\"8\") && codeList.get(1).equals(\"8\")) {\n+          type = 2;\n+          invalidDataInfo = new InvalidData(type);\n+          invalidDataInfo.setInvalidValues(valueList);\n \n-        Set<Map.Entry<String,List<String>>> msvl = missingValueTable.entrySet();\n-        for (Map.Entry<String, List<String>> et : msvl) {\n-            String variable = et.getKey();\n-            List<String> valueList = et.getValue();\n+        } else if (codeList.get(0).equals(\"9\")) {\n+          type = -2;\n+          invalidDataInfo = new InvalidData(type);\n+          invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n \n-            List<String> codeList = missingValueCodeTable.get(variable);\n+        } else if (codeList.get(0).equals(\"A\")) {\n+          type = -2;\n+          invalidDataInfo = new InvalidData(type);\n+          invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n+        } else if (codeList.get(0).equals(\"B\")) {\n+          type = -2;\n+          invalidDataInfo = new InvalidData(type);\n+          invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n \n-            dbgLog.finer(\"var=\"+variable+\"\\tvalue=\"+valueList+\"\\t code\"+ codeList);\n-            List<String> temp = new ArrayList<>();\n-            for (int j=0; j<codeList.size(); j++){\n-                if (codeList.get(j).equals(\"8\")){\n-                  temp.add(valueList.get(j));\n-                }\n-            }\n-            missingValueTable.put(variable, temp);\n+        } else {\n+          dbgLog.severe(\"unknown missing value combination(2 values)\");\n         }\n-        dbgLog.fine(\"missingValueTable=\"+missingValueTable);\n-    }\n-    \n-    \n-    \n-    // utility methods  -----------------------------------------------------//\n-    \n-    private int parseNumericField(BufferedReader reader) throws IOException{\n-        String temp = null;\n-        char[] tmp = new char[1];\n-        StringBuilder sb = new StringBuilder();\n-        while(reader.read(tmp) > 0 ){\n-            temp = Character.toString(tmp[0]);//new String(tmp);\n-            if (temp.equals(\"/\")){\n-                break;\n-            } else {\n-                sb.append(temp);\n-            }\n-            //temp = sb.toString();//new String(tmp);\n+      } else if (valueList.size() == 1) {\n+        if (codeList.get(0).equals(\"8\")) {\n+          type = 1;\n+          invalidDataInfo = new InvalidData(type);\n+          invalidDataInfo.setInvalidValues(valueList);\n+        } else {\n+          dbgLog.severe(\"unknown missing value combination(2 values)\");\n         }\n-        String base30numberString = sb.toString();\n-        dbgLog.finer(\"base30numberString=\"+base30numberString);\n-        int base10equivalent = Integer.valueOf(base30numberString, 30);\n-        dbgLog.finer(\"base10equivalent=\"+base10equivalent);\n-        return base10equivalent;\n+      }\n+      invalidDataTable.put(variable, invalidDataInfo);\n     }\n \n+    dbgLog.fine(\"invalidDataTable=\" + invalidDataTable);\n \n-    private String parseStringField(BufferedReader reader) throws IOException{\n-        String temp = null;\n-        char[] tmp = new char[1];\n-        StringBuilder sb = new StringBuilder();\n-        while(reader.read(tmp) > 0 ){\n-            temp = Character.toString(tmp[0]);//new String(tmp);\n-            if (temp.equals(\"/\")){\n-                break;\n-            } else {\n-                sb.append(temp);\n-            }\n-            //temp = sb.toString();//new String(tmp);\n-        }\n-        String base30numberString = sb.toString();\n-        //dbgLog.fine(\"base30numberString=\"+base30numberString);\n-        int base10equivalent = Integer.valueOf(base30numberString, 30);\n-        //dbgLog.fine(\"base10equivalent=\"+base10equivalent);\n-        char[] stringBody = new char[base10equivalent];\n-        reader.read(stringBody);\n-        String stringData = new String(stringBody);\n-        dbgLog.finer(\"stringData=\"+stringData);\n-        return stringData;\n-    }\n-\n-\n-\n-    private String getNumericFieldAsRawString(BufferedReader reader) throws IOException{\n-        String temp = null;\n-        char[] tmp = new char[1];\n-        StringBuilder sb = new StringBuilder();\n-        while(reader.read(tmp) > 0 ){\n-            temp = Character.toString(tmp[0]);//new String(tmp);\n-            if (temp.equals(\"/\")){\n-                break;\n-            } else {\n-                sb.append(temp);\n-            }\n-            //temp = sb.toString();//new String(tmp);\n-        }\n-        String base30numberString = sb.toString();\n-        dbgLog.finer(\"base30numberString=\"+base30numberString);\n \n-        return base30numberString;\n+    Set<Map.Entry<String, List<String>>> msvl = missingValueTable.entrySet();\n+    for (Map.Entry<String, List<String>> et : msvl) {\n+      String variable = et.getKey();\n+      List<String> valueList = et.getValue();\n+\n+      List<String> codeList = missingValueCodeTable.get(variable);\n+\n+      dbgLog.finer(\"var=\" + variable + \"\\tvalue=\" + valueList + \"\\t code\" + codeList);\n+      List<String> temp = new ArrayList<>();\n+      for (int j = 0; j < codeList.size(); j++) {\n+        if (codeList.get(j).equals(\"8\")) {\n+          temp.add(valueList.get(j));\n+        }\n+      }\n+      missingValueTable.put(variable, temp);\n+    }\n+    dbgLog.fine(\"missingValueTable=\" + missingValueTable);\n+  }\n+\n+\n+  // utility methods  -----------------------------------------------------//\n+\n+  private int parseNumericField(BufferedReader reader) throws IOException {\n+    String temp = null;\n+    char[] tmp = new char[1];\n+    StringBuilder sb = new StringBuilder();\n+    while (reader.read(tmp) > 0) {\n+      temp = Character.toString(tmp[0]);//new String(tmp);\n+      if (temp.equals(\"/\")) {\n+        break;\n+      } else {\n+        sb.append(temp);\n+      }\n+      //temp = sb.toString();//new String(tmp);\n+    }\n+    String base30numberString = sb.toString();\n+    dbgLog.finer(\"base30numberString=\" + base30numberString);\n+    int base10equivalent = Integer.valueOf(base30numberString, 30);\n+    dbgLog.finer(\"base10equivalent=\" + base10equivalent);\n+    return base10equivalent;\n+  }\n+\n+\n+  private String parseStringField(BufferedReader reader) throws IOException {\n+    String temp = null;\n+    char[] tmp = new char[1];\n+    StringBuilder sb = new StringBuilder();\n+    while (reader.read(tmp) > 0) {\n+      temp = Character.toString(tmp[0]);//new String(tmp);\n+      if (temp.equals(\"/\")) {\n+        break;\n+      } else {\n+        sb.append(temp);\n+      }\n+      //temp = sb.toString();//new String(tmp);\n     }\n+    String base30numberString = sb.toString();\n+    //dbgLog.fine(\"base30numberString=\"+base30numberString);\n+    int base10equivalent = Integer.valueOf(base30numberString, 30);\n+    //dbgLog.fine(\"base10equivalent=\"+base10equivalent);\n+    char[] stringBody = new char[base10equivalent];\n+    reader.read(stringBody);\n+    String stringData = new String(stringBody);\n+    dbgLog.finer(\"stringData=\" + stringData);\n+    return stringData;\n+  }\n+\n+\n+  private String getNumericFieldAsRawString(BufferedReader reader) throws IOException {\n+    String temp = null;\n+    char[] tmp = new char[1];\n+    StringBuilder sb = new StringBuilder();\n+    while (reader.read(tmp) > 0) {\n+      temp = Character.toString(tmp[0]);//new String(tmp);\n+      if (temp.equals(\"/\")) {\n+        break;\n+      } else {\n+        sb.append(temp);\n+      }\n+      //temp = sb.toString();//new String(tmp);\n+    }\n+    String base30numberString = sb.toString();\n+    dbgLog.finer(\"base30numberString=\" + base30numberString);\n \n+    return base30numberString;\n+  }\n \n-    private double base30Tobase10Conversion(String base30String){\n \n-        // new base(radix) number\n-        int oldBase = 30;\n-        //dbgLog.fine(\"base30String=\"+base30String);\n+  private double base30Tobase10Conversion(String base30String) {\n \n-        // trim white-spaces from the both ends\n-        String base30StringClean = StringUtils.trim(base30String);\n-        //dbgLog.fine(\"base30StringClean=\"+base30StringClean);\n+    // new base(radix) number\n+    int oldBase = 30;\n+    //dbgLog.fine(\"base30String=\"+base30String);\n \n-        // check the negative/positive sign\n-        boolean isNegativeNumber = false;\n-        boolean hasPositiveSign = false;\n-        if (base30StringClean.startsWith(\"-\")){\n-            isNegativeNumber = true;\n-        }\n+    // trim white-spaces from the both ends\n+    String base30StringClean = StringUtils.trim(base30String);\n+    //dbgLog.fine(\"base30StringClean=\"+base30StringClean);\n \n-        if (base30StringClean.startsWith(\"+\")){\n-            hasPositiveSign = true;\n-        }\n+    // check the negative/positive sign\n+    boolean isNegativeNumber = false;\n+    boolean hasPositiveSign = false;\n+    if (base30StringClean.startsWith(\"-\")) {\n+      isNegativeNumber = true;\n+    }\n \n-        // remove the sign if exits\n-        String base30StringNoSign = null;\n+    if (base30StringClean.startsWith(\"+\")) {\n+      hasPositiveSign = true;\n+    }\n \n-        if ((isNegativeNumber) ||(hasPositiveSign)){\n-            base30StringNoSign = base30StringClean.substring(1);\n-        } else {\n-            base30StringNoSign = base30StringClean;\n-        }\n+    // remove the sign if exits\n+    String base30StringNoSign = null;\n \n-        // check the scientific notation\n-        // if so, divide it into the significand and exponent\n-        String significand  = null;\n-        long exponent = 0;\n+    if ((isNegativeNumber) || (hasPositiveSign)) {\n+      base30StringNoSign = base30StringClean.substring(1);\n+    } else {\n+      base30StringNoSign = base30StringClean;\n+    }\n \n-        int plusIndex = base30StringNoSign.indexOf(\"+\");\n-        int minusIndex = base30StringNoSign.indexOf(\"-\");\n+    // check the scientific notation\n+    // if so, divide it into the significand and exponent\n+    String significand = null;\n+    long exponent = 0;\n \n-        if (plusIndex> 0){\n-            significand = base30StringNoSign.substring(0, plusIndex);\n-            exponent = Long.valueOf( base30StringNoSign.substring(plusIndex+1), oldBase );\n+    int plusIndex = base30StringNoSign.indexOf(\"+\");\n+    int minusIndex = base30StringNoSign.indexOf(\"-\");\n \n-        } else if (minusIndex > 0){\n-            significand = base30StringNoSign.substring(0, minusIndex);\n-            exponent = -1 * Long.valueOf( base30StringNoSign.substring(minusIndex+1), oldBase );\n+    if (plusIndex > 0) {\n+      significand = base30StringNoSign.substring(0, plusIndex);\n+      exponent = Long.valueOf(base30StringNoSign.substring(plusIndex + 1), oldBase);\n \n-        } else {\n-            significand = base30StringNoSign;\n-        }\n+    } else if (minusIndex > 0) {\n+      significand = base30StringNoSign.substring(0, minusIndex);\n+      exponent = -1 * Long.valueOf(base30StringNoSign.substring(minusIndex + 1), oldBase);\n \n+    } else {\n+      significand = base30StringNoSign;\n+    }\n \n-        // \"move\" decimal point; for each shift right, subtract one from exponent; end result is a string with no decimal\n-        int decimalIndex = significand.indexOf(\".\");\n-        if (decimalIndex != -1) {\n-            exponent -= (significand.length() - (decimalIndex + 1) );\n-            significand = significand.substring(0, decimalIndex) + significand.substring( decimalIndex + 1 );\n-        }\n \n-        // TODO: Verify that the MathContext/Rounding methods are OK:\n-        // -- L.A. 4.0 beta\n-        MathContext mc = new MathContext(15,RoundingMode.HALF_UP);\n-        long base10Significand = Long.parseLong(significand, oldBase);\n-        BigDecimal base10value = new BigDecimal( String.valueOf(base10Significand), mc );\n-        BigDecimal exponentialComponent = new BigDecimal(\"1\", mc);\n+    // \"move\" decimal point; for each shift right, subtract one from exponent; end result is a string with no decimal\n+    int decimalIndex = significand.indexOf(\".\");\n+    if (decimalIndex != -1) {\n+      exponent -= (significand.length() - (decimalIndex + 1));\n+      significand = significand.substring(0, decimalIndex) + significand.substring(decimalIndex + 1);\n+    }\n \n-        for (int g=0; g < Math.abs(exponent); g++) {\n-            exponentialComponent = exponentialComponent.multiply(new BigDecimal(\"30\", mc));\n-        }\n+    // TODO: Verify that the MathContext/Rounding methods are OK:\n+    // -- L.A. 4.0 beta\n+    MathContext mc = new MathContext(15, RoundingMode.HALF_UP);\n+    long base10Significand = Long.parseLong(significand, oldBase);\n+    BigDecimal base10value = new BigDecimal(String.valueOf(base10Significand), mc);\n+    BigDecimal exponentialComponent = new BigDecimal(\"1\", mc);\n \n-        if (exponent >= 0) {\n-            base10value = base10value.multiply(exponentialComponent, mc);\n-        } else {\n-            base10value = base10value.divide(exponentialComponent, mc);\n-        }\n+    for (int g = 0; g < Math.abs(exponent); g++) {\n+      exponentialComponent = exponentialComponent.multiply(new BigDecimal(\"30\", mc));\n+    }\n \n-        // negative sign if applicable\n-        if (isNegativeNumber){\n-            base10value = base10value.multiply(new BigDecimal(\"-1\", mc));\n-        }\n+    if (exponent >= 0) {\n+      base10value = base10value.multiply(exponentialComponent, mc);\n+    } else {\n+      base10value = base10value.divide(exponentialComponent, mc);\n+    }\n \n-        return base10value.doubleValue();\n+    // negative sign if applicable\n+    if (isNegativeNumber) {\n+      base10value = base10value.multiply(new BigDecimal(\"-1\", mc));\n     }\n-    \n-    void assignValueLabels(Map<String, Map<String, String>> valueLabelTable) {\n-        // Let's go through all the categorical value label mappings and \n-        // assign them to the correct variables: \n-        \n-        for (DataVariable dataVariable : dataTable.getDataVariables()) {\n-            String varName = dataVariable.getName();\n-            \n-            Map<String, String> valueLabelPairs = valueLabelTable.get(valueVariableMappingTable.get(varName));\n-            if (valueLabelPairs != null && !valueLabelPairs.isEmpty()) {\n-                for (String value : valueLabelPairs.keySet()) {\n-                    \n-                    VariableCategory cat = new VariableCategory();\n-                    cat.setValue(value);\n-                    cat.setLabel(valueLabelPairs.get(value));\n-\n-                    /* cross-link the variable and category to each other: */\n-                    cat.setDataVariable(dataVariable);\n-                    dataVariable.getCategories().add(cat);\n-                }\n-            }\n+\n+    return base10value.doubleValue();\n+  }\n+\n+  void assignValueLabels(Map<String, Map<String, String>> valueLabelTable) {\n+    // Let's go through all the categorical value label mappings and\n+    // assign them to the correct variables:\n+\n+    for (DataVariable dataVariable : dataTable.getDataVariables()) {\n+      String varName = dataVariable.getName();\n+\n+      Map<String, String> valueLabelPairs = valueLabelTable.get(valueVariableMappingTable.get(varName));\n+      if (valueLabelPairs != null && !valueLabelPairs.isEmpty()) {\n+        for (String value : valueLabelPairs.keySet()) {\n+\n+          VariableCategory cat = new VariableCategory();\n+          cat.setValue(value);\n+          cat.setLabel(valueLabelPairs.get(value));\n+\n+          /* cross-link the variable and category to each other: */\n+          cat.setDataVariable(dataVariable);\n+          dataVariable.getCategories().add(cat);\n         }\n+      }\n     }\n-    \n-    private void print2Darray(Object[][] datatable, String title){\n-        dbgLog.fine(title);\n-        for (Object[] datatable1 : datatable) {\n-            dbgLog.fine(StringUtils.join(datatable1, \"|\"));\n-        }\n-    }    \n-    \n-    private Map<String,String> createLabelMap (File extendedLabelsFile) {\n-        Map<String,String> varLabelMap = new HashMap<>();\n+  }\n \n-        // Simply open the text file supplied, and read the variable-lable                                                                   \n-        // pairs supplied:                                                                                                                   \n+  private void print2Darray(Object[][] datatable, String title) {\n+    dbgLog.fine(title);\n+    for (Object[] datatable1 : datatable) {\n+      dbgLog.fine(StringUtils.join(datatable1, \"|\"));\n+    }\n+  }\n \n-        BufferedReader labelsFileReader = null;\n+  private Map<String, String> createLabelMap(File extendedLabelsFile) {\n+    Map<String, String> varLabelMap = new HashMap<>();\n \n-        try {\n-            labelsFileReader = new BufferedReader(new InputStreamReader(new FileInputStream(extendedLabelsFile)));\n+    // Simply open the text file supplied, and read the variable-lable\n+    // pairs supplied:\n \n-            String inLine;\n+    BufferedReader labelsFileReader = null;\n \n-            while ((inLine = labelsFileReader.readLine() ) != null) {\n-                String[] valueTokens = inLine.split(\"\\t\", 2);\n+    try {\n+      labelsFileReader = new BufferedReader(new InputStreamReader(new FileInputStream(extendedLabelsFile)));\n \n-                if (valueTokens[0] != null && !\"\".equals(valueTokens[0]) &&\n-                    valueTokens[1] != null && !\"\".equals(valueTokens[1])) {\n+      String inLine;\n \n-                    valueTokens[1] = valueTokens[1].replaceAll(\"[\\n\\r]\", \"\");\n-                    // A very temporary fix for the varstr limit in the database!\n-                    // -- L.A. 4.0 beta 11\n-                    // TODO: change the label field to \"text\" by beta 12!!\n-                    if (valueTokens[1].length() > 255) {\n-                        valueTokens[1] = valueTokens[1].substring(0, 255);\n-                    }\n-                    varLabelMap.put(valueTokens[0], valueTokens[1]);\n-                }\n-            }\n+      while ((inLine = labelsFileReader.readLine()) != null) {\n+        String[] valueTokens = inLine.split(\"\\t\", 2);\n \n-        } catch (java.io.FileNotFoundException fnfex) {\n-            dbgLog.warning(\"Ingest: could not open Extended Labels file\");\n-            dbgLog.warning(fnfex.getMessage());\n-            return null;\n-        } catch (IOException ioex) {\n-            dbgLog.warning(\"Ingest: caught exception trying to process Labels File\");\n-            dbgLog.warning(ioex.getMessage());\n-            return null;\n-        } finally {\n-            if (labelsFileReader != null) {\n-                try {labelsFileReader.close();}catch(Exception x){};\n-            }\n+        if (valueTokens[0] != null && !\"\".equals(valueTokens[0]) &&\n+          valueTokens[1] != null && !\"\".equals(valueTokens[1])) {\n+\n+          valueTokens[1] = valueTokens[1].replaceAll(\"[\\n\\r]\", \"\");\n+          // A very temporary fix for the varstr limit in the database!\n+          // -- L.A. 4.0 beta 11\n+          // TODO: change the label field to \"text\" by beta 12!!\n+          if (valueTokens[1].length() > 255) {\n+            valueTokens[1] = valueTokens[1].substring(0, 255);\n+          }\n+          varLabelMap.put(valueTokens[0], valueTokens[1]);\n         }\n+      }\n \n-        return varLabelMap;\n+    } catch (java.io.FileNotFoundException fnfex) {\n+      dbgLog.warning(\"Ingest: could not open Extended Labels file\");\n+      dbgLog.warning(fnfex.getMessage());\n+      return null;\n+    } catch (IOException ioex) {\n+      dbgLog.warning(\"Ingest: caught exception trying to process Labels File\");\n+      dbgLog.warning(ioex.getMessage());\n+      return null;\n+    } finally {\n+      if (labelsFileReader != null) {\n+        try {\n+          labelsFileReader.close();\n+        } catch (Exception x) {\n+        }\n+        ;\n+      }\n     }\n \n-    \n+    return varLabelMap;\n+  }\n+\n+\n }\n \n",
            "diff_size": 2368
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/2/PORFileReader.java\nindex c90b0ea6950..28a2f4df56d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/2/PORFileReader.java\n@@ -31,7 +31,6 @@ import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.io.Writer;\n import java.nio.ByteBuffer;\n-\n import java.text.DecimalFormat;\n import java.text.NumberFormat;\n import java.text.SimpleDateFormat;\n@@ -54,15 +53,12 @@ import java.math.MathContext;\n import java.math.RoundingMode;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-\n import org.apache.commons.codec.binary.Hex;\n import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.StringUtils;\n-\n import edu.harvard.iq.dataverse.DataTable;\n import edu.harvard.iq.dataverse.datavariable.DataVariable;\n import edu.harvard.iq.dataverse.datavariable.VariableCategory;\n-\n import edu.harvard.iq.dataverse.ingest.tabulardata.TabularDataFileReader;\n import edu.harvard.iq.dataverse.ingest.tabulardata.spi.TabularDataFileReaderSpi;\n import edu.harvard.iq.dataverse.ingest.tabulardata.TabularDataIngest;\n@@ -82,22 +78,23 @@ import edu.harvard.iq.dataverse.ingest.tabulardata.impl.plugins.sav.SPSSConstant\n  * @author Leonid Andreev\n  */\n \n-public class PORFileReader  extends TabularDataFileReader{\n+\n+public class PORFileReader extends TabularDataFileReader {\n     // static fields ---------------------------------------------------------//\n-    private static final String MissingValueForTextDataFile = \"\";\n \n+    private static final String MissingValueForTextDataFile = \"\";\n     private TabularDataIngest ingesteddata = new TabularDataIngest();\n-    private DataTable dataTable = new DataTable(); \n-    \n-    private static final int POR_HEADER_SIZE = 500;   \n+    private DataTable dataTable = new DataTable();\n+    private static final int POR_HEADER_SIZE = 500;\n     private static final int POR_MARK_POSITION_DEFAULT = 461;\n     private static final String POR_MARK = \"SPSSPORT\";\n     private static final int LENGTH_SECTION_HEADER = 1;\n-    private static final int LENGTH_SECTION_2 = 19;        \n+    private static final int LENGTH_SECTION_2 = 19;\n     private static final String MIME_TYPE = \"application/x-spss-por\";\n     private static Pattern pattern4positiveInteger = Pattern.compile(\"[0-9A-T]+\");\n     private static Pattern pattern4Integer = Pattern.compile(\"[-]?[0-9A-T]+\");\n     private static Calendar GCO = new GregorianCalendar();\n+\n     static {\n         // set the origin of GCO to 1582-10-15\n         GCO.set(1, 1582);// year\n@@ -109,22 +106,19 @@ public class PORFileReader  extends TabularDataFileReader{\n         GCO.set(13, 0);// ss\n         GCO.set(14, 0); // SS millisecond\n         GCO.set(15, 0);// z\n-        \n     }\n-    private static final long SPSS_DATE_BIAS = 60*60*24*1000;\n+\n+\n+    private static final long SPSS_DATE_BIAS = 60 * 60 * 24 * 1000;\n     private static final long SPSS_DATE_OFFSET = SPSS_DATE_BIAS + Math.abs(GCO.getTimeInMillis());\n     \n \n     // instance fields -------------------------------------------------------//\n-\n     private static Logger dbgLog = Logger.getLogger(PORFileReader.class.getPackage().getName());\n-\n     private boolean isCurrentVariableString = false;\n     private String currentVariableName = null;\n-\n-    private int caseQnty=0;\n-    private int varQnty=0;\n-\n+    private int caseQnty = 0;\n+    private int varQnty = 0;\n     private Map<String, Integer> variableTypeTable = new LinkedHashMap<>();\n     private List<Integer> variableTypelList = new ArrayList<>();\n     private List<Integer> printFormatList = new ArrayList<>();\n@@ -142,124 +136,103 @@ public class PORFileReader  extends TabularDataFileReader{\n     private Map<String, List<String>> missingValueCodeTable = new LinkedHashMap<>();\n     private Map<String, InvalidData> invalidDataTable = new LinkedHashMap<>();\n     private Set<Integer> decimalVariableSet = new HashSet<>();\n-    private List<Integer> formatDecimalPointPositionList= new ArrayList<>();\n+    private List<Integer> formatDecimalPointPositionList = new ArrayList<>();\n \n \n \n     // date/time data format\n-    private SimpleDateFormat sdf_ymd    = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    private SimpleDateFormat sdf_ymd = new SimpleDateFormat(\"yyyy-MM-dd\");\n     private SimpleDateFormat sdf_ymdhms = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n-    private SimpleDateFormat sdf_dhms   = new SimpleDateFormat(\"DDD HH:mm:ss\");\n-    private SimpleDateFormat sdf_hms    = new SimpleDateFormat(\"HH:mm:ss\");\n+    private SimpleDateFormat sdf_dhms = new SimpleDateFormat(\"DDD HH:mm:ss\");\n+    private SimpleDateFormat sdf_hms = new SimpleDateFormat(\"HH:mm:ss\");\n \n     // DecimalFormat for doubles\n     // may need more setXXXX() to handle scientific data\n     private NumberFormat doubleNumberFormatter = new DecimalFormat();\n-\n     private String[] variableFormatTypeList;\n     private String[] dateFormatList;\n-\n-    private Map<String,String> extendedLabels;\n+    private Map<String, String> extendedLabels;\n \n     // Constructor -----------------------------------------------------------//\n \n-    public PORFileReader(TabularDataFileReaderSpi originator){\n+    public PORFileReader(TabularDataFileReaderSpi originator) {\n         super(originator);\n     }\n \n-    \n     private void init() throws IOException {\n-        \n         sdf_ymd.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n         sdf_ymdhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n         sdf_dhms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n         sdf_hms.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-    \n         doubleNumberFormatter.setGroupingUsed(false);\n         doubleNumberFormatter.setMaximumFractionDigits(340); // TODO: 340?? -- L.A. 4.0 beta\n     }\n-    \n+\n     @Override\n-    public TabularDataIngest read(BufferedInputStream stream, File additionalData) throws IOException{\n+    public TabularDataIngest read(BufferedInputStream stream, File additionalData) throws IOException {\n         dbgLog.fine(\"PORFileReader: read() start\");\n-        \n         if (additionalData != null) {\n             //throw new IOException (\"this plugin does not support external raw data files\");\n-            dbgLog.fine(\"Using extended variable labels from file \"+additionalData.getName());\n-            \n+            dbgLog.fine(\"Using extended variable labels from file \" + additionalData.getName());\n             extendedLabels = createLabelMap(additionalData);\n         }\n-        \n-        \n+\n         File tempPORfile = decodeHeader(stream);\n         BufferedReader bfReader = null;\n-        \n-        try {            \n+        try {\n             bfReader = new BufferedReader(new InputStreamReader(new FileInputStream(tempPORfile.getAbsolutePath()), \"US-ASCII\"));\n-            if (bfReader == null){\n+            if (bfReader == null) {\n                 dbgLog.fine(\"bfReader is null\");\n                 throw new IOException(\"bufferedReader is null\");\n             }\n-            \n             decodeSec2(bfReader);\n-            \n-            while(true){\n-\n+            while (true) {\n                 char[] header = new char[LENGTH_SECTION_HEADER]; // 1 byte\n                 bfReader.read(header);\n                 String headerId = Character.toString(header[0]);\n-                \n-                dbgLog.fine(\"////////////////////// headerId=\"+headerId+ \"//////////////////////\");\n-                \n-                if (headerId.equals(\"Z\")){\n+                dbgLog.fine(\"////////////////////// headerId=\" + headerId + \"//////////////////////\");\n+                if (headerId.equals(\"Z\")) {\n                     throw new IOException(\"reading failure: wrong headerId(Z) here\");\n                 }\n-                \n+\n                 if (headerId.equals(\"F\")) {\n                     // missing value\n-                    if ((missingValueTable !=null) && (missingValueTable.size()>0)){\n+                    if ((missingValueTable != null) && (missingValueTable.size() > 0)) {\n                         processMissingValueData();\n                     }\n                 }\n-                                \n-                if (headerId.equals(\"8\") && isCurrentVariableString){\n+\n+                if (headerId.equals(\"8\") && isCurrentVariableString) {\n                     headerId = \"8S\";\n                 }\n-\n                 decode(headerId, bfReader);\n \n                 \n                 // for last iteration\n-                if (headerId.equals(\"F\")){\n+                if (headerId.equals(\"F\")) {\n                     // finished the last block (F == data) \n                     // without reaching the end of this file.\n                     break;\n                 }\n             }\n-            \n-                    \n         } finally {\n             try {\n-                if (bfReader!= null){\n+                if (bfReader != null) {\n                     bfReader.close();\n                 }\n-            } catch (IOException ex){\n+            } catch (IOException ex) {\n                 ex.printStackTrace();\n             }\n \n-            if (tempPORfile.exists()){\n+            if (tempPORfile.exists()) {\n                 tempPORfile.delete();\n             }\n         }\n-        \n         dbgLog.fine(\"done parsing headers and decoding;\");\n-\n         List<DataVariable> variableList = new ArrayList<>();\n-        \n         for (int indx = 0; indx < variableTypelList.size(); indx++) {\n-            \n             DataVariable dv = new DataVariable(indx, dataTable);\n-            String varName = variableNameList.get(indx); \n+            String varName = variableNameList.get(indx);\n             dv.setName(varName);\n             String varLabel = variableLabelMap.get(varName);\n             if (varLabel != null && varLabel.length() > 255) {\n@@ -269,14 +242,14 @@ public class PORFileReader  extends TabularDataFileReader{\n             // labels? is that enough to store whatever they have \n             // in their POR files at ODUM?\n             // -- L.A. 4.0, beta11\n+\n             if (extendedLabels != null && extendedLabels.get(varName) != null) {\n                 dv.setLabel(extendedLabels.get(varName));\n             } else {\n                 dv.setLabel(varLabel);\n             }\n-            \n-            variableList.add(dv);            \n-            \n+            variableList.add(dv);\n+\n             int simpleType = 0;\n             if (variableTypelList.get(indx) != null) {\n                 simpleType = variableTypelList.get(indx);\n@@ -292,28 +265,22 @@ public class PORFileReader  extends TabularDataFileReader{\n                 // (see the setFormatCategory below... but double-check!)\n                 // -- L.A. 4.0 alpha\n                 String variableFormatType = variableFormatTypeList[indx];\n-                \n                 if (variableFormatType != null) {\n-                    if (variableFormatType.equals(\"time\")\n-                        || variableFormatType.equals(\"date\")) {\n-                        simpleType = 1; \n-                    \n+                    if (variableFormatType.equals(\"time\") || variableFormatType.equals(\"date\")) {\n+                        simpleType = 1;\n                         String formatCategory = formatCategoryTable.get(varName);\n-\n                         if (formatCategory != null) {\n                             if (dateFormatList[indx] != null) {\n-                                dbgLog.fine(\"setting format category to \"+formatCategory);\n+                                dbgLog.fine(\"setting format category to \" + formatCategory);\n                                 variableList.get(indx).setFormatCategory(formatCategory);\n-                                dbgLog.fine(\"setting formatschemaname to \"+dateFormatList[indx]);\n+                                dbgLog.fine(\"setting formatschemaname to \" + dateFormatList[indx]);\n                                 variableList.get(indx).setFormat(dateFormatList[indx]);\n                             }\n                         }\n                     } else if (variableFormatType.equals(\"other\")) {\n                         dbgLog.fine(\"Variable of format type \\\"other\\\"; type adjustment may be needed\");\n-                        dbgLog.fine(\"SPSS print format: \"+printFormatTable.get(variableList.get(indx).getName()));\n-                        \n-                        if (printFormatTable.get(variableList.get(indx).getName()).equals(\"WKDAY\")\n-                            || printFormatTable.get(variableList.get(indx).getName()).equals(\"MONTH\")) {\n+                        dbgLog.fine(\"SPSS print format: \" + printFormatTable.get(variableList.get(indx).getName()));\n+                        if (printFormatTable.get(variableList.get(indx).getName()).equals(\"WKDAY\") || printFormatTable.get(variableList.get(indx).getName()).equals(\"MONTH\")) {\n                             // week day or month; \n                             // These are not treated as time/date values (meaning, we \n                             // don't define time/date formats for them; there's likely \n@@ -323,18 +290,14 @@ public class PORFileReader  extends TabularDataFileReader{\n                             // and not as numerics - as they were stored in the \n                             // SAV file. So we need to adjust the type here.\n                             // -- L.A. \n-                            \n                             simpleType = 1;\n                         }\n                     }\n                 }\n-                \n             }\n-            \n-            dbgLog.fine(\"Finished creating variable \"+indx+\", \"+varName);\n+            dbgLog.fine(\"Finished creating variable \" + indx + \", \" + varName);\n             \n             // OK, we can now assign the types: \n-            \n             if (simpleType > 0) {\n                 // String: \n                 variableList.get(indx).setTypeCharacter();\n@@ -344,18 +307,14 @@ public class PORFileReader  extends TabularDataFileReader{\n                 variableList.get(indx).setTypeNumeric();\n                 // discrete or continuous?\n                 // \"decimal variables\" become dataverse data variables of interval type \"continuous\":\n-        \n                 if (decimalVariableSet.contains(indx)) {\n                     variableList.get(indx).setIntervalContinuous();\n                 } else {\n                     variableList.get(indx).setIntervalDiscrete();\n                 }\n-                \n             }\n             dbgLog.fine(\"Finished configuring variable type information.\");\n         }\n-        \n-        \n         dbgLog.fine(\"done configuring variables;\");\n         \n         /* \n@@ -369,67 +328,76 @@ public class PORFileReader  extends TabularDataFileReader{\n          * double-check that it's all being taken care of by the new plugin!\n          * (for variable format and formatName, consult the SAV plugin)\n          */\n-        \n         dataTable.setDataVariables(variableList);\n         \n         // Assign value labels: \n-        \n         assignValueLabels(valueLabelTable);\n-        \n         ingesteddata.setDataTable(dataTable);\n-        \n         dbgLog.info(\"PORFileReader: read() end\");\n         return ingesteddata;\n     }\n-    \n-    private void decode(String headerId, BufferedReader reader) throws IOException{\n-        if (headerId.equals(\"1\")) decodeProductName(reader);\n-        else if (headerId.equals(\"2\")) decodeLicensee(reader);\n-        else if (headerId.equals(\"3\")) decodeFileLabel(reader);\n-        else if (headerId.equals(\"4\")) decodeNumberOfVariables(reader);\n-        else if (headerId.equals(\"5\")) decodeFieldNo5(reader);\n-        else if (headerId.equals(\"6\")) decodeWeightVariable(reader);\n-        else if (headerId.equals(\"7\")) decodeVariableInformation(reader);\n-        else if (headerId.equals(\"8\")) decodeMissValuePointNumeric(reader);\n-        else if (headerId.equals(\"8S\")) decodeMissValuePointString(reader);\n-        else if (headerId.equals(\"9\")) decodeMissValueRangeLow(reader);\n-        else if (headerId.equals(\"A\")) decodeMissValueRangeHigh(reader);\n-        else if (headerId.equals(\"B\")) decodeMissValueRange(reader);\n-        else if (headerId.equals(\"C\")) decodeVariableLabel(reader);\n-        else if (headerId.equals(\"D\")) decodeValueLabel(reader);\n-        else if (headerId.equals(\"E\")) decodeDocument(reader);\n+\n+    private void decode(String headerId, BufferedReader reader) throws IOException {\n+        if (headerId.equals(\"1\"))\n+            decodeProductName(reader);\n+        else if (headerId.equals(\"2\"))\n+            decodeLicensee(reader);\n+        else if (headerId.equals(\"3\"))\n+            decodeFileLabel(reader);\n+        else if (headerId.equals(\"4\"))\n+            decodeNumberOfVariables(reader);\n+        else if (headerId.equals(\"5\"))\n+            decodeFieldNo5(reader);\n+        else if (headerId.equals(\"6\"))\n+            decodeWeightVariable(reader);\n+        else if (headerId.equals(\"7\"))\n+            decodeVariableInformation(reader);\n+        else if (headerId.equals(\"8\"))\n+            decodeMissValuePointNumeric(reader);\n+        else if (headerId.equals(\"8S\"))\n+            decodeMissValuePointString(reader);\n+        else if (headerId.equals(\"9\"))\n+            decodeMissValueRangeLow(reader);\n+        else if (headerId.equals(\"A\"))\n+            decodeMissValueRangeHigh(reader);\n+        else if (headerId.equals(\"B\"))\n+            decodeMissValueRange(reader);\n+        else if (headerId.equals(\"C\"))\n+            decodeVariableLabel(reader);\n+        else if (headerId.equals(\"D\"))\n+            decodeValueLabel(reader);\n+        else if (headerId.equals(\"E\"))\n+            decodeDocument(reader);\n         else if (headerId.equals(\"F\")) decodeData(reader);\n     }\n-    \n \n     private File decodeHeader(BufferedInputStream stream) throws IOException {\n         dbgLog.fine(\"decodeHeader(): start\");\n         File tempPORfile = null;\n-\n-        if (stream  == null){\n+        if (stream == null) {\n             throw new IllegalArgumentException(\"file == null!\");\n         }\n-        \n-        byte[] headerByes = new byte[POR_HEADER_SIZE];\n \n-        if (stream.markSupported()){\n+        byte[] headerByes = new byte[POR_HEADER_SIZE];\n+        if (stream.markSupported()) {\n             stream.mark(1000);\n         }\n+\n         int nbytes = stream.read(headerByes, 0, POR_HEADER_SIZE);\n \n         //printHexDump(headerByes, \"hex dump of the byte-array\");\n-\n-        if (nbytes == 0){\n+        if (nbytes == 0) {\n             throw new IOException(\"decodeHeader: reading failure\");\n-        } else if ( nbytes < 491) {\n+        } else if (nbytes < 491) {\n            // Size test: by defnition, it must have at least\n             // 491-byte header, i.e., the file size less than this threshold\n             // is not a POR file\n-           dbgLog.fine(\"this file is NOT spss-por type\");\n-           throw new IllegalArgumentException(\"file is not spss-por type\");\n+            dbgLog.fine(\"this file is NOT spss-por type\");\n+            throw new IllegalArgumentException(\"file is not spss-por type\");\n         }\n         // rewind the current reading position back to the beginning\n-        if (stream.markSupported()){\n+\n+        if (stream.markSupported()) {\n             stream.reset();\n         }\n \n@@ -454,7 +422,7 @@ public class PORFileReader  extends TabularDataFileReader{\n         //           : [0D0D0A] : [82], [165], [248], [331], [414], [495]\n         \n         // convert b into a ByteBuffer\n-        \n+\n         ByteBuffer buff = ByteBuffer.wrap(headerByes);\n         byte[] nlch = new byte[36];\n         int pos1;\n@@ -472,9 +440,9 @@ public class PORFileReader  extends TabularDataFileReader{\n             pos1 = baseBias + i;\n             buff.position(pos1);\n             dbgLog.finer(\"\\tposition(1)=\" + buff.position());\n+\n             int j = 6 * i;\n             nlch[j] = buff.get();\n-\n             if (nlch[j] == 10) {\n                 ucase++;\n             } else if (nlch[j] == 13) {\n@@ -485,7 +453,6 @@ public class PORFileReader  extends TabularDataFileReader{\n             pos2 = baseBias + 2 * i;\n             buff.position(pos2);\n             dbgLog.finer(\"\\tposition(2)=\" + buff.position());\n-            \n             nlch[j + 1] = buff.get();\n             nlch[j + 2] = buff.get();\n \n@@ -493,40 +460,31 @@ public class PORFileReader  extends TabularDataFileReader{\n             pos3 = baseBias + 3 * i;\n             buff.position(pos3);\n             dbgLog.finer(\"\\tposition(3)=\" + buff.position());\n-            \n             nlch[j + 3] = buff.get();\n             nlch[j + 4] = buff.get();\n             nlch[j + 5] = buff.get();\n-\n-            dbgLog.finer(i + \"-th iteration position =\" +\n-                    nlch[j] + \"\\t\" + nlch[j + 1] + \"\\t\" + nlch[j + 2]);\n-            dbgLog.finer(i + \"-th iteration position =\" +\n-                    nlch[j + 3] + \"\\t\" + nlch[j + 4] + \"\\t\" + nlch[j + 5]);\n-            \n-            if ((nlch[j + 3] == 13) &&\n-                (nlch[j + 4] == 13) &&\n-                (nlch[j + 5] == 10)) {\n+            dbgLog.finer(i + \"-th iteration position =\" + nlch[j] + \"\\t\" + nlch[j + 1] + \"\\t\" + nlch[j + 2]);\n+            dbgLog.finer(i + \"-th iteration position =\" + nlch[j + 3] + \"\\t\" + nlch[j + 4] + \"\\t\" + nlch[j + 5]);\n+            if ((nlch[j + 3] == 13) && (nlch[j + 4] == 13) && (nlch[j + 5] == 10)) {\n                 three++;\n             } else if ((nlch[j + 1] == 13) && (nlch[j + 2] == 10)) {\n                 wcase++;\n             }\n-\n             buff.rewind();\n         }\n-        \n+\n         boolean windowsNewLine = true;\n         if (three == nolines) {\n             windowsNewLine = false; // lineTerminator = \"0D0D0A\"\n         } else if ((ucase == nolines) && (wcase < nolines)) {\n             windowsNewLine = false; // lineTerminator = \"0A\"\n         } else if ((ucase < nolines) && (wcase == nolines)) {\n-            windowsNewLine = true; //lineTerminator = \"0D0A\"\n-        } else if ((mcase == nolines) && (wcase < nolines)) {\n-            windowsNewLine = false; //lineTerminator = \"0D\"\n-        }\n-\n-\n+                   windowsNewLine = true; //lineTerminator = \"0D0A\"\n+               } else if ((mcase == nolines) && (wcase < nolines)) {\n+                   windowsNewLine = false; //lineTerminator = \"0D\"\n+               }\n         buff.rewind();\n+\n         int PORmarkPosition = POR_MARK_POSITION_DEFAULT;\n         if (windowsNewLine) {\n             PORmarkPosition = PORmarkPosition + 5;\n@@ -540,20 +498,15 @@ public class PORFileReader  extends TabularDataFileReader{\n         String pormarks = new String(pormark);\n \n         //dbgLog.fine(\"pormark =>\" + pormarks + \"<-\");\n-        dbgLog.fine(\"pormark[hex: 53 50 53 53 50 4F 52 54 == SPSSPORT] =>\" +\n-                new String(Hex.encodeHex(pormark)) + \"<-\");\n-\n+        dbgLog.fine(\"pormark[hex: 53 50 53 53 50 4F 52 54 == SPSSPORT] =>\" + new String(Hex.encodeHex(pormark)) + \"<-\");\n         if (pormarks.equals(POR_MARK)) {\n             dbgLog.fine(\"POR ID toke test: Passed\");\n             init();\n-                        \n             dataTable.setOriginalFileFormat(MIME_TYPE);\n             dataTable.setUnf(\"UNF:6:NOTCALCULATED\");\n-\n         } else {\n             dbgLog.fine(\"this file is NOT spss-por type\");\n-            throw new IllegalArgumentException(\n-                \"decodeHeader: POR ID token was not found\");\n+            throw new IllegalArgumentException(\"decodeHeader: POR ID token was not found\");\n         }\n \n         // save the POR file without new line characters\n@@ -563,7 +516,6 @@ public class PORFileReader  extends TabularDataFileReader{\n \n         // Scanner class can handle three-character line-terminator\n         Scanner porScanner = null;\n-        \n         try {\n             tempPORfile = File.createTempFile(\"tempPORfile.\", \".por\");\n             fileOutPOR = new FileOutputStream(tempPORfile);\n@@ -574,38 +526,35 @@ public class PORFileReader  extends TabularDataFileReader{\n             // sequence differently, the first 5 leader lines are skipped from\n             // the new-line-stripped file\n \n-            int lineCounter= 0;\n-            while(porScanner.hasNextLine()){\n+            int lineCounter = 0;\n+            while (porScanner.hasNextLine()) {\n                 lineCounter++;\n-                if (lineCounter<=5){\n+                if (lineCounter <= 5) {\n                     String line = porScanner.nextLine();\n-                    dbgLog.fine(\"line=\"+lineCounter+\":\"+line.length()+\":\"+line);\n+                    dbgLog.fine(\"line=\" + lineCounter + \":\" + line.length() + \":\" + line);\n                 } else {\n                     fileWriter.write(porScanner.nextLine());\n                 }\n             }\n         } finally {\n-            try{\n-                if (fileWriter != null){\n+            try {\n+                if (fileWriter != null) {\n                     fileWriter.close();\n                 }\n-            } catch (IOException ex){\n+            } catch (IOException ex) {\n                 ex.printStackTrace();\n             }\n \n-            if (porScanner != null){\n+            if (porScanner != null) {\n                 porScanner.close();\n             }\n         }\n-\n         return tempPORfile;\n     }\n \n-\n-\n     private void decodeSec2(BufferedReader reader) throws IOException {\n         dbgLog.fine(\"decodeSec2(): start\");\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeSec2: stream == null!\");\n         }\n \n@@ -616,21 +565,19 @@ public class PORFileReader  extends TabularDataFileReader{\n         // somewhere in it.\n \n         // mark the start position for the later rewind\n-        if (reader.markSupported()){\n+\n+        if (reader.markSupported()) {\n             reader.mark(100000);\n         }\n \n-\n         char[] sixthLineCharArray = new char[80];\n         int nbytes_sixthLine = reader.read(sixthLineCharArray);\n-\n         String sixthLine = new String(sixthLineCharArray);\n-        dbgLog.fine(\"sixthLineCharArray=\"+\n-            Arrays.deepToString(ArrayUtils.toObject(sixthLineCharArray)));\n-        int signatureLocation = sixthLine.indexOf(POR_MARK);\n+        dbgLog.fine(\"sixthLineCharArray=\" + Arrays.deepToString(ArrayUtils.toObject(sixthLineCharArray)));\n \n-        if (signatureLocation >= 0){\n-            dbgLog.fine(\"format signature was found at:\"+signatureLocation);\n+        int signatureLocation = sixthLine.indexOf(POR_MARK);\n+        if (signatureLocation >=0) {\n+            dbgLog.fine(\"format signature was found at:\" + signatureLocation);\n         } else {\n             dbgLog.severe(\"signature string was not found\");\n             throw new IOException(\"signature string was not found\");\n@@ -641,70 +588,56 @@ public class PORFileReader  extends TabularDataFileReader{\n \n         // skip bytes up to the signature string\n         long skippedBytes = reader.skip(signatureLocation);\n-\n         char[] sec2_leader = new char[POR_MARK.length()];\n         int nbytes_sec2_leader = reader.read(sec2_leader);\n-\n         String leader_string = new String(sec2_leader);\n-\n-        dbgLog.fine(\"format signature [SPSSPORT] detected=\"+leader_string);\n-\n-\n-        if (leader_string.equals(\"SPSSPORT\")){\n+        dbgLog.fine(\"format signature [SPSSPORT] detected=\" + leader_string);\n+        if (leader_string.equals(\"SPSSPORT\")) {\n             dbgLog.fine(\"signature was correctly detected\");\n-\n         } else {\n-            dbgLog.severe(\n-            \"the format signature is not found at the previously located column\");\n+            dbgLog.severe(\"the format signature is not found at the previously located column\");\n             throw new IOException(\"decodeSec2: failed to find the signature string\");\n         }\n \n         int length_section_2 = LENGTH_SECTION_2;\n-\n         char[] Sec2_bytes = new char[length_section_2];\n-\n         int nbytes_sec2 = reader.read(Sec2_bytes);\n-\n-        if (nbytes_sec2 == 0){\n+        if (nbytes_sec2 == 0) {\n             dbgLog.severe(\"decodeSec2: reading error\");\n             throw new IOException(\"decodeSec2: reading error\");\n         } else {\n-            dbgLog.fine(\"bytes read=\"+nbytes_sec2);\n+            dbgLog.fine(\"bytes read=\" + nbytes_sec2);\n         }\n \n         String sec2 = new String(Sec2_bytes);\n-        dbgLog.fine(\"sec2[creation date/time]=\"+sec2);\n+        dbgLog.fine(\"sec2[creation date/time]=\" + sec2);\n \n         // sec2\n         //       0123456789012345678\n         //       A8/YYYYMMDD6/HHMMSS\n         // thus\n         // section2 should has 3 elements\n-\n         String[] section2 = StringUtils.split(sec2, '/');\n-\n-        dbgLog.fine(\"section2=\"+StringUtils.join(section2, \"|\"));\n-\n-        String fileCreationDate =null;\n+        dbgLog.fine(\"section2=\" + StringUtils.join(section2, \"|\"));\n+        String fileCreationDate = null;\n         String fileCreationTime = null;\n-        if ((section2.length == 3)&& (section2[0].startsWith(\"A\"))){\n-            fileCreationDate = section2[1].substring(0,7);\n+        if ((section2.length == 3) && (section2[0].startsWith(\"A\"))) {\n+            fileCreationDate = section2[1].substring(0, 7);\n             fileCreationTime = section2[2];\n         } else {\n             dbgLog.severe(\"decodeSec2: file creation date/time were not correctly detected\");\n             throw new IOException(\"decodeSec2: file creation date/time were not correctly detected\");\n         }\n-        dbgLog.fine(\"fileCreationDate=\"+fileCreationDate);\n-        dbgLog.fine(\"fileCreationTime=\"+fileCreationTime);\n+        dbgLog.fine(\"fileCreationDate=\" + fileCreationDate);\n+        dbgLog.fine(\"fileCreationTime=\" + fileCreationTime);\n         ///smd.getFileInformation().put(\"fileCreationDate\", fileCreationDate);\n         ///smd.getFileInformation().put(\"fileCreationTime\", fileCreationTime);\n         ///smd.getFileInformation().put(\"varFormat_schema\", \"SPSS\");\n         dbgLog.fine(\"decodeSec2(): end\");\n     }\n \n-\n     private void decodeProductName(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeProductName: reader == null!\");\n         }\n \n@@ -712,9 +645,8 @@ public class PORFileReader  extends TabularDataFileReader{\n         ///smd.getFileInformation().put(\"productName\", productName);\n     }\n \n-\n     private void decodeLicensee(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeLicensee: reader == null!\");\n         }\n \n@@ -722,9 +654,8 @@ public class PORFileReader  extends TabularDataFileReader{\n         ///smd.getFileInformation().put(\"licenseeName\", licenseeName);\n     }\n \n-\n     private void decodeFileLabel(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeFileLabel: reader == null!\");\n         }\n \n@@ -733,16 +664,14 @@ public class PORFileReader  extends TabularDataFileReader{\n         ///smd.getFileInformation().put(\"fileLabel\", fileLabel);\n     }\n \n-\n     private void decodeNumberOfVariables(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeNumberOfVariables: reader == null!\");\n         }\n-        \n+\n         String temp = null;\n         char[] tmp = new char[1];\n         StringBuilder sb = new StringBuilder();\n-\n         while (reader.read(tmp) > 0) {\n             temp = Character.toString(tmp[0]);\n             if (temp.equals(\"/\")) {\n@@ -754,32 +683,27 @@ public class PORFileReader  extends TabularDataFileReader{\n \n         String rawNumberOfVariables = sb.toString();\n         int rawLength = rawNumberOfVariables.length();\n-\n         String numberOfVariables = StringUtils.stripStart((StringUtils.strip(rawNumberOfVariables)), \"0\");\n-        \n-        if ((numberOfVariables.equals(\"\")) && (numberOfVariables.length() == rawLength)){\n-            numberOfVariables =\"0\";\n+        if ((numberOfVariables.equals(\"\")) && (numberOfVariables.length() == rawLength)) {\n+            numberOfVariables = \"0\";\n         }\n-\n         varQnty = Integer.valueOf(numberOfVariables, 30);\n         dataTable.setVarQuantity(Long.valueOf(numberOfVariables, 30));\n     }\n \n-\n     private void decodeFieldNo5(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeFieldNo5: reader == null!\");\n-        }    \n-        \n+        }\n+\n         int field5 = parseNumericField(reader);\n     }\n \n-\n     private void decodeWeightVariable(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeWeightVariable: reader == null!\");\n-        }    \n-        \n+        }\n+\n         String weightVariableName = parseStringField(reader);\n         // TODO: make sure case weight variables are properly handled! \n         // -- L.A. 4.0 beta\n@@ -787,13 +711,13 @@ public class PORFileReader  extends TabularDataFileReader{\n         ///smd.setCaseWeightVariableName(weightVariableName);\n     }\n \n-\n     private void decodeVariableInformation(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeVariableInformation: reader == null!\");\n         } \n \n         // step 1: variable type\n+\n         int variableType = parseNumericField(reader);\n         variableTypelList.add(variableType);\n         isCurrentVariableString = (variableType > 0);\n@@ -803,43 +727,41 @@ public class PORFileReader  extends TabularDataFileReader{\n         String variableName = parseStringField(reader);\n         currentVariableName = variableName;\n         variableNameList.add(variableName);\n-        variableTypeTable.put(variableName,variableType);\n+        variableTypeTable.put(variableName, variableType);\n            \n         // step 3: format(print/write)\n+\n         int[] printWriteFormatTable = new int[6];\n-        for (int i=0; i < 6; i++){\n-            printWriteFormatTable[i]= parseNumericField(reader);\n+        for (int i = 0; i < 6; i++) {\n+            printWriteFormatTable[i] = parseNumericField(reader);\n         }\n \n         int formatCode = printWriteFormatTable[0];\n         int formatWidth = printWriteFormatTable[1];\n         int formatDecimalPointPosition = printWriteFormatTable[2];\n-\n         formatDecimalPointPositionList.add(formatDecimalPointPosition);\n-        if (!SPSSConstants.FORMAT_CODE_TABLE_POR.containsKey(formatCode)){\n-                throw new IOException(\"Unknown format code was found = \" + formatCode);\n+        if (!SPSSConstants.FORMAT_CODE_TABLE_POR.containsKey(formatCode)) {\n+            throw new IOException(\"Unknown format code was found = \" + formatCode);\n         } else {\n             printFormatList.add(printWriteFormatTable[0]);\n         }\n \n-        if (!SPSSConstants.ORDINARY_FORMAT_CODE_SET.contains(formatCode)){\n+        if (!SPSSConstants.ORDINARY_FORMAT_CODE_SET.contains(formatCode)) {\n             StringBuilder sb = new StringBuilder(SPSSConstants.FORMAT_CODE_TABLE_POR.get(formatCode) + formatWidth);\n-            if (formatDecimalPointPosition > 0){\n-                sb.append(\".\"+ formatDecimalPointPosition);\n+            if (formatDecimalPointPosition > 0) {\n+                sb.append(\".\" + formatDecimalPointPosition);\n             }\n             printFormatNameTable.put(variableName, sb.toString());\n         }\n-\n         printFormatTable.put(variableName, SPSSConstants.FORMAT_CODE_TABLE_POR.get(formatCode));\n     }\n \n-\n     private void decodeMissValuePointNumeric(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeMissValuePointNumeric: reader == null!\");\n         }\n-        \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n+\n+        if (missingValueCodeTable.containsKey(currentVariableName)) {\n             missingValueCodeTable.get(currentVariableName).add(\"8\");\n         } else {\n             List<String> mvc = new ArrayList<>();\n@@ -847,17 +769,17 @@ public class PORFileReader  extends TabularDataFileReader{\n             missingValueCodeTable.put(currentVariableName, mvc);\n         }\n \n-        String missingValuePoint=null;\n+        String missingValuePoint = null;\n \n         // missing values are not always integers\n         String base30value = getNumericFieldAsRawString(reader);\n-        if (base30value.contains(\".\")){\n+        if (base30value.contains(\".\")) {\n             missingValuePoint = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n         } else {\n-            missingValuePoint= Integer.valueOf(base30value, 30).toString();\n+            missingValuePoint = Integer.valueOf(base30value, 30).toString();\n         }\n \n-        if (missingValueTable.containsKey(currentVariableName)){\n+        if (missingValueTable.containsKey(currentVariableName)) {\n             // already stored\n             (missingValueTable.get(currentVariableName)).add(missingValuePoint);\n         } else {\n@@ -868,23 +790,21 @@ public class PORFileReader  extends TabularDataFileReader{\n         }\n     }\n \n-\n     private void decodeMissValuePointString(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeMissValuePointString: reader == null!\");\n-        }    \n-        \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n+        }\n+\n+        if (missingValueCodeTable.containsKey(currentVariableName)) {\n             missingValueCodeTable.get(currentVariableName).add(\"8\");\n         } else {\n             List<String> mvc = new ArrayList<>();\n             mvc.add(\"8\");\n             missingValueCodeTable.put(currentVariableName, mvc);\n         }\n-        \n-        String missingValuePointString  = parseStringField(reader);\n-        \n-        if (missingValueTable.containsKey(currentVariableName)){\n+\n+        String missingValuePointString = parseStringField(reader);\n+        if (missingValueTable.containsKey(currentVariableName)) {\n             // already stored\n             (missingValueTable.get(currentVariableName)).add(missingValuePointString);\n         } else {\n@@ -895,13 +815,12 @@ public class PORFileReader  extends TabularDataFileReader{\n         }\n     }\n \n-\n     private void decodeMissValueRangeLow(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeMissValueRangeLow: reader == null!\");\n         }\n-        \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n+\n+        if (missingValueCodeTable.containsKey(currentVariableName)) {\n             missingValueCodeTable.get(currentVariableName).add(\"9\");\n         } else {\n             List<String> mvc = new ArrayList<>();\n@@ -909,20 +828,20 @@ public class PORFileReader  extends TabularDataFileReader{\n             missingValueCodeTable.put(currentVariableName, mvc);\n         }\n \n-        String missingValueRangeLOtype=null;\n+        String missingValueRangeLOtype = null;\n \n         // missing values are not always integers\n         String base30value = getNumericFieldAsRawString(reader);\n-\n-        if (base30value.contains(\".\")){\n+        if (base30value.contains(\".\")) {\n             missingValueRangeLOtype = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n         } else {\n-            missingValueRangeLOtype= Integer.valueOf(base30value, 30).toString();\n+            missingValueRangeLOtype = Integer.valueOf(base30value, 30).toString();\n         }\n-        \n-        if (missingValueTable.containsKey(currentVariableName)){\n+\n+        if (missingValueTable.containsKey(currentVariableName)) {\n             // already stored\n             (missingValueTable.get(currentVariableName)).add(\"LOWEST\");\n+\n             (missingValueTable.get(currentVariableName)).add(missingValueRangeLOtype);\n         } else {\n             // no missing value stored\n@@ -933,13 +852,12 @@ public class PORFileReader  extends TabularDataFileReader{\n         }\n     }\n \n-\n     private void decodeMissValueRangeHigh(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeMissValueRangeHigh: reader == null!\");\n         }\n-        \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n+\n+        if (missingValueCodeTable.containsKey(currentVariableName)) {\n             missingValueCodeTable.get(currentVariableName).add(\"A\");\n         } else {\n             List<String> mvc = new ArrayList<>();\n@@ -951,111 +869,101 @@ public class PORFileReader  extends TabularDataFileReader{\n \n         // missing values are not always integers\n         String base30value = getNumericFieldAsRawString(reader);\n-\n-        if (base30value.contains(\".\")){\n+        if (base30value.contains(\".\")) {\n             missingValueRangeHItype = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n         } else {\n-            missingValueRangeHItype= Integer.valueOf(base30value, 30).toString();\n+            missingValueRangeHItype = Integer.valueOf(base30value, 30).toString();\n         }\n \n-        if (missingValueTable.containsKey(currentVariableName)){\n+        if (missingValueTable.containsKey(currentVariableName)) {\n             // already stored\n             (missingValueTable.get(currentVariableName)).add(missingValueRangeHItype);\n+\n             (missingValueTable.get(currentVariableName)).add(\"HIGHEST\");\n         } else {\n             // no missing value stored\n-           List<String> mv = new ArrayList<>();\n-           mv.add(missingValueRangeHItype);\n-           mv.add(\"HIGHEST\");\n-           missingValueTable.put(currentVariableName, mv);\n+            List<String> mv = new ArrayList<>();\n+            mv.add(missingValueRangeHItype);\n+            mv.add(\"HIGHEST\");\n+            missingValueTable.put(currentVariableName, mv);\n         }\n     }\n-    \n-    \n+\n     private void decodeMissValueRange(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeMissValueRange: reader == null!\");\n         }\n \n-        if (missingValueCodeTable.containsKey(currentVariableName)){\n+        if (missingValueCodeTable.containsKey(currentVariableName)) {\n             missingValueCodeTable.get(currentVariableName).add(\"B\");\n         } else {\n             List<String> mvc = new ArrayList<>();\n             mvc.add(\"B\");\n             missingValueCodeTable.put(currentVariableName, mvc);\n         }\n-        \n+\n         String[] missingValueRange = new String[2];\n \n        // missing values are not always integers\n         String base30value0 = getNumericFieldAsRawString(reader);\n-\n-        if (base30value0.contains(\".\")){\n+        if (base30value0.contains(\".\")) {\n             missingValueRange[0] = doubleNumberFormatter.format(base30Tobase10Conversion(base30value0));\n         } else {\n-            missingValueRange[0]= Integer.valueOf(base30value0, 30).toString();\n+            missingValueRange[0] = Integer.valueOf(base30value0, 30).toString();\n         }\n \n         String base30value1 = getNumericFieldAsRawString(reader);\n-\n-        if (base30value1.contains(\".\")){\n+        if (base30value1.contains(\".\")) {\n             missingValueRange[1] = doubleNumberFormatter.format(base30Tobase10Conversion(base30value1));\n         } else {\n-            missingValueRange[1]= Integer.valueOf(base30value1, 30).toString();\n+            missingValueRange[1] = Integer.valueOf(base30value1, 30).toString();\n         }\n \n-        if (missingValueTable.containsKey(currentVariableName)){\n+        if (missingValueTable.containsKey(currentVariableName)) {\n             // already stored\n             (missingValueTable.get(currentVariableName)).add(missingValueRange[0]);\n+\n             (missingValueTable.get(currentVariableName)).add(missingValueRange[1]);\n         } else {\n             // no missing value stored\n-           List<String> mv = new ArrayList<>();\n-           mv.add(missingValueRange[0]);\n-           mv.add(missingValueRange[1]);\n-           missingValueTable.put(currentVariableName, mv);\n+            List<String> mv = new ArrayList<>();\n+            mv.add(missingValueRange[0]);\n+            mv.add(missingValueRange[1]);\n+            missingValueTable.put(currentVariableName, mv);\n         }\n     }\n-    \n \n     private void decodeVariableLabel(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeVariableLabel: reader == null!\");\n-        }    \n+        }\n \n         String variableLabel = parseStringField(reader);\n         variableLabelMap.put(currentVariableName, variableLabel);\n         // note: not all variables have their variable label; therefore,\n         // saving them to the metatadata object is done within read() method\n-\n     }\n-    \n-    \n+\n     private void decodeValueLabel(BufferedReader reader) throws IOException {\n         Map<String, String> valueLabelSet = new LinkedHashMap<>();\n-        \n         int numberOfVariables = parseNumericField(reader);\n         String[] variableNames = new String[numberOfVariables];\n-\n-        for (int i= 0; i< numberOfVariables; i++){\n+        for (int i = 0; i < numberOfVariables; i++) {\n             variableNames[i] = parseStringField(reader);\n         }\n \n         int numberOfvalueLabelSets = parseNumericField(reader);\n         boolean isStringType = variableTypeTable.get(variableNames[0]) > 0;\n-\n-        for (int i=0; i<numberOfvalueLabelSets ;i++){\n+        for (int i = 0; i < numberOfvalueLabelSets; i++) {\n             String[] tempValueLabel = new String[2];\n-            if (isStringType){\n+            if (isStringType) {\n                 // String case\n                 tempValueLabel[0] = parseStringField(reader);\n             } else {\n                 // Numeric case\n                 // values may not be always integers\n                 String base30value = getNumericFieldAsRawString(reader);\n-\n                 Matcher matcher = pattern4Integer.matcher(base30value);\n-\n                 if (matcher.matches()) {\n                     // integer case\n                     tempValueLabel[0] = Long.valueOf(base30value, 30).toString();\n@@ -1064,31 +972,28 @@ public class PORFileReader  extends TabularDataFileReader{\n                     tempValueLabel[0] = doubleNumberFormatter.format(base30Tobase10Conversion(base30value));\n                 }\n             }\n-\n-\n             tempValueLabel[1] = parseStringField(reader);\n-            valueLabelSet.put(tempValueLabel[0],tempValueLabel[1]);\n+            valueLabelSet.put(tempValueLabel[0], tempValueLabel[1]);\n         }\n         // save the value-label mapping list\n         // use the first variable name as the key\n         valueLabelTable.put(variableNames[0], valueLabelSet);\n \n         // create a mapping table that finds the key variable for this mapping table\n-        for (String vn : variableNames){\n+\n+        for (String vn : variableNames) {\n             valueVariableMappingTable.put(vn, variableNames[0]);\n         }\n     }\n \n-\n     private void decodeDocument(BufferedReader reader) throws IOException {\n-        if (reader ==null){\n+        if (reader == null) {\n             throw new IllegalArgumentException(\"decodeVariableLabel: reader == null!\");\n-        }    \n-        \n+        }\n+\n         int noOfdocumentLines = parseNumericField(reader);\n         String[] document = new String[noOfdocumentLines];\n-\n-        for (int i= 0; i< noOfdocumentLines; i++){\n+        for (int i = 0; i < noOfdocumentLines; i++) {\n             document[i] = parseStringField(reader);\n         }\n \n@@ -1098,26 +1003,23 @@ public class PORFileReader  extends TabularDataFileReader{\n         ///smd.getFileInformation().put(\"document\", StringUtils.join(document,\" \" ));\n     }\n \n-\n     private void decodeData(BufferedReader reader) throws IOException {\n         dbgLog.fine(\"decodeData(): start\");\n         // TODO: get rid of this \"variableTypeFinal\"; -- L.A. 4.0 beta\n-        int[] variableTypeFinal= new int[varQnty];\n+\n+        int[] variableTypeFinal = new int[varQnty];\n         dateFormatList = new String[varQnty];\n \n         // create a File object to save the tab-delimited data file\n         File tabDelimitedDataFile = File.createTempFile(\"tempTabfile.\", \".tab\");\n         ingesteddata.setTabDelimitedFile(tabDelimitedDataFile);\n-        \n-\n         FileOutputStream fileOutTab = null;\n         PrintWriter pwout = null;\n-\n         try {\n             fileOutTab = new FileOutputStream(tabDelimitedDataFile);\n             pwout = new PrintWriter(new OutputStreamWriter(fileOutTab, \"utf8\"), true);\n-\n             variableFormatTypeList = new String[varQnty];\n+\n             for (int i = 0; i < varQnty; i++) {\n                 variableFormatTypeList[i] = SPSSConstants.FORMAT_CATEGORY_TABLE.get(printFormatTable.get(variableNameList.get(i)));\n                 formatCategoryTable.put(variableNameList.get(i), variableFormatTypeList[i]);\n@@ -1127,256 +1029,228 @@ public class PORFileReader  extends TabularDataFileReader{\n             Arrays.fill(variableTypeFinal, 0);\n \n             // raw-case counter\n+\n             int j = 0; // case\n \n             // use while instead for because the number of cases (observations) is usually unknown\n-            FBLOCK: while(true){\n-                j++;\n+            FBLOCK: while (true) {\n+                        j++;\n \n                 // case(row)-wise storage object; to be updated after each row-reading\n-\n-                String[] casewiseRecordForTabFile = new String[varQnty];\n+                        String[] casewiseRecordForTabFile = new String[varQnty];\n                 // warning: the above object is later shallow-copied to the\n                 // data object for calculating a UNF value/summary statistics\n                 //\n-\n-                for (int i=0; i<varQnty; i++){\n+                        for (int i = 0; i < varQnty; i++) {\n                     // check the type of this variable\n-                    boolean isStringType = variableTypeTable.get(variableNameList.get(i)) > 0;\n-\n-                    if (isStringType){\n+                            boolean isStringType = variableTypeTable.get(variableNameList.get(i)) > 0;\n+                            if (isStringType) {\n                         // String case\n-                        variableTypeFinal[i]=-1;\n-\n-                        StringBuilder sb_StringLengthBase30 = new StringBuilder(\"\");\n-                        int stringLengthBase10 = 0;\n-                        String buffer = \"\";\n-                        char[] tmp = new char[1];\n-\n-                        int nint;\n-                        while((nint = reader.read(tmp))>0){\n-                            buffer =  Character.toString(tmp[0]);\n-                            if (buffer.equals(\"/\")){\n-                                break;\n-                            } else if (buffer.equals(\"Z\")){\n-                                if (i == 0){\n+                                variableTypeFinal[i] = -1;\n+                                StringBuilder sb_StringLengthBase30 = new StringBuilder(\"\");\n+                                int stringLengthBase10 = 0;\n+                                String buffer = \"\";\n+                                char[] tmp = new char[1];\n+                                int nint;\n+                                while ((nint = reader.read(tmp)) > 0) {\n+                                    buffer = Character.toString(tmp[0]);\n+                                    if (buffer.equals(\"/\")) {\n+                                        break;\n+                                    } else if (buffer.equals(\"Z\")) {\n+                                        if (i == 0) {\n                                     // the reader has passed the last case; subtract 1 from the j counter\n-                                    caseQnty = j-1;\n-                                    break FBLOCK;\n+                                            caseQnty = j - 1;\n+                                            break FBLOCK;\n+                                        }\n+                                    } else {\n+                                        sb_StringLengthBase30.append(buffer);\n+                                    }\n                                 }\n-                            } else {\n-                                sb_StringLengthBase30.append(buffer);\n-                            }\n-\n-\n-                        }\n \n-                        if (nint == 0){\n+                                if (nint == 0) {\n                             // no more data to be read (reached the eof)\n-                            caseQnty = j - 1;\n-                            break FBLOCK;\n-                        }\n-\n-\n-                        dbgLog.finer(j+\"-th case \"+i+\"=th var:datum length=\" +sb_StringLengthBase30.toString());\n+                                    caseQnty = j - 1;\n+                                    break FBLOCK;\n+                                }\n+                                dbgLog.finer(j + \"-th case \" + i + \"=th var:datum length=\" + sb_StringLengthBase30.toString());\n \n                         // this length value should be a positive integer\n-                        Matcher mtr = pattern4positiveInteger.matcher(sb_StringLengthBase30.toString());\n-                        if (mtr.matches()){\n-                            stringLengthBase10 = Integer.valueOf(sb_StringLengthBase30.toString(), 30);\n-                        } else{\n+                                Matcher mtr = pattern4positiveInteger.matcher(sb_StringLengthBase30.toString());\n+                                if (mtr.matches()) {\n+                                    stringLengthBase10 = Integer.valueOf(sb_StringLengthBase30.toString(), 30);\n+                                } else {\n                             // reading error case\n-                            throw new IOException(\"reading F(data) section: string: length is not integer\");\n-                        }\n+                                    throw new IOException(\"reading F(data) section: string: length is not integer\");\n+                                }\n \n                         // read this string-variable's contents after \"/\"\n-                        char[] char_datumString = new char[stringLengthBase10];\n-                        reader.read(char_datumString);\n \n-                        String datum = new String(char_datumString);\n-                        casewiseRecordForTabFile[i] =  \"\\\"\" + datum.replaceAll(\"\\\"\",Matcher.quoteReplacement(\"\\\\\\\"\")) + \"\\\"\";\n+                                char[] char_datumString = new char[stringLengthBase10];\n+                                reader.read(char_datumString);\n+                                String datum = new String(char_datumString);\n+                                casewiseRecordForTabFile[i] = \"\\\"\" + datum.replaceAll(\"\\\"\", Matcher.quoteReplacement(\"\\\\\\\"\")) + \"\\\"\";\n                         // end of string case\n-                    } else {\n+                            } else {\n \n                         // numeric case\n-                        StringBuilder sb_datumNumericBase30 = new StringBuilder(\"\");\n-                        boolean isMissingValue = false;\n-                        String datum = null;\n-                        String datumForTabFile = null;\n-                        String datumDateFormat = null;\n-\n-                        String buffer = \"\";\n-                        char[] tmp = new char[1];\n-                        int nint;\n-                        while((nint = reader.read(tmp))>0){\n-                            sb_datumNumericBase30.append(buffer);\n-                            buffer = Character.toString(tmp[0]);\n-\n-                            if (buffer.equals(\"/\")){\n-                                break;\n-                            } else if (buffer.equals(\"Z\")){\n-                                if (i == 0){\n+                                StringBuilder sb_datumNumericBase30 = new StringBuilder(\"\");\n+                                boolean isMissingValue = false;\n+                                String datum = null;\n+                                String datumForTabFile = null;\n+                                String datumDateFormat = null;\n+                                String buffer = \"\";\n+                                char[] tmp = new char[1];\n+                                int nint;\n+                                while ((nint = reader.read(tmp)) > 0) {\n+                                    sb_datumNumericBase30.append(buffer);\n+                                    buffer = Character.toString(tmp[0]);\n+                                    if (buffer.equals(\"/\")) {\n+                                        break;\n+                                    } else if (buffer.equals(\"Z\")) {\n+                                        if (i == 0) {\n                                     // the reader has passed the last case\n                                     // subtract 1 from the j counter\n-                                    dbgLog.fine(\"Z-mark was detected\");\n-                                    caseQnty = j-1;\n-                                    break FBLOCK;\n-                                }\n-                            } else if (buffer.equals(\"*\")) {\n+                                            dbgLog.fine(\"Z-mark was detected\");\n+                                            caseQnty = j - 1;\n+                                            break FBLOCK;\n+                                        }\n+                                    } else if (buffer.equals(\"*\")) {\n                                 // '*' is the first character of the system missing value\n-                                datumForTabFile = MissingValueForTextDataFile;\n-                                datum = null;\n-                                isMissingValue = true;\n+                                               datumForTabFile = MissingValueForTextDataFile;\n+                                               datum = null;\n+                                               isMissingValue = true;\n \n                                // read next char '.' as part of the missing value\n-                                reader.read(tmp);\n-                                buffer = Character.toString(tmp[0]);\n-                                break;\n-                            }\n+                                               reader.read(tmp);\n+                                               buffer = Character.toString(tmp[0]);\n+                                               break;\n+                                           }\n+                                }\n \n-                        }\n-                        if (nint == 0){\n+                                if (nint == 0) {\n                             // no more data to be read; reached the eof\n-                            caseQnty = j - 1;\n-                            break FBLOCK;\n-                        }\n+                                    caseQnty = j - 1;\n+                                    break FBLOCK;\n+                                }\n \n                         // follow-up process for non-missing-values\n-                        if (!isMissingValue) {\n-                            // decode a numeric datum as String\n-                            String datumNumericBase30 = sb_datumNumericBase30.toString();\n-                            Matcher matcher = pattern4Integer.matcher(datumNumericBase30);\n \n-                            if (matcher.matches()){\n+                                if (!isMissingValue) {\n+                            // decode a numeric datum as String\n+                                    String datumNumericBase30 = sb_datumNumericBase30.toString();\n+                                    Matcher matcher = pattern4Integer.matcher(datumNumericBase30);\n+                                    if (matcher.matches()) {\n                                 // integer case\n-                                datum = Long.valueOf(datumNumericBase30, 30).toString();\n-                            } else {\n+                                        datum = Long.valueOf(datumNumericBase30, 30).toString();\n+                                    } else {\n                                 // double case\n-                                datum = doubleNumberFormatter.format(base30Tobase10Conversion(datumNumericBase30));\n-                            }\n+                                        datum = doubleNumberFormatter.format(base30Tobase10Conversion(datumNumericBase30));\n+                                    }\n \n                             // now check format (if date or time)\n-                            String variableFormatType = variableFormatTypeList[i];\n-\n-                            if (variableFormatType.equals(\"date\")){\n-                                variableTypeFinal[i]=-1;\n-                                long dateDatum = Long.parseLong(datum)*1000L- SPSS_DATE_OFFSET;\n-                                datum = sdf_ymd.format(new Date(dateDatum));\n-                                datumDateFormat = sdf_ymd.toPattern();\n-\n-                            } else if (variableFormatType.equals(\"time\")) {\n-                                variableTypeFinal[i]=-1;\n-                                int formatDecimalPointPosition = formatDecimalPointPositionList.get(i);\n \n-                                if (printFormatTable.get(variableNameList.get(i)).equals(\"DTIME\")){\n-\n-                                    if (datum.indexOf(\".\") < 0){\n-                                        long dateDatum  = Long.parseLong(datum)*1000L - SPSS_DATE_BIAS;\n-                                        datum = sdf_dhms.format(new Date(dateDatum));\n+                                    String variableFormatType = variableFormatTypeList[i];\n+                                    if (variableFormatType.equals(\"date\")) {\n+                                        variableTypeFinal[i] = -1;\n+                                        long dateDatum = Long.parseLong(datum) * 1000L - SPSS_DATE_OFFSET;\n+                                        datum = sdf_ymd.format(new Date(dateDatum));\n+                                        datumDateFormat = sdf_ymd.toPattern();\n+                                    } else if (variableFormatType.equals(\"time\")) {\n+                                        variableTypeFinal[i] = -1;\n+\n+                                        int formatDecimalPointPosition = formatDecimalPointPositionList.get(i);\n+                                        if (printFormatTable.get(variableNameList.get(i)).equals(\"DTIME\")) {\n+                                            if (datum.indexOf(\".\") < 0) {\n+                                                long dateDatum = Long.parseLong(datum) * 1000L - SPSS_DATE_BIAS;\n+                                                datum = sdf_dhms.format(new Date(dateDatum));\n                                         // don't save date format for dtime\n-                                    } else {\n+                                            } else {\n                                         // decimal point included\n-                                        String[] timeData = datum.split(\"\\\\.\");\n-                                        long dateDatum = Long.parseLong(timeData[0])*1000L - SPSS_DATE_BIAS;\n-                                        StringBuilder sb_time = new StringBuilder(sdf_dhms.format(new Date(dateDatum)));\n-\n-                                        if (formatDecimalPointPosition > 0){\n-                                            sb_time.append(\".\"+timeData[1].substring(0,formatDecimalPointPosition));\n-                                        }\n-\n-                                        datum = sb_time.toString();\n+                                                String[] timeData = datum.split(\"\\\\.\");\n+                                                long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_BIAS;\n+                                                StringBuilder sb_time = new StringBuilder(sdf_dhms.format(new Date(dateDatum)));\n+                                                if (formatDecimalPointPosition > 0) {\n+                                                    sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                                                }\n+                                                datum = sb_time.toString();\n                                         // DTIME is weird date/time format that no one uses outside of \n                                         // SPSS; so we are not even going to bother trying to save\n                                         // this variable as a datetime. \n-                                    }\n-\n-                                } else if (printFormatTable.get(variableNameList.get(i)).equals(\"DATETIME\")){\n+                                            }\n+                                        } else if (printFormatTable.get(variableNameList.get(i)).equals(\"DATETIME\")) {\n                                     // TODO: \n                                     // (for both datetime and \"dateless\" time)\n                                     // keep the longest of the matching formats - i.e., if there are *some*\n                                     // values in the vector that have thousands of a second, that should be \n                                     // part of the saved format!\n                                     //  -- L.A. Aug. 12 2014 \n-\n-                                    if (!datum.contains(\".\")){\n-                                        long dateDatum  = Long.parseLong(datum)*1000L - SPSS_DATE_OFFSET;\n-                                        datum = sdf_ymdhms.format(new Date(dateDatum));\n-                                        datumDateFormat = sdf_ymdhms.toPattern();\n-                                    } else {\n+                                            if (!datum.contains(\".\")) {\n+                                                long dateDatum = Long.parseLong(datum) * 1000L - SPSS_DATE_OFFSET;\n+                                                datum = sdf_ymdhms.format(new Date(dateDatum));\n+                                                datumDateFormat = sdf_ymdhms.toPattern();\n+                                            } else {\n                                         // decimal point included\n-                                        String[] timeData = datum.split(\"\\\\.\");\n-                                        long dateDatum = Long.parseLong(timeData[0])*1000L- SPSS_DATE_OFFSET;\n-                                        StringBuilder sb_time = new StringBuilder(sdf_ymdhms.format(new Date(dateDatum)));\n-\n-                                        if (formatDecimalPointPosition > 0){\n-                                            sb_time.append(\".\"+timeData[1].substring(0,formatDecimalPointPosition));\n-                                        }\n-\n-                                        datum = sb_time.toString();\n-                                        datumDateFormat = sdf_ymdhms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\" );\n-                                    }\n-\n-                                } else if (printFormatTable.get(variableNameList.get(i)).equals(\"TIME\")){\n-\n-                                    if (!datum.contains(\".\")){\n-                                        long dateDatum = Long.parseLong(datum)*1000L;\n-                                        datum = sdf_hms.format(new Date(dateDatum));\n-                                        datumDateFormat = sdf_hms.toPattern();\n-                                    } else {\n+                                                String[] timeData = datum.split(\"\\\\.\");\n+                                                long dateDatum = Long.parseLong(timeData[0]) * 1000L - SPSS_DATE_OFFSET;\n+                                                StringBuilder sb_time = new StringBuilder(sdf_ymdhms.format(new Date(dateDatum)));\n+                                                if (formatDecimalPointPosition > 0) {\n+                                                    sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                                                }\n+                                                datum = sb_time.toString();\n+                                                datumDateFormat = sdf_ymdhms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\");\n+                                            }\n+                                        } else if (printFormatTable.get(variableNameList.get(i)).equals(\"TIME\")) {\n+                                                   if (!datum.contains(\".\")) {\n+                                                       long dateDatum = Long.parseLong(datum) * 1000L;\n+                                                       datum = sdf_hms.format(new Date(dateDatum));\n+                                                       datumDateFormat = sdf_hms.toPattern();\n+                                                   } else {\n                                         // decimal point included\n-                                        String[] timeData = datum.split(\"\\\\.\");\n-                                        long dateDatum = Long.parseLong(timeData[0])*1000L;\n-                                        StringBuilder sb_time = new StringBuilder(sdf_hms.format(new Date(dateDatum)));\n-\n-                                        if (formatDecimalPointPosition > 0){\n-                                            sb_time.append(\".\"+timeData[1].substring(0,formatDecimalPointPosition));\n-                                        }\n-\n-                                        datum = sb_time.toString();\n-                                        datumDateFormat = sdf_hms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\" );\n-                                    }\n-                                }\n-\n-                            } else if (variableFormatType.equals(\"other\")){\n-\n-                                if (printFormatTable.get(variableNameList.get(i)).equals(\"WKDAY\")){\n+                                                       String[] timeData = datum.split(\"\\\\.\");\n+                                                       long dateDatum = Long.parseLong(timeData[0]) * 1000L;\n+                                                       StringBuilder sb_time = new StringBuilder(sdf_hms.format(new Date(dateDatum)));\n+                                                       if (formatDecimalPointPosition > 0) {\n+                                                           sb_time.append(\".\" + timeData[1].substring(0, formatDecimalPointPosition));\n+                                                       }\n+                                                       datum = sb_time.toString();\n+                                                       datumDateFormat = sdf_hms.toPattern() + (formatDecimalPointPosition > 0 ? \".S\" : \"\");\n+                                                   }\n+                                               }\n+                                    } else if (variableFormatType.equals(\"other\")) {\n+                                               if (printFormatTable.get(variableNameList.get(i)).equals(\"WKDAY\")) {\n                                     // day of week\n-                                    variableTypeFinal[i]=-1;\n-                                    datum = SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(datum)-1);\n-\n-                                } else if (printFormatTable.get(variableNameList.get(i)).equals(\"MONTH\")){\n+                                                   variableTypeFinal[i] = -1;\n+                                                   datum = SPSSConstants.WEEKDAY_LIST.get(Integer.valueOf(datum) - 1);\n+                                               } else if (printFormatTable.get(variableNameList.get(i)).equals(\"MONTH\")) {\n                                     // month\n-                                    variableTypeFinal[i]=-1;\n-                                    datum = SPSSConstants.MONTH_LIST.get(Integer.valueOf(datum)-1);\n-                                }\n-                            }\n+                                                   variableTypeFinal[i] = -1;\n+                                                   datum = SPSSConstants.MONTH_LIST.get(Integer.valueOf(datum) - 1);\n+                                               }\n+                                           }\n \n                             // since value is not missing, set both values to be the same\n-                            datumForTabFile = datum;\n+                                    datumForTabFile = datum;\n \n                             // decimal-point check (variable is integer or not)\n-                            if (variableTypeFinal[i]==0){\n-                                if (datum.contains(\".\")){\n-                                    variableTypeFinal[i] = 1;\n-                                    decimalVariableSet.add(i);\n+                                    if (variableTypeFinal[i] == 0) {\n+                                        if (datum.contains(\".\")) {\n+                                            variableTypeFinal[i] = 1;\n+                                            decimalVariableSet.add(i);\n+                                        }\n+                                    }\n                                 }\n-                            }\n-                        }\n \n-                        if (datumDateFormat != null) {\n-                            dateFormatList[i] = datumDateFormat;\n-                        }\n-                        casewiseRecordForTabFile[i]= datumForTabFile;\n-\n-                    } // end: if: string vs numeric variable\n-\n-                } // end:for-loop-i (variable-wise loop)\n+                                if (datumDateFormat != null) {\n+                                    dateFormatList[i] = datumDateFormat;\n+                                }\n+                                casewiseRecordForTabFile[i] = datumForTabFile;\n+                            } // end: if: string vs numeric variable\n+                        } // end:for-loop-i (variable-wise loop)\n \n \n                 // print the i-th case; use casewiseRecord to dump the current case to the tab-delimited file\n-                pwout.println(StringUtils.join(casewiseRecordForTabFile, \"\\t\"));\n-\n-            } // end: while-block\n+                        pwout.println(StringUtils.join(casewiseRecordForTabFile, \"\\t\"));\n+                    } // end: while-block\n         } finally {\n             // close the print writer\n             if (pwout != null) {\n@@ -1386,12 +1260,10 @@ public class PORFileReader  extends TabularDataFileReader{\n \n         ///smd.setDecimalVariables(decimalVariableSet);\n         dataTable.setCaseQuantity(new Long(caseQnty));\n-\n         dbgLog.fine(\"decodeData(): end\");\n     }\n-    \n-    \n-    private void processMissingValueData(){\n+\n+    private void processMissingValueData() {\n         /*\n \n          POR's missing-value storage differs form the counterpart of SAV;\n@@ -1413,140 +1285,130 @@ public class PORFileReader  extends TabularDataFileReader{\n              VAR5=[-1, -2, -3], VAR6=[], VAR7=[-2]}\n \n          */\n-\n-        dbgLog.fine(\"missingValueCodeTable=\"+missingValueCodeTable);\n-        Set<Map.Entry<String,List<String>>> msvlc = missingValueCodeTable.entrySet();\n+        dbgLog.fine(\"missingValueCodeTable=\" + missingValueCodeTable);\n+        Set<Map.Entry<String, List<String>>> msvlc = missingValueCodeTable.entrySet();\n         for (Map.Entry<String, List<String>> et : msvlc) {\n             String variable = et.getKey();\n-            dbgLog.fine(\"variable=\"+variable);\n+            dbgLog.fine(\"variable=\" + variable);\n             List<String> codeList = et.getValue();\n             List<String> valueList = missingValueTable.get(variable);\n-            dbgLog.fine(\"codeList=\"+codeList);\n-            dbgLog.fine(\"valueList=\"+valueList);\n+            dbgLog.fine(\"codeList=\" + codeList);\n+            dbgLog.fine(\"valueList=\" + valueList);\n+\n             int type;\n             InvalidData invalidDataInfo = null;\n-            if (valueList.size() == 3){\n-                if (codeList.get(0).equals(\"8\") && codeList.get(1).equals(\"8\") &&\n-                        codeList.get(2).equals(\"8\") ){\n+            if (valueList.size() == 3) {\n+                if (codeList.get(0).equals(\"8\") && codeList.get(1).equals(\"8\") && codeList.get(2).equals(\"8\")) {\n                     type = 3;\n                     invalidDataInfo = new InvalidData(type);\n                     invalidDataInfo.setInvalidValues(valueList);\n-                } else if (codeList.get(0).equals(\"9\") && codeList.get(1).equals(\"8\")){\n-                    type = -3;\n-\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-\n-                } else if (codeList.get(0).equals(\"A\") && codeList.get(1).equals(\"8\")){\n+                } else if (codeList.get(0).equals(\"9\") && codeList.get(1).equals(\"8\")) {\n                     type = -3;\n                     invalidDataInfo = new InvalidData(type);\n                     invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n                     invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-                } else if (codeList.get(0).equals(\"B\") && codeList.get(1).equals(\"8\")){\n-                    type = -3;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-                } else {\n-                   dbgLog.severe(\"unkown missing-value combination(3 values)\");\n-                }\n-                \n-            } else if (valueList.size() == 2){\n-                if (codeList.get(0).equals(\"8\") && codeList.get(1).equals(\"8\")){\n+                } else if (codeList.get(0).equals(\"A\") && codeList.get(1).equals(\"8\")) {\n+                           type = -3;\n+                           invalidDataInfo = new InvalidData(type);\n+                           invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n+                           invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n+                       } else if (codeList.get(0).equals(\"B\") && codeList.get(1).equals(\"8\")) {\n+                           type = -3;\n+                           invalidDataInfo = new InvalidData(type);\n+                           invalidDataInfo.setInvalidValues(valueList.subList(2, 3));\n+                           invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n+                       } else {\n+                           dbgLog.severe(\"unkown missing-value combination(3 values)\");\n+                       }\n+            } else if (valueList.size() == 2) {\n+                if (codeList.get(0).equals(\"8\") && codeList.get(1).equals(\"8\")) {\n                     type = 2;\n                     invalidDataInfo = new InvalidData(type);\n                     invalidDataInfo.setInvalidValues(valueList);\n-\n-                } else if (codeList.get(0).equals(\"9\")){\n-                    type = -2;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-\n-                } else if (codeList.get(0).equals(\"A\")){\n+                } else if (codeList.get(0).equals(\"9\")) {\n                     type = -2;\n                     invalidDataInfo = new InvalidData(type);\n                     invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-                } else if (codeList.get(0).equals(\"B\")){\n-                    type = -2;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n-\n-                } else {\n-                    dbgLog.severe(\"unknown missing value combination(2 values)\");\n-                }\n-            } else if (valueList.size() == 1){\n-                if (codeList.get(0).equals(\"8\")){\n-                    type = 1;\n-                    invalidDataInfo = new InvalidData(type);\n-                    invalidDataInfo.setInvalidValues(valueList);\n-                } else {\n-                    dbgLog.severe(\"unknown missing value combination(2 values)\");\n-                }\n-            }\n+                } else if (codeList.get(0).equals(\"A\")) {\n+                           type = -2;\n+                           invalidDataInfo = new InvalidData(type);\n+                           invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n+                       } else if (codeList.get(0).equals(\"B\")) {\n+                           type = -2;\n+                           invalidDataInfo = new InvalidData(type);\n+                           invalidDataInfo.setInvalidRange(valueList.subList(0, 2));\n+                       } else {\n+                           dbgLog.severe(\"unknown missing value combination(2 values)\");\n+                       }\n+            } else if (valueList.size() == 1) {\n+                       if (codeList.get(0).equals(\"8\")) {\n+                           type = 1;\n+                           invalidDataInfo = new InvalidData(type);\n+                           invalidDataInfo.setInvalidValues(valueList);\n+                       } else {\n+                           dbgLog.severe(\"unknown missing value combination(2 values)\");\n+                       }\n+                   }\n             invalidDataTable.put(variable, invalidDataInfo);\n         }\n-\n-        dbgLog.fine(\"invalidDataTable=\"+invalidDataTable);\n-\n-\n-        Set<Map.Entry<String,List<String>>> msvl = missingValueTable.entrySet();\n+        dbgLog.fine(\"invalidDataTable=\" + invalidDataTable);\n+        Set<Map.Entry<String, List<String>>> msvl = missingValueTable.entrySet();\n         for (Map.Entry<String, List<String>> et : msvl) {\n             String variable = et.getKey();\n             List<String> valueList = et.getValue();\n-\n             List<String> codeList = missingValueCodeTable.get(variable);\n-\n-            dbgLog.finer(\"var=\"+variable+\"\\tvalue=\"+valueList+\"\\t code\"+ codeList);\n+            dbgLog.finer(\"var=\" + variable + \"\\tvalue=\" + valueList + \"\\t code\" + codeList);\n             List<String> temp = new ArrayList<>();\n-            for (int j=0; j<codeList.size(); j++){\n-                if (codeList.get(j).equals(\"8\")){\n-                  temp.add(valueList.get(j));\n+            for (int j = 0; j < codeList.size(); j++) {\n+                if (codeList.get(j).equals(\"8\")) {\n+                    temp.add(valueList.get(j));\n                 }\n             }\n             missingValueTable.put(variable, temp);\n         }\n-        dbgLog.fine(\"missingValueTable=\"+missingValueTable);\n+        dbgLog.fine(\"missingValueTable=\" + missingValueTable);\n     }\n     \n     \n     \n     // utility methods  -----------------------------------------------------//\n-    \n-    private int parseNumericField(BufferedReader reader) throws IOException{\n+\n+    private int parseNumericField(BufferedReader reader) throws IOException {\n         String temp = null;\n         char[] tmp = new char[1];\n         StringBuilder sb = new StringBuilder();\n-        while(reader.read(tmp) > 0 ){\n+        while (reader.read(tmp) > 0) {\n             temp = Character.toString(tmp[0]);//new String(tmp);\n-            if (temp.equals(\"/\")){\n+            if (temp.equals(\"/\")) {\n                 break;\n             } else {\n                 sb.append(temp);\n             }\n             //temp = sb.toString();//new String(tmp);\n         }\n+\n         String base30numberString = sb.toString();\n-        dbgLog.finer(\"base30numberString=\"+base30numberString);\n+        dbgLog.finer(\"base30numberString=\" + base30numberString);\n+\n         int base10equivalent = Integer.valueOf(base30numberString, 30);\n-        dbgLog.finer(\"base10equivalent=\"+base10equivalent);\n+        dbgLog.finer(\"base10equivalent=\" + base10equivalent);\n         return base10equivalent;\n     }\n \n-\n-    private String parseStringField(BufferedReader reader) throws IOException{\n+    private String parseStringField(BufferedReader reader) throws IOException {\n         String temp = null;\n         char[] tmp = new char[1];\n         StringBuilder sb = new StringBuilder();\n-        while(reader.read(tmp) > 0 ){\n+        while (reader.read(tmp) > 0) {\n             temp = Character.toString(tmp[0]);//new String(tmp);\n-            if (temp.equals(\"/\")){\n+            if (temp.equals(\"/\")) {\n                 break;\n             } else {\n                 sb.append(temp);\n             }\n             //temp = sb.toString();//new String(tmp);\n         }\n+\n         String base30numberString = sb.toString();\n         //dbgLog.fine(\"base30numberString=\"+base30numberString);\n         int base10equivalent = Integer.valueOf(base30numberString, 30);\n@@ -1554,33 +1416,30 @@ public class PORFileReader  extends TabularDataFileReader{\n         char[] stringBody = new char[base10equivalent];\n         reader.read(stringBody);\n         String stringData = new String(stringBody);\n-        dbgLog.finer(\"stringData=\"+stringData);\n+        dbgLog.finer(\"stringData=\" + stringData);\n         return stringData;\n     }\n \n-\n-\n-    private String getNumericFieldAsRawString(BufferedReader reader) throws IOException{\n+    private String getNumericFieldAsRawString(BufferedReader reader) throws IOException {\n         String temp = null;\n         char[] tmp = new char[1];\n         StringBuilder sb = new StringBuilder();\n-        while(reader.read(tmp) > 0 ){\n+        while (reader.read(tmp) > 0) {\n             temp = Character.toString(tmp[0]);//new String(tmp);\n-            if (temp.equals(\"/\")){\n+            if (temp.equals(\"/\")) {\n                 break;\n             } else {\n                 sb.append(temp);\n             }\n             //temp = sb.toString();//new String(tmp);\n         }\n-        String base30numberString = sb.toString();\n-        dbgLog.finer(\"base30numberString=\"+base30numberString);\n \n+        String base30numberString = sb.toString();\n+        dbgLog.finer(\"base30numberString=\" + base30numberString);\n         return base30numberString;\n     }\n \n-\n-    private double base30Tobase10Conversion(String base30String){\n+    private double base30Tobase10Conversion(String base30String) {\n \n         // new base(radix) number\n         int oldBase = 30;\n@@ -1593,18 +1452,18 @@ public class PORFileReader  extends TabularDataFileReader{\n         // check the negative/positive sign\n         boolean isNegativeNumber = false;\n         boolean hasPositiveSign = false;\n-        if (base30StringClean.startsWith(\"-\")){\n+        if (base30StringClean.startsWith(\"-\")) {\n             isNegativeNumber = true;\n         }\n \n-        if (base30StringClean.startsWith(\"+\")){\n+        if (base30StringClean.startsWith(\"+\")) {\n             hasPositiveSign = true;\n         }\n \n         // remove the sign if exits\n-        String base30StringNoSign = null;\n \n-        if ((isNegativeNumber) ||(hasPositiveSign)){\n+        String base30StringNoSign = null;\n+        if ((isNegativeNumber) || (hasPositiveSign)) {\n             base30StringNoSign = base30StringClean.substring(1);\n         } else {\n             base30StringNoSign = base30StringClean;\n@@ -1612,68 +1471,63 @@ public class PORFileReader  extends TabularDataFileReader{\n \n         // check the scientific notation\n         // if so, divide it into the significand and exponent\n-        String significand  = null;\n-        long exponent = 0;\n \n+        String significand = null;\n+        long exponent = 0;\n         int plusIndex = base30StringNoSign.indexOf(\"+\");\n         int minusIndex = base30StringNoSign.indexOf(\"-\");\n-\n-        if (plusIndex> 0){\n+        if (plusIndex > 0) {\n             significand = base30StringNoSign.substring(0, plusIndex);\n-            exponent = Long.valueOf( base30StringNoSign.substring(plusIndex+1), oldBase );\n-\n-        } else if (minusIndex > 0){\n+            exponent = Long.valueOf(base30StringNoSign.substring(plusIndex + 1), oldBase);\n+        } else if (minusIndex > 0) {\n             significand = base30StringNoSign.substring(0, minusIndex);\n-            exponent = -1 * Long.valueOf( base30StringNoSign.substring(minusIndex+1), oldBase );\n-\n+            exponent = -1 * Long.valueOf(base30StringNoSign.substring(minusIndex + 1), oldBase);\n         } else {\n             significand = base30StringNoSign;\n         }\n \n \n         // \"move\" decimal point; for each shift right, subtract one from exponent; end result is a string with no decimal\n+\n         int decimalIndex = significand.indexOf(\".\");\n         if (decimalIndex != -1) {\n-            exponent -= (significand.length() - (decimalIndex + 1) );\n-            significand = significand.substring(0, decimalIndex) + significand.substring( decimalIndex + 1 );\n+            exponent -= (significand.length() - (decimalIndex + 1));\n+            significand = significand.substring(0, decimalIndex) + significand.substring(decimalIndex + 1);\n         }\n \n         // TODO: Verify that the MathContext/Rounding methods are OK:\n         // -- L.A. 4.0 beta\n-        MathContext mc = new MathContext(15,RoundingMode.HALF_UP);\n+\n+        MathContext mc = new MathContext(15, RoundingMode.HALF_UP);\n         long base10Significand = Long.parseLong(significand, oldBase);\n-        BigDecimal base10value = new BigDecimal( String.valueOf(base10Significand), mc );\n+        BigDecimal base10value = new BigDecimal(String.valueOf(base10Significand), mc);\n         BigDecimal exponentialComponent = new BigDecimal(\"1\", mc);\n-\n-        for (int g=0; g < Math.abs(exponent); g++) {\n+        for (int g = 0; g < Math.abs(exponent); g++) {\n             exponentialComponent = exponentialComponent.multiply(new BigDecimal(\"30\", mc));\n         }\n \n-        if (exponent >= 0) {\n+        if (exponent >=0) {\n             base10value = base10value.multiply(exponentialComponent, mc);\n         } else {\n             base10value = base10value.divide(exponentialComponent, mc);\n         }\n \n         // negative sign if applicable\n-        if (isNegativeNumber){\n+\n+        if (isNegativeNumber) {\n             base10value = base10value.multiply(new BigDecimal(\"-1\", mc));\n         }\n-\n         return base10value.doubleValue();\n     }\n-    \n+\n     void assignValueLabels(Map<String, Map<String, String>> valueLabelTable) {\n         // Let's go through all the categorical value label mappings and \n         // assign them to the correct variables: \n-        \n         for (DataVariable dataVariable : dataTable.getDataVariables()) {\n             String varName = dataVariable.getName();\n-            \n             Map<String, String> valueLabelPairs = valueLabelTable.get(valueVariableMappingTable.get(varName));\n             if (valueLabelPairs != null && !valueLabelPairs.isEmpty()) {\n                 for (String value : valueLabelPairs.keySet()) {\n-                    \n                     VariableCategory cat = new VariableCategory();\n                     cat.setValue(value);\n                     cat.setLabel(valueLabelPairs.get(value));\n@@ -1685,33 +1539,28 @@ public class PORFileReader  extends TabularDataFileReader{\n             }\n         }\n     }\n-    \n-    private void print2Darray(Object[][] datatable, String title){\n+\n+    private void print2Darray(Object[][] datatable, String title) {\n         dbgLog.fine(title);\n+\n         for (Object[] datatable1 : datatable) {\n             dbgLog.fine(StringUtils.join(datatable1, \"|\"));\n         }\n-    }    \n-    \n-    private Map<String,String> createLabelMap (File extendedLabelsFile) {\n-        Map<String,String> varLabelMap = new HashMap<>();\n+    }\n+\n+    private Map<String, String> createLabelMap(File extendedLabelsFile) {\n+        Map<String, String> varLabelMap = new HashMap<>();\n \n         // Simply open the text file supplied, and read the variable-lable                                                                   \n         // pairs supplied:                                                                                                                   \n-\n         BufferedReader labelsFileReader = null;\n-\n         try {\n             labelsFileReader = new BufferedReader(new InputStreamReader(new FileInputStream(extendedLabelsFile)));\n-\n             String inLine;\n-\n-            while ((inLine = labelsFileReader.readLine() ) != null) {\n+            while ((inLine = labelsFileReader.readLine()) != null) {\n                 String[] valueTokens = inLine.split(\"\\t\", 2);\n-\n-                if (valueTokens[0] != null && !\"\".equals(valueTokens[0]) &&\n-                    valueTokens[1] != null && !\"\".equals(valueTokens[1])) {\n-\n+                if (valueTokens[0] != null && !\"\".equals(valueTokens[0])\n+                && valueTokens[1] != null && !\"\".equals(valueTokens[1])) {\n                     valueTokens[1] = valueTokens[1].replaceAll(\"[\\n\\r]\", \"\");\n                     // A very temporary fix for the varstr limit in the database!\n                     // -- L.A. 4.0 beta 11\n@@ -1722,7 +1571,6 @@ public class PORFileReader  extends TabularDataFileReader{\n                     varLabelMap.put(valueTokens[0], valueTokens[1]);\n                 }\n             }\n-\n         } catch (java.io.FileNotFoundException fnfex) {\n             dbgLog.warning(\"Ingest: could not open Extended Labels file\");\n             dbgLog.warning(fnfex.getMessage());\n@@ -1733,13 +1581,11 @@ public class PORFileReader  extends TabularDataFileReader{\n             return null;\n         } finally {\n             if (labelsFileReader != null) {\n-                try {labelsFileReader.close();}catch(Exception x){};\n+                try {\n+                    labelsFileReader.close();\n+                } catch (Exception x) {};\n             }\n         }\n-\n         return varLabelMap;\n     }\n-\n-    \n-}\n-\n+}\n\\ No newline at end of file\n",
            "diff_size": 719
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/2/PORFileReader.java\nindex c90b0ea6950..7f6f9cff717 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/2/PORFileReader.java\n@@ -1733,7 +1733,8 @@ public class PORFileReader  extends TabularDataFileReader{\n             return null;\n         } finally {\n             if (labelsFileReader != null) {\n-                try {labelsFileReader.close();}catch(Exception x){};\n+                try {\n+                  labelsFileReader.close();}catch(Exception x){};\n             }\n         }\n \n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/2/PORFileReader.java\nindex c90b0ea6950..bd0f8fbcddd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/2/PORFileReader.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/2/PORFileReader.java\n@@ -1733,7 +1733,8 @@ public class PORFileReader  extends TabularDataFileReader{\n             return null;\n         } finally {\n             if (labelsFileReader != null) {\n-                try {labelsFileReader.close();}catch(Exception x){};\n+                try {\n+                    labelsFileReader.close();}catch(Exception x){};\n             }\n         }\n \n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}