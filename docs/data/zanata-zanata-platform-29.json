{
    "project_name": "zanata-zanata-platform",
    "error_id": "29",
    "information": {
        "errors": [
            {
                "line": "192",
                "column": "9",
                "severity": "error",
                "message": "'for' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "    private final List<Integer> getContentStateOrdinals(Collection<ContentState>... contentStatesCollection) {\n        Set<Integer> results = Sets.newHashSet();\n        for(Collection<ContentState> contentStates: contentStatesCollection) {\n            results.addAll(contentStates.stream()\n                .map((Function<ContentState, Integer>) ContentState::ordinal)\n                .collect(Collectors.toList()));",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/29/TextFlowTargetHistoryDAO.java\nindex e9b0432b9df..c698af39300 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/29/TextFlowTargetHistoryDAO.java\n@@ -189,7 +189,7 @@ public class TextFlowTargetHistoryDAO extends\n     @SafeVarargs\n     private final List<Integer> getContentStateOrdinals(Collection<ContentState>... contentStatesCollection) {\n         Set<Integer> results = Sets.newHashSet();\n-        for(Collection<ContentState> contentStates: contentStatesCollection) {\n+        for (Collection<ContentState> contentStates: contentStatesCollection) {\n             results.addAll(contentStates.stream()\n                 .map((Function<ContentState, Integer>) ContentState::ordinal)\n                 .collect(Collectors.toList()));\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/29/TextFlowTargetHistoryDAO.java\nindex e9b0432b9df..36479e0aeb9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/29/TextFlowTargetHistoryDAO.java\n@@ -18,6 +18,7 @@\n  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n  */\n+\n package org.zanata.dao;\n \n import java.util.Collection;\n@@ -53,352 +54,347 @@ import org.zanata.rest.service.StatisticsServiceImpl.UserMatrixResultTransformer\n @Named(\"textFlowTargetHistoryDAO\")\n @RequestScoped\n public class TextFlowTargetHistoryDAO extends\n-        AbstractDAOImpl<HTextFlowTargetHistory, Long> {\n+  AbstractDAOImpl<HTextFlowTargetHistory, Long> {\n \n-    private static final long serialVersionUID = -2556266468897519199L;\n+  private static final long serialVersionUID = -2556266468897519199L;\n \n-    public TextFlowTargetHistoryDAO() {\n-        super(HTextFlowTargetHistory.class);\n-    }\n+  public TextFlowTargetHistoryDAO() {\n+    super(HTextFlowTargetHistory.class);\n+  }\n \n-    public TextFlowTargetHistoryDAO(Session session) {\n-        super(HTextFlowTargetHistory.class, session);\n-    }\n+  public TextFlowTargetHistoryDAO(Session session) {\n+    super(HTextFlowTargetHistory.class, session);\n+  }\n \n-    /**\n-     * Query to get total wordCount of a person(translated_by_id) from\n-     * HTextFlowTarget union HTextFlowTargetHistory tables\n-     * in a project-version, within given date range group by state and locale.\n-     *\n-     * HTextFlowTargetHistory:\n-     * gets latest of all records translated from user in given version,\n-     * locale and dateRange and its target is not translated by same person.\n-     *\n-     * HTextFlowTarget:\n-     * gets all records translated from user in given version, locale and\n-     * dateRange.\n-     *\n-     * @param versionId HProjectIteration identifier\n-     * @param personId HPerson identifier\n-     * @param from start of date range\n-     * @param to end of date range\n-     *\n-     * @return list of Object[wordCount][contentState][localeId]\n-     */\n-    @NativeQuery\n-    public List<Object[]> getUserTranslationStatisticInVersion(\n-            Long versionId, Long personId, Date fromDate, Date toDate, boolean automatedEntry) {\n-        Query query = buildContributionStatisticQuery(true, versionId,\n-            personId, fromDate, toDate, automatedEntry);\n-        query.setComment(\"textFlowTargetHistoryDAO.getUserTranslationStatisticInVersion\");\n-        @SuppressWarnings(\"unchecked\")\n-        List<Object[]> list = query.list();\n-        return list;\n-    }\n+  /**\n+   * Query to get total wordCount of a person(translated_by_id) from\n+   * HTextFlowTarget union HTextFlowTargetHistory tables\n+   * in a project-version, within given date range group by state and locale.\n+   * <p>\n+   * HTextFlowTargetHistory:\n+   * gets latest of all records translated from user in given version,\n+   * locale and dateRange and its target is not translated by same person.\n+   * <p>\n+   * HTextFlowTarget:\n+   * gets all records translated from user in given version, locale and\n+   * dateRange.\n+   *\n+   * @param versionId HProjectIteration identifier\n+   * @param personId  HPerson identifier\n+   * @param from      start of date range\n+   * @param to        end of date range\n+   * @return list of Object[wordCount][contentState][localeId]\n+   */\n+  @NativeQuery\n+  public List<Object[]> getUserTranslationStatisticInVersion(\n+    Long versionId, Long personId, Date fromDate, Date toDate, boolean automatedEntry) {\n+    Query query = buildContributionStatisticQuery(true, versionId,\n+      personId, fromDate, toDate, automatedEntry);\n+    query.setComment(\"textFlowTargetHistoryDAO.getUserTranslationStatisticInVersion\");\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object[]> list = query.list();\n+    return list;\n+  }\n \n-    /**\n-     * Query to get total wordCount of a person(reviewed_by_id) from\n-     * HTextFlowTarget union HTextFlowTargetHistory tables\n-     * in a project-version, within given date range group by state and locale.\n-     *\n-     * HTextFlowTargetHistory:\n-     * gets latest of all records reviewed from user in given version,\n-     * locale and dateRange and its target is not translated by same person.\n-     *\n-     * HTextFlowTarget:\n-     * gets all records reviewed from user in given version, locale and\n-     * dateRange.\n-     *\n-     * @param versionId HProjectIteration identifier\n-     * @param personId HPerson identifier\n-     * @param from start of date range\n-     * @param to end of date range\n-     *\n-     * @return list of Object[wordCount][contentState][localeId]\n-     */\n-    @NativeQuery\n-    public List<Object[]> getUserReviewStatisticInVersion(\n-            Long versionId, Long personId, Date fromDate, Date toDate,\n-            boolean automatedEntry) {\n-        Query query = buildContributionStatisticQuery(false, versionId,\n-                personId, fromDate, toDate, automatedEntry);\n-        query.setComment(\"textFlowTargetHistoryDAO.getUserReviewStatisticInVersion\");\n-        @SuppressWarnings(\"unchecked\")\n-        List<Object[]> list = query.list();\n-        return list;\n-    }\n+  /**\n+   * Query to get total wordCount of a person(reviewed_by_id) from\n+   * HTextFlowTarget union HTextFlowTargetHistory tables\n+   * in a project-version, within given date range group by state and locale.\n+   * <p>\n+   * HTextFlowTargetHistory:\n+   * gets latest of all records reviewed from user in given version,\n+   * locale and dateRange and its target is not translated by same person.\n+   * <p>\n+   * HTextFlowTarget:\n+   * gets all records reviewed from user in given version, locale and\n+   * dateRange.\n+   *\n+   * @param versionId HProjectIteration identifier\n+   * @param personId  HPerson identifier\n+   * @param from      start of date range\n+   * @param to        end of date range\n+   * @return list of Object[wordCount][contentState][localeId]\n+   */\n+  @NativeQuery\n+  public List<Object[]> getUserReviewStatisticInVersion(\n+    Long versionId, Long personId, Date fromDate, Date toDate,\n+    boolean automatedEntry) {\n+    Query query = buildContributionStatisticQuery(false, versionId,\n+      personId, fromDate, toDate, automatedEntry);\n+    query.setComment(\"textFlowTargetHistoryDAO.getUserReviewStatisticInVersion\");\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object[]> list = query.list();\n+    return list;\n+  }\n \n-    private Query buildContributionStatisticQuery(boolean translations,\n-            Long versionId, Long personId, Date fromDate, Date toDate,\n-            boolean automatedEntry) {\n-        String lastModifiedColumn =\n-                translations ? \"translated_by_id\" : \"reviewed_by_id\";\n+  private Query buildContributionStatisticQuery(boolean translations,\n+                                                Long versionId, Long personId, Date fromDate, Date toDate,\n+                                                boolean automatedEntry) {\n+    String lastModifiedColumn =\n+      translations ? \"translated_by_id\" : \"reviewed_by_id\";\n \n-        StringBuilder queryString = new StringBuilder();\n-        queryString\n-            .append(\"select sum(wordCount), state, localeId from \")\n-            .append(\"(select wordCount, id, state, localeId from \")\n-            .append(\"(select h.state, tft.id, h.\").append(lastModifiedColumn).append(\", tf.wordCount, locale.localeId \")\n-            .append(\"from HTextFlowTargetHistory h \")\n-            .append(\"JOIN HTextFlowTarget tft ON tft.id = h.target_id \")\n-            .append(\"JOIN HLocale locale ON locale.id = tft.locale \")\n-            .append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \")\n-            .append(\"JOIN HDocument doc ON doc.id = tf.document_Id \")\n-            .append(\"where doc.project_iteration_id =:versionId \")\n-            .append(\"and h.state in (:states) \")\n-            .append(\"and h.\").append(lastModifiedColumn).append(\" =:personId \")\n-            .append(\"and h.lastChanged between :fromDate and :toDate \")\n-            .append(\"and h.automatedEntry =:automatedEntry \")\n-            .append(\"and tft.\").append(lastModifiedColumn).append(\" <> h.\").append(lastModifiedColumn).append(\" \")\n-            .append(\"and h.lastChanged = \")\n-            .append(\n-                \"(select max(lastChanged) from HTextFlowTargetHistory where h.target_id = target_id) \")\n-            .append(\"union all \")\n-            .append(\"select tft.state, tft.id, tft.\").append(lastModifiedColumn).append(\", tf.wordCount, locale.localeId \")\n-            .append(\"from HTextFlowTarget tft \")\n-            .append(\"JOIN HLocale locale ON locale.id = tft.locale \")\n-            .append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \")\n-            .append(\"JOIN HDocument doc ON doc.id = tf.document_Id \")\n-            .append(\"where doc.project_iteration_id =:versionId \")\n-            .append(\"and tft.state in (:states) \")\n-            .append(\"and tft.automatedEntry =:automatedEntry \")\n-            .append(\"and tft.\").append(lastModifiedColumn).append(\" =:personId \")\n-            .append(\"and tft.lastChanged between :fromDate and :toDate \")\n-            .append(\") as target_history_union \")\n-            .append(\"group by state, id, localeId, wordCount) as target_history_group \")\n-            .append(\"group by state, localeId\");\n+    StringBuilder queryString = new StringBuilder();\n+    queryString\n+      .append(\"select sum(wordCount), state, localeId from \")\n+      .append(\"(select wordCount, id, state, localeId from \")\n+      .append(\"(select h.state, tft.id, h.\").append(lastModifiedColumn).append(\", tf.wordCount, locale.localeId \")\n+      .append(\"from HTextFlowTargetHistory h \")\n+      .append(\"JOIN HTextFlowTarget tft ON tft.id = h.target_id \")\n+      .append(\"JOIN HLocale locale ON locale.id = tft.locale \")\n+      .append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \")\n+      .append(\"JOIN HDocument doc ON doc.id = tf.document_Id \")\n+      .append(\"where doc.project_iteration_id =:versionId \")\n+      .append(\"and h.state in (:states) \")\n+      .append(\"and h.\").append(lastModifiedColumn).append(\" =:personId \")\n+      .append(\"and h.lastChanged between :fromDate and :toDate \")\n+      .append(\"and h.automatedEntry =:automatedEntry \")\n+      .append(\"and tft.\").append(lastModifiedColumn).append(\" <> h.\").append(lastModifiedColumn).append(\" \")\n+      .append(\"and h.lastChanged = \")\n+      .append(\n+        \"(select max(lastChanged) from HTextFlowTargetHistory where h.target_id = target_id) \")\n+      .append(\"union all \")\n+      .append(\"select tft.state, tft.id, tft.\").append(lastModifiedColumn).append(\", tf.wordCount, locale.localeId \")\n+      .append(\"from HTextFlowTarget tft \")\n+      .append(\"JOIN HLocale locale ON locale.id = tft.locale \")\n+      .append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \")\n+      .append(\"JOIN HDocument doc ON doc.id = tf.document_Id \")\n+      .append(\"where doc.project_iteration_id =:versionId \")\n+      .append(\"and tft.state in (:states) \")\n+      .append(\"and tft.automatedEntry =:automatedEntry \")\n+      .append(\"and tft.\").append(lastModifiedColumn).append(\" =:personId \")\n+      .append(\"and tft.lastChanged between :fromDate and :toDate \")\n+      .append(\") as target_history_union \")\n+      .append(\"group by state, id, localeId, wordCount) as target_history_group \")\n+      .append(\"group by state, localeId\");\n \n-        Query query = getSession().createSQLQuery(queryString.toString());\n-        query.setParameter(\"versionId\", versionId);\n-        query.setParameter(\"personId\", personId);\n-        if (translations) {\n-            query.setParameterList(\"states\",\n-                    getContentStateOrdinals(ContentState.TRANSLATED_STATES,\n-                            ContentState.DRAFT_STATES));\n-        } else {\n-            query.setParameterList(\"states\",\n-                    getContentStateOrdinals(ContentState.REVIEWED_STATES));\n-        }\n-        query.setBoolean(\"automatedEntry\", automatedEntry);\n-        query.setTimestamp(\"fromDate\", fromDate);\n-        query.setTimestamp(\"toDate\", toDate);\n-        return query;\n+    Query query = getSession().createSQLQuery(queryString.toString());\n+    query.setParameter(\"versionId\", versionId);\n+    query.setParameter(\"personId\", personId);\n+    if (translations) {\n+      query.setParameterList(\"states\",\n+        getContentStateOrdinals(ContentState.TRANSLATED_STATES,\n+          ContentState.DRAFT_STATES));\n+    } else {\n+      query.setParameterList(\"states\",\n+        getContentStateOrdinals(ContentState.REVIEWED_STATES));\n     }\n+    query.setBoolean(\"automatedEntry\", automatedEntry);\n+    query.setTimestamp(\"fromDate\", fromDate);\n+    query.setTimestamp(\"toDate\", toDate);\n+    return query;\n+  }\n \n-    // safe because we just iterate over the varargs array\n-    @SafeVarargs\n-    private final List<Integer> getContentStateOrdinals(Collection<ContentState>... contentStatesCollection) {\n-        Set<Integer> results = Sets.newHashSet();\n-        for(Collection<ContentState> contentStates: contentStatesCollection) {\n-            results.addAll(contentStates.stream()\n-                .map((Function<ContentState, Integer>) ContentState::ordinal)\n-                .collect(Collectors.toList()));\n-        }\n-        return Lists.newArrayList(results);\n+  // safe because we just iterate over the varargs array\n+  @SafeVarargs\n+  private final List<Integer> getContentStateOrdinals(Collection<ContentState>... contentStatesCollection) {\n+    Set<Integer> results = Sets.newHashSet();\n+    for (Collection<ContentState> contentStates : contentStatesCollection) {\n+      results.addAll(contentStates.stream()\n+        .map((Function<ContentState, Integer>) ContentState::ordinal)\n+        .collect(Collectors.toList()));\n     }\n+    return Lists.newArrayList(results);\n+  }\n \n-    public boolean findContentInHistory(HTextFlowTarget target,\n-            List<String> contents) {\n-        // Ordinal parameters can't be used in NamedQueries due to the following\n-        // bug:\n-        // https://hibernate.onjira.com/browse/HHH-5653\n-        Query query;\n+  public boolean findContentInHistory(HTextFlowTarget target,\n+                                      List<String> contents) {\n+    // Ordinal parameters can't be used in NamedQueries due to the following\n+    // bug:\n+    // https://hibernate.onjira.com/browse/HHH-5653\n+    Query query;\n \n-        // use named queries for the smaller more common cases\n-        if (contents.size() <= 6) {\n-            query =\n-                    getSession().getNamedQuery(\n-                            HTextFlowTargetHistory\n-                                    .getQueryNameMatchingHistory(contents\n-                                            .size()));\n-        } else {\n-            StringBuilder queryStr =\n-                    new StringBuilder(\n-                            \"select count(*) from HTextFlowTargetHistory t where t.textFlowTarget = :tft and size(t.contents) = :contentCount\");\n-            for (int i = 0; i < contents.size(); i++) {\n-                queryStr.append(\" and contents[\" + i + \"] = :content\" + i);\n-            }\n-            query = getSession().createQuery(queryStr.toString());\n-        }\n-        query.setParameter(\"tft\", target);\n-        query.setParameter(\"contentCount\", contents.size());\n-        int paramPos = 0;\n-        for (String c : contents) {\n-            query.setParameter(\"content\" + paramPos++, c);\n-        }\n-        query.setComment(\"TextFlowTargetHistoryDAO.findContentInHistory-\"\n-                + contents.size());\n-        return (Long) query.uniqueResult() != 0;\n+    // use named queries for the smaller more common cases\n+    if (contents.size() <= 6) {\n+      query =\n+        getSession().getNamedQuery(\n+          HTextFlowTargetHistory\n+            .getQueryNameMatchingHistory(contents\n+              .size()));\n+    } else {\n+      StringBuilder queryStr =\n+        new StringBuilder(\n+          \"select count(*) from HTextFlowTargetHistory t where t.textFlowTarget = :tft and size(t.contents) = :contentCount\");\n+      for (int i = 0; i < contents.size(); i++) {\n+        queryStr.append(\" and contents[\" + i + \"] = :content\" + i);\n+      }\n+      query = getSession().createQuery(queryStr.toString());\n     }\n-\n-    public boolean findConflictInHistory(HTextFlowTarget target,\n-            Integer verNum, String username) {\n-        Query query =\n-                getSession()\n-                        .createQuery(\n-                                \"select count(*) from HTextFlowTargetHistory t where t.textFlowTarget.id =:id and t.textFlowRevision > :ver and t.lastModifiedBy.account.username != :username\");\n-        query.setParameter(\"id\", target.getId());\n-        query.setParameter(\"ver\", verNum);\n-        query.setParameter(\"username\", username);\n-        query.setComment(\"TextFlowTargetHistoryDAO.findConflictInHistory\");\n-        Long count = (Long) query.uniqueResult();\n-        return count != 0;\n+    query.setParameter(\"tft\", target);\n+    query.setParameter(\"contentCount\", contents.size());\n+    int paramPos = 0;\n+    for (String c : contents) {\n+      query.setParameter(\"content\" + paramPos++, c);\n     }\n+    query.setComment(\"TextFlowTargetHistoryDAO.findContentInHistory-\"\n+      + contents.size());\n+    return (Long) query.uniqueResult() != 0;\n+  }\n \n-    /**\n-     * Query to get total wordCount of a person(translated_by_id or\n-     * reviewed_by_id) from HTextFlowTarget union HTextFlowTargetHistory tables\n-     * within given date range group by lastChangeDate (date portion only),\n-     * project version, locale and state.\n-     *\n-     * HTextFlowTargetHistory: gets all records translated from user in any\n-     * version, any locale and dateRange.\n-     *\n-     * HTextFlowTarget: gets all records translated from user in any version,\n-     * any locale and dateRange.\n-     *\n-     * @param user\n-     *            a HPerson person\n-     * @param fromDate\n-     *            date from\n-     * @param toDate\n-     *            date to\n-     *\n-     * @param userZoneOpt\n-     *            optional DateTimeZone of the user. Only present if it's\n-     *            different from system time zone\n-     * @param systemZone\n-     *            current system time zone\n-     * @param resultTransformer\n-     *            result transformer to transform query results\n-     * @return a list of transformed object\n-     */\n-    @NativeQuery(value = \"need to use union\", specificTo = \"mysql due to usage of date() and convert_tz() functions.\")\n-    public List<TranslationMatrix> getUserTranslationMatrix(\n-            HPerson user, DateTime fromDate, DateTime toDate,\n-            Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone,\n-            UserMatrixResultTransformer resultTransformer) {\n-        // @formatter:off\n-        String queryHistory = \"select history.id, iter.id as iteration, tft.locale as locale, tf.wordCount as wordCount, history.state as state, history.lastChanged as lastChanged \" +\n-                \"  from HTextFlowTargetHistory history \" +\n-                \"    join HTextFlowTarget tft on tft.id = history.target_id \" +\n-                \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n-                \"    join HDocument doc on doc.id = tf.document_id \" +\n-                \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n-                \"  where history.lastChanged >= :fromDate and history.lastChanged <= :toDate \" +\n-                \"    and history.last_modified_by_id = :user and (history.translated_by_id is not null or history.reviewed_by_id is not null)\" +\n-                \"    and history.state <> :untranslated and history.state <> :rejected and history.automatedEntry =:automatedEntry\";\n+  public boolean findConflictInHistory(HTextFlowTarget target,\n+                                       Integer verNum, String username) {\n+    Query query =\n+      getSession()\n+        .createQuery(\n+          \"select count(*) from HTextFlowTargetHistory t where t.textFlowTarget.id =:id and t.textFlowRevision > :ver and t.lastModifiedBy.account.username != :username\");\n+    query.setParameter(\"id\", target.getId());\n+    query.setParameter(\"ver\", verNum);\n+    query.setParameter(\"username\", username);\n+    query.setComment(\"TextFlowTargetHistoryDAO.findConflictInHistory\");\n+    Long count = (Long) query.uniqueResult();\n+    return count != 0;\n+  }\n \n-        String queryTarget = \"select tft.id, iter.id as iteration, tft.locale as locale, tf.wordCount as wordCount, tft.state as state, tft.lastChanged as lastChanged \" +\n-                \"  from HTextFlowTarget tft \" +\n-                \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n-                \"    join HDocument doc on doc.id = tf.document_id \" +\n-                \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n-                \"  where tft.lastChanged >= :fromDate and tft.lastChanged <= :toDate \" +\n-                \"    and tft.last_modified_by_id = :user and (tft.translated_by_id is not null or tft.reviewed_by_id is not null)\" +\n-                \"    and tft.state <> :untranslated and tft.state <> :rejected and tft.automatedEntry =:automatedEntry\";\n+  /**\n+   * Query to get total wordCount of a person(translated_by_id or\n+   * reviewed_by_id) from HTextFlowTarget union HTextFlowTargetHistory tables\n+   * within given date range group by lastChangeDate (date portion only),\n+   * project version, locale and state.\n+   * <p>\n+   * HTextFlowTargetHistory: gets all records translated from user in any\n+   * version, any locale and dateRange.\n+   * <p>\n+   * HTextFlowTarget: gets all records translated from user in any version,\n+   * any locale and dateRange.\n+   *\n+   * @param user              a HPerson person\n+   * @param fromDate          date from\n+   * @param toDate            date to\n+   * @param userZoneOpt       optional DateTimeZone of the user. Only present if it's\n+   *                          different from system time zone\n+   * @param systemZone        current system time zone\n+   * @param resultTransformer result transformer to transform query results\n+   * @return a list of transformed object\n+   */\n+  @NativeQuery(value = \"need to use union\", specificTo = \"mysql due to usage of date() and convert_tz() functions.\")\n+  public List<TranslationMatrix> getUserTranslationMatrix(\n+    HPerson user, DateTime fromDate, DateTime toDate,\n+    Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone,\n+    UserMatrixResultTransformer resultTransformer) {\n+    // @formatter:off\n+    String queryHistory =\n+      \"select history.id, iter.id as iteration, tft.locale as locale, tf.wordCount as wordCount, history.state as state, history.lastChanged as lastChanged \" +\n+        \"  from HTextFlowTargetHistory history \" +\n+        \"    join HTextFlowTarget tft on tft.id = history.target_id \" +\n+        \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n+        \"    join HDocument doc on doc.id = tf.document_id \" +\n+        \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n+        \"  where history.lastChanged >= :fromDate and history.lastChanged <= :toDate \" +\n+        \"    and history.last_modified_by_id = :user and (history.translated_by_id is not null or history.reviewed_by_id is not null)\" +\n+        \"    and history.state <> :untranslated and history.state <> :rejected and history.automatedEntry =:automatedEntry\";\n \n-        String convertedLastChanged = convertTimeZoneFunction(\"lastChanged\",\n-                userZoneOpt, systemZone);\n-        // @formatter:on\n-        String dateOfLastChanged = stripTimeFromDateTimeFunction(convertedLastChanged);\n-        String queryString =\n-                \"select \" + dateOfLastChanged + \", iteration, locale, state, sum(wordCount)\" +\n-                        \"  from (\" +\n-                        \"  (\" + queryHistory + \") union (\" + queryTarget + \")\" +\n-                        \"  ) as all_translation\" +\n-                        \"  group by \" + dateOfLastChanged + \", iteration, locale, state \" +\n-                        \"  order by lastChanged, iteration, locale, state\";\n-        Query query = getSession().createSQLQuery(queryString)\n-            .setParameter(\"user\", user.getId())\n-            .setInteger(\"untranslated\", ContentState.New.ordinal())\n-                .setInteger(\"rejected\", ContentState.Rejected.ordinal())\n-            .setBoolean(\"automatedEntry\", false)\n-            .setTimestamp(\"fromDate\", fromDate.toDate())\n-            .setTimestamp(\"toDate\", toDate.toDate())\n-            .setResultTransformer(resultTransformer);\n-        @SuppressWarnings(\"unchecked\")\n-        List<TranslationMatrix> list = query.list();\n-        return list;\n-    }\n+    String queryTarget =\n+      \"select tft.id, iter.id as iteration, tft.locale as locale, tf.wordCount as wordCount, tft.state as state, tft.lastChanged as lastChanged \" +\n+        \"  from HTextFlowTarget tft \" +\n+        \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n+        \"    join HDocument doc on doc.id = tf.document_id \" +\n+        \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n+        \"  where tft.lastChanged >= :fromDate and tft.lastChanged <= :toDate \" +\n+        \"    and tft.last_modified_by_id = :user and (tft.translated_by_id is not null or tft.reviewed_by_id is not null)\" +\n+        \"    and tft.state <> :untranslated and tft.state <> :rejected and tft.automatedEntry =:automatedEntry\";\n \n-    /**\n-     * Get words statistics of a project version in given timeframe.\n-     */\n-    @NativeQuery(value = \"need to use union\", specificTo = \"mysql due to usage of date() and convert_tz() functions.\")\n-    public List<ProjectStatisticsMatrix> getProjectTranslationMatrix(\n-            HProjectIteration version, DateTime fromDate, DateTime toDate,\n-            Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone,\n-            ProjectMatrixResultTransformer resultTransformer) {\n-        // @formatter:off\n-        String queryHistory = \"select history.id, tft.locale as locale, tf.wordCount as wordCount, history.state as state, history.lastChanged as lastChanged \" +\n-                \"  from HTextFlowTargetHistory history \" +\n-                \"    join HTextFlowTarget tft on tft.id = history.target_id \" +\n-                \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n-                \"    join HDocument doc on doc.id = tf.document_id \" +\n-                \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n-                \"  where iter.id = :versionId \" +\n-                \"    and history.lastChanged >= :fromDate and history.lastChanged <= :toDate \" +\n-                \"    and history.automatedEntry =:automatedEntry\";\n+    String convertedLastChanged = convertTimeZoneFunction(\"lastChanged\",\n+      userZoneOpt, systemZone);\n+    // @formatter:on\n+    String dateOfLastChanged = stripTimeFromDateTimeFunction(convertedLastChanged);\n+    String queryString =\n+      \"select \" + dateOfLastChanged + \", iteration, locale, state, sum(wordCount)\" +\n+        \"  from (\" +\n+        \"  (\" + queryHistory + \") union (\" + queryTarget + \")\" +\n+        \"  ) as all_translation\" +\n+        \"  group by \" + dateOfLastChanged + \", iteration, locale, state \" +\n+        \"  order by lastChanged, iteration, locale, state\";\n+    Query query = getSession().createSQLQuery(queryString)\n+      .setParameter(\"user\", user.getId())\n+      .setInteger(\"untranslated\", ContentState.New.ordinal())\n+      .setInteger(\"rejected\", ContentState.Rejected.ordinal())\n+      .setBoolean(\"automatedEntry\", false)\n+      .setTimestamp(\"fromDate\", fromDate.toDate())\n+      .setTimestamp(\"toDate\", toDate.toDate())\n+      .setResultTransformer(resultTransformer);\n+    @SuppressWarnings(\"unchecked\")\n+    List<TranslationMatrix> list = query.list();\n+    return list;\n+  }\n \n-        String queryTarget = \"select tft.id, tft.locale as locale, tf.wordCount as wordCount, tft.state as state, tft.lastChanged as lastChanged \" +\n-                \"  from HTextFlowTarget tft \" +\n-                \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n-                \"    join HDocument doc on doc.id = tf.document_id \" +\n-                \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n-                \"  where iter.id = :versionId \" +\n-                \"    and tft.lastChanged >= :fromDate and tft.lastChanged <= :toDate \" +\n-                \"    and tft.automatedEntry =:automatedEntry\";\n+  /**\n+   * Get words statistics of a project version in given timeframe.\n+   */\n+  @NativeQuery(value = \"need to use union\", specificTo = \"mysql due to usage of date() and convert_tz() functions.\")\n+  public List<ProjectStatisticsMatrix> getProjectTranslationMatrix(\n+    HProjectIteration version, DateTime fromDate, DateTime toDate,\n+    Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone,\n+    ProjectMatrixResultTransformer resultTransformer) {\n+    // @formatter:off\n+    String queryHistory =\n+      \"select history.id, tft.locale as locale, tf.wordCount as wordCount, history.state as state, history.lastChanged as lastChanged \" +\n+        \"  from HTextFlowTargetHistory history \" +\n+        \"    join HTextFlowTarget tft on tft.id = history.target_id \" +\n+        \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n+        \"    join HDocument doc on doc.id = tf.document_id \" +\n+        \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n+        \"  where iter.id = :versionId \" +\n+        \"    and history.lastChanged >= :fromDate and history.lastChanged <= :toDate \" +\n+        \"    and history.automatedEntry =:automatedEntry\";\n \n-        String convertedLastChanged = convertTimeZoneFunction(\"lastChanged\",\n-                userZoneOpt, systemZone);\n-        // @formatter:on\n-        String dateOfLastChanged = stripTimeFromDateTimeFunction(convertedLastChanged);\n-        String queryString =\n-                \"select \" + dateOfLastChanged + \", locale, state, sum(wordCount)\" +\n-                        \"  from (\" +\n-                        \"  (\" + queryHistory + \") union (\" + queryTarget + \")\" +\n-                        \"  ) as all_translation\" +\n-                        \"  group by \" + dateOfLastChanged + \", locale, state \" +\n-                        \"  order by lastChanged, locale, state\";\n-        Query query = getSession().createSQLQuery(queryString)\n-                .setParameter(\"versionId\", version.getId())\n-                .setBoolean(\"automatedEntry\", false)\n-                .setTimestamp(\"fromDate\", fromDate.toDate())\n-                .setTimestamp(\"toDate\", toDate.toDate())\n-                .setResultTransformer(resultTransformer);\n-        @SuppressWarnings(\"unchecked\")\n-        List<ProjectStatisticsMatrix> list = query.list();\n-        return list;\n-    }\n+    String queryTarget =\n+      \"select tft.id, tft.locale as locale, tf.wordCount as wordCount, tft.state as state, tft.lastChanged as lastChanged \" +\n+        \"  from HTextFlowTarget tft \" +\n+        \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n+        \"    join HDocument doc on doc.id = tf.document_id \" +\n+        \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n+        \"  where iter.id = :versionId \" +\n+        \"    and tft.lastChanged >= :fromDate and tft.lastChanged <= :toDate \" +\n+        \"    and tft.automatedEntry =:automatedEntry\";\n \n-    @VisibleForTesting\n-    protected String convertTimeZoneFunction(String columnName,\n-            Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone) {\n-        if (userZoneOpt.isPresent()) {\n-            String userOffset = getOffsetAsString(userZoneOpt.get());\n-            String systemOffset = getOffsetAsString(systemZone);\n-            return String.format(\"CONVERT_TZ(%s, '%s', '%s')\", columnName, systemOffset, userOffset);\n-        }\n-        // no need to convert timezone\n-        return columnName;\n-    }\n+    String convertedLastChanged = convertTimeZoneFunction(\"lastChanged\",\n+      userZoneOpt, systemZone);\n+    // @formatter:on\n+    String dateOfLastChanged = stripTimeFromDateTimeFunction(convertedLastChanged);\n+    String queryString =\n+      \"select \" + dateOfLastChanged + \", locale, state, sum(wordCount)\" +\n+        \"  from (\" +\n+        \"  (\" + queryHistory + \") union (\" + queryTarget + \")\" +\n+        \"  ) as all_translation\" +\n+        \"  group by \" + dateOfLastChanged + \", locale, state \" +\n+        \"  order by lastChanged, locale, state\";\n+    Query query = getSession().createSQLQuery(queryString)\n+      .setParameter(\"versionId\", version.getId())\n+      .setBoolean(\"automatedEntry\", false)\n+      .setTimestamp(\"fromDate\", fromDate.toDate())\n+      .setTimestamp(\"toDate\", toDate.toDate())\n+      .setResultTransformer(resultTransformer);\n+    @SuppressWarnings(\"unchecked\")\n+    List<ProjectStatisticsMatrix> list = query.list();\n+    return list;\n+  }\n \n-    // This is so we can override it in test and be able to test it against h2\n-    @VisibleForTesting\n-    protected String stripTimeFromDateTimeFunction(String columnName) {\n-        return \"date(\" + columnName + \")\";\n+  @VisibleForTesting\n+  protected String convertTimeZoneFunction(String columnName,\n+                                           Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone) {\n+    if (userZoneOpt.isPresent()) {\n+      String userOffset = getOffsetAsString(userZoneOpt.get());\n+      String systemOffset = getOffsetAsString(systemZone);\n+      return String.format(\"CONVERT_TZ(%s, '%s', '%s')\", columnName, systemOffset, userOffset);\n     }\n+    // no need to convert timezone\n+    return columnName;\n+  }\n+\n+  // This is so we can override it in test and be able to test it against h2\n+  @VisibleForTesting\n+  protected String stripTimeFromDateTimeFunction(String columnName) {\n+    return \"date(\" + columnName + \")\";\n+  }\n \n-    private static String getOffsetAsString(DateTimeZone zone) {\n-        int standardOffset = zone.getStandardOffset(0);\n-        String prefix = \"\";\n-        if (standardOffset < 0) {\n-            prefix = \"-\";\n-            standardOffset = -standardOffset;\n-        }\n-        return String.format(\"%s%02d:00\", prefix,\n-                TimeUnit.MILLISECONDS.toHours(standardOffset));\n+  private static String getOffsetAsString(DateTimeZone zone) {\n+    int standardOffset = zone.getStandardOffset(0);\n+    String prefix = \"\";\n+    if (standardOffset < 0) {\n+      prefix = \"-\";\n+      standardOffset = -standardOffset;\n     }\n+    return String.format(\"%s%02d:00\", prefix,\n+      TimeUnit.MILLISECONDS.toHours(standardOffset));\n+  }\n \n }\n",
            "diff_size": 403
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/29/TextFlowTargetHistoryDAO.java\nindex e9b0432b9df..ad0dd5e4c7d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/29/TextFlowTargetHistoryDAO.java\n@@ -135,8 +135,7 @@ public class TextFlowTargetHistoryDAO extends\n                 translations ? \"translated_by_id\" : \"reviewed_by_id\";\n \n         StringBuilder queryString = new StringBuilder();\n-        queryString\n-            .append(\"select sum(wordCount), state, localeId from \")\n+        queryString.append(\"select sum(wordCount), state, localeId from \")\n             .append(\"(select wordCount, id, state, localeId from \")\n             .append(\"(select h.state, tft.id, h.\").append(lastModifiedColumn).append(\", tf.wordCount, locale.localeId \")\n             .append(\"from HTextFlowTargetHistory h \")\n@@ -189,7 +188,7 @@ public class TextFlowTargetHistoryDAO extends\n     @SafeVarargs\n     private final List<Integer> getContentStateOrdinals(Collection<ContentState>... contentStatesCollection) {\n         Set<Integer> results = Sets.newHashSet();\n-        for(Collection<ContentState> contentStates: contentStatesCollection) {\n+        for (Collection<ContentState> contentStates: contentStatesCollection) {\n             results.addAll(contentStates.stream()\n                 .map((Function<ContentState, Integer>) ContentState::ordinal)\n                 .collect(Collectors.toList()));\n@@ -208,10 +207,9 @@ public class TextFlowTargetHistoryDAO extends\n         if (contents.size() <= 6) {\n             query =\n                     getSession().getNamedQuery(\n-                            HTextFlowTargetHistory\n-                                    .getQueryNameMatchingHistory(contents\n+                            HTextFlowTargetHistory.getQueryNameMatchingHistory(contents\n                                             .size()));\n-        } else {\n+    } else {\n             StringBuilder queryStr =\n                     new StringBuilder(\n                             \"select count(*) from HTextFlowTargetHistory t where t.textFlowTarget = :tft and size(t.contents) = :contentCount\");\n@@ -401,4 +399,4 @@ public class TextFlowTargetHistoryDAO extends\n                 TimeUnit.MILLISECONDS.toHours(standardOffset));\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/29/TextFlowTargetHistoryDAO.java\nindex e9b0432b9df..04acbbc88bd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/29/TextFlowTargetHistoryDAO.java\n@@ -27,10 +27,8 @@ import java.util.Set;\n import java.util.concurrent.TimeUnit;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-\n import org.hibernate.Query;\n import org.hibernate.Session;\n-\n import javax.enterprise.context.RequestScoped;\n import javax.inject.Named;\n import org.joda.time.DateTime;\n@@ -40,7 +38,6 @@ import org.zanata.model.HPerson;\n import org.zanata.model.HProjectIteration;\n import org.zanata.model.HTextFlowTarget;\n import org.zanata.model.HTextFlowTargetHistory;\n-\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Optional;\n import com.google.common.collect.Lists;\n@@ -50,11 +47,10 @@ import org.zanata.rest.dto.TranslationMatrix;\n import org.zanata.rest.service.StatisticsServiceImpl.ProjectMatrixResultTransformer;\n import org.zanata.rest.service.StatisticsServiceImpl.UserMatrixResultTransformer;\n \n+\n @Named(\"textFlowTargetHistoryDAO\")\n @RequestScoped\n-public class TextFlowTargetHistoryDAO extends\n-        AbstractDAOImpl<HTextFlowTargetHistory, Long> {\n-\n+public class TextFlowTargetHistoryDAO extends AbstractDAOImpl<HTextFlowTargetHistory, Long> {\n     private static final long serialVersionUID = -2556266468897519199L;\n \n     public TextFlowTargetHistoryDAO() {\n@@ -85,11 +81,10 @@ public class TextFlowTargetHistoryDAO extends\n      *\n      * @return list of Object[wordCount][contentState][localeId]\n      */\n+\n     @NativeQuery\n-    public List<Object[]> getUserTranslationStatisticInVersion(\n-            Long versionId, Long personId, Date fromDate, Date toDate, boolean automatedEntry) {\n-        Query query = buildContributionStatisticQuery(true, versionId,\n-            personId, fromDate, toDate, automatedEntry);\n+    public List<Object[]> getUserTranslationStatisticInVersion(Long versionId, Long personId, Date fromDate, Date toDate, boolean automatedEntry) {\n+        Query query = buildContributionStatisticQuery(true, versionId, personId, fromDate, toDate, automatedEntry);\n         query.setComment(\"textFlowTargetHistoryDAO.getUserTranslationStatisticInVersion\");\n         @SuppressWarnings(\"unchecked\")\n         List<Object[]> list = query.list();\n@@ -116,12 +111,10 @@ public class TextFlowTargetHistoryDAO extends\n      *\n      * @return list of Object[wordCount][contentState][localeId]\n      */\n+\n     @NativeQuery\n-    public List<Object[]> getUserReviewStatisticInVersion(\n-            Long versionId, Long personId, Date fromDate, Date toDate,\n-            boolean automatedEntry) {\n-        Query query = buildContributionStatisticQuery(false, versionId,\n-                personId, fromDate, toDate, automatedEntry);\n+    public List<Object[]> getUserReviewStatisticInVersion(Long versionId, Long personId, Date fromDate, Date toDate, boolean automatedEntry) {\n+        Query query = buildContributionStatisticQuery(false, versionId, personId, fromDate, toDate, automatedEntry);\n         query.setComment(\"textFlowTargetHistoryDAO.getUserReviewStatisticInVersion\");\n         @SuppressWarnings(\"unchecked\")\n         List<Object[]> list = query.list();\n@@ -129,55 +122,20 @@ public class TextFlowTargetHistoryDAO extends\n     }\n \n     private Query buildContributionStatisticQuery(boolean translations,\n-            Long versionId, Long personId, Date fromDate, Date toDate,\n-            boolean automatedEntry) {\n-        String lastModifiedColumn =\n-                translations ? \"translated_by_id\" : \"reviewed_by_id\";\n-\n+            Long versionId,\n+            Long personId,\n+            Date fromDate,\n+            Date toDate, boolean automatedEntry) {\n+        String lastModifiedColumn = translations ? \"translated_by_id\" : \"reviewed_by_id\";\n         StringBuilder queryString = new StringBuilder();\n-        queryString\n-            .append(\"select sum(wordCount), state, localeId from \")\n-            .append(\"(select wordCount, id, state, localeId from \")\n-            .append(\"(select h.state, tft.id, h.\").append(lastModifiedColumn).append(\", tf.wordCount, locale.localeId \")\n-            .append(\"from HTextFlowTargetHistory h \")\n-            .append(\"JOIN HTextFlowTarget tft ON tft.id = h.target_id \")\n-            .append(\"JOIN HLocale locale ON locale.id = tft.locale \")\n-            .append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \")\n-            .append(\"JOIN HDocument doc ON doc.id = tf.document_Id \")\n-            .append(\"where doc.project_iteration_id =:versionId \")\n-            .append(\"and h.state in (:states) \")\n-            .append(\"and h.\").append(lastModifiedColumn).append(\" =:personId \")\n-            .append(\"and h.lastChanged between :fromDate and :toDate \")\n-            .append(\"and h.automatedEntry =:automatedEntry \")\n-            .append(\"and tft.\").append(lastModifiedColumn).append(\" <> h.\").append(lastModifiedColumn).append(\" \")\n-            .append(\"and h.lastChanged = \")\n-            .append(\n-                \"(select max(lastChanged) from HTextFlowTargetHistory where h.target_id = target_id) \")\n-            .append(\"union all \")\n-            .append(\"select tft.state, tft.id, tft.\").append(lastModifiedColumn).append(\", tf.wordCount, locale.localeId \")\n-            .append(\"from HTextFlowTarget tft \")\n-            .append(\"JOIN HLocale locale ON locale.id = tft.locale \")\n-            .append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \")\n-            .append(\"JOIN HDocument doc ON doc.id = tf.document_Id \")\n-            .append(\"where doc.project_iteration_id =:versionId \")\n-            .append(\"and tft.state in (:states) \")\n-            .append(\"and tft.automatedEntry =:automatedEntry \")\n-            .append(\"and tft.\").append(lastModifiedColumn).append(\" =:personId \")\n-            .append(\"and tft.lastChanged between :fromDate and :toDate \")\n-            .append(\") as target_history_union \")\n-            .append(\"group by state, id, localeId, wordCount) as target_history_group \")\n-            .append(\"group by state, localeId\");\n-\n+        queryString.append(\"select sum(wordCount), state, localeId from \").append(\"(select wordCount, id, state, localeId from \").append(\"(select h.state, tft.id, h.\").append(lastModifiedColumn).append(\", tf.wordCount, locale.localeId \").append(\"from HTextFlowTargetHistory h \").append(\"JOIN HTextFlowTarget tft ON tft.id = h.target_id \").append(\"JOIN HLocale locale ON locale.id = tft.locale \").append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \").append(\"JOIN HDocument doc ON doc.id = tf.document_Id \").append(\"where doc.project_iteration_id =:versionId \").append(\"and h.state in (:states) \").append(\"and h.\").append(lastModifiedColumn).append(\" =:personId \").append(\"and h.lastChanged between :fromDate and :toDate \").append(\"and h.automatedEntry =:automatedEntry \").append(\"and tft.\").append(lastModifiedColumn).append(\" <> h.\").append(lastModifiedColumn).append(\" \").append(\"and h.lastChanged = \").append(\"(select max(lastChanged) from HTextFlowTargetHistory where h.target_id = target_id) \").append(\"union all \").append(\"select tft.state, tft.id, tft.\").append(lastModifiedColumn).append(\", tf.wordCount, locale.localeId \").append(\"from HTextFlowTarget tft \").append(\"JOIN HLocale locale ON locale.id = tft.locale \").append(\"JOIN HTextFlow tf ON tf.id = tft.tf_id \").append(\"JOIN HDocument doc ON doc.id = tf.document_Id \").append(\"where doc.project_iteration_id =:versionId \").append(\"and tft.state in (:states) \").append(\"and tft.automatedEntry =:automatedEntry \").append(\"and tft.\").append(lastModifiedColumn).append(\" =:personId \").append(\"and tft.lastChanged between :fromDate and :toDate \").append(\") as target_history_union \").append(\"group by state, id, localeId, wordCount) as target_history_group \").append(\"group by state, localeId\");\n         Query query = getSession().createSQLQuery(queryString.toString());\n         query.setParameter(\"versionId\", versionId);\n         query.setParameter(\"personId\", personId);\n         if (translations) {\n-            query.setParameterList(\"states\",\n-                    getContentStateOrdinals(ContentState.TRANSLATED_STATES,\n-                            ContentState.DRAFT_STATES));\n+            query.setParameterList(\"states\", getContentStateOrdinals(ContentState.TRANSLATED_STATES, ContentState.DRAFT_STATES));\n         } else {\n-            query.setParameterList(\"states\",\n-                    getContentStateOrdinals(ContentState.REVIEWED_STATES));\n+            query.setParameterList(\"states\", getContentStateOrdinals(ContentState.REVIEWED_STATES));\n         }\n         query.setBoolean(\"automatedEntry\", automatedEntry);\n         query.setTimestamp(\"fromDate\", fromDate);\n@@ -186,19 +144,17 @@ public class TextFlowTargetHistoryDAO extends\n     }\n \n     // safe because we just iterate over the varargs array\n+\n     @SafeVarargs\n     private final List<Integer> getContentStateOrdinals(Collection<ContentState>... contentStatesCollection) {\n         Set<Integer> results = Sets.newHashSet();\n-        for(Collection<ContentState> contentStates: contentStatesCollection) {\n-            results.addAll(contentStates.stream()\n-                .map((Function<ContentState, Integer>) ContentState::ordinal)\n-                .collect(Collectors.toList()));\n+        for (Collection<ContentState> contentStates : contentStatesCollection) {\n+            results.addAll(contentStates.stream().map((Function<ContentState, Integer>) ContentState::ordinal).collect(Collectors.toList()));\n         }\n         return Lists.newArrayList(results);\n     }\n \n-    public boolean findContentInHistory(HTextFlowTarget target,\n-            List<String> contents) {\n+    public boolean findContentInHistory(HTextFlowTarget target, List<String> contents) {\n         // Ordinal parameters can't be used in NamedQueries due to the following\n         // bug:\n         // https://hibernate.onjira.com/browse/HHH-5653\n@@ -206,15 +162,9 @@ public class TextFlowTargetHistoryDAO extends\n \n         // use named queries for the smaller more common cases\n         if (contents.size() <= 6) {\n-            query =\n-                    getSession().getNamedQuery(\n-                            HTextFlowTargetHistory\n-                                    .getQueryNameMatchingHistory(contents\n-                                            .size()));\n+            query = getSession().getNamedQuery(HTextFlowTargetHistory.getQueryNameMatchingHistory(contents.size()));\n         } else {\n-            StringBuilder queryStr =\n-                    new StringBuilder(\n-                            \"select count(*) from HTextFlowTargetHistory t where t.textFlowTarget = :tft and size(t.contents) = :contentCount\");\n+            StringBuilder queryStr = new StringBuilder(\"select count(*) from HTextFlowTargetHistory t where t.textFlowTarget = :tft and size(t.contents) = :contentCount\");\n             for (int i = 0; i < contents.size(); i++) {\n                 queryStr.append(\" and contents[\" + i + \"] = :content\" + i);\n             }\n@@ -226,17 +176,12 @@ public class TextFlowTargetHistoryDAO extends\n         for (String c : contents) {\n             query.setParameter(\"content\" + paramPos++, c);\n         }\n-        query.setComment(\"TextFlowTargetHistoryDAO.findContentInHistory-\"\n-                + contents.size());\n+        query.setComment(\"TextFlowTargetHistoryDAO.findContentInHistory-\" + contents.size());\n         return (Long) query.uniqueResult() != 0;\n     }\n \n-    public boolean findConflictInHistory(HTextFlowTarget target,\n-            Integer verNum, String username) {\n-        Query query =\n-                getSession()\n-                        .createQuery(\n-                                \"select count(*) from HTextFlowTargetHistory t where t.textFlowTarget.id =:id and t.textFlowRevision > :ver and t.lastModifiedBy.account.username != :username\");\n+    public boolean findConflictInHistory(HTextFlowTarget target, Integer verNum, String username) {\n+        Query query = getSession().createQuery(\"select count(*) from HTextFlowTargetHistory t where t.textFlowTarget.id =:id and t.textFlowRevision > :ver and t.lastModifiedBy.account.username != :username\");\n         query.setParameter(\"id\", target.getId());\n         query.setParameter(\"ver\", verNum);\n         query.setParameter(\"username\", username);\n@@ -273,50 +218,22 @@ public class TextFlowTargetHistoryDAO extends\n      *            result transformer to transform query results\n      * @return a list of transformed object\n      */\n-    @NativeQuery(value = \"need to use union\", specificTo = \"mysql due to usage of date() and convert_tz() functions.\")\n-    public List<TranslationMatrix> getUserTranslationMatrix(\n-            HPerson user, DateTime fromDate, DateTime toDate,\n-            Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone,\n-            UserMatrixResultTransformer resultTransformer) {\n-        // @formatter:off\n-        String queryHistory = \"select history.id, iter.id as iteration, tft.locale as locale, tf.wordCount as wordCount, history.state as state, history.lastChanged as lastChanged \" +\n-                \"  from HTextFlowTargetHistory history \" +\n-                \"    join HTextFlowTarget tft on tft.id = history.target_id \" +\n-                \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n-                \"    join HDocument doc on doc.id = tf.document_id \" +\n-                \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n-                \"  where history.lastChanged >= :fromDate and history.lastChanged <= :toDate \" +\n-                \"    and history.last_modified_by_id = :user and (history.translated_by_id is not null or history.reviewed_by_id is not null)\" +\n-                \"    and history.state <> :untranslated and history.state <> :rejected and history.automatedEntry =:automatedEntry\";\n-\n-        String queryTarget = \"select tft.id, iter.id as iteration, tft.locale as locale, tf.wordCount as wordCount, tft.state as state, tft.lastChanged as lastChanged \" +\n-                \"  from HTextFlowTarget tft \" +\n-                \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n-                \"    join HDocument doc on doc.id = tf.document_id \" +\n-                \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n-                \"  where tft.lastChanged >= :fromDate and tft.lastChanged <= :toDate \" +\n-                \"    and tft.last_modified_by_id = :user and (tft.translated_by_id is not null or tft.reviewed_by_id is not null)\" +\n-                \"    and tft.state <> :untranslated and tft.state <> :rejected and tft.automatedEntry =:automatedEntry\";\n \n-        String convertedLastChanged = convertTimeZoneFunction(\"lastChanged\",\n-                userZoneOpt, systemZone);\n+    @NativeQuery(value = \"need to use union\",\n+                 specificTo = \"mysql due to usage of date() and convert_tz() functions.\")\n+    public List<TranslationMatrix> getUserTranslationMatrix(HPerson user,\n+        DateTime fromDate,\n+            DateTime toDate,\n+                Optional<DateTimeZone> userZoneOpt,\n+                    DateTimeZone systemZone, UserMatrixResultTransformer resultTransformer) {\n+        // @formatter:off\n+        String queryHistory = \"select history.id, iter.id as iteration, tft.locale as locale, tf.wordCount as wordCount, history.state as state, history.lastChanged as lastChanged \" + \"  from HTextFlowTargetHistory history \" + \"    join HTextFlowTarget tft on tft.id = history.target_id \" + \"    join HTextFlow tf on tf.id = tft.tf_id \" + \"    join HDocument doc on doc.id = tf.document_id \" + \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" + \"  where history.lastChanged >= :fromDate and history.lastChanged <= :toDate \" + \"    and history.last_modified_by_id = :user and (history.translated_by_id is not null or history.reviewed_by_id is not null)\" + \"    and history.state <> :untranslated and history.state <> :rejected and history.automatedEntry =:automatedEntry\";\n+        String queryTarget = \"select tft.id, iter.id as iteration, tft.locale as locale, tf.wordCount as wordCount, tft.state as state, tft.lastChanged as lastChanged \" + \"  from HTextFlowTarget tft \" + \"    join HTextFlow tf on tf.id = tft.tf_id \" + \"    join HDocument doc on doc.id = tf.document_id \" + \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" + \"  where tft.lastChanged >= :fromDate and tft.lastChanged <= :toDate \" + \"    and tft.last_modified_by_id = :user and (tft.translated_by_id is not null or tft.reviewed_by_id is not null)\" + \"    and tft.state <> :untranslated and tft.state <> :rejected and tft.automatedEntry =:automatedEntry\";\n+        String convertedLastChanged = convertTimeZoneFunction(\"lastChanged\", userZoneOpt, systemZone);\n         // @formatter:on\n         String dateOfLastChanged = stripTimeFromDateTimeFunction(convertedLastChanged);\n-        String queryString =\n-                \"select \" + dateOfLastChanged + \", iteration, locale, state, sum(wordCount)\" +\n-                        \"  from (\" +\n-                        \"  (\" + queryHistory + \") union (\" + queryTarget + \")\" +\n-                        \"  ) as all_translation\" +\n-                        \"  group by \" + dateOfLastChanged + \", iteration, locale, state \" +\n-                        \"  order by lastChanged, iteration, locale, state\";\n-        Query query = getSession().createSQLQuery(queryString)\n-            .setParameter(\"user\", user.getId())\n-            .setInteger(\"untranslated\", ContentState.New.ordinal())\n-                .setInteger(\"rejected\", ContentState.Rejected.ordinal())\n-            .setBoolean(\"automatedEntry\", false)\n-            .setTimestamp(\"fromDate\", fromDate.toDate())\n-            .setTimestamp(\"toDate\", toDate.toDate())\n-            .setResultTransformer(resultTransformer);\n+        String queryString = \"select \" + dateOfLastChanged + \", iteration, locale, state, sum(wordCount)\" + \"  from (\" + \"  (\" + queryHistory + \") union (\" + queryTarget + \")\" + \"  ) as all_translation\" + \"  group by \" + dateOfLastChanged + \", iteration, locale, state \" + \"  order by lastChanged, iteration, locale, state\";\n+        Query query = getSession().createSQLQuery(queryString).setParameter(\"user\", user.getId()).setInteger(\"untranslated\", ContentState.New.ordinal()).setInteger(\"rejected\", ContentState.Rejected.ordinal()).setBoolean(\"automatedEntry\", false).setTimestamp(\"fromDate\", fromDate.toDate()).setTimestamp(\"toDate\", toDate.toDate()).setResultTransformer(resultTransformer);\n         @SuppressWarnings(\"unchecked\")\n         List<TranslationMatrix> list = query.list();\n         return list;\n@@ -325,56 +242,29 @@ public class TextFlowTargetHistoryDAO extends\n     /**\n      * Get words statistics of a project version in given timeframe.\n      */\n-    @NativeQuery(value = \"need to use union\", specificTo = \"mysql due to usage of date() and convert_tz() functions.\")\n-    public List<ProjectStatisticsMatrix> getProjectTranslationMatrix(\n-            HProjectIteration version, DateTime fromDate, DateTime toDate,\n-            Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone,\n-            ProjectMatrixResultTransformer resultTransformer) {\n-        // @formatter:off\n-        String queryHistory = \"select history.id, tft.locale as locale, tf.wordCount as wordCount, history.state as state, history.lastChanged as lastChanged \" +\n-                \"  from HTextFlowTargetHistory history \" +\n-                \"    join HTextFlowTarget tft on tft.id = history.target_id \" +\n-                \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n-                \"    join HDocument doc on doc.id = tf.document_id \" +\n-                \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n-                \"  where iter.id = :versionId \" +\n-                \"    and history.lastChanged >= :fromDate and history.lastChanged <= :toDate \" +\n-                \"    and history.automatedEntry =:automatedEntry\";\n \n-        String queryTarget = \"select tft.id, tft.locale as locale, tf.wordCount as wordCount, tft.state as state, tft.lastChanged as lastChanged \" +\n-                \"  from HTextFlowTarget tft \" +\n-                \"    join HTextFlow tf on tf.id = tft.tf_id \" +\n-                \"    join HDocument doc on doc.id = tf.document_id \" +\n-                \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" +\n-                \"  where iter.id = :versionId \" +\n-                \"    and tft.lastChanged >= :fromDate and tft.lastChanged <= :toDate \" +\n-                \"    and tft.automatedEntry =:automatedEntry\";\n-\n-        String convertedLastChanged = convertTimeZoneFunction(\"lastChanged\",\n-                userZoneOpt, systemZone);\n+    @NativeQuery(value = \"need to use union\",\n+                 specificTo = \"mysql due to usage of date() and convert_tz() functions.\")\n+    public List<ProjectStatisticsMatrix> getProjectTranslationMatrix(HProjectIteration version,\n+        DateTime fromDate,\n+            DateTime toDate,\n+                Optional<DateTimeZone> userZoneOpt,\n+                    DateTimeZone systemZone, ProjectMatrixResultTransformer resultTransformer) {\n+        // @formatter:off\n+        String queryHistory = \"select history.id, tft.locale as locale, tf.wordCount as wordCount, history.state as state, history.lastChanged as lastChanged \" + \"  from HTextFlowTargetHistory history \" + \"    join HTextFlowTarget tft on tft.id = history.target_id \" + \"    join HTextFlow tf on tf.id = tft.tf_id \" + \"    join HDocument doc on doc.id = tf.document_id \" + \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" + \"  where iter.id = :versionId \" + \"    and history.lastChanged >= :fromDate and history.lastChanged <= :toDate \" + \"    and history.automatedEntry =:automatedEntry\";\n+        String queryTarget = \"select tft.id, tft.locale as locale, tf.wordCount as wordCount, tft.state as state, tft.lastChanged as lastChanged \" + \"  from HTextFlowTarget tft \" + \"    join HTextFlow tf on tf.id = tft.tf_id \" + \"    join HDocument doc on doc.id = tf.document_id \" + \"    join HProjectIteration iter on iter.id = doc.project_iteration_id \" + \"  where iter.id = :versionId \" + \"    and tft.lastChanged >= :fromDate and tft.lastChanged <= :toDate \" + \"    and tft.automatedEntry =:automatedEntry\";\n+        String convertedLastChanged = convertTimeZoneFunction(\"lastChanged\", userZoneOpt, systemZone);\n         // @formatter:on\n         String dateOfLastChanged = stripTimeFromDateTimeFunction(convertedLastChanged);\n-        String queryString =\n-                \"select \" + dateOfLastChanged + \", locale, state, sum(wordCount)\" +\n-                        \"  from (\" +\n-                        \"  (\" + queryHistory + \") union (\" + queryTarget + \")\" +\n-                        \"  ) as all_translation\" +\n-                        \"  group by \" + dateOfLastChanged + \", locale, state \" +\n-                        \"  order by lastChanged, locale, state\";\n-        Query query = getSession().createSQLQuery(queryString)\n-                .setParameter(\"versionId\", version.getId())\n-                .setBoolean(\"automatedEntry\", false)\n-                .setTimestamp(\"fromDate\", fromDate.toDate())\n-                .setTimestamp(\"toDate\", toDate.toDate())\n-                .setResultTransformer(resultTransformer);\n+        String queryString = \"select \" + dateOfLastChanged + \", locale, state, sum(wordCount)\" + \"  from (\" + \"  (\" + queryHistory + \") union (\" + queryTarget + \")\" + \"  ) as all_translation\" + \"  group by \" + dateOfLastChanged + \", locale, state \" + \"  order by lastChanged, locale, state\";\n+        Query query = getSession().createSQLQuery(queryString).setParameter(\"versionId\", version.getId()).setBoolean(\"automatedEntry\", false).setTimestamp(\"fromDate\", fromDate.toDate()).setTimestamp(\"toDate\", toDate.toDate()).setResultTransformer(resultTransformer);\n         @SuppressWarnings(\"unchecked\")\n         List<ProjectStatisticsMatrix> list = query.list();\n         return list;\n     }\n \n     @VisibleForTesting\n-    protected String convertTimeZoneFunction(String columnName,\n-            Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone) {\n+    protected String convertTimeZoneFunction(String columnName, Optional<DateTimeZone> userZoneOpt, DateTimeZone systemZone) {\n         if (userZoneOpt.isPresent()) {\n             String userOffset = getOffsetAsString(userZoneOpt.get());\n             String systemOffset = getOffsetAsString(systemZone);\n@@ -385,6 +275,7 @@ public class TextFlowTargetHistoryDAO extends\n     }\n \n     // This is so we can override it in test and be able to test it against h2\n+\n     @VisibleForTesting\n     protected String stripTimeFromDateTimeFunction(String columnName) {\n         return \"date(\" + columnName + \")\";\n@@ -397,8 +288,6 @@ public class TextFlowTargetHistoryDAO extends\n             prefix = \"-\";\n             standardOffset = -standardOffset;\n         }\n-        return String.format(\"%s%02d:00\", prefix,\n-                TimeUnit.MILLISECONDS.toHours(standardOffset));\n+        return String.format(\"%s%02d:00\", prefix, TimeUnit.MILLISECONDS.toHours(standardOffset));\n     }\n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 180
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/29/TextFlowTargetHistoryDAO.java\nindex e9b0432b9df..c698af39300 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/29/TextFlowTargetHistoryDAO.java\n@@ -189,7 +189,7 @@ public class TextFlowTargetHistoryDAO extends\n     @SafeVarargs\n     private final List<Integer> getContentStateOrdinals(Collection<ContentState>... contentStatesCollection) {\n         Set<Integer> results = Sets.newHashSet();\n-        for(Collection<ContentState> contentStates: contentStatesCollection) {\n+        for (Collection<ContentState> contentStates: contentStatesCollection) {\n             results.addAll(contentStates.stream()\n                 .map((Function<ContentState, Integer>) ContentState::ordinal)\n                 .collect(Collectors.toList()));\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/29/TextFlowTargetHistoryDAO.java\nindex e9b0432b9df..c698af39300 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/29/TextFlowTargetHistoryDAO.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/29/TextFlowTargetHistoryDAO.java\n@@ -189,7 +189,7 @@ public class TextFlowTargetHistoryDAO extends\n     @SafeVarargs\n     private final List<Integer> getContentStateOrdinals(Collection<ContentState>... contentStatesCollection) {\n         Set<Integer> results = Sets.newHashSet();\n-        for(Collection<ContentState> contentStates: contentStatesCollection) {\n+        for (Collection<ContentState> contentStates: contentStatesCollection) {\n             results.addAll(contentStates.stream()\n                 .map((Function<ContentState, Integer>) ContentState::ordinal)\n                 .collect(Collectors.toList()));\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}