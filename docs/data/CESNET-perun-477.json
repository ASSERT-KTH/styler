{
    "project_name": "CESNET-perun",
    "error_id": "477",
    "information": {
        "errors": [
            {
                "line": "692",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks whether the object is null or not.\n\t *",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/477/BeansUtils.java\nindex ece5548a061..414fb3dac3d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/477/BeansUtils.java\n@@ -689,7 +689,7 @@ public class BeansUtils {\n \t\tlog.debug(\"Read only configuration found='{}', set to false.\", initializatorEnabled);\n \t\treturn false;\n \t}\n-\t\n+\n \t/**\n \t * Checks whether the object is null or not.\n \t *\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/477/BeansUtils.java\nindex ece5548a061..aee7adfa1f4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/477/BeansUtils.java\n@@ -2,6 +2,7 @@ package cz.metacentrum.perun.core.api;\n \n import cz.metacentrum.perun.core.api.exceptions.ConsistencyErrorException;\n import cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\n+\n import java.io.BufferedInputStream;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n@@ -18,718 +19,748 @@ import java.util.Properties;\n import java.util.Set;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  * Beans Utilities.\n- *\n  */\n public class BeansUtils {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(BeansUtils.class);\n-\n-\tprivate final static Pattern patternForCommonNameParsing = Pattern.compile(\"(([\\\\w]*. )*)([\\\\p{L}-']+) ([\\\\p{L}-']+)[, ]*(.*)\");\n-\tprivate final static Pattern richBeanNamePattern = Pattern.compile(\"^Rich([A-Z].*$)\");\n-\tpublic static final char LIST_DELIMITER = ',';\n-\tpublic static final char KEY_VALUE_DELIMITER = ':';\n-\tprivate final static int MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE = 1000;\n-\tpublic final static String configurationsLocations = \"/etc/perun/\";\n-\tprivate static Properties properties;\n-\tprivate static Boolean isPerunReadOnly = null;\n-\n-\t/**\n-\t * Method create formatter with default settings for perun timestamps and set lenient on false\n-\t * Timestamp format:  \"yyyy-MM-dd HH:mm:ss.S\" - \"ex. 2014-01-01 10:10:10.0\"\n-\t *\n-\t * Lenient on false means that formatter will be more strict to creating timestamp from string\n-\t *\n-\t * IMPORTANT: SimpleDateFormat is not thread safe !!!\n-\t *\n-\t * @return date formatter\n-\t */\n-\tpublic static DateFormat getDateFormatter() {\n-\t\tDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n-\t\tdf.setLenient(false);\n-\t\treturn df;\n-\t}\n-\n-\t/**\n-\t * Method create formatter with default settings for perun timestamps (only date without time)\n-\t * and set lenient on false.\n-\t *\n-\t * Timestamp format:  \"yyyy-MM-dd\" - \"ex. 2014-01-01\"\n-\t *\n-\t * Lenient on false means that formatter will be more strict to creating timestamp from string\n-\t *\n-\t * IMPORTANT: SimpleDateFormat is not thread safe !!!\n-\t *\n-\t * @return date formatter\n-\t */\n-\tpublic static DateFormat getDateFormatterWithoutTime() {\n-\t\tDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n-\t\tdf.setLenient(false);\n-\t\treturn df;\n-\t}\n-\n-\t/**\n-\t * This method take text and for every chars in \"<>\\\" erase escaping\n-\t * also change '\\0' to 'null' if it is escaped zero symbol.\n-\t *\n-\t * Escaping char is \\.\n-\t * Expecting: Before using this method, text must be escaped by using method createEscaping.\n-\t *            So in text will never be string like \"\\\\>\", \"\\\" or \"\\\\\\\".\n-\t *\n-\t * For every \\ in text it put \\\\ and for every < it put \\< and for every > it put \\>\n-\t *\n-\t * @param text text from which will be erase escaping\n-\t * @return nonescaped text\n-\t */\n-\tpublic static String eraseEscaping(String text) {\n-\t\tif(text == null || text.equals(\"\\\\0\")) return null;\n-\t\t//change \\0 to null if zero is escaped\n-\t\ttext = text.replaceAll(\"((^|[^\\\\\\\\])(\\\\\\\\\\\\\\\\)*)(\\\\\\\\0)\", \"$1null\");\n-\t\ttext = text.replace(\"\\\\>\", \">\");\n-\t\ttext = text.replace(\"\\\\<\", \"<\");\n-\t\ttext = text.replace(\"\\\\\\\\\", \"\\\\\");\n-\t\treturn text;\n-\t}\n-\t/**\n-\t * This method take text and for every chars in \"<>\\\" create escaping\n-\t * Escaping char is \\.\n-\t * For every \\\\ in text it put \\ and for every \\< it put < and for every \\> it put >\n-\t *\n-\t * @param text text from which will be erase escaping\n-\t * @return escaped text\n-\t */\n-\tpublic static String createEscaping(String text) {\n-\t\tif(text == null) return \"\\\\0\";\n-\t\ttext = text.replace(\"\\\\\", \"\\\\\\\\\");\n-\t\ttext = text.replace(\">\", \"\\\\>\");\n-\t\ttext = text.replace(\"<\", \"\\\\<\");\n-\t\treturn text;\n-\t}\n-\n-\t/**\n-\t * This method get text and all nonescaped characters < and > replace by apostrophe\n-\t *\n-\t * @param text\n-\t * @return text where nonescaped characters < and  > will be reaplace by apostrophe '\n-\t */\n-\tpublic static String replacePointyBracketsByApostrophe(String text) {\n-\t\tStringBuilder stringBuilder = new StringBuilder(text);\n-\t\tfor(int i=0; i<text.length(); i++) {\n-\t\t\tif(text.charAt(i)=='<' || text.charAt(i)=='>') {\n-\t\t\t\tif(!isEscaped(text, i-1)) {\n-\t\t\t\t\tstringBuilder.setCharAt(i, '\\'');\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn stringBuilder.toString();\n-\t}\n-\n-\t/**\n-\t * This method get text and all escaped \\0 replace for text null\n-\t *\n-\t * @param text\n-\t * @return text where \\0 is replaced for null\n-\t */\n-\tpublic static String replaceEscapedNullByStringNull(String text) {\n-\t\tStringBuilder stringBuilder = new StringBuilder(text);\n-\t\tfor(int i=0; i<stringBuilder.length(); i++) {\n-\t\t\tif(stringBuilder.charAt(i)=='0') {\n-\t\t\t\tif(isEscaped(stringBuilder.toString(), i-1)) {\n-\t\t\t\t\tstringBuilder.replace(i-1, i+1, \"null\");\n-\t\t\t\t\ti=i+2;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn stringBuilder.toString();\n-\t}\n-\n-\t/**\n-\t * Return true, if char on position in text is escaped by '\\' Return false,\n-\t * if not.\n-\t *\n-\t * @param text text in which will be searching\n-\t * @param position position in text <0-text.length>\n-\t * @return true if char is escaped, false if not\n-\t */\n-\tpublic static boolean isEscaped(String text, int position) {\n-\t\tboolean escaped = false;\n-\t\twhile (text.charAt(position) == '\\\\') {\n-\t\t\tescaped = !escaped;\n-\t\t\tposition--;\n-\t\t\tif (position < 0) {\n-\t\t\t\treturn escaped;\n-\t\t\t}\n-\t\t}\n-\t\treturn escaped;\n-\t}\n-\n-\t/**\n-\t * Serialize map to string\n-\t *\n-\t * @param map\n-\t * @return string of escaped map\n-\t */\n-\tpublic static String serializeMapToString(Map<String, String> map) {\n-\t\tif(map == null) return \"\\\\0\";\n-\t\tMap<String, String> attrNew = new HashMap<String, String>(map);\n-\t\tSet<String> keys = new HashSet<String>(attrNew.keySet());\n-\t\tfor(String s: keys) {\n-\t\t\tattrNew.put(\"<\" + BeansUtils.createEscaping(s) + \">\", \"<\" + BeansUtils.createEscaping(attrNew.get(s)) + \">\");\n-\t\t\tattrNew.remove(s);\n-\t\t}\n-\t\treturn attrNew.toString();\n-\t}\n-\n-\n-\t/**\n-\t * Converts attribute value to string (for storing into DB)\n-\t *\n-\t * @param attribute value of the attribute\n-\t * @return string representation of the value\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tpublic static String attributeValueToString(Attribute attribute) throws InternalErrorException {\n-\t\tif(attribute == null) throw new InternalErrorException(new NullPointerException(\"attribute is null\"));\n-\t\tif(attribute.getValue() == null) return null;\n-\n-\t\tif(!attribute.getType().equals(attribute.getValue().getClass().getName())) {\n-\t\t\tthrow new InternalErrorException(\"Attribute's type mismatch \" + attribute + \". The type of attribute's value (\" + attribute.getValue().getClass().getName() + \") doesn't match the type of attribute (\" + attribute.getType() + \").\");\n-\t\t}\n-\n-\t\tif(attribute.getType().equals(String.class.getName())) {\n-\t\t\treturn (String) attribute.getValue();\n-\t\t} else if(attribute.getType().equals(Integer.class.getName())) {\n-\t\t\treturn Integer.toString((Integer) attribute.getValue());\n-\t\t} else if(attribute.getType().equals(Boolean.class.getName())) {\n-\t\t\treturn Boolean.toString((Boolean) attribute.getValue());\n-\t\t} else if(attribute.getType().equals(ArrayList.class.getName())) {\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tfor(String item : (List<String>) attribute.getValue()) {\n-\t\t\t\tif(item == null) {\n-\t\t\t\t\titem = \"\\\\0\";\n-\t\t\t\t} else {\n-\t\t\t\t\titem = item.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n-\t\t\t\t\titem = item.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n-\t\t\t\t}\n-\t\t\t\tsb.append(item);\n-\t\t\t\tsb.append(LIST_DELIMITER);\n-\t\t\t}\n-\t\t\treturn sb.toString();\n-\t\t} else if(attribute.getType().equals(LinkedHashMap.class.getName())) {\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tfor(Map.Entry<String, String> entry : ((Map<String, String>) attribute.getValue()).entrySet()) {\n-\t\t\t\tString key = entry.getKey();\n-\t\t\t\tif(key == null) {\n-\t\t\t\t\tkey = \"\\\\0\";\n-\t\t\t\t} else {\n-\t\t\t\t\tkey = key.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n-\t\t\t\t\tkey = key.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n-\t\t\t\t\tkey = key.replace(Character.toString(KEY_VALUE_DELIMITER), \"\\\\\" + KEY_VALUE_DELIMITER); //escape KEY_VALUE_DELIMITER\n-\t\t\t\t}\n-\n-\t\t\t\tString value = entry.getValue();\n-\t\t\t\tif(value == null) {\n-\t\t\t\t\tvalue = \"\\\\0\";\n-\t\t\t\t} else {\n-\t\t\t\t\tvalue = value.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n-\t\t\t\t\tvalue = value.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n-\t\t\t\t\tvalue = value.replace(Character.toString(KEY_VALUE_DELIMITER), \"\\\\\" + KEY_VALUE_DELIMITER); //escape KEY_VALUE_DELIMITER\n-\t\t\t\t}\n-\n-\t\t\t\tsb.append(key);\n-\t\t\t\tsb.append(KEY_VALUE_DELIMITER);\n-\t\t\t\tsb.append(value);\n-\t\t\t\tsb.append(LIST_DELIMITER);\n-\t\t\t}\n-\t\t\treturn sb.toString();\n-\t\t} else throw new InternalErrorException(\"Unknown java type of attribute's value.\");\n-\t}\n-\n-\t/**\n-\t * This method get map created by example : {<key1>=<value1>, <key2>=<value2>}\n-\t * Keys and values are escaped for \"\\\", \"<\" and \">\"\n-\t * Example of escaping key=\"key\\\\s\\>\" is \"key\\s>\"\n-\t * Return Map<String, String> attribute to value.\n-\t *\n-\t * @param text text from which will be parsed map\n-\t * @return map<string, string> attributes\n-\t */\n-\tpublic static Map<String, String> deserializeStringToMap(String text) {\n-\t\tif(text.equals(\"\\\\0\")) return null;\n-\t\tMap<String, String> map = new HashMap<String, String>();\n-\t\tint startName = -1;\n-\t\tint endName = -1;\n-\t\tint startValue = -1;\n-\t\tint endValue = -1;\n-\t\tint pointyBrackets = 0;\n-\t\tboolean notValue = true;\n-\n-\t\tfor(int i = 0; i < text.length(); i++) {\n-\t\t\tif(text.charAt(i) == '<' && notValue && startName == -1) {\n-\t\t\t\tif (!BeansUtils.isEscaped(text, i - 1)) {\n-\t\t\t\t\tstartName = i;\n-\t\t\t\t}\n-\t\t\t}else if(text.charAt(i) == '>' && notValue && endName == -1) {\n-\t\t\t\tif (!BeansUtils.isEscaped(text, i - 1)) {\n-\t\t\t\t\tendName = i;\n-\t\t\t\t\tnotValue = false;\n-\t\t\t\t}\n-\t\t\t} else if(text.charAt(i) == '<' && !notValue && startValue == -1) {\n-\t\t\t\tif (!BeansUtils.isEscaped(text, i - 1)) {\n-\t\t\t\t\tstartValue = i;\n-\t\t\t\t}\n-\t\t\t} else if(text.charAt(i) == '>' && !notValue && endValue == -1) {\n-\t\t\t\tif (!BeansUtils.isEscaped(text, i - 1)) {\n-\t\t\t\t\tendValue = i;\n-\t\t\t\t\tnotValue = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (startName != -1 && endName != -1 && startValue != -1 && endValue != -1) {\n-\t\t\t\tmap.put(BeansUtils.eraseEscaping(text.substring(startName + 1, endName)), BeansUtils.eraseEscaping(text.substring(startValue + 1, endValue)));\n-\t\t\t\tstartName = -1;\n-\t\t\t\tendName = -1;\n-\t\t\t\tstartValue = -1;\n-\t\t\t\tendValue = -1;\n-\t\t\t}\n-\t\t}\n-\t\treturn map;\n-\t}\n-\n-\t/**\n-\t * Converts string representation of an attribute value to correct java object\n-\t *\n-\t * @param stringValue string representation of the attribute value\n-\t * @param type type of the value (\"Java.lang.String\" for example)/\n-\t * @return\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tpublic static Object stringToAttributeValue(String stringValue, String type) throws InternalErrorException {\n-\t\tif(stringValue == null || stringValue.isEmpty()) return null;\n-\n-\t\tClass<?> attributeClass;\n-\t\ttry {\n-\t\t\tattributeClass = Class.forName(type);\n-\t\t} catch (ClassNotFoundException e) {\n-\t\t\tthrow new InternalErrorException(\"Unknown attribute type\", e);\n-\t\t} catch (NoClassDefFoundError e) {\n-\t\t\tthrow new InternalErrorException(\"Unknown attribute def type\", e);\n-\t\t}\n-\n-\t\tif(attributeClass.equals(String.class)) {\n-\t\t\treturn stringValue;\n-\t\t} else if(attributeClass.equals(Integer.class)) {\n-\t\t\treturn Integer.parseInt(stringValue);\n-\t\t} else if(attributeClass.equals(Boolean.class)) {\n-\t\t\treturn Boolean.parseBoolean(stringValue);\n-\t\t} else if(attributeClass.equals(ArrayList.class)) {\n-\t\t\tString[] array = stringValue.split(Character.toString(LIST_DELIMITER), -1);\n-\t\t\tList<String> attributeValue =  new ArrayList<String>();\n-\n-\t\t\t//join items which was splited on escaped LIST_DELIMITER\n-\t\t\tfor(int i = 0; i < array.length -1; i++) { //itarate to lenght -1  ... last array item is always empty\n-\t\t\t\tString item = array[i];\n-\t\t\t\twhile(item.matches(\"^(.*[^\\\\\\\\])?(\\\\\\\\\\\\\\\\)*\\\\\\\\$\")) { //item last char is '\\' . Next item start with ',', so we need to concat this items.\n-\t\t\t\t\titem = item.substring(0, item.length()-1);  //cut off last char ('\\')\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\titem = item.concat(Character.toString(LIST_DELIMITER)).concat(array[i+1]);\n-\t\t\t\t\t\ti++;\n-\t\t\t\t\t} catch(ArrayIndexOutOfBoundsException ex) {\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"Bad format in attribute value\", ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t//unescape\n-\t\t\t\titem = item.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + \"])\", \"$1\");\n-\t\t\t\tif(item.equals(\"\\\\0\")) item = null;\n-\n-\t\t\t\t//return updated item back to list\n-\t\t\t\tattributeValue.add(item);\n-\t\t\t}\n-\n-\t\t\treturn attributeValue;\n-\t\t} else if(attributeClass.equals(LinkedHashMap.class)) {\n-\t\t\tString[] array = stringValue.split(Character.toString(LIST_DELIMITER), -1);\n-\t\t\tMap<String, String> attributeValue = new LinkedHashMap<String, String>();\n-\n-\t\t\t//join items which was splited on escaped LIST_DELIMITER\n-\t\t\tfor(int i = 0; i < array.length -1; i++) {  //itarate to lenght -1  ... last array item is always empty\n-\t\t\t\tString mapEntry = array[i];\n-\n-\t\t\t\twhile(mapEntry.matches(\"^(.*[^\\\\\\\\])?(\\\\\\\\\\\\\\\\)*\\\\\\\\$\")) { //mapEntry last char is '\\' . Next mapEntry start with ',', so we need to concat this mapEntries.\n-\t\t\t\t\tmapEntry = mapEntry.substring(0, mapEntry.length()-1);  //cut off last char ('\\')\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tmapEntry = mapEntry.concat(Character.toString(LIST_DELIMITER)).concat(array[i+1]);\n-\t\t\t\t\t\ti++;\n-\t\t\t\t\t} catch(ArrayIndexOutOfBoundsException ex) {\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"Bad format in attribute value\", ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tboolean delimiterFound = false;\n-\t\t\t\tint delimiterIndex = -1;\n-\n-\n-\t\t\t\twhile(!delimiterFound) {\n-\t\t\t\t\tdelimiterIndex++; //start searching at next char then last time\n-\t\t\t\t\tdelimiterIndex = mapEntry.indexOf(Character.toString(KEY_VALUE_DELIMITER), delimiterIndex);\n-\t\t\t\t\tif(delimiterIndex == -1) throw new ConsistencyErrorException(\"Bad format in attribute value. KEY_VALUE_DELIMITER not found. Attribute value='\" + stringValue + \"', processed entry='\" + mapEntry + \"'\");\n-\n-\t\t\t\t\t//check if this delimiter is not escaped\n-\t\t\t\t\tboolean isEscaped = false;  //is delimiter escaped\n-\t\t\t\t\tboolean stop = false;\n-\t\t\t\t\tint processedIndex = delimiterIndex - 1;\n-\t\t\t\t\twhile(!stop && processedIndex >= 0) {\n-\t\t\t\t\t\tif(mapEntry.charAt(processedIndex) == '\\\\') {\n-\t\t\t\t\t\t\tisEscaped = !isEscaped;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tstop = true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tprocessedIndex--;\n-\t\t\t\t\t}\n-\t\t\t\t\tif(!isEscaped) delimiterFound = true;\n-\t\t\t\t}\n-\n-\t\t\t\tString key = mapEntry.substring(0, delimiterIndex);\n-\t\t\t\tString value = mapEntry.substring(delimiterIndex+1);\n-\n-\t\t\t\t//unescape\n-\t\t\t\tkey = key.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + Character.toString(KEY_VALUE_DELIMITER) + \"])\", \"$1\");\n-\t\t\t\tvalue = value.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + Character.toString(KEY_VALUE_DELIMITER) + \"])\", \"$1\");\n-\n-\t\t\t\tif(key.equals(\"\\\\0\")) key = null;\n-\t\t\t\tif(value.equals(\"\\\\0\")) value = null;\n-\n-\t\t\t\t//return updated item back to list\n-\t\t\t\tattributeValue.put(key, value);\n-\t\t\t}\n-\n-\t\t\treturn attributeValue;\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"Unknown attribute type. (\"+ attributeClass.toString() + \")\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Take perunBean name and if it is RichObject, convert it to simple name.\n-\t *\n-\t * RichObject mean: starts with \"Rich\" and continue with Upper Letter [A-Z]\n-\t *\n-\t * Ex.: RichGroup -> Group, RichUser -> User\n-\t * Ex.: RichardObject -> RichardObject\n-\t * Ex.: Null -> Null\n-\t *\n-\t * @param beanName bean Name of PerunBean (simple name of object)\n-\t *\n-\t * @return converted beanName (without Rich part)\n-\t */\n-\tpublic static String convertRichBeanNameToBeanName(String beanName) {\n-\t\tif(beanName == null || beanName.isEmpty()) return beanName;\n-\n-\t\tMatcher richBeanNameMatcher = richBeanNamePattern.matcher(beanName);\n-\t\tif (richBeanNameMatcher.find()) {\n-\t\t\treturn richBeanNameMatcher.group(1);\n-\t\t}\n-\n-\t\treturn beanName;\n-\t}\n-\n-\t/**\n-\t * Create a string with set of IN clause. Every in clause has maximum 1000 ids.\n-\t * Identifier means for what IN clause is calling (Like 'table.id')\n-\t *\n-\t * Reason for using is compatibility with oracle and other dbs.\n-\t *\n-\t * Example: \" ( in (10,15,...) or in (...) or ... ) \"\n-\t *\n-\t * @param beans list of perun beans\n-\t * @return string with some sql IN clause\n-\t */\n-\tpublic static String prepareInSQLClause(String identifier, List<? extends PerunBean> beans) {\n-\t\t//get Ids\n-\t\tList<Integer> beansIds = new ArrayList<>();\n-\t\tfor(PerunBean pb: beans) {\n-\t\t\tbeansIds.add(pb.getId());\n-\t\t}\n-\t\treturn BeansUtils.prepareInSQLClause(beansIds, identifier);\n-\t}\n-\n-\n-\t/**\n-\t * Create a string with set of IN clause. Every in clause has maximum 1000 ids.\n-\t * Identifier means for what IN clause is calling (Like 'table.id')\n-\t *\n-\t * Reason for using is compatibility with oracle and other dbs.\n-\t *\n-\t * Example: \" ( in (10,15,...) or in (...) or ... ) \"\n-\t *\n-\t * @param beansIds list of perun bean ids\n-\t * @return string with some sql IN clause\n-\t */\n-\tpublic static String prepareInSQLClause(List<Integer> beansIds, String identifier) {\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\t//use or in sql clause\n-\t\tboolean useOr = false;\n-\t\t//first bracket\n-\t\tsb.append(\" (\");\n-\n-\t\t//for every maxSize of beans\n-\t\twhile(beansIds.size() > MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE ) {\n-\n-\t\t\tif(useOr) sb.append(\" or \");\n-\t\t\telse useOr = true;\n-\n-\t\t\tsb.append(\" \");\n-\t\t\tsb.append(identifier);\n-\t\t\tsb.append(\" in (\");\n-\t\t\tList<Integer> partOfBeansIds = beansIds.subList(0, MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE);\n-\t\t\tsb.append(beanIdsToString(partOfBeansIds));\n-\t\t\tsb.append(\") \");\n-\t\t\tpartOfBeansIds.clear();\n-\t\t}\n-\n-\t\t//for rest of beans less or equals to 1000\n-\t\tif(useOr) sb.append(\" or \");\n-\t\tsb.append(\" \");\n-\t\tsb.append(identifier);\n-\t\tsb.append(\" in (\");\n-\t\tsb.append(beanIdsToString(beansIds));\n-\t\tsb.append(\") \");\n-\n-\t\t//last bracket\n-\t\tsb.append(\") \");\n-\t\treturn sb.toString();\n-\t}\n-\n-\t/**\n-\t * Convert list of beans ids to one string with ',' between ids\n-\t *\n-\t * @param beans List of ids to construct string with\n-\t * @return string representation of list of ids\n-\t */\n-\tpublic static String beanIdsToString(List<Integer> beansIds) {\n-\t\tStringBuilder stringBuilder = new StringBuilder();\n-\t\tfor(Integer beanId : beansIds) {\n-\t\t\tstringBuilder.append(\",\");\n-\t\t\tstringBuilder.append(beanId);\n-\t\t\t}\n-\t\tstringBuilder.deleteCharAt(0);\n-\t\treturn stringBuilder.toString();\n-\t}\n-\n-\t/**\n-\t * Gets particular property from perun.properties file.\n-\t *\n-\t * @param propertyName name of the property\n-\t * @return value of the property\n-\t */\n-\tpublic static String getPropertyFromConfiguration(String propertyName) throws InternalErrorException {\n-\t\tlog.trace(\"Entering getPropertyFromConfiguration: propertyName='\" + propertyName + \"'\");\n-\t\tnotNull(propertyName, \"propertyName\");\n-\n-\t\tif(BeansUtils.properties == null) {\n-\t\t\t// Load properties file with configuration\n-\t\t\tProperties properties = new Properties();\n-\t\t\ttry {\n-\t\t\t\t// Get the path to the perun.properties file\n-\t\t\t\tBufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + \"perun.properties\"));\n-\t\t\t\tproperties.load(is);\n-\t\t\t\tis.close();\n-\t\t\t} catch (FileNotFoundException e) {\n-\t\t\t\tthrow new InternalErrorException(\"Cannot find perun.properties file\", e);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tthrow new InternalErrorException(\"Cannot read perun.properties file\", e);\n-\t\t\t}\n-\n-\t\t\tBeansUtils.properties = properties;\n-\t\t}\n-\t\tString property = BeansUtils.properties.getProperty(propertyName);\n-\t\tif (property == null) {\n-\t\t\tthrow new InternalErrorException(\"Property \" + propertyName + \" cannot be found in the configuration file\");\n-\t\t}\n-\t\treturn property;\n-\t}\n-\n-\t/**\n-\t * Gets particular property from custom property file.\n-\t *\n-\t * @param propertyFile name of properties file\n-\t * @param propertyName name of the property\n-\t * @return value of the property\n-\t */\n-\tpublic static String getPropertyFromCustomConfiguration(String propertyFile, String propertyName) throws InternalErrorException {\n-\t\tlog.trace(\"Entering getPropertyFromCustomConfiguration: propertyFile='\" +  propertyFile + \"' propertyName='\" +  propertyName + \"'\");\n-\t\tnotNull(propertyName, \"propertyName\");\n-\t\tnotNull(propertyFile, \"propertyFile\");\n-\n-\t\t// Load properties file with configuration\n-\t\tProperties properties = new Properties();\n-\t\ttry {\n-\t\t\t// Get the path to the perun.properties file\n-\t\t\tBufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + propertyFile));\n-\t\t\tproperties.load(is);\n-\t\t\tis.close();\n-\n-\t\t\tString property = properties.getProperty(propertyName);\n-\t\t\tif (property == null) {\n-\t\t\t\tthrow new InternalErrorException(\"Property \" + propertyName + \" cannot be found in the configuration file: \"+propertyFile);\n-\t\t\t}\n-\t\t\treturn property;\n-\t\t} catch (FileNotFoundException e) {\n-\t\t\tthrow new InternalErrorException(\"Cannot find \"+propertyFile+\" file\", e);\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new InternalErrorException(\"Cannot read \"+propertyFile+\" file\", e);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Gets all properties from custom property file.\n-\t *\n-\t * @param propertyFile name of properties file\n-\t * @return all properties with values\n-\t */\n-\tpublic static Map<String, String> getAllPropertiesFromCustomConfiguration(String propertyFile) throws InternalErrorException {\n-\t\tlog.trace(\"Entering getAllPropertiesFromCustomConfiguration: propertyFile='\" + propertyFile + \"'\");\n-\t\tnotNull(propertyFile, \"propertyFile\");\n-\n-\t\t// Load properties file with configuration\n-\t\tProperties properties = new Properties();\n-\t\ttry {\n-\n-\t\t\t// Get the path to the perun.properties file\n-\t\t\tBufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + propertyFile));\n-\t\t\tproperties.load(is);\n-\t\t\tis.close();\n-\n-\t\t\tMap<String, String> myMap = new HashMap<String, String>();\n-\t\t\tfor (Object key : properties.keySet()) {\n-\t\t\t\tmyMap.put(key.toString(), properties.get(key).toString());\n-\t\t\t}\n-\t\t\treturn myMap;\n-\n-\t\t} catch (FileNotFoundException e) {\n-\t\t\tthrow new InternalErrorException(\"Cannot find \"+propertyFile+\" file\", e);\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new InternalErrorException(\"Cannot read \"+propertyFile+\" file\", e);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * True if this instance of perun is read only.\n-\t * False if not.\n-\t *\n-\t * @return true or false (readOnly or not)\n-\t */\n-\tpublic static boolean isPerunReadOnly() {\n-\t\t//Set only if variable isPerunReadOnly is not set already\n-\t\tif(isPerunReadOnly == null) {\n-\t\t\tString readOnly;\n-\t\t\ttry {\n-\t\t\t\treadOnly = BeansUtils.getPropertyFromConfiguration(\"perun.readOnlyPerun\");\n-\t\t\t} catch (Exception ex) {\n-\t\t\t\t//If something wierd happens, set this to normal configuration (not readOnly) and log this exception\n-\t\t\t\tlog.error(\"Problem occures when trying to get readOnly configuration from perun properties file.\", ex);\n-\t\t\t\tlog.debug(\"Read only configuration not found, set to false.\");\n-\t\t\t\tisPerunReadOnly = false;\n-\t\t\t\treturn isPerunReadOnly;\n-\t\t\t}\n-\n-\t\t\tif(readOnly == null) {\n-\t\t\t\tlog.debug(\"Read only configuration is null, set to false.\");\n-\t\t\t\tisPerunReadOnly = false;\n-\t\t\t\treturn isPerunReadOnly;\n-\t\t\t}\n-\n-\t\t\tif(readOnly.contains(\"true\")) {\n-\t\t\t\tlog.debug(\"Read only configuration found='{}', set to true.\", readOnly);\n-\t\t\t\tisPerunReadOnly = true;\n-\t\t\t\treturn isPerunReadOnly;\n-\t\t\t}\n-\n-\t\t\tlog.debug(\"Read only configuration found='{}', set to false.\", readOnly);\n-\t\t\tisPerunReadOnly = false;\n-\t\t\treturn isPerunReadOnly;\n-\t\t} else {\n-\t\t\treturn isPerunReadOnly;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * True if DB initializator is enabled, false if not\n-\t * Default is false\n-\t *\n-\t * @return true if enabled, false if disabled\n-\t */\n-\tpublic static boolean initializatorEnabled() {\n-\t\tString initializatorEnabled;\n-\t\ttry {\n-\t\t\tinitializatorEnabled = BeansUtils.getPropertyFromConfiguration(\"perun.DBInitializatorEnabled\");\n-\t\t} catch (Exception ex) {\n-\t\t\t//If something wierd happens, set this to normal configuration (not readOnly) and log this exception\n-\t\t\tlog.error(\"Problem occures when trying to get DBInitializatorEnabled configuration from perun properties file.\", ex);\n-\t\t\tlog.debug(\"DBInitializatorEnabled configuration not found, set to false.\");\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif(initializatorEnabled == null) {\n-\t\t\tlog.debug(\"DBInitializatorEnabled configuration is null, set to false.\");\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif(initializatorEnabled.contains(\"true\")) {\n-\t\t\tlog.debug(\"DBInitializatorEnabled configuration found='{}', set to true.\", initializatorEnabled);\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tlog.debug(\"Read only configuration found='{}', set to false.\", initializatorEnabled);\n-\t\treturn false;\n-\t}\n-\t\n-\t/**\n-\t * Checks whether the object is null or not.\n-\t *\n-\t * @param e\n-\t * @param name\n-\t * @throws InternalErrorException which wraps NullPointerException\n-\t */\n-\tpublic static void notNull(Object e, String name) throws InternalErrorException {\n-\t\tif(e == null){\n-\t\t\tthrow new InternalErrorException(new NullPointerException(\"'\" + name + \"' is null\"));\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Set already filled-in properties (used by Spring container to inject properties bean)\n-\t *\n-\t * @param properties\n-\t * @return\n-\t */\n-\tpublic static Properties setProperties(Properties properties) {\n-\t\tBeansUtils.properties = properties;\n-\t\treturn BeansUtils.properties;\n-\t}\n-\n-\tpublic static String getIDsOfPerunBeans(List<? extends PerunBean> listOfBeans) {\n-\t\tif (listOfBeans == null || listOfBeans.isEmpty()) {\n-\t\t\treturn \"\";\n-\t\t}\n-\n-\t\tBoolean isFirstIteration = true;\n-\t\tStringBuilder str = new StringBuilder();\n-\t\tfor(PerunBean perunBean : listOfBeans) {\n-\t\t\tif(isFirstIteration) {\n-\t\t\t\tstr.append(perunBean.getId());\n-\t\t\t\tisFirstIteration = false;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tstr.append(\",\").append(perunBean.getId());\n-\t\t\t}\n-\t\t}\n-\t\treturn str.toString();\n-\t}\n+    private final static Logger log = LoggerFactory.getLogger(BeansUtils.class);\n+\n+    private final static Pattern patternForCommonNameParsing = Pattern.compile(\"(([\\\\w]*. )*)([\\\\p{L}-']+) ([\\\\p{L}-']+)[, ]*(.*)\");\n+    private final static Pattern richBeanNamePattern = Pattern.compile(\"^Rich([A-Z].*$)\");\n+    public static final char LIST_DELIMITER = ',';\n+    public static final char KEY_VALUE_DELIMITER = ':';\n+    private final static int MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE = 1000;\n+    public final static String configurationsLocations = \"/etc/perun/\";\n+    private static Properties properties;\n+    private static Boolean isPerunReadOnly = null;\n+\n+    /**\n+     * Method create formatter with default settings for perun timestamps and set lenient on false\n+     * Timestamp format:  \"yyyy-MM-dd HH:mm:ss.S\" - \"ex. 2014-01-01 10:10:10.0\"\n+     * <p>\n+     * Lenient on false means that formatter will be more strict to creating timestamp from string\n+     * <p>\n+     * IMPORTANT: SimpleDateFormat is not thread safe !!!\n+     *\n+     * @return date formatter\n+     */\n+    public static DateFormat getDateFormatter() {\n+        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+        df.setLenient(false);\n+        return df;\n+    }\n+\n+    /**\n+     * Method create formatter with default settings for perun timestamps (only date without time)\n+     * and set lenient on false.\n+     * <p>\n+     * Timestamp format:  \"yyyy-MM-dd\" - \"ex. 2014-01-01\"\n+     * <p>\n+     * Lenient on false means that formatter will be more strict to creating timestamp from string\n+     * <p>\n+     * IMPORTANT: SimpleDateFormat is not thread safe !!!\n+     *\n+     * @return date formatter\n+     */\n+    public static DateFormat getDateFormatterWithoutTime() {\n+        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n+        df.setLenient(false);\n+        return df;\n+    }\n+\n+    /**\n+     * This method take text and for every chars in \"<>\\\" erase escaping\n+     * also change '\\0' to 'null' if it is escaped zero symbol.\n+     * <p>\n+     * Escaping char is \\.\n+     * Expecting: Before using this method, text must be escaped by using method createEscaping.\n+     * So in text will never be string like \"\\\\>\", \"\\\" or \"\\\\\\\".\n+     * <p>\n+     * For every \\ in text it put \\\\ and for every < it put \\< and for every > it put \\>\n+     *\n+     * @param text text from which will be erase escaping\n+     * @return nonescaped text\n+     */\n+    public static String eraseEscaping(String text) {\n+        if (text == null || text.equals(\"\\\\0\")) {\n+            return null;\n+        }\n+        //change \\0 to null if zero is escaped\n+        text = text.replaceAll(\"((^|[^\\\\\\\\])(\\\\\\\\\\\\\\\\)*)(\\\\\\\\0)\", \"$1null\");\n+        text = text.replace(\"\\\\>\", \">\");\n+        text = text.replace(\"\\\\<\", \"<\");\n+        text = text.replace(\"\\\\\\\\\", \"\\\\\");\n+        return text;\n+    }\n+\n+    /**\n+     * This method take text and for every chars in \"<>\\\" create escaping\n+     * Escaping char is \\.\n+     * For every \\\\ in text it put \\ and for every \\< it put < and for every \\> it put >\n+     *\n+     * @param text text from which will be erase escaping\n+     * @return escaped text\n+     */\n+    public static String createEscaping(String text) {\n+        if (text == null) {\n+            return \"\\\\0\";\n+        }\n+        text = text.replace(\"\\\\\", \"\\\\\\\\\");\n+        text = text.replace(\">\", \"\\\\>\");\n+        text = text.replace(\"<\", \"\\\\<\");\n+        return text;\n+    }\n+\n+    /**\n+     * This method get text and all nonescaped characters < and > replace by apostrophe\n+     *\n+     * @param text\n+     * @return text where nonescaped characters < and  > will be reaplace by apostrophe '\n+     */\n+    public static String replacePointyBracketsByApostrophe(String text) {\n+        StringBuilder stringBuilder = new StringBuilder(text);\n+        for (int i = 0; i < text.length(); i++) {\n+            if (text.charAt(i) == '<' || text.charAt(i) == '>') {\n+                if (!isEscaped(text, i - 1)) {\n+                    stringBuilder.setCharAt(i, '\\'');\n+                }\n+            }\n+        }\n+        return stringBuilder.toString();\n+    }\n+\n+    /**\n+     * This method get text and all escaped \\0 replace for text null\n+     *\n+     * @param text\n+     * @return text where \\0 is replaced for null\n+     */\n+    public static String replaceEscapedNullByStringNull(String text) {\n+        StringBuilder stringBuilder = new StringBuilder(text);\n+        for (int i = 0; i < stringBuilder.length(); i++) {\n+            if (stringBuilder.charAt(i) == '0') {\n+                if (isEscaped(stringBuilder.toString(), i - 1)) {\n+                    stringBuilder.replace(i - 1, i + 1, \"null\");\n+                    i = i + 2;\n+                }\n+            }\n+        }\n+        return stringBuilder.toString();\n+    }\n+\n+    /**\n+     * Return true, if char on position in text is escaped by '\\' Return false,\n+     * if not.\n+     *\n+     * @param text     text in which will be searching\n+     * @param position position in text <0-text.length>\n+     * @return true if char is escaped, false if not\n+     */\n+    public static boolean isEscaped(String text, int position) {\n+        boolean escaped = false;\n+        while (text.charAt(position) == '\\\\') {\n+            escaped = !escaped;\n+            position--;\n+            if (position < 0) {\n+                return escaped;\n+            }\n+        }\n+        return escaped;\n+    }\n+\n+    /**\n+     * Serialize map to string\n+     *\n+     * @param map\n+     * @return string of escaped map\n+     */\n+    public static String serializeMapToString(Map<String, String> map) {\n+        if (map == null) {\n+            return \"\\\\0\";\n+        }\n+        Map<String, String> attrNew = new HashMap<String, String>(map);\n+        Set<String> keys = new HashSet<String>(attrNew.keySet());\n+        for (String s : keys) {\n+            attrNew.put(\"<\" + BeansUtils.createEscaping(s) + \">\", \"<\" + BeansUtils.createEscaping(attrNew.get(s)) + \">\");\n+            attrNew.remove(s);\n+        }\n+        return attrNew.toString();\n+    }\n+\n+\n+    /**\n+     * Converts attribute value to string (for storing into DB)\n+     *\n+     * @param attribute value of the attribute\n+     * @return string representation of the value\n+     * @throws InternalErrorException\n+     */\n+    public static String attributeValueToString(Attribute attribute) throws InternalErrorException {\n+        if (attribute == null) {\n+            throw new InternalErrorException(new NullPointerException(\"attribute is null\"));\n+        }\n+        if (attribute.getValue() == null) {\n+            return null;\n+        }\n+\n+        if (!attribute.getType().equals(attribute.getValue().getClass().getName())) {\n+            throw new InternalErrorException(\"Attribute's type mismatch \" + attribute + \". The type of attribute's value (\" + attribute.getValue().getClass().getName() + \") doesn't match the type of attribute (\" + attribute.getType() + \").\");\n+        }\n+\n+        if (attribute.getType().equals(String.class.getName())) {\n+            return (String) attribute.getValue();\n+        } else if (attribute.getType().equals(Integer.class.getName())) {\n+            return Integer.toString((Integer) attribute.getValue());\n+        } else if (attribute.getType().equals(Boolean.class.getName())) {\n+            return Boolean.toString((Boolean) attribute.getValue());\n+        } else if (attribute.getType().equals(ArrayList.class.getName())) {\n+            StringBuilder sb = new StringBuilder();\n+            for (String item : (List<String>) attribute.getValue()) {\n+                if (item == null) {\n+                    item = \"\\\\0\";\n+                } else {\n+                    item = item.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n+                    item = item.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n+                }\n+                sb.append(item);\n+                sb.append(LIST_DELIMITER);\n+            }\n+            return sb.toString();\n+        } else if (attribute.getType().equals(LinkedHashMap.class.getName())) {\n+            StringBuilder sb = new StringBuilder();\n+            for (Map.Entry<String, String> entry : ((Map<String, String>) attribute.getValue()).entrySet()) {\n+                String key = entry.getKey();\n+                if (key == null) {\n+                    key = \"\\\\0\";\n+                } else {\n+                    key = key.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n+                    key = key.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n+                    key = key.replace(Character.toString(KEY_VALUE_DELIMITER), \"\\\\\" + KEY_VALUE_DELIMITER); //escape KEY_VALUE_DELIMITER\n+                }\n+\n+                String value = entry.getValue();\n+                if (value == null) {\n+                    value = \"\\\\0\";\n+                } else {\n+                    value = value.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n+                    value = value.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n+                    value = value.replace(Character.toString(KEY_VALUE_DELIMITER), \"\\\\\" + KEY_VALUE_DELIMITER); //escape KEY_VALUE_DELIMITER\n+                }\n+\n+                sb.append(key);\n+                sb.append(KEY_VALUE_DELIMITER);\n+                sb.append(value);\n+                sb.append(LIST_DELIMITER);\n+            }\n+            return sb.toString();\n+        } else {\n+            throw new InternalErrorException(\"Unknown java type of attribute's value.\");\n+        }\n+    }\n+\n+    /**\n+     * This method get map created by example : {<key1>=<value1>, <key2>=<value2>}\n+     * Keys and values are escaped for \"\\\", \"<\" and \">\"\n+     * Example of escaping key=\"key\\\\s\\>\" is \"key\\s>\"\n+     * Return Map<String, String> attribute to value.\n+     *\n+     * @param text text from which will be parsed map\n+     * @return map<string, string> attributes\n+     */\n+    public static Map<String, String> deserializeStringToMap(String text) {\n+        if (text.equals(\"\\\\0\")) {\n+            return null;\n+        }\n+        Map<String, String> map = new HashMap<String, String>();\n+        int startName = -1;\n+        int endName = -1;\n+        int startValue = -1;\n+        int endValue = -1;\n+        int pointyBrackets = 0;\n+        boolean notValue = true;\n+\n+        for (int i = 0; i < text.length(); i++) {\n+            if (text.charAt(i) == '<' && notValue && startName == -1) {\n+                if (!BeansUtils.isEscaped(text, i - 1)) {\n+                    startName = i;\n+                }\n+            } else if (text.charAt(i) == '>' && notValue && endName == -1) {\n+                if (!BeansUtils.isEscaped(text, i - 1)) {\n+                    endName = i;\n+                    notValue = false;\n+                }\n+            } else if (text.charAt(i) == '<' && !notValue && startValue == -1) {\n+                if (!BeansUtils.isEscaped(text, i - 1)) {\n+                    startValue = i;\n+                }\n+            } else if (text.charAt(i) == '>' && !notValue && endValue == -1) {\n+                if (!BeansUtils.isEscaped(text, i - 1)) {\n+                    endValue = i;\n+                    notValue = true;\n+                }\n+            }\n+            if (startName != -1 && endName != -1 && startValue != -1 && endValue != -1) {\n+                map.put(BeansUtils.eraseEscaping(text.substring(startName + 1, endName)), BeansUtils.eraseEscaping(text.substring(startValue + 1, endValue)));\n+                startName = -1;\n+                endName = -1;\n+                startValue = -1;\n+                endValue = -1;\n+            }\n+        }\n+        return map;\n+    }\n+\n+    /**\n+     * Converts string representation of an attribute value to correct java object\n+     *\n+     * @param stringValue string representation of the attribute value\n+     * @param type        type of the value (\"Java.lang.String\" for example)/\n+     * @return\n+     * @throws InternalErrorException\n+     */\n+    public static Object stringToAttributeValue(String stringValue, String type) throws InternalErrorException {\n+        if (stringValue == null || stringValue.isEmpty()) {\n+            return null;\n+        }\n+\n+        Class<?> attributeClass;\n+        try {\n+            attributeClass = Class.forName(type);\n+        } catch (ClassNotFoundException e) {\n+            throw new InternalErrorException(\"Unknown attribute type\", e);\n+        } catch (NoClassDefFoundError e) {\n+            throw new InternalErrorException(\"Unknown attribute def type\", e);\n+        }\n+\n+        if (attributeClass.equals(String.class)) {\n+            return stringValue;\n+        } else if (attributeClass.equals(Integer.class)) {\n+            return Integer.parseInt(stringValue);\n+        } else if (attributeClass.equals(Boolean.class)) {\n+            return Boolean.parseBoolean(stringValue);\n+        } else if (attributeClass.equals(ArrayList.class)) {\n+            String[] array = stringValue.split(Character.toString(LIST_DELIMITER), -1);\n+            List<String> attributeValue = new ArrayList<String>();\n+\n+            //join items which was splited on escaped LIST_DELIMITER\n+            for (int i = 0; i < array.length - 1; i++) { //itarate to lenght -1  ... last array item is always empty\n+                String item = array[i];\n+                while (item.matches(\"^(.*[^\\\\\\\\])?(\\\\\\\\\\\\\\\\)*\\\\\\\\$\")) { //item last char is '\\' . Next item start with ',', so we need to concat this items.\n+                    item = item.substring(0, item.length() - 1);  //cut off last char ('\\')\n+                    try {\n+                        item = item.concat(Character.toString(LIST_DELIMITER)).concat(array[i + 1]);\n+                        i++;\n+                    } catch (ArrayIndexOutOfBoundsException ex) {\n+                        throw new ConsistencyErrorException(\"Bad format in attribute value\", ex);\n+                    }\n+                }\n+                //unescape\n+                item = item.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + \"])\", \"$1\");\n+                if (item.equals(\"\\\\0\")) {\n+                    item = null;\n+                }\n+\n+                //return updated item back to list\n+                attributeValue.add(item);\n+            }\n+\n+            return attributeValue;\n+        } else if (attributeClass.equals(LinkedHashMap.class)) {\n+            String[] array = stringValue.split(Character.toString(LIST_DELIMITER), -1);\n+            Map<String, String> attributeValue = new LinkedHashMap<String, String>();\n+\n+            //join items which was splited on escaped LIST_DELIMITER\n+            for (int i = 0; i < array.length - 1; i++) {  //itarate to lenght -1  ... last array item is always empty\n+                String mapEntry = array[i];\n+\n+                while (mapEntry.matches(\"^(.*[^\\\\\\\\])?(\\\\\\\\\\\\\\\\)*\\\\\\\\$\")) { //mapEntry last char is '\\' . Next mapEntry start with ',', so we need to concat this mapEntries.\n+                    mapEntry = mapEntry.substring(0, mapEntry.length() - 1);  //cut off last char ('\\')\n+                    try {\n+                        mapEntry = mapEntry.concat(Character.toString(LIST_DELIMITER)).concat(array[i + 1]);\n+                        i++;\n+                    } catch (ArrayIndexOutOfBoundsException ex) {\n+                        throw new ConsistencyErrorException(\"Bad format in attribute value\", ex);\n+                    }\n+                }\n+\n+                boolean delimiterFound = false;\n+                int delimiterIndex = -1;\n+\n+\n+                while (!delimiterFound) {\n+                    delimiterIndex++; //start searching at next char then last time\n+                    delimiterIndex = mapEntry.indexOf(Character.toString(KEY_VALUE_DELIMITER), delimiterIndex);\n+                    if (delimiterIndex == -1) {\n+                        throw new ConsistencyErrorException(\"Bad format in attribute value. KEY_VALUE_DELIMITER not found. Attribute value='\" + stringValue + \"', processed entry='\" + mapEntry + \"'\");\n+                    }\n+\n+                    //check if this delimiter is not escaped\n+                    boolean isEscaped = false;  //is delimiter escaped\n+                    boolean stop = false;\n+                    int processedIndex = delimiterIndex - 1;\n+                    while (!stop && processedIndex >= 0) {\n+                        if (mapEntry.charAt(processedIndex) == '\\\\') {\n+                            isEscaped = !isEscaped;\n+                        } else {\n+                            stop = true;\n+                        }\n+                        processedIndex--;\n+                    }\n+                    if (!isEscaped) {\n+                        delimiterFound = true;\n+                    }\n+                }\n+\n+                String key = mapEntry.substring(0, delimiterIndex);\n+                String value = mapEntry.substring(delimiterIndex + 1);\n+\n+                //unescape\n+                key = key.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + Character.toString(KEY_VALUE_DELIMITER) + \"])\", \"$1\");\n+                value = value.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + Character.toString(KEY_VALUE_DELIMITER) + \"])\", \"$1\");\n+\n+                if (key.equals(\"\\\\0\")) {\n+                    key = null;\n+                }\n+                if (value.equals(\"\\\\0\")) {\n+                    value = null;\n+                }\n+\n+                //return updated item back to list\n+                attributeValue.put(key, value);\n+            }\n+\n+            return attributeValue;\n+        } else {\n+            throw new InternalErrorException(\"Unknown attribute type. (\" + attributeClass.toString() + \")\");\n+        }\n+    }\n+\n+    /**\n+     * Take perunBean name and if it is RichObject, convert it to simple name.\n+     * <p>\n+     * RichObject mean: starts with \"Rich\" and continue with Upper Letter [A-Z]\n+     * <p>\n+     * Ex.: RichGroup -> Group, RichUser -> User\n+     * Ex.: RichardObject -> RichardObject\n+     * Ex.: Null -> Null\n+     *\n+     * @param beanName bean Name of PerunBean (simple name of object)\n+     * @return converted beanName (without Rich part)\n+     */\n+    public static String convertRichBeanNameToBeanName(String beanName) {\n+        if (beanName == null || beanName.isEmpty()) {\n+            return beanName;\n+        }\n+\n+        Matcher richBeanNameMatcher = richBeanNamePattern.matcher(beanName);\n+        if (richBeanNameMatcher.find()) {\n+            return richBeanNameMatcher.group(1);\n+        }\n+\n+        return beanName;\n+    }\n+\n+    /**\n+     * Create a string with set of IN clause. Every in clause has maximum 1000 ids.\n+     * Identifier means for what IN clause is calling (Like 'table.id')\n+     * <p>\n+     * Reason for using is compatibility with oracle and other dbs.\n+     * <p>\n+     * Example: \" ( in (10,15,...) or in (...) or ... ) \"\n+     *\n+     * @param beans list of perun beans\n+     * @return string with some sql IN clause\n+     */\n+    public static String prepareInSQLClause(String identifier, List<? extends PerunBean> beans) {\n+        //get Ids\n+        List<Integer> beansIds = new ArrayList<>();\n+        for (PerunBean pb : beans) {\n+            beansIds.add(pb.getId());\n+        }\n+        return BeansUtils.prepareInSQLClause(beansIds, identifier);\n+    }\n+\n+\n+    /**\n+     * Create a string with set of IN clause. Every in clause has maximum 1000 ids.\n+     * Identifier means for what IN clause is calling (Like 'table.id')\n+     * <p>\n+     * Reason for using is compatibility with oracle and other dbs.\n+     * <p>\n+     * Example: \" ( in (10,15,...) or in (...) or ... ) \"\n+     *\n+     * @param beansIds list of perun bean ids\n+     * @return string with some sql IN clause\n+     */\n+    public static String prepareInSQLClause(List<Integer> beansIds, String identifier) {\n+        StringBuilder sb = new StringBuilder();\n+        //use or in sql clause\n+        boolean useOr = false;\n+        //first bracket\n+        sb.append(\" (\");\n+\n+        //for every maxSize of beans\n+        while (beansIds.size() > MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE) {\n+\n+            if (useOr) {\n+                sb.append(\" or \");\n+            } else {\n+                useOr = true;\n+            }\n+\n+            sb.append(\" \");\n+            sb.append(identifier);\n+            sb.append(\" in (\");\n+            List<Integer> partOfBeansIds = beansIds.subList(0, MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE);\n+            sb.append(beanIdsToString(partOfBeansIds));\n+            sb.append(\") \");\n+            partOfBeansIds.clear();\n+        }\n+\n+        //for rest of beans less or equals to 1000\n+        if (useOr) {\n+            sb.append(\" or \");\n+        }\n+        sb.append(\" \");\n+        sb.append(identifier);\n+        sb.append(\" in (\");\n+        sb.append(beanIdsToString(beansIds));\n+        sb.append(\") \");\n+\n+        //last bracket\n+        sb.append(\") \");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Convert list of beans ids to one string with ',' between ids\n+     *\n+     * @param beans List of ids to construct string with\n+     * @return string representation of list of ids\n+     */\n+    public static String beanIdsToString(List<Integer> beansIds) {\n+        StringBuilder stringBuilder = new StringBuilder();\n+        for (Integer beanId : beansIds) {\n+            stringBuilder.append(\",\");\n+            stringBuilder.append(beanId);\n+        }\n+        stringBuilder.deleteCharAt(0);\n+        return stringBuilder.toString();\n+    }\n+\n+    /**\n+     * Gets particular property from perun.properties file.\n+     *\n+     * @param propertyName name of the property\n+     * @return value of the property\n+     */\n+    public static String getPropertyFromConfiguration(String propertyName) throws InternalErrorException {\n+        log.trace(\"Entering getPropertyFromConfiguration: propertyName='\" + propertyName + \"'\");\n+        notNull(propertyName, \"propertyName\");\n+\n+        if (BeansUtils.properties == null) {\n+            // Load properties file with configuration\n+            Properties properties = new Properties();\n+            try {\n+                // Get the path to the perun.properties file\n+                BufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + \"perun.properties\"));\n+                properties.load(is);\n+                is.close();\n+            } catch (FileNotFoundException e) {\n+                throw new InternalErrorException(\"Cannot find perun.properties file\", e);\n+            } catch (IOException e) {\n+                throw new InternalErrorException(\"Cannot read perun.properties file\", e);\n+            }\n+\n+            BeansUtils.properties = properties;\n+        }\n+        String property = BeansUtils.properties.getProperty(propertyName);\n+        if (property == null) {\n+            throw new InternalErrorException(\"Property \" + propertyName + \" cannot be found in the configuration file\");\n+        }\n+        return property;\n+    }\n+\n+    /**\n+     * Gets particular property from custom property file.\n+     *\n+     * @param propertyFile name of properties file\n+     * @param propertyName name of the property\n+     * @return value of the property\n+     */\n+    public static String getPropertyFromCustomConfiguration(String propertyFile, String propertyName) throws InternalErrorException {\n+        log.trace(\"Entering getPropertyFromCustomConfiguration: propertyFile='\" + propertyFile + \"' propertyName='\" + propertyName + \"'\");\n+        notNull(propertyName, \"propertyName\");\n+        notNull(propertyFile, \"propertyFile\");\n+\n+        // Load properties file with configuration\n+        Properties properties = new Properties();\n+        try {\n+            // Get the path to the perun.properties file\n+            BufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + propertyFile));\n+            properties.load(is);\n+            is.close();\n+\n+            String property = properties.getProperty(propertyName);\n+            if (property == null) {\n+                throw new InternalErrorException(\"Property \" + propertyName + \" cannot be found in the configuration file: \" + propertyFile);\n+            }\n+            return property;\n+        } catch (FileNotFoundException e) {\n+            throw new InternalErrorException(\"Cannot find \" + propertyFile + \" file\", e);\n+        } catch (IOException e) {\n+            throw new InternalErrorException(\"Cannot read \" + propertyFile + \" file\", e);\n+        }\n+    }\n+\n+    /**\n+     * Gets all properties from custom property file.\n+     *\n+     * @param propertyFile name of properties file\n+     * @return all properties with values\n+     */\n+    public static Map<String, String> getAllPropertiesFromCustomConfiguration(String propertyFile) throws InternalErrorException {\n+        log.trace(\"Entering getAllPropertiesFromCustomConfiguration: propertyFile='\" + propertyFile + \"'\");\n+        notNull(propertyFile, \"propertyFile\");\n+\n+        // Load properties file with configuration\n+        Properties properties = new Properties();\n+        try {\n+\n+            // Get the path to the perun.properties file\n+            BufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + propertyFile));\n+            properties.load(is);\n+            is.close();\n+\n+            Map<String, String> myMap = new HashMap<String, String>();\n+            for (Object key : properties.keySet()) {\n+                myMap.put(key.toString(), properties.get(key).toString());\n+            }\n+            return myMap;\n+\n+        } catch (FileNotFoundException e) {\n+            throw new InternalErrorException(\"Cannot find \" + propertyFile + \" file\", e);\n+        } catch (IOException e) {\n+            throw new InternalErrorException(\"Cannot read \" + propertyFile + \" file\", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * True if this instance of perun is read only.\n+     * False if not.\n+     *\n+     * @return true or false (readOnly or not)\n+     */\n+    public static boolean isPerunReadOnly() {\n+        //Set only if variable isPerunReadOnly is not set already\n+        if (isPerunReadOnly == null) {\n+            String readOnly;\n+            try {\n+                readOnly = BeansUtils.getPropertyFromConfiguration(\"perun.readOnlyPerun\");\n+            } catch (Exception ex) {\n+                //If something wierd happens, set this to normal configuration (not readOnly) and log this exception\n+                log.error(\"Problem occures when trying to get readOnly configuration from perun properties file.\", ex);\n+                log.debug(\"Read only configuration not found, set to false.\");\n+                isPerunReadOnly = false;\n+                return isPerunReadOnly;\n+            }\n+\n+            if (readOnly == null) {\n+                log.debug(\"Read only configuration is null, set to false.\");\n+                isPerunReadOnly = false;\n+                return isPerunReadOnly;\n+            }\n+\n+            if (readOnly.contains(\"true\")) {\n+                log.debug(\"Read only configuration found='{}', set to true.\", readOnly);\n+                isPerunReadOnly = true;\n+                return isPerunReadOnly;\n+            }\n+\n+            log.debug(\"Read only configuration found='{}', set to false.\", readOnly);\n+            isPerunReadOnly = false;\n+            return isPerunReadOnly;\n+        } else {\n+            return isPerunReadOnly;\n+        }\n+    }\n+\n+    /**\n+     * True if DB initializator is enabled, false if not\n+     * Default is false\n+     *\n+     * @return true if enabled, false if disabled\n+     */\n+    public static boolean initializatorEnabled() {\n+        String initializatorEnabled;\n+        try {\n+            initializatorEnabled = BeansUtils.getPropertyFromConfiguration(\"perun.DBInitializatorEnabled\");\n+        } catch (Exception ex) {\n+            //If something wierd happens, set this to normal configuration (not readOnly) and log this exception\n+            log.error(\"Problem occures when trying to get DBInitializatorEnabled configuration from perun properties file.\", ex);\n+            log.debug(\"DBInitializatorEnabled configuration not found, set to false.\");\n+            return false;\n+        }\n+\n+        if (initializatorEnabled == null) {\n+            log.debug(\"DBInitializatorEnabled configuration is null, set to false.\");\n+            return false;\n+        }\n+\n+        if (initializatorEnabled.contains(\"true\")) {\n+            log.debug(\"DBInitializatorEnabled configuration found='{}', set to true.\", initializatorEnabled);\n+            return true;\n+        }\n+\n+        log.debug(\"Read only configuration found='{}', set to false.\", initializatorEnabled);\n+        return false;\n+    }\n+\n+    /**\n+     * Checks whether the object is null or not.\n+     *\n+     * @param e\n+     * @param name\n+     * @throws InternalErrorException which wraps NullPointerException\n+     */\n+    public static void notNull(Object e, String name) throws InternalErrorException {\n+        if (e == null) {\n+            throw new InternalErrorException(new NullPointerException(\"'\" + name + \"' is null\"));\n+        }\n+    }\n+\n+    /**\n+     * Set already filled-in properties (used by Spring container to inject properties bean)\n+     *\n+     * @param properties\n+     * @return\n+     */\n+    public static Properties setProperties(Properties properties) {\n+        BeansUtils.properties = properties;\n+        return BeansUtils.properties;\n+    }\n+\n+    public static String getIDsOfPerunBeans(List<? extends PerunBean> listOfBeans) {\n+        if (listOfBeans == null || listOfBeans.isEmpty()) {\n+            return \"\";\n+        }\n+\n+        Boolean isFirstIteration = true;\n+        StringBuilder str = new StringBuilder();\n+        for (PerunBean perunBean : listOfBeans) {\n+            if (isFirstIteration) {\n+                str.append(perunBean.getId());\n+                isFirstIteration = false;\n+            } else {\n+                str.append(\",\").append(perunBean.getId());\n+            }\n+        }\n+        return str.toString();\n+    }\n }\n",
            "diff_size": 738
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "713",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/477/BeansUtils.java\nindex ece5548a061..07bdf7330c4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/477/BeansUtils.java\n@@ -25,711 +25,734 @@ import org.slf4j.LoggerFactory;\n  * Beans Utilities.\n  *\n  */\n+\n+\n public class BeansUtils {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(BeansUtils.class);\n-\n-\tprivate final static Pattern patternForCommonNameParsing = Pattern.compile(\"(([\\\\w]*. )*)([\\\\p{L}-']+) ([\\\\p{L}-']+)[, ]*(.*)\");\n-\tprivate final static Pattern richBeanNamePattern = Pattern.compile(\"^Rich([A-Z].*$)\");\n-\tpublic static final char LIST_DELIMITER = ',';\n-\tpublic static final char KEY_VALUE_DELIMITER = ':';\n-\tprivate final static int MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE = 1000;\n-\tpublic final static String configurationsLocations = \"/etc/perun/\";\n-\tprivate static Properties properties;\n-\tprivate static Boolean isPerunReadOnly = null;\n-\n-\t/**\n-\t * Method create formatter with default settings for perun timestamps and set lenient on false\n-\t * Timestamp format:  \"yyyy-MM-dd HH:mm:ss.S\" - \"ex. 2014-01-01 10:10:10.0\"\n-\t *\n-\t * Lenient on false means that formatter will be more strict to creating timestamp from string\n-\t *\n-\t * IMPORTANT: SimpleDateFormat is not thread safe !!!\n-\t *\n-\t * @return date formatter\n-\t */\n-\tpublic static DateFormat getDateFormatter() {\n-\t\tDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n-\t\tdf.setLenient(false);\n-\t\treturn df;\n-\t}\n-\n-\t/**\n-\t * Method create formatter with default settings for perun timestamps (only date without time)\n-\t * and set lenient on false.\n-\t *\n-\t * Timestamp format:  \"yyyy-MM-dd\" - \"ex. 2014-01-01\"\n-\t *\n-\t * Lenient on false means that formatter will be more strict to creating timestamp from string\n-\t *\n-\t * IMPORTANT: SimpleDateFormat is not thread safe !!!\n-\t *\n-\t * @return date formatter\n-\t */\n-\tpublic static DateFormat getDateFormatterWithoutTime() {\n-\t\tDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n-\t\tdf.setLenient(false);\n-\t\treturn df;\n-\t}\n-\n-\t/**\n-\t * This method take text and for every chars in \"<>\\\" erase escaping\n-\t * also change '\\0' to 'null' if it is escaped zero symbol.\n-\t *\n-\t * Escaping char is \\.\n-\t * Expecting: Before using this method, text must be escaped by using method createEscaping.\n-\t *            So in text will never be string like \"\\\\>\", \"\\\" or \"\\\\\\\".\n-\t *\n-\t * For every \\ in text it put \\\\ and for every < it put \\< and for every > it put \\>\n-\t *\n-\t * @param text text from which will be erase escaping\n-\t * @return nonescaped text\n-\t */\n-\tpublic static String eraseEscaping(String text) {\n-\t\tif(text == null || text.equals(\"\\\\0\")) return null;\n-\t\t//change \\0 to null if zero is escaped\n-\t\ttext = text.replaceAll(\"((^|[^\\\\\\\\])(\\\\\\\\\\\\\\\\)*)(\\\\\\\\0)\", \"$1null\");\n-\t\ttext = text.replace(\"\\\\>\", \">\");\n-\t\ttext = text.replace(\"\\\\<\", \"<\");\n-\t\ttext = text.replace(\"\\\\\\\\\", \"\\\\\");\n-\t\treturn text;\n-\t}\n-\t/**\n-\t * This method take text and for every chars in \"<>\\\" create escaping\n-\t * Escaping char is \\.\n-\t * For every \\\\ in text it put \\ and for every \\< it put < and for every \\> it put >\n-\t *\n-\t * @param text text from which will be erase escaping\n-\t * @return escaped text\n-\t */\n-\tpublic static String createEscaping(String text) {\n-\t\tif(text == null) return \"\\\\0\";\n-\t\ttext = text.replace(\"\\\\\", \"\\\\\\\\\");\n-\t\ttext = text.replace(\">\", \"\\\\>\");\n-\t\ttext = text.replace(\"<\", \"\\\\<\");\n-\t\treturn text;\n-\t}\n-\n-\t/**\n-\t * This method get text and all nonescaped characters < and > replace by apostrophe\n-\t *\n-\t * @param text\n-\t * @return text where nonescaped characters < and  > will be reaplace by apostrophe '\n-\t */\n-\tpublic static String replacePointyBracketsByApostrophe(String text) {\n-\t\tStringBuilder stringBuilder = new StringBuilder(text);\n-\t\tfor(int i=0; i<text.length(); i++) {\n-\t\t\tif(text.charAt(i)=='<' || text.charAt(i)=='>') {\n-\t\t\t\tif(!isEscaped(text, i-1)) {\n-\t\t\t\t\tstringBuilder.setCharAt(i, '\\'');\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn stringBuilder.toString();\n-\t}\n-\n-\t/**\n-\t * This method get text and all escaped \\0 replace for text null\n-\t *\n-\t * @param text\n-\t * @return text where \\0 is replaced for null\n-\t */\n-\tpublic static String replaceEscapedNullByStringNull(String text) {\n-\t\tStringBuilder stringBuilder = new StringBuilder(text);\n-\t\tfor(int i=0; i<stringBuilder.length(); i++) {\n-\t\t\tif(stringBuilder.charAt(i)=='0') {\n-\t\t\t\tif(isEscaped(stringBuilder.toString(), i-1)) {\n-\t\t\t\t\tstringBuilder.replace(i-1, i+1, \"null\");\n-\t\t\t\t\ti=i+2;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn stringBuilder.toString();\n-\t}\n-\n-\t/**\n-\t * Return true, if char on position in text is escaped by '\\' Return false,\n-\t * if not.\n-\t *\n-\t * @param text text in which will be searching\n-\t * @param position position in text <0-text.length>\n-\t * @return true if char is escaped, false if not\n-\t */\n-\tpublic static boolean isEscaped(String text, int position) {\n-\t\tboolean escaped = false;\n-\t\twhile (text.charAt(position) == '\\\\') {\n-\t\t\tescaped = !escaped;\n-\t\t\tposition--;\n-\t\t\tif (position < 0) {\n-\t\t\t\treturn escaped;\n-\t\t\t}\n-\t\t}\n-\t\treturn escaped;\n-\t}\n-\n-\t/**\n-\t * Serialize map to string\n-\t *\n-\t * @param map\n-\t * @return string of escaped map\n-\t */\n-\tpublic static String serializeMapToString(Map<String, String> map) {\n-\t\tif(map == null) return \"\\\\0\";\n-\t\tMap<String, String> attrNew = new HashMap<String, String>(map);\n-\t\tSet<String> keys = new HashSet<String>(attrNew.keySet());\n-\t\tfor(String s: keys) {\n-\t\t\tattrNew.put(\"<\" + BeansUtils.createEscaping(s) + \">\", \"<\" + BeansUtils.createEscaping(attrNew.get(s)) + \">\");\n-\t\t\tattrNew.remove(s);\n-\t\t}\n-\t\treturn attrNew.toString();\n-\t}\n-\n-\n-\t/**\n-\t * Converts attribute value to string (for storing into DB)\n-\t *\n-\t * @param attribute value of the attribute\n-\t * @return string representation of the value\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tpublic static String attributeValueToString(Attribute attribute) throws InternalErrorException {\n-\t\tif(attribute == null) throw new InternalErrorException(new NullPointerException(\"attribute is null\"));\n-\t\tif(attribute.getValue() == null) return null;\n-\n-\t\tif(!attribute.getType().equals(attribute.getValue().getClass().getName())) {\n-\t\t\tthrow new InternalErrorException(\"Attribute's type mismatch \" + attribute + \". The type of attribute's value (\" + attribute.getValue().getClass().getName() + \") doesn't match the type of attribute (\" + attribute.getType() + \").\");\n-\t\t}\n-\n-\t\tif(attribute.getType().equals(String.class.getName())) {\n-\t\t\treturn (String) attribute.getValue();\n-\t\t} else if(attribute.getType().equals(Integer.class.getName())) {\n-\t\t\treturn Integer.toString((Integer) attribute.getValue());\n-\t\t} else if(attribute.getType().equals(Boolean.class.getName())) {\n-\t\t\treturn Boolean.toString((Boolean) attribute.getValue());\n-\t\t} else if(attribute.getType().equals(ArrayList.class.getName())) {\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tfor(String item : (List<String>) attribute.getValue()) {\n-\t\t\t\tif(item == null) {\n-\t\t\t\t\titem = \"\\\\0\";\n-\t\t\t\t} else {\n-\t\t\t\t\titem = item.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n-\t\t\t\t\titem = item.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n-\t\t\t\t}\n-\t\t\t\tsb.append(item);\n-\t\t\t\tsb.append(LIST_DELIMITER);\n-\t\t\t}\n-\t\t\treturn sb.toString();\n-\t\t} else if(attribute.getType().equals(LinkedHashMap.class.getName())) {\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tfor(Map.Entry<String, String> entry : ((Map<String, String>) attribute.getValue()).entrySet()) {\n-\t\t\t\tString key = entry.getKey();\n-\t\t\t\tif(key == null) {\n-\t\t\t\t\tkey = \"\\\\0\";\n-\t\t\t\t} else {\n-\t\t\t\t\tkey = key.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n-\t\t\t\t\tkey = key.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n-\t\t\t\t\tkey = key.replace(Character.toString(KEY_VALUE_DELIMITER), \"\\\\\" + KEY_VALUE_DELIMITER); //escape KEY_VALUE_DELIMITER\n-\t\t\t\t}\n-\n-\t\t\t\tString value = entry.getValue();\n-\t\t\t\tif(value == null) {\n-\t\t\t\t\tvalue = \"\\\\0\";\n-\t\t\t\t} else {\n-\t\t\t\t\tvalue = value.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n-\t\t\t\t\tvalue = value.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n-\t\t\t\t\tvalue = value.replace(Character.toString(KEY_VALUE_DELIMITER), \"\\\\\" + KEY_VALUE_DELIMITER); //escape KEY_VALUE_DELIMITER\n-\t\t\t\t}\n-\n-\t\t\t\tsb.append(key);\n-\t\t\t\tsb.append(KEY_VALUE_DELIMITER);\n-\t\t\t\tsb.append(value);\n-\t\t\t\tsb.append(LIST_DELIMITER);\n-\t\t\t}\n-\t\t\treturn sb.toString();\n-\t\t} else throw new InternalErrorException(\"Unknown java type of attribute's value.\");\n-\t}\n-\n-\t/**\n-\t * This method get map created by example : {<key1>=<value1>, <key2>=<value2>}\n-\t * Keys and values are escaped for \"\\\", \"<\" and \">\"\n-\t * Example of escaping key=\"key\\\\s\\>\" is \"key\\s>\"\n-\t * Return Map<String, String> attribute to value.\n-\t *\n-\t * @param text text from which will be parsed map\n-\t * @return map<string, string> attributes\n-\t */\n-\tpublic static Map<String, String> deserializeStringToMap(String text) {\n-\t\tif(text.equals(\"\\\\0\")) return null;\n-\t\tMap<String, String> map = new HashMap<String, String>();\n-\t\tint startName = -1;\n-\t\tint endName = -1;\n-\t\tint startValue = -1;\n-\t\tint endValue = -1;\n-\t\tint pointyBrackets = 0;\n-\t\tboolean notValue = true;\n-\n-\t\tfor(int i = 0; i < text.length(); i++) {\n-\t\t\tif(text.charAt(i) == '<' && notValue && startName == -1) {\n-\t\t\t\tif (!BeansUtils.isEscaped(text, i - 1)) {\n-\t\t\t\t\tstartName = i;\n-\t\t\t\t}\n-\t\t\t}else if(text.charAt(i) == '>' && notValue && endName == -1) {\n-\t\t\t\tif (!BeansUtils.isEscaped(text, i - 1)) {\n-\t\t\t\t\tendName = i;\n-\t\t\t\t\tnotValue = false;\n-\t\t\t\t}\n-\t\t\t} else if(text.charAt(i) == '<' && !notValue && startValue == -1) {\n-\t\t\t\tif (!BeansUtils.isEscaped(text, i - 1)) {\n-\t\t\t\t\tstartValue = i;\n-\t\t\t\t}\n-\t\t\t} else if(text.charAt(i) == '>' && !notValue && endValue == -1) {\n-\t\t\t\tif (!BeansUtils.isEscaped(text, i - 1)) {\n-\t\t\t\t\tendValue = i;\n-\t\t\t\t\tnotValue = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (startName != -1 && endName != -1 && startValue != -1 && endValue != -1) {\n-\t\t\t\tmap.put(BeansUtils.eraseEscaping(text.substring(startName + 1, endName)), BeansUtils.eraseEscaping(text.substring(startValue + 1, endValue)));\n-\t\t\t\tstartName = -1;\n-\t\t\t\tendName = -1;\n-\t\t\t\tstartValue = -1;\n-\t\t\t\tendValue = -1;\n-\t\t\t}\n-\t\t}\n-\t\treturn map;\n-\t}\n-\n-\t/**\n-\t * Converts string representation of an attribute value to correct java object\n-\t *\n-\t * @param stringValue string representation of the attribute value\n-\t * @param type type of the value (\"Java.lang.String\" for example)/\n-\t * @return\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tpublic static Object stringToAttributeValue(String stringValue, String type) throws InternalErrorException {\n-\t\tif(stringValue == null || stringValue.isEmpty()) return null;\n-\n-\t\tClass<?> attributeClass;\n-\t\ttry {\n-\t\t\tattributeClass = Class.forName(type);\n-\t\t} catch (ClassNotFoundException e) {\n-\t\t\tthrow new InternalErrorException(\"Unknown attribute type\", e);\n-\t\t} catch (NoClassDefFoundError e) {\n-\t\t\tthrow new InternalErrorException(\"Unknown attribute def type\", e);\n-\t\t}\n-\n-\t\tif(attributeClass.equals(String.class)) {\n-\t\t\treturn stringValue;\n-\t\t} else if(attributeClass.equals(Integer.class)) {\n-\t\t\treturn Integer.parseInt(stringValue);\n-\t\t} else if(attributeClass.equals(Boolean.class)) {\n-\t\t\treturn Boolean.parseBoolean(stringValue);\n-\t\t} else if(attributeClass.equals(ArrayList.class)) {\n-\t\t\tString[] array = stringValue.split(Character.toString(LIST_DELIMITER), -1);\n-\t\t\tList<String> attributeValue =  new ArrayList<String>();\n-\n-\t\t\t//join items which was splited on escaped LIST_DELIMITER\n-\t\t\tfor(int i = 0; i < array.length -1; i++) { //itarate to lenght -1  ... last array item is always empty\n-\t\t\t\tString item = array[i];\n-\t\t\t\twhile(item.matches(\"^(.*[^\\\\\\\\])?(\\\\\\\\\\\\\\\\)*\\\\\\\\$\")) { //item last char is '\\' . Next item start with ',', so we need to concat this items.\n-\t\t\t\t\titem = item.substring(0, item.length()-1);  //cut off last char ('\\')\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\titem = item.concat(Character.toString(LIST_DELIMITER)).concat(array[i+1]);\n-\t\t\t\t\t\ti++;\n-\t\t\t\t\t} catch(ArrayIndexOutOfBoundsException ex) {\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"Bad format in attribute value\", ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t//unescape\n-\t\t\t\titem = item.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + \"])\", \"$1\");\n-\t\t\t\tif(item.equals(\"\\\\0\")) item = null;\n-\n-\t\t\t\t//return updated item back to list\n-\t\t\t\tattributeValue.add(item);\n-\t\t\t}\n-\n-\t\t\treturn attributeValue;\n-\t\t} else if(attributeClass.equals(LinkedHashMap.class)) {\n-\t\t\tString[] array = stringValue.split(Character.toString(LIST_DELIMITER), -1);\n-\t\t\tMap<String, String> attributeValue = new LinkedHashMap<String, String>();\n-\n-\t\t\t//join items which was splited on escaped LIST_DELIMITER\n-\t\t\tfor(int i = 0; i < array.length -1; i++) {  //itarate to lenght -1  ... last array item is always empty\n-\t\t\t\tString mapEntry = array[i];\n-\n-\t\t\t\twhile(mapEntry.matches(\"^(.*[^\\\\\\\\])?(\\\\\\\\\\\\\\\\)*\\\\\\\\$\")) { //mapEntry last char is '\\' . Next mapEntry start with ',', so we need to concat this mapEntries.\n-\t\t\t\t\tmapEntry = mapEntry.substring(0, mapEntry.length()-1);  //cut off last char ('\\')\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tmapEntry = mapEntry.concat(Character.toString(LIST_DELIMITER)).concat(array[i+1]);\n-\t\t\t\t\t\ti++;\n-\t\t\t\t\t} catch(ArrayIndexOutOfBoundsException ex) {\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"Bad format in attribute value\", ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tboolean delimiterFound = false;\n-\t\t\t\tint delimiterIndex = -1;\n-\n-\n-\t\t\t\twhile(!delimiterFound) {\n-\t\t\t\t\tdelimiterIndex++; //start searching at next char then last time\n-\t\t\t\t\tdelimiterIndex = mapEntry.indexOf(Character.toString(KEY_VALUE_DELIMITER), delimiterIndex);\n-\t\t\t\t\tif(delimiterIndex == -1) throw new ConsistencyErrorException(\"Bad format in attribute value. KEY_VALUE_DELIMITER not found. Attribute value='\" + stringValue + \"', processed entry='\" + mapEntry + \"'\");\n-\n-\t\t\t\t\t//check if this delimiter is not escaped\n-\t\t\t\t\tboolean isEscaped = false;  //is delimiter escaped\n-\t\t\t\t\tboolean stop = false;\n-\t\t\t\t\tint processedIndex = delimiterIndex - 1;\n-\t\t\t\t\twhile(!stop && processedIndex >= 0) {\n-\t\t\t\t\t\tif(mapEntry.charAt(processedIndex) == '\\\\') {\n-\t\t\t\t\t\t\tisEscaped = !isEscaped;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tstop = true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tprocessedIndex--;\n-\t\t\t\t\t}\n-\t\t\t\t\tif(!isEscaped) delimiterFound = true;\n-\t\t\t\t}\n-\n-\t\t\t\tString key = mapEntry.substring(0, delimiterIndex);\n-\t\t\t\tString value = mapEntry.substring(delimiterIndex+1);\n-\n-\t\t\t\t//unescape\n-\t\t\t\tkey = key.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + Character.toString(KEY_VALUE_DELIMITER) + \"])\", \"$1\");\n-\t\t\t\tvalue = value.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + Character.toString(KEY_VALUE_DELIMITER) + \"])\", \"$1\");\n-\n-\t\t\t\tif(key.equals(\"\\\\0\")) key = null;\n-\t\t\t\tif(value.equals(\"\\\\0\")) value = null;\n-\n-\t\t\t\t//return updated item back to list\n-\t\t\t\tattributeValue.put(key, value);\n-\t\t\t}\n-\n-\t\t\treturn attributeValue;\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"Unknown attribute type. (\"+ attributeClass.toString() + \")\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Take perunBean name and if it is RichObject, convert it to simple name.\n-\t *\n-\t * RichObject mean: starts with \"Rich\" and continue with Upper Letter [A-Z]\n-\t *\n-\t * Ex.: RichGroup -> Group, RichUser -> User\n-\t * Ex.: RichardObject -> RichardObject\n-\t * Ex.: Null -> Null\n-\t *\n-\t * @param beanName bean Name of PerunBean (simple name of object)\n-\t *\n-\t * @return converted beanName (without Rich part)\n-\t */\n-\tpublic static String convertRichBeanNameToBeanName(String beanName) {\n-\t\tif(beanName == null || beanName.isEmpty()) return beanName;\n-\n-\t\tMatcher richBeanNameMatcher = richBeanNamePattern.matcher(beanName);\n-\t\tif (richBeanNameMatcher.find()) {\n-\t\t\treturn richBeanNameMatcher.group(1);\n-\t\t}\n-\n-\t\treturn beanName;\n-\t}\n-\n-\t/**\n-\t * Create a string with set of IN clause. Every in clause has maximum 1000 ids.\n-\t * Identifier means for what IN clause is calling (Like 'table.id')\n-\t *\n-\t * Reason for using is compatibility with oracle and other dbs.\n-\t *\n-\t * Example: \" ( in (10,15,...) or in (...) or ... ) \"\n-\t *\n-\t * @param beans list of perun beans\n-\t * @return string with some sql IN clause\n-\t */\n-\tpublic static String prepareInSQLClause(String identifier, List<? extends PerunBean> beans) {\n-\t\t//get Ids\n-\t\tList<Integer> beansIds = new ArrayList<>();\n-\t\tfor(PerunBean pb: beans) {\n-\t\t\tbeansIds.add(pb.getId());\n-\t\t}\n-\t\treturn BeansUtils.prepareInSQLClause(beansIds, identifier);\n-\t}\n-\n-\n-\t/**\n-\t * Create a string with set of IN clause. Every in clause has maximum 1000 ids.\n-\t * Identifier means for what IN clause is calling (Like 'table.id')\n-\t *\n-\t * Reason for using is compatibility with oracle and other dbs.\n-\t *\n-\t * Example: \" ( in (10,15,...) or in (...) or ... ) \"\n-\t *\n-\t * @param beansIds list of perun bean ids\n-\t * @return string with some sql IN clause\n-\t */\n-\tpublic static String prepareInSQLClause(List<Integer> beansIds, String identifier) {\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\t//use or in sql clause\n-\t\tboolean useOr = false;\n-\t\t//first bracket\n-\t\tsb.append(\" (\");\n-\n-\t\t//for every maxSize of beans\n-\t\twhile(beansIds.size() > MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE ) {\n-\n-\t\t\tif(useOr) sb.append(\" or \");\n-\t\t\telse useOr = true;\n-\n-\t\t\tsb.append(\" \");\n-\t\t\tsb.append(identifier);\n-\t\t\tsb.append(\" in (\");\n-\t\t\tList<Integer> partOfBeansIds = beansIds.subList(0, MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE);\n-\t\t\tsb.append(beanIdsToString(partOfBeansIds));\n-\t\t\tsb.append(\") \");\n-\t\t\tpartOfBeansIds.clear();\n-\t\t}\n-\n-\t\t//for rest of beans less or equals to 1000\n-\t\tif(useOr) sb.append(\" or \");\n-\t\tsb.append(\" \");\n-\t\tsb.append(identifier);\n-\t\tsb.append(\" in (\");\n-\t\tsb.append(beanIdsToString(beansIds));\n-\t\tsb.append(\") \");\n-\n-\t\t//last bracket\n-\t\tsb.append(\") \");\n-\t\treturn sb.toString();\n-\t}\n-\n-\t/**\n-\t * Convert list of beans ids to one string with ',' between ids\n-\t *\n-\t * @param beans List of ids to construct string with\n-\t * @return string representation of list of ids\n-\t */\n-\tpublic static String beanIdsToString(List<Integer> beansIds) {\n-\t\tStringBuilder stringBuilder = new StringBuilder();\n-\t\tfor(Integer beanId : beansIds) {\n-\t\t\tstringBuilder.append(\",\");\n-\t\t\tstringBuilder.append(beanId);\n-\t\t\t}\n-\t\tstringBuilder.deleteCharAt(0);\n-\t\treturn stringBuilder.toString();\n-\t}\n-\n-\t/**\n-\t * Gets particular property from perun.properties file.\n-\t *\n-\t * @param propertyName name of the property\n-\t * @return value of the property\n-\t */\n-\tpublic static String getPropertyFromConfiguration(String propertyName) throws InternalErrorException {\n-\t\tlog.trace(\"Entering getPropertyFromConfiguration: propertyName='\" + propertyName + \"'\");\n-\t\tnotNull(propertyName, \"propertyName\");\n-\n-\t\tif(BeansUtils.properties == null) {\n-\t\t\t// Load properties file with configuration\n-\t\t\tProperties properties = new Properties();\n-\t\t\ttry {\n-\t\t\t\t// Get the path to the perun.properties file\n-\t\t\t\tBufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + \"perun.properties\"));\n-\t\t\t\tproperties.load(is);\n-\t\t\t\tis.close();\n-\t\t\t} catch (FileNotFoundException e) {\n-\t\t\t\tthrow new InternalErrorException(\"Cannot find perun.properties file\", e);\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tthrow new InternalErrorException(\"Cannot read perun.properties file\", e);\n-\t\t\t}\n-\n-\t\t\tBeansUtils.properties = properties;\n-\t\t}\n-\t\tString property = BeansUtils.properties.getProperty(propertyName);\n-\t\tif (property == null) {\n-\t\t\tthrow new InternalErrorException(\"Property \" + propertyName + \" cannot be found in the configuration file\");\n-\t\t}\n-\t\treturn property;\n-\t}\n-\n-\t/**\n-\t * Gets particular property from custom property file.\n-\t *\n-\t * @param propertyFile name of properties file\n-\t * @param propertyName name of the property\n-\t * @return value of the property\n-\t */\n-\tpublic static String getPropertyFromCustomConfiguration(String propertyFile, String propertyName) throws InternalErrorException {\n-\t\tlog.trace(\"Entering getPropertyFromCustomConfiguration: propertyFile='\" +  propertyFile + \"' propertyName='\" +  propertyName + \"'\");\n-\t\tnotNull(propertyName, \"propertyName\");\n-\t\tnotNull(propertyFile, \"propertyFile\");\n-\n-\t\t// Load properties file with configuration\n-\t\tProperties properties = new Properties();\n-\t\ttry {\n-\t\t\t// Get the path to the perun.properties file\n-\t\t\tBufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + propertyFile));\n-\t\t\tproperties.load(is);\n-\t\t\tis.close();\n-\n-\t\t\tString property = properties.getProperty(propertyName);\n-\t\t\tif (property == null) {\n-\t\t\t\tthrow new InternalErrorException(\"Property \" + propertyName + \" cannot be found in the configuration file: \"+propertyFile);\n-\t\t\t}\n-\t\t\treturn property;\n-\t\t} catch (FileNotFoundException e) {\n-\t\t\tthrow new InternalErrorException(\"Cannot find \"+propertyFile+\" file\", e);\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new InternalErrorException(\"Cannot read \"+propertyFile+\" file\", e);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Gets all properties from custom property file.\n-\t *\n-\t * @param propertyFile name of properties file\n-\t * @return all properties with values\n-\t */\n-\tpublic static Map<String, String> getAllPropertiesFromCustomConfiguration(String propertyFile) throws InternalErrorException {\n-\t\tlog.trace(\"Entering getAllPropertiesFromCustomConfiguration: propertyFile='\" + propertyFile + \"'\");\n-\t\tnotNull(propertyFile, \"propertyFile\");\n-\n-\t\t// Load properties file with configuration\n-\t\tProperties properties = new Properties();\n-\t\ttry {\n-\n-\t\t\t// Get the path to the perun.properties file\n-\t\t\tBufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + propertyFile));\n-\t\t\tproperties.load(is);\n-\t\t\tis.close();\n-\n-\t\t\tMap<String, String> myMap = new HashMap<String, String>();\n-\t\t\tfor (Object key : properties.keySet()) {\n-\t\t\t\tmyMap.put(key.toString(), properties.get(key).toString());\n-\t\t\t}\n-\t\t\treturn myMap;\n-\n-\t\t} catch (FileNotFoundException e) {\n-\t\t\tthrow new InternalErrorException(\"Cannot find \"+propertyFile+\" file\", e);\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new InternalErrorException(\"Cannot read \"+propertyFile+\" file\", e);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * True if this instance of perun is read only.\n-\t * False if not.\n-\t *\n-\t * @return true or false (readOnly or not)\n-\t */\n-\tpublic static boolean isPerunReadOnly() {\n-\t\t//Set only if variable isPerunReadOnly is not set already\n-\t\tif(isPerunReadOnly == null) {\n-\t\t\tString readOnly;\n-\t\t\ttry {\n-\t\t\t\treadOnly = BeansUtils.getPropertyFromConfiguration(\"perun.readOnlyPerun\");\n-\t\t\t} catch (Exception ex) {\n-\t\t\t\t//If something wierd happens, set this to normal configuration (not readOnly) and log this exception\n-\t\t\t\tlog.error(\"Problem occures when trying to get readOnly configuration from perun properties file.\", ex);\n-\t\t\t\tlog.debug(\"Read only configuration not found, set to false.\");\n-\t\t\t\tisPerunReadOnly = false;\n-\t\t\t\treturn isPerunReadOnly;\n-\t\t\t}\n-\n-\t\t\tif(readOnly == null) {\n-\t\t\t\tlog.debug(\"Read only configuration is null, set to false.\");\n-\t\t\t\tisPerunReadOnly = false;\n-\t\t\t\treturn isPerunReadOnly;\n-\t\t\t}\n-\n-\t\t\tif(readOnly.contains(\"true\")) {\n-\t\t\t\tlog.debug(\"Read only configuration found='{}', set to true.\", readOnly);\n-\t\t\t\tisPerunReadOnly = true;\n-\t\t\t\treturn isPerunReadOnly;\n-\t\t\t}\n-\n-\t\t\tlog.debug(\"Read only configuration found='{}', set to false.\", readOnly);\n-\t\t\tisPerunReadOnly = false;\n-\t\t\treturn isPerunReadOnly;\n-\t\t} else {\n-\t\t\treturn isPerunReadOnly;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * True if DB initializator is enabled, false if not\n-\t * Default is false\n-\t *\n-\t * @return true if enabled, false if disabled\n-\t */\n-\tpublic static boolean initializatorEnabled() {\n-\t\tString initializatorEnabled;\n-\t\ttry {\n-\t\t\tinitializatorEnabled = BeansUtils.getPropertyFromConfiguration(\"perun.DBInitializatorEnabled\");\n-\t\t} catch (Exception ex) {\n-\t\t\t//If something wierd happens, set this to normal configuration (not readOnly) and log this exception\n-\t\t\tlog.error(\"Problem occures when trying to get DBInitializatorEnabled configuration from perun properties file.\", ex);\n-\t\t\tlog.debug(\"DBInitializatorEnabled configuration not found, set to false.\");\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif(initializatorEnabled == null) {\n-\t\t\tlog.debug(\"DBInitializatorEnabled configuration is null, set to false.\");\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif(initializatorEnabled.contains(\"true\")) {\n-\t\t\tlog.debug(\"DBInitializatorEnabled configuration found='{}', set to true.\", initializatorEnabled);\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tlog.debug(\"Read only configuration found='{}', set to false.\", initializatorEnabled);\n-\t\treturn false;\n-\t}\n-\t\n-\t/**\n-\t * Checks whether the object is null or not.\n-\t *\n-\t * @param e\n-\t * @param name\n-\t * @throws InternalErrorException which wraps NullPointerException\n-\t */\n-\tpublic static void notNull(Object e, String name) throws InternalErrorException {\n-\t\tif(e == null){\n-\t\t\tthrow new InternalErrorException(new NullPointerException(\"'\" + name + \"' is null\"));\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Set already filled-in properties (used by Spring container to inject properties bean)\n-\t *\n-\t * @param properties\n-\t * @return\n-\t */\n-\tpublic static Properties setProperties(Properties properties) {\n-\t\tBeansUtils.properties = properties;\n-\t\treturn BeansUtils.properties;\n-\t}\n-\n-\tpublic static String getIDsOfPerunBeans(List<? extends PerunBean> listOfBeans) {\n-\t\tif (listOfBeans == null || listOfBeans.isEmpty()) {\n-\t\t\treturn \"\";\n-\t\t}\n-\n-\t\tBoolean isFirstIteration = true;\n-\t\tStringBuilder str = new StringBuilder();\n-\t\tfor(PerunBean perunBean : listOfBeans) {\n-\t\t\tif(isFirstIteration) {\n-\t\t\t\tstr.append(perunBean.getId());\n-\t\t\t\tisFirstIteration = false;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tstr.append(\",\").append(perunBean.getId());\n-\t\t\t}\n-\t\t}\n-\t\treturn str.toString();\n-\t}\n-}\n+\n+ private final static Logger log = LoggerFactory.getLogger(BeansUtils.class);\n+ private final static Pattern patternForCommonNameParsing = Pattern.compile(\"(([\\\\w]*. )*)([\\\\p{L}-']+) ([\\\\p{L}-']+)[, ]*(.*)\");\n+ private final static Pattern richBeanNamePattern = Pattern.compile(\"^Rich([A-Z].*$)\");\n+\n+ public static final char LIST_DELIMITER =',';\n+\n+ public static final char KEY_VALUE_DELIMITER =':';\n+ private final static int MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE = 1000;\n+\n+ public final static String configurationsLocations = \"/etc/perun/\";\n+ private static Properties properties;\n+ private static Boolean isPerunReadOnly = null;\n+\n+ /**\n+  * Method create formatter with default settings for perun timestamps and set lenient on false\n+  * Timestamp format:  \"yyyy-MM-dd HH:mm:ss.S\" - \"ex. 2014-01-01 10:10:10.0\"\n+  *\n+  * Lenient on false means that formatter will be more strict to creating timestamp from string\n+  *\n+  * IMPORTANT: SimpleDateFormat is not thread safe !!!\n+  *\n+  * @return date formatter\n+  */\n+\n+ public static DateFormat getDateFormatter() {\n+  DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n+  df.setLenient(false);\n+  return df;\n+ }\n+\n+ /**\n+  * Method create formatter with default settings for perun timestamps (only date without time)\n+  * and set lenient on false.\n+  *\n+  * Timestamp format:  \"yyyy-MM-dd\" - \"ex. 2014-01-01\"\n+  *\n+  * Lenient on false means that formatter will be more strict to creating timestamp from string\n+  *\n+  * IMPORTANT: SimpleDateFormat is not thread safe !!!\n+  *\n+  * @return date formatter\n+  */\n+\n+ public static DateFormat getDateFormatterWithoutTime() {\n+  DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n+  df.setLenient(false);\n+  return df;\n+ }\n+\n+ /**\n+  * This method take text and for every chars in \"<>\\\" erase escaping\n+  * also change '\\0' to 'null' if it is escaped zero symbol.\n+  *\n+  * Escaping char is \\.\n+  * Expecting: Before using this method, text must be escaped by using method createEscaping.\n+  *            So in text will never be string like \"\\\\>\", \"\\\" or \"\\\\\\\".\n+  *\n+  * For every \\ in text it put \\\\ and for every < it put \\< and for every > it put \\>\n+  *\n+  * @param text text from which will be erase escaping\n+  * @return nonescaped text\n+  */\n+\n+ public static String eraseEscaping(String text) {\n+  if (text == null || text.equals(\"\\\\0\"))\n+   return null;\n+  //change \\0 to null if zero is escaped\n+  text = text.replaceAll(\"((^|[^\\\\\\\\])(\\\\\\\\\\\\\\\\)*)(\\\\\\\\0)\", \"$1null\");\n+  text = text.replace(\"\\\\>\", \">\");\n+  text = text.replace(\"\\\\<\", \"<\");\n+  text = text.replace(\"\\\\\\\\\", \"\\\\\");\n+  return text;\n+ }\n+ /**\n+  * This method take text and for every chars in \"<>\\\" create escaping\n+  * Escaping char is \\.\n+  * For every \\\\ in text it put \\ and for every \\< it put < and for every \\> it put >\n+  *\n+  * @param text text from which will be erase escaping\n+  * @return escaped text\n+  */\n+\n+ public static String createEscaping(String text) {\n+  if (text == null)\n+   return \"\\\\0\";\n+  text = text.replace(\"\\\\\", \"\\\\\\\\\");\n+  text = text.replace(\">\", \"\\\\>\");\n+  text = text.replace(\"<\", \"\\\\<\");\n+  return text;\n+ }\n+\n+ /**\n+  * This method get text and all nonescaped characters < and > replace by apostrophe\n+  *\n+  * @param text\n+  * @return text where nonescaped characters < and  > will be reaplace by apostrophe '\n+  */\n+\n+ public static String replacePointyBracketsByApostrophe(String text) {\n+  StringBuilder stringBuilder = new StringBuilder(text);\n+  for (int i = 0; i<text.length(); i++) {\n+   if (text.charAt(i) == '<' || text.charAt(i) == '>') {\n+    if (!isEscaped(text, i -1)) {\n+     stringBuilder.setCharAt(i, '\\'');\n+    }\n+   }\n+  }\n+\n+  return stringBuilder.toString();\n+ }\n+\n+ /**\n+  * This method get text and all escaped \\0 replace for text null\n+  *\n+  * @param text\n+  * @return text where \\0 is replaced for null\n+  */\n+\n+ public static String replaceEscapedNullByStringNull(String text) {\n+  StringBuilder stringBuilder = new StringBuilder(text);\n+  for (int i = 0; i<stringBuilder.length(); i++) {\n+   if (stringBuilder.charAt(i) == '0') {\n+    if (isEscaped(stringBuilder.toString(), i -1)) {\n+     stringBuilder.replace(i -1, i + 1, \"null\");\n+     i = i + 2;\n+    }\n+   }\n+  }\n+\n+  return stringBuilder.toString();\n+ }\n+\n+ /**\n+  * Return true, if char on position in text is escaped by '\\' Return false,\n+  * if not.\n+  *\n+  * @param text text in which will be searching\n+  * @param position position in text <0-text.length>\n+  * @return true if char is escaped, false if not\n+  */\n+\n+ public static boolean isEscaped(String text, int position) {\n+\n+  boolean escaped = false;\n+  while (text.charAt(position) == '\\\\') {\n+   escaped = !escaped;\n+   position--;\n+   if (position< 0) {\n+    return escaped;\n+   }\n+  }\n+\n+  return escaped;\n+ }\n+\n+ /**\n+  * Serialize map to string\n+  *\n+  * @param map\n+  * @return string of escaped map\n+  */\n+\n+ public static String serializeMapToString(Map<String, String> map) {\n+  if (map == null)\n+   return \"\\\\0\";\n+  Map<String, String> attrNew = new HashMap<String, String>(map);\n+  Set<String> keys = new HashSet<String>(attrNew.keySet());\n+  for (String s : keys) {\n+   attrNew.put(\"<\" + BeansUtils.createEscaping(s) + \">\", \"<\" + BeansUtils.createEscaping(attrNew.get(s)) + \">\");\n+   attrNew.remove(s);\n+  }\n+\n+  return attrNew.toString();\n+ }\n+\n+\n+ /**\n+  * Converts attribute value to string (for storing into DB)\n+  *\n+  * @param attribute value of the attribute\n+  * @return string representation of the value\n+  *\n+  * @throws InternalErrorException\n+  */\n+\n+ public static String attributeValueToString(Attribute attribute) throws InternalErrorException {\n+  if (attribute == null) throw new InternalErrorException(new NullPointerException(\"attribute is null\"));\n+  if (attribute.getValue() == null)\n+   return null;\n+  if (!attribute.getType().equals(attribute.getValue().getClass().getName())) {\n+   throw new InternalErrorException(\"Attribute's type mismatch \" + attribute + \". The type of attribute's value (\" + attribute.getValue().getClass().getName() + \") doesn't match the type of attribute (\" + attribute.getType() + \").\");\n+  }\n+  if (attribute.getType().equals(String.class.getName())) {\n+   return (String) attribute.getValue();\n+  } else if (attribute.getType().equals(Integer.class.getName())) {\n+   return Integer.toString((Integer) attribute.getValue());\n+  } else if (attribute.getType().equals(Boolean.class.getName())) {\n+          return Boolean.toString((Boolean) attribute.getValue());\n+         } else if (attribute.getType().equals(ArrayList.class.getName())) {\n+          StringBuilder sb = new StringBuilder();\n+          for (String item : (List<String>) attribute.getValue()) {\n+           if (item == null) {\n+            item = \"\\\\0\";\n+           } else {\n+            item = item.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n+            item = item.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n+           }\n+           sb.append(item);\n+           sb.append(LIST_DELIMITER);\n+          }\n+\n+          return sb.toString();\n+         } else if (attribute.getType().equals(LinkedHashMap.class.getName())) {\n+                 StringBuilder sb = new StringBuilder();\n+                 for (Map.Entry<String, String> entry : ((Map<String, String>) attribute.getValue()).entrySet()) {\n+                  String key = entry.getKey();\n+                  if (key == null) {\n+                   key = \"\\\\0\";\n+                  } else {\n+                   key = key.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n+                   key = key.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n+                   key = key.replace(Character.toString(KEY_VALUE_DELIMITER), \"\\\\\" + KEY_VALUE_DELIMITER); //escape KEY_VALUE_DELIMITER\n+                  }\n+                  String value = entry.getValue();\n+                  if (value == null) {\n+                   value = \"\\\\0\";\n+                  } else {\n+                   value = value.replace(\"\\\\\", \"\\\\\\\\\");   //escape char '\\'\n+                   value = value.replace(Character.toString(LIST_DELIMITER), \"\\\\\" + LIST_DELIMITER); //escape LIST_DELIMITER\n+                   value = value.replace(Character.toString(KEY_VALUE_DELIMITER), \"\\\\\" + KEY_VALUE_DELIMITER); //escape KEY_VALUE_DELIMITER\n+                  }\n+                  sb.append(key);\n+                  sb.append(KEY_VALUE_DELIMITER);\n+                  sb.append(value);\n+                  sb.append(LIST_DELIMITER);\n+                 }\n+\n+                 return sb.toString();\n+                } else throw new InternalErrorException(\"Unknown java type of attribute's value.\");\n+ }\n+\n+ /**\n+  * This method get map created by example : {<key1>=<value1>, <key2>=<value2>}\n+  * Keys and values are escaped for \"\\\", \"<\" and \">\"\n+  * Example of escaping key=\"key\\\\s\\>\" is \"key\\s>\"\n+  * Return Map<String, String> attribute to value.\n+  *\n+  * @param text text from which will be parsed map\n+  * @return map<string, string> attributes\n+  */\n+\n+ public static Map<String, String> deserializeStringToMap(String text) {\n+  if (text.equals(\"\\\\0\"))\n+   return null;\n+  Map<String, String> map = new HashMap<String, String>();\n+  int startName = -1;\n+  int endName = -1;\n+  int startValue = -1;\n+  int endValue = -1;\n+  int pointyBrackets = 0;\n+  boolean notValue = true;\n+  for (int i = 0; i<text.length(); i++) {\n+   if (text.charAt(i) == '<' && notValue && startName == -1) {\n+    if (!BeansUtils.isEscaped(text, i -1)) {\n+     startName = i;\n+    }\n+   } else if (text.charAt(i) == '>' && notValue && endName == -1) {\n+    if (!BeansUtils.isEscaped(text, i -1)) {\n+     endName = i;\n+     notValue = false;\n+    }\n+   } else if (text.charAt(i) == '<' && !notValue && startValue == -1) {\n+           if (!BeansUtils.isEscaped(text, i -1)) {\n+            startValue = i;\n+           }\n+          } else if (text.charAt(i) == '>' && !notValue && endValue == -1) {\n+           if (!BeansUtils.isEscaped(text, i -1)) {\n+            endValue = i;\n+            notValue = true;\n+           }\n+          }\n+   if (startName != -1 && endName != -1 && startValue != -1 && endValue != -1) {\n+    map.put(BeansUtils.eraseEscaping(text.substring(startName + 1, endName)), BeansUtils.eraseEscaping(text.substring(startValue + 1, endValue)));\n+    startName = -1;\n+    endName = -1;\n+    startValue = -1;\n+    endValue = -1;\n+   }\n+  }\n+\n+  return map;\n+ }\n+\n+ /**\n+  * Converts string representation of an attribute value to correct java object\n+  *\n+  * @param stringValue string representation of the attribute value\n+  * @param type type of the value (\"Java.lang.String\" for example)/\n+  * @return\n+  *\n+  * @throws InternalErrorException\n+  */\n+\n+ public static Object stringToAttributeValue(String stringValue, String type) throws InternalErrorException {\n+  if (stringValue == null || stringValue.isEmpty())\n+   return null;\n+  Class<?> attributeClass;\n+  try {\n+   attributeClass = Class.forName(type);\n+  } catch (ClassNotFoundException e) {\n+   throw new InternalErrorException(\"Unknown attribute type\", e);\n+  } catch (NoClassDefFoundError e) {\n+   throw new InternalErrorException(\"Unknown attribute def type\", e);\n+  }\n+  if (attributeClass.equals(String.class)) {\n+   return stringValue;\n+  } else if (attributeClass.equals(Integer.class)) {\n+   return Integer.parseInt(stringValue);\n+  } else if (attributeClass.equals(Boolean.class)) {\n+          return Boolean.parseBoolean(stringValue);\n+         } else if (attributeClass.equals(ArrayList.class)) {\n+          String[] array = stringValue.split(Character.toString(LIST_DELIMITER), -1);\n+          List<String> attributeValue = new ArrayList<String>();\n+\n+   //join items which was splited on escaped LIST_DELIMITER\n+          for (int i = 0; i<array.length -1; i++) { //itarate to lenght -1  ... last array item is always empty\n+           String item = array[i];\n+           while (item.matches(\"^(.*[^\\\\\\\\])?(\\\\\\\\\\\\\\\\)*\\\\\\\\$\")) { //item last char is '\\' . Next item start with ',', so we need to concat this items.\n+            item = item.substring(0, item.length()-1);  //cut off last char ('\\')\n+\n+            try {\n+             item = item.concat(Character.toString(LIST_DELIMITER)).concat(array[i + 1]);\n+             i++;\n+            } catch (ArrayIndexOutOfBoundsException ex) {\n+             throw new ConsistencyErrorException(\"Bad format in attribute value\", ex);\n+            }\n+           }\n+    //unescape\n+           item = item.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + \"])\", \"$1\");\n+           if (item.equals(\"\\\\0\")) item = null;\n+\n+    //return updated item back to list\n+           attributeValue.add(item);\n+          }\n+\n+          return attributeValue;\n+         } else if (attributeClass.equals(LinkedHashMap.class)) {\n+                 String[] array = stringValue.split(Character.toString(LIST_DELIMITER), -1);\n+                 Map<String, String> attributeValue = new LinkedHashMap<String, String>();\n+\n+   //join items which was splited on escaped LIST_DELIMITER\n+                 for (int i = 0; i<array.length -1; i++) {  //itarate to lenght -1  ... last array item is always empty\n+                  String mapEntry = array[i];\n+                  while (mapEntry.matches(\"^(.*[^\\\\\\\\])?(\\\\\\\\\\\\\\\\)*\\\\\\\\$\")) { //mapEntry last char is '\\' . Next mapEntry start with ',', so we need to concat this mapEntries.\n+                   mapEntry = mapEntry.substring(0, mapEntry.length()-1);  //cut off last char ('\\')\n+\n+                   try {\n+                    mapEntry = mapEntry.concat(Character.toString(LIST_DELIMITER)).concat(array[i + 1]);\n+                    i++;\n+                   } catch (ArrayIndexOutOfBoundsException ex) {\n+                    throw new ConsistencyErrorException(\"Bad format in attribute value\", ex);\n+                   }\n+                  }\n+\n+                  boolean delimiterFound = false;\n+                  int delimiterIndex = -1;\n+                  while (!delimiterFound) {\n+                   delimiterIndex++; //start searching at next char then last time\n+                   delimiterIndex = mapEntry.indexOf(Character.toString(KEY_VALUE_DELIMITER), delimiterIndex);\n+                   if (delimiterIndex == -1) throw new ConsistencyErrorException(\"Bad format in attribute value. KEY_VALUE_DELIMITER not found. Attribute value='\" + stringValue + \"', processed entry='\" + mapEntry + \"'\");\n+\n+     //check if this delimiter is not escaped\n+\n+                   boolean isEscaped = false;  //is delimiter escaped\n+                   boolean stop = false;\n+                   int processedIndex = delimiterIndex -1;\n+                   while (!stop && processedIndex >= 0) {\n+                    if (mapEntry.charAt(processedIndex) == '\\\\') {\n+                     isEscaped = !isEscaped;\n+                    } else {\n+                     stop = true;\n+                    }\n+                    processedIndex--;\n+                   }\n+                   if (!isEscaped) delimiterFound = true;\n+                  }\n+                  String key = mapEntry.substring(0, delimiterIndex);\n+                  String value = mapEntry.substring(delimiterIndex + 1);\n+\n+    //unescape\n+                  key = key.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + Character.toString(KEY_VALUE_DELIMITER) + \"])\", \"$1\");\n+                  value = value.replaceAll(\"\\\\\\\\([\\\\\\\\\" + Character.toString(LIST_DELIMITER) + Character.toString(KEY_VALUE_DELIMITER) + \"])\", \"$1\");\n+                  if (key.equals(\"\\\\0\")) key = null;\n+                  if (value.equals(\"\\\\0\")) value = null;\n+\n+    //return updated item back to list\n+                  attributeValue.put(key, value);\n+                 }\n+\n+                 return attributeValue;\n+                } else {\n+                 throw new InternalErrorException(\"Unknown attribute type. (\" + attributeClass.toString() + \")\");\n+                }\n+ }\n+\n+ /**\n+  * Take perunBean name and if it is RichObject, convert it to simple name.\n+  *\n+  * RichObject mean: starts with \"Rich\" and continue with Upper Letter [A-Z]\n+  *\n+  * Ex.: RichGroup -> Group, RichUser -> User\n+  * Ex.: RichardObject -> RichardObject\n+  * Ex.: Null -> Null\n+  *\n+  * @param beanName bean Name of PerunBean (simple name of object)\n+  *\n+  * @return converted beanName (without Rich part)\n+  */\n+\n+ public static String convertRichBeanNameToBeanName(String beanName) {\n+  if (beanName == null || beanName.isEmpty())\n+   return beanName;\n+  Matcher richBeanNameMatcher = richBeanNamePattern.matcher(beanName);\n+  if (richBeanNameMatcher.find()) {\n+   return richBeanNameMatcher.group(1);\n+  }\n+\n+  return beanName;\n+ }\n+\n+ /**\n+  * Create a string with set of IN clause. Every in clause has maximum 1000 ids.\n+  * Identifier means for what IN clause is calling (Like 'table.id')\n+  *\n+  * Reason for using is compatibility with oracle and other dbs.\n+  *\n+  * Example: \" ( in (10,15,...) or in (...) or ... ) \"\n+  *\n+  * @param beans list of perun beans\n+  * @return string with some sql IN clause\n+  */\n+\n+ public static String prepareInSQLClause(String identifier, List<? extends PerunBean> beans) {\n+  //get Ids\n+  List<Integer> beansIds = new ArrayList<>();\n+  for (PerunBean pb : beans) {\n+   beansIds.add(pb.getId());\n+  }\n+\n+  return BeansUtils.prepareInSQLClause(beansIds, identifier);\n+ }\n+\n+\n+ /**\n+  * Create a string with set of IN clause. Every in clause has maximum 1000 ids.\n+  * Identifier means for what IN clause is calling (Like 'table.id')\n+  *\n+  * Reason for using is compatibility with oracle and other dbs.\n+  *\n+  * Example: \" ( in (10,15,...) or in (...) or ... ) \"\n+  *\n+  * @param beansIds list of perun bean ids\n+  * @return string with some sql IN clause\n+  */\n+\n+ public static String prepareInSQLClause(List<Integer> beansIds, String identifier) {\n+  StringBuilder sb = new StringBuilder();\n+  //use or in sql clause\n+  boolean useOr = false;\n+  //first bracket\n+  sb.append(\" (\");\n+\n+  //for every maxSize of beans\n+  while (beansIds.size() > MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE) {\n+   if (useOr) sb.append(\" or \");\n+   else useOr = true;\n+   sb.append(\" \");\n+   sb.append(identifier);\n+   sb.append(\" in (\");\n+   List<Integer> partOfBeansIds = beansIds.subList(0, MAX_SIZE_OF_ITEMS_IN_SQL_IN_CLAUSE);\n+   sb.append(beanIdsToString(partOfBeansIds));\n+   sb.append(\") \");\n+   partOfBeansIds.clear();\n+  }\n+\n+  //for rest of beans less or equals to 1000\n+  if (useOr) sb.append(\" or \");\n+  sb.append(\" \");\n+  sb.append(identifier);\n+  sb.append(\" in (\");\n+  sb.append(beanIdsToString(beansIds));\n+  sb.append(\") \");\n+\n+  //last bracket\n+  sb.append(\") \");\n+  return sb.toString();\n+ }\n+\n+ /**\n+  * Convert list of beans ids to one string with ',' between ids\n+  *\n+  * @param beans List of ids to construct string with\n+  * @return string representation of list of ids\n+  */\n+\n+ public static String beanIdsToString(List<Integer> beansIds) {\n+  StringBuilder stringBuilder = new StringBuilder();\n+  for (Integer beanId : beansIds) {\n+   stringBuilder.append(\",\");\n+   stringBuilder.append(beanId);\n+  }\n+  stringBuilder.deleteCharAt(0);\n+  return stringBuilder.toString();\n+ }\n+\n+ /**\n+  * Gets particular property from perun.properties file.\n+  *\n+  * @param propertyName name of the property\n+  * @return value of the property\n+  */\n+\n+ public static String getPropertyFromConfiguration(String propertyName) throws InternalErrorException {\n+  log.trace(\"Entering getPropertyFromConfiguration: propertyName='\" + propertyName + \"'\");\n+  notNull(propertyName, \"propertyName\");\n+  if (BeansUtils.properties == null) {\n+   // Load properties file with configuration\n+   Properties properties = new Properties();\n+   try {\n+    // Get the path to the perun.properties file\n+    BufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + \"perun.properties\"));\n+    properties.load(is);\n+    is.close();\n+   } catch (FileNotFoundException e) {\n+    throw new InternalErrorException(\"Cannot find perun.properties file\", e);\n+   } catch (IOException e) {\n+    throw new InternalErrorException(\"Cannot read perun.properties file\", e);\n+   }\n+   BeansUtils.properties = properties;\n+  }\n+  String property = BeansUtils.properties.getProperty(propertyName);\n+  if (property == null) {\n+   throw new InternalErrorException(\"Property \" + propertyName + \" cannot be found in the configuration file\");\n+  }\n+\n+  return property;\n+ }\n+\n+ /**\n+  * Gets particular property from custom property file.\n+  *\n+  * @param propertyFile name of properties file\n+  * @param propertyName name of the property\n+  * @return value of the property\n+  */\n+\n+ public static String getPropertyFromCustomConfiguration(String propertyFile, String propertyName) throws InternalErrorException {\n+  log.trace(\"Entering getPropertyFromCustomConfiguration: propertyFile='\" + propertyFile + \"' propertyName='\" + propertyName + \"'\");\n+  notNull(propertyName, \"propertyName\");\n+  notNull(propertyFile, \"propertyFile\");\n+\n+  // Load properties file with configuration\n+  Properties properties = new Properties();\n+  try {\n+   // Get the path to the perun.properties file\n+   BufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + propertyFile));\n+   properties.load(is);\n+   is.close();\n+   String property = properties.getProperty(propertyName);\n+   if (property == null) {\n+    throw new InternalErrorException(\"Property \" + propertyName + \" cannot be found in the configuration file: \" + propertyFile);\n+   }\n+\n+   return property;\n+  } catch (FileNotFoundException e) {\n+   throw new InternalErrorException(\"Cannot find \" + propertyFile + \" file\", e);\n+  } catch (IOException e) {\n+   throw new InternalErrorException(\"Cannot read \" + propertyFile + \" file\", e);\n+  }\n+ }\n+\n+ /**\n+  * Gets all properties from custom property file.\n+  *\n+  * @param propertyFile name of properties file\n+  * @return all properties with values\n+  */\n+\n+ public static Map<String, String> getAllPropertiesFromCustomConfiguration(String propertyFile) throws InternalErrorException {\n+  log.trace(\"Entering getAllPropertiesFromCustomConfiguration: propertyFile='\" + propertyFile + \"'\");\n+  notNull(propertyFile, \"propertyFile\");\n+\n+  // Load properties file with configuration\n+  Properties properties = new Properties();\n+  try {\n+\n+   // Get the path to the perun.properties file\n+   BufferedInputStream is = new BufferedInputStream(new FileInputStream(BeansUtils.configurationsLocations + propertyFile));\n+   properties.load(is);\n+   is.close();\n+   Map<String, String> myMap = new HashMap<String, String>();\n+   for (Object key : properties.keySet()) {\n+    myMap.put(key.toString(), properties.get(key).toString());\n+   }\n+\n+   return myMap;\n+  } catch (FileNotFoundException e) {\n+   throw new InternalErrorException(\"Cannot find \" + propertyFile + \" file\", e);\n+  } catch (IOException e) {\n+   throw new InternalErrorException(\"Cannot read \" + propertyFile + \" file\", e);\n+  }\n+ }\n+\n+ /**\n+  * True if this instance of perun is read only.\n+  * False if not.\n+  *\n+  * @return true or false (readOnly or not)\n+  */\n+\n+ public static boolean isPerunReadOnly() {\n+  //Set only if variable isPerunReadOnly is not set already\n+  if (isPerunReadOnly == null) {\n+   String readOnly;\n+   try {\n+    readOnly = BeansUtils.getPropertyFromConfiguration(\"perun.readOnlyPerun\");\n+   } catch (Exception ex) {\n+    //If something wierd happens, set this to normal configuration (not readOnly) and log this exception\n+    log.error(\"Problem occures when trying to get readOnly configuration from perun properties file.\", ex);\n+    log.debug(\"Read only configuration not found, set to false.\");\n+    isPerunReadOnly = false;\n+    return isPerunReadOnly;\n+   }\n+   if (readOnly == null) {\n+    log.debug(\"Read only configuration is null, set to false.\");\n+    isPerunReadOnly = false;\n+    return isPerunReadOnly;\n+   }\n+   if (readOnly.contains(\"true\")) {\n+    log.debug(\"Read only configuration found='{}', set to true.\", readOnly);\n+    isPerunReadOnly = true;\n+    return isPerunReadOnly;\n+   }\n+   log.debug(\"Read only configuration found='{}', set to false.\", readOnly);\n+   isPerunReadOnly = false;\n+   return isPerunReadOnly;\n+  } else {\n+   return isPerunReadOnly;\n+  }\n+ }\n+\n+ /**\n+  * True if DB initializator is enabled, false if not\n+  * Default is false\n+  *\n+  * @return true if enabled, false if disabled\n+  */\n+\n+ public static boolean initializatorEnabled() {\n+  String initializatorEnabled;\n+  try {\n+   initializatorEnabled = BeansUtils.getPropertyFromConfiguration(\"perun.DBInitializatorEnabled\");\n+  } catch (Exception ex) {\n+   //If something wierd happens, set this to normal configuration (not readOnly) and log this exception\n+   log.error(\"Problem occures when trying to get DBInitializatorEnabled configuration from perun properties file.\",\n+   ex);\n+   log.debug(\"DBInitializatorEnabled configuration not found, set to false.\");\n+   return false;\n+  }\n+  if (initializatorEnabled == null) {\n+   log.debug(\"DBInitializatorEnabled configuration is null, set to false.\");\n+   return false;\n+  }\n+  if (initializatorEnabled.contains(\"true\")) {\n+   log.debug(\"DBInitializatorEnabled configuration found='{}', set to true.\", initializatorEnabled);\n+   return true;\n+  }\n+  log.debug(\"Read only configuration found='{}', set to false.\", initializatorEnabled);\n+  return false;\n+ }\n+ \n+ /**\n+  * Checks whether the object is null or not.\n+  *\n+  * @param e\n+  * @param name\n+  * @throws InternalErrorException which wraps NullPointerException\n+  */\n+\n+ public static void notNull(Object e, String name) throws InternalErrorException {\n+  if (e == null) {\n+   throw new InternalErrorException(new NullPointerException(\"'\" + name + \"' is null\"));\n+  }\n+ }\n+\n+ /**\n+  * Set already filled-in properties (used by Spring container to inject properties bean)\n+  *\n+  * @param properties\n+  * @return\n+  */\n+\n+ public static Properties setProperties(Properties properties) {\n+  BeansUtils.properties = properties;\n+  return BeansUtils.properties;\n+ }\n+\n+ public static String getIDsOfPerunBeans(List<? extends PerunBean> listOfBeans) {\n+  if (listOfBeans == null || listOfBeans.isEmpty()) {\n+   return \"\";\n+  }\n+  Boolean isFirstIteration = true;\n+  StringBuilder str = new StringBuilder();\n+  for (PerunBean perunBean : listOfBeans) {\n+   if (isFirstIteration) {\n+    str.append(perunBean.getId());\n+    isFirstIteration = false;\n+   } else {\n+    str.append(\",\").append(perunBean.getId());\n+   }\n+  }\n+\n+  return str.toString();\n+ }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 729
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/477/BeansUtils.java\nindex ece5548a061..414fb3dac3d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/477/BeansUtils.java\n@@ -689,7 +689,7 @@ public class BeansUtils {\n \t\tlog.debug(\"Read only configuration found='{}', set to false.\", initializatorEnabled);\n \t\treturn false;\n \t}\n-\t\n+\n \t/**\n \t * Checks whether the object is null or not.\n \t *\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/477/BeansUtils.java\nindex ece5548a061..0258d172203 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/477/BeansUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/477/BeansUtils.java\n@@ -688,8 +688,9 @@ public class BeansUtils {\n \n \t\tlog.debug(\"Read only configuration found='{}', set to false.\", initializatorEnabled);\n \t\treturn false;\n-\t}\n-\t\n+\n+\t\t}\n+\n \t/**\n \t * Checks whether the object is null or not.\n \t *\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}