{
    "project_name": "DaGeRe-peass",
    "error_id": "47",
    "information": {
        "errors": [
            {
                "line": "112",
                "column": "95",
                "severity": "error",
                "message": "'+' should be on a new line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
            }
        ]
    },
    "source_code": "      double relativeDeviationPredecessor = statisticsPredecessor.getStandardDeviation() / statisticsPredecessor.getMean();\n      double relativeDeviationVersion = statisticsVersion.getStandardDeviation() / statisticsVersion.getMean();\n      double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) +\n            Math.pow(relativeDeviationVersion, 2)) / 2);\n      return relativeDifference > causeSearchConfig.getMinTime() * relativeStandardDeviation;\n   }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/47/DifferentNodeDeterminer.java\nindex 7d9b936e493..439796b7d53 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/47/DifferentNodeDeterminer.java\n@@ -109,8 +109,7 @@ public abstract class DifferentNodeDeterminer {\n       double relativeDifference = Math.abs(statisticsPredecessor.getMean() - statisticsVersion.getMean()) / statisticsVersion.getMean();\n       double relativeDeviationPredecessor = statisticsPredecessor.getStandardDeviation() / statisticsPredecessor.getMean();\n       double relativeDeviationVersion = statisticsVersion.getStandardDeviation() / statisticsVersion.getMean();\n-      double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) +\n-            Math.pow(relativeDeviationVersion, 2)) / 2);\n+      double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) + Math.pow(relativeDeviationVersion, 2)) / 2);\n       return relativeDifference > causeSearchConfig.getMinTime() * relativeStandardDeviation;\n    }\n \n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "42",
                    "column": "43",
                    "severity": "error",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "112",
                    "column": "93",
                    "severity": "error",
                    "message": "'+' should be on a new line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.OperatorWrapCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/47/DifferentNodeDeterminer.java\nindex 7d9b936e493..1052147ea8f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/47/DifferentNodeDeterminer.java\n@@ -19,120 +19,120 @@ import de.precision.analysis.repetitions.bimodal.OutlierRemoverBimodal;\n \n public abstract class DifferentNodeDeterminer {\n \n-   private static final Logger LOG = LogManager.getLogger(DifferentNodeDeterminer.class);\n-\n-   protected List<CallTreeNode> measurePredecessor = new LinkedList<>();\n-\n-   protected final List<CallTreeNode> measureNextlevelPredecessor = new LinkedList<>();\n-   protected final List<CallTreeNode> measureNextLevel = new LinkedList<>();\n-\n-   protected final List<CallTreeNode> currentLevelDifferent = new LinkedList<>();\n-\n-   protected final CauseSearcherConfig causeSearchConfig;\n-   protected final MeasurementConfiguration measurementConfig;\n-\n-   public DifferentNodeDeterminer(final CauseSearcherConfig causeSearchConfig, final MeasurementConfiguration measurementConfig) {\n-      this.causeSearchConfig = causeSearchConfig;\n-      this.measurementConfig = measurementConfig;\n-   }\n-\n-   public void calculateDiffering() {\n-      final Iterator<CallTreeNode> predecessorIterator = measurePredecessor.iterator();\n-      // final Iterator<CallTreeNode> currentIterator = needToMeasureCurrent.iterator();\n-      for (; predecessorIterator.hasNext();) {\n-         final CallTreeNode currentPredecessorNode = predecessorIterator.next();\n-         // final CallTreeNode currentVersionNode = currentIterator.next();\n-         CompareData cd = currentPredecessorNode.getComparableStatistics(measurementConfig.getVersionOld(), measurementConfig.getVersion());\n-         calculateNodeDifference(currentPredecessorNode, cd);\n-      }\n-   }\n-\n-   private void calculateNodeDifference(final CallTreeNode currentPredecessorNode, final CompareData cd) {\n-      if (cd.getBeforeStat() == null || cd.getAfterStat() == null) {\n-         LOG.debug(\"Statistics is null, is different: {} vs {}\", cd.getBeforeStat(), cd.getAfterStat());\n-         currentLevelDifferent.add(currentPredecessorNode);\n-      } else {\n-         final CompareData cleaned = removeOutliers(cd);\n-         printComparisonInfos(currentPredecessorNode, cleaned.getBeforeStat(), cleaned.getAfterStat());\n-         checkNodeDiffering(currentPredecessorNode, cleaned);\n-      }\n-   }\n-\n-   private CompareData removeOutliers(final CompareData cd) {\n-      final CompareData cleaned;\n-      if (measurementConfig.getStatisticsConfig().getOutlierFactor() != 0) {\n-         cleaned = OutlierRemoverBimodal.removeOutliers(cd);\n+  private static final Logger LOG = LogManager.getLogger(DifferentNodeDeterminer.class);\n+\n+  protected List<CallTreeNode> measurePredecessor = new LinkedList<>();\n+\n+  protected final List<CallTreeNode> measureNextlevelPredecessor = new LinkedList<>();\n+  protected final List<CallTreeNode> measureNextLevel = new LinkedList<>();\n+\n+  protected final List<CallTreeNode> currentLevelDifferent = new LinkedList<>();\n+\n+  protected final CauseSearcherConfig causeSearchConfig;\n+  protected final MeasurementConfiguration measurementConfig;\n+\n+  public DifferentNodeDeterminer(final CauseSearcherConfig causeSearchConfig, final MeasurementConfiguration measurementConfig) {\n+    this.causeSearchConfig = causeSearchConfig;\n+    this.measurementConfig = measurementConfig;\n+  }\n+\n+  public void calculateDiffering() {\n+    final Iterator<CallTreeNode> predecessorIterator = measurePredecessor.iterator();\n+    // final Iterator<CallTreeNode> currentIterator = needToMeasureCurrent.iterator();\n+    for (; predecessorIterator.hasNext(); ) {\n+      final CallTreeNode currentPredecessorNode = predecessorIterator.next();\n+      // final CallTreeNode currentVersionNode = currentIterator.next();\n+      CompareData cd = currentPredecessorNode.getComparableStatistics(measurementConfig.getVersionOld(), measurementConfig.getVersion());\n+      calculateNodeDifference(currentPredecessorNode, cd);\n+    }\n+  }\n+\n+  private void calculateNodeDifference(final CallTreeNode currentPredecessorNode, final CompareData cd) {\n+    if (cd.getBeforeStat() == null || cd.getAfterStat() == null) {\n+      LOG.debug(\"Statistics is null, is different: {} vs {}\", cd.getBeforeStat(), cd.getAfterStat());\n+      currentLevelDifferent.add(currentPredecessorNode);\n+    } else {\n+      final CompareData cleaned = removeOutliers(cd);\n+      printComparisonInfos(currentPredecessorNode, cleaned.getBeforeStat(), cleaned.getAfterStat());\n+      checkNodeDiffering(currentPredecessorNode, cleaned);\n+    }\n+  }\n+\n+  private CompareData removeOutliers(final CompareData cd) {\n+    final CompareData cleaned;\n+    if (measurementConfig.getStatisticsConfig().getOutlierFactor() != 0) {\n+      cleaned = OutlierRemoverBimodal.removeOutliers(cd);\n+    } else {\n+      cleaned = cd;\n+    }\n+    return cleaned;\n+  }\n+\n+  private void checkNodeDiffering(final CallTreeNode currentPredecessorNode, final CompareData cleaned) {\n+    if (cleaned.getBeforeStat().getN() > 0 && cleaned.getAfterStat().getN() > 0) {\n+      final Relation relation = StatisticUtil.isDifferent(cleaned, measurementConfig);\n+      LOG.debug(\"Relation: {}\", relation);\n+      if ((relation == Relation.UNEQUAL || relation == Relation.GREATER_THAN || relation == Relation.LESS_THAN)\n+          && needsEnoughTime(cleaned.getBeforeStat(), cleaned.getAfterStat())) {\n+        addChildsToMeasurement(currentPredecessorNode, cleaned.getBeforeStat(), cleaned.getAfterStat());\n       } else {\n-         cleaned = cd;\n-      }\n-      return cleaned;\n-   }\n-\n-   private void checkNodeDiffering(final CallTreeNode currentPredecessorNode, final CompareData cleaned) {\n-      if (cleaned.getBeforeStat().getN() > 0 && cleaned.getAfterStat().getN() > 0) {\n-         final Relation relation = StatisticUtil.isDifferent(cleaned, measurementConfig);\n-         LOG.debug(\"Relation: {}\", relation);\n-         if ((relation == Relation.UNEQUAL || relation == Relation.GREATER_THAN || relation == Relation.LESS_THAN)\n-               && needsEnoughTime(cleaned.getBeforeStat(), cleaned.getAfterStat())) {\n-            addChildsToMeasurement(currentPredecessorNode, cleaned.getBeforeStat(), cleaned.getAfterStat());\n-         } else {\n-            LOG.info(\"No remeasurement\");\n-         }\n-      }\n-   }\n-\n-   private void printComparisonInfos(final CallTreeNode currentPredecessorNode, final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n-      LOG.debug(\"Comparison {} - {}\",\n-            currentPredecessorNode.getKiekerPattern(),\n-            currentPredecessorNode.getOtherVersionNode() != null ? currentPredecessorNode.getOtherVersionNode().getKiekerPattern() : null);\n-      LOG.debug(\"Predecessor: {} {} Current: {} {} \",\n-            statisticsPredecessor.getMean(), statisticsPredecessor.getStandardDeviation(),\n-            statisticsVersion.getMean(), statisticsVersion.getStandardDeviation());\n-   }\n-\n-   private void addChildsToMeasurement(final CallTreeNode currentPredecessorNode, final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n-      measureNextlevelPredecessor.addAll(currentPredecessorNode.getChildren());\n-      final List<CallTreeNode> currentNodes = buildCurrentDiffering(currentPredecessorNode);\n-      measureNextLevel.addAll(currentNodes);\n-\n-      final int childsRemeasure = getRemeasureChilds(currentPredecessorNode);\n-\n-      if (childsRemeasure == 0) {\n-         LOG.debug(\"Adding {} - no childs needs to be remeasured, T={}\", currentPredecessorNode, childsRemeasure,\n-               TestUtils.homoscedasticT(statisticsPredecessor, statisticsVersion));\n-         LOG.debug(\"Childs: {}\", currentPredecessorNode.getChildren());\n-         currentLevelDifferent.add(currentPredecessorNode);\n+        LOG.info(\"No remeasurement\");\n       }\n-   }\n-\n-   private boolean needsEnoughTime(final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n-      double relativeDifference = Math.abs(statisticsPredecessor.getMean() - statisticsVersion.getMean()) / statisticsVersion.getMean();\n-      double relativeDeviationPredecessor = statisticsPredecessor.getStandardDeviation() / statisticsPredecessor.getMean();\n-      double relativeDeviationVersion = statisticsVersion.getStandardDeviation() / statisticsVersion.getMean();\n-      double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) +\n-            Math.pow(relativeDeviationVersion, 2)) / 2);\n-      return relativeDifference > causeSearchConfig.getMinTime() * relativeStandardDeviation;\n-   }\n-\n-   private List<CallTreeNode> buildCurrentDiffering(final CallTreeNode currentPredecessorNode) {\n-      final List<CallTreeNode> currentNodes = new LinkedList<>();\n-      currentPredecessorNode.getChildren().forEach(node -> currentNodes.add(node.getOtherVersionNode()));\n-      return currentNodes;\n-   }\n-\n-   private int getRemeasureChilds(final CallTreeNode predecessorNode) {\n-      int childsRemeasure = 0;\n-      LOG.debug(\"Children: {}\", predecessorNode.getChildren().size());\n-      for (final CallTreeNode testChild : predecessorNode.getChildren()) {\n-         LOG.debug(\"Child: {} Parent: {}\", testChild, measureNextlevelPredecessor);\n-         if (measureNextlevelPredecessor.contains(testChild)) {\n-            childsRemeasure++;\n-         }\n+    }\n+  }\n+\n+  private void printComparisonInfos(final CallTreeNode currentPredecessorNode, final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n+    LOG.debug(\"Comparison {} - {}\",\n+        currentPredecessorNode.getKiekerPattern(),\n+        currentPredecessorNode.getOtherVersionNode() != null ? currentPredecessorNode.getOtherVersionNode().getKiekerPattern() : null);\n+    LOG.debug(\"Predecessor: {} {} Current: {} {} \",\n+        statisticsPredecessor.getMean(), statisticsPredecessor.getStandardDeviation(),\n+        statisticsVersion.getMean(), statisticsVersion.getStandardDeviation());\n+  }\n+\n+  private void addChildsToMeasurement(final CallTreeNode currentPredecessorNode, final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n+    measureNextlevelPredecessor.addAll(currentPredecessorNode.getChildren());\n+    final List<CallTreeNode> currentNodes = buildCurrentDiffering(currentPredecessorNode);\n+    measureNextLevel.addAll(currentNodes);\n+\n+    final int childsRemeasure = getRemeasureChilds(currentPredecessorNode);\n+\n+    if (childsRemeasure == 0) {\n+      LOG.debug(\"Adding {} - no childs needs to be remeasured, T={}\", currentPredecessorNode, childsRemeasure,\n+          TestUtils.homoscedasticT(statisticsPredecessor, statisticsVersion));\n+      LOG.debug(\"Childs: {}\", currentPredecessorNode.getChildren());\n+      currentLevelDifferent.add(currentPredecessorNode);\n+    }\n+  }\n+\n+  private boolean needsEnoughTime(final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n+    double relativeDifference = Math.abs(statisticsPredecessor.getMean() - statisticsVersion.getMean()) / statisticsVersion.getMean();\n+    double relativeDeviationPredecessor = statisticsPredecessor.getStandardDeviation() / statisticsPredecessor.getMean();\n+    double relativeDeviationVersion = statisticsVersion.getStandardDeviation() / statisticsVersion.getMean();\n+    double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) +\n+        Math.pow(relativeDeviationVersion, 2)) / 2);\n+    return relativeDifference > causeSearchConfig.getMinTime() * relativeStandardDeviation;\n+  }\n+\n+  private List<CallTreeNode> buildCurrentDiffering(final CallTreeNode currentPredecessorNode) {\n+    final List<CallTreeNode> currentNodes = new LinkedList<>();\n+    currentPredecessorNode.getChildren().forEach(node -> currentNodes.add(node.getOtherVersionNode()));\n+    return currentNodes;\n+  }\n+\n+  private int getRemeasureChilds(final CallTreeNode predecessorNode) {\n+    int childsRemeasure = 0;\n+    LOG.debug(\"Children: {}\", predecessorNode.getChildren().size());\n+    for (final CallTreeNode testChild : predecessorNode.getChildren()) {\n+      LOG.debug(\"Child: {} Parent: {}\", testChild, measureNextlevelPredecessor);\n+      if (measureNextlevelPredecessor.contains(testChild)) {\n+        childsRemeasure++;\n       }\n-      return childsRemeasure;\n-   }\n+    }\n+    return childsRemeasure;\n+  }\n \n-   public List<CallTreeNode> getCurrentLevelDifferent() {\n-      return currentLevelDifferent;\n-   }\n+  public List<CallTreeNode> getCurrentLevelDifferent() {\n+    return currentLevelDifferent;\n+  }\n }\n\\ No newline at end of file\n",
            "diff_size": 150
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "79",
                    "severity": "error",
                    "message": "Line is longer than 200 characters (found 204).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/47/DifferentNodeDeterminer.java\nindex 7d9b936e493..634ea336fb8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/47/DifferentNodeDeterminer.java\n@@ -3,12 +3,10 @@ package de.peass.measurement.rca.treeanalysis;\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n-\n import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n import org.apache.commons.math3.stat.inference.TestUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-\n import de.peass.config.MeasurementConfiguration;\n import de.peass.measurement.analysis.Relation;\n import de.peass.measurement.analysis.StatisticUtil;\n@@ -17,122 +15,112 @@ import de.peass.measurement.rca.data.CallTreeNode;\n import de.precision.analysis.repetitions.bimodal.CompareData;\n import de.precision.analysis.repetitions.bimodal.OutlierRemoverBimodal;\n \n-public abstract class DifferentNodeDeterminer {\n-\n-   private static final Logger LOG = LogManager.getLogger(DifferentNodeDeterminer.class);\n-\n-   protected List<CallTreeNode> measurePredecessor = new LinkedList<>();\n-\n-   protected final List<CallTreeNode> measureNextlevelPredecessor = new LinkedList<>();\n-   protected final List<CallTreeNode> measureNextLevel = new LinkedList<>();\n-\n-   protected final List<CallTreeNode> currentLevelDifferent = new LinkedList<>();\n-\n-   protected final CauseSearcherConfig causeSearchConfig;\n-   protected final MeasurementConfiguration measurementConfig;\n \n-   public DifferentNodeDeterminer(final CauseSearcherConfig causeSearchConfig, final MeasurementConfiguration measurementConfig) {\n-      this.causeSearchConfig = causeSearchConfig;\n-      this.measurementConfig = measurementConfig;\n-   }\n-\n-   public void calculateDiffering() {\n-      final Iterator<CallTreeNode> predecessorIterator = measurePredecessor.iterator();\n+public abstract class DifferentNodeDeterminer {\n+ private static final Logger LOG = LogManager.getLogger(DifferentNodeDeterminer.class);\n+ protected List<CallTreeNode> measurePredecessor = new LinkedList<>();\n+ protected final List<CallTreeNode> measureNextlevelPredecessor = new LinkedList<>();\n+ protected final List<CallTreeNode> measureNextLevel = new LinkedList<>();\n+ protected final List<CallTreeNode> currentLevelDifferent = new LinkedList<>();\n+ protected final CauseSearcherConfig causeSearchConfig;\n+ protected final MeasurementConfiguration measurementConfig;\n+\n+ public DifferentNodeDeterminer(final CauseSearcherConfig causeSearchConfig, final MeasurementConfiguration measurementConfig) {\n+  this.causeSearchConfig = causeSearchConfig;\n+  this.measurementConfig = measurementConfig;\n+ }\n+\n+\n+ public void calculateDiffering() {\n+  final Iterator<CallTreeNode> predecessorIterator = measurePredecessor.iterator();\n       // final Iterator<CallTreeNode> currentIterator = needToMeasureCurrent.iterator();\n-      for (; predecessorIterator.hasNext();) {\n-         final CallTreeNode currentPredecessorNode = predecessorIterator.next();\n+  for (; predecessorIterator.hasNext();) {\n+   final CallTreeNode currentPredecessorNode = predecessorIterator.next();\n          // final CallTreeNode currentVersionNode = currentIterator.next();\n-         CompareData cd = currentPredecessorNode.getComparableStatistics(measurementConfig.getVersionOld(), measurementConfig.getVersion());\n-         calculateNodeDifference(currentPredecessorNode, cd);\n-      }\n+   CompareData cd = currentPredecessorNode.getComparableStatistics(measurementConfig.getVersionOld(), measurementConfig.getVersion());\n+   calculateNodeDifference(currentPredecessorNode, cd);\n+  }\n+ }\n+\n+ private void calculateNodeDifference(final CallTreeNode currentPredecessorNode, final CompareData cd) {\n+  if (cd.getBeforeStat() == null || cd.getAfterStat() == null) {\n+   LOG.debug(\"Statistics is null, is different: {} vs {}\", cd.getBeforeStat(), cd.getAfterStat());\n+   currentLevelDifferent.add(currentPredecessorNode);\n+  } else {\n+   final CompareData cleaned = removeOutliers(cd);\n+   printComparisonInfos(currentPredecessorNode, cleaned.getBeforeStat(), cleaned.getAfterStat());\n+   checkNodeDiffering(currentPredecessorNode, cleaned);\n+  }\n+ }\n+\n+ private CompareData removeOutliers(final CompareData cd) {\n+  final CompareData cleaned;\n+  if (measurementConfig.getStatisticsConfig().getOutlierFactor() != 0) {\n+   cleaned = OutlierRemoverBimodal.removeOutliers(cd);\n+  } else {\n+   cleaned = cd;\n+  }\n+  return cleaned;\n+ }\n+\n+ private void checkNodeDiffering(final CallTreeNode currentPredecessorNode, final CompareData cleaned) {\n+  if (cleaned.getBeforeStat().getN() > 0 && cleaned.getAfterStat().getN() > 0) {\n+   final Relation relation = StatisticUtil.isDifferent(cleaned, measurementConfig);\n+   LOG.debug(\"Relation: {}\", relation);\n+   if ((relation == Relation.UNEQUAL || relation == Relation.GREATER_THAN || relation == Relation.LESS_THAN) && needsEnoughTime(cleaned.getBeforeStat(), cleaned.getAfterStat())) {\n+    addChildsToMeasurement(currentPredecessorNode, cleaned.getBeforeStat(), cleaned.getAfterStat());\n+   } else {\n+    LOG.info(\"No remeasurement\");\n    }\n-\n-   private void calculateNodeDifference(final CallTreeNode currentPredecessorNode, final CompareData cd) {\n-      if (cd.getBeforeStat() == null || cd.getAfterStat() == null) {\n-         LOG.debug(\"Statistics is null, is different: {} vs {}\", cd.getBeforeStat(), cd.getAfterStat());\n-         currentLevelDifferent.add(currentPredecessorNode);\n-      } else {\n-         final CompareData cleaned = removeOutliers(cd);\n-         printComparisonInfos(currentPredecessorNode, cleaned.getBeforeStat(), cleaned.getAfterStat());\n-         checkNodeDiffering(currentPredecessorNode, cleaned);\n-      }\n+  }\n+ }\n+\n+ private void printComparisonInfos(final CallTreeNode currentPredecessorNode, final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n+  LOG.debug(\"Comparison {} - {}\", currentPredecessorNode.getKiekerPattern(), currentPredecessorNode.getOtherVersionNode() != null ? currentPredecessorNode.getOtherVersionNode().getKiekerPattern() : null);\n+  LOG.debug(\"Predecessor: {} {} Current: {} {} \", statisticsPredecessor.getMean(), statisticsPredecessor.getStandardDeviation(), statisticsVersion.getMean(), statisticsVersion.getStandardDeviation());\n+ }\n+\n+ private void addChildsToMeasurement(final CallTreeNode currentPredecessorNode, final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n+  measureNextlevelPredecessor.addAll(currentPredecessorNode.getChildren());\n+\n+  final List<CallTreeNode> currentNodes = buildCurrentDiffering(currentPredecessorNode);\n+  measureNextLevel.addAll(currentNodes);\n+\n+  final int childsRemeasure = getRemeasureChilds(currentPredecessorNode);\n+  if (childsRemeasure == 0) {\n+   LOG.debug(\"Adding {} - no childs needs to be remeasured, T={}\", currentPredecessorNode, childsRemeasure, TestUtils.homoscedasticT(statisticsPredecessor, statisticsVersion));\n+   LOG.debug(\"Childs: {}\", currentPredecessorNode.getChildren());\n+   currentLevelDifferent.add(currentPredecessorNode);\n+  }\n+ }\n+\n+ private boolean needsEnoughTime(final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n+  double relativeDifference = Math.abs(statisticsPredecessor.getMean() - statisticsVersion.getMean()) / statisticsVersion.getMean();\n+  double relativeDeviationPredecessor = statisticsPredecessor.getStandardDeviation() / statisticsPredecessor.getMean();\n+  double relativeDeviationVersion = statisticsVersion.getStandardDeviation() / statisticsVersion.getMean();\n+  double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) + Math.pow(relativeDeviationVersion, 2)) / 2);\n+  return relativeDifference > causeSearchConfig.getMinTime() * relativeStandardDeviation;\n+ }\n+\n+ private List<CallTreeNode> buildCurrentDiffering(final CallTreeNode currentPredecessorNode) {\n+  final List<CallTreeNode> currentNodes = new LinkedList<>();\n+  currentPredecessorNode.getChildren().forEach(node -> currentNodes.add(node.getOtherVersionNode()));\n+  return currentNodes;\n+ }\n+\n+ private int getRemeasureChilds(final CallTreeNode predecessorNode) {\n+  int childsRemeasure = 0;\n+  LOG.debug(\"Children: {}\", predecessorNode.getChildren().size());\n+  for (final CallTreeNode testChild : predecessorNode.getChildren()) {\n+   LOG.debug(\"Child: {} Parent: {}\", testChild, measureNextlevelPredecessor);\n+   if (measureNextlevelPredecessor.contains(testChild)) {\n+    childsRemeasure++;\n    }\n+  }\n+  return childsRemeasure;\n+ }\n \n-   private CompareData removeOutliers(final CompareData cd) {\n-      final CompareData cleaned;\n-      if (measurementConfig.getStatisticsConfig().getOutlierFactor() != 0) {\n-         cleaned = OutlierRemoverBimodal.removeOutliers(cd);\n-      } else {\n-         cleaned = cd;\n-      }\n-      return cleaned;\n-   }\n-\n-   private void checkNodeDiffering(final CallTreeNode currentPredecessorNode, final CompareData cleaned) {\n-      if (cleaned.getBeforeStat().getN() > 0 && cleaned.getAfterStat().getN() > 0) {\n-         final Relation relation = StatisticUtil.isDifferent(cleaned, measurementConfig);\n-         LOG.debug(\"Relation: {}\", relation);\n-         if ((relation == Relation.UNEQUAL || relation == Relation.GREATER_THAN || relation == Relation.LESS_THAN)\n-               && needsEnoughTime(cleaned.getBeforeStat(), cleaned.getAfterStat())) {\n-            addChildsToMeasurement(currentPredecessorNode, cleaned.getBeforeStat(), cleaned.getAfterStat());\n-         } else {\n-            LOG.info(\"No remeasurement\");\n-         }\n-      }\n-   }\n-\n-   private void printComparisonInfos(final CallTreeNode currentPredecessorNode, final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n-      LOG.debug(\"Comparison {} - {}\",\n-            currentPredecessorNode.getKiekerPattern(),\n-            currentPredecessorNode.getOtherVersionNode() != null ? currentPredecessorNode.getOtherVersionNode().getKiekerPattern() : null);\n-      LOG.debug(\"Predecessor: {} {} Current: {} {} \",\n-            statisticsPredecessor.getMean(), statisticsPredecessor.getStandardDeviation(),\n-            statisticsVersion.getMean(), statisticsVersion.getStandardDeviation());\n-   }\n-\n-   private void addChildsToMeasurement(final CallTreeNode currentPredecessorNode, final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n-      measureNextlevelPredecessor.addAll(currentPredecessorNode.getChildren());\n-      final List<CallTreeNode> currentNodes = buildCurrentDiffering(currentPredecessorNode);\n-      measureNextLevel.addAll(currentNodes);\n-\n-      final int childsRemeasure = getRemeasureChilds(currentPredecessorNode);\n-\n-      if (childsRemeasure == 0) {\n-         LOG.debug(\"Adding {} - no childs needs to be remeasured, T={}\", currentPredecessorNode, childsRemeasure,\n-               TestUtils.homoscedasticT(statisticsPredecessor, statisticsVersion));\n-         LOG.debug(\"Childs: {}\", currentPredecessorNode.getChildren());\n-         currentLevelDifferent.add(currentPredecessorNode);\n-      }\n-   }\n-\n-   private boolean needsEnoughTime(final SummaryStatistics statisticsPredecessor, final SummaryStatistics statisticsVersion) {\n-      double relativeDifference = Math.abs(statisticsPredecessor.getMean() - statisticsVersion.getMean()) / statisticsVersion.getMean();\n-      double relativeDeviationPredecessor = statisticsPredecessor.getStandardDeviation() / statisticsPredecessor.getMean();\n-      double relativeDeviationVersion = statisticsVersion.getStandardDeviation() / statisticsVersion.getMean();\n-      double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) +\n-            Math.pow(relativeDeviationVersion, 2)) / 2);\n-      return relativeDifference > causeSearchConfig.getMinTime() * relativeStandardDeviation;\n-   }\n-\n-   private List<CallTreeNode> buildCurrentDiffering(final CallTreeNode currentPredecessorNode) {\n-      final List<CallTreeNode> currentNodes = new LinkedList<>();\n-      currentPredecessorNode.getChildren().forEach(node -> currentNodes.add(node.getOtherVersionNode()));\n-      return currentNodes;\n-   }\n-\n-   private int getRemeasureChilds(final CallTreeNode predecessorNode) {\n-      int childsRemeasure = 0;\n-      LOG.debug(\"Children: {}\", predecessorNode.getChildren().size());\n-      for (final CallTreeNode testChild : predecessorNode.getChildren()) {\n-         LOG.debug(\"Child: {} Parent: {}\", testChild, measureNextlevelPredecessor);\n-         if (measureNextlevelPredecessor.contains(testChild)) {\n-            childsRemeasure++;\n-         }\n-      }\n-      return childsRemeasure;\n-   }\n-\n-   public List<CallTreeNode> getCurrentLevelDifferent() {\n-      return currentLevelDifferent;\n-   }\n+ public List<CallTreeNode> getCurrentLevelDifferent() {\n+  return currentLevelDifferent;\n+ }\n }\n\\ No newline at end of file\n",
            "diff_size": 191
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/47/DifferentNodeDeterminer.java\nindex 7d9b936e493..439796b7d53 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/47/DifferentNodeDeterminer.java\n@@ -109,8 +109,7 @@ public abstract class DifferentNodeDeterminer {\n       double relativeDifference = Math.abs(statisticsPredecessor.getMean() - statisticsVersion.getMean()) / statisticsVersion.getMean();\n       double relativeDeviationPredecessor = statisticsPredecessor.getStandardDeviation() / statisticsPredecessor.getMean();\n       double relativeDeviationVersion = statisticsVersion.getStandardDeviation() / statisticsVersion.getMean();\n-      double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) +\n-            Math.pow(relativeDeviationVersion, 2)) / 2);\n+      double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) + Math.pow(relativeDeviationVersion, 2)) / 2);\n       return relativeDifference > causeSearchConfig.getMinTime() * relativeStandardDeviation;\n    }\n \n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_three_grams/47/DifferentNodeDeterminer.java\nindex 7d9b936e493..439796b7d53 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/47/DifferentNodeDeterminer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_three_grams/47/DifferentNodeDeterminer.java\n@@ -109,8 +109,7 @@ public abstract class DifferentNodeDeterminer {\n       double relativeDifference = Math.abs(statisticsPredecessor.getMean() - statisticsVersion.getMean()) / statisticsVersion.getMean();\n       double relativeDeviationPredecessor = statisticsPredecessor.getStandardDeviation() / statisticsPredecessor.getMean();\n       double relativeDeviationVersion = statisticsVersion.getStandardDeviation() / statisticsVersion.getMean();\n-      double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) +\n-            Math.pow(relativeDeviationVersion, 2)) / 2);\n+      double relativeStandardDeviation = Math.sqrt((Math.pow(relativeDeviationPredecessor, 2) + Math.pow(relativeDeviationVersion, 2)) / 2);\n       return relativeDifference > causeSearchConfig.getMinTime() * relativeStandardDeviation;\n    }\n \n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff"
    ]
}