{
    "project_name": "zanata-zanata-platform",
    "error_id": "67",
    "information": {
        "errors": [
            {
                "line": "656",
                "column": "38",
                "severity": "error",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "\n    public void validateSuppliedId() {\n        HProject ip = getInstance(); // this will raise an EntityNotFound\n        // exception\n        // when id is invalid and conversation will not\n        // start",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/67/ProjectHome.java\nindex 9bb27e6eacb..59ecb54913e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/67/ProjectHome.java\n@@ -653,8 +653,9 @@ public class ProjectHome extends SlugHome<HProject>\n     }\n \n     public void validateSuppliedId() {\n-        HProject ip = getInstance(); // this will raise an EntityNotFound\n-        // exception\n+        HProject ip = getInstance();\n+        // this will raise an EntityNotFound\n+         // exception\n         // when id is invalid and conversation will not\n         // start\n         if (ip.getStatus().equals(EntityStatus.OBSOLETE)) {\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "651",
                    "column": "34",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/67/ProjectHome.java\nindex 9bb27e6eacb..f2dda580b76 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/67/ProjectHome.java\n@@ -18,6 +18,7 @@\n  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA, or see the FSF\n  * site: http://www.fsf.org.\n  */\n+\n package org.zanata.action;\n \n import static com.google.common.base.Strings.isNullOrEmpty;\n@@ -95,1248 +96,1243 @@ import static org.zanata.model.ProjectRole.Maintainer;\n @Model\n @Transactional\n public class ProjectHome extends SlugHome<HProject>\n-        implements HasLanguageSettings {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(ProjectHome.class);\n-    private static final long serialVersionUID = 1L;\n-\n-    // /**\n-    // * This field is set from http parameter which will be the original slug\n-    // */\n-    // @Getter\n-    // private String slug;\n-    @Inject\n-    @Any\n-    private ProjectSlug projectSlug;\n-\n-    /**\n-     * This field is set from form input which can differ from original slug\n-     */\n-    @Nullable\n-    private String inputSlugValue;\n-    private Long projectId;\n-    @Inject\n-    private ZanataIdentity identity;\n-    @Inject\n-    private CurrentUser currentUser;\n-    @Inject\n-    private LocaleService localeServiceImpl;\n-    @Inject\n-    private LocaleDAO localeDAO;\n-    @Inject\n-    private SlugEntityService slugEntityServiceImpl;\n-    @Inject\n-    @SuppressFBWarnings(value = \"SE_BAD_FIELD\", justification = \"CDI proxies are Serializable\")\n-    private CommonMarkRenderer renderer;\n-    @SuppressFBWarnings(value = \"SE_BAD_FIELD\", justification = \"CDI proxies are Serializable\")\n-    @Inject\n-    private EntityManager entityManager;\n-    @Inject\n-    private FacesMessages facesMessages;\n-    @Inject\n-    private Messages msgs;\n-    @Inject\n-    private PersonDAO personDAO;\n-    @Inject\n-    private AccountRoleDAO accountRoleDAO;\n-    @Inject\n-    private WebHookDAO webHookDAO;\n-    @Inject\n-    private ValidationService validationServiceImpl;\n-    @Inject\n-    private CopyTransOptionsModel copyTransOptionsModel;\n-    @Inject\n-    private WebhookServiceImpl webhookServiceImpl;\n-    @Inject\n-    private ProjectService projectServiceImpl;\n-    @Inject\n-    private UrlUtil urlUtil;\n-    // This property is present to keep the filter in place when the region with\n-    // the filter box is refreshed.\n-    private String enabledLocalesFilter = \"\";\n-    private String disabledLocalesFilter;\n-\n-    /**\n-     * A separate map is used, rather than binding the alias map from the\n-     * project directly. This is done so that empty values are not added to the\n-     * map in every form submission, and so that a value entered in the field\n-     * for a row is not automatically updated when a different row is submitted.\n-     */\n-    private Map<LocaleId, String> enteredLocaleAliases = Maps.newHashMap();\n-    private Map<LocaleId, Boolean> selectedEnabledLocales = Maps.newHashMap();\n-    // Not sure if this is necessary, seems to work ok on selected disabled\n-    // locales without this.\n-\n-    public Map<LocaleId, Boolean> getSelectedEnabledLocales() {\n-        if (selectedEnabledLocales == null) {\n-            selectedEnabledLocales = Maps.newHashMap();\n-            for (HLocale locale : getEnabledLocales()) {\n-                selectedEnabledLocales.put(locale.getLocaleId(), Boolean.FALSE);\n-            }\n-        }\n-        return selectedEnabledLocales;\n-    }\n-\n-    private Map<LocaleId, Boolean> selectedDisabledLocales = Maps.newHashMap();\n-    private Boolean selectedCheckbox = Boolean.TRUE;\n-    private List<HLocale> disabledLocales;\n-\n-    public ProjectHome() {\n-        setEntityClass(HProject.class);\n-    }\n-\n-    public String getSlug() {\n-        return projectSlug.getValue();\n-    }\n-\n-    public List<HLocale> getDisabledLocales() {\n-        if (disabledLocales == null) {\n-            disabledLocales = findActiveNotEnabledLocales();\n-        }\n-        return disabledLocales;\n-    }\n-\n-    /**\n-     * Populate the list of available locales after filtering out the locales\n-     * already in the project.\n-     */\n-    private List<HLocale> findActiveNotEnabledLocales() {\n-        List<HLocale> activeLocales = localeDAO.findAllActive();\n-        // only include those not already in the project\n-        List<HLocale> filteredList = activeLocales.stream()\n-                .filter(hLocale -> !getEnabledLocales().contains(hLocale))\n-                .collect(\n-                        Collectors.toList());\n-        Collections.sort(filteredList, ComparatorUtil.LOCALE_COMPARATOR);\n-        return filteredList;\n-    }\n-\n-    private Map<String, Boolean> roleRestrictions;\n-    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n-    private Map<ValidationId, ValidationAction> availableValidations =\n-            Maps.newHashMap();\n-    private final java.util.concurrent.atomic.AtomicReference<List<HProjectIteration>>\n-            versions = new java.util.concurrent.atomic.AtomicReference<>();\n-    private String selectedProjectType;\n-    @Inject\n-    private ProjectMaintainersAutocomplete maintainerAutocomplete;\n-    private AbstractListFilter<HPerson> maintainerFilter =\n-            new InMemoryListFilter<HPerson>() {\n-\n-                private static final long serialVersionUID =\n-                        8259700829800303578L;\n-\n-                @Override\n-                protected List<HPerson> fetchAll() {\n-                    return getInstanceMaintainers();\n-                }\n-\n-                @Override\n-                protected boolean include(HPerson elem, String filter) {\n-                    return StringUtils.containsIgnoreCase(elem.getName(),\n-                            filter);\n-                }\n-            };\n-\n-    public void createNew() {\n-        clearSlugs();\n-        HProject instance = getInstance();\n-        identity.checkPermission(instance, \"insert\");\n-        instance.setDefaultProjectType(ProjectType.File);\n-        selectedProjectType = ProjectType.File.name();\n-        enteredLocaleAliases.putAll(getLocaleAliases());\n-        // force get so it will create and populate the hashmap\n-        getSelectedEnabledLocales();\n-    }\n-\n-    @Transactional\n-    public void updateSelectedProjectType(ValueChangeEvent e) {\n-        selectedProjectType = (String) e.getNewValue();\n-        updateProjectType();\n-    }\n-\n-    @Transactional\n-    public void setSelectedProjectType(String selectedProjectType) {\n-        if (!StringUtils.isEmpty(selectedProjectType)\n-                && !selectedProjectType.equals(\"null\")) {\n-            ProjectType projectType = ProjectType.valueOf(selectedProjectType);\n-            getInstance().setDefaultProjectType(projectType);\n-        }\n-    }\n-\n-    public boolean isOverrideLocales() {\n-        return getInstance().isOverrideLocales();\n-    }\n-\n-    @Transactional\n-    public void setOverrideLocales(boolean overrideLocales) {\n-        getInstance().setOverrideLocales(overrideLocales);\n-    }\n-\n-    /**\n-     * Return the list of enabled locales for this project, which may be\n-     * inherited from global locales. If the project slug is empty, all the\n-     * enabled locales for the server are returned.\n-     */\n-    public List<HLocale> getEnabledLocales() {\n-        List<HLocale> locales;\n-        if (StringUtils.isNotEmpty(getSlug())) {\n-            locales =\n-                    localeServiceImpl.getSupportedLanguageByProject(getSlug());\n-        } else {\n-            locales = localeServiceImpl.getSupportedAndEnabledLocales();\n-        }\n-        Collections.sort(locales, ComparatorUtil.LOCALE_COMPARATOR);\n-        return locales;\n-    }\n-\n-    public Map<LocaleId, String> getLocaleAliases() {\n-        return getInstance().getLocaleAliases();\n-    }\n-\n-    private void setLocaleAliases(Map<LocaleId, String> localeAliases) {\n-        getInstance().setLocaleAliases(localeAliases);\n-    }\n-\n-    /**\n-     * Return the locale alias for the given locale in this project, if it\n-     * exists, otherwise null.\n-     */\n-    public String getLocaleAlias(HLocale locale) {\n-        return getLocaleAliases().get(locale.getLocaleId());\n-    }\n-\n-    /**\n-     * Return true if the given locale has an alias, otherwise false.\n-     */\n-    public boolean hasLocaleAlias(HLocale locale) {\n-        return getLocaleAliases().containsKey(locale.getLocaleId());\n-    }\n-\n-    /**\n-     * Set or remove a locale alias based on form input.\n-     *\n-     * Uses value from enteredLocaleAlias. If the value is null or empty, the\n-     * alias (if any) is removed for the given locale, otherwise the alias is\n-     * replaced with the value.\n-     */\n-    @Transactional\n-    public void updateToEnteredLocaleAlias(LocaleId localeId) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        String enteredAlias = enteredLocaleAliases.get(localeId);\n-        setLocaleAlias(localeId, enteredAlias);\n-    }\n-\n-    private void setLocaleAlias(LocaleId localeId, String alias) {\n-        boolean hadAlias = setLocaleAliasSilently(localeId, alias);\n-        if (isNullOrEmpty(alias)) {\n-            if (hadAlias) {\n-                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                        msgs.format(\"jsf.LocaleAlias.AliasRemoved\", localeId));\n-            } else {\n-                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                        .format(\"jsf.LocaleAlias.NoAliasToRemove\", localeId));\n-            }\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.LocaleAlias.AliasSet\", localeId, alias));\n-        }\n-    }\n-\n-    /**\n-     * Set or remove a locale alias without showing any message.\n-     *\n-     * @param localeId\n-     *            for which to set alias\n-     * @param alias\n-     *            new alias to use. Use empty string to remove alias.\n-     * @return true if there was already an alias, otherwise false.\n-     */\n-    private boolean setLocaleAliasSilently(LocaleId localeId, String alias) {\n-        HProject instance = getInstance();\n-        Map<LocaleId, String> aliases = instance.getLocaleAliases();\n-        boolean hadAlias = aliases.containsKey(localeId);\n-        if (isNullOrEmpty(alias)) {\n-            if (hadAlias) {\n-                // no need to ensure overriding locales, aliases are independent\n-                aliases.remove(localeId);\n-            }\n-        } else {\n-            final boolean sameAlias =\n-                    hadAlias && alias.equals(aliases.get(localeId));\n-            if (!sameAlias) {\n-                // no need to ensure overriding locales, aliases are independent\n-                aliases.put(localeId, alias);\n-            }\n-        }\n-        update();\n-        return hadAlias;\n-    }\n-\n-    /**\n-     * Remove a locale alias without showing any message.\n-     *\n-     * @param localeId\n-     *            that will have its locale alias removed.\n-     * @return true if the locale had an alias, otherwise false.\n-     */\n-    private boolean removeAliasSilently(LocaleId localeId) {\n-        return setLocaleAliasSilently(localeId, \"\");\n-    }\n-\n-    @Transactional\n-    public void removeSelectedLocaleAliases() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        List<LocaleId> removed = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n-                .entrySet()) {\n-            if (entry.getValue()) {\n-                boolean hadAlias = removeAliasSilently(entry.getKey());\n-                if (hadAlias) {\n-                    removed.add(entry.getKey());\n-                }\n-            }\n-        }\n-        showRemovedAliasesMessage(removed);\n-    }\n-\n-    @Transactional\n-    public void removeAllLocaleAliases() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        List<LocaleId> removed = new ArrayList<>();\n-        List<LocaleId> aliasedLocales =\n-                new ArrayList<>(getLocaleAliases().keySet());\n-        for (LocaleId aliasedLocale : aliasedLocales) {\n-            boolean hadAlias = removeAliasSilently(aliasedLocale);\n-            if (hadAlias) {\n-                removed.add(aliasedLocale);\n-            }\n-        }\n-        showRemovedAliasesMessage(removed);\n-    }\n-\n-    /**\n-     * Show an appropriate message for the removal of aliases from locales with\n-     * the given IDs.\n-     *\n-     * @param removed\n-     *            ids of locales that had aliases removed\n-     */\n-    private void showRemovedAliasesMessage(List<LocaleId> removed) {\n-        if (removed.isEmpty()) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.get(\"jsf.LocaleAlias.NoAliasesToRemove\"));\n-        } else if (removed.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                    .format(\"jsf.LocaleAlias.AliasRemoved\", removed.get(0)));\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.LocaleAlias.AliasesRemoved\",\n-                            StringUtils.join(removed, \", \")));\n-        }\n-    }\n-\n-    @Transactional\n-    public void disableLocale(HLocale locale) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        disableLocaleSilently(locale);\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n-                \"jsf.languageSettings.LanguageDisabled\", locale.getLocaleId()));\n-    }\n-\n-    @Transactional\n-    public void disableSelectedLocales() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        List<LocaleId> removedLocales = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n-                .entrySet()) {\n-            if (entry.getValue()) {\n-                boolean wasEnabled = disableLocaleSilently(entry.getKey());\n-                if (wasEnabled) {\n-                    removedLocales.add(entry.getKey());\n-                }\n-            }\n-        }\n-        selectedEnabledLocales.clear();\n-        if (removedLocales.isEmpty()) {\n-            // This should not be possible in the UI, but maybe if multiple\n-            // users are editing it.\n-        } else if (removedLocales.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguageDisabled\",\n-                            removedLocales.get(0)));\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguagesDisabled\",\n-                            StringUtils.join(removedLocales, \", \")));\n-        }\n-    }\n-\n-    private boolean disableLocaleSilently(LocaleId localeId) {\n-        HLocale locale = localeServiceImpl.getByLocaleId(localeId);\n-        return disableLocaleSilently(locale);\n-    }\n-\n-    /**\n-     * Disable a locale without printing any message.\n-     *\n-     * @param locale\n-     *            locale that should be disabled.\n-     * @return false if the locale was already disabled, true otherwise.\n-     */\n-    private boolean disableLocaleSilently(HLocale locale) {\n-        final Set<HLocale> customizedLocales =\n-                getInstance().getCustomizedLocales();\n-        ensureOverridingLocales();\n-        boolean localeWasEnabled = customizedLocales.remove(locale);\n-        getLocaleAliases().remove(locale.getLocaleId());\n-        refreshDisabledLocales();\n-        return localeWasEnabled;\n-    }\n-\n-    @Transactional\n-    public void enableLocale(HLocale locale) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        enableLocaleSilently(locale);\n-        LocaleId localeId = locale.getLocaleId();\n+  implements HasLanguageSettings {\n+  private static final org.slf4j.Logger log =\n+    org.slf4j.LoggerFactory.getLogger(ProjectHome.class);\n+  private static final long serialVersionUID = 1L;\n+\n+  // /**\n+  // * This field is set from http parameter which will be the original slug\n+  // */\n+  // @Getter\n+  // private String slug;\n+  @Inject\n+  @Any\n+  private ProjectSlug projectSlug;\n+\n+  /**\n+   * This field is set from form input which can differ from original slug\n+   */\n+  @Nullable\n+  private String inputSlugValue;\n+  private Long projectId;\n+  @Inject\n+  private ZanataIdentity identity;\n+  @Inject\n+  private CurrentUser currentUser;\n+  @Inject\n+  private LocaleService localeServiceImpl;\n+  @Inject\n+  private LocaleDAO localeDAO;\n+  @Inject\n+  private SlugEntityService slugEntityServiceImpl;\n+  @Inject\n+  @SuppressFBWarnings(value = \"SE_BAD_FIELD\", justification = \"CDI proxies are Serializable\")\n+  private CommonMarkRenderer renderer;\n+  @SuppressFBWarnings(value = \"SE_BAD_FIELD\", justification = \"CDI proxies are Serializable\")\n+  @Inject\n+  private EntityManager entityManager;\n+  @Inject\n+  private FacesMessages facesMessages;\n+  @Inject\n+  private Messages msgs;\n+  @Inject\n+  private PersonDAO personDAO;\n+  @Inject\n+  private AccountRoleDAO accountRoleDAO;\n+  @Inject\n+  private WebHookDAO webHookDAO;\n+  @Inject\n+  private ValidationService validationServiceImpl;\n+  @Inject\n+  private CopyTransOptionsModel copyTransOptionsModel;\n+  @Inject\n+  private WebhookServiceImpl webhookServiceImpl;\n+  @Inject\n+  private ProjectService projectServiceImpl;\n+  @Inject\n+  private UrlUtil urlUtil;\n+  // This property is present to keep the filter in place when the region with\n+  // the filter box is refreshed.\n+  private String enabledLocalesFilter = \"\";\n+  private String disabledLocalesFilter;\n+\n+  /**\n+   * A separate map is used, rather than binding the alias map from the\n+   * project directly. This is done so that empty values are not added to the\n+   * map in every form submission, and so that a value entered in the field\n+   * for a row is not automatically updated when a different row is submitted.\n+   */\n+  private Map<LocaleId, String> enteredLocaleAliases = Maps.newHashMap();\n+  private Map<LocaleId, Boolean> selectedEnabledLocales = Maps.newHashMap();\n+  // Not sure if this is necessary, seems to work ok on selected disabled\n+  // locales without this.\n+\n+  public Map<LocaleId, Boolean> getSelectedEnabledLocales() {\n+    if (selectedEnabledLocales == null) {\n+      selectedEnabledLocales = Maps.newHashMap();\n+      for (HLocale locale : getEnabledLocales()) {\n+        selectedEnabledLocales.put(locale.getLocaleId(), Boolean.FALSE);\n+      }\n+    }\n+    return selectedEnabledLocales;\n+  }\n+\n+  private Map<LocaleId, Boolean> selectedDisabledLocales = Maps.newHashMap();\n+  private Boolean selectedCheckbox = Boolean.TRUE;\n+  private List<HLocale> disabledLocales;\n+\n+  public ProjectHome() {\n+    setEntityClass(HProject.class);\n+  }\n+\n+  public String getSlug() {\n+    return projectSlug.getValue();\n+  }\n+\n+  public List<HLocale> getDisabledLocales() {\n+    if (disabledLocales == null) {\n+      disabledLocales = findActiveNotEnabledLocales();\n+    }\n+    return disabledLocales;\n+  }\n+\n+  /**\n+   * Populate the list of available locales after filtering out the locales\n+   * already in the project.\n+   */\n+  private List<HLocale> findActiveNotEnabledLocales() {\n+    List<HLocale> activeLocales = localeDAO.findAllActive();\n+    // only include those not already in the project\n+    List<HLocale> filteredList = activeLocales.stream()\n+      .filter(hLocale -> !getEnabledLocales().contains(hLocale))\n+      .collect(\n+        Collectors.toList());\n+    Collections.sort(filteredList, ComparatorUtil.LOCALE_COMPARATOR);\n+    return filteredList;\n+  }\n+\n+  private Map<String, Boolean> roleRestrictions;\n+  @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+  private Map<ValidationId, ValidationAction> availableValidations =\n+    Maps.newHashMap();\n+  private final java.util.concurrent.atomic.AtomicReference<List<HProjectIteration>>\n+    versions = new java.util.concurrent.atomic.AtomicReference<>();\n+  private String selectedProjectType;\n+  @Inject\n+  private ProjectMaintainersAutocomplete maintainerAutocomplete;\n+  private AbstractListFilter<HPerson> maintainerFilter =\n+    new InMemoryListFilter<HPerson>() {\n+\n+      private static final long serialVersionUID =\n+        8259700829800303578L;\n+\n+      @Override\n+      protected List<HPerson> fetchAll() {\n+        return getInstanceMaintainers();\n+      }\n+\n+      @Override\n+      protected boolean include(HPerson elem, String filter) {\n+        return StringUtils.containsIgnoreCase(elem.getName(),\n+          filter);\n+      }\n+    };\n+\n+  public void createNew() {\n+    clearSlugs();\n+    HProject instance = getInstance();\n+    identity.checkPermission(instance, \"insert\");\n+    instance.setDefaultProjectType(ProjectType.File);\n+    selectedProjectType = ProjectType.File.name();\n+    enteredLocaleAliases.putAll(getLocaleAliases());\n+    // force get so it will create and populate the hashmap\n+    getSelectedEnabledLocales();\n+  }\n+\n+  @Transactional\n+  public void updateSelectedProjectType(ValueChangeEvent e) {\n+    selectedProjectType = (String) e.getNewValue();\n+    updateProjectType();\n+  }\n+\n+  @Transactional\n+  public void setSelectedProjectType(String selectedProjectType) {\n+    if (!StringUtils.isEmpty(selectedProjectType)\n+      && !selectedProjectType.equals(\"null\")) {\n+      ProjectType projectType = ProjectType.valueOf(selectedProjectType);\n+      getInstance().setDefaultProjectType(projectType);\n+    }\n+  }\n+\n+  public boolean isOverrideLocales() {\n+    return getInstance().isOverrideLocales();\n+  }\n+\n+  @Transactional\n+  public void setOverrideLocales(boolean overrideLocales) {\n+    getInstance().setOverrideLocales(overrideLocales);\n+  }\n+\n+  /**\n+   * Return the list of enabled locales for this project, which may be\n+   * inherited from global locales. If the project slug is empty, all the\n+   * enabled locales for the server are returned.\n+   */\n+  public List<HLocale> getEnabledLocales() {\n+    List<HLocale> locales;\n+    if (StringUtils.isNotEmpty(getSlug())) {\n+      locales =\n+        localeServiceImpl.getSupportedLanguageByProject(getSlug());\n+    } else {\n+      locales = localeServiceImpl.getSupportedAndEnabledLocales();\n+    }\n+    Collections.sort(locales, ComparatorUtil.LOCALE_COMPARATOR);\n+    return locales;\n+  }\n+\n+  public Map<LocaleId, String> getLocaleAliases() {\n+    return getInstance().getLocaleAliases();\n+  }\n+\n+  private void setLocaleAliases(Map<LocaleId, String> localeAliases) {\n+    getInstance().setLocaleAliases(localeAliases);\n+  }\n+\n+  /**\n+   * Return the locale alias for the given locale in this project, if it\n+   * exists, otherwise null.\n+   */\n+  public String getLocaleAlias(HLocale locale) {\n+    return getLocaleAliases().get(locale.getLocaleId());\n+  }\n+\n+  /**\n+   * Return true if the given locale has an alias, otherwise false.\n+   */\n+  public boolean hasLocaleAlias(HLocale locale) {\n+    return getLocaleAliases().containsKey(locale.getLocaleId());\n+  }\n+\n+  /**\n+   * Set or remove a locale alias based on form input.\n+   * <p>\n+   * Uses value from enteredLocaleAlias. If the value is null or empty, the\n+   * alias (if any) is removed for the given locale, otherwise the alias is\n+   * replaced with the value.\n+   */\n+  @Transactional\n+  public void updateToEnteredLocaleAlias(LocaleId localeId) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    String enteredAlias = enteredLocaleAliases.get(localeId);\n+    setLocaleAlias(localeId, enteredAlias);\n+  }\n+\n+  private void setLocaleAlias(LocaleId localeId, String alias) {\n+    boolean hadAlias = setLocaleAliasSilently(localeId, alias);\n+    if (isNullOrEmpty(alias)) {\n+      if (hadAlias) {\n         facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.format(\"jsf.languageSettings.LanguageEnabled\", localeId));\n-    }\n-\n-    @Transactional\n-    public void enableSelectedLocales() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        List<LocaleId> addedLocales = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : selectedDisabledLocales\n-                .entrySet()) {\n-            if (entry.getValue()) {\n-                boolean wasDisabled = enableLocaleSilently(entry.getKey());\n-                if (wasDisabled) {\n-                    addedLocales.add(entry.getKey());\n-                }\n-            }\n-        }\n-        selectedDisabledLocales.clear();\n-        if (addedLocales.isEmpty()) {\n-            // This should not be possible in the UI, but maybe if multiple\n-            // users are editing it.\n-        } else if (addedLocales.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguageEnabled\",\n-                            addedLocales.get(0)));\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguagesEnabled\",\n-                            StringUtils.join(addedLocales, \", \")));\n-        }\n-    }\n-\n-    private boolean enableLocaleSilently(LocaleId localeId) {\n-        HLocale locale = localeServiceImpl.getByLocaleId(localeId);\n-        return enableLocaleSilently(locale);\n-    }\n-\n-    /**\n-     * Enable a given locale without printing any message.\n-     *\n-     * @param locale\n-     *            locale that should be enabled.\n-     * @return false if the locale was already enabled, true otherwise.\n-     */\n-    private boolean enableLocaleSilently(HLocale locale) {\n-        ensureOverridingLocales();\n-        final boolean localeWasDisabled =\n-                getInstance().getCustomizedLocales().add(locale);\n-        refreshDisabledLocales();\n-        return localeWasDisabled;\n-    }\n-\n-    @Transactional\n-    public void useDefaultLocales() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        setOverrideLocales(false);\n-        removeAliasesForDisabledLocales();\n-        refreshDisabledLocales();\n-        update();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.get(\"jsf.project.LanguageUpdateFromGlobal\"));\n-    }\n-\n-    private void removeAliasesForDisabledLocales() {\n-        Map<LocaleId, String> oldAliases = getLocaleAliases();\n-        Map<LocaleId, String> newAliases = Maps.newHashMap();\n-        for (HLocale enabledLocale : getEnabledLocales()) {\n-            LocaleId key = enabledLocale.getLocaleId();\n-            if (oldAliases.containsKey(key)) {\n-                newAliases.put(key, oldAliases.get(key));\n-            }\n-        }\n-        setLocaleAliases(newAliases);\n-    }\n-\n-    /**\n-     * Ensure that isOverrideLocales is true, and copy data if necessary.\n-     */\n-    private void ensureOverridingLocales() {\n-        if (!isOverrideLocales()) {\n-            startOverridingLocales();\n-        }\n-    }\n-\n-    /**\n-     * Copy locale data from project and set overrideLocales, in preparation for\n-     * making customizations to the locales.\n-     */\n-    private void startOverridingLocales() {\n-        // Copied before setOverrideLocales(true) so that the currently returned\n-        // values will be used as the basis for any customization.\n-        List<HLocale> enabledLocales = getEnabledLocales();\n-        setOverrideLocales(true);\n-        // Replace contents rather than entire collections to avoid confusion\n-        // with reference to the collections that are bound before this runs.\n-        getInstance().getCustomizedLocales().clear();\n-        getInstance().getCustomizedLocales().addAll(enabledLocales);\n-        enteredLocaleAliases.clear();\n-        refreshDisabledLocales();\n-    }\n-\n-    /**\n-     * Update disabled locales to be consistent with enabled locales.\n-     */\n-    private void refreshDisabledLocales() {\n-        // will be re-generated with correct values next time it is fetched.\n-        disabledLocales = null;\n-    }\n-\n-    @Transactional\n-    public void setRestrictedByRole(String key, boolean checked) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        getInstance().setRestrictedByRoles(checked);\n-        update();\n-    }\n-\n-    @Transactional\n-    public void setPrivateProject(boolean privateProject) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        getInstance().setPrivateProject(privateProject);\n-        update();\n-        String message = privateProject\n-                ? msgs.get(\"jsf.permission.private.Active\")\n-                : msgs.get(\"jsf.permission.private.Inactive\");\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, message);\n-    }\n-\n-    @Override\n-    protected HProject loadInstance() {\n-        Session session = (Session) getEntityManager().getDelegate();\n-        if (projectId == null) {\n-            HProject project = (HProject) session.byNaturalId(HProject.class)\n-                    .using(\"slug\", getSlug()).load();\n-            validateProjectState(project);\n-            projectId = project.getId();\n-            return project;\n-        } else {\n-            HProject project =\n-                    (HProject) session.byId(HProject.class).load(projectId);\n-            validateProjectState(project);\n-            return project;\n-        }\n-    }\n-\n-    private void validateProjectState(HProject project) {\n-        if (project == null || project.getStatus() == EntityStatus.OBSOLETE) {\n-            log.warn(\n-                    \"Project [id={}, slug={}], does not exist or is soft deleted: {}\",\n-                    projectId, getSlug(), project);\n-            throw new ProjectNotFoundException(getSlug());\n-        }\n-    }\n-\n-    public void validateSuppliedId() {\n-        HProject ip = getInstance(); // this will raise an EntityNotFound\n-        // exception\n-        // when id is invalid and conversation will not\n-        // start\n-        if (ip.getStatus().equals(EntityStatus.OBSOLETE)) {\n-            throw new EntityNotFoundException();\n-        }\n-    }\n-\n-    @Transactional\n-    public void updateCopyTrans(String action, String value) {\n-        copyTransOptionsModel\n-                .setInstance(getInstance().getDefaultCopyTransOpts());\n-        copyTransOptionsModel.update(action, value);\n-        copyTransOptionsModel.save();\n-        getInstance()\n-                .setDefaultCopyTransOpts(copyTransOptionsModel.getInstance());\n-        update();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.get(\"jsf.project.CopyTransOpts.updated\"));\n-    }\n-    // @Begin(join = true) /* TODO [CDI] commented out begin conversation.\n-    // Verify it still works properly */\n-\n-    public void initialize() {\n-        if (!identity.hasPermission(getInstance(), \"read\")) {\n-            throw new EntityNotFoundException();\n-        }\n-        validateSuppliedId();\n-        if (getInstance().getDefaultCopyTransOpts() != null) {\n-            copyTransOptionsModel\n-                    .setInstance(getInstance().getDefaultCopyTransOpts());\n-        }\n-    }\n-\n-    public void onProjectNameChange(ValueChangeEvent e) {\n-        if (!isValidName((String) e.getNewValue())) {\n-            String componentId = e.getComponent().getId();\n-            facesMessages.addToControl(componentId,\n-                    msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n-        }\n-    }\n-\n-    /**\n-     * Check the name by removing any whitespaces in the string and\n-     * make sure it contains at least an alphanumeric char\n-     */\n-    public boolean isValidName(String name) {\n-        String trimmedName = StringUtils.deleteWhitespace(name);\n-        for (char c : trimmedName.toCharArray()) {\n-            if (Character.isDigit(c) || Character.isLetter(c)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public void verifySlugAvailable(ValueChangeEvent e) {\n-        String slug = (String) e.getNewValue();\n-        validateSlug(slug, e.getComponent().getId());\n-    }\n-\n-    public boolean validateSlug(String slug, String componentId) {\n-        if (StringUtils.equals(getInstance().getSlug(), slug)) {\n-            return true;\n+          msgs.format(\"jsf.LocaleAlias.AliasRemoved\", localeId));\n+      } else {\n+        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n+          .format(\"jsf.LocaleAlias.NoAliasToRemove\", localeId));\n+      }\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.LocaleAlias.AliasSet\", localeId, alias));\n+    }\n+  }\n+\n+  /**\n+   * Set or remove a locale alias without showing any message.\n+   *\n+   * @param localeId for which to set alias\n+   * @param alias    new alias to use. Use empty string to remove alias.\n+   * @return true if there was already an alias, otherwise false.\n+   */\n+  private boolean setLocaleAliasSilently(LocaleId localeId, String alias) {\n+    HProject instance = getInstance();\n+    Map<LocaleId, String> aliases = instance.getLocaleAliases();\n+    boolean hadAlias = aliases.containsKey(localeId);\n+    if (isNullOrEmpty(alias)) {\n+      if (hadAlias) {\n+        // no need to ensure overriding locales, aliases are independent\n+        aliases.remove(localeId);\n+      }\n+    } else {\n+      final boolean sameAlias =\n+        hadAlias && alias.equals(aliases.get(localeId));\n+      if (!sameAlias) {\n+        // no need to ensure overriding locales, aliases are independent\n+        aliases.put(localeId, alias);\n+      }\n+    }\n+    update();\n+    return hadAlias;\n+  }\n+\n+  /**\n+   * Remove a locale alias without showing any message.\n+   *\n+   * @param localeId that will have its locale alias removed.\n+   * @return true if the locale had an alias, otherwise false.\n+   */\n+  private boolean removeAliasSilently(LocaleId localeId) {\n+    return setLocaleAliasSilently(localeId, \"\");\n+  }\n+\n+  @Transactional\n+  public void removeSelectedLocaleAliases() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    List<LocaleId> removed = new ArrayList<>();\n+    for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n+      .entrySet()) {\n+      if (entry.getValue()) {\n+        boolean hadAlias = removeAliasSilently(entry.getKey());\n+        if (hadAlias) {\n+          removed.add(entry.getKey());\n         }\n-        if (!isSlugAvailable(slug)) {\n-            facesMessages.addToControl(componentId,\n-                    \"This Project ID is not available\");\n-            return false;\n+      }\n+    }\n+    showRemovedAliasesMessage(removed);\n+  }\n+\n+  @Transactional\n+  public void removeAllLocaleAliases() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    List<LocaleId> removed = new ArrayList<>();\n+    List<LocaleId> aliasedLocales =\n+      new ArrayList<>(getLocaleAliases().keySet());\n+    for (LocaleId aliasedLocale : aliasedLocales) {\n+      boolean hadAlias = removeAliasSilently(aliasedLocale);\n+      if (hadAlias) {\n+        removed.add(aliasedLocale);\n+      }\n+    }\n+    showRemovedAliasesMessage(removed);\n+  }\n+\n+  /**\n+   * Show an appropriate message for the removal of aliases from locales with\n+   * the given IDs.\n+   *\n+   * @param removed ids of locales that had aliases removed\n+   */\n+  private void showRemovedAliasesMessage(List<LocaleId> removed) {\n+    if (removed.isEmpty()) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.get(\"jsf.LocaleAlias.NoAliasesToRemove\"));\n+    } else if (removed.size() == 1) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n+        .format(\"jsf.LocaleAlias.AliasRemoved\", removed.get(0)));\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.LocaleAlias.AliasesRemoved\",\n+          StringUtils.join(removed, \", \")));\n+    }\n+  }\n+\n+  @Transactional\n+  public void disableLocale(HLocale locale) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    disableLocaleSilently(locale);\n+    facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n+      \"jsf.languageSettings.LanguageDisabled\", locale.getLocaleId()));\n+  }\n+\n+  @Transactional\n+  public void disableSelectedLocales() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    List<LocaleId> removedLocales = new ArrayList<>();\n+    for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n+      .entrySet()) {\n+      if (entry.getValue()) {\n+        boolean wasEnabled = disableLocaleSilently(entry.getKey());\n+        if (wasEnabled) {\n+          removedLocales.add(entry.getKey());\n         }\n-        boolean valid = new SlugValidator().isValid(slug, null);\n-        if (!valid) {\n-            String validationMessages =\n-                    ResourceBundle.getBundle(\"ValidationMessages\").getString(\n-                            \"javax.validation.constraints.Slug.message\");\n-            facesMessages.addToControl(componentId, validationMessages);\n-            return false;\n+      }\n+    }\n+    selectedEnabledLocales.clear();\n+    if (removedLocales.isEmpty()) {\n+      // This should not be possible in the UI, but maybe if multiple\n+      // users are editing it.\n+    } else if (removedLocales.size() == 1) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.languageSettings.LanguageDisabled\",\n+          removedLocales.get(0)));\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.languageSettings.LanguagesDisabled\",\n+          StringUtils.join(removedLocales, \", \")));\n+    }\n+  }\n+\n+  private boolean disableLocaleSilently(LocaleId localeId) {\n+    HLocale locale = localeServiceImpl.getByLocaleId(localeId);\n+    return disableLocaleSilently(locale);\n+  }\n+\n+  /**\n+   * Disable a locale without printing any message.\n+   *\n+   * @param locale locale that should be disabled.\n+   * @return false if the locale was already disabled, true otherwise.\n+   */\n+  private boolean disableLocaleSilently(HLocale locale) {\n+    final Set<HLocale> customizedLocales =\n+      getInstance().getCustomizedLocales();\n+    ensureOverridingLocales();\n+    boolean localeWasEnabled = customizedLocales.remove(locale);\n+    getLocaleAliases().remove(locale.getLocaleId());\n+    refreshDisabledLocales();\n+    return localeWasEnabled;\n+  }\n+\n+  @Transactional\n+  public void enableLocale(HLocale locale) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    enableLocaleSilently(locale);\n+    LocaleId localeId = locale.getLocaleId();\n+    facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+      msgs.format(\"jsf.languageSettings.LanguageEnabled\", localeId));\n+  }\n+\n+  @Transactional\n+  public void enableSelectedLocales() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    List<LocaleId> addedLocales = new ArrayList<>();\n+    for (Map.Entry<LocaleId, Boolean> entry : selectedDisabledLocales\n+      .entrySet()) {\n+      if (entry.getValue()) {\n+        boolean wasDisabled = enableLocaleSilently(entry.getKey());\n+        if (wasDisabled) {\n+          addedLocales.add(entry.getKey());\n         }\n+      }\n+    }\n+    selectedDisabledLocales.clear();\n+    if (addedLocales.isEmpty()) {\n+      // This should not be possible in the UI, but maybe if multiple\n+      // users are editing it.\n+    } else if (addedLocales.size() == 1) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.languageSettings.LanguageEnabled\",\n+          addedLocales.get(0)));\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.languageSettings.LanguagesEnabled\",\n+          StringUtils.join(addedLocales, \", \")));\n+    }\n+  }\n+\n+  private boolean enableLocaleSilently(LocaleId localeId) {\n+    HLocale locale = localeServiceImpl.getByLocaleId(localeId);\n+    return enableLocaleSilently(locale);\n+  }\n+\n+  /**\n+   * Enable a given locale without printing any message.\n+   *\n+   * @param locale locale that should be enabled.\n+   * @return false if the locale was already enabled, true otherwise.\n+   */\n+  private boolean enableLocaleSilently(HLocale locale) {\n+    ensureOverridingLocales();\n+    final boolean localeWasDisabled =\n+      getInstance().getCustomizedLocales().add(locale);\n+    refreshDisabledLocales();\n+    return localeWasDisabled;\n+  }\n+\n+  @Transactional\n+  public void useDefaultLocales() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    setOverrideLocales(false);\n+    removeAliasesForDisabledLocales();\n+    refreshDisabledLocales();\n+    update();\n+    facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+      msgs.get(\"jsf.project.LanguageUpdateFromGlobal\"));\n+  }\n+\n+  private void removeAliasesForDisabledLocales() {\n+    Map<LocaleId, String> oldAliases = getLocaleAliases();\n+    Map<LocaleId, String> newAliases = Maps.newHashMap();\n+    for (HLocale enabledLocale : getEnabledLocales()) {\n+      LocaleId key = enabledLocale.getLocaleId();\n+      if (oldAliases.containsKey(key)) {\n+        newAliases.put(key, oldAliases.get(key));\n+      }\n+    }\n+    setLocaleAliases(newAliases);\n+  }\n+\n+  /**\n+   * Ensure that isOverrideLocales is true, and copy data if necessary.\n+   */\n+  private void ensureOverridingLocales() {\n+    if (!isOverrideLocales()) {\n+      startOverridingLocales();\n+    }\n+  }\n+\n+  /**\n+   * Copy locale data from project and set overrideLocales, in preparation for\n+   * making customizations to the locales.\n+   */\n+  private void startOverridingLocales() {\n+    // Copied before setOverrideLocales(true) so that the currently returned\n+    // values will be used as the basis for any customization.\n+    List<HLocale> enabledLocales = getEnabledLocales();\n+    setOverrideLocales(true);\n+    // Replace contents rather than entire collections to avoid confusion\n+    // with reference to the collections that are bound before this runs.\n+    getInstance().getCustomizedLocales().clear();\n+    getInstance().getCustomizedLocales().addAll(enabledLocales);\n+    enteredLocaleAliases.clear();\n+    refreshDisabledLocales();\n+  }\n+\n+  /**\n+   * Update disabled locales to be consistent with enabled locales.\n+   */\n+  private void refreshDisabledLocales() {\n+    // will be re-generated with correct values next time it is fetched.\n+    disabledLocales = null;\n+  }\n+\n+  @Transactional\n+  public void setRestrictedByRole(String key, boolean checked) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    getInstance().setRestrictedByRoles(checked);\n+    update();\n+  }\n+\n+  @Transactional\n+  public void setPrivateProject(boolean privateProject) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    getInstance().setPrivateProject(privateProject);\n+    update();\n+    String message = privateProject\n+      ? msgs.get(\"jsf.permission.private.Active\")\n+      : msgs.get(\"jsf.permission.private.Inactive\");\n+    facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, message);\n+  }\n+\n+  @Override\n+  protected HProject loadInstance() {\n+    Session session = (Session) getEntityManager().getDelegate();\n+    if (projectId == null) {\n+      HProject project = (HProject) session.byNaturalId(HProject.class)\n+        .using(\"slug\", getSlug()).load();\n+      validateProjectState(project);\n+      projectId = project.getId();\n+      return project;\n+    } else {\n+      HProject project =\n+        (HProject) session.byId(HProject.class).load(projectId);\n+      validateProjectState(project);\n+      return project;\n+    }\n+  }\n+\n+  private void validateProjectState(HProject project) {\n+    if (project == null || project.getStatus() == EntityStatus.OBSOLETE) {\n+      log.warn(\n+        \"Project [id={}, slug={}], does not exist or is soft deleted: {}\",\n+        projectId, getSlug(), project);\n+      throw new ProjectNotFoundException(getSlug());\n+    }\n+  }\n+\n+  public void validateSuppliedId() {\n+    HProject ip = getInstance(); // this will raise an EntityNotFound\n+    // exception\n+    // when id is invalid and conversation will not\n+    // start\n+    if (ip.getStatus().equals(EntityStatus.OBSOLETE)) {\n+      throw new EntityNotFoundException();\n+    }\n+  }\n+\n+  @Transactional\n+  public void updateCopyTrans(String action, String value) {\n+    copyTransOptionsModel\n+      .setInstance(getInstance().getDefaultCopyTransOpts());\n+    copyTransOptionsModel.update(action, value);\n+    copyTransOptionsModel.save();\n+    getInstance()\n+      .setDefaultCopyTransOpts(copyTransOptionsModel.getInstance());\n+    update();\n+    facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+      msgs.get(\"jsf.project.CopyTransOpts.updated\"));\n+  }\n+  // @Begin(join = true) /* TODO [CDI] commented out begin conversation.\n+  // Verify it still works properly */\n+\n+  public void initialize() {\n+    if (!identity.hasPermission(getInstance(), \"read\")) {\n+      throw new EntityNotFoundException();\n+    }\n+    validateSuppliedId();\n+    if (getInstance().getDefaultCopyTransOpts() != null) {\n+      copyTransOptionsModel\n+        .setInstance(getInstance().getDefaultCopyTransOpts());\n+    }\n+  }\n+\n+  public void onProjectNameChange(ValueChangeEvent e) {\n+    if (!isValidName((String) e.getNewValue())) {\n+      String componentId = e.getComponent().getId();\n+      facesMessages.addToControl(componentId,\n+        msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n+    }\n+  }\n+\n+  /**\n+   * Check the name by removing any whitespaces in the string and\n+   * make sure it contains at least an alphanumeric char\n+   */\n+  public boolean isValidName(String name) {\n+    String trimmedName = StringUtils.deleteWhitespace(name);\n+    for (char c : trimmedName.toCharArray()) {\n+      if (Character.isDigit(c) || Character.isLetter(c)) {\n         return true;\n-    }\n-\n-    public boolean isSlugAvailable(String slug) {\n-        return slugEntityServiceImpl.isSlugAvailable(slug, HProject.class);\n-    }\n-\n-    private void updateProjectType() {\n-        if (!StringUtils.isEmpty(selectedProjectType)\n-                && !selectedProjectType.equals(\"null\")) {\n-            ProjectType projectType = ProjectType.valueOf(selectedProjectType);\n-            getInstance().setDefaultProjectType(projectType);\n-        }\n-    }\n-\n-    public void setSlug(String slug) {\n-        this.projectSlug.setValue(slug);\n-        this.inputSlugValue = slug;\n-    }\n-\n-    @Override\n-    @Transactional\n-    public String update() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        // getInputSlugValue() can be null\n-        if (!getSlug().equals(getInputSlugValue())\n-                && !validateSlug(getInputSlugValue(), \"slug\")) {\n-            return null;\n-        }\n-        if (getInputSlugValue() != null\n-                && !getSlug().equals(getInputSlugValue())) {\n-            getInstance().setSlug(getInputSlugValue());\n-        }\n-        if (!isValidName(getInstance().getName())) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n-            return null;\n-        }\n-        boolean softDeleted = false;\n-        if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n-            softDeleted = true;\n-            getInstance().setSlug(getInstance().changeToDeletedSlug());\n-        }\n-        String result = super.update();\n-        if (softDeleted) {\n-            String url = urlUtil.dashboardUrl();\n-            urlUtil.redirectToInternal(url);\n-            return result;\n-        }\n-        facesMessages.addGlobal(SEVERITY_INFO,\n-                msgs.get(\"jsf.project.settings.updated\"));\n-        if (!getSlug().equals(getInstance().getSlug())) {\n-            projectSlug.setValue(getInstance().getSlug());\n-            return \"project-slug-updated\";\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    @Transactional\n-    public String persist() {\n-        String retValue = \"\";\n-        if (!validateSlug(getInputSlugValue(), \"slug\")) {\n-            return null;\n-        }\n-        getInstance().setSlug(getInputSlugValue());\n-        if (!isValidName(getInstance().getName())) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n-            return null;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public void verifySlugAvailable(ValueChangeEvent e) {\n+    String slug = (String) e.getNewValue();\n+    validateSlug(slug, e.getComponent().getId());\n+  }\n+\n+  public boolean validateSlug(String slug, String componentId) {\n+    if (StringUtils.equals(getInstance().getSlug(), slug)) {\n+      return true;\n+    }\n+    if (!isSlugAvailable(slug)) {\n+      facesMessages.addToControl(componentId,\n+        \"This Project ID is not available\");\n+      return false;\n+    }\n+    boolean valid = new SlugValidator().isValid(slug, null);\n+    if (!valid) {\n+      String validationMessages =\n+        ResourceBundle.getBundle(\"ValidationMessages\").getString(\n+          \"javax.validation.constraints.Slug.message\");\n+      facesMessages.addToControl(componentId, validationMessages);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  public boolean isSlugAvailable(String slug) {\n+    return slugEntityServiceImpl.isSlugAvailable(slug, HProject.class);\n+  }\n+\n+  private void updateProjectType() {\n+    if (!StringUtils.isEmpty(selectedProjectType)\n+      && !selectedProjectType.equals(\"null\")) {\n+      ProjectType projectType = ProjectType.valueOf(selectedProjectType);\n+      getInstance().setDefaultProjectType(projectType);\n+    }\n+  }\n+\n+  public void setSlug(String slug) {\n+    this.projectSlug.setValue(slug);\n+    this.inputSlugValue = slug;\n+  }\n+\n+  @Override\n+  @Transactional\n+  public String update() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    // getInputSlugValue() can be null\n+    if (!getSlug().equals(getInputSlugValue())\n+      && !validateSlug(getInputSlugValue(), \"slug\")) {\n+      return null;\n+    }\n+    if (getInputSlugValue() != null\n+      && !getSlug().equals(getInputSlugValue())) {\n+      getInstance().setSlug(getInputSlugValue());\n+    }\n+    if (!isValidName(getInstance().getName())) {\n+      facesMessages.addGlobal(SEVERITY_ERROR,\n+        msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n+      return null;\n+    }\n+    boolean softDeleted = false;\n+    if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n+      softDeleted = true;\n+      getInstance().setSlug(getInstance().changeToDeletedSlug());\n+    }\n+    String result = super.update();\n+    if (softDeleted) {\n+      String url = urlUtil.dashboardUrl();\n+      urlUtil.redirectToInternal(url);\n+      return result;\n+    }\n+    facesMessages.addGlobal(SEVERITY_INFO,\n+      msgs.get(\"jsf.project.settings.updated\"));\n+    if (!getSlug().equals(getInstance().getSlug())) {\n+      projectSlug.setValue(getInstance().getSlug());\n+      return \"project-slug-updated\";\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  @Transactional\n+  public String persist() {\n+    String retValue = \"\";\n+    if (!validateSlug(getInputSlugValue(), \"slug\")) {\n+      return null;\n+    }\n+    getInstance().setSlug(getInputSlugValue());\n+    if (!isValidName(getInstance().getName())) {\n+      facesMessages.addGlobal(SEVERITY_ERROR,\n+        msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n+      return null;\n+    }\n+    if (StringUtils.isEmpty(selectedProjectType)\n+      || selectedProjectType.equals(\"null\")) {\n+      facesMessages.addGlobal(SEVERITY_ERROR,\n+        \"Project type not selected\");\n+      return null;\n+    }\n+    if (StringUtils.isEmpty(selectedProjectType)\n+      || selectedProjectType.equals(\"null\")) {\n+      facesMessages.addGlobal(SEVERITY_ERROR,\n+        \"Project type not selected\");\n+      return null;\n+    }\n+    updateProjectType();\n+    if (currentUser.isLoggedIn()) {\n+      // authenticatedAccount person is a detached entity, so fetch a copy\n+      // that is attached to the current session.\n+      HPerson creator = personDAO\n+        .findById(currentUser.getPerson().getId());\n+      getInstance().addMaintainer(creator);\n+      getInstance().getCustomizedValidations().clear();\n+      for (ValidationAction validationAction : validationServiceImpl\n+        .getValidationActions(\"\")) {\n+        getInstance().getCustomizedValidations().put(\n+          validationAction.getId().name(),\n+          validationAction.getState().name());\n+      }\n+      retValue = super.persist();\n+      webhookServiceImpl.processWebhookMaintainerChanged(\n+        getInstance().getSlug(), creator.getAccount().getUsername(),\n+        Maintainer, getInstance().getWebHooks(),\n+        ProjectMaintainerChangedEvent.ChangeType.ADD);\n+    }\n+    return retValue;\n+  }\n+\n+  /**\n+   * Returns the rendered, sanitised HTML for the about page content set by\n+   * the project maintainer.\n+   *\n+   * @return\n+   */\n+  public String getAboutHtml() {\n+    // we could cache this, but it may not be worth it\n+    String text = getInstance().getHomeContent();\n+    return renderer.renderToHtmlSafe(text);\n+  }\n+\n+  public List<HPerson> getInstanceMaintainers() {\n+    List<HPerson> list = Lists.newArrayList(getInstance().getMaintainers());\n+    Collections.sort(list, ComparatorUtil.PERSON_NAME_COMPARATOR);\n+    return list;\n+  }\n+\n+  @Transactional\n+  public String removeMaintainer(HPerson person) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    if (getInstanceMaintainers().size() <= 1) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.get(\"jsf.project.NeedAtLeastOneMaintainer\"));\n+    } else {\n+      getInstance().removeMaintainer(person);\n+      maintainerFilter.reset();\n+      update();\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n+        .format(\"jsf.project.MaintainerRemoved\", person.getName()));\n+      webhookServiceImpl.processWebhookMaintainerChanged(getSlug(),\n+        person.getAccount().getUsername(), Maintainer,\n+        getInstance().getWebHooks(),\n+        ProjectMaintainerChangedEvent.ChangeType.REMOVE);\n+      if (person.equals(currentUser.getPerson())) {\n+        urlUtil.redirectToInternal(urlUtil.projectUrl(getSlug()));\n+      }\n+    }\n+    return \"\";\n+  }\n+\n+  @Transactional\n+  public void updateRoles(String roleName, boolean isRestricted) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    getInstance().getAllowedRoles().clear();\n+    if (getInstance().isRestrictedByRoles()) {\n+      getRoleRestrictions().put(roleName, isRestricted);\n+      for (Map.Entry<String, Boolean> entry : getRoleRestrictions()\n+        .entrySet()) {\n+        if (entry.getValue()) {\n+          getInstance().getAllowedRoles()\n+            .add(accountRoleDAO.findByName(entry.getKey()));\n         }\n-        if (StringUtils.isEmpty(selectedProjectType)\n-                || selectedProjectType.equals(\"null\")) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    \"Project type not selected\");\n-            return null;\n+      }\n+    }\n+    update();\n+    facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+      msgs.get(\"jsf.RolesUpdated\"));\n+  }\n+\n+  @Transactional\n+  public void updateStatus(char initial) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    EntityStatus status = EntityStatus.valueOf(initial);\n+    getInstance().setStatus(status);\n+    if (getInstance().getStatus() == EntityStatus.READONLY) {\n+      for (HProjectIteration version : getInstance()\n+        .getProjectIterations()) {\n+        if (version.getStatus() == EntityStatus.ACTIVE) {\n+          version.setStatus(EntityStatus.READONLY);\n+          entityManager.merge(version);\n         }\n-        if (StringUtils.isEmpty(selectedProjectType)\n-                || selectedProjectType.equals(\"null\")) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    \"Project type not selected\");\n-            return null;\n+      }\n+    } else if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n+      for (HProjectIteration version : getInstance()\n+        .getProjectIterations()) {\n+        if (version.getStatus() != EntityStatus.OBSOLETE) {\n+          version.setStatus(EntityStatus.OBSOLETE);\n+          entityManager.merge(version);\n         }\n-        updateProjectType();\n-        if (currentUser.isLoggedIn()) {\n-            // authenticatedAccount person is a detached entity, so fetch a copy\n-            // that is attached to the current session.\n-            HPerson creator = personDAO\n-                    .findById(currentUser.getPerson().getId());\n-            getInstance().addMaintainer(creator);\n-            getInstance().getCustomizedValidations().clear();\n-            for (ValidationAction validationAction : validationServiceImpl\n-                    .getValidationActions(\"\")) {\n-                getInstance().getCustomizedValidations().put(\n-                        validationAction.getId().name(),\n-                        validationAction.getState().name());\n-            }\n-            retValue = super.persist();\n-            webhookServiceImpl.processWebhookMaintainerChanged(\n-                    getInstance().getSlug(), creator.getAccount().getUsername(),\n-                    Maintainer, getInstance().getWebHooks(),\n-                    ProjectMaintainerChangedEvent.ChangeType.ADD);\n+      }\n+    }\n+    update();\n+    if (status.equals(EntityStatus.OBSOLETE)) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.project.notification.deleted\", getSlug()));\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.format(\"jsf.project.status.updated\", status));\n+    }\n+  }\n+\n+  @Transactional\n+  public void deleteSelf() {\n+    updateStatus('O');\n+  }\n+\n+  public Map<String, Boolean> getRoleRestrictions() {\n+    if (roleRestrictions == null) {\n+      roleRestrictions = Maps.newHashMap();\n+      for (HAccountRole role : getInstance().getAllowedRoles()) {\n+        roleRestrictions.put(role.getName(), true);\n+      }\n+    }\n+    return roleRestrictions;\n+  }\n+\n+  public boolean isRoleRestrictionEnabled(String roleName) {\n+    if (getRoleRestrictions().containsKey(roleName)) {\n+      return getRoleRestrictions().get(roleName);\n+    }\n+    return false;\n+  }\n+\n+  public List<HAccountRole> getAvailableRoles() {\n+    List<HAccountRole> allRoles = accountRoleDAO.findAll();\n+    allRoles.sort(ComparatorUtil.ACCOUNT_ROLE_COMPARATOR);\n+    return allRoles;\n+  }\n+\n+  private @NotNull\n+  List<HProjectIteration> fetchVersions() {\n+    return getInstance()\n+      .getProjectIterations()\n+      .stream()\n+      .filter(it -> it.getStatus() != EntityStatus.OBSOLETE)\n+      .sorted((o1, o2) -> {\n+        EntityStatus fromStatus = o1.getStatus();\n+        EntityStatus toStatus = o2.getStatus();\n+        if (fromStatus.equals(toStatus)) {\n+          return 0;\n         }\n-        return retValue;\n-    }\n-\n-    /**\n-     * Returns the rendered, sanitised HTML for the about page content set by\n-     * the project maintainer.\n-     *\n-     * @return\n-     */\n-    public String getAboutHtml() {\n-        // we could cache this, but it may not be worth it\n-        String text = getInstance().getHomeContent();\n-        return renderer.renderToHtmlSafe(text);\n-    }\n-\n-    public List<HPerson> getInstanceMaintainers() {\n-        List<HPerson> list = Lists.newArrayList(getInstance().getMaintainers());\n-        Collections.sort(list, ComparatorUtil.PERSON_NAME_COMPARATOR);\n-        return list;\n-    }\n-\n-    @Transactional\n-    public String removeMaintainer(HPerson person) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        if (getInstanceMaintainers().size() <= 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.get(\"jsf.project.NeedAtLeastOneMaintainer\"));\n-        } else {\n-            getInstance().removeMaintainer(person);\n-            maintainerFilter.reset();\n-            update();\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                    .format(\"jsf.project.MaintainerRemoved\", person.getName()));\n-            webhookServiceImpl.processWebhookMaintainerChanged(getSlug(),\n-                    person.getAccount().getUsername(), Maintainer,\n-                    getInstance().getWebHooks(),\n-                    ProjectMaintainerChangedEvent.ChangeType.REMOVE);\n-            if (person.equals(currentUser.getPerson())) {\n-                urlUtil.redirectToInternal(urlUtil.projectUrl(getSlug()));\n-            }\n-        }\n-        return \"\";\n-    }\n-\n-    @Transactional\n-    public void updateRoles(String roleName, boolean isRestricted) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        getInstance().getAllowedRoles().clear();\n-        if (getInstance().isRestrictedByRoles()) {\n-            getRoleRestrictions().put(roleName, isRestricted);\n-            for (Map.Entry<String, Boolean> entry : getRoleRestrictions()\n-                    .entrySet()) {\n-                if (entry.getValue()) {\n-                    getInstance().getAllowedRoles()\n-                            .add(accountRoleDAO.findByName(entry.getKey()));\n-                }\n-            }\n-        }\n-        update();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.get(\"jsf.RolesUpdated\"));\n-    }\n-\n-    @Transactional\n-    public void updateStatus(char initial) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        EntityStatus status = EntityStatus.valueOf(initial);\n-        getInstance().setStatus(status);\n-        if (getInstance().getStatus() == EntityStatus.READONLY) {\n-            for (HProjectIteration version : getInstance()\n-                    .getProjectIterations()) {\n-                if (version.getStatus() == EntityStatus.ACTIVE) {\n-                    version.setStatus(EntityStatus.READONLY);\n-                    entityManager.merge(version);\n-                }\n-            }\n-        } else if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n-            for (HProjectIteration version : getInstance()\n-                    .getProjectIterations()) {\n-                if (version.getStatus() != EntityStatus.OBSOLETE) {\n-                    version.setStatus(EntityStatus.OBSOLETE);\n-                    entityManager.merge(version);\n-                }\n-            }\n+        if (fromStatus.equals(EntityStatus.ACTIVE)) {\n+          return -1;\n         }\n-        update();\n-        if (status.equals(EntityStatus.OBSOLETE)) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.project.notification.deleted\", getSlug()));\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.project.status.updated\", status));\n+        if (fromStatus.equals(EntityStatus.READONLY)) {\n+          if (toStatus.equals(EntityStatus.ACTIVE)) {\n+            return 1;\n+          }\n+          return -1;\n         }\n-    }\n-\n-    @Transactional\n-    public void deleteSelf() {\n-        updateStatus('O');\n-    }\n-\n-    public Map<String, Boolean> getRoleRestrictions() {\n-        if (roleRestrictions == null) {\n-            roleRestrictions = Maps.newHashMap();\n-            for (HAccountRole role : getInstance().getAllowedRoles()) {\n-                roleRestrictions.put(role.getName(), true);\n-            }\n-        }\n-        return roleRestrictions;\n-    }\n-\n-    public boolean isRoleRestrictionEnabled(String roleName) {\n-        if (getRoleRestrictions().containsKey(roleName)) {\n-            return getRoleRestrictions().get(roleName);\n-        }\n-        return false;\n-    }\n-\n-    public List<HAccountRole> getAvailableRoles() {\n-        List<HAccountRole> allRoles = accountRoleDAO.findAll();\n-        allRoles.sort(ComparatorUtil.ACCOUNT_ROLE_COMPARATOR);\n-        return allRoles;\n-    }\n-\n-    private @NotNull List<HProjectIteration> fetchVersions() {\n-        return getInstance()\n-                .getProjectIterations()\n-                .stream()\n-                .filter(it -> it.getStatus() != EntityStatus.OBSOLETE)\n-                .sorted((o1, o2) -> {\n-                    EntityStatus fromStatus = o1.getStatus();\n-                    EntityStatus toStatus = o2.getStatus();\n-                    if (fromStatus.equals(toStatus)) {\n-                        return 0;\n-                    }\n-                    if (fromStatus.equals(EntityStatus.ACTIVE)) {\n-                        return -1;\n-                    }\n-                    if (fromStatus.equals(EntityStatus.READONLY)) {\n-                        if (toStatus.equals(EntityStatus.ACTIVE)) {\n-                            return 1;\n-                        }\n-                        return -1;\n-                    }\n-                    return 0;\n-                })\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public boolean isIdDefined() {\n-        return getSlug() != null;\n-    }\n+        return 0;\n+      })\n+      .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public boolean isIdDefined() {\n+    return getSlug() != null;\n+  }\n+\n+  @Override\n+  public NaturalIdentifier getNaturalId() {\n+    return Restrictions.naturalId().set(\"slug\", getSlug());\n+  }\n+\n+  @Override\n+  public Object getId() {\n+    return getSlug();\n+  }\n+\n+  private Map<ValidationId, ValidationAction> getValidations() {\n+    if (availableValidations.isEmpty()) {\n+      Collection<ValidationAction> validationList = validationServiceImpl\n+        .getValidationActions(getInstance().getSlug());\n+      for (ValidationAction validationAction : validationList) {\n+        availableValidations.put(validationAction.getId(),\n+          validationAction);\n+      }\n+    }\n+    return availableValidations;\n+  }\n+\n+  @Transactional\n+  public void updateValidationOption(String name, String state) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    ValidationId validationId = ValidationId.valueOf(name);\n+    for (Map.Entry<ValidationId, ValidationAction> entry : getValidations()\n+      .entrySet()) {\n+      if (entry.getKey().name().equals(name)) {\n+        getValidations().get(validationId)\n+          .setState(ValidationAction.State.valueOf(state));\n+        getInstance().getCustomizedValidations().put(\n+          entry.getKey().name(),\n+          entry.getValue().getState().name());\n+        ensureMutualExclusivity(getValidations().get(validationId));\n+        break;\n+      }\n+    }\n+    update();\n+    facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+      msgs.format(\"jsf.validation.updated\",\n+        validationId.getDisplayName(), state));\n+  }\n+\n+  public List<ValidationAction> getValidationList() {\n+    List<ValidationAction> sortedList =\n+      Lists.newArrayList(getValidations().values());\n+    Collections.sort(sortedList,\n+      ValidationFactory.ValidationActionComparator);\n+    return sortedList;\n+  }\n+\n+  @Transactional\n+  public void addWebHook(String url, String secret, String strTypes,\n+                         String name) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    Set<WebhookType> types = getTypesFromString(strTypes);\n+    if (types.isEmpty()) {\n+      facesMessages.addGlobal(msgs.get(\"jsf.project.webhookType.empty\"));\n+      return;\n+    }\n+    if (!isValidUrl(url)) {\n+      return;\n+    }\n+    if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url)) {\n+      facesMessages.addGlobal(SEVERITY_ERROR,\n+        msgs.format(\"jsf.project.DuplicateUrl\", url));\n+      return;\n+    }\n+    boolean isAdded = projectServiceImpl.addWebhook(getInstance(), url,\n+      secret, name, types);\n+    if (isAdded) {\n+      facesMessages\n+        .addGlobal(msgs.format(\"jsf.project.AddNewWebhook\", url));\n+    }\n+  }\n+\n+  @Transactional\n+  public void removeWebHook(String id) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    WebHook webHook = webHookDAO.findById(Long.valueOf(id));\n+    if (webHook != null) {\n+      String url = webHook.getUrl();\n+      getInstance().getWebHooks().remove(webHook);\n+      webHookDAO.makeTransient(webHook);\n+      facesMessages\n+        .addGlobal(msgs.format(\"jsf.project.RemoveWebhook\", url));\n+    }\n+  }\n+\n+  @Transactional\n+  public void updateWebhook(String id, String url, String secret,\n+                            String strTypes, String name) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    Set<WebhookType> types = getTypesFromString(strTypes);\n+    if (types.isEmpty()) {\n+      facesMessages.addGlobal(msgs.get(\"jsf.project.webhookType.empty\"));\n+      return;\n+    }\n+    if (!isValidUrl(url)) {\n+      return;\n+    }\n+    Long webhookId = Long.valueOf(id);\n+    if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url,\n+      webhookId)) {\n+      facesMessages.addGlobal(SEVERITY_ERROR,\n+        msgs.format(\"jsf.project.DuplicateUrl\", url));\n+      return;\n+    }\n+    boolean updated = projectServiceImpl.updateWebhook(getInstance(),\n+      webhookId, url, secret, name, types);\n+    if (updated) {\n+      facesMessages\n+        .addGlobal(msgs.format(\"jsf.project.UpdateWebhook\", url));\n+    }\n+  }\n+\n+  public void testWebhook(String url, String secret) {\n+    identity.checkPermission(getInstance(), \"update\");\n+    if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url)) {\n+      facesMessages.addGlobal(SEVERITY_ERROR,\n+        msgs.format(\"jsf.project.DuplicateUrl\", url));\n+      return;\n+    }\n+    if (!isValidUrl(url)) {\n+      return;\n+    }\n+    webhookServiceImpl.processTestEvent(identity.getAccountUsername(),\n+      getSlug(), url, secret);\n+  }\n+\n+  /**\n+   * Check if url is valid and there is no duplication of url+type\n+   */\n+  private boolean isValidUrl(String url) {\n+    if (!webhookServiceImpl.isValidUrl(url)) {\n+      facesMessages.addGlobal(SEVERITY_ERROR,\n+        msgs.format(\"jsf.project.InvalidUrl\", url));\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * If this action is enabled(Warning or Error), then it's exclusive\n+   * validation will be turn off\n+   *\n+   * @param selectedValidationAction\n+   */\n+  private void\n+  ensureMutualExclusivity(ValidationAction selectedValidationAction) {\n+    if (selectedValidationAction.getState() != ValidationAction.State.Off) {\n+      for (ValidationAction exclusiveValAction : selectedValidationAction\n+        .getExclusiveValidations()) {\n+        getInstance().getCustomizedValidations().put(\n+          exclusiveValAction.getId().name(),\n+          ValidationAction.State.Off.name());\n+        getValidations().get(exclusiveValAction.getId())\n+          .setState(ValidationAction.State.Off);\n+      }\n+    }\n+  }\n+\n+  public List<ValidationAction.State> getValidationStates() {\n+    return Arrays.asList(ValidationAction.State.values());\n+  }\n+\n+  /**\n+   * Update the about page to the entered value, and show a success message.\n+   */\n+  @Transactional\n+  public void updateAboutPage() {\n+    identity.checkPermission(getInstance(), \"update\");\n+    String status = update();\n+    if (\"updated\".equals(status)) {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n+        msgs.get(\"jsf.project.AboutPageUpdated\"));\n+    } else {\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_ERROR,\n+        msgs.get(\"jsf.project.AboutPageUpdateFailed\"));\n+    }\n+  }\n+\n+  @Override\n+  protected void updatedMessage() {\n+    // Disable the default message from Seam\n+  }\n+\n+  @ViewScoped\n+  public static class ProjectMaintainersAutocomplete\n+    extends MaintainerAutocomplete {\n+\n+    private static final long serialVersionUID = -6765972032876700000L;\n+    @Inject\n+    private ProjectHome projectHome;\n+    @Inject\n+    private WebhookServiceImpl webhookServiceImpl;\n+    @Inject\n+    private Messages msgs;\n+    @Inject\n+    private ZanataIdentity zanataIdentity;\n+    @Inject\n+    private PersonDAO personDAO;\n+    @Inject\n+    private FacesMessages facesMessages;\n \n-    @Override\n-    public NaturalIdentifier getNaturalId() {\n-        return Restrictions.naturalId().set(\"slug\", getSlug());\n+    private HProject getInstance() {\n+      return projectHome.getInstance();\n     }\n \n     @Override\n-    public Object getId() {\n-        return getSlug();\n-    }\n-\n-    private Map<ValidationId, ValidationAction> getValidations() {\n-        if (availableValidations.isEmpty()) {\n-            Collection<ValidationAction> validationList = validationServiceImpl\n-                    .getValidationActions(getInstance().getSlug());\n-            for (ValidationAction validationAction : validationList) {\n-                availableValidations.put(validationAction.getId(),\n-                        validationAction);\n-            }\n-        }\n-        return availableValidations;\n-    }\n-\n-    @Transactional\n-    public void updateValidationOption(String name, String state) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        ValidationId validationId = ValidationId.valueOf(name);\n-        for (Map.Entry<ValidationId, ValidationAction> entry : getValidations()\n-                .entrySet()) {\n-            if (entry.getKey().name().equals(name)) {\n-                getValidations().get(validationId)\n-                        .setState(ValidationAction.State.valueOf(state));\n-                getInstance().getCustomizedValidations().put(\n-                        entry.getKey().name(),\n-                        entry.getValue().getState().name());\n-                ensureMutualExclusivity(getValidations().get(validationId));\n-                break;\n-            }\n-        }\n-        update();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.format(\"jsf.validation.updated\",\n-                        validationId.getDisplayName(), state));\n-    }\n-\n-    public List<ValidationAction> getValidationList() {\n-        List<ValidationAction> sortedList =\n-                Lists.newArrayList(getValidations().values());\n-        Collections.sort(sortedList,\n-                ValidationFactory.ValidationActionComparator);\n-        return sortedList;\n-    }\n-\n-    @Transactional\n-    public void addWebHook(String url, String secret, String strTypes,\n-            String name) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        Set<WebhookType> types = getTypesFromString(strTypes);\n-        if (types.isEmpty()) {\n-            facesMessages.addGlobal(msgs.get(\"jsf.project.webhookType.empty\"));\n-            return;\n-        }\n-        if (!isValidUrl(url)) {\n-            return;\n-        }\n-        if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url)) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.format(\"jsf.project.DuplicateUrl\", url));\n-            return;\n-        }\n-        boolean isAdded = projectServiceImpl.addWebhook(getInstance(), url,\n-                secret, name, types);\n-        if (isAdded) {\n-            facesMessages\n-                    .addGlobal(msgs.format(\"jsf.project.AddNewWebhook\", url));\n-        }\n-    }\n-\n-    @Transactional\n-    public void removeWebHook(String id) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        WebHook webHook = webHookDAO.findById(Long.valueOf(id));\n-        if (webHook != null) {\n-            String url = webHook.getUrl();\n-            getInstance().getWebHooks().remove(webHook);\n-            webHookDAO.makeTransient(webHook);\n-            facesMessages\n-                    .addGlobal(msgs.format(\"jsf.project.RemoveWebhook\", url));\n-        }\n-    }\n-\n-    @Transactional\n-    public void updateWebhook(String id, String url, String secret,\n-            String strTypes, String name) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        Set<WebhookType> types = getTypesFromString(strTypes);\n-        if (types.isEmpty()) {\n-            facesMessages.addGlobal(msgs.get(\"jsf.project.webhookType.empty\"));\n-            return;\n-        }\n-        if (!isValidUrl(url)) {\n-            return;\n-        }\n-        Long webhookId = Long.valueOf(id);\n-        if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url,\n-                webhookId)) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.format(\"jsf.project.DuplicateUrl\", url));\n-            return;\n-        }\n-        boolean updated = projectServiceImpl.updateWebhook(getInstance(),\n-                webhookId, url, secret, name, types);\n-        if (updated) {\n-            facesMessages\n-                    .addGlobal(msgs.format(\"jsf.project.UpdateWebhook\", url));\n-        }\n-    }\n-\n-    public void testWebhook(String url, String secret) {\n-        identity.checkPermission(getInstance(), \"update\");\n-        if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url)) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.format(\"jsf.project.DuplicateUrl\", url));\n-            return;\n-        }\n-        if (!isValidUrl(url)) {\n-            return;\n-        }\n-        webhookServiceImpl.processTestEvent(identity.getAccountUsername(),\n-                getSlug(), url, secret);\n-    }\n-\n-    /**\n-     * Check if url is valid and there is no duplication of url+type\n-     */\n-    private boolean isValidUrl(String url) {\n-        if (!webhookServiceImpl.isValidUrl(url)) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.format(\"jsf.project.InvalidUrl\", url));\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * If this action is enabled(Warning or Error), then it's exclusive\n-     * validation will be turn off\n-     *\n-     * @param selectedValidationAction\n-     */\n-    private void\n-            ensureMutualExclusivity(ValidationAction selectedValidationAction) {\n-        if (selectedValidationAction.getState() != ValidationAction.State.Off) {\n-            for (ValidationAction exclusiveValAction : selectedValidationAction\n-                    .getExclusiveValidations()) {\n-                getInstance().getCustomizedValidations().put(\n-                        exclusiveValAction.getId().name(),\n-                        ValidationAction.State.Off.name());\n-                getValidations().get(exclusiveValAction.getId())\n-                        .setState(ValidationAction.State.Off);\n-            }\n-        }\n-    }\n-\n-    public List<ValidationAction.State> getValidationStates() {\n-        return Arrays.asList(ValidationAction.State.values());\n+    protected List<HPerson> getMaintainers() {\n+      List<HPerson> list =\n+        Lists.newArrayList(getInstance().getMaintainers());\n+      Collections.sort(list, ComparatorUtil.PERSON_NAME_COMPARATOR);\n+      return list;\n     }\n \n     /**\n-     * Update the about page to the entered value, and show a success message.\n+     * Action when an item is selected\n      */\n-    @Transactional\n-    public void updateAboutPage() {\n-        identity.checkPermission(getInstance(), \"update\");\n-        String status = update();\n-        if (\"updated\".equals(status)) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.get(\"jsf.project.AboutPageUpdated\"));\n-        } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_ERROR,\n-                    msgs.get(\"jsf.project.AboutPageUpdateFailed\"));\n-        }\n-    }\n-\n     @Override\n-    protected void updatedMessage() {\n-        // Disable the default message from Seam\n-    }\n-\n-    @ViewScoped\n-    public static class ProjectMaintainersAutocomplete\n-            extends MaintainerAutocomplete {\n-\n-        private static final long serialVersionUID = -6765972032876700000L;\n-        @Inject\n-        private ProjectHome projectHome;\n-        @Inject\n-        private WebhookServiceImpl webhookServiceImpl;\n-        @Inject\n-        private Messages msgs;\n-        @Inject\n-        private ZanataIdentity zanataIdentity;\n-        @Inject\n-        private PersonDAO personDAO;\n-        @Inject\n-        private FacesMessages facesMessages;\n-\n-        private HProject getInstance() {\n-            return projectHome.getInstance();\n-        }\n-\n-        @Override\n-        protected List<HPerson> getMaintainers() {\n-            List<HPerson> list =\n-                    Lists.newArrayList(getInstance().getMaintainers());\n-            Collections.sort(list, ComparatorUtil.PERSON_NAME_COMPARATOR);\n-            return list;\n-        }\n-\n-        /**\n-         * Action when an item is selected\n-         */\n-        @Override\n-        @Transactional\n-        public void onSelectItemAction() {\n-            if (StringUtils.isEmpty(getSelectedItem())) {\n-                return;\n-            }\n-            zanataIdentity.checkPermission(getInstance(), \"update\");\n-            HPerson maintainer = personDAO.findByUsername(getSelectedItem());\n-            getInstance().addMaintainer(maintainer);\n-            projectHome.update();\n-            reset();\n-            projectHome.getMaintainerFilter().reset();\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n-                    \"jsf.project.MaintainerAdded\", maintainer.getName()));\n-            webhookServiceImpl.processWebhookMaintainerChanged(\n-                    getInstance().getSlug(),\n-                    maintainer.getAccount().getUsername(), Maintainer,\n-                    getInstance().getWebHooks(),\n-                    ProjectMaintainerChangedEvent.ChangeType.ADD);\n-        }\n-    }\n-\n-    public List<ProjectType> getProjectTypeList() {\n-        List<ProjectType> projectTypes = Arrays.asList(ProjectType.values());\n-        Collections.sort(projectTypes, ComparatorUtil.PROJECT_TYPE_COMPARATOR);\n-        return projectTypes;\n-    }\n-\n-    public ProjectSlug getProjectSlug() {\n-        return this.projectSlug;\n-    }\n-\n-    /**\n-     * This field is set from form input which can differ from original slug\n-     */\n-    @Nullable\n-    public String getInputSlugValue() {\n-        return this.inputSlugValue;\n-    }\n-\n-    /**\n-     * This field is set from form input which can differ from original slug\n-     */\n-    public void setInputSlugValue(@Nullable final String inputSlugValue) {\n-        this.inputSlugValue = inputSlugValue;\n-    }\n-\n-    public void setProjectId(final Long projectId) {\n-        this.projectId = projectId;\n-    }\n-\n-    public Long getProjectId() {\n-        return this.projectId;\n-    }\n-\n-    public String getEnabledLocalesFilter() {\n-        return this.enabledLocalesFilter;\n-    }\n-\n-    public void setEnabledLocalesFilter(final String enabledLocalesFilter) {\n-        this.enabledLocalesFilter = enabledLocalesFilter;\n-    }\n-\n-    public String getDisabledLocalesFilter() {\n-        return this.disabledLocalesFilter;\n-    }\n-\n-    public void setDisabledLocalesFilter(final String disabledLocalesFilter) {\n-        this.disabledLocalesFilter = disabledLocalesFilter;\n-    }\n-\n-    /**\n-     * A separate map is used, rather than binding the alias map from the\n-     * project directly. This is done so that empty values are not added to the\n-     * map in every form submission, and so that a value entered in the field\n-     * for a row is not automatically updated when a different row is submitted.\n-     */\n-    public Map<LocaleId, String> getEnteredLocaleAliases() {\n-        return this.enteredLocaleAliases;\n-    }\n-\n-    /**\n-     * A separate map is used, rather than binding the alias map from the\n-     * project directly. This is done so that empty values are not added to the\n-     * map in every form submission, and so that a value entered in the field\n-     * for a row is not automatically updated when a different row is submitted.\n-     */\n-    public void setEnteredLocaleAliases(\n-            final Map<LocaleId, String> enteredLocaleAliases) {\n-        this.enteredLocaleAliases = enteredLocaleAliases;\n-    }\n-\n-    public void setSelectedEnabledLocales(\n-            final Map<LocaleId, Boolean> selectedEnabledLocales) {\n-        this.selectedEnabledLocales = selectedEnabledLocales;\n-    }\n-\n-    public Map<LocaleId, Boolean> getSelectedDisabledLocales() {\n-        return this.selectedDisabledLocales;\n-    }\n-\n-    public void setSelectedDisabledLocales(\n-            final Map<LocaleId, Boolean> selectedDisabledLocales) {\n-        this.selectedDisabledLocales = selectedDisabledLocales;\n-    }\n-\n-    public Boolean getSelectedCheckbox() {\n-        return this.selectedCheckbox;\n-    }\n-\n-    public void setSelectedCheckbox(final Boolean selectedCheckbox) {\n-        this.selectedCheckbox = selectedCheckbox;\n-    }\n-\n-    public List<HProjectIteration> getVersions() {\n-        this.versions.compareAndSet(null, fetchVersions());\n-        return versions.get();\n-    }\n-\n-    public String getSelectedProjectType() {\n-        return this.selectedProjectType;\n-    }\n-\n-    public ProjectMaintainersAutocomplete getMaintainerAutocomplete() {\n-        return this.maintainerAutocomplete;\n-    }\n-\n-    public AbstractListFilter<HPerson> getMaintainerFilter() {\n-        return this.maintainerFilter;\n-    }\n+    @Transactional\n+    public void onSelectItemAction() {\n+      if (StringUtils.isEmpty(getSelectedItem())) {\n+        return;\n+      }\n+      zanataIdentity.checkPermission(getInstance(), \"update\");\n+      HPerson maintainer = personDAO.findByUsername(getSelectedItem());\n+      getInstance().addMaintainer(maintainer);\n+      projectHome.update();\n+      reset();\n+      projectHome.getMaintainerFilter().reset();\n+      facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n+        \"jsf.project.MaintainerAdded\", maintainer.getName()));\n+      webhookServiceImpl.processWebhookMaintainerChanged(\n+        getInstance().getSlug(),\n+        maintainer.getAccount().getUsername(), Maintainer,\n+        getInstance().getWebHooks(),\n+        ProjectMaintainerChangedEvent.ChangeType.ADD);\n+    }\n+  }\n+\n+  public List<ProjectType> getProjectTypeList() {\n+    List<ProjectType> projectTypes = Arrays.asList(ProjectType.values());\n+    Collections.sort(projectTypes, ComparatorUtil.PROJECT_TYPE_COMPARATOR);\n+    return projectTypes;\n+  }\n+\n+  public ProjectSlug getProjectSlug() {\n+    return this.projectSlug;\n+  }\n+\n+  /**\n+   * This field is set from form input which can differ from original slug\n+   */\n+  @Nullable\n+  public String getInputSlugValue() {\n+    return this.inputSlugValue;\n+  }\n+\n+  /**\n+   * This field is set from form input which can differ from original slug\n+   */\n+  public void setInputSlugValue(@Nullable final String inputSlugValue) {\n+    this.inputSlugValue = inputSlugValue;\n+  }\n+\n+  public void setProjectId(final Long projectId) {\n+    this.projectId = projectId;\n+  }\n+\n+  public Long getProjectId() {\n+    return this.projectId;\n+  }\n+\n+  public String getEnabledLocalesFilter() {\n+    return this.enabledLocalesFilter;\n+  }\n+\n+  public void setEnabledLocalesFilter(final String enabledLocalesFilter) {\n+    this.enabledLocalesFilter = enabledLocalesFilter;\n+  }\n+\n+  public String getDisabledLocalesFilter() {\n+    return this.disabledLocalesFilter;\n+  }\n+\n+  public void setDisabledLocalesFilter(final String disabledLocalesFilter) {\n+    this.disabledLocalesFilter = disabledLocalesFilter;\n+  }\n+\n+  /**\n+   * A separate map is used, rather than binding the alias map from the\n+   * project directly. This is done so that empty values are not added to the\n+   * map in every form submission, and so that a value entered in the field\n+   * for a row is not automatically updated when a different row is submitted.\n+   */\n+  public Map<LocaleId, String> getEnteredLocaleAliases() {\n+    return this.enteredLocaleAliases;\n+  }\n+\n+  /**\n+   * A separate map is used, rather than binding the alias map from the\n+   * project directly. This is done so that empty values are not added to the\n+   * map in every form submission, and so that a value entered in the field\n+   * for a row is not automatically updated when a different row is submitted.\n+   */\n+  public void setEnteredLocaleAliases(\n+    final Map<LocaleId, String> enteredLocaleAliases) {\n+    this.enteredLocaleAliases = enteredLocaleAliases;\n+  }\n+\n+  public void setSelectedEnabledLocales(\n+    final Map<LocaleId, Boolean> selectedEnabledLocales) {\n+    this.selectedEnabledLocales = selectedEnabledLocales;\n+  }\n+\n+  public Map<LocaleId, Boolean> getSelectedDisabledLocales() {\n+    return this.selectedDisabledLocales;\n+  }\n+\n+  public void setSelectedDisabledLocales(\n+    final Map<LocaleId, Boolean> selectedDisabledLocales) {\n+    this.selectedDisabledLocales = selectedDisabledLocales;\n+  }\n+\n+  public Boolean getSelectedCheckbox() {\n+    return this.selectedCheckbox;\n+  }\n+\n+  public void setSelectedCheckbox(final Boolean selectedCheckbox) {\n+    this.selectedCheckbox = selectedCheckbox;\n+  }\n+\n+  public List<HProjectIteration> getVersions() {\n+    this.versions.compareAndSet(null, fetchVersions());\n+    return versions.get();\n+  }\n+\n+  public String getSelectedProjectType() {\n+    return this.selectedProjectType;\n+  }\n+\n+  public ProjectMaintainersAutocomplete getMaintainerAutocomplete() {\n+    return this.maintainerAutocomplete;\n+  }\n+\n+  public AbstractListFilter<HPerson> getMaintainerFilter() {\n+    return this.maintainerFilter;\n+  }\n }\n",
            "diff_size": 1837
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/67/ProjectHome.java\nindex 9bb27e6eacb..979c28ae167 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/67/ProjectHome.java\n@@ -653,7 +653,8 @@ public class ProjectHome extends SlugHome<HProject>\n     }\n \n     public void validateSuppliedId() {\n-        HProject ip = getInstance(); // this will raise an EntityNotFound\n+        HProject ip = getInstance();\n+// this will raise an EntityNotFound\n         // exception\n         // when id is invalid and conversation will not\n         // start\n@@ -1339,4 +1340,4 @@ public class ProjectHome extends SlugHome<HProject>\n     public AbstractListFilter<HPerson> getMaintainerFilter() {\n         return this.maintainerFilter;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "628",
                    "column": "38",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/67/ProjectHome.java\nindex 9bb27e6eacb..72cd14095d8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/67/ProjectHome.java\n@@ -21,6 +21,7 @@\n package org.zanata.action;\n \n import static com.google.common.base.Strings.isNullOrEmpty;\n+\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -46,7 +47,6 @@ import org.hibernate.criterion.Restrictions;\n import javax.inject.Inject;\n import javax.inject.Named;\n import javax.validation.constraints.NotNull;\n-\n import org.apache.deltaspike.jpa.api.transaction.Transactional;\n import org.zanata.common.EntityStatus;\n import org.zanata.common.LocaleId;\n@@ -85,19 +85,20 @@ import org.zanata.webtrans.shared.model.ValidationId;\n import org.zanata.webtrans.shared.validation.ValidationFactory;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+\n import static javax.faces.application.FacesMessage.SEVERITY_ERROR;\n import static javax.faces.application.FacesMessage.SEVERITY_INFO;\n import static org.zanata.service.impl.WebhookServiceImpl.getTypesFromString;\n import static org.zanata.model.ProjectRole.Maintainer;\n \n+\n @Named(\"projectHome\")\n @ViewScoped\n @Model\n @Transactional\n public class ProjectHome extends SlugHome<HProject>\n-        implements HasLanguageSettings {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(ProjectHome.class);\n+    implements HasLanguageSettings {\n+    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(ProjectHome.class);\n     private static final long serialVersionUID = 1L;\n \n     // /**\n@@ -166,7 +167,6 @@ public class ProjectHome extends SlugHome<HProject>\n     private Map<LocaleId, Boolean> selectedEnabledLocales = Maps.newHashMap();\n     // Not sure if this is necessary, seems to work ok on selected disabled\n     // locales without this.\n-\n     public Map<LocaleId, Boolean> getSelectedEnabledLocales() {\n         if (selectedEnabledLocales == null) {\n             selectedEnabledLocales = Maps.newHashMap();\n@@ -200,44 +200,34 @@ public class ProjectHome extends SlugHome<HProject>\n      * Populate the list of available locales after filtering out the locales\n      * already in the project.\n      */\n+\n     private List<HLocale> findActiveNotEnabledLocales() {\n         List<HLocale> activeLocales = localeDAO.findAllActive();\n         // only include those not already in the project\n-        List<HLocale> filteredList = activeLocales.stream()\n-                .filter(hLocale -> !getEnabledLocales().contains(hLocale))\n-                .collect(\n-                        Collectors.toList());\n+        List<HLocale> filteredList = activeLocales.stream().filter(hLocale -> !getEnabledLocales().contains(hLocale)).collect(Collectors.toList());\n         Collections.sort(filteredList, ComparatorUtil.LOCALE_COMPARATOR);\n         return filteredList;\n     }\n \n     private Map<String, Boolean> roleRestrictions;\n     @SuppressFBWarnings(\"SE_BAD_FIELD\")\n-    private Map<ValidationId, ValidationAction> availableValidations =\n-            Maps.newHashMap();\n-    private final java.util.concurrent.atomic.AtomicReference<List<HProjectIteration>>\n-            versions = new java.util.concurrent.atomic.AtomicReference<>();\n+    private Map<ValidationId, ValidationAction> availableValidations = Maps.newHashMap();\n+    private final java.util.concurrent.atomic.AtomicReference<List<HProjectIteration>> versions = new java.util.concurrent.atomic.AtomicReference<>();\n     private String selectedProjectType;\n     @Inject\n     private ProjectMaintainersAutocomplete maintainerAutocomplete;\n-    private AbstractListFilter<HPerson> maintainerFilter =\n-            new InMemoryListFilter<HPerson>() {\n-\n-                private static final long serialVersionUID =\n-                        8259700829800303578L;\n-\n-                @Override\n-                protected List<HPerson> fetchAll() {\n-                    return getInstanceMaintainers();\n-                }\n-\n-                @Override\n-                protected boolean include(HPerson elem, String filter) {\n-                    return StringUtils.containsIgnoreCase(elem.getName(),\n-                            filter);\n-                }\n-            };\n-\n+    private AbstractListFilter<HPerson> maintainerFilter = new InMemoryListFilter<HPerson>() {\n+                                                               private static final long serialVersionUID = 8259700829800303578L;\n+                                                               @Override\n+                                                               protected List<HPerson> fetchAll() {\n+                                                                   return getInstanceMaintainers();\n+                                                               }\n+\n+                                                               @Override\n+                                                               protected boolean include(HPerson elem, String filter) {\n+                                                                   return StringUtils.containsIgnoreCase(elem.getName(), filter);\n+                                                               }\n+                                                           };\n     public void createNew() {\n         clearSlugs();\n         HProject instance = getInstance();\n@@ -251,14 +241,14 @@ public class ProjectHome extends SlugHome<HProject>\n \n     @Transactional\n     public void updateSelectedProjectType(ValueChangeEvent e) {\n-        selectedProjectType = (String) e.getNewValue();\n+        selectedProjectType =\n+            (String) e.getNewValue();\n         updateProjectType();\n     }\n \n     @Transactional\n     public void setSelectedProjectType(String selectedProjectType) {\n-        if (!StringUtils.isEmpty(selectedProjectType)\n-                && !selectedProjectType.equals(\"null\")) {\n+        if (!StringUtils.isEmpty(selectedProjectType) && !selectedProjectType.equals(\"null\")) {\n             ProjectType projectType = ProjectType.valueOf(selectedProjectType);\n             getInstance().setDefaultProjectType(projectType);\n         }\n@@ -278,11 +268,11 @@ public class ProjectHome extends SlugHome<HProject>\n      * inherited from global locales. If the project slug is empty, all the\n      * enabled locales for the server are returned.\n      */\n+\n     public List<HLocale> getEnabledLocales() {\n         List<HLocale> locales;\n         if (StringUtils.isNotEmpty(getSlug())) {\n-            locales =\n-                    localeServiceImpl.getSupportedLanguageByProject(getSlug());\n+            locales = localeServiceImpl.getSupportedLanguageByProject(getSlug());\n         } else {\n             locales = localeServiceImpl.getSupportedAndEnabledLocales();\n         }\n@@ -302,6 +292,7 @@ public class ProjectHome extends SlugHome<HProject>\n      * Return the locale alias for the given locale in this project, if it\n      * exists, otherwise null.\n      */\n+\n     public String getLocaleAlias(HLocale locale) {\n         return getLocaleAliases().get(locale.getLocaleId());\n     }\n@@ -309,6 +300,7 @@ public class ProjectHome extends SlugHome<HProject>\n     /**\n      * Return true if the given locale has an alias, otherwise false.\n      */\n+\n     public boolean hasLocaleAlias(HLocale locale) {\n         return getLocaleAliases().containsKey(locale.getLocaleId());\n     }\n@@ -320,6 +312,7 @@ public class ProjectHome extends SlugHome<HProject>\n      * alias (if any) is removed for the given locale, otherwise the alias is\n      * replaced with the value.\n      */\n+\n     @Transactional\n     public void updateToEnteredLocaleAlias(LocaleId localeId) {\n         identity.checkPermission(getInstance(), \"update\");\n@@ -331,15 +324,12 @@ public class ProjectHome extends SlugHome<HProject>\n         boolean hadAlias = setLocaleAliasSilently(localeId, alias);\n         if (isNullOrEmpty(alias)) {\n             if (hadAlias) {\n-                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                        msgs.format(\"jsf.LocaleAlias.AliasRemoved\", localeId));\n+                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.AliasRemoved\", localeId));\n             } else {\n-                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                        .format(\"jsf.LocaleAlias.NoAliasToRemove\", localeId));\n+                facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.NoAliasToRemove\", localeId));\n             }\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.LocaleAlias.AliasSet\", localeId, alias));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.AliasSet\", localeId, alias));\n         }\n     }\n \n@@ -352,6 +342,7 @@ public class ProjectHome extends SlugHome<HProject>\n      *            new alias to use. Use empty string to remove alias.\n      * @return true if there was already an alias, otherwise false.\n      */\n+\n     private boolean setLocaleAliasSilently(LocaleId localeId, String alias) {\n         HProject instance = getInstance();\n         Map<LocaleId, String> aliases = instance.getLocaleAliases();\n@@ -362,8 +353,7 @@ public class ProjectHome extends SlugHome<HProject>\n                 aliases.remove(localeId);\n             }\n         } else {\n-            final boolean sameAlias =\n-                    hadAlias && alias.equals(aliases.get(localeId));\n+            final boolean sameAlias = hadAlias && alias.equals(aliases.get(localeId));\n             if (!sameAlias) {\n                 // no need to ensure overriding locales, aliases are independent\n                 aliases.put(localeId, alias);\n@@ -380,6 +370,7 @@ public class ProjectHome extends SlugHome<HProject>\n      *            that will have its locale alias removed.\n      * @return true if the locale had an alias, otherwise false.\n      */\n+\n     private boolean removeAliasSilently(LocaleId localeId) {\n         return setLocaleAliasSilently(localeId, \"\");\n     }\n@@ -388,8 +379,7 @@ public class ProjectHome extends SlugHome<HProject>\n     public void removeSelectedLocaleAliases() {\n         identity.checkPermission(getInstance(), \"update\");\n         List<LocaleId> removed = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n-                .entrySet()) {\n+        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales().entrySet()) {\n             if (entry.getValue()) {\n                 boolean hadAlias = removeAliasSilently(entry.getKey());\n                 if (hadAlias) {\n@@ -404,8 +394,7 @@ public class ProjectHome extends SlugHome<HProject>\n     public void removeAllLocaleAliases() {\n         identity.checkPermission(getInstance(), \"update\");\n         List<LocaleId> removed = new ArrayList<>();\n-        List<LocaleId> aliasedLocales =\n-                new ArrayList<>(getLocaleAliases().keySet());\n+        List<LocaleId> aliasedLocales = new ArrayList<>(getLocaleAliases().keySet());\n         for (LocaleId aliasedLocale : aliasedLocales) {\n             boolean hadAlias = removeAliasSilently(aliasedLocale);\n             if (hadAlias) {\n@@ -422,17 +411,14 @@ public class ProjectHome extends SlugHome<HProject>\n      * @param removed\n      *            ids of locales that had aliases removed\n      */\n+\n     private void showRemovedAliasesMessage(List<LocaleId> removed) {\n         if (removed.isEmpty()) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.get(\"jsf.LocaleAlias.NoAliasesToRemove\"));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.get(\"jsf.LocaleAlias.NoAliasesToRemove\"));\n         } else if (removed.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                    .format(\"jsf.LocaleAlias.AliasRemoved\", removed.get(0)));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.AliasRemoved\", removed.get(0)));\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.LocaleAlias.AliasesRemoved\",\n-                            StringUtils.join(removed, \", \")));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.LocaleAlias.AliasesRemoved\", StringUtils.join(removed, \", \")));\n         }\n     }\n \n@@ -440,16 +426,14 @@ public class ProjectHome extends SlugHome<HProject>\n     public void disableLocale(HLocale locale) {\n         identity.checkPermission(getInstance(), \"update\");\n         disableLocaleSilently(locale);\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n-                \"jsf.languageSettings.LanguageDisabled\", locale.getLocaleId()));\n+        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguageDisabled\", locale.getLocaleId()));\n     }\n \n     @Transactional\n     public void disableSelectedLocales() {\n         identity.checkPermission(getInstance(), \"update\");\n         List<LocaleId> removedLocales = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales()\n-                .entrySet()) {\n+        for (Map.Entry<LocaleId, Boolean> entry : getSelectedEnabledLocales().entrySet()) {\n             if (entry.getValue()) {\n                 boolean wasEnabled = disableLocaleSilently(entry.getKey());\n                 if (wasEnabled) {\n@@ -461,14 +445,11 @@ public class ProjectHome extends SlugHome<HProject>\n         if (removedLocales.isEmpty()) {\n             // This should not be possible in the UI, but maybe if multiple\n             // users are editing it.\n+\n         } else if (removedLocales.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguageDisabled\",\n-                            removedLocales.get(0)));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguageDisabled\", removedLocales.get(0)));\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguagesDisabled\",\n-                            StringUtils.join(removedLocales, \", \")));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguagesDisabled\", StringUtils.join(removedLocales, \", \")));\n         }\n     }\n \n@@ -484,9 +465,9 @@ public class ProjectHome extends SlugHome<HProject>\n      *            locale that should be disabled.\n      * @return false if the locale was already disabled, true otherwise.\n      */\n+\n     private boolean disableLocaleSilently(HLocale locale) {\n-        final Set<HLocale> customizedLocales =\n-                getInstance().getCustomizedLocales();\n+        final Set<HLocale> customizedLocales = getInstance().getCustomizedLocales();\n         ensureOverridingLocales();\n         boolean localeWasEnabled = customizedLocales.remove(locale);\n         getLocaleAliases().remove(locale.getLocaleId());\n@@ -499,16 +480,14 @@ public class ProjectHome extends SlugHome<HProject>\n         identity.checkPermission(getInstance(), \"update\");\n         enableLocaleSilently(locale);\n         LocaleId localeId = locale.getLocaleId();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.format(\"jsf.languageSettings.LanguageEnabled\", localeId));\n+        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguageEnabled\", localeId));\n     }\n \n     @Transactional\n     public void enableSelectedLocales() {\n         identity.checkPermission(getInstance(), \"update\");\n         List<LocaleId> addedLocales = new ArrayList<>();\n-        for (Map.Entry<LocaleId, Boolean> entry : selectedDisabledLocales\n-                .entrySet()) {\n+        for (Map.Entry<LocaleId, Boolean> entry : selectedDisabledLocales.entrySet()) {\n             if (entry.getValue()) {\n                 boolean wasDisabled = enableLocaleSilently(entry.getKey());\n                 if (wasDisabled) {\n@@ -520,14 +499,11 @@ public class ProjectHome extends SlugHome<HProject>\n         if (addedLocales.isEmpty()) {\n             // This should not be possible in the UI, but maybe if multiple\n             // users are editing it.\n+\n         } else if (addedLocales.size() == 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguageEnabled\",\n-                            addedLocales.get(0)));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguageEnabled\", addedLocales.get(0)));\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.languageSettings.LanguagesEnabled\",\n-                            StringUtils.join(addedLocales, \", \")));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.languageSettings.LanguagesEnabled\", StringUtils.join(addedLocales, \", \")));\n         }\n     }\n \n@@ -543,10 +519,10 @@ public class ProjectHome extends SlugHome<HProject>\n      *            locale that should be enabled.\n      * @return false if the locale was already enabled, true otherwise.\n      */\n+\n     private boolean enableLocaleSilently(HLocale locale) {\n         ensureOverridingLocales();\n-        final boolean localeWasDisabled =\n-                getInstance().getCustomizedLocales().add(locale);\n+        final boolean localeWasDisabled = getInstance().getCustomizedLocales().add(locale);\n         refreshDisabledLocales();\n         return localeWasDisabled;\n     }\n@@ -558,8 +534,7 @@ public class ProjectHome extends SlugHome<HProject>\n         removeAliasesForDisabledLocales();\n         refreshDisabledLocales();\n         update();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.get(\"jsf.project.LanguageUpdateFromGlobal\"));\n+        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.get(\"jsf.project.LanguageUpdateFromGlobal\"));\n     }\n \n     private void removeAliasesForDisabledLocales() {\n@@ -577,6 +552,7 @@ public class ProjectHome extends SlugHome<HProject>\n     /**\n      * Ensure that isOverrideLocales is true, and copy data if necessary.\n      */\n+\n     private void ensureOverridingLocales() {\n         if (!isOverrideLocales()) {\n             startOverridingLocales();\n@@ -587,6 +563,7 @@ public class ProjectHome extends SlugHome<HProject>\n      * Copy locale data from project and set overrideLocales, in preparation for\n      * making customizations to the locales.\n      */\n+\n     private void startOverridingLocales() {\n         // Copied before setOverrideLocales(true) so that the currently returned\n         // values will be used as the basis for any customization.\n@@ -603,6 +580,7 @@ public class ProjectHome extends SlugHome<HProject>\n     /**\n      * Update disabled locales to be consistent with enabled locales.\n      */\n+\n     private void refreshDisabledLocales() {\n         // will be re-generated with correct values next time it is fetched.\n         disabledLocales = null;\n@@ -620,9 +598,7 @@ public class ProjectHome extends SlugHome<HProject>\n         identity.checkPermission(getInstance(), \"update\");\n         getInstance().setPrivateProject(privateProject);\n         update();\n-        String message = privateProject\n-                ? msgs.get(\"jsf.permission.private.Active\")\n-                : msgs.get(\"jsf.permission.private.Inactive\");\n+        String message = privateProject ? msgs.get(\"jsf.permission.private.Active\") : msgs.get(\"jsf.permission.private.Inactive\");\n         facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, message);\n     }\n \n@@ -630,14 +606,12 @@ public class ProjectHome extends SlugHome<HProject>\n     protected HProject loadInstance() {\n         Session session = (Session) getEntityManager().getDelegate();\n         if (projectId == null) {\n-            HProject project = (HProject) session.byNaturalId(HProject.class)\n-                    .using(\"slug\", getSlug()).load();\n+            HProject project = (HProject) session.byNaturalId(HProject.class).using(\"slug\", getSlug()).load();\n             validateProjectState(project);\n             projectId = project.getId();\n             return project;\n         } else {\n-            HProject project =\n-                    (HProject) session.byId(HProject.class).load(projectId);\n+            HProject project = (HProject) session.byId(HProject.class).load(projectId);\n             validateProjectState(project);\n             return project;\n         }\n@@ -645,9 +619,7 @@ public class ProjectHome extends SlugHome<HProject>\n \n     private void validateProjectState(HProject project) {\n         if (project == null || project.getStatus() == EntityStatus.OBSOLETE) {\n-            log.warn(\n-                    \"Project [id={}, slug={}], does not exist or is soft deleted: {}\",\n-                    projectId, getSlug(), project);\n+            log.warn(\"Project [id={}, slug={}], does not exist or is soft deleted: {}\", projectId, getSlug(), project);\n             throw new ProjectNotFoundException(getSlug());\n         }\n     }\n@@ -664,15 +636,12 @@ public class ProjectHome extends SlugHome<HProject>\n \n     @Transactional\n     public void updateCopyTrans(String action, String value) {\n-        copyTransOptionsModel\n-                .setInstance(getInstance().getDefaultCopyTransOpts());\n+        copyTransOptionsModel.setInstance(getInstance().getDefaultCopyTransOpts());\n         copyTransOptionsModel.update(action, value);\n         copyTransOptionsModel.save();\n-        getInstance()\n-                .setDefaultCopyTransOpts(copyTransOptionsModel.getInstance());\n+        getInstance().setDefaultCopyTransOpts(copyTransOptionsModel.getInstance());\n         update();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.get(\"jsf.project.CopyTransOpts.updated\"));\n+        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.get(\"jsf.project.CopyTransOpts.updated\"));\n     }\n     // @Begin(join = true) /* TODO [CDI] commented out begin conversation.\n     // Verify it still works properly */\n@@ -683,16 +652,14 @@ public class ProjectHome extends SlugHome<HProject>\n         }\n         validateSuppliedId();\n         if (getInstance().getDefaultCopyTransOpts() != null) {\n-            copyTransOptionsModel\n-                    .setInstance(getInstance().getDefaultCopyTransOpts());\n+            copyTransOptionsModel.setInstance(getInstance().getDefaultCopyTransOpts());\n         }\n     }\n \n     public void onProjectNameChange(ValueChangeEvent e) {\n         if (!isValidName((String) e.getNewValue())) {\n             String componentId = e.getComponent().getId();\n-            facesMessages.addToControl(componentId,\n-                    msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n+            facesMessages.addToControl(componentId, msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n         }\n     }\n \n@@ -700,6 +667,7 @@ public class ProjectHome extends SlugHome<HProject>\n      * Check the name by removing any whitespaces in the string and\n      * make sure it contains at least an alphanumeric char\n      */\n+\n     public boolean isValidName(String name) {\n         String trimmedName = StringUtils.deleteWhitespace(name);\n         for (char c : trimmedName.toCharArray()) {\n@@ -720,15 +688,13 @@ public class ProjectHome extends SlugHome<HProject>\n             return true;\n         }\n         if (!isSlugAvailable(slug)) {\n-            facesMessages.addToControl(componentId,\n-                    \"This Project ID is not available\");\n+            facesMessages.addToControl(componentId, \"This Project ID is not available\");\n             return false;\n         }\n+\n         boolean valid = new SlugValidator().isValid(slug, null);\n         if (!valid) {\n-            String validationMessages =\n-                    ResourceBundle.getBundle(\"ValidationMessages\").getString(\n-                            \"javax.validation.constraints.Slug.message\");\n+            String validationMessages = ResourceBundle.getBundle(\"ValidationMessages\").getString(\"javax.validation.constraints.Slug.message\");\n             facesMessages.addToControl(componentId, validationMessages);\n             return false;\n         }\n@@ -740,8 +706,7 @@ public class ProjectHome extends SlugHome<HProject>\n     }\n \n     private void updateProjectType() {\n-        if (!StringUtils.isEmpty(selectedProjectType)\n-                && !selectedProjectType.equals(\"null\")) {\n+        if (!StringUtils.isEmpty(selectedProjectType) && !selectedProjectType.equals(\"null\")) {\n             ProjectType projectType = ProjectType.valueOf(selectedProjectType);\n             getInstance().setDefaultProjectType(projectType);\n         }\n@@ -757,19 +722,17 @@ public class ProjectHome extends SlugHome<HProject>\n     public String update() {\n         identity.checkPermission(getInstance(), \"update\");\n         // getInputSlugValue() can be null\n-        if (!getSlug().equals(getInputSlugValue())\n-                && !validateSlug(getInputSlugValue(), \"slug\")) {\n+        if (!getSlug().equals(getInputSlugValue()) && !validateSlug(getInputSlugValue(), \"slug\")) {\n             return null;\n         }\n-        if (getInputSlugValue() != null\n-                && !getSlug().equals(getInputSlugValue())) {\n+        if (getInputSlugValue() != null && !getSlug().equals(getInputSlugValue())) {\n             getInstance().setSlug(getInputSlugValue());\n         }\n         if (!isValidName(getInstance().getName())) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n+            facesMessages.addGlobal(SEVERITY_ERROR, msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n             return null;\n         }\n+\n         boolean softDeleted = false;\n         if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n             softDeleted = true;\n@@ -781,8 +744,7 @@ public class ProjectHome extends SlugHome<HProject>\n             urlUtil.redirectToInternal(url);\n             return result;\n         }\n-        facesMessages.addGlobal(SEVERITY_INFO,\n-                msgs.get(\"jsf.project.settings.updated\"));\n+        facesMessages.addGlobal(SEVERITY_INFO, msgs.get(\"jsf.project.settings.updated\"));\n         if (!getSlug().equals(getInstance().getSlug())) {\n             projectSlug.setValue(getInstance().getSlug());\n             return \"project-slug-updated\";\n@@ -799,41 +761,29 @@ public class ProjectHome extends SlugHome<HProject>\n         }\n         getInstance().setSlug(getInputSlugValue());\n         if (!isValidName(getInstance().getName())) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n+            facesMessages.addGlobal(SEVERITY_ERROR, msgs.get(\"jsf.project.name.validation.alphanumeric\"));\n             return null;\n         }\n-        if (StringUtils.isEmpty(selectedProjectType)\n-                || selectedProjectType.equals(\"null\")) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    \"Project type not selected\");\n+        if (StringUtils.isEmpty(selectedProjectType) || selectedProjectType.equals(\"null\")) {\n+            facesMessages.addGlobal(SEVERITY_ERROR, \"Project type not selected\");\n             return null;\n         }\n-        if (StringUtils.isEmpty(selectedProjectType)\n-                || selectedProjectType.equals(\"null\")) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    \"Project type not selected\");\n+        if (StringUtils.isEmpty(selectedProjectType) || selectedProjectType.equals(\"null\")) {\n+            facesMessages.addGlobal(SEVERITY_ERROR, \"Project type not selected\");\n             return null;\n         }\n         updateProjectType();\n         if (currentUser.isLoggedIn()) {\n             // authenticatedAccount person is a detached entity, so fetch a copy\n             // that is attached to the current session.\n-            HPerson creator = personDAO\n-                    .findById(currentUser.getPerson().getId());\n+            HPerson creator = personDAO.findById(currentUser.getPerson().getId());\n             getInstance().addMaintainer(creator);\n             getInstance().getCustomizedValidations().clear();\n-            for (ValidationAction validationAction : validationServiceImpl\n-                    .getValidationActions(\"\")) {\n-                getInstance().getCustomizedValidations().put(\n-                        validationAction.getId().name(),\n-                        validationAction.getState().name());\n+            for (ValidationAction validationAction : validationServiceImpl.getValidationActions(\"\")) {\n+                getInstance().getCustomizedValidations().put(validationAction.getId().name(), validationAction.getState().name());\n             }\n             retValue = super.persist();\n-            webhookServiceImpl.processWebhookMaintainerChanged(\n-                    getInstance().getSlug(), creator.getAccount().getUsername(),\n-                    Maintainer, getInstance().getWebHooks(),\n-                    ProjectMaintainerChangedEvent.ChangeType.ADD);\n+            webhookServiceImpl.processWebhookMaintainerChanged(getInstance().getSlug(), creator.getAccount().getUsername(), Maintainer, getInstance().getWebHooks(), ProjectMaintainerChangedEvent.ChangeType.ADD);\n         }\n         return retValue;\n     }\n@@ -844,6 +794,7 @@ public class ProjectHome extends SlugHome<HProject>\n      *\n      * @return\n      */\n+\n     public String getAboutHtml() {\n         // we could cache this, but it may not be worth it\n         String text = getInstance().getHomeContent();\n@@ -860,18 +811,13 @@ public class ProjectHome extends SlugHome<HProject>\n     public String removeMaintainer(HPerson person) {\n         identity.checkPermission(getInstance(), \"update\");\n         if (getInstanceMaintainers().size() <= 1) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.get(\"jsf.project.NeedAtLeastOneMaintainer\"));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.get(\"jsf.project.NeedAtLeastOneMaintainer\"));\n         } else {\n             getInstance().removeMaintainer(person);\n             maintainerFilter.reset();\n             update();\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs\n-                    .format(\"jsf.project.MaintainerRemoved\", person.getName()));\n-            webhookServiceImpl.processWebhookMaintainerChanged(getSlug(),\n-                    person.getAccount().getUsername(), Maintainer,\n-                    getInstance().getWebHooks(),\n-                    ProjectMaintainerChangedEvent.ChangeType.REMOVE);\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.project.MaintainerRemoved\", person.getName()));\n+            webhookServiceImpl.processWebhookMaintainerChanged(getSlug(), person.getAccount().getUsername(), Maintainer, getInstance().getWebHooks(), ProjectMaintainerChangedEvent.ChangeType.REMOVE);\n             if (person.equals(currentUser.getPerson())) {\n                 urlUtil.redirectToInternal(urlUtil.projectUrl(getSlug()));\n             }\n@@ -885,17 +831,14 @@ public class ProjectHome extends SlugHome<HProject>\n         getInstance().getAllowedRoles().clear();\n         if (getInstance().isRestrictedByRoles()) {\n             getRoleRestrictions().put(roleName, isRestricted);\n-            for (Map.Entry<String, Boolean> entry : getRoleRestrictions()\n-                    .entrySet()) {\n+            for (Map.Entry<String, Boolean> entry : getRoleRestrictions().entrySet()) {\n                 if (entry.getValue()) {\n-                    getInstance().getAllowedRoles()\n-                            .add(accountRoleDAO.findByName(entry.getKey()));\n+                    getInstance().getAllowedRoles().add(accountRoleDAO.findByName(entry.getKey()));\n                 }\n             }\n         }\n         update();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.get(\"jsf.RolesUpdated\"));\n+        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.get(\"jsf.RolesUpdated\"));\n     }\n \n     @Transactional\n@@ -904,16 +847,14 @@ public class ProjectHome extends SlugHome<HProject>\n         EntityStatus status = EntityStatus.valueOf(initial);\n         getInstance().setStatus(status);\n         if (getInstance().getStatus() == EntityStatus.READONLY) {\n-            for (HProjectIteration version : getInstance()\n-                    .getProjectIterations()) {\n+            for (HProjectIteration version : getInstance().getProjectIterations()) {\n                 if (version.getStatus() == EntityStatus.ACTIVE) {\n                     version.setStatus(EntityStatus.READONLY);\n                     entityManager.merge(version);\n                 }\n             }\n         } else if (getInstance().getStatus() == EntityStatus.OBSOLETE) {\n-            for (HProjectIteration version : getInstance()\n-                    .getProjectIterations()) {\n+            for (HProjectIteration version : getInstance().getProjectIterations()) {\n                 if (version.getStatus() != EntityStatus.OBSOLETE) {\n                     version.setStatus(EntityStatus.OBSOLETE);\n                     entityManager.merge(version);\n@@ -922,11 +863,9 @@ public class ProjectHome extends SlugHome<HProject>\n         }\n         update();\n         if (status.equals(EntityStatus.OBSOLETE)) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.project.notification.deleted\", getSlug()));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.project.notification.deleted\", getSlug()));\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.format(\"jsf.project.status.updated\", status));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.project.status.updated\", status));\n         }\n     }\n \n@@ -958,29 +897,25 @@ public class ProjectHome extends SlugHome<HProject>\n         return allRoles;\n     }\n \n-    private @NotNull List<HProjectIteration> fetchVersions() {\n-        return getInstance()\n-                .getProjectIterations()\n-                .stream()\n-                .filter(it -> it.getStatus() != EntityStatus.OBSOLETE)\n-                .sorted((o1, o2) -> {\n-                    EntityStatus fromStatus = o1.getStatus();\n-                    EntityStatus toStatus = o2.getStatus();\n-                    if (fromStatus.equals(toStatus)) {\n-                        return 0;\n-                    }\n-                    if (fromStatus.equals(EntityStatus.ACTIVE)) {\n-                        return -1;\n-                    }\n-                    if (fromStatus.equals(EntityStatus.READONLY)) {\n-                        if (toStatus.equals(EntityStatus.ACTIVE)) {\n-                            return 1;\n-                        }\n-                        return -1;\n-                    }\n-                    return 0;\n-                })\n-                .collect(Collectors.toList());\n+    private @NotNull\n+    List<HProjectIteration> fetchVersions() {\n+        return getInstance().getProjectIterations().stream().filter(it -> it.getStatus() != EntityStatus.OBSOLETE).sorted((o1, o2) -> {\n+                                                                                                                      EntityStatus fromStatus = o1.getStatus();\n+                                                                                                                      EntityStatus toStatus = o2.getStatus();\n+                                                                                                                      if (fromStatus.equals(toStatus)) {\n+                                                                                                                          return 0;\n+                                                                                                                      }\n+                                                                                                                      if (fromStatus.equals(EntityStatus.ACTIVE)) {\n+                                                                                                                          return -1;\n+                                                                                                                      }\n+                                                                                                                      if (fromStatus.equals(EntityStatus.READONLY)) {\n+                                                                                                                          if (toStatus.equals(EntityStatus.ACTIVE)) {\n+                                                                                                                              return 1;\n+                                                                                                                          }\n+                                                                                                                          return -1;\n+                                                                                                                      }\n+                                                                                                                      return 0;\n+                                                                                                                  }).collect(Collectors.toList());\n     }\n \n     @Override\n@@ -1000,11 +935,9 @@ public class ProjectHome extends SlugHome<HProject>\n \n     private Map<ValidationId, ValidationAction> getValidations() {\n         if (availableValidations.isEmpty()) {\n-            Collection<ValidationAction> validationList = validationServiceImpl\n-                    .getValidationActions(getInstance().getSlug());\n+            Collection<ValidationAction> validationList = validationServiceImpl.getValidationActions(getInstance().getSlug());\n             for (ValidationAction validationAction : validationList) {\n-                availableValidations.put(validationAction.getId(),\n-                        validationAction);\n+                availableValidations.put(validationAction.getId(), validationAction);\n             }\n         }\n         return availableValidations;\n@@ -1014,35 +947,26 @@ public class ProjectHome extends SlugHome<HProject>\n     public void updateValidationOption(String name, String state) {\n         identity.checkPermission(getInstance(), \"update\");\n         ValidationId validationId = ValidationId.valueOf(name);\n-        for (Map.Entry<ValidationId, ValidationAction> entry : getValidations()\n-                .entrySet()) {\n+        for (Map.Entry<ValidationId, ValidationAction> entry : getValidations().entrySet()) {\n             if (entry.getKey().name().equals(name)) {\n-                getValidations().get(validationId)\n-                        .setState(ValidationAction.State.valueOf(state));\n-                getInstance().getCustomizedValidations().put(\n-                        entry.getKey().name(),\n-                        entry.getValue().getState().name());\n+                getValidations().get(validationId).setState(ValidationAction.State.valueOf(state));\n+                getInstance().getCustomizedValidations().put(entry.getKey().name(), entry.getValue().getState().name());\n                 ensureMutualExclusivity(getValidations().get(validationId));\n                 break;\n             }\n         }\n         update();\n-        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                msgs.format(\"jsf.validation.updated\",\n-                        validationId.getDisplayName(), state));\n+        facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.validation.updated\", validationId.getDisplayName(), state));\n     }\n \n     public List<ValidationAction> getValidationList() {\n-        List<ValidationAction> sortedList =\n-                Lists.newArrayList(getValidations().values());\n-        Collections.sort(sortedList,\n-                ValidationFactory.ValidationActionComparator);\n+        List<ValidationAction> sortedList = Lists.newArrayList(getValidations().values());\n+        Collections.sort(sortedList, ValidationFactory.ValidationActionComparator);\n         return sortedList;\n     }\n \n     @Transactional\n-    public void addWebHook(String url, String secret, String strTypes,\n-            String name) {\n+    public void addWebHook(String url, String secret, String strTypes, String name) {\n         identity.checkPermission(getInstance(), \"update\");\n         Set<WebhookType> types = getTypesFromString(strTypes);\n         if (types.isEmpty()) {\n@@ -1053,15 +977,13 @@ public class ProjectHome extends SlugHome<HProject>\n             return;\n         }\n         if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url)) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.format(\"jsf.project.DuplicateUrl\", url));\n+            facesMessages.addGlobal(SEVERITY_ERROR, msgs.format(\"jsf.project.DuplicateUrl\", url));\n             return;\n         }\n-        boolean isAdded = projectServiceImpl.addWebhook(getInstance(), url,\n-                secret, name, types);\n+\n+        boolean isAdded = projectServiceImpl.addWebhook(getInstance(), url, secret, name, types);\n         if (isAdded) {\n-            facesMessages\n-                    .addGlobal(msgs.format(\"jsf.project.AddNewWebhook\", url));\n+            facesMessages.addGlobal(msgs.format(\"jsf.project.AddNewWebhook\", url));\n         }\n     }\n \n@@ -1073,14 +995,12 @@ public class ProjectHome extends SlugHome<HProject>\n             String url = webHook.getUrl();\n             getInstance().getWebHooks().remove(webHook);\n             webHookDAO.makeTransient(webHook);\n-            facesMessages\n-                    .addGlobal(msgs.format(\"jsf.project.RemoveWebhook\", url));\n+            facesMessages.addGlobal(msgs.format(\"jsf.project.RemoveWebhook\", url));\n         }\n     }\n \n     @Transactional\n-    public void updateWebhook(String id, String url, String secret,\n-            String strTypes, String name) {\n+    public void updateWebhook(String id, String url, String secret, String strTypes, String name) {\n         identity.checkPermission(getInstance(), \"update\");\n         Set<WebhookType> types = getTypesFromString(strTypes);\n         if (types.isEmpty()) {\n@@ -1091,41 +1011,36 @@ public class ProjectHome extends SlugHome<HProject>\n             return;\n         }\n         Long webhookId = Long.valueOf(id);\n-        if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url,\n-                webhookId)) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.format(\"jsf.project.DuplicateUrl\", url));\n+        if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url, webhookId)) {\n+            facesMessages.addGlobal(SEVERITY_ERROR, msgs.format(\"jsf.project.DuplicateUrl\", url));\n             return;\n         }\n-        boolean updated = projectServiceImpl.updateWebhook(getInstance(),\n-                webhookId, url, secret, name, types);\n+\n+        boolean updated = projectServiceImpl.updateWebhook(getInstance(), webhookId, url, secret, name, types);\n         if (updated) {\n-            facesMessages\n-                    .addGlobal(msgs.format(\"jsf.project.UpdateWebhook\", url));\n+            facesMessages.addGlobal(msgs.format(\"jsf.project.UpdateWebhook\", url));\n         }\n     }\n \n     public void testWebhook(String url, String secret) {\n         identity.checkPermission(getInstance(), \"update\");\n         if (projectServiceImpl.isDuplicateWebhookUrl(getInstance(), url)) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.format(\"jsf.project.DuplicateUrl\", url));\n+            facesMessages.addGlobal(SEVERITY_ERROR, msgs.format(\"jsf.project.DuplicateUrl\", url));\n             return;\n         }\n         if (!isValidUrl(url)) {\n             return;\n         }\n-        webhookServiceImpl.processTestEvent(identity.getAccountUsername(),\n-                getSlug(), url, secret);\n+        webhookServiceImpl.processTestEvent(identity.getAccountUsername(), getSlug(), url, secret);\n     }\n \n     /**\n      * Check if url is valid and there is no duplication of url+type\n      */\n+\n     private boolean isValidUrl(String url) {\n         if (!webhookServiceImpl.isValidUrl(url)) {\n-            facesMessages.addGlobal(SEVERITY_ERROR,\n-                    msgs.format(\"jsf.project.InvalidUrl\", url));\n+            facesMessages.addGlobal(SEVERITY_ERROR, msgs.format(\"jsf.project.InvalidUrl\", url));\n             return false;\n         }\n         return true;\n@@ -1137,16 +1052,12 @@ public class ProjectHome extends SlugHome<HProject>\n      *\n      * @param selectedValidationAction\n      */\n-    private void\n-            ensureMutualExclusivity(ValidationAction selectedValidationAction) {\n+\n+    private void ensureMutualExclusivity(ValidationAction selectedValidationAction) {\n         if (selectedValidationAction.getState() != ValidationAction.State.Off) {\n-            for (ValidationAction exclusiveValAction : selectedValidationAction\n-                    .getExclusiveValidations()) {\n-                getInstance().getCustomizedValidations().put(\n-                        exclusiveValAction.getId().name(),\n-                        ValidationAction.State.Off.name());\n-                getValidations().get(exclusiveValAction.getId())\n-                        .setState(ValidationAction.State.Off);\n+            for (ValidationAction exclusiveValAction : selectedValidationAction.getExclusiveValidations()) {\n+                getInstance().getCustomizedValidations().put(exclusiveValAction.getId().name(), ValidationAction.State.Off.name());\n+                getValidations().get(exclusiveValAction.getId()).setState(ValidationAction.State.Off);\n             }\n         }\n     }\n@@ -1158,16 +1069,15 @@ public class ProjectHome extends SlugHome<HProject>\n     /**\n      * Update the about page to the entered value, and show a success message.\n      */\n+\n     @Transactional\n     public void updateAboutPage() {\n         identity.checkPermission(getInstance(), \"update\");\n         String status = update();\n         if (\"updated\".equals(status)) {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO,\n-                    msgs.get(\"jsf.project.AboutPageUpdated\"));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.get(\"jsf.project.AboutPageUpdated\"));\n         } else {\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_ERROR,\n-                    msgs.get(\"jsf.project.AboutPageUpdateFailed\"));\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_ERROR, msgs.get(\"jsf.project.AboutPageUpdateFailed\"));\n         }\n     }\n \n@@ -1177,9 +1087,7 @@ public class ProjectHome extends SlugHome<HProject>\n     }\n \n     @ViewScoped\n-    public static class ProjectMaintainersAutocomplete\n-            extends MaintainerAutocomplete {\n-\n+    public static class ProjectMaintainersAutocomplete extends MaintainerAutocomplete {\n         private static final long serialVersionUID = -6765972032876700000L;\n         @Inject\n         private ProjectHome projectHome;\n@@ -1193,15 +1101,13 @@ public class ProjectHome extends SlugHome<HProject>\n         private PersonDAO personDAO;\n         @Inject\n         private FacesMessages facesMessages;\n-\n         private HProject getInstance() {\n             return projectHome.getInstance();\n         }\n \n         @Override\n         protected List<HPerson> getMaintainers() {\n-            List<HPerson> list =\n-                    Lists.newArrayList(getInstance().getMaintainers());\n+            List<HPerson> list = Lists.newArrayList(getInstance().getMaintainers());\n             Collections.sort(list, ComparatorUtil.PERSON_NAME_COMPARATOR);\n             return list;\n         }\n@@ -1209,6 +1115,7 @@ public class ProjectHome extends SlugHome<HProject>\n         /**\n          * Action when an item is selected\n          */\n+\n         @Override\n         @Transactional\n         public void onSelectItemAction() {\n@@ -1221,13 +1128,8 @@ public class ProjectHome extends SlugHome<HProject>\n             projectHome.update();\n             reset();\n             projectHome.getMaintainerFilter().reset();\n-            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\n-                    \"jsf.project.MaintainerAdded\", maintainer.getName()));\n-            webhookServiceImpl.processWebhookMaintainerChanged(\n-                    getInstance().getSlug(),\n-                    maintainer.getAccount().getUsername(), Maintainer,\n-                    getInstance().getWebHooks(),\n-                    ProjectMaintainerChangedEvent.ChangeType.ADD);\n+            facesMessages.addGlobal(FacesMessage.SEVERITY_INFO, msgs.format(\"jsf.project.MaintainerAdded\", maintainer.getName()));\n+            webhookServiceImpl.processWebhookMaintainerChanged(getInstance().getSlug(), maintainer.getAccount().getUsername(), Maintainer, getInstance().getWebHooks(), ProjectMaintainerChangedEvent.ChangeType.ADD);\n         }\n     }\n \n@@ -1244,6 +1146,7 @@ public class ProjectHome extends SlugHome<HProject>\n     /**\n      * This field is set from form input which can differ from original slug\n      */\n+\n     @Nullable\n     public String getInputSlugValue() {\n         return this.inputSlugValue;\n@@ -1252,6 +1155,7 @@ public class ProjectHome extends SlugHome<HProject>\n     /**\n      * This field is set from form input which can differ from original slug\n      */\n+\n     public void setInputSlugValue(@Nullable final String inputSlugValue) {\n         this.inputSlugValue = inputSlugValue;\n     }\n@@ -1286,6 +1190,7 @@ public class ProjectHome extends SlugHome<HProject>\n      * map in every form submission, and so that a value entered in the field\n      * for a row is not automatically updated when a different row is submitted.\n      */\n+\n     public Map<LocaleId, String> getEnteredLocaleAliases() {\n         return this.enteredLocaleAliases;\n     }\n@@ -1296,13 +1201,12 @@ public class ProjectHome extends SlugHome<HProject>\n      * map in every form submission, and so that a value entered in the field\n      * for a row is not automatically updated when a different row is submitted.\n      */\n-    public void setEnteredLocaleAliases(\n-            final Map<LocaleId, String> enteredLocaleAliases) {\n+\n+    public void setEnteredLocaleAliases(final Map<LocaleId, String> enteredLocaleAliases) {\n         this.enteredLocaleAliases = enteredLocaleAliases;\n     }\n \n-    public void setSelectedEnabledLocales(\n-            final Map<LocaleId, Boolean> selectedEnabledLocales) {\n+    public void setSelectedEnabledLocales(final Map<LocaleId, Boolean> selectedEnabledLocales) {\n         this.selectedEnabledLocales = selectedEnabledLocales;\n     }\n \n@@ -1310,8 +1214,7 @@ public class ProjectHome extends SlugHome<HProject>\n         return this.selectedDisabledLocales;\n     }\n \n-    public void setSelectedDisabledLocales(\n-            final Map<LocaleId, Boolean> selectedDisabledLocales) {\n+    public void setSelectedDisabledLocales(final Map<LocaleId, Boolean> selectedDisabledLocales) {\n         this.selectedDisabledLocales = selectedDisabledLocales;\n     }\n \n@@ -1339,4 +1242,4 @@ public class ProjectHome extends SlugHome<HProject>\n     public AbstractListFilter<HPerson> getMaintainerFilter() {\n         return this.maintainerFilter;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 288
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/67/ProjectHome.java\nindex 9bb27e6eacb..59ecb54913e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/67/ProjectHome.java\n@@ -653,8 +653,9 @@ public class ProjectHome extends SlugHome<HProject>\n     }\n \n     public void validateSuppliedId() {\n-        HProject ip = getInstance(); // this will raise an EntityNotFound\n-        // exception\n+        HProject ip = getInstance();\n+        // this will raise an EntityNotFound\n+         // exception\n         // when id is invalid and conversation will not\n         // start\n         if (ip.getStatus().equals(EntityStatus.OBSOLETE)) {\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/67/ProjectHome.java\nindex 9bb27e6eacb..59ecb54913e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/67/ProjectHome.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/67/ProjectHome.java\n@@ -653,8 +653,9 @@ public class ProjectHome extends SlugHome<HProject>\n     }\n \n     public void validateSuppliedId() {\n-        HProject ip = getInstance(); // this will raise an EntityNotFound\n-        // exception\n+        HProject ip = getInstance();\n+        // this will raise an EntityNotFound\n+         // exception\n         // when id is invalid and conversation will not\n         // start\n         if (ip.getStatus().equals(EntityStatus.OBSOLETE)) {\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}