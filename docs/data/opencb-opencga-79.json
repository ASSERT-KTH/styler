{
    "project_name": "opencb-opencga",
    "error_id": "79",
    "information": {
        "errors": [
            {
                "line": "462",
                "column": "65",
                "severity": "error",
                "message": "';' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "                    String regex = genotype.toString()\n                            .replace(\".\", \"\\\\.\")\n                            .replace(\"2\", \"([2-9]|[0-9][0-9])\");// Replace allele \"2\" with \"any number >= 2\")\n                    Pattern pattern = Pattern.compile(regex);\n                    for (String loadedGenotype : loadedGenotypes) {\n                        if (pattern.matcher(loadedGenotype).matches()) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/79/VariantQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/79/VariantQueryParser.java\nindex a96f14136c9..4446a00ebfa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/79/VariantQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/79/VariantQueryParser.java\n@@ -459,7 +459,7 @@ public class VariantQueryParser {\n                 if (multiallelic) {\n                     String regex = genotype.toString()\n                             .replace(\".\", \"\\\\.\")\n-                            .replace(\"2\", \"([2-9]|[0-9][0-9])\");// Replace allele \"2\" with \"any number >= 2\")\n+                            .replace(\"2\", \"([2-9]|[0-9][0-9])\"); // Replace allele \"2\" with \"any number >= 2\")\n                     Pattern pattern = Pattern.compile(regex);\n                     for (String loadedGenotype : loadedGenotypes) {\n                         if (pattern.matcher(loadedGenotype).matches()) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "462",
                    "column": "51",
                    "severity": "error",
                    "message": "';' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/79/VariantQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/79/VariantQueryParser.java\nindex a96f14136c9..f4c0fd286a8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/79/VariantQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/79/VariantQueryParser.java\n@@ -37,549 +37,549 @@ import static org.opencb.opencga.storage.core.variant.adaptors.VariantQueryUtils\n  */\n public class VariantQueryParser {\n \n-    public static final String SAMPLE_ID = \"SAMPLE_ID\";\n-    public static final String FILE_IDX = \"FILE_IDX\";\n-    public static final String FILE_ID = \"FILE_ID\";\n+  public static final String SAMPLE_ID = \"SAMPLE_ID\";\n+  public static final String FILE_IDX = \"FILE_IDX\";\n+  public static final String FILE_ID = \"FILE_ID\";\n \n-    protected final CellBaseUtils cellBaseUtils;\n-    protected final VariantStorageMetadataManager metadataManager;\n+  protected final CellBaseUtils cellBaseUtils;\n+  protected final VariantStorageMetadataManager metadataManager;\n \n-    public VariantQueryParser(CellBaseUtils cellBaseUtils, VariantStorageMetadataManager metadataManager) {\n-        this.cellBaseUtils = cellBaseUtils;\n-        this.metadataManager = metadataManager;\n-    }\n+  public VariantQueryParser(CellBaseUtils cellBaseUtils, VariantStorageMetadataManager metadataManager) {\n+    this.cellBaseUtils = cellBaseUtils;\n+    this.metadataManager = metadataManager;\n+  }\n \n-    //    public VariantQuery parseQuery(Query query, QueryOptions options) throws StorageEngineException {};\n+  //    public VariantQuery parseQuery(Query query, QueryOptions options) throws StorageEngineException {};\n \n-    public Query preProcessQuery(Query originalQuery, QueryOptions options) {\n-        // Copy input query! Do not modify original query!\n-        Query query = originalQuery == null ? new Query() : new Query(originalQuery);\n+  public Query preProcessQuery(Query originalQuery, QueryOptions options) {\n+    // Copy input query! Do not modify original query!\n+    Query query = originalQuery == null ? new Query() : new Query(originalQuery);\n \n-        preProcessAnnotationParams(query);\n+    preProcessAnnotationParams(query);\n \n-        preProcessStudyParams(options, query);\n+    preProcessStudyParams(options, query);\n \n-        return query;\n-    }\n+    return query;\n+  }\n \n-    protected void preProcessAnnotationParams(Query query) {\n-        convertGoToGeneQuery(query, cellBaseUtils);\n-        convertExpressionToGeneQuery(query, cellBaseUtils);\n+  protected void preProcessAnnotationParams(Query query) {\n+    convertGoToGeneQuery(query, cellBaseUtils);\n+    convertExpressionToGeneQuery(query, cellBaseUtils);\n \n-        VariantQueryXref xrefs = parseXrefs(query);\n-        List<String> allIds = new ArrayList<>(xrefs.getIds().size() + xrefs.getVariants().size());\n-        allIds.addAll(xrefs.getIds());\n-        for (Variant variant : xrefs.getVariants()) {\n-            allIds.add(variant.toString());\n+    VariantQueryXref xrefs = parseXrefs(query);\n+    List<String> allIds = new ArrayList<>(xrefs.getIds().size() + xrefs.getVariants().size());\n+    allIds.addAll(xrefs.getIds());\n+    for (Variant variant : xrefs.getVariants()) {\n+      allIds.add(variant.toString());\n+    }\n+    query.put(ID.key(), allIds);\n+    query.put(GENE.key(), xrefs.getGenes());\n+    query.put(ANNOT_XREF.key(), xrefs.getOtherXrefs());\n+    query.remove(ANNOT_CLINVAR.key());\n+    query.remove(ANNOT_COSMIC.key());\n+\n+    if (VariantQueryUtils.isValidParam(query, TYPE)) {\n+      Set<String> types = new HashSet<>();\n+      if (query.getString(TYPE.key()).contains(NOT)) {\n+        // Invert negations\n+        for (VariantType value : VariantType.values()) {\n+          types.add(value.name());\n         }\n-        query.put(ID.key(), allIds);\n-        query.put(GENE.key(), xrefs.getGenes());\n-        query.put(ANNOT_XREF.key(), xrefs.getOtherXrefs());\n-        query.remove(ANNOT_CLINVAR.key());\n-        query.remove(ANNOT_COSMIC.key());\n-\n-        if (VariantQueryUtils.isValidParam(query, TYPE)) {\n-            Set<String> types = new HashSet<>();\n-            if (query.getString(TYPE.key()).contains(NOT)) {\n-                // Invert negations\n-                for (VariantType value : VariantType.values()) {\n-                    types.add(value.name());\n-                }\n-                for (String type : query.getAsStringList(TYPE.key())) {\n-                    if (isNegated(type)) {\n-                        type = removeNegation(type);\n-                    } else {\n-                        throw VariantQueryException.malformedParam(TYPE, \"Can not mix negated and no negated values\");\n-                    }\n-                    // Expand types to subtypes\n-                    type = type.toUpperCase();\n-                    Set<VariantType> subTypes = Variant.subTypes(VariantType.valueOf(type));\n-                    types.remove(type);\n-                    subTypes.forEach(subType -> types.remove(subType.toString()));\n-                }\n-            } else {\n-                // Expand types to subtypes\n-                for (String type : query.getAsStringList(TYPE.key())) {\n-                    type = type.toUpperCase();\n-                    Set<VariantType> subTypes = Variant.subTypes(VariantType.valueOf(type));\n-                    types.add(type);\n-                    subTypes.forEach(subType -> types.add(subType.toString()));\n-                }\n-            }\n-            query.put(TYPE.key(), new ArrayList<>(types));\n+        for (String type : query.getAsStringList(TYPE.key())) {\n+          if (isNegated(type)) {\n+            type = removeNegation(type);\n+          } else {\n+            throw VariantQueryException.malformedParam(TYPE, \"Can not mix negated and no negated values\");\n+          }\n+          // Expand types to subtypes\n+          type = type.toUpperCase();\n+          Set<VariantType> subTypes = Variant.subTypes(VariantType.valueOf(type));\n+          types.remove(type);\n+          subTypes.forEach(subType -> types.remove(subType.toString()));\n         }\n-\n-        if (VariantQueryUtils.isValidParam(query, ANNOT_CLINICAL_SIGNIFICANCE)) {\n-            String v = query.getString(ANNOT_CLINICAL_SIGNIFICANCE.key());\n-            QueryOperation operator = VariantQueryUtils.checkOperator(v);\n-            List<String> values = VariantQueryUtils.splitValue(v, operator);\n-            List<String> clinicalSignificanceList = new ArrayList<>(values.size());\n-            for (String clinicalSignificance : values) {\n-                ClinicalSignificance enumValue = EnumUtils.getEnum(ClinicalSignificance.class, clinicalSignificance);\n-                if (enumValue == null) {\n-                    String key = clinicalSignificance.toLowerCase().replace(' ', '_');\n-                    enumValue = EnumUtils.getEnum(ClinicalSignificance.class, key);\n-                }\n-                if (enumValue == null) {\n-                    String key = clinicalSignificance.toLowerCase();\n-                    if (VariantAnnotationUtils.CLINVAR_CLINSIG_TO_ACMG.containsKey(key)) {\n-                        // No value set\n-                        enumValue = VariantAnnotationUtils.CLINVAR_CLINSIG_TO_ACMG.get(key);\n-                    }\n-                }\n-                if (enumValue != null) {\n-                    clinicalSignificance = enumValue.toString();\n-                } // else should throw exception?\n-\n-                clinicalSignificanceList.add(clinicalSignificance);\n-            }\n-            query.put(ANNOT_CLINICAL_SIGNIFICANCE.key(), clinicalSignificanceList);\n+      } else {\n+        // Expand types to subtypes\n+        for (String type : query.getAsStringList(TYPE.key())) {\n+          type = type.toUpperCase();\n+          Set<VariantType> subTypes = Variant.subTypes(VariantType.valueOf(type));\n+          types.add(type);\n+          subTypes.forEach(subType -> types.add(subType.toString()));\n         }\n+      }\n+      query.put(TYPE.key(), new ArrayList<>(types));\n+    }\n \n-        if (isValidParam(query, ANNOT_SIFT)) {\n-            String sift = query.getString(ANNOT_SIFT.key());\n-            String[] split = splitOperator(sift);\n-            if (StringUtils.isNotEmpty(split[0])) {\n-                throw VariantQueryException.malformedParam(ANNOT_SIFT, sift);\n-            }\n-            if (isValidParam(query, ANNOT_PROTEIN_SUBSTITUTION)) {\n-                String proteinSubstitution = query.getString(ANNOT_PROTEIN_SUBSTITUTION.key());\n-                if (proteinSubstitution.contains(\"sift\")) {\n-                    throw VariantQueryException.malformedParam(ANNOT_SIFT,\n-                            \"Conflict with parameter \\\"\" + ANNOT_PROTEIN_SUBSTITUTION.key() + \"\\\"\");\n-                }\n-                query.put(ANNOT_PROTEIN_SUBSTITUTION.key(), proteinSubstitution + AND + \"sift\" + split[1] + split[2]);\n-            } else {\n-                query.put(ANNOT_PROTEIN_SUBSTITUTION.key(), \"sift\" + split[1] + split[2]);\n-            }\n-            query.remove(ANNOT_SIFT.key());\n+    if (VariantQueryUtils.isValidParam(query, ANNOT_CLINICAL_SIGNIFICANCE)) {\n+      String v = query.getString(ANNOT_CLINICAL_SIGNIFICANCE.key());\n+      QueryOperation operator = VariantQueryUtils.checkOperator(v);\n+      List<String> values = VariantQueryUtils.splitValue(v, operator);\n+      List<String> clinicalSignificanceList = new ArrayList<>(values.size());\n+      for (String clinicalSignificance : values) {\n+        ClinicalSignificance enumValue = EnumUtils.getEnum(ClinicalSignificance.class, clinicalSignificance);\n+        if (enumValue == null) {\n+          String key = clinicalSignificance.toLowerCase().replace(' ', '_');\n+          enumValue = EnumUtils.getEnum(ClinicalSignificance.class, key);\n         }\n-\n-        if (isValidParam(query, ANNOT_POLYPHEN)) {\n-            String polyphen = query.getString(ANNOT_POLYPHEN.key());\n-            String[] split = splitOperator(polyphen);\n-            if (StringUtils.isNotEmpty(split[0])) {\n-                throw VariantQueryException.malformedParam(ANNOT_POLYPHEN, polyphen);\n-            }\n-            if (isValidParam(query, ANNOT_PROTEIN_SUBSTITUTION)) {\n-                String proteinSubstitution = query.getString(ANNOT_PROTEIN_SUBSTITUTION.key());\n-                if (proteinSubstitution.contains(\"sift\")) {\n-                    throw VariantQueryException.malformedParam(ANNOT_SIFT,\n-                            \"Conflict with parameter \\\"\" + ANNOT_PROTEIN_SUBSTITUTION.key() + \"\\\"\");\n-                }\n-                query.put(ANNOT_PROTEIN_SUBSTITUTION.key(), proteinSubstitution + AND + \"polyphen\" + split[1] + split[2]);\n-            } else {\n-                query.put(ANNOT_PROTEIN_SUBSTITUTION.key(), \"polyphen\" + split[1] + split[2]);\n-            }\n-            query.remove(ANNOT_POLYPHEN.key());\n+        if (enumValue == null) {\n+          String key = clinicalSignificance.toLowerCase();\n+          if (VariantAnnotationUtils.CLINVAR_CLINSIG_TO_ACMG.containsKey(key)) {\n+            // No value set\n+            enumValue = VariantAnnotationUtils.CLINVAR_CLINSIG_TO_ACMG.get(key);\n+          }\n         }\n+        if (enumValue != null) {\n+          clinicalSignificance = enumValue.toString();\n+        } // else should throw exception?\n \n-        if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE)) {\n-            Pair<QueryOperation, List<String>> pair = VariantQueryUtils.splitValue(query.getString(ANNOT_CONSEQUENCE_TYPE.key()));\n-            QueryOperation op = pair.getLeft();\n-            List<String> cts = pair.getRight();\n-            List<String> parsedCts = parseConsequenceTypes(cts);\n-            query.put(ANNOT_CONSEQUENCE_TYPE.key(), op == null ? parsedCts : String.join(op.separator(), parsedCts));\n-        }\n+        clinicalSignificanceList.add(clinicalSignificance);\n+      }\n+      query.put(ANNOT_CLINICAL_SIGNIFICANCE.key(), clinicalSignificanceList);\n     }\n \n-    protected void preProcessStudyParams(QueryOptions options, Query query) {\n-        StudyMetadata defaultStudy = getDefaultStudy(query, options, metadataManager);\n-        QueryOperation formatOperator = null;\n-        if (isValidParam(query, FORMAT)) {\n-            extractGenotypeFromFormatFilter(query);\n-\n-            Pair<QueryOperation, Map<String, String>> pair = parseFormat(query);\n-            formatOperator = pair.getKey();\n-\n-            for (Map.Entry<String, String> entry : pair.getValue().entrySet()) {\n-                String sampleName = entry.getKey();\n-                if (defaultStudy == null) {\n-                    throw VariantQueryException.missingStudyForSample(sampleName, metadataManager.getStudyNames());\n-                }\n-                Integer sampleId = metadataManager.getSampleId(defaultStudy.getId(), sampleName, true);\n-                if (sampleId == null) {\n-                    throw VariantQueryException.sampleNotFound(sampleName, defaultStudy.getName());\n-                }\n-                List<String> formats = splitValue(entry.getValue()).getValue();\n-                for (String format : formats) {\n-                    String[] split = splitOperator(format);\n-                    VariantFileHeaderComplexLine line = defaultStudy.getVariantHeaderLine(\"FORMAT\", split[0]);\n-                    if (line == null) {\n-                        throw VariantQueryException.malformedParam(FORMAT, query.getString(FORMAT.key()),\n-                                \"FORMAT field \\\"\" + split[0] + \"\\\" not found. Available keys in study: \"\n-                                        + defaultStudy.getVariantHeaderLines(\"FORMAT\").keySet());\n-                    }\n-                }\n-            }\n+    if (isValidParam(query, ANNOT_SIFT)) {\n+      String sift = query.getString(ANNOT_SIFT.key());\n+      String[] split = splitOperator(sift);\n+      if (StringUtils.isNotEmpty(split[0])) {\n+        throw VariantQueryException.malformedParam(ANNOT_SIFT, sift);\n+      }\n+      if (isValidParam(query, ANNOT_PROTEIN_SUBSTITUTION)) {\n+        String proteinSubstitution = query.getString(ANNOT_PROTEIN_SUBSTITUTION.key());\n+        if (proteinSubstitution.contains(\"sift\")) {\n+          throw VariantQueryException.malformedParam(ANNOT_SIFT,\n+              \"Conflict with parameter \\\"\" + ANNOT_PROTEIN_SUBSTITUTION.key() + \"\\\"\");\n         }\n+        query.put(ANNOT_PROTEIN_SUBSTITUTION.key(), proteinSubstitution + AND + \"sift\" + split[1] + split[2]);\n+      } else {\n+        query.put(ANNOT_PROTEIN_SUBSTITUTION.key(), \"sift\" + split[1] + split[2]);\n+      }\n+      query.remove(ANNOT_SIFT.key());\n+    }\n \n-        if (isValidParam(query, INFO)) {\n-            Pair<QueryOperation, Map<String, String>> pair = parseInfo(query);\n-            if (isValidParam(query, FILE) && pair.getKey() != null) {\n-                QueryOperation fileOperator = checkOperator(query.getString(FILE.key()));\n-                if (fileOperator != null && pair.getKey() != fileOperator) {\n-                    throw VariantQueryException.mixedAndOrOperators(FILE, INFO);\n-                }\n-            }\n-            for (Map.Entry<String, String> entry : pair.getValue().entrySet()) {\n-                String fileName = entry.getKey();\n-                if (defaultStudy == null) {\n-                    throw VariantQueryException.missingStudyForFile(fileName, metadataManager.getStudyNames());\n-                }\n-                Integer fileId = metadataManager.getFileId(defaultStudy.getId(), fileName, true);\n-                if (fileId == null) {\n-                    throw VariantQueryException.fileNotFound(fileName, defaultStudy.getName());\n-                }\n-                List<String> infos = splitValue(entry.getValue()).getValue();\n-                for (String info : infos) {\n-                    String[] split = splitOperator(info);\n-                    VariantFileHeaderComplexLine line = defaultStudy.getVariantHeaderLine(\"INFO\", split[0]);\n-                    if (line == null) {\n-                        throw VariantQueryException.malformedParam(INFO, query.getString(INFO.key()),\n-                                \"INFO field \\\"\" + split[0] + \"\\\" not found. Available keys in study: \"\n-                                        + defaultStudy.getVariantHeaderLines(\"INFO\").keySet());\n-                    }\n-                }\n-            }\n+    if (isValidParam(query, ANNOT_POLYPHEN)) {\n+      String polyphen = query.getString(ANNOT_POLYPHEN.key());\n+      String[] split = splitOperator(polyphen);\n+      if (StringUtils.isNotEmpty(split[0])) {\n+        throw VariantQueryException.malformedParam(ANNOT_POLYPHEN, polyphen);\n+      }\n+      if (isValidParam(query, ANNOT_PROTEIN_SUBSTITUTION)) {\n+        String proteinSubstitution = query.getString(ANNOT_PROTEIN_SUBSTITUTION.key());\n+        if (proteinSubstitution.contains(\"sift\")) {\n+          throw VariantQueryException.malformedParam(ANNOT_SIFT,\n+              \"Conflict with parameter \\\"\" + ANNOT_PROTEIN_SUBSTITUTION.key() + \"\\\"\");\n         }\n+        query.put(ANNOT_PROTEIN_SUBSTITUTION.key(), proteinSubstitution + AND + \"polyphen\" + split[1] + split[2]);\n+      } else {\n+        query.put(ANNOT_PROTEIN_SUBSTITUTION.key(), \"polyphen\" + split[1] + split[2]);\n+      }\n+      query.remove(ANNOT_POLYPHEN.key());\n+    }\n \n-        QueryOperation genotypeOperator = null;\n-        VariantQueryParam genotypeParam = null;\n-        if (isValidParam(query, SAMPLE)) {\n-            if (isValidParam(query, GENOTYPE)) {\n-                throw VariantQueryException.malformedParam(SAMPLE, query.getString(SAMPLE.key()),\n-                        \"Can not be used along with filter \\\"\" + GENOTYPE.key() + '\"');\n-            }\n-            genotypeParam = SAMPLE;\n-\n-            if (defaultStudy == null) {\n-                throw VariantQueryException.missingStudyForSamples(query.getAsStringList(SAMPLE.key()),\n-                        metadataManager.getStudyNames());\n-            }\n-            List<String> loadedGenotypes = defaultStudy.getAttributes().getAsStringList(LOADED_GENOTYPES.key());\n-            if (CollectionUtils.isEmpty(loadedGenotypes)) {\n-                loadedGenotypes = Arrays.asList(\n-                        \"0/0\", \"0|0\",\n-                        \"0/1\", \"1/0\", \"1/1\", \"./.\",\n-                        \"0|1\", \"1|0\", \"1|1\", \".|.\",\n-                        \"0|2\", \"2|0\", \"2|1\", \"1|2\", \"2|2\",\n-                        \"0/2\", \"2/0\", \"2/1\", \"1/2\", \"2/2\",\n-                        GenotypeClass.UNKNOWN_GENOTYPE);\n-            }\n-            String genotypes;\n-            if (loadedGenotypes.contains(GenotypeClass.NA_GT_VALUE)\n-                    || defaultStudy.getAttributes().getBoolean(EXCLUDE_GENOTYPES.key(), EXCLUDE_GENOTYPES.defaultValue())) {\n-                genotypes = GenotypeClass.NA_GT_VALUE;\n-            } else {\n-                genotypes = String.join(\",\", GenotypeClass.MAIN_ALT.filter(loadedGenotypes));\n-            }\n-\n-            Pair<QueryOperation, List<String>> pair = VariantQueryUtils.splitValue(query.getString(SAMPLE.key()));\n-            genotypeOperator = pair.getLeft();\n+    if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE)) {\n+      Pair<QueryOperation, List<String>> pair = VariantQueryUtils.splitValue(query.getString(ANNOT_CONSEQUENCE_TYPE.key()));\n+      QueryOperation op = pair.getLeft();\n+      List<String> cts = pair.getRight();\n+      List<String> parsedCts = parseConsequenceTypes(cts);\n+      query.put(ANNOT_CONSEQUENCE_TYPE.key(), op == null ? parsedCts : String.join(op.separator(), parsedCts));\n+    }\n+  }\n \n-            StringBuilder sb = new StringBuilder();\n-            for (String sample : pair.getValue()) {\n-                if (sb.length() > 0) {\n-                    sb.append(genotypeOperator.separator());\n-                }\n-                sb.append(sample).append(IS).append(genotypes);\n-            }\n-            query.remove(SAMPLE.key());\n-            query.put(GENOTYPE.key(), sb.toString());\n-        } else if (isValidParam(query, GENOTYPE)) {\n-            genotypeParam = GENOTYPE;\n-\n-            List<String> loadedGenotypes = defaultStudy.getAttributes().getAsStringList(LOADED_GENOTYPES.key());\n-            if (CollectionUtils.isEmpty(loadedGenotypes)) {\n-                loadedGenotypes = Arrays.asList(\n-                        \"0/0\", \"0|0\",\n-                        \"0/1\", \"1/0\", \"1/1\", \"./.\",\n-                        \"0|1\", \"1|0\", \"1|1\", \".|.\",\n-                        \"0|2\", \"2|0\", \"2|1\", \"1|2\", \"2|2\",\n-                        \"0/2\", \"2/0\", \"2/1\", \"1/2\", \"2/2\",\n-                        GenotypeClass.UNKNOWN_GENOTYPE);\n-            }\n+  protected void preProcessStudyParams(QueryOptions options, Query query) {\n+    StudyMetadata defaultStudy = getDefaultStudy(query, options, metadataManager);\n+    QueryOperation formatOperator = null;\n+    if (isValidParam(query, FORMAT)) {\n+      extractGenotypeFromFormatFilter(query);\n \n-            Map<Object, List<String>> map = new LinkedHashMap<>();\n-            genotypeOperator = VariantQueryUtils.parseGenotypeFilter(query.getString(GENOTYPE.key()), map);\n+      Pair<QueryOperation, Map<String, String>> pair = parseFormat(query);\n+      formatOperator = pair.getKey();\n \n-            String filter = preProcessGenotypesFilter(map, genotypeOperator, loadedGenotypes);\n-            query.put(GENOTYPE.key(), filter);\n+      for (Map.Entry<String, String> entry : pair.getValue().entrySet()) {\n+        String sampleName = entry.getKey();\n+        if (defaultStudy == null) {\n+          throw VariantQueryException.missingStudyForSample(sampleName, metadataManager.getStudyNames());\n+        }\n+        Integer sampleId = metadataManager.getSampleId(defaultStudy.getId(), sampleName, true);\n+        if (sampleId == null) {\n+          throw VariantQueryException.sampleNotFound(sampleName, defaultStudy.getName());\n         }\n+        List<String> formats = splitValue(entry.getValue()).getValue();\n+        for (String format : formats) {\n+          String[] split = splitOperator(format);\n+          VariantFileHeaderComplexLine line = defaultStudy.getVariantHeaderLine(\"FORMAT\", split[0]);\n+          if (line == null) {\n+            throw VariantQueryException.malformedParam(FORMAT, query.getString(FORMAT.key()),\n+                \"FORMAT field \\\"\" + split[0] + \"\\\" not found. Available keys in study: \"\n+                    + defaultStudy.getVariantHeaderLines(\"FORMAT\").keySet());\n+          }\n+        }\n+      }\n+    }\n \n-        if (formatOperator != null && genotypeOperator != null && formatOperator != genotypeOperator) {\n-            throw VariantQueryException.mixedAndOrOperators(FORMAT, genotypeParam);\n+    if (isValidParam(query, INFO)) {\n+      Pair<QueryOperation, Map<String, String>> pair = parseInfo(query);\n+      if (isValidParam(query, FILE) && pair.getKey() != null) {\n+        QueryOperation fileOperator = checkOperator(query.getString(FILE.key()));\n+        if (fileOperator != null && pair.getKey() != fileOperator) {\n+          throw VariantQueryException.mixedAndOrOperators(FILE, INFO);\n+        }\n+      }\n+      for (Map.Entry<String, String> entry : pair.getValue().entrySet()) {\n+        String fileName = entry.getKey();\n+        if (defaultStudy == null) {\n+          throw VariantQueryException.missingStudyForFile(fileName, metadataManager.getStudyNames());\n+        }\n+        Integer fileId = metadataManager.getFileId(defaultStudy.getId(), fileName, true);\n+        if (fileId == null) {\n+          throw VariantQueryException.fileNotFound(fileName, defaultStudy.getName());\n+        }\n+        List<String> infos = splitValue(entry.getValue()).getValue();\n+        for (String info : infos) {\n+          String[] split = splitOperator(info);\n+          VariantFileHeaderComplexLine line = defaultStudy.getVariantHeaderLine(\"INFO\", split[0]);\n+          if (line == null) {\n+            throw VariantQueryException.malformedParam(INFO, query.getString(INFO.key()),\n+                \"INFO field \\\"\" + split[0] + \"\\\" not found. Available keys in study: \"\n+                    + defaultStudy.getVariantHeaderLines(\"INFO\").keySet());\n+          }\n         }\n+      }\n+    }\n \n-        if (isValidParam(query, SAMPLE_MENDELIAN_ERROR) || isValidParam(query, SAMPLE_DE_NOVO)) {\n-            QueryParam param;\n-            if (isValidParam(query, SAMPLE_MENDELIAN_ERROR) && isValidParam(query, SAMPLE_DE_NOVO)) {\n-                throw VariantQueryException.unsupportedParamsCombination(\n-                        SAMPLE_MENDELIAN_ERROR, query.getString(SAMPLE_MENDELIAN_ERROR.key()),\n-                        SAMPLE_DE_NOVO, query.getString(SAMPLE_DE_NOVO.key()));\n-            } else if (isValidParam(query, SAMPLE_MENDELIAN_ERROR)) {\n-                param = SAMPLE_MENDELIAN_ERROR;\n-            } else {\n-                param = SAMPLE_DE_NOVO;\n-            }\n-            if (defaultStudy == null) {\n-                throw VariantQueryException.missingStudyForSamples(query.getAsStringList(param.key()),\n-                        metadataManager.getStudyNames());\n-            }\n-            // Check no other samples filter is being used, and all samples are precomputed\n-            if (genotypeParam != null) {\n-                throw VariantQueryException.unsupportedParamsCombination(\n-                        param, query.getString(param.key()),\n-                        genotypeParam, query.getString(genotypeParam.key())\n-                );\n-            }\n-            for (String sample : query.getAsStringList(param.key())) {\n-                Integer sampleId = metadataManager.getSampleId(defaultStudy.getId(), sample);\n-                if (sampleId == null) {\n-                    throw VariantQueryException.sampleNotFound(sample, defaultStudy.getName());\n-                }\n-                SampleMetadata sampleMetadata = metadataManager.getSampleMetadata(defaultStudy.getId(), sampleId);\n-                if (!TaskMetadata.Status.READY.equals(sampleMetadata.getMendelianErrorStatus())) {\n-                    throw VariantQueryException.malformedParam(param, \"Sample \\\"\" + sampleMetadata.getName()\n-                            + \"\\\" does not have the Mendelian Errors precomputed yet\");\n-                }\n-            }\n+    QueryOperation genotypeOperator = null;\n+    VariantQueryParam genotypeParam = null;\n+    if (isValidParam(query, SAMPLE)) {\n+      if (isValidParam(query, GENOTYPE)) {\n+        throw VariantQueryException.malformedParam(SAMPLE, query.getString(SAMPLE.key()),\n+            \"Can not be used along with filter \\\"\" + GENOTYPE.key() + '\"');\n+      }\n+      genotypeParam = SAMPLE;\n+\n+      if (defaultStudy == null) {\n+        throw VariantQueryException.missingStudyForSamples(query.getAsStringList(SAMPLE.key()),\n+            metadataManager.getStudyNames());\n+      }\n+      List<String> loadedGenotypes = defaultStudy.getAttributes().getAsStringList(LOADED_GENOTYPES.key());\n+      if (CollectionUtils.isEmpty(loadedGenotypes)) {\n+        loadedGenotypes = Arrays.asList(\n+            \"0/0\", \"0|0\",\n+            \"0/1\", \"1/0\", \"1/1\", \"./.\",\n+            \"0|1\", \"1|0\", \"1|1\", \".|.\",\n+            \"0|2\", \"2|0\", \"2|1\", \"1|2\", \"2|2\",\n+            \"0/2\", \"2/0\", \"2/1\", \"1/2\", \"2/2\",\n+            GenotypeClass.UNKNOWN_GENOTYPE);\n+      }\n+      String genotypes;\n+      if (loadedGenotypes.contains(GenotypeClass.NA_GT_VALUE)\n+          || defaultStudy.getAttributes().getBoolean(EXCLUDE_GENOTYPES.key(), EXCLUDE_GENOTYPES.defaultValue())) {\n+        genotypes = GenotypeClass.NA_GT_VALUE;\n+      } else {\n+        genotypes = String.join(\",\", GenotypeClass.MAIN_ALT.filter(loadedGenotypes));\n+      }\n+\n+      Pair<QueryOperation, List<String>> pair = VariantQueryUtils.splitValue(query.getString(SAMPLE.key()));\n+      genotypeOperator = pair.getLeft();\n+\n+      StringBuilder sb = new StringBuilder();\n+      for (String sample : pair.getValue()) {\n+        if (sb.length() > 0) {\n+          sb.append(genotypeOperator.separator());\n         }\n+        sb.append(sample).append(IS).append(genotypes);\n+      }\n+      query.remove(SAMPLE.key());\n+      query.put(GENOTYPE.key(), sb.toString());\n+    } else if (isValidParam(query, GENOTYPE)) {\n+      genotypeParam = GENOTYPE;\n+\n+      List<String> loadedGenotypes = defaultStudy.getAttributes().getAsStringList(LOADED_GENOTYPES.key());\n+      if (CollectionUtils.isEmpty(loadedGenotypes)) {\n+        loadedGenotypes = Arrays.asList(\n+            \"0/0\", \"0|0\",\n+            \"0/1\", \"1/0\", \"1/1\", \"./.\",\n+            \"0|1\", \"1|0\", \"1|1\", \".|.\",\n+            \"0|2\", \"2|0\", \"2|1\", \"1|2\", \"2|2\",\n+            \"0/2\", \"2/0\", \"2/1\", \"1/2\", \"2/2\",\n+            GenotypeClass.UNKNOWN_GENOTYPE);\n+      }\n+\n+      Map<Object, List<String>> map = new LinkedHashMap<>();\n+      genotypeOperator = VariantQueryUtils.parseGenotypeFilter(query.getString(GENOTYPE.key()), map);\n+\n+      String filter = preProcessGenotypesFilter(map, genotypeOperator, loadedGenotypes);\n+      query.put(GENOTYPE.key(), filter);\n+    }\n \n-        if (isValidParam(query, SCORE)) {\n-            String value = query.getString(SCORE.key());\n-            List<String> values = splitValue(value).getValue();\n-            for (String scoreFilter : values) {\n-                String variantScore = splitOperator(scoreFilter)[0];\n-                VariantScoreMetadata variantScoreMetadata;\n-                String[] studyScore = splitStudyResource(variantScore);\n-                if (studyScore.length == 2) {\n-                    int studyId = metadataManager.getStudyId(studyScore[0]);\n-                    variantScoreMetadata = metadataManager.getVariantScoreMetadata(studyId, studyScore[1]);\n-                } else {\n-                    if (defaultStudy == null) {\n-                        throw VariantQueryException.missingStudyFor(\"score\", variantScore, metadataManager.getStudyNames());\n-                    } else {\n-                        variantScoreMetadata = metadataManager.getVariantScoreMetadata(defaultStudy, variantScore);\n-                    }\n-                }\n-                if (variantScoreMetadata == null) {\n-                    throw VariantQueryException.scoreNotFound(variantScore, defaultStudy.getName());\n-                }\n-            }\n+    if (formatOperator != null && genotypeOperator != null && formatOperator != genotypeOperator) {\n+      throw VariantQueryException.mixedAndOrOperators(FORMAT, genotypeParam);\n+    }\n+\n+    if (isValidParam(query, SAMPLE_MENDELIAN_ERROR) || isValidParam(query, SAMPLE_DE_NOVO)) {\n+      QueryParam param;\n+      if (isValidParam(query, SAMPLE_MENDELIAN_ERROR) && isValidParam(query, SAMPLE_DE_NOVO)) {\n+        throw VariantQueryException.unsupportedParamsCombination(\n+            SAMPLE_MENDELIAN_ERROR, query.getString(SAMPLE_MENDELIAN_ERROR.key()),\n+            SAMPLE_DE_NOVO, query.getString(SAMPLE_DE_NOVO.key()));\n+      } else if (isValidParam(query, SAMPLE_MENDELIAN_ERROR)) {\n+        param = SAMPLE_MENDELIAN_ERROR;\n+      } else {\n+        param = SAMPLE_DE_NOVO;\n+      }\n+      if (defaultStudy == null) {\n+        throw VariantQueryException.missingStudyForSamples(query.getAsStringList(param.key()),\n+            metadataManager.getStudyNames());\n+      }\n+      // Check no other samples filter is being used, and all samples are precomputed\n+      if (genotypeParam != null) {\n+        throw VariantQueryException.unsupportedParamsCombination(\n+            param, query.getString(param.key()),\n+            genotypeParam, query.getString(genotypeParam.key())\n+        );\n+      }\n+      for (String sample : query.getAsStringList(param.key())) {\n+        Integer sampleId = metadataManager.getSampleId(defaultStudy.getId(), sample);\n+        if (sampleId == null) {\n+          throw VariantQueryException.sampleNotFound(sample, defaultStudy.getName());\n         }\n+        SampleMetadata sampleMetadata = metadataManager.getSampleMetadata(defaultStudy.getId(), sampleId);\n+        if (!TaskMetadata.Status.READY.equals(sampleMetadata.getMendelianErrorStatus())) {\n+          throw VariantQueryException.malformedParam(param, \"Sample \\\"\" + sampleMetadata.getName()\n+              + \"\\\" does not have the Mendelian Errors precomputed yet\");\n+        }\n+      }\n+    }\n \n-        if (!isValidParam(query, INCLUDE_STUDY)\n-                || !isValidParam(query, INCLUDE_SAMPLE)\n-                || !isValidParam(query, INCLUDE_FILE)\n-                || !isValidParam(query, SAMPLE_SKIP)\n-                || !isValidParam(query, SAMPLE_LIMIT)\n-        ) {\n-            VariantQueryFields selectVariantElements =\n-                    parseVariantQueryFields(query, options, metadataManager);\n-            // Apply the sample pagination.\n-            // Remove the sampleLimit and sampleSkip to avoid applying the pagination twice\n-            query.remove(SAMPLE_SKIP.key());\n-            query.remove(SAMPLE_LIMIT.key());\n-            query.put(NUM_TOTAL_SAMPLES.key(), selectVariantElements.getNumTotalSamples());\n-            query.put(NUM_SAMPLES.key(), selectVariantElements.getNumSamples());\n-\n-            if (!isValidParam(query, INCLUDE_STUDY)) {\n-                List<String> includeStudy = new ArrayList<>();\n-                for (Integer studyId : selectVariantElements.getStudies()) {\n-                    includeStudy.add(selectVariantElements.getStudyMetadatas().get(studyId).getName());\n-                }\n-                if (includeStudy.isEmpty()) {\n-                    query.put(INCLUDE_STUDY.key(), NONE);\n-                } else {\n-                    query.put(INCLUDE_STUDY.key(), includeStudy);\n-                }\n-            }\n-            if (!isValidParam(query, INCLUDE_SAMPLE) || selectVariantElements.getSamplePagination()) {\n-                List<String> includeSample = selectVariantElements.getSamples()\n-                        .entrySet()\n-                        .stream()\n-                        .flatMap(e -> e.getValue()\n-                                .stream()\n-                                .map(s -> metadataManager.getSampleName(e.getKey(), s)))\n-                        .collect(Collectors.toList());\n-                if (includeSample.isEmpty()) {\n-                    query.put(INCLUDE_SAMPLE.key(), NONE);\n-                } else {\n-                    query.put(INCLUDE_SAMPLE.key(), includeSample);\n-                }\n-            }\n-            if (!isValidParam(query, INCLUDE_FILE) || selectVariantElements.getSamplePagination()) {\n-                List<String> includeFile = selectVariantElements.getFiles()\n-                        .entrySet()\n-                        .stream()\n-                        .flatMap(e -> e.getValue()\n-                                .stream()\n-                                .map(f -> metadataManager.getFileName(e.getKey(), f)))\n-                        .collect(Collectors.toList());\n-                if (includeFile.isEmpty()) {\n-                    query.put(INCLUDE_FILE.key(), NONE);\n-                } else {\n-                    query.put(INCLUDE_FILE.key(), includeFile);\n-                }\n-            }\n+    if (isValidParam(query, SCORE)) {\n+      String value = query.getString(SCORE.key());\n+      List<String> values = splitValue(value).getValue();\n+      for (String scoreFilter : values) {\n+        String variantScore = splitOperator(scoreFilter)[0];\n+        VariantScoreMetadata variantScoreMetadata;\n+        String[] studyScore = splitStudyResource(variantScore);\n+        if (studyScore.length == 2) {\n+          int studyId = metadataManager.getStudyId(studyScore[0]);\n+          variantScoreMetadata = metadataManager.getVariantScoreMetadata(studyId, studyScore[1]);\n+        } else {\n+          if (defaultStudy == null) {\n+            throw VariantQueryException.missingStudyFor(\"score\", variantScore, metadataManager.getStudyNames());\n+          } else {\n+            variantScoreMetadata = metadataManager.getVariantScoreMetadata(defaultStudy, variantScore);\n+          }\n         }\n+        if (variantScoreMetadata == null) {\n+          throw VariantQueryException.scoreNotFound(variantScore, defaultStudy.getName());\n+        }\n+      }\n+    }\n \n-        List<String> formats = getIncludeFormats(query);\n-        if (formats == null) {\n-            formats = Collections.singletonList(ALL);\n-        } else if (formats.isEmpty()) {\n-            formats = Collections.singletonList(NONE);\n+    if (!isValidParam(query, INCLUDE_STUDY)\n+        || !isValidParam(query, INCLUDE_SAMPLE)\n+        || !isValidParam(query, INCLUDE_FILE)\n+        || !isValidParam(query, SAMPLE_SKIP)\n+        || !isValidParam(query, SAMPLE_LIMIT)\n+    ) {\n+      VariantQueryFields selectVariantElements =\n+          parseVariantQueryFields(query, options, metadataManager);\n+      // Apply the sample pagination.\n+      // Remove the sampleLimit and sampleSkip to avoid applying the pagination twice\n+      query.remove(SAMPLE_SKIP.key());\n+      query.remove(SAMPLE_LIMIT.key());\n+      query.put(NUM_TOTAL_SAMPLES.key(), selectVariantElements.getNumTotalSamples());\n+      query.put(NUM_SAMPLES.key(), selectVariantElements.getNumSamples());\n+\n+      if (!isValidParam(query, INCLUDE_STUDY)) {\n+        List<String> includeStudy = new ArrayList<>();\n+        for (Integer studyId : selectVariantElements.getStudies()) {\n+          includeStudy.add(selectVariantElements.getStudyMetadatas().get(studyId).getName());\n+        }\n+        if (includeStudy.isEmpty()) {\n+          query.put(INCLUDE_STUDY.key(), NONE);\n+        } else {\n+          query.put(INCLUDE_STUDY.key(), includeStudy);\n         }\n+      }\n+      if (!isValidParam(query, INCLUDE_SAMPLE) || selectVariantElements.getSamplePagination()) {\n+        List<String> includeSample = selectVariantElements.getSamples()\n+            .entrySet()\n+            .stream()\n+            .flatMap(e -> e.getValue()\n+                .stream()\n+                .map(s -> metadataManager.getSampleName(e.getKey(), s)))\n+            .collect(Collectors.toList());\n+        if (includeSample.isEmpty()) {\n+          query.put(INCLUDE_SAMPLE.key(), NONE);\n+        } else {\n+          query.put(INCLUDE_SAMPLE.key(), includeSample);\n+        }\n+      }\n+      if (!isValidParam(query, INCLUDE_FILE) || selectVariantElements.getSamplePagination()) {\n+        List<String> includeFile = selectVariantElements.getFiles()\n+            .entrySet()\n+            .stream()\n+            .flatMap(e -> e.getValue()\n+                .stream()\n+                .map(f -> metadataManager.getFileName(e.getKey(), f)))\n+            .collect(Collectors.toList());\n+        if (includeFile.isEmpty()) {\n+          query.put(INCLUDE_FILE.key(), NONE);\n+        } else {\n+          query.put(INCLUDE_FILE.key(), includeFile);\n+        }\n+      }\n+    }\n \n-        query.put(INCLUDE_FORMAT.key(), formats);\n-        query.remove(INCLUDE_GENOTYPE.key(), formats);\n+    List<String> formats = getIncludeFormats(query);\n+    if (formats == null) {\n+      formats = Collections.singletonList(ALL);\n+    } else if (formats.isEmpty()) {\n+      formats = Collections.singletonList(NONE);\n     }\n \n-    protected String preProcessGenotypesFilter(Map<Object, List<String>> map, QueryOperation op, List<String> loadedGenotypes) {\n-        StringBuilder sb = new StringBuilder();\n-        for (Map.Entry<Object, List<String>> entry : map.entrySet()) {\n+    query.put(INCLUDE_FORMAT.key(), formats);\n+    query.remove(INCLUDE_GENOTYPE.key(), formats);\n+  }\n+\n+  protected String preProcessGenotypesFilter(Map<Object, List<String>> map, QueryOperation op, List<String> loadedGenotypes) {\n+    StringBuilder sb = new StringBuilder();\n+    for (Map.Entry<Object, List<String>> entry : map.entrySet()) {\n //                List<String> genotypes = GenotypeClass.filter(entry.getValue(), loadedGenotypes, defaultGenotypes);\n-            List<String> genotypes = new ArrayList<>(entry.getValue());\n-            for (String genotypeStr : entry.getValue()) {\n-                boolean negated = isNegated(genotypeStr);\n-                if (negated) {\n-                    removeNegation(genotypeStr);\n-                }\n-                Genotype genotype = new Genotype(genotypeStr);\n-                int[] allelesIdx = genotype.getAllelesIdx();\n-                boolean multiallelic = false;\n-                for (int i = 0; i < allelesIdx.length; i++) {\n-                    if (allelesIdx[i] > 1) {\n-                        allelesIdx[i] = 2;\n-                        multiallelic = true;\n-                    }\n-                }\n-                if (multiallelic) {\n-                    String regex = genotype.toString()\n-                            .replace(\".\", \"\\\\.\")\n-                            .replace(\"2\", \"([2-9]|[0-9][0-9])\");// Replace allele \"2\" with \"any number >= 2\")\n-                    Pattern pattern = Pattern.compile(regex);\n-                    for (String loadedGenotype : loadedGenotypes) {\n-                        if (pattern.matcher(loadedGenotype).matches()) {\n-                            genotypes.add((negated ? NOT : \"\") + loadedGenotype);\n-                        }\n-                    }\n-                }\n+      List<String> genotypes = new ArrayList<>(entry.getValue());\n+      for (String genotypeStr : entry.getValue()) {\n+        boolean negated = isNegated(genotypeStr);\n+        if (negated) {\n+          removeNegation(genotypeStr);\n+        }\n+        Genotype genotype = new Genotype(genotypeStr);\n+        int[] allelesIdx = genotype.getAllelesIdx();\n+        boolean multiallelic = false;\n+        for (int i = 0; i < allelesIdx.length; i++) {\n+          if (allelesIdx[i] > 1) {\n+            allelesIdx[i] = 2;\n+            multiallelic = true;\n+          }\n+        }\n+        if (multiallelic) {\n+          String regex = genotype.toString()\n+              .replace(\".\", \"\\\\.\")\n+              .replace(\"2\", \"([2-9]|[0-9][0-9])\");// Replace allele \"2\" with \"any number >= 2\")\n+          Pattern pattern = Pattern.compile(regex);\n+          for (String loadedGenotype : loadedGenotypes) {\n+            if (pattern.matcher(loadedGenotype).matches()) {\n+              genotypes.add((negated ? NOT : \"\") + loadedGenotype);\n             }\n-            genotypes = GenotypeClass.filter(genotypes, loadedGenotypes);\n+          }\n+        }\n+      }\n+      genotypes = GenotypeClass.filter(genotypes, loadedGenotypes);\n+\n+      if (genotypes.isEmpty()) {\n+        // TODO: Do fast fail, NO RESULTS!\n+        genotypes = Collections.singletonList(GenotypeClass.NONE_GT_VALUE);\n+      }\n+\n+      if (sb.length() > 0) {\n+        sb.append(op.separator());\n+      }\n+      sb.append(entry.getKey()).append(IS);\n+      for (int i = 0; i < genotypes.size(); i++) {\n+        if (i > 0) {\n+          sb.append(OR);\n+        }\n+        sb.append(genotypes.get(i));\n+      }\n+    }\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Parses XREFS related filters, and sorts in different lists.\n+   * <p>\n+   * - {@link VariantQueryParam#ID}\n+   * - {@link VariantQueryParam#GENE}\n+   * - {@link VariantQueryParam#ANNOT_XREF}\n+   * - {@link VariantQueryParam#ANNOT_CLINVAR}\n+   * - {@link VariantQueryParam#ANNOT_COSMIC}\n+   *\n+   * @param query Query to parse\n+   * @return VariantQueryXref with all VariantIds, ids, genes and xrefs\n+   */\n+  public static VariantQueryXref parseXrefs(Query query) {\n+    VariantQueryXref xrefs = new VariantQueryXref();\n+    if (query == null) {\n+      return xrefs;\n+    }\n+    xrefs.getGenes().addAll(query.getAsStringList(GENE.key(), OR));\n \n-            if (genotypes.isEmpty()) {\n-                // TODO: Do fast fail, NO RESULTS!\n-                genotypes = Collections.singletonList(GenotypeClass.NONE_GT_VALUE);\n-            }\n+    if (isValidParam(query, ID)) {\n+      List<String> idsList = query.getAsStringList(ID.key(), OR);\n \n-            if (sb.length() > 0) {\n-                sb.append(op.separator());\n-            }\n-            sb.append(entry.getKey()).append(IS);\n-            for (int i = 0; i < genotypes.size(); i++) {\n-                if (i > 0) {\n-                    sb.append(OR);\n-                }\n-                sb.append(genotypes.get(i));\n-            }\n+      for (String value : idsList) {\n+        Variant variant = toVariant(value);\n+        if (variant != null) {\n+          xrefs.getVariants().add(variant);\n+        } else {\n+          xrefs.getIds().add(value);\n         }\n-        return sb.toString();\n+      }\n     }\n \n-    /**\n-     * Parses XREFS related filters, and sorts in different lists.\n-     *\n-     * - {@link VariantQueryParam#ID}\n-     * - {@link VariantQueryParam#GENE}\n-     * - {@link VariantQueryParam#ANNOT_XREF}\n-     * - {@link VariantQueryParam#ANNOT_CLINVAR}\n-     * - {@link VariantQueryParam#ANNOT_COSMIC}\n-     *\n-     * @param query Query to parse\n-     * @return VariantQueryXref with all VariantIds, ids, genes and xrefs\n-     */\n-    public static VariantQueryXref parseXrefs(Query query) {\n-        VariantQueryXref xrefs = new VariantQueryXref();\n-        if (query == null) {\n-            return xrefs;\n-        }\n-        xrefs.getGenes().addAll(query.getAsStringList(GENE.key(), OR));\n-\n-        if (isValidParam(query, ID)) {\n-            List<String> idsList = query.getAsStringList(ID.key(), OR);\n-\n-            for (String value : idsList) {\n-                Variant variant = toVariant(value);\n-                if (variant != null) {\n-                    xrefs.getVariants().add(variant);\n-                } else {\n-                    xrefs.getIds().add(value);\n-                }\n-            }\n+    if (isValidParam(query, ANNOT_XREF)) {\n+      List<String> xrefsList = query.getAsStringList(ANNOT_XREF.key(), OR);\n+      for (String value : xrefsList) {\n+        Variant variant = toVariant(value);\n+        if (variant != null) {\n+          xrefs.getVariants().add(variant);\n+        } else {\n+          if (isVariantAccession(value) || isClinicalAccession(value) || isGeneAccession(value)) {\n+            xrefs.getOtherXrefs().add(value);\n+          } else {\n+            xrefs.getGenes().add(value);\n+          }\n         }\n+      }\n \n-        if (isValidParam(query, ANNOT_XREF)) {\n-            List<String> xrefsList = query.getAsStringList(ANNOT_XREF.key(), OR);\n-            for (String value : xrefsList) {\n-                Variant variant = toVariant(value);\n-                if (variant != null) {\n-                    xrefs.getVariants().add(variant);\n-                } else {\n-                    if (isVariantAccession(value) || isClinicalAccession(value) || isGeneAccession(value)) {\n-                        xrefs.getOtherXrefs().add(value);\n-                    } else {\n-                        xrefs.getGenes().add(value);\n-                    }\n-                }\n-            }\n-\n-        }\n+    }\n //        xrefs.getOtherXrefs().addAll(query.getAsStringList(ANNOT_HPO.key(), OR));\n-        xrefs.getOtherXrefs().addAll(query.getAsStringList(ANNOT_COSMIC.key(), OR));\n-        xrefs.getOtherXrefs().addAll(query.getAsStringList(ANNOT_CLINVAR.key(), OR));\n+    xrefs.getOtherXrefs().addAll(query.getAsStringList(ANNOT_COSMIC.key(), OR));\n+    xrefs.getOtherXrefs().addAll(query.getAsStringList(ANNOT_CLINVAR.key(), OR));\n \n-        return xrefs;\n-    }\n+    return xrefs;\n+  }\n \n-    public static class VariantQueryXref {\n-        private final List<String> genes = new LinkedList<>();\n-        private final List<Variant> variants = new LinkedList<>();\n-        private final List<String> ids = new LinkedList<>();\n-        private final List<String> otherXrefs = new LinkedList<>();\n-\n-        /**\n-         * @return List of genes found at {@link VariantQueryParam#GENE} and {@link VariantQueryParam#ANNOT_XREF}\n-         */\n-        public List<String> getGenes() {\n-            return genes;\n-        }\n+  public static class VariantQueryXref {\n+    private final List<String> genes = new LinkedList<>();\n+    private final List<Variant> variants = new LinkedList<>();\n+    private final List<String> ids = new LinkedList<>();\n+    private final List<String> otherXrefs = new LinkedList<>();\n \n-        /**\n-         * @return List of variants found at {@link VariantQueryParam#ANNOT_XREF} and {@link VariantQueryParam#ID}\n-         */\n-        public List<Variant> getVariants() {\n-            return variants;\n-        }\n+    /**\n+     * @return List of genes found at {@link VariantQueryParam#GENE} and {@link VariantQueryParam#ANNOT_XREF}\n+     */\n+    public List<String> getGenes() {\n+      return genes;\n+    }\n \n-        /**\n-         * @return List of ids found at {@link VariantQueryParam#ID}\n-         */\n-        public List<String> getIds() {\n-            return ids;\n-        }\n+    /**\n+     * @return List of variants found at {@link VariantQueryParam#ANNOT_XREF} and {@link VariantQueryParam#ID}\n+     */\n+    public List<Variant> getVariants() {\n+      return variants;\n+    }\n \n-        /**\n-         * @return List of other xrefs found at\n-         * {@link VariantQueryParam#ANNOT_XREF},\n-         * {@link VariantQueryParam#ID},\n-         * {@link VariantQueryParam#ANNOT_CLINVAR},\n-         * {@link VariantQueryParam#ANNOT_COSMIC}\n-         */\n-        public List<String> getOtherXrefs() {\n-            return otherXrefs;\n-        }\n+    /**\n+     * @return List of ids found at {@link VariantQueryParam#ID}\n+     */\n+    public List<String> getIds() {\n+      return ids;\n+    }\n+\n+    /**\n+     * @return List of other xrefs found at\n+     * {@link VariantQueryParam#ANNOT_XREF},\n+     * {@link VariantQueryParam#ID},\n+     * {@link VariantQueryParam#ANNOT_CLINVAR},\n+     * {@link VariantQueryParam#ANNOT_COSMIC}\n+     */\n+    public List<String> getOtherXrefs() {\n+      return otherXrefs;\n     }\n+  }\n }\n",
            "diff_size": 720
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/79/VariantQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/79/VariantQueryParser.java\nindex a96f14136c9..a0aa6a1152d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/79/VariantQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/79/VariantQueryParser.java\n@@ -459,8 +459,8 @@ public class VariantQueryParser {\n                 if (multiallelic) {\n                     String regex = genotype.toString()\n                             .replace(\".\", \"\\\\.\")\n-                            .replace(\"2\", \"([2-9]|[0-9][0-9])\");// Replace allele \"2\" with \"any number >= 2\")\n-                    Pattern pattern = Pattern.compile(regex);\n+                            .replace(\"2\", \"([2-9]|[0-9][0-9])\"); // Replace allele \"2\" with \"any number >= 2\")\n+                            Pattern pattern = Pattern.compile(regex);\n                     for (String loadedGenotype : loadedGenotypes) {\n                         if (pattern.matcher(loadedGenotype).matches()) {\n                             genotypes.add((negated ? NOT : \"\") + loadedGenotype);\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/79/VariantQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/79/VariantQueryParser.java\nindex a96f14136c9..4446a00ebfa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/79/VariantQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/79/VariantQueryParser.java\n@@ -459,7 +459,7 @@ public class VariantQueryParser {\n                 if (multiallelic) {\n                     String regex = genotype.toString()\n                             .replace(\".\", \"\\\\.\")\n-                            .replace(\"2\", \"([2-9]|[0-9][0-9])\");// Replace allele \"2\" with \"any number >= 2\")\n+                            .replace(\"2\", \"([2-9]|[0-9][0-9])\"); // Replace allele \"2\" with \"any number >= 2\")\n                     Pattern pattern = Pattern.compile(regex);\n                     for (String loadedGenotype : loadedGenotypes) {\n                         if (pattern.matcher(loadedGenotype).matches()) {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff"
    ]
}