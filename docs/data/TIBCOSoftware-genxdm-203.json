{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "203",
    "information": {
        "errors": [
            {
                "line": "27",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "public class TestValidate<N,A> extends BaseBridgePerfTest<N,A>\n{\n\tpublic static final String SCHEMA_FILE_PROP_NAME = \"schema\";\n\tpublic static final String COPY_TYPE_ANNOTATION_NAME = \"copyTypeAnnotations\";\n\tprivate static final ArrayList<String> REQUIRED_FEATURES = new ArrayList<String>();\n\tstatic ",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "28",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/203/TestValidate.java\nindex 4c883a99b2c..8c400d1d039 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/203/TestValidate.java\n@@ -24,7 +24,7 @@ import org.genxdm.xs.resolve.SchemaCatalog;\n \r\n public class TestValidate<N,A> extends BaseBridgePerfTest<N,A>\r\n {\r\n-\tpublic static final String SCHEMA_FILE_PROP_NAME = \"schema\";\r\n+public static final String SCHEMA_FILE_PROP_NAME = \"schema\";\r\n \tpublic static final String COPY_TYPE_ANNOTATION_NAME = \"copyTypeAnnotations\";\r\n \tprivate static final ArrayList<String> REQUIRED_FEATURES = new ArrayList<String>();\r\n \tstatic \r\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "144",
                    "column": "3",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/203/TestValidate.java\nindex 4c883a99b2c..37620411bc2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/203/TestValidate.java\n@@ -22,182 +22,180 @@ import org.genxdm.xs.exceptions.SchemaExceptionCatcher;\n import org.genxdm.xs.resolve.CatalogResolver;\r\n import org.genxdm.xs.resolve.SchemaCatalog;\r\n \r\n-public class TestValidate<N,A> extends BaseBridgePerfTest<N,A>\r\n-{\r\n-\tpublic static final String SCHEMA_FILE_PROP_NAME = \"schema\";\r\n-\tpublic static final String COPY_TYPE_ANNOTATION_NAME = \"copyTypeAnnotations\";\r\n-\tprivate static final ArrayList<String> REQUIRED_FEATURES = new ArrayList<String>();\r\n-\tstatic \r\n-\t{\r\n-\t\tREQUIRED_FEATURES.add(Feature.TYPED);\r\n-\t}\r\n-\tList<String> m_schemaFiles;\r\n-\tSchemaExceptionCatcher m_errors;\r\n+public class TestValidate<N, A> extends BaseBridgePerfTest<N, A> {\r\n+    public static final String SCHEMA_FILE_PROP_NAME = \"schema\";\r\n+\r\n+    public static final String COPY_TYPE_ANNOTATION_NAME = \"copyTypeAnnotations\";\r\n+\r\n+    private static final ArrayList<String> REQUIRED_FEATURES = new ArrayList<String>();\r\n+\r\n+    static {\r\n+        REQUIRED_FEATURES.add(Feature.TYPED);\r\n+    }\r\n+\r\n+    List<String> m_schemaFiles;\r\n+\r\n+    SchemaExceptionCatcher m_errors;\r\n+\r\n     ValidationHandler<A> m_validator;\r\n+\r\n     boolean m_copyTypeAnnotations = false;\r\n-    \r\n+\r\n+    @Override\r\n+    public Iterable<String> getRequiredFeatures() {\r\n+        return REQUIRED_FEATURES;\r\n+    }\r\n+\r\n+    @Override\r\n+    public String getTestName() {\r\n+        return getDocFilename();\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialSetup(Map<String, Object> props) {\r\n+        super.initialSetup(props);\r\n+\r\n+        Object schemaFiles = props.get(SCHEMA_FILE_PROP_NAME);\r\n+        if (schemaFiles == null) {\r\n+            throw new IllegalStateException(\"Validation testing requires schema file location.\");\r\n+        }\r\n+        if (schemaFiles instanceof List) {\r\n+            m_schemaFiles = (List<String>) schemaFiles;\r\n+        } else {\r\n+            m_schemaFiles = new ArrayList<String>();\r\n+            m_schemaFiles.add((String) schemaFiles);\r\n+        }\r\n+\r\n+        String baseURI = (String) props.get(BASE_URI_PROP_NAME);\r\n+        if (baseURI == null) {\r\n+            throw new IllegalStateException(\"Base URI must be specified.\");\r\n+        }\r\n+        m_copyTypeAnnotations = Boolean.parseBoolean((String) props.get(COPY_TYPE_ANNOTATION_NAME));\r\n+\r\n+        // Load a schema...\r\n+        final TypedContext<N, A> typedContext = getPcx().getTypedContext(null);\r\n+        for (String schemaFile : m_schemaFiles) {\r\n+            final String schemaFilePath = getBaseURI() + \"/\" + schemaFile;\r\n+            try {\r\n+                addSchema(typedContext, new URI(schemaFilePath));\r\n+            } catch (IOException e) {\r\n+                throw new RuntimeException(e);\r\n+            } catch (URISyntaxException e) {\r\n+                throw new RuntimeException(e);\r\n+            } catch (Exception e) {\r\n+                throw new RuntimeException(e);\r\n+            }\r\n+        }\r\n+\r\n+        // Create a validator...\r\n+        final ValidatorFactory<N, A> vcf = new ValidatorFactory<N, A>(typedContext);\r\n+        m_validator = vcf.newXdmContentValidator();\r\n+        m_validator.setSchema(typedContext.getSchema());\r\n+    }\r\n+\r\n     @Override\r\n-    public Iterable<String> getRequiredFeatures()\r\n-    {\r\n-    \treturn REQUIRED_FEATURES;\r\n+    public void iterativeSetup() {\r\n+        if (m_errors == null) {\r\n+            m_errors = new SchemaExceptionCatcher();\r\n+            m_validator.setSchemaExceptionHandler(m_errors);\r\n+        } else {\r\n+            m_errors.clear();\r\n+        }\r\n     }\r\n-\t@Override\r\n-\tpublic String getTestName() {\r\n-\t\treturn getDocFilename();\r\n-\t}\r\n-\t@Override\r\n-\tpublic void initialSetup(Map<String,Object> props)\t{\r\n-\t\tsuper.initialSetup(props);\r\n-\t\t\r\n-\t\tObject schemaFiles = props.get(SCHEMA_FILE_PROP_NAME);\r\n-\t\tif(schemaFiles == null)\r\n-\t\t{\r\n-\t\t\tthrow new IllegalStateException(\"Validation testing requires schema file location.\");\r\n-\t\t}\r\n-\t\tif(schemaFiles instanceof List)\r\n-\t\t{\r\n-\t\t\tm_schemaFiles = (List<String>)schemaFiles;\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\tm_schemaFiles = new ArrayList<String>();\r\n-\t\t\tm_schemaFiles.add((String)schemaFiles);\r\n-\t\t}\r\n-\t\t\r\n-\t\tString baseURI = (String)props.get(BASE_URI_PROP_NAME);\r\n-\t\tif(baseURI == null)\r\n-\t\t{\r\n-\t\t\tthrow new IllegalStateException(\"Base URI must be specified.\");\r\n-\t\t}\r\n-\t\tm_copyTypeAnnotations = Boolean.parseBoolean((String)props.get(COPY_TYPE_ANNOTATION_NAME));\r\n-\r\n-\t\t// Load a schema...\r\n-\t\tfinal TypedContext<N,A> typedContext = getPcx().getTypedContext(null);\r\n-\t\tfor(String schemaFile : m_schemaFiles)\r\n-\t\t{\r\n-\t        final String schemaFilePath = getBaseURI() + \"/\" + schemaFile;\r\n-\t        try {\r\n-\t\t\t\taddSchema(typedContext, new URI(schemaFilePath));\r\n-\t\t\t} catch (IOException e) {\r\n-\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t} catch (URISyntaxException e) {\r\n-\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t} catch (Exception e) {\r\n-\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t} \r\n-\t\t}\r\n-        \r\n-\t\t// Create a validator...\r\n-\t\tfinal ValidatorFactory<N, A> vcf = new ValidatorFactory<N, A>(typedContext);\r\n-\t\tm_validator = vcf.newXdmContentValidator();\r\n-\t\tm_validator.setSchema(typedContext.getSchema());\r\n-\t}\r\n-\t\r\n-\t@Override\r\n-\tpublic void iterativeSetup() {\r\n-\t\tif(m_errors == null)\r\n-\t\t{\r\n-\t\t\tm_errors = new SchemaExceptionCatcher();\r\n-\t\t\tm_validator.setSchemaExceptionHandler(m_errors);\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\tm_errors.clear();\r\n-\t\t}\r\n-\t}\r\n-\t@Override\r\n-\tpublic void execute() {\r\n-\t\tgetModel().stream(getTestNode(), m_validator);\r\n-\t}\r\n-\t@Override\r\n-\tpublic Iterable<String> iterativeTeardown() {\r\n-\t\tArrayList<String> retval = new ArrayList<String>();\r\n-\t\tif(!m_errors.isEmpty())\r\n-\t\t{\r\n-\t\t\tretval.add(m_errors.size() + \" validation errors.\");\r\n-\t\t\tint errorCnt = 0;\r\n-\t\t\tfor (SchemaException ex : m_errors)\r\n-\t\t\t{\r\n-\t\t\t\tif(errorCnt == 10)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tretval.add(\"\\t\" + \"... that's all we're listing...\");\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t}\r\n-\t\t\t\terrorCnt++;\r\n-\t\t\t\tretval.add(\"\\t\" + ex.getMessage());\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn null; \r\n-\t}\r\n-\t\r\n-\t@Override\r\n-\tpublic void finalTeardown()\t{\r\n-\t\tm_schemaFiles = null;\r\n-\t\tm_errors = null;\r\n-\t\tm_validator = null;\r\n-\t\tsuper.finalTeardown();\r\n-\t}\r\n-\tprotected LinkedList<SchemaException> addSchema(TypedContext<N, A> tpcx, URI uri) throws Exception\r\n-\t{\r\n-\t\t// Load a top-level schema into the processing context.\r\n-\t\tfinal List<Resolved<InputStream>> resources = new LinkedList<Resolved<InputStream>>();\r\n-\t\tresources.add(getResolver().resolveInputStream(uri));\r\n-\r\n-\t\tfinal SchemaExceptionCatcher errors = new SchemaExceptionCatcher();\r\n+\r\n+    @Override\r\n+    public void execute() {\r\n+        getModel().stream(getTestNode(), m_validator);\r\n+    }\r\n+\r\n+    @Override\r\n+    public Iterable<String> iterativeTeardown() {\r\n+        ArrayList<String> retval = new ArrayList<String>();\r\n+        if (!m_errors.isEmpty()) {\r\n+            retval.add(m_errors.size() + \" validation errors.\");\r\n+            int errorCnt = 0;\r\n+            for (SchemaException ex : m_errors) {\r\n+                if (errorCnt == 10) {\r\n+                    retval.add(\"\\t\" + \"... that's all we're listing...\");\r\n+                    break;\r\n+                }\r\n+                errorCnt++;\r\n+                retval.add(\"\\t\" + ex.getMessage());\r\n+            }\r\n+        }\r\n+        return null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void finalTeardown() {\r\n+        m_schemaFiles = null;\r\n+        m_errors = null;\r\n+        m_validator = null;\r\n+        super.finalTeardown();\r\n+    }\r\n+\r\n+    protected LinkedList<SchemaException> addSchema(TypedContext<N, A> tpcx, URI uri)\r\n+        throws Exception {\r\n+        // Load a top-level schema into the processing context.\r\n+        final List<Resolved<InputStream>> resources = new LinkedList<Resolved<InputStream>>();\r\n+        resources.add(getResolver().resolveInputStream(uri));\r\n+\r\n+        final SchemaExceptionCatcher errors = new SchemaExceptionCatcher();\r\n //\t\tfinal SchemaLoadOptions args = new SchemaLoadOptions();\r\n-\t\tfinal W3cXmlSchemaParser parser = new W3cXmlSchemaParser();\r\n-\t\t\r\n-\t\tparser.setComponentProvider(tpcx.getSchema().getComponentProvider());\r\n-\t\tparser.setCatalogResolver(new MyResolver(), new MyCatalog());\r\n-\t\t\r\n-\t\tfor (final Resolved<InputStream> resource : resources)\r\n-\t\t{\r\n-\t\t\tComponentBag scBag = parser.parse(resource.getLocation(), resource.getResource(), resource.getSystemId(), errors);\r\n-\t\t\tif(!errors.isEmpty())\r\n-\t\t\t{\r\n-\t\t\t\tfor(SchemaException error : errors)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tSystem.out.println(\"      \" + error.getLocalizedMessage());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\ttpcx.getSchema().register(scBag);\r\n-\t\t}\r\n-\t\treturn errors;\r\n-\t}\r\n-\tclass MyCatalog implements SchemaCatalog {\r\n-\r\n-\t\tprivate final HashMap<URI, URI> m_ns2loc = new HashMap<URI, URI>();\r\n-\t\t\r\n-\t\t@Override\r\n-\t\tpublic URI resolveLocation(URI baseURI, URI schemaLocation) {\r\n-\t\t\treturn resolveNamespaceAndSchemaLocation(baseURI, null, schemaLocation);\r\n-\t\t}\r\n-\r\n-\t\t@Override\r\n-\t\tpublic URI resolveNamespaceAndSchemaLocation(URI baseURI, URI namespace, URI schemaLocation) {\r\n-\t\t\tif(schemaLocation == null)\r\n-\t\t\t{\r\n-\t\t\t\t// No other way to look this up in this catalog.\r\n-\t\t\t\treturn m_ns2loc.get(namespace);\r\n-\t\t\t}\r\n-\t\t\tString x = baseURI.toString();\r\n-\t\t\tint index = x.lastIndexOf('/');\r\n-\t\t\tString uriString = x.substring(0, index + 1).concat(schemaLocation.toString());\r\n-\t\t\ttry {\r\n-\t\t\t\tm_ns2loc.put(namespace, schemaLocation);\r\n-\t\t\t\treturn new URI(uriString);\r\n-\t\t\t} catch (URISyntaxException e) {\r\n-\t\t\t\te.printStackTrace();\r\n-\t\t\t\treturn schemaLocation;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\tclass MyResolver implements CatalogResolver {\r\n-\t\t@Override\r\n-\t\tpublic InputStream resolveInputStream(URI catalogURI)\r\n-\t\t\t\tthrows IOException {\r\n-\t\t\tResolved<InputStream> resolved = getResolver().resolveInputStream(catalogURI);\r\n-\t\t\treturn resolved.getResource();\r\n-\t\t}\r\n-\t}\r\n+        final W3cXmlSchemaParser parser = new W3cXmlSchemaParser();\r\n+\r\n+        parser.setComponentProvider(tpcx.getSchema().getComponentProvider());\r\n+        parser.setCatalogResolver(new MyResolver(), new MyCatalog());\r\n+\r\n+        for (final Resolved<InputStream> resource : resources) {\r\n+            ComponentBag scBag = parser\r\n+                .parse(resource.getLocation(), resource.getResource(), resource.getSystemId(),\r\n+                    errors);\r\n+            if (!errors.isEmpty()) {\r\n+                for (SchemaException error : errors) {\r\n+                    System.out.println(\"      \" + error.getLocalizedMessage());\r\n+                }\r\n+            }\r\n+            tpcx.getSchema().register(scBag);\r\n+        }\r\n+        return errors;\r\n+    }\r\n+\r\n+    class MyCatalog implements SchemaCatalog {\r\n+\r\n+        private final HashMap<URI, URI> m_ns2loc = new HashMap<URI, URI>();\r\n+\r\n+        @Override\r\n+        public URI resolveLocation(URI baseURI, URI schemaLocation) {\r\n+            return resolveNamespaceAndSchemaLocation(baseURI, null, schemaLocation);\r\n+        }\r\n+\r\n+        @Override\r\n+        public URI resolveNamespaceAndSchemaLocation(URI baseURI, URI namespace,\r\n+                                                     URI schemaLocation) {\r\n+            if (schemaLocation == null) {\r\n+                // No other way to look this up in this catalog.\r\n+                return m_ns2loc.get(namespace);\r\n+            }\r\n+            String x = baseURI.toString();\r\n+            int index = x.lastIndexOf('/');\r\n+            String uriString = x.substring(0, index + 1).concat(schemaLocation.toString());\r\n+            try {\r\n+                m_ns2loc.put(namespace, schemaLocation);\r\n+                return new URI(uriString);\r\n+            } catch (URISyntaxException e) {\r\n+                e.printStackTrace();\r\n+                return schemaLocation;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    class MyResolver implements CatalogResolver {\r\n+        @Override\r\n+        public InputStream resolveInputStream(URI catalogURI)\r\n+            throws IOException {\r\n+            Resolved<InputStream> resolved = getResolver().resolveInputStream(catalogURI);\r\n+            return resolved.getResource();\r\n+        }\r\n+    }\r\n }\r\n",
            "diff_size": 235
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/203/TestValidate.java\nindex 4c883a99b2c..b8343a3b92c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/203/TestValidate.java\n@@ -1,203 +1,235 @@\n-package org.genxdm.samples.performance.bridges;\r\n+package org.genxdm.samples.performance.bridges;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.genxdm.Feature;\n+import org.genxdm.io.Resolved;\n+import org.genxdm.processor.w3c.xs.W3cXmlSchemaParser;\n+import org.genxdm.processor.w3c.xs.validation.ValidatorFactory;\n+import org.genxdm.typed.TypedContext;\n+import org.genxdm.typed.ValidationHandler;\n+import org.genxdm.xs.ComponentBag;\n+import org.genxdm.xs.exceptions.SchemaException;\n+import org.genxdm.xs.exceptions.SchemaExceptionCatcher;\n+import org.genxdm.xs.resolve.CatalogResolver;\n+import org.genxdm.xs.resolve.SchemaCatalog;\n+\n+public class TestValidate<N, A>\n+    extends BaseBridgePerfTest<N, A>\n+{\n+    public static final String SCHEMA_FILE_PROP_NAME = \"schema\";\n+    public static final String COPY_TYPE_ANNOTATION_NAME = \"copyTypeAnnotations\";\n+    private static final ArrayList<String> REQUIRED_FEATURES = new ArrayList<String>();\n+\n+    static\n+    {\n+        REQUIRED_FEATURES.add(Feature.TYPED);\n+    }\n+\n+    List<String> m_schemaFiles;\n+    SchemaExceptionCatcher m_errors;\n+    ValidationHandler<A> m_validator;\n+\n+    boolean m_copyTypeAnnotations = false;\n+\n+    @Override\n+    public Iterable<String> getRequiredFeatures()\n+    {\n+        return REQUIRED_FEATURES;\n+    }\n+\n+    @Override\n+    public String getTestName()\n+    {\n+        return getDocFilename();\n+    }\n+\n+    @Override\n+    public void initialSetup(Map<String, Object> props)\n+    {\n+        super.initialSetup(props);\n+        Object schemaFiles = props.get(SCHEMA_FILE_PROP_NAME);\n+        if (schemaFiles == null)\n+        {\n+            throw new IllegalStateException(\"Validation testing requires schema file location.\");\n+        }\n+        if (schemaFiles instanceof List)\n+        {\n+            m_schemaFiles = (List<String>)schemaFiles;\n+        }\n+        else\n+        {\n+            m_schemaFiles = new ArrayList<String>();\n+            m_schemaFiles.add((String)schemaFiles);\n+        }\n+        String baseURI = (String)props.get(BASE_URI_PROP_NAME);\n+        if (baseURI == null)\n+        {\n+            throw new IllegalStateException(\"Base URI must be specified.\");\n+        }\n+        m_copyTypeAnnotations = Boolean.parseBoolean((String)props.get(COPY_TYPE_ANNOTATION_NAME));\r\n \r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.net.URI;\r\n-import java.net.URISyntaxException;\r\n-import java.util.ArrayList;\r\n-import java.util.HashMap;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.genxdm.Feature;\r\n-import org.genxdm.io.Resolved;\r\n-import org.genxdm.processor.w3c.xs.W3cXmlSchemaParser;\r\n-import org.genxdm.processor.w3c.xs.validation.ValidatorFactory;\r\n-import org.genxdm.typed.TypedContext;\r\n-import org.genxdm.typed.ValidationHandler;\r\n-import org.genxdm.xs.ComponentBag;\r\n-import org.genxdm.xs.exceptions.SchemaException;\r\n-import org.genxdm.xs.exceptions.SchemaExceptionCatcher;\r\n-import org.genxdm.xs.resolve.CatalogResolver;\r\n-import org.genxdm.xs.resolve.SchemaCatalog;\r\n-\r\n-public class TestValidate<N,A> extends BaseBridgePerfTest<N,A>\r\n-{\r\n-\tpublic static final String SCHEMA_FILE_PROP_NAME = \"schema\";\r\n-\tpublic static final String COPY_TYPE_ANNOTATION_NAME = \"copyTypeAnnotations\";\r\n-\tprivate static final ArrayList<String> REQUIRED_FEATURES = new ArrayList<String>();\r\n-\tstatic \r\n-\t{\r\n-\t\tREQUIRED_FEATURES.add(Feature.TYPED);\r\n-\t}\r\n-\tList<String> m_schemaFiles;\r\n-\tSchemaExceptionCatcher m_errors;\r\n-    ValidationHandler<A> m_validator;\r\n-    boolean m_copyTypeAnnotations = false;\r\n-    \r\n-    @Override\r\n-    public Iterable<String> getRequiredFeatures()\r\n-    {\r\n-    \treturn REQUIRED_FEATURES;\r\n-    }\r\n-\t@Override\r\n-\tpublic String getTestName() {\r\n-\t\treturn getDocFilename();\r\n-\t}\r\n-\t@Override\r\n-\tpublic void initialSetup(Map<String,Object> props)\t{\r\n-\t\tsuper.initialSetup(props);\r\n-\t\t\r\n-\t\tObject schemaFiles = props.get(SCHEMA_FILE_PROP_NAME);\r\n-\t\tif(schemaFiles == null)\r\n-\t\t{\r\n-\t\t\tthrow new IllegalStateException(\"Validation testing requires schema file location.\");\r\n-\t\t}\r\n-\t\tif(schemaFiles instanceof List)\r\n-\t\t{\r\n-\t\t\tm_schemaFiles = (List<String>)schemaFiles;\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\tm_schemaFiles = new ArrayList<String>();\r\n-\t\t\tm_schemaFiles.add((String)schemaFiles);\r\n-\t\t}\r\n-\t\t\r\n-\t\tString baseURI = (String)props.get(BASE_URI_PROP_NAME);\r\n-\t\tif(baseURI == null)\r\n-\t\t{\r\n-\t\t\tthrow new IllegalStateException(\"Base URI must be specified.\");\r\n-\t\t}\r\n-\t\tm_copyTypeAnnotations = Boolean.parseBoolean((String)props.get(COPY_TYPE_ANNOTATION_NAME));\r\n-\r\n-\t\t// Load a schema...\r\n-\t\tfinal TypedContext<N,A> typedContext = getPcx().getTypedContext(null);\r\n-\t\tfor(String schemaFile : m_schemaFiles)\r\n-\t\t{\r\n-\t        final String schemaFilePath = getBaseURI() + \"/\" + schemaFile;\r\n-\t        try {\r\n-\t\t\t\taddSchema(typedContext, new URI(schemaFilePath));\r\n-\t\t\t} catch (IOException e) {\r\n-\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t} catch (URISyntaxException e) {\r\n-\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t} catch (Exception e) {\r\n-\t\t\t\tthrow new RuntimeException(e);\r\n-\t\t\t} \r\n-\t\t}\r\n+        // Load a schema...\n+\n+        final TypedContext<N, A> typedContext = getPcx().getTypedContext(null);\n+        for (String schemaFile : m_schemaFiles)\n+        {\n+            final String schemaFilePath = getBaseURI() + \"/\" + schemaFile;\n+            try\n+            {\n+                addSchema(typedContext, new URI(schemaFilePath));\n+            }\n+            catch (IOException e)\n+            {\n+                throw new RuntimeException(e);\n+            }\n+            catch (URISyntaxException e)\n+            {\n+                throw new RuntimeException(e);\n+            }\n+            catch (Exception e)\n+            {\n+                throw new RuntimeException(e);\n+            }\n+        }\r\n         \r\n-\t\t// Create a validator...\r\n-\t\tfinal ValidatorFactory<N, A> vcf = new ValidatorFactory<N, A>(typedContext);\r\n-\t\tm_validator = vcf.newXdmContentValidator();\r\n-\t\tm_validator.setSchema(typedContext.getSchema());\r\n-\t}\r\n-\t\r\n-\t@Override\r\n-\tpublic void iterativeSetup() {\r\n-\t\tif(m_errors == null)\r\n-\t\t{\r\n-\t\t\tm_errors = new SchemaExceptionCatcher();\r\n-\t\t\tm_validator.setSchemaExceptionHandler(m_errors);\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\tm_errors.clear();\r\n-\t\t}\r\n-\t}\r\n-\t@Override\r\n-\tpublic void execute() {\r\n-\t\tgetModel().stream(getTestNode(), m_validator);\r\n-\t}\r\n-\t@Override\r\n-\tpublic Iterable<String> iterativeTeardown() {\r\n-\t\tArrayList<String> retval = new ArrayList<String>();\r\n-\t\tif(!m_errors.isEmpty())\r\n-\t\t{\r\n-\t\t\tretval.add(m_errors.size() + \" validation errors.\");\r\n-\t\t\tint errorCnt = 0;\r\n-\t\t\tfor (SchemaException ex : m_errors)\r\n-\t\t\t{\r\n-\t\t\t\tif(errorCnt == 10)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tretval.add(\"\\t\" + \"... that's all we're listing...\");\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t}\r\n-\t\t\t\terrorCnt++;\r\n-\t\t\t\tretval.add(\"\\t\" + ex.getMessage());\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn null; \r\n-\t}\r\n-\t\r\n-\t@Override\r\n-\tpublic void finalTeardown()\t{\r\n-\t\tm_schemaFiles = null;\r\n-\t\tm_errors = null;\r\n-\t\tm_validator = null;\r\n-\t\tsuper.finalTeardown();\r\n-\t}\r\n-\tprotected LinkedList<SchemaException> addSchema(TypedContext<N, A> tpcx, URI uri) throws Exception\r\n-\t{\r\n-\t\t// Load a top-level schema into the processing context.\r\n-\t\tfinal List<Resolved<InputStream>> resources = new LinkedList<Resolved<InputStream>>();\r\n-\t\tresources.add(getResolver().resolveInputStream(uri));\r\n-\r\n-\t\tfinal SchemaExceptionCatcher errors = new SchemaExceptionCatcher();\r\n-//\t\tfinal SchemaLoadOptions args = new SchemaLoadOptions();\r\n-\t\tfinal W3cXmlSchemaParser parser = new W3cXmlSchemaParser();\r\n-\t\t\r\n-\t\tparser.setComponentProvider(tpcx.getSchema().getComponentProvider());\r\n-\t\tparser.setCatalogResolver(new MyResolver(), new MyCatalog());\r\n-\t\t\r\n-\t\tfor (final Resolved<InputStream> resource : resources)\r\n-\t\t{\r\n-\t\t\tComponentBag scBag = parser.parse(resource.getLocation(), resource.getResource(), resource.getSystemId(), errors);\r\n-\t\t\tif(!errors.isEmpty())\r\n-\t\t\t{\r\n-\t\t\t\tfor(SchemaException error : errors)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tSystem.out.println(\"      \" + error.getLocalizedMessage());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\ttpcx.getSchema().register(scBag);\r\n-\t\t}\r\n-\t\treturn errors;\r\n-\t}\r\n-\tclass MyCatalog implements SchemaCatalog {\r\n-\r\n-\t\tprivate final HashMap<URI, URI> m_ns2loc = new HashMap<URI, URI>();\r\n-\t\t\r\n-\t\t@Override\r\n-\t\tpublic URI resolveLocation(URI baseURI, URI schemaLocation) {\r\n-\t\t\treturn resolveNamespaceAndSchemaLocation(baseURI, null, schemaLocation);\r\n-\t\t}\r\n-\r\n-\t\t@Override\r\n-\t\tpublic URI resolveNamespaceAndSchemaLocation(URI baseURI, URI namespace, URI schemaLocation) {\r\n-\t\t\tif(schemaLocation == null)\r\n-\t\t\t{\r\n-\t\t\t\t// No other way to look this up in this catalog.\r\n-\t\t\t\treturn m_ns2loc.get(namespace);\r\n-\t\t\t}\r\n-\t\t\tString x = baseURI.toString();\r\n-\t\t\tint index = x.lastIndexOf('/');\r\n-\t\t\tString uriString = x.substring(0, index + 1).concat(schemaLocation.toString());\r\n-\t\t\ttry {\r\n-\t\t\t\tm_ns2loc.put(namespace, schemaLocation);\r\n-\t\t\t\treturn new URI(uriString);\r\n-\t\t\t} catch (URISyntaxException e) {\r\n-\t\t\t\te.printStackTrace();\r\n-\t\t\t\treturn schemaLocation;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\tclass MyResolver implements CatalogResolver {\r\n-\t\t@Override\r\n-\t\tpublic InputStream resolveInputStream(URI catalogURI)\r\n-\t\t\t\tthrows IOException {\r\n-\t\t\tResolved<InputStream> resolved = getResolver().resolveInputStream(catalogURI);\r\n-\t\t\treturn resolved.getResource();\r\n-\t\t}\r\n-\t}\r\n-}\r\n+        // Create a validator...\n+\n+        final ValidatorFactory<N, A> vcf = new ValidatorFactory<N, A>(typedContext);\n+        m_validator = vcf.newXdmContentValidator();\n+        m_validator.setSchema(typedContext.getSchema());\n+    }\n+\n+    @Override\n+    public void iterativeSetup()\n+    {\n+        if (m_errors == null)\n+        {\n+            m_errors = new SchemaExceptionCatcher();\n+            m_validator.setSchemaExceptionHandler(m_errors);\n+        }\n+        else\n+        {\n+            m_errors.clear();\n+        }\n+    }\n+\n+    @Override\n+    public void execute()\n+    {\n+        getModel().stream(getTestNode(), m_validator);\n+    }\n+\n+    @Override\n+    public Iterable<String> iterativeTeardown()\n+    {\n+        ArrayList<String> retval = new ArrayList<String>();\n+        if (!m_errors.isEmpty())\n+        {\n+            retval.add(m_errors.size() + \" validation errors.\");\n+\n+            int errorCnt = 0;\n+            for (SchemaException ex : m_errors)\n+            {\n+                if (errorCnt == 10)\n+                {\n+                    retval.add(\"\\t\" + \"... that's all we're listing...\");\n+                    break;\n+                }\n+                errorCnt++;\n+                retval.add(\"\\t\" + ex.getMessage());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void finalTeardown()\n+    {\n+        m_schemaFiles = null;\n+        m_errors = null;\n+        m_validator = null;\n+        super.finalTeardown();\n+    }\n+\n+    protected LinkedList<SchemaException> addSchema(TypedContext<N, A> tpcx, URI uri)\n+        throws Exception\n+    {\r\n+        // Load a top-level schema into the processing context.\n+        final List<Resolved<InputStream>> resources = new LinkedList<Resolved<InputStream>>();\n+        resources.add(getResolver().resolveInputStream(uri));\n+\n+        final SchemaExceptionCatcher errors = new SchemaExceptionCatcher();\r\n+//      final SchemaLoadOptions args = new SchemaLoadOptions();\n+        final W3cXmlSchemaParser parser = new W3cXmlSchemaParser();\n+        parser.setComponentProvider(tpcx.getSchema().getComponentProvider());\n+        parser.setCatalogResolver(new MyResolver(), new MyCatalog());\n+        for (final Resolved<InputStream> resource : resources)\n+        {\n+            ComponentBag scBag = parser.parse(resource.getLocation(), resource.getResource(), resource.getSystemId(), errors);\n+            if (!errors.isEmpty())\n+            {\n+                for (SchemaException error : errors)\n+                {\n+                    System.out.println(\"      \" + error.getLocalizedMessage());\n+                }\n+            }\n+            tpcx.getSchema().register(scBag);\n+        }\n+        return errors;\n+    }\n+\n+    class MyCatalog implements SchemaCatalog\n+    {\n+        private final HashMap<URI, URI> m_ns2loc = new HashMap<URI, URI>();\n+\n+        @Override\n+        public URI resolveLocation(URI baseURI, URI schemaLocation)\n+        {\n+            return resolveNamespaceAndSchemaLocation(baseURI, null, schemaLocation);\n+        }\n+\n+        @Override\n+        public URI resolveNamespaceAndSchemaLocation(URI baseURI, URI namespace, URI schemaLocation)\n+        {\n+            if (schemaLocation == null)\n+            {\r\n+                // No other way to look this up in this catalog.\n+                return m_ns2loc.get(namespace);\n+            }\n+            String x = baseURI.toString();\n+            int index = x.lastIndexOf('/');\n+            String uriString = x.substring(0, index + 1).concat(schemaLocation.toString());\n+            try\n+            {\n+                m_ns2loc.put(namespace, schemaLocation);\n+                return new URI(uriString);\n+            }\n+            catch (URISyntaxException e)\n+            {\n+                e.printStackTrace();\n+                return schemaLocation;\n+            }\n+        }\n+    }\n+\n+    class MyResolver implements CatalogResolver\n+    {\n+\n+        @Override\n+        public InputStream resolveInputStream(URI catalogURI)\n+            throws IOException\n+        {\n+            Resolved<InputStream> resolved = getResolver().resolveInputStream(catalogURI);\n+            return resolved.getResource();\n+        }\n+\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 296
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "28",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/203/TestValidate.java\nindex 4c883a99b2c..8c400d1d039 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/203/TestValidate.java\n@@ -24,7 +24,7 @@ import org.genxdm.xs.resolve.SchemaCatalog;\n \r\n public class TestValidate<N,A> extends BaseBridgePerfTest<N,A>\r\n {\r\n-\tpublic static final String SCHEMA_FILE_PROP_NAME = \"schema\";\r\n+public static final String SCHEMA_FILE_PROP_NAME = \"schema\";\r\n \tpublic static final String COPY_TYPE_ANNOTATION_NAME = \"copyTypeAnnotations\";\r\n \tprivate static final ArrayList<String> REQUIRED_FEATURES = new ArrayList<String>();\r\n \tstatic \r\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "28",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/203/TestValidate.java\nindex 4c883a99b2c..566351c92fe 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/203/TestValidate.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/203/TestValidate.java\n@@ -24,7 +24,7 @@ import org.genxdm.xs.resolve.SchemaCatalog;\n \r\n public class TestValidate<N,A> extends BaseBridgePerfTest<N,A>\r\n {\r\n-\tpublic static final String SCHEMA_FILE_PROP_NAME = \"schema\";\r\n+    public static final String SCHEMA_FILE_PROP_NAME = \"schema\";\r\n \tpublic static final String COPY_TYPE_ANNOTATION_NAME = \"copyTypeAnnotations\";\r\n \tprivate static final ArrayList<String> REQUIRED_FEATURES = new ArrayList<String>();\r\n \tstatic \r\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}