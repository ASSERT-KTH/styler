{
    "project_name": "IQSS-dataverse",
    "error_id": "108",
    "information": {
        "errors": [
            {
                "line": "25",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "        @NamedQuery(name=\"DatasetFieldType.findByName\",\n                            query= \"SELECT dsfType FROM DatasetFieldType dsfType WHERE dsfType.name=:name\"),\n\t@NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n\t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' order by dsfType.id\"),\n        @NamedQuery(name = \"DatasetFieldType.findFacetableByMetadaBlock\",\n\t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' and dsfType.metadataBlock.id = :metadataBlockId order by dsfType.id\")",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "26",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/108/DatasetFieldType.java\nindex 842b9490784..dcc1b01def9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/108/DatasetFieldType.java\n@@ -22,7 +22,7 @@ import javax.persistence.*;\n @NamedQueries({\n         @NamedQuery(name=\"DatasetFieldType.findByName\",\n                             query= \"SELECT dsfType FROM DatasetFieldType dsfType WHERE dsfType.name=:name\"),\n-\t@NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n+                 @NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n \t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' order by dsfType.id\"),\n         @NamedQuery(name = \"DatasetFieldType.findFacetableByMetadaBlock\",\n \t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' and dsfType.metadataBlock.id = :metadataBlockId order by dsfType.id\")\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/108/DatasetFieldType.java\nindex 842b9490784..fff4ba95e6c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/108/DatasetFieldType.java\n@@ -17,594 +17,602 @@ import javax.persistence.*;\n \n /**\n  * Defines the meaning and constraints of a metadata field and its values.\n+ *\n  * @author Stephen Kraffmiller\n  */\n @NamedQueries({\n-        @NamedQuery(name=\"DatasetFieldType.findByName\",\n-                            query= \"SELECT dsfType FROM DatasetFieldType dsfType WHERE dsfType.name=:name\"),\n-\t@NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n-\t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' order by dsfType.id\"),\n-        @NamedQuery(name = \"DatasetFieldType.findFacetableByMetadaBlock\",\n-\t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' and dsfType.metadataBlock.id = :metadataBlockId order by dsfType.id\")\n+  @NamedQuery(name = \"DatasetFieldType.findByName\",\n+    query = \"SELECT dsfType FROM DatasetFieldType dsfType WHERE dsfType.name=:name\"),\n+  @NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n+    query = \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' order by dsfType.id\"),\n+  @NamedQuery(name = \"DatasetFieldType.findFacetableByMetadaBlock\",\n+    query = \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' and dsfType.metadataBlock.id = :metadataBlockId order by dsfType.id\")\n })\n @Entity\n-@Table(indexes = {@Index(columnList=\"metadatablock_id\"),@Index(columnList=\"parentdatasetfieldtype_id\")})\n+@Table(indexes = {@Index(columnList = \"metadatablock_id\"), @Index(columnList = \"parentdatasetfieldtype_id\")})\n public class DatasetFieldType implements Serializable, Comparable<DatasetFieldType> {\n \n-    /**\n-     * The set of possible metatypes of the field. Used for validation and layout.\n-     */\n-    public enum FieldType {\n-        TEXT, TEXTBOX, DATE, EMAIL, URL, FLOAT, INT, NONE\n-    };    \n-    \n-    @Id\n-    @GeneratedValue(strategy = GenerationType.IDENTITY)\n-    private Long id;\n-\n-    public Long getId() {\n-        return this.id;\n-    }\n-\n-    public void setId(Long id) {\n-        this.id = id;\n-    }\n+  /**\n+   * The set of possible metatypes of the field. Used for validation and layout.\n+   */\n+  public enum FieldType {\n+    TEXT, TEXTBOX, DATE, EMAIL, URL, FLOAT, INT, NONE\n+  }\n+\n+  ;\n \n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  private Long id;\n+\n+  public Long getId() {\n+    return this.id;\n+  }\n+\n+  public void setId(Long id) {\n+    this.id = id;\n+  }\n+\n+\n+  /**\n+   * The internal, DDI-like name, no spaces, etc.\n+   */\n+  @Column(name = \"name\", columnDefinition = \"TEXT\", nullable = false)\n+  private String name;\n+\n+  /**\n+   * A longer, human-friendlier name. Punctuation allowed.\n+   */\n+  @Column(name = \"title\", columnDefinition = \"TEXT\")\n+  private String title;\n+\n+  /**\n+   * A user-friendly Description; will be used for\n+   * mouse-overs, etc.\n+   */\n+  @Column(name = \"description\", columnDefinition = \"TEXT\")\n+  private String description;\n+  /**\n+   * Metatype of the field.\n+   */\n+  @Enumerated(EnumType.STRING)\n+  @Column(nullable = false)\n+  private FieldType fieldType;\n+  /**\n+   * Whether the value must be taken from a controlled vocabulary.\n+   */\n+  private boolean allowControlledVocabulary;\n+  /**\n+   * A watermark to be displayed in the UI.\n+   */\n+  private String watermark;\n+\n+  private String validationFormat;\n+\n+  @OneToMany(mappedBy = \"datasetFieldType\")\n+  private Set<DataverseFacet> dataverseFacets;\n+\n+  @OneToMany(mappedBy = \"datasetFieldType\")\n+  private Set<DataverseFieldTypeInputLevel> dataverseFieldTypeInputLevels;\n+\n+  @Transient\n+  private String searchValue;\n \n-    /**\n-     * The internal, DDI-like name, no spaces, etc.\n-     */\n-    @Column(name = \"name\", columnDefinition = \"TEXT\", nullable = false)\n-    private String name;\n-\n-    /**\n-     * A longer, human-friendlier name. Punctuation allowed.\n-     */\n-    @Column(name = \"title\", columnDefinition = \"TEXT\")\n-    private String title;\n-\n-    /**\n-     * A user-friendly Description; will be used for\n-     * mouse-overs, etc.\n-     */\n-    @Column(name = \"description\", columnDefinition = \"TEXT\")\n-    private String description;\n-    /**\n-     * Metatype of the field.\n-     */\n-    @Enumerated(EnumType.STRING)\n-    @Column( nullable=false )\n-    private FieldType fieldType;\n-    /**\n-     * Whether the value must be taken from a controlled vocabulary.\n-     */\n-    private boolean allowControlledVocabulary;\n-    /**\n-     * A watermark to be displayed in the UI.\n-     */\n-    private String watermark;\n-    \n-    private String validationFormat;\n-\n-    @OneToMany(mappedBy = \"datasetFieldType\")\n-    private Set<DataverseFacet> dataverseFacets;\n-    \n-    @OneToMany(mappedBy = \"datasetFieldType\")\n-    private Set<DataverseFieldTypeInputLevel> dataverseFieldTypeInputLevels;\n-    \n-    @Transient\n-    private String searchValue;\n-    \n-    @Transient\n-    private List<String> listValues;\n-\n-    @Transient\n-    private Map<String, ControlledVocabularyValue> controlledVocabularyValuesByStrValue;\n-    \n-    @Transient \n-    private boolean requiredDV;\n-    \n-    public void setRequiredDV(boolean requiredDV){\n-        this.requiredDV = requiredDV;\n-    }\n-    \n-    public boolean isRequiredDV(){\n-        return this.requiredDV;\n-    }\n-    \n-    @Transient \n-    private boolean include;\n-    \n-    public void setInclude(boolean include){\n-        this.include = include;\n-    }\n-    \n-    public boolean isInclude(){\n-        return this.include;\n-    }\n-    \n-    @Transient \n-    private List<SelectItem> optionSelectItems;\n+  @Transient\n+  private List<String> listValues;\n+\n+  @Transient\n+  private Map<String, ControlledVocabularyValue> controlledVocabularyValuesByStrValue;\n+\n+  @Transient\n+  private boolean requiredDV;\n+\n+  public void setRequiredDV(boolean requiredDV) {\n+    this.requiredDV = requiredDV;\n+  }\n+\n+  public boolean isRequiredDV() {\n+    return this.requiredDV;\n+  }\n+\n+  @Transient\n+  private boolean include;\n \n-    public List<SelectItem> getOptionSelectItems() {\n-        return optionSelectItems;\n-    }\n+  public void setInclude(boolean include) {\n+    this.include = include;\n+  }\n+\n+  public boolean isInclude() {\n+    return this.include;\n+  }\n+\n+  @Transient\n+  private List<SelectItem> optionSelectItems;\n+\n+  public List<SelectItem> getOptionSelectItems() {\n+    return optionSelectItems;\n+  }\n+\n+  public void setOptionSelectItems(List<SelectItem> optionSelectItems) {\n+    this.optionSelectItems = optionSelectItems;\n+  }\n+\n+\n+  public DatasetFieldType() {\n+  }\n+\n+  public DatasetFieldType(String name, FieldType fieldType, boolean allowMultiples) {\n+    // use the name for both default name and title\n+    this.name = name;\n+    this.title = name;\n+    this.fieldType = fieldType;\n+    this.allowMultiples = allowMultiples;\n+    childDatasetFieldTypes = new LinkedList<>();\n+  }\n+\n+  private int displayOrder;\n+  private String displayFormat;\n+\n+  public int getDisplayOrder() {\n+    return this.displayOrder;\n+  }\n+\n+  public void setDisplayOrder(int displayOrder) {\n+    this.displayOrder = displayOrder;\n+  }\n+\n+  public String getDisplayFormat() {\n+    return displayFormat;\n+  }\n+\n+  public void setDisplayFormat(String displayFormat) {\n+    this.displayFormat = displayFormat;\n+  }\n+\n+  public Boolean isSanitizeHtml() {\n+    if (this.fieldType.equals(FieldType.URL)) {\n+      return true;\n+    }\n+    return this.fieldType.equals(FieldType.TEXTBOX);\n+  }\n \n-    public void setOptionSelectItems(List<SelectItem> optionSelectItems) {\n-        this.optionSelectItems = optionSelectItems;\n+  public Boolean isEscapeOutputText() {\n+    if (this.fieldType.equals(FieldType.URL)) {\n+      return false;\n     }\n-    \n-    \n-    \n-\n-    \n-    public DatasetFieldType() {}\n-\n-    public DatasetFieldType(String name, FieldType fieldType, boolean allowMultiples) {\n-        // use the name for both default name and title\n-        this.name = name;\n-        this.title = name;\n-        this.fieldType = fieldType;\n-        this.allowMultiples = allowMultiples;\n-        childDatasetFieldTypes = new LinkedList<>();\n+    if (this.fieldType.equals(FieldType.TEXTBOX)) {\n+      return false;\n     }\n-    \n-    private int displayOrder;\n-    private String displayFormat;\n+    return !(this.fieldType.equals(FieldType.TEXT) && this.displayFormat != null && this.displayFormat.contains(\"<a\"));\n+  }\n \n-    public int getDisplayOrder() {\n-        return this.displayOrder;\n-    }\n+  public String getName() {\n+    return name;\n+  }\n \n-    public void setDisplayOrder(int displayOrder) {\n-        this.displayOrder = displayOrder;\n-    }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n \n-    public String getDisplayFormat() {\n-        return displayFormat;\n-    }\n+  public String getTitle() {\n+    return title;\n+  }\n \n-    public void setDisplayFormat(String displayFormat) {\n-        this.displayFormat = displayFormat;\n-    }\n-    \n-    public Boolean isSanitizeHtml(){\n-        if (this.fieldType.equals(FieldType.URL)){\n-            return true;\n-        }\n-        return this.fieldType.equals(FieldType.TEXTBOX);\n-    }\n-    \n-    public Boolean isEscapeOutputText(){\n-        if (this.fieldType.equals(FieldType.URL)){\n-            return false;\n+  public void setTitle(String title) {\n+    this.title = title;\n+  }\n+\n+  public String getDescription() {\n+    return description;\n+  }\n+\n+  public void setDescription(String description) {\n+    this.description = description;\n+  }\n+\n+  public boolean isAllowControlledVocabulary() {\n+    return allowControlledVocabulary;\n+  }\n+\n+  public void setAllowControlledVocabulary(boolean allowControlledVocabulary) {\n+    this.allowControlledVocabulary = allowControlledVocabulary;\n+  }\n+\n+  /**\n+   * Determines whether an instance of this field type may have multiple\n+   * values.\n+   */\n+  private boolean allowMultiples;\n+\n+  public boolean isAllowMultiples() {\n+    return this.allowMultiples;\n+  }\n+\n+  public void setAllowMultiples(boolean allowMultiples) {\n+    this.allowMultiples = allowMultiples;\n+  }\n+\n+  public FieldType getFieldType() {\n+    return fieldType;\n+  }\n+\n+  public void setFieldType(FieldType fieldType) {\n+    this.fieldType = fieldType;\n+  }\n+\n+  public String getWatermark() {\n+    return watermark;\n+  }\n+\n+  public void setWatermark(String watermark) {\n+    this.watermark = watermark;\n+  }\n+\n+  /**\n+   * Determines whether this field type may be used as a facet.\n+   */\n+  private boolean facetable;\n+\n+  public boolean isFacetable() {\n+    return facetable;\n+  }\n+\n+  public void setFacetable(boolean facetable) {\n+    this.facetable = facetable;\n+  }\n+\n+  public String getValidationFormat() {\n+    return validationFormat;\n+  }\n+\n+  public void setValidationFormat(String validationFormat) {\n+    this.validationFormat = validationFormat;\n+  }\n+\n+  /**\n+   * Determines whether this field type is displayed in the form when creating\n+   * the Dataset (or only later when editing after the initial creation).\n+   */\n+  private boolean displayOnCreate;\n+\n+  public boolean isDisplayOnCreate() {\n+    return displayOnCreate;\n+  }\n+\n+  public void setDisplayOnCreate(boolean displayOnCreate) {\n+    this.displayOnCreate = displayOnCreate;\n+  }\n+\n+  public boolean isControlledVocabulary() {\n+    return controlledVocabularyValues != null && !controlledVocabularyValues.isEmpty();\n+  }\n+\n+  /**\n+   * The {@code MetadataBlock} this field type belongs to.\n+   */\n+  @ManyToOne(cascade = CascadeType.MERGE)\n+  private MetadataBlock metadataBlock;\n+\n+  public MetadataBlock getMetadataBlock() {\n+    return metadataBlock;\n+  }\n+\n+  public void setMetadataBlock(MetadataBlock metadataBlock) {\n+    this.metadataBlock = metadataBlock;\n+  }\n+\n+  /**\n+   * A formal URI for the field used in json-ld exports\n+   */\n+  @Column(name = \"uri\", columnDefinition = \"TEXT\")\n+  private String uri;\n+\n+  public String getUri() {\n+    return uri;\n+  }\n+\n+  public void setUri(String uri) {\n+    this.uri = uri;\n+  }\n+\n+  /**\n+   * The list of controlled vocabulary terms that may be used as values for\n+   * fields of this field type.\n+   */\n+  @OneToMany(mappedBy = \"datasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  @OrderBy(\"displayOrder ASC\")\n+  private Collection<ControlledVocabularyValue> controlledVocabularyValues;\n+\n+  public Collection<ControlledVocabularyValue> getControlledVocabularyValues() {\n+    return this.controlledVocabularyValues;\n+  }\n+\n+  public void setControlledVocabularyValues(Collection<ControlledVocabularyValue> controlledVocabularyValues) {\n+    this.controlledVocabularyValues = controlledVocabularyValues;\n+  }\n+\n+  public ControlledVocabularyValue getControlledVocabularyValue(String strValue) {\n+    if (!isControlledVocabulary()) {\n+      throw new IllegalStateException(\"getControlledVocabularyValue() called on a non-controlled vocabulary type.\");\n+    }\n+    if (controlledVocabularyValuesByStrValue == null) {\n+      controlledVocabularyValuesByStrValue = new TreeMap<>();\n+      for (ControlledVocabularyValue cvv : getControlledVocabularyValues()) {\n+        controlledVocabularyValuesByStrValue.put(cvv.getStrValue(), cvv);\n+      }\n+    }\n+    return controlledVocabularyValuesByStrValue.get(strValue);\n+  }\n+\n+  /**\n+   * Collection of field types that are children of this field type.\n+   * A field type may consist of one or more child field types, but only one\n+   * parent.\n+   */\n+  @OneToMany(mappedBy = \"parentDatasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE,\n+    CascadeType.PERSIST})\n+  @OrderBy(\"displayOrder ASC\")\n+  private Collection<DatasetFieldType> childDatasetFieldTypes;\n+\n+  public Collection<DatasetFieldType> getChildDatasetFieldTypes() {\n+    return this.childDatasetFieldTypes;\n+  }\n+\n+  public void setChildDatasetFieldTypes(Collection<DatasetFieldType> childDatasetFieldTypes) {\n+    this.childDatasetFieldTypes = childDatasetFieldTypes;\n+  }\n+\n+  @ManyToOne(cascade = CascadeType.MERGE)\n+  private DatasetFieldType parentDatasetFieldType;\n+\n+  public DatasetFieldType getParentDatasetFieldType() {\n+    return parentDatasetFieldType;\n+  }\n+\n+  public void setParentDatasetFieldType(DatasetFieldType parentDatasetFieldType) {\n+    this.parentDatasetFieldType = parentDatasetFieldType;\n+  }\n+\n+\n+  public Set<DataverseFacet> getDataverseFacets() {\n+    return dataverseFacets;\n+  }\n+\n+  public void setDataverseFacets(Set<DataverseFacet> dataverseFacets) {\n+    this.dataverseFacets = dataverseFacets;\n+  }\n+\n+  public Set<DataverseFieldTypeInputLevel> getDataverseFieldTypeInputLevels() {\n+    return dataverseFieldTypeInputLevels;\n+  }\n+\n+  public void setDataverseFieldTypeInputLevels(Set<DataverseFieldTypeInputLevel> dataverseFieldTypeInputLevels) {\n+    this.dataverseFieldTypeInputLevels = dataverseFieldTypeInputLevels;\n+  }\n+\n+  public String getSearchValue() {\n+    return searchValue;\n+  }\n+\n+  public void setSearchValue(String searchValue) {\n+    this.searchValue = searchValue;\n+  }\n+\n+  public List<String> getListValues() {\n+    return listValues;\n+  }\n+\n+  public void setListValues(List<String> listValues) {\n+    this.listValues = listValues;\n+  }\n+\n+  /**\n+   * Determines whether fields of this field type are always required. A\n+   * dataverse may set some fields required, but only if this is false.\n+   */\n+  private boolean required;\n+\n+  public boolean isRequired() {\n+    return this.required;\n+  }\n+\n+  public void setRequired(boolean required) {\n+    this.required = required;\n+  }\n+\n+  private boolean advancedSearchFieldType;\n+\n+  public boolean isAdvancedSearchFieldType() {\n+    return this.advancedSearchFieldType;\n+  }\n+\n+  public void setAdvancedSearchFieldType(boolean advancedSearchFieldType) {\n+    this.advancedSearchFieldType = advancedSearchFieldType;\n+  }\n+\n+  public boolean isPrimitive() {\n+    return this.childDatasetFieldTypes.isEmpty();\n+  }\n+\n+  public boolean isCompound() {\n+    return !this.childDatasetFieldTypes.isEmpty();\n+  }\n+\n+  public boolean isChild() {\n+    return this.parentDatasetFieldType != null;\n+  }\n+\n+  public boolean isSubField() {\n+    return this.parentDatasetFieldType != null;\n+  }\n+\n+  public boolean isHasChildren() {\n+    return !this.childDatasetFieldTypes.isEmpty();\n+  }\n+\n+  public boolean isHasRequiredChildren() {\n+    if (this.childDatasetFieldTypes.isEmpty()) {\n+      return false;\n+    } else {\n+      for (DatasetFieldType dsftC : this.childDatasetFieldTypes) {\n+        if (dsftC.isRequired()) {\n+          return true;\n         }\n-        if (this.fieldType.equals(FieldType.TEXTBOX)){\n-            return false;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public boolean isHasParent() {\n+    return this.parentDatasetFieldType != null;\n+  }\n+\n+  public int hashCode() {\n+    int hash = 0;\n+    hash += (this.id != null ? this.id.hashCode() : 0);\n+    return hash;\n+  }\n+\n+  public boolean equals(Object object) {\n+    // TODO: Warning - this method won't work in the case the id fields are not set\n+    if (!(object instanceof DatasetFieldType)) {\n+      return false;\n+    }\n+    DatasetFieldType other = (DatasetFieldType) object;\n+    if (this.id != other.id && (this.id == null || !this.id.equals(other.id))) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * List of fields that use this field type. If this field type is removed,\n+   * these fields will be removed too.\n+   */\n+  @OneToMany(mappedBy = \"datasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private List<DatasetField> datasetFields;\n+\n+  public List<DatasetField> getDatasetFields() {\n+    return datasetFields;\n+  }\n+\n+  public void setDatasetFields(List<DatasetField> datasetFieldValues) {\n+    this.datasetFields = datasetFieldValues;\n+  }\n+\n+  @OneToMany(mappedBy = \"datasetField\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private List<DatasetFieldDefaultValue> datasetFieldDefaultValues;\n+\n+  public List<DatasetFieldDefaultValue> getDatasetFieldDefaultValues() {\n+    return datasetFieldDefaultValues;\n+  }\n+\n+  public void setDatasetFieldDefaultValues(List<DatasetFieldDefaultValue> datasetFieldDefaultValues) {\n+    this.datasetFieldDefaultValues = datasetFieldDefaultValues;\n+  }\n+\n+  @Override\n+  public int compareTo(DatasetFieldType o) {\n+    return Integer.compare(this.getDisplayOrder(), (o.getDisplayOrder()));\n+  }\n+\n+  public String getDisplayName() {\n+    if (isHasParent() && !parentDatasetFieldType.getTitle().equals(title)) {\n+      return parentDatasetFieldType.getLocaleTitle() + \" \" + getLocaleTitle();\n+    } else {\n+      return getLocaleTitle();\n+    }\n+  }\n+\n+  public SolrField getSolrField() {\n+    SolrField.SolrType solrType = SolrField.SolrType.TEXT_EN;\n+    if (fieldType != null) {\n+\n+      /**\n+       * @todo made more decisions based on fieldType: index as dates,\n+       * integers, and floats so we can do range queries etc.\n+       */\n+      if (fieldType.equals(FieldType.DATE)) {\n+        solrType = SolrField.SolrType.DATE;\n+      } else if (fieldType.equals(FieldType.EMAIL)) {\n+        solrType = SolrField.SolrType.EMAIL;\n+      }\n+\n+      Boolean parentAllowsMultiplesBoolean = false;\n+      if (isHasParent()) {\n+        if (getParentDatasetFieldType() != null) {\n+          DatasetFieldType parent = getParentDatasetFieldType();\n+          parentAllowsMultiplesBoolean = parent.isAllowMultiples();\n         }\n-        return !(this.fieldType.equals(FieldType.TEXT) &&  this.displayFormat != null &&this.displayFormat.contains(\"<a\"));\n-    }\n-    \n-    public String getName() {\n-        return name;\n-    }\n-\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getTitle() {\n+      }\n+\n+      boolean makeSolrFieldMultivalued;\n+      // http://stackoverflow.com/questions/5800762/what-is-the-use-of-multivalued-field-type-in-solr\n+      if (allowMultiples || parentAllowsMultiplesBoolean) {\n+        makeSolrFieldMultivalued = true;\n+      } else {\n+        makeSolrFieldMultivalued = false;\n+      }\n+\n+      return new SolrField(name, solrType, makeSolrFieldMultivalued, facetable);\n+\n+    } else {\n+      /**\n+       * @todo: clean this up\n+       */\n+      String oddValue = name + getTmpNullFieldTypeIdentifier();\n+      boolean makeSolrFieldMultivalued = false;\n+      SolrField solrField = new SolrField(oddValue, solrType, makeSolrFieldMultivalued, facetable);\n+      return solrField;\n+    }\n+  }\n+\n+  public String getLocaleTitle() {\n+    if (getMetadataBlock() == null) {\n+      return title;\n+    } else {\n+      try {\n+        return BundleUtil\n+          .getStringFromPropertyFile(\"datasetfieldtype.\" + getName() + \".title\", getMetadataBlock().getName());\n+      } catch (MissingResourceException e) {\n         return title;\n-    }\n-\n-    public void setTitle(String title) {\n-        this.title = title;\n-    }\n-\n-    public String getDescription() {\n+      }\n+    }\n+  }\n+\n+  public String getLocaleDescription() {\n+    if (getMetadataBlock() == null) {\n+      return description;\n+    } else {\n+      try {\n+        return BundleUtil\n+          .getStringFromPropertyFile(\"datasetfieldtype.\" + getName() + \".description\", getMetadataBlock().getName());\n+      } catch (MissingResourceException e) {\n         return description;\n-    }\n-\n-    public void setDescription(String description) {\n-        this.description = description;\n-    }\n-    \n-    public boolean isAllowControlledVocabulary() {\n-        return allowControlledVocabulary;\n-    }\n-\n-    public void setAllowControlledVocabulary(boolean allowControlledVocabulary) {\n-        this.allowControlledVocabulary = allowControlledVocabulary;\n-    }\n-\n-    /**\n-     * Determines whether an instance of this field type may have multiple\n-     * values.\n-     */\n-    private boolean allowMultiples;\n-\n-    public boolean isAllowMultiples() {\n-        return this.allowMultiples;\n-    }\n-\n-    public void setAllowMultiples(boolean allowMultiples) {\n-        this.allowMultiples = allowMultiples;\n-    }\n-\n-    public FieldType getFieldType() {\n-        return fieldType;\n-    }\n-\n-    public void setFieldType(FieldType fieldType) {\n-        this.fieldType = fieldType;\n-    }\n-    \n-    public String getWatermark() {\n+      }\n+    }\n+  }\n+\n+  public String getLocaleWatermark() {\n+    if (getMetadataBlock() == null) {\n+      return watermark;\n+    } else {\n+      try {\n+        return BundleUtil\n+          .getStringFromPropertyFile(\"datasetfieldtype.\" + getName() + \".watermark\", getMetadataBlock().getName());\n+      } catch (MissingResourceException e) {\n         return watermark;\n+      }\n     }\n+  }\n \n-    public void setWatermark(String watermark) {\n-        this.watermark = watermark;\n-    }\n-    /**\n-     * Determines whether this field type may be used as a facet.\n-     */\n-    private boolean facetable;\n-\n-    public boolean isFacetable() {\n-        return facetable;\n-    }\n-\n-    public void setFacetable(boolean facetable) {\n-        this.facetable = facetable;\n-    }\n-    \n-    public String getValidationFormat() {\n-        return validationFormat;\n-    }\n-\n-    public void setValidationFormat(String validationFormat) {\n-        this.validationFormat = validationFormat;\n-    }\n-\n-    /**\n-     * Determines whether this field type is displayed in the form when creating\n-     * the Dataset (or only later when editing after the initial creation).\n-     */\n-    private boolean displayOnCreate;\n-\n-    public boolean isDisplayOnCreate() {\n-        return displayOnCreate;\n-    }\n-\n-    public void setDisplayOnCreate(boolean displayOnCreate) {\n-        this.displayOnCreate = displayOnCreate;\n-    }\n-    \n-    public boolean isControlledVocabulary() {\n-        return controlledVocabularyValues != null && !controlledVocabularyValues.isEmpty();\n-    }\n-\n-    /**\n-     * The {@code MetadataBlock} this field type belongs to.\n-     */\n-    @ManyToOne(cascade = CascadeType.MERGE)\n-    private MetadataBlock metadataBlock;\n-\n-    public MetadataBlock getMetadataBlock() {\n-        return metadataBlock;\n-    }\n-\n-    public void setMetadataBlock(MetadataBlock metadataBlock) {\n-        this.metadataBlock = metadataBlock;\n-    }\n-\n-    /**\n-     * A formal URI for the field used in json-ld exports\n-     */\n-    @Column(name = \"uri\", columnDefinition = \"TEXT\")\n-    private String uri;\n-\n-    public String getUri() {\n-    \treturn uri;\n-    }\n-\n-    public void setUri(String uri) {\n-    \tthis.uri=uri;\n-    }\n-    \n-    /**\n-     * The list of controlled vocabulary terms that may be used as values for\n-     * fields of this field type.\n-     */\n-   @OneToMany(mappedBy = \"datasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-   @OrderBy(\"displayOrder ASC\")\n-    private Collection<ControlledVocabularyValue> controlledVocabularyValues;\n-\n-    public Collection<ControlledVocabularyValue> getControlledVocabularyValues() {\n-        return this.controlledVocabularyValues;\n-    }\n-\n-    public void setControlledVocabularyValues(Collection<ControlledVocabularyValue> controlledVocabularyValues) {\n-        this.controlledVocabularyValues = controlledVocabularyValues;\n-    }\n-    \n-    public ControlledVocabularyValue getControlledVocabularyValue( String strValue ) {\n-        if ( ! isControlledVocabulary() ) {\n-            throw new IllegalStateException(\"getControlledVocabularyValue() called on a non-controlled vocabulary type.\");\n-        }\n-        if ( controlledVocabularyValuesByStrValue == null ) {\n-            controlledVocabularyValuesByStrValue = new TreeMap<>();               \n-            for ( ControlledVocabularyValue cvv : getControlledVocabularyValues() ) {\n-                controlledVocabularyValuesByStrValue.put( cvv.getStrValue(), cvv);\n-            }\n-        }\n-        return controlledVocabularyValuesByStrValue.get(strValue);\n-    }\n-\n-    /**\n-     * Collection of field types that are children of this field type.\n-     * A field type may consist of one or more child field types, but only one\n-     * parent.\n-     */\n-    @OneToMany(mappedBy = \"parentDatasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    @OrderBy(\"displayOrder ASC\")\n-    private Collection<DatasetFieldType> childDatasetFieldTypes;\n-\n-    public Collection<DatasetFieldType> getChildDatasetFieldTypes() {\n-        return this.childDatasetFieldTypes;\n-    }\n-\n-    public void setChildDatasetFieldTypes(Collection<DatasetFieldType> childDatasetFieldTypes) {\n-        this.childDatasetFieldTypes = childDatasetFieldTypes;\n-    }\n-\n-    @ManyToOne(cascade = CascadeType.MERGE)\n-    private DatasetFieldType parentDatasetFieldType;\n-\n-    public DatasetFieldType getParentDatasetFieldType() {\n-        return parentDatasetFieldType;\n-    }\n-\n-    public void setParentDatasetFieldType(DatasetFieldType parentDatasetFieldType) {\n-        this.parentDatasetFieldType = parentDatasetFieldType;\n-    }\n-\n-\n-    public Set<DataverseFacet> getDataverseFacets() {\n-        return dataverseFacets;\n-    }\n-\n-    public void setDataverseFacets(Set<DataverseFacet> dataverseFacets) {\n-        this.dataverseFacets = dataverseFacets;\n-    }\n-    \n-    public Set<DataverseFieldTypeInputLevel> getDataverseFieldTypeInputLevels() {\n-        return dataverseFieldTypeInputLevels;\n-    }\n-\n-    public void setDataverseFieldTypeInputLevels(Set<DataverseFieldTypeInputLevel> dataverseFieldTypeInputLevels) {\n-        this.dataverseFieldTypeInputLevels = dataverseFieldTypeInputLevels;\n-    }\n-\n-    public String getSearchValue() {\n-        return searchValue;\n-    }\n-\n-    public void setSearchValue(String searchValue) {\n-        this.searchValue = searchValue;\n-    }\n-\n-    public List<String> getListValues() {\n-        return listValues;\n-    }\n+  // help us identify fields that have null fieldType values\n+  public String getTmpNullFieldTypeIdentifier() {\n+    return \"NullFieldType_s\";\n+  }\n \n-    public void setListValues(List<String> listValues) {\n-        this.listValues = listValues;\n-    }\n-    /**\n-     * Determines whether fields of this field type are always required. A\n-     * dataverse may set some fields required, but only if this is false.\n-     */\n-    private boolean required;\n-\n-    public boolean isRequired() {\n-        return this.required;\n-    }\n-\n-    public void setRequired(boolean required) {\n-        this.required = required;\n-    }\n-\n-    private boolean advancedSearchFieldType;\n-\n-    public boolean isAdvancedSearchFieldType() {\n-        return this.advancedSearchFieldType;\n-    }\n-\n-    public void setAdvancedSearchFieldType(boolean advancedSearchFieldType) {\n-        this.advancedSearchFieldType = advancedSearchFieldType;\n-    }\n-\n-    public boolean isPrimitive() {\n-        return this.childDatasetFieldTypes.isEmpty();\n-    }\n-    \n-    public boolean isCompound() {\n-         return !this.childDatasetFieldTypes.isEmpty();       \n-    }\n-    \n-    public boolean isChild() {\n-        return this.parentDatasetFieldType != null;        \n-    }    \n-    \n-    public boolean isSubField() {\n-        return this.parentDatasetFieldType != null;        \n-    }\n-    \n-    public boolean isHasChildren() {\n-        return !this.childDatasetFieldTypes.isEmpty();\n-    }\n-    \n-    public boolean isHasRequiredChildren() {\n-        if (this.childDatasetFieldTypes.isEmpty()){\n-            return false;\n-        } else {\n-            for (DatasetFieldType dsftC : this.childDatasetFieldTypes){\n-                if (dsftC.isRequired()) return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public boolean isHasParent() {\n-        return this.parentDatasetFieldType != null;\n-    }\n-\n-    public int hashCode() {\n-        int hash = 0;\n-        hash += (this.id != null ? this.id.hashCode() : 0);\n-        return hash;\n-    }\n-\n-    public boolean equals(Object object) {\n-        // TODO: Warning - this method won't work in the case the id fields are not set\n-        if (!(object instanceof DatasetFieldType)) {\n-            return false;\n-        }\n-        DatasetFieldType other = (DatasetFieldType) object;\n-        if (this.id != other.id && (this.id == null || !this.id.equals(other.id))) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * List of fields that use this field type. If this field type is removed,\n-     * these fields will be removed too.\n-     */\n-    @OneToMany(mappedBy = \"datasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    private List<DatasetField> datasetFields;\n-\n-    public List<DatasetField> getDatasetFields() {\n-        return datasetFields;\n-    }\n-\n-    public void setDatasetFields(List<DatasetField> datasetFieldValues) {\n-        this.datasetFields = datasetFieldValues;\n-    }\n-\n-    @OneToMany(mappedBy = \"datasetField\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    private List<DatasetFieldDefaultValue> datasetFieldDefaultValues;\n-\n-    public List<DatasetFieldDefaultValue> getDatasetFieldDefaultValues() {\n-        return datasetFieldDefaultValues;\n-    }\n-\n-    public void setDatasetFieldDefaultValues(List<DatasetFieldDefaultValue> datasetFieldDefaultValues) {\n-        this.datasetFieldDefaultValues = datasetFieldDefaultValues;\n-    }\n-\n-    @Override\n-    public int compareTo(DatasetFieldType o) {\n-        return Integer.compare(this.getDisplayOrder(), (o.getDisplayOrder()));\n-    }\n-    \n-    public String getDisplayName() {\n-        if (isHasParent() && !parentDatasetFieldType.getTitle().equals(title)) {\n-        return parentDatasetFieldType.getLocaleTitle()  + \" \" + getLocaleTitle();\n-        } else {\n-            return getLocaleTitle();\n-        }\n-    }\n-\n-    public SolrField getSolrField() {\n-        SolrField.SolrType solrType = SolrField.SolrType.TEXT_EN;\n-        if (fieldType != null) {\n-\n-            /**\n-             * @todo made more decisions based on fieldType: index as dates,\n-             * integers, and floats so we can do range queries etc.\n-             */\n-            if (fieldType.equals(FieldType.DATE)) {\n-                solrType = SolrField.SolrType.DATE;\n-            } else if (fieldType.equals(FieldType.EMAIL)) {\n-                solrType = SolrField.SolrType.EMAIL;\n-            }\n-\n-            Boolean parentAllowsMultiplesBoolean = false;\n-            if (isHasParent()) {\n-                if (getParentDatasetFieldType() != null) {\n-                    DatasetFieldType parent = getParentDatasetFieldType();\n-                    parentAllowsMultiplesBoolean = parent.isAllowMultiples();\n-                }\n-            }\n-            \n-            boolean makeSolrFieldMultivalued;\n-            // http://stackoverflow.com/questions/5800762/what-is-the-use-of-multivalued-field-type-in-solr\n-            if (allowMultiples || parentAllowsMultiplesBoolean) {\n-                makeSolrFieldMultivalued = true;\n-            } else {\n-                makeSolrFieldMultivalued = false;\n-            }\n-\n-            return new SolrField(name, solrType, makeSolrFieldMultivalued, facetable);\n-\n-        } else {\n-            /**\n-             * @todo: clean this up\n-             */\n-            String oddValue = name + getTmpNullFieldTypeIdentifier();\n-            boolean makeSolrFieldMultivalued = false;\n-            SolrField solrField = new SolrField(oddValue, solrType, makeSolrFieldMultivalued, facetable);\n-            return solrField;\n-        }\n-    }\n-\n-    public String getLocaleTitle() {\n-        if(getMetadataBlock()  == null) {\n-            return title;\n-        }\n-        else {\n-            try {\n-                return BundleUtil.getStringFromPropertyFile(\"datasetfieldtype.\" + getName() + \".title\", getMetadataBlock().getName());\n-            } catch (MissingResourceException e) {\n-                return title;\n-            }\n-        }\n-    }\n-\n-    public String getLocaleDescription() {\n-        if(getMetadataBlock()  == null) {\n-            return description;\n-        } else {\n-            try {\n-                return BundleUtil.getStringFromPropertyFile(\"datasetfieldtype.\" + getName() + \".description\", getMetadataBlock().getName());\n-            } catch (MissingResourceException e) {\n-                return description;\n-            }\n-        }\n-    }\n-\n-    public String getLocaleWatermark()    {\n-        if(getMetadataBlock()  == null) {\n-            return watermark;\n-        } else {\n-            try {\n-                return BundleUtil.getStringFromPropertyFile(\"datasetfieldtype.\" + getName() + \".watermark\", getMetadataBlock().getName());\n-            } catch (MissingResourceException e) {\n-                return watermark;\n-            }\n-        }\n-    }\n-\n-    // help us identify fields that have null fieldType values\n-    public String getTmpNullFieldTypeIdentifier() {\n-        return \"NullFieldType_s\";\n-    }\n-    \n-    @Override\n-    public String toString() {\n-        return \"[DatasetFieldType name:\" + getName() + \" id:\" + getId() + \"]\";\n-    }\n+  @Override\n+  public String toString() {\n+    return \"[DatasetFieldType name:\" + getName() + \" id:\" + getId() + \"]\";\n+  }\n }\n",
            "diff_size": 1031
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/108/DatasetFieldType.java\nindex 842b9490784..922940f3366 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/108/DatasetFieldType.java\n@@ -2,9 +2,7 @@ package edu.harvard.iq.dataverse;\n \n import edu.harvard.iq.dataverse.search.SolrField;\n import edu.harvard.iq.dataverse.util.BundleUtil;\n-\n import java.util.Collection;\n-\n import java.io.Serializable;\n import java.util.LinkedList;\n import java.util.List;\n@@ -19,25 +17,28 @@ import javax.persistence.*;\n  * Defines the meaning and constraints of a metadata field and its values.\n  * @author Stephen Kraffmiller\n  */\n+\n+\n @NamedQueries({\n-        @NamedQuery(name=\"DatasetFieldType.findByName\",\n-                            query= \"SELECT dsfType FROM DatasetFieldType dsfType WHERE dsfType.name=:name\"),\n-\t@NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n-\t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' order by dsfType.id\"),\n-        @NamedQuery(name = \"DatasetFieldType.findFacetableByMetadaBlock\",\n-\t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' and dsfType.metadataBlock.id = :metadataBlockId order by dsfType.id\")\n+    @NamedQuery(name = \"DatasetFieldType.findByName\",\n+        query = \"SELECT dsfType FROM DatasetFieldType dsfType WHERE dsfType.name=:name\"),\n+    @NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n+        query = \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' order by dsfType.id\"),\n+    @NamedQuery(name = \"DatasetFieldType.findFacetableByMetadaBlock\",\n+        query = \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' and dsfType.metadataBlock.id = :metadataBlockId order by dsfType.id\")\n })\n @Entity\n-@Table(indexes = {@Index(columnList=\"metadatablock_id\"),@Index(columnList=\"parentdatasetfieldtype_id\")})\n+@Table(indexes = {@Index(columnList = \"metadatablock_id\"), @Index(columnList = \"parentdatasetfieldtype_id\")})\n public class DatasetFieldType implements Serializable, Comparable<DatasetFieldType> {\n \n     /**\n      * The set of possible metatypes of the field. Used for validation and layout.\n      */\n+\n     public enum FieldType {\n         TEXT, TEXTBOX, DATE, EMAIL, URL, FLOAT, INT, NONE\n-    };    \n-    \n+    };\n+\n     @Id\n     @GeneratedValue(strategy = GenerationType.IDENTITY)\n     private Long id;\n@@ -54,12 +55,14 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     /**\n      * The internal, DDI-like name, no spaces, etc.\n      */\n+\n     @Column(name = \"name\", columnDefinition = \"TEXT\", nullable = false)\n     private String name;\n \n     /**\n      * A longer, human-friendlier name. Punctuation allowed.\n      */\n+\n     @Column(name = \"title\", columnDefinition = \"TEXT\")\n     private String title;\n \n@@ -67,13 +70,15 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n      * A user-friendly Description; will be used for\n      * mouse-overs, etc.\n      */\n+\n     @Column(name = \"description\", columnDefinition = \"TEXT\")\n     private String description;\n     /**\n      * Metatype of the field.\n      */\n+\n     @Enumerated(EnumType.STRING)\n-    @Column( nullable=false )\n+    @Column(nullable = false)\n     private FieldType fieldType;\n     /**\n      * Whether the value must be taken from a controlled vocabulary.\n@@ -83,47 +88,46 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n      * A watermark to be displayed in the UI.\n      */\n     private String watermark;\n-    \n     private String validationFormat;\n \n     @OneToMany(mappedBy = \"datasetFieldType\")\n     private Set<DataverseFacet> dataverseFacets;\n-    \n+\n     @OneToMany(mappedBy = \"datasetFieldType\")\n     private Set<DataverseFieldTypeInputLevel> dataverseFieldTypeInputLevels;\n-    \n+\n     @Transient\n     private String searchValue;\n-    \n+\n     @Transient\n     private List<String> listValues;\n \n     @Transient\n     private Map<String, ControlledVocabularyValue> controlledVocabularyValuesByStrValue;\n-    \n-    @Transient \n+\n+    @Transient\n     private boolean requiredDV;\n-    \n-    public void setRequiredDV(boolean requiredDV){\n+\n+    public void setRequiredDV(boolean requiredDV) {\n         this.requiredDV = requiredDV;\n     }\n-    \n-    public boolean isRequiredDV(){\n+\n+    public boolean isRequiredDV() {\n         return this.requiredDV;\n     }\n-    \n-    @Transient \n+\n+    @Transient\n     private boolean include;\n-    \n-    public void setInclude(boolean include){\n+\n+    public void setInclude(boolean include) {\n         this.include = include;\n     }\n-    \n-    public boolean isInclude(){\n+\n+    public boolean isInclude() {\n         return this.include;\n     }\n-    \n-    @Transient \n+\n+    @Transient\n     private List<SelectItem> optionSelectItems;\n \n     public List<SelectItem> getOptionSelectItems() {\n@@ -133,11 +137,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public void setOptionSelectItems(List<SelectItem> optionSelectItems) {\n         this.optionSelectItems = optionSelectItems;\n     }\n-    \n-    \n-    \n \n-    \n     public DatasetFieldType() {}\n \n     public DatasetFieldType(String name, FieldType fieldType, boolean allowMultiples) {\n@@ -148,7 +148,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n         this.allowMultiples = allowMultiples;\n         childDatasetFieldTypes = new LinkedList<>();\n     }\n-    \n+\n     private int displayOrder;\n     private String displayFormat;\n \n@@ -167,24 +167,25 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public void setDisplayFormat(String displayFormat) {\n         this.displayFormat = displayFormat;\n     }\n-    \n-    public Boolean isSanitizeHtml(){\n-        if (this.fieldType.equals(FieldType.URL)){\n+\n+    public Boolean isSanitizeHtml() {\n+        if (this.fieldType.equals(FieldType.URL)) {\n             return true;\n         }\n         return this.fieldType.equals(FieldType.TEXTBOX);\n     }\n-    \n-    public Boolean isEscapeOutputText(){\n-        if (this.fieldType.equals(FieldType.URL)){\n+\n+    public Boolean isEscapeOutputText() {\n+        if (this.fieldType.equals(FieldType.URL)) {\n             return false;\n         }\n-        if (this.fieldType.equals(FieldType.TEXTBOX)){\n+\n+        if (this.fieldType.equals(FieldType.TEXTBOX)) {\n             return false;\n         }\n-        return !(this.fieldType.equals(FieldType.TEXT) &&  this.displayFormat != null &&this.displayFormat.contains(\"<a\"));\n+        return !(this.fieldType.equals(FieldType.TEXT) && this.displayFormat != null && this.displayFormat.contains(\"<a\"));\n     }\n-    \n+\n     public String getName() {\n         return name;\n     }\n@@ -208,7 +209,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public void setDescription(String description) {\n         this.description = description;\n     }\n-    \n+\n     public boolean isAllowControlledVocabulary() {\n         return allowControlledVocabulary;\n     }\n@@ -221,6 +222,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n      * Determines whether an instance of this field type may have multiple\n      * values.\n      */\n+\n     private boolean allowMultiples;\n \n     public boolean isAllowMultiples() {\n@@ -238,7 +240,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public void setFieldType(FieldType fieldType) {\n         this.fieldType = fieldType;\n     }\n-    \n+\n     public String getWatermark() {\n         return watermark;\n     }\n@@ -249,6 +251,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     /**\n      * Determines whether this field type may be used as a facet.\n      */\n+\n     private boolean facetable;\n \n     public boolean isFacetable() {\n@@ -258,7 +261,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public void setFacetable(boolean facetable) {\n         this.facetable = facetable;\n     }\n-    \n+\n     public String getValidationFormat() {\n         return validationFormat;\n     }\n@@ -271,6 +274,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n      * Determines whether this field type is displayed in the form when creating\n      * the Dataset (or only later when editing after the initial creation).\n      */\n+\n     private boolean displayOnCreate;\n \n     public boolean isDisplayOnCreate() {\n@@ -280,7 +284,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public void setDisplayOnCreate(boolean displayOnCreate) {\n         this.displayOnCreate = displayOnCreate;\n     }\n-    \n+\n     public boolean isControlledVocabulary() {\n         return controlledVocabularyValues != null && !controlledVocabularyValues.isEmpty();\n     }\n@@ -288,6 +292,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     /**\n      * The {@code MetadataBlock} this field type belongs to.\n      */\n+\n     @ManyToOne(cascade = CascadeType.MERGE)\n     private MetadataBlock metadataBlock;\n \n@@ -302,23 +307,25 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     /**\n      * A formal URI for the field used in json-ld exports\n      */\n+\n     @Column(name = \"uri\", columnDefinition = \"TEXT\")\n     private String uri;\n \n     public String getUri() {\n-    \treturn uri;\n+        return uri;\n     }\n \n     public void setUri(String uri) {\n-    \tthis.uri=uri;\n+        this.uri = uri;\n     }\n     \n     /**\n      * The list of controlled vocabulary terms that may be used as values for\n      * fields of this field type.\n      */\n-   @OneToMany(mappedBy = \"datasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-   @OrderBy(\"displayOrder ASC\")\n+\n+    @OneToMany(mappedBy = \"datasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+    @OrderBy(\"displayOrder ASC\")\n     private Collection<ControlledVocabularyValue> controlledVocabularyValues;\n \n     public Collection<ControlledVocabularyValue> getControlledVocabularyValues() {\n@@ -328,15 +335,17 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public void setControlledVocabularyValues(Collection<ControlledVocabularyValue> controlledVocabularyValues) {\n         this.controlledVocabularyValues = controlledVocabularyValues;\n     }\n-    \n-    public ControlledVocabularyValue getControlledVocabularyValue( String strValue ) {\n-        if ( ! isControlledVocabulary() ) {\n+\n+    public ControlledVocabularyValue getControlledVocabularyValue(String strValue) {\n+        if (!isControlledVocabulary()) {\n             throw new IllegalStateException(\"getControlledVocabularyValue() called on a non-controlled vocabulary type.\");\n         }\n-        if ( controlledVocabularyValuesByStrValue == null ) {\n-            controlledVocabularyValuesByStrValue = new TreeMap<>();               \n-            for ( ControlledVocabularyValue cvv : getControlledVocabularyValues() ) {\n-                controlledVocabularyValuesByStrValue.put( cvv.getStrValue(), cvv);\n+\n+        if (controlledVocabularyValuesByStrValue == null) {\n+            controlledVocabularyValuesByStrValue = new TreeMap<>();\n+\n+            for (ControlledVocabularyValue cvv : getControlledVocabularyValues()) {\n+                controlledVocabularyValuesByStrValue.put(cvv.getStrValue(), cvv);\n             }\n         }\n         return controlledVocabularyValuesByStrValue.get(strValue);\n@@ -347,6 +356,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n      * A field type may consist of one or more child field types, but only one\n      * parent.\n      */\n+\n     @OneToMany(mappedBy = \"parentDatasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n     @OrderBy(\"displayOrder ASC\")\n     private Collection<DatasetFieldType> childDatasetFieldTypes;\n@@ -370,7 +380,6 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n         this.parentDatasetFieldType = parentDatasetFieldType;\n     }\n \n-\n     public Set<DataverseFacet> getDataverseFacets() {\n         return dataverseFacets;\n     }\n@@ -378,7 +387,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public void setDataverseFacets(Set<DataverseFacet> dataverseFacets) {\n         this.dataverseFacets = dataverseFacets;\n     }\n-    \n+\n     public Set<DataverseFieldTypeInputLevel> getDataverseFieldTypeInputLevels() {\n         return dataverseFieldTypeInputLevels;\n     }\n@@ -406,6 +415,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n      * Determines whether fields of this field type are always required. A\n      * dataverse may set some fields required, but only if this is false.\n      */\n+\n     private boolean required;\n \n     public boolean isRequired() {\n@@ -429,28 +439,28 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public boolean isPrimitive() {\n         return this.childDatasetFieldTypes.isEmpty();\n     }\n-    \n+\n     public boolean isCompound() {\n-         return !this.childDatasetFieldTypes.isEmpty();       \n+        return !this.childDatasetFieldTypes.isEmpty();\n     }\n-    \n+\n     public boolean isChild() {\n-        return this.parentDatasetFieldType != null;        \n-    }    \n-    \n+        return this.parentDatasetFieldType != null;\n+    }\n+\n     public boolean isSubField() {\n-        return this.parentDatasetFieldType != null;        \n+        return this.parentDatasetFieldType != null;\n     }\n-    \n+\n     public boolean isHasChildren() {\n         return !this.childDatasetFieldTypes.isEmpty();\n     }\n-    \n+\n     public boolean isHasRequiredChildren() {\n-        if (this.childDatasetFieldTypes.isEmpty()){\n+        if (this.childDatasetFieldTypes.isEmpty()) {\n             return false;\n         } else {\n-            for (DatasetFieldType dsftC : this.childDatasetFieldTypes){\n+            for (DatasetFieldType dsftC : this.childDatasetFieldTypes) {\n                 if (dsftC.isRequired()) return true;\n             }\n         }\n@@ -472,6 +482,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n         if (!(object instanceof DatasetFieldType)) {\n             return false;\n         }\n+\n         DatasetFieldType other = (DatasetFieldType) object;\n         if (this.id != other.id && (this.id == null || !this.id.equals(other.id))) {\n             return false;\n@@ -483,6 +494,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n      * List of fields that use this field type. If this field type is removed,\n      * these fields will be removed too.\n      */\n+\n     @OneToMany(mappedBy = \"datasetFieldType\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n     private List<DatasetField> datasetFields;\n \n@@ -509,10 +521,10 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     public int compareTo(DatasetFieldType o) {\n         return Integer.compare(this.getDisplayOrder(), (o.getDisplayOrder()));\n     }\n-    \n+\n     public String getDisplayName() {\n         if (isHasParent() && !parentDatasetFieldType.getTitle().equals(title)) {\n-        return parentDatasetFieldType.getLocaleTitle()  + \" \" + getLocaleTitle();\n+            return parentDatasetFieldType.getLocaleTitle() + \" \" + getLocaleTitle();\n         } else {\n             return getLocaleTitle();\n         }\n@@ -539,7 +551,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n                     parentAllowsMultiplesBoolean = parent.isAllowMultiples();\n                 }\n             }\n-            \n+\n             boolean makeSolrFieldMultivalued;\n             // http://stackoverflow.com/questions/5800762/what-is-the-use-of-multivalued-field-type-in-solr\n             if (allowMultiples || parentAllowsMultiplesBoolean) {\n@@ -547,9 +559,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n             } else {\n                 makeSolrFieldMultivalued = false;\n             }\n-\n             return new SolrField(name, solrType, makeSolrFieldMultivalued, facetable);\n-\n         } else {\n             /**\n              * @todo: clean this up\n@@ -562,10 +572,9 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     }\n \n     public String getLocaleTitle() {\n-        if(getMetadataBlock()  == null) {\n+        if (getMetadataBlock() == null) {\n             return title;\n-        }\n-        else {\n+        } else {\n             try {\n                 return BundleUtil.getStringFromPropertyFile(\"datasetfieldtype.\" + getName() + \".title\", getMetadataBlock().getName());\n             } catch (MissingResourceException e) {\n@@ -575,7 +584,7 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     }\n \n     public String getLocaleDescription() {\n-        if(getMetadataBlock()  == null) {\n+        if (getMetadataBlock() == null) {\n             return description;\n         } else {\n             try {\n@@ -586,8 +595,8 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n         }\n     }\n \n-    public String getLocaleWatermark()    {\n-        if(getMetadataBlock()  == null) {\n+    public String getLocaleWatermark() {\n+        if (getMetadataBlock() == null) {\n             return watermark;\n         } else {\n             try {\n@@ -599,12 +608,14 @@ public class DatasetFieldType implements Serializable, Comparable<DatasetFieldTy\n     }\n \n     // help us identify fields that have null fieldType values\n+\n     public String getTmpNullFieldTypeIdentifier() {\n         return \"NullFieldType_s\";\n     }\n-    \n+\n     @Override\n     public String toString() {\n         return \"[DatasetFieldType name:\" + getName() + \" id:\" + getId() + \"]\";\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 107
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "26",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/108/DatasetFieldType.java\nindex 842b9490784..dcc1b01def9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/108/DatasetFieldType.java\n@@ -22,7 +22,7 @@ import javax.persistence.*;\n @NamedQueries({\n         @NamedQuery(name=\"DatasetFieldType.findByName\",\n                             query= \"SELECT dsfType FROM DatasetFieldType dsfType WHERE dsfType.name=:name\"),\n-\t@NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n+                 @NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n \t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' order by dsfType.id\"),\n         @NamedQuery(name = \"DatasetFieldType.findFacetableByMetadaBlock\",\n \t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' and dsfType.metadataBlock.id = :metadataBlockId order by dsfType.id\")\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "26",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/108/DatasetFieldType.java\nindex 842b9490784..e3094374834 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/108/DatasetFieldType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/108/DatasetFieldType.java\n@@ -22,7 +22,7 @@ import javax.persistence.*;\n @NamedQueries({\n         @NamedQuery(name=\"DatasetFieldType.findByName\",\n                             query= \"SELECT dsfType FROM DatasetFieldType dsfType WHERE dsfType.name=:name\"),\n-\t@NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n+                            @NamedQuery(name = \"DatasetFieldType.findAllFacetable\",\n \t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' order by dsfType.id\"),\n         @NamedQuery(name = \"DatasetFieldType.findFacetableByMetadaBlock\",\n \t\t\t    query= \"select dsfType from DatasetFieldType dsfType WHERE dsfType.facetable = true and dsfType.title != '' and dsfType.metadataBlock.id = :metadataBlockId order by dsfType.id\")\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}