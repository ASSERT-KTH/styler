{
    "project_name": "graphfoundation-ongdb",
    "error_id": "388",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "40",
                    "column": "15",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "45",
                    "column": "90",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "50",
                    "column": "15",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "61",
                    "column": "72",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "66",
                    "column": "15",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "77",
                    "column": "72",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "82",
                    "column": "15",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "87",
                    "column": "98",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "92",
                    "column": "52",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "92",
                    "column": "108",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "109",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "109",
                    "column": "73",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "111",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "111",
                    "column": "56",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "113",
                    "column": "13",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "113",
                    "column": "68",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "127",
                    "column": "44",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "127",
                    "column": "52",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/388/SpatialIndexSettings.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/388/SpatialIndexSettings.java\nindex 00061e2fdb8..d330c3915a2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/388/SpatialIndexSettings.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/388/SpatialIndexSettings.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.kernel.impl.index.schema.config;\n \n import java.util.ArrayList;\n@@ -36,97 +37,97 @@ import static org.neo4j.kernel.configuration.Settings.setting;\n \n public class SpatialIndexSettings implements LoadableConfig\n {\n-    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n-            \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n-            \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n-            \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n-            \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n-            \"This setting will cause the algorithm to search deeper, reducing false positives.\" )\n-    @Internal\n-    public static final Setting<Integer> space_filling_curve_extra_levels = setting(\n-            \"unsupported.dbms.index.spatial.curve.extra_levels\", INTEGER, \"1\" );\n+  @Description(\"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n+      \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n+      \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n+      \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n+      \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n+      \"This setting will cause the algorithm to search deeper, reducing false positives.\")\n+  @Internal\n+  public static final Setting<Integer> space_filling_curve_extra_levels = setting(\n+      \"unsupported.dbms.index.spatial.curve.extra_levels\", INTEGER, \"1\");\n \n-    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n-            \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n-            \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n-            \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n-            \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n-            \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" +\n-            \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" +\n-            \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" +\n-            \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" +\n-            \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" +\n-            \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" +\n-            \"curve index. Setting this value to zero turns off this feature.\" )\n-    @Internal\n-    public static final Setting<Double> space_filling_curve_top_threshold = setting(\n-            \"unsupported.dbms.index.spatial.curve.top_threshold\", DOUBLE, \"0\" );\n+  @Description(\"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n+      \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n+      \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n+      \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n+      \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n+      \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" +\n+      \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" +\n+      \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" +\n+      \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" +\n+      \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" +\n+      \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" +\n+      \"curve index. Setting this value to zero turns off this feature.\")\n+  @Internal\n+  public static final Setting<Double> space_filling_curve_top_threshold = setting(\n+      \"unsupported.dbms.index.spatial.curve.top_threshold\", DOUBLE, \"0\");\n \n-    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n-            \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n-            \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n-            \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n-            \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n-            \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" +\n-            \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" +\n-            \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" +\n-            \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" +\n-            \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" +\n-            \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" +\n-            \"curve index. Setting this value to zero turns off this feature.\" )\n-    @Internal\n-    public static final Setting<Double> space_filling_curve_bottom_threshold = setting(\n-            \"unsupported.dbms.index.spatial.curve.bottom_threshold\", DOUBLE, \"0\" );\n+  @Description(\"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n+      \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n+      \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n+      \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n+      \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n+      \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" +\n+      \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" +\n+      \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" +\n+      \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" +\n+      \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" +\n+      \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" +\n+      \"curve index. Setting this value to zero turns off this feature.\")\n+  @Internal\n+  public static final Setting<Double> space_filling_curve_bottom_threshold = setting(\n+      \"unsupported.dbms.index.spatial.curve.bottom_threshold\", DOUBLE, \"0\");\n \n-    @Description( \"The maximum number of bits to use for levels in the quad tree representing the spatial index. When creating the spatial index, we \" +\n-            \"simulate a quad tree using a 2D (or 3D) to 1D mapping function. This requires that the extents of the index and the depth \" +\n-            \"of the tree be defined in advance, so ensure the 2D to 1D mapping is deterministic and repeatable. This setting will define \" +\n-            \"the maximum depth of any future spatial index created, calculated as max_bits / dimensions. For example 60 bits will define 30 levels in 2D \" +\n-            \"and 20 levels in 3D. Existing indexes will not be changed, and need to be recreated if you wish to use the new value. \" +\n-            \"For 2D indexes, a value of 30 is the largest supported. For 3D indexes 20 is the largest.\" )\n-    @Internal\n-    public static final Setting<Integer> space_filling_curve_max_bits = setting(\n-            \"unsupported.dbms.index.spatial.curve.max_bits\", INTEGER, \"60\" );\n+  @Description(\"The maximum number of bits to use for levels in the quad tree representing the spatial index. When creating the spatial index, we \" +\n+      \"simulate a quad tree using a 2D (or 3D) to 1D mapping function. This requires that the extents of the index and the depth \" +\n+      \"of the tree be defined in advance, so ensure the 2D to 1D mapping is deterministic and repeatable. This setting will define \" +\n+      \"the maximum depth of any future spatial index created, calculated as max_bits / dimensions. For example 60 bits will define 30 levels in 2D \" +\n+      \"and 20 levels in 3D. Existing indexes will not be changed, and need to be recreated if you wish to use the new value. \" +\n+      \"For 2D indexes, a value of 30 is the largest supported. For 3D indexes 20 is the largest.\")\n+  @Internal\n+  public static final Setting<Integer> space_filling_curve_max_bits = setting(\n+      \"unsupported.dbms.index.spatial.curve.max_bits\", INTEGER, \"60\");\n \n-    public static Setting<Double> makeCRSRangeSetting( CoordinateReferenceSystem crs, int dim, String rangeKey )\n-    {\n-        double defaultCartesianExtent = 1000000;\n-        double[] defaultGeographicExtents = new double[]{180, 90, defaultCartesianExtent};\n-        String[] keyFields = new String[]{PREFIX, crs.getName().toLowerCase(), String.valueOf( COORDS[dim] ), rangeKey};\n-        double defValue = crs.isGeographic() ? defaultGeographicExtents[dim] : defaultCartesianExtent;\n-        defValue = rangeKey.equals( \"min\" ) ? -1 * defValue : defValue;\n-        return setting( String.join( \".\", keyFields ), DOUBLE, String.valueOf( defValue ) );\n-    }\n+  public static Setting<Double> makeCRSRangeSetting(CoordinateReferenceSystem crs, int dim, String rangeKey)\n+  {\n+    double defaultCartesianExtent = 1000000;\n+    double[] defaultGeographicExtents = new double[] {180, 90, defaultCartesianExtent};\n+    String[] keyFields = new String[] {PREFIX, crs.getName().toLowerCase(), String.valueOf(COORDS[dim]), rangeKey};\n+    double defValue = crs.isGeographic() ? defaultGeographicExtents[dim] : defaultCartesianExtent;\n+    defValue = rangeKey.equals(\"min\") ? -1 * defValue : defValue;\n+    return setting(String.join(\".\", keyFields), DOUBLE, String.valueOf(defValue));\n+  }\n \n-    private static final String PREFIX = \"unsupported.dbms.db.spatial.crs\";\n-    private static final char[] COORDS = new char[]{'x', 'y', 'z'};\n+  private static final String PREFIX = \"unsupported.dbms.db.spatial.crs\";\n+  private static final char[] COORDS = new char[] {'x', 'y', 'z'};\n \n-    @Override\n-    public List<ConfigOptions> getConfigOptions()\n+  @Override\n+  public List<ConfigOptions> getConfigOptions()\n+  {\n+    ArrayList<ConfigOptions> crsSettings = (ArrayList<ConfigOptions>) LoadableConfig.super.getConfigOptions();\n+    for (CoordinateReferenceSystem crs : CoordinateReferenceSystem.all())\n     {\n-        ArrayList<ConfigOptions> crsSettings = (ArrayList<ConfigOptions>) LoadableConfig.super.getConfigOptions();\n-        for ( CoordinateReferenceSystem crs : CoordinateReferenceSystem.all() )\n+      for (int dim = 0; dim < crs.getDimension(); dim++)\n+      {\n+        for (String rangeName : new String[] {\"minimum\", \"maximum\"})\n         {\n-            for ( int dim = 0; dim < crs.getDimension(); dim++ )\n-            {\n-                for ( String rangeName : new String[]{\"minimum\", \"maximum\"} )\n-                {\n-                    String descriptionHeader =\n-                            String.format( \"The %s %s value for the index extents for %dD %s spatial index\", rangeName, COORDS[dim], crs.getDimension(),\n-                                    crs.getName().replace( \"_3D\", \"\" ) );\n-                    String descriptionBody =\n-                            \"The 2D to 1D mapping function divides all 2D space into discrete tiles, and orders these using a space filling curve designed \" +\n-                            \"to optimize the requirement that tiles that are close together in this ordered list are also close together in 2D space. \" +\n-                            \"This requires that the extents of the 2D space be known in advance and never changed. If you do change these settings, you \" +\n-                            \"need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.\";\n-                    Setting<Double> setting = makeCRSRangeSetting( crs, dim, rangeName.substring( 0, 3 ) );\n-                    ((BaseSetting<Double>) setting).setInternal( true );\n-                    ((BaseSetting<Double>) setting).setDescription(\n-                            descriptionHeader + \". \" + descriptionBody.replaceAll( \" 2D \", String.format( \" %dD\", crs.getDimension() ) ) );\n-                    crsSettings.add( new ConfigOptions( setting ) );\n-                }\n-            }\n+          String descriptionHeader =\n+              String.format(\"The %s %s value for the index extents for %dD %s spatial index\", rangeName, COORDS[dim], crs.getDimension(),\n+                  crs.getName().replace(\"_3D\", \"\"));\n+          String descriptionBody =\n+              \"The 2D to 1D mapping function divides all 2D space into discrete tiles, and orders these using a space filling curve designed \" +\n+                  \"to optimize the requirement that tiles that are close together in this ordered list are also close together in 2D space. \" +\n+                  \"This requires that the extents of the 2D space be known in advance and never changed. If you do change these settings, you \" +\n+                  \"need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.\";\n+          Setting<Double> setting = makeCRSRangeSetting(crs, dim, rangeName.substring(0, 3));\n+          ((BaseSetting<Double>) setting).setInternal(true);\n+          ((BaseSetting<Double>) setting).setDescription(\n+              descriptionHeader + \". \" + descriptionBody.replaceAll(\" 2D \", String.format(\" %dD\", crs.getDimension())));\n+          crsSettings.add(new ConfigOptions(setting));\n         }\n-        return crsSettings;\n+      }\n     }\n+    return crsSettings;\n+  }\n }\n",
            "diff_size": 90
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "39",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 735).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "43",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 1,485).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "44",
                    "severity": "error",
                    "message": "Annotation 'Internal' have incorrect indentation level 4, expected level should be 0.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.annotation.AnnotationLocationCheck"
                },
                {
                    "line": "47",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 1,485).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "48",
                    "severity": "error",
                    "message": "Annotation 'Internal' have incorrect indentation level 4, expected level should be 0.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.annotation.AnnotationLocationCheck"
                },
                {
                    "line": "51",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 766).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "52",
                    "severity": "error",
                    "message": "Annotation 'Internal' have incorrect indentation level 4, expected level should be 0.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.annotation.AnnotationLocationCheck"
                },
                {
                    "line": "78",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 209).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "79",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 627).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "79",
                    "column": "627",
                    "severity": "error",
                    "message": "Only one statement per line allowed.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.coding.OneStatementPerLineCheck"
                },
                {
                    "line": "81",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/388/SpatialIndexSettings.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/388/SpatialIndexSettings.java\nindex 00061e2fdb8..20840994b35 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/388/SpatialIndexSettings.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/388/SpatialIndexSettings.java\n@@ -36,59 +36,23 @@ import static org.neo4j.kernel.configuration.Settings.setting;\n \n public class SpatialIndexSettings implements LoadableConfig\n {\n-    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n-            \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n-            \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n-            \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n-            \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n-            \"This setting will cause the algorithm to search deeper, reducing false positives.\" )\n+    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" + \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" + \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" + \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" + \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" + \"This setting will cause the algorithm to search deeper, reducing false positives.\" )\n     @Internal\n-    public static final Setting<Integer> space_filling_curve_extra_levels = setting(\n-            \"unsupported.dbms.index.spatial.curve.extra_levels\", INTEGER, \"1\" );\n+    public static final Setting<Integer> space_filling_curve_extra_levels = setting( \"unsupported.dbms.index.spatial.curve.extra_levels\", INTEGER, \"1\" );\n \n-    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n-            \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n-            \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n-            \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n-            \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n-            \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" +\n-            \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" +\n-            \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" +\n-            \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" +\n-            \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" +\n-            \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" +\n-            \"curve index. Setting this value to zero turns off this feature.\" )\n+@Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" + \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" + \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" + \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" + \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" + \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" + \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" + \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" + \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" + \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" + \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" + \"curve index. Setting this value to zero turns off this feature.\" )\n     @Internal\n-    public static final Setting<Double> space_filling_curve_top_threshold = setting(\n-            \"unsupported.dbms.index.spatial.curve.top_threshold\", DOUBLE, \"0\" );\n+    public static final Setting<Double> space_filling_curve_top_threshold = setting( \"unsupported.dbms.index.spatial.curve.top_threshold\", DOUBLE, \"0\" );\n \n-    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n-            \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n-            \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n-            \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n-            \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n-            \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" +\n-            \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" +\n-            \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" +\n-            \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" +\n-            \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" +\n-            \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" +\n-            \"curve index. Setting this value to zero turns off this feature.\" )\n+@Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" + \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" + \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" + \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" + \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" + \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" + \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" + \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" + \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" + \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" + \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" + \"curve index. Setting this value to zero turns off this feature.\" )\n     @Internal\n-    public static final Setting<Double> space_filling_curve_bottom_threshold = setting(\n-            \"unsupported.dbms.index.spatial.curve.bottom_threshold\", DOUBLE, \"0\" );\n+    public static final Setting<Double> space_filling_curve_bottom_threshold = setting( \"unsupported.dbms.index.spatial.curve.bottom_threshold\", DOUBLE, \"0\" );\n \n-    @Description( \"The maximum number of bits to use for levels in the quad tree representing the spatial index. When creating the spatial index, we \" +\n-            \"simulate a quad tree using a 2D (or 3D) to 1D mapping function. This requires that the extents of the index and the depth \" +\n-            \"of the tree be defined in advance, so ensure the 2D to 1D mapping is deterministic and repeatable. This setting will define \" +\n-            \"the maximum depth of any future spatial index created, calculated as max_bits / dimensions. For example 60 bits will define 30 levels in 2D \" +\n-            \"and 20 levels in 3D. Existing indexes will not be changed, and need to be recreated if you wish to use the new value. \" +\n-            \"For 2D indexes, a value of 30 is the largest supported. For 3D indexes 20 is the largest.\" )\n+@Description( \"The maximum number of bits to use for levels in the quad tree representing the spatial index. When creating the spatial index, we \" + \"simulate a quad tree using a 2D (or 3D) to 1D mapping function. This requires that the extents of the index and the depth \" + \"of the tree be defined in advance, so ensure the 2D to 1D mapping is deterministic and repeatable. This setting will define \" + \"the maximum depth of any future spatial index created, calculated as max_bits / dimensions. For example 60 bits will define 30 levels in 2D \" + \"and 20 levels in 3D. Existing indexes will not be changed, and need to be recreated if you wish to use the new value. \" + \"For 2D indexes, a value of 30 is the largest supported. For 3D indexes 20 is the largest.\" )\n     @Internal\n-    public static final Setting<Integer> space_filling_curve_max_bits = setting(\n-            \"unsupported.dbms.index.spatial.curve.max_bits\", INTEGER, \"60\" );\n+    public static final Setting<Integer> space_filling_curve_max_bits = setting( \"unsupported.dbms.index.spatial.curve.max_bits\", INTEGER, \"60\" );\n \n-    public static Setting<Double> makeCRSRangeSetting( CoordinateReferenceSystem crs, int dim, String rangeKey )\n+public static Setting<Double> makeCRSRangeSetting( CoordinateReferenceSystem crs, int dim, String rangeKey )\n     {\n         double defaultCartesianExtent = 1000000;\n         double[] defaultGeographicExtents = new double[]{180, 90, defaultCartesianExtent};\n@@ -111,22 +75,14 @@ public class SpatialIndexSettings implements LoadableConfig\n             {\n                 for ( String rangeName : new String[]{\"minimum\", \"maximum\"} )\n                 {\n-                    String descriptionHeader =\n-                            String.format( \"The %s %s value for the index extents for %dD %s spatial index\", rangeName, COORDS[dim], crs.getDimension(),\n-                                    crs.getName().replace( \"_3D\", \"\" ) );\n-                    String descriptionBody =\n-                            \"The 2D to 1D mapping function divides all 2D space into discrete tiles, and orders these using a space filling curve designed \" +\n-                            \"to optimize the requirement that tiles that are close together in this ordered list are also close together in 2D space. \" +\n-                            \"This requires that the extents of the 2D space be known in advance and never changed. If you do change these settings, you \" +\n-                            \"need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.\";\n-                    Setting<Double> setting = makeCRSRangeSetting( crs, dim, rangeName.substring( 0, 3 ) );\n+                    String descriptionHeader = String.format( \"The %s %s value for the index extents for %dD %s spatial index\", rangeName, COORDS[dim], crs.getDimension(), crs.getName().replace( \"_3D\", \"\" ) );\n+String descriptionBody = \"The 2D to 1D mapping function divides all 2D space into discrete tiles, and orders these using a space filling curve designed \" + \"to optimize the requirement that tiles that are close together in this ordered list are also close together in 2D space. \" + \"This requires that the extents of the 2D space be known in advance and never changed. If you do change these settings, you \" + \"need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.\"; Setting<Double> setting = makeCRSRangeSetting( crs, dim, rangeName.substring( 0, 3 ) );\n                     ((BaseSetting<Double>) setting).setInternal( true );\n-                    ((BaseSetting<Double>) setting).setDescription(\n-                            descriptionHeader + \". \" + descriptionBody.replaceAll( \" 2D \", String.format( \" %dD\", crs.getDimension() ) ) );\n-                    crsSettings.add( new ConfigOptions( setting ) );\n+                    ((BaseSetting<Double>) setting).setDescription( descriptionHeader + \". \" + descriptionBody.replaceAll( \" 2D \", String.format( \" %dD\", crs.getDimension() ) ) );\n+crsSettings.add( new ConfigOptions( setting ) );\n                 }\n             }\n         }\n         return crsSettings;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 58
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "39",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 735).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "39",
                    "column": "735",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "40",
                    "severity": "error",
                    "message": "Annotation 'Internal' should be alone on line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.annotation.AnnotationLocationCheck"
                },
                {
                    "line": "40",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 163).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "41",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 1,489).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "41",
                    "column": "1489",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "42",
                    "severity": "error",
                    "message": "Annotation 'Internal' should be alone on line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.annotation.AnnotationLocationCheck"
                },
                {
                    "line": "42",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 163).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "43",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 1,489).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "43",
                    "column": "1489",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "44",
                    "severity": "error",
                    "message": "Annotation 'Internal' should be alone on line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.annotation.AnnotationLocationCheck"
                },
                {
                    "line": "44",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 169).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "45",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 770).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "45",
                    "column": "770",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "46",
                    "severity": "error",
                    "message": "Annotation 'Internal' should be alone on line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.annotation.AnnotationLocationCheck"
                },
                {
                    "line": "54",
                    "column": "50",
                    "severity": "error",
                    "message": "'*' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "64",
                    "column": "9",
                    "severity": "error",
                    "message": "'for' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "69",
                    "column": "17",
                    "severity": "error",
                    "message": "'for' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "69",
                    "column": "78",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "71",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 210).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "72",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 559).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "75",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/388/SpatialIndexSettings.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/codebuff/388/SpatialIndexSettings.java\nindex 00061e2fdb8..f3ea26ed1f8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/388/SpatialIndexSettings.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/codebuff/388/SpatialIndexSettings.java\n@@ -21,7 +21,6 @@ package org.neo4j.kernel.impl.index.schema.config;\n \n import java.util.ArrayList;\n import java.util.List;\n-\n import org.neo4j.configuration.ConfigOptions;\n import org.neo4j.configuration.Description;\n import org.neo4j.configuration.Internal;\n@@ -29,104 +28,56 @@ import org.neo4j.configuration.LoadableConfig;\n import org.neo4j.graphdb.config.BaseSetting;\n import org.neo4j.graphdb.config.Setting;\n import org.neo4j.values.storable.CoordinateReferenceSystem;\n-\n import static org.neo4j.kernel.configuration.Settings.DOUBLE;\n+\n import static org.neo4j.kernel.configuration.Settings.INTEGER;\n+\n import static org.neo4j.kernel.configuration.Settings.setting;\n \n public class SpatialIndexSettings implements LoadableConfig\n {\n-    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n-            \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n-            \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n-            \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n-            \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n-            \"This setting will cause the algorithm to search deeper, reducing false positives.\" )\n-    @Internal\n-    public static final Setting<Integer> space_filling_curve_extra_levels = setting(\n-            \"unsupported.dbms.index.spatial.curve.extra_levels\", INTEGER, \"1\" );\n-\n-    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n-            \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n-            \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n-            \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n-            \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n-            \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" +\n-            \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" +\n-            \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" +\n-            \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" +\n-            \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" +\n-            \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" +\n-            \"curve index. Setting this value to zero turns off this feature.\" )\n-    @Internal\n-    public static final Setting<Double> space_filling_curve_top_threshold = setting(\n-            \"unsupported.dbms.index.spatial.curve.top_threshold\", DOUBLE, \"0\" );\n-\n-    @Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" +\n-            \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" +\n-            \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" +\n-            \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" +\n-            \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" +\n-            \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" +\n-            \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" +\n-            \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" +\n-            \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" +\n-            \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" +\n-            \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" +\n-            \"curve index. Setting this value to zero turns off this feature.\" )\n-    @Internal\n-    public static final Setting<Double> space_filling_curve_bottom_threshold = setting(\n-            \"unsupported.dbms.index.spatial.curve.bottom_threshold\", DOUBLE, \"0\" );\n-\n-    @Description( \"The maximum number of bits to use for levels in the quad tree representing the spatial index. When creating the spatial index, we \" +\n-            \"simulate a quad tree using a 2D (or 3D) to 1D mapping function. This requires that the extents of the index and the depth \" +\n-            \"of the tree be defined in advance, so ensure the 2D to 1D mapping is deterministic and repeatable. This setting will define \" +\n-            \"the maximum depth of any future spatial index created, calculated as max_bits / dimensions. For example 60 bits will define 30 levels in 2D \" +\n-            \"and 20 levels in 3D. Existing indexes will not be changed, and need to be recreated if you wish to use the new value. \" +\n-            \"For 2D indexes, a value of 30 is the largest supported. For 3D indexes 20 is the largest.\" )\n-    @Internal\n-    public static final Setting<Integer> space_filling_curve_max_bits = setting(\n-            \"unsupported.dbms.index.spatial.curve.max_bits\", INTEGER, \"60\" );\n+    @ Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" + \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" + \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" + \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" + \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" + \"This setting will cause the algorithm to search deeper, reducing false positives.\")\n+    @Internal public static final Setting<Integer> space_filling_curve_extra_levels = setting( \"unsupported.dbms.index.spatial.curve.extra_levels\", INTEGER, \"1\" );\n+    @ Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" + \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" + \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" + \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" + \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" + \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" + \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" + \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" + \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" + \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" + \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" + \"curve index. Setting this value to zero turns off this feature.\")\n+    @Internal public static final Setting<Double> space_filling_curve_top_threshold = setting( \"unsupported.dbms.index.spatial.curve.top_threshold\", DOUBLE, \"0\" );\n+    @ Description( \"When searching the spatial index we need to convert a 2D range in the quad tree into a set of 1D ranges on the \" + \"underlying 1D space filling curve index. There is a balance to be made between many small 1D ranges that have few false \" + \"positives, and fewer, larger 1D ranges that have more false positives. The former has a more efficient filtering of false \" + \"positives, while the latter will have a more efficient search of the numerical index. The maximum depth to which the quad tree is \" + \"processed when mapping 2D to 1D is based on the size of the search area compared to the size of the 2D tiles at that depth. \" + \"When traversing the tree to this depth, we can stop early based on when the search envelope overlaps the current tile by \" + \"more than a certain threshold. The threshold is calculated based on depth, from the `top_threshold` at the top of the tree \" + \"to the `bottom_threshold` at the depth calculated by the area comparison. Setting the top to 0.99 and the bottom to 0.5, \" + \"for example would mean that if we reached the maximum depth, and the search area overlapped the current tile by more than \" + \"50%, we would stop traversing the tree, and return the 1D range for that entire tile to the search set. If the overlap is even \" + \"higher, we would stop higher in the tree. This technique reduces the number of 1D ranges passed to the underlying space filling \" + \"curve index. Setting this value to zero turns off this feature.\")\n+    @Internal public static final Setting<Double> space_filling_curve_bottom_threshold = setting( \"unsupported.dbms.index.spatial.curve.bottom_threshold\", DOUBLE, \"0\" );\n+    @ Description( \"The maximum number of bits to use for levels in the quad tree representing the spatial index. When creating the spatial index, we \" + \"simulate a quad tree using a 2D (or 3D) to 1D mapping function. This requires that the extents of the index and the depth \" + \"of the tree be defined in advance, so ensure the 2D to 1D mapping is deterministic and repeatable. This setting will define \" + \"the maximum depth of any future spatial index created, calculated as max_bits / dimensions. For example 60 bits will define 30 levels in 2D \" + \"and 20 levels in 3D. Existing indexes will not be changed, and need to be recreated if you wish to use the new value. \" + \"For 2D indexes, a value of 30 is the largest supported. For 3D indexes 20 is the largest.\")\n+    @Internal public static final Setting<Integer> space_filling_curve_max_bits = setting( \"unsupported.dbms.index.spatial.curve.max_bits\", INTEGER, \"60\" );\n \n     public static Setting<Double> makeCRSRangeSetting( CoordinateReferenceSystem crs, int dim, String rangeKey )\n     {\n         double defaultCartesianExtent = 1000000;\n-        double[] defaultGeographicExtents = new double[]{180, 90, defaultCartesianExtent};\n-        String[] keyFields = new String[]{PREFIX, crs.getName().toLowerCase(), String.valueOf( COORDS[dim] ), rangeKey};\n-        double defValue = crs.isGeographic() ? defaultGeographicExtents[dim] : defaultCartesianExtent;\n-        defValue = rangeKey.equals( \"min\" ) ? -1 * defValue : defValue;\n+        double[] defaultGeographicExtents = new double[] { 180, 90, defaultCartesianExtent };\n+        String[] keyFields = new String[] { PREFIX, crs.getName().toLowerCase(), String.valueOf( COORDS[ dim] ), rangeKey };\n+        double defValue = crs.isGeographic() ? defaultGeographicExtents[ dim] : defaultCartesianExtent;\n+        defValue = rangeKey.equals( \"min\" ) ? - 1* defValue : defValue;\n         return setting( String.join( \".\", keyFields ), DOUBLE, String.valueOf( defValue ) );\n     }\n \n     private static final String PREFIX = \"unsupported.dbms.db.spatial.crs\";\n-    private static final char[] COORDS = new char[]{'x', 'y', 'z'};\n-\n+    private static final char[] COORDS = new char[] { 'x', 'y', 'z' };\n     @Override\n     public List<ConfigOptions> getConfigOptions()\n     {\n         ArrayList<ConfigOptions> crsSettings = (ArrayList<ConfigOptions>) LoadableConfig.super.getConfigOptions();\n-        for ( CoordinateReferenceSystem crs : CoordinateReferenceSystem.all() )\n+        for( CoordinateReferenceSystem crs : CoordinateReferenceSystem.all()\n+        )\n         {\n             for ( int dim = 0; dim < crs.getDimension(); dim++ )\n             {\n-                for ( String rangeName : new String[]{\"minimum\", \"maximum\"} )\n+                for( String rangeName : new String[] { \"minimum\", \"maximum\" })\n                 {\n-                    String descriptionHeader =\n-                            String.format( \"The %s %s value for the index extents for %dD %s spatial index\", rangeName, COORDS[dim], crs.getDimension(),\n-                                    crs.getName().replace( \"_3D\", \"\" ) );\n-                    String descriptionBody =\n-                            \"The 2D to 1D mapping function divides all 2D space into discrete tiles, and orders these using a space filling curve designed \" +\n-                            \"to optimize the requirement that tiles that are close together in this ordered list are also close together in 2D space. \" +\n-                            \"This requires that the extents of the 2D space be known in advance and never changed. If you do change these settings, you \" +\n-                            \"need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.\";\n+                    String descriptionHeader = String.format( \"The %s %s value for the index extents for %dD %s spatial index\", rangeName, COORDS[ dim], crs.getDimension(), crs.getName().replace( \"_3D\", \"\" ) );\n+                    String descriptionBody = \"The 2D to 1D mapping function divides all 2D space into discrete tiles, and orders these using a space filling curve designed \" + \"to optimize the requirement that tiles that are close together in this ordered list are also close together in 2D space. \" + \"This requires that the extents of the 2D space be known in advance and never changed. If you do change these settings, you \" + \"need to recreate any affected index in order for the settings to apply, otherwise the index will retain the previous settings.\";\n                     Setting<Double> setting = makeCRSRangeSetting( crs, dim, rangeName.substring( 0, 3 ) );\n                     ((BaseSetting<Double>) setting).setInternal( true );\n-                    ((BaseSetting<Double>) setting).setDescription(\n-                            descriptionHeader + \". \" + descriptionBody.replaceAll( \" 2D \", String.format( \" %dD\", crs.getDimension() ) ) );\n+                    ((BaseSetting<Double>) setting).setDescription( descriptionHeader + \". \" + descriptionBody.replaceAll( \" 2D \", String.format( \" %dD\", crs.getDimension() ) ) );\n                     crsSettings.add( new ConfigOptions( setting ) );\n                 }\n             }\n         }\n+\n         return crsSettings;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 76
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}