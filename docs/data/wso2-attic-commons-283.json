{
    "project_name": "wso2-attic-commons",
    "error_id": "283",
    "information": {
        "errors": [
            {
                "line": "51",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 132).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "    long _mexTtl;\n\n    private static Map<String,MessageExchangeDAO> _mexStore = Collections.synchronizedMap(new HashMap<String,MessageExchangeDAO>());\n    protected static Map<String, Long> _mexAge = new ConcurrentHashMap<String, Long>();\n    private static AtomicLong counter = new AtomicLong(Long.MAX_VALUE / 2);\n    private static volatile long _lastRemoval = 0;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "51",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/283/BpelDAOConnectionImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/283/BpelDAOConnectionImpl.java\nindex d0579006400..5bb35ffec6e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/283/BpelDAOConnectionImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/283/BpelDAOConnectionImpl.java\n@@ -16,6 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n+\n package org.apache.ode.bpel.memdao;\n \n import org.apache.commons.logging.Log;\n@@ -41,90 +42,102 @@ import java.util.concurrent.atomic.AtomicLong;\n  * A very simple, in-memory implementation of the {@link BpelDAOConnection} interface.\n  */\n class BpelDAOConnectionImpl implements BpelDAOConnection {\n-    private static final Log __log = LogFactory.getLog(BpelDAOConnectionImpl.class);\n-\n-    private Scheduler _scheduler;\n-    private Map<QName, ProcessDaoImpl> _store;\n-    private List<BpelEvent> _events = new LinkedList<BpelEvent>();\n-    long _mexTtl;\n-\n-    private static Map<String,MessageExchangeDAO> _mexStore = Collections.synchronizedMap(new HashMap<String,MessageExchangeDAO>());\n-    protected static Map<String, Long> _mexAge = new ConcurrentHashMap<String, Long>();\n-    private static AtomicLong counter = new AtomicLong(Long.MAX_VALUE / 2);\n-    private static volatile long _lastRemoval = 0;\n-\n-    BpelDAOConnectionImpl(Map<QName, ProcessDaoImpl> store, Scheduler scheduler, long mexTtl) {\n-        _store = store;\n-        _scheduler = scheduler;\n-        _mexTtl = mexTtl;\n-    }\n-\n-    public ProcessDAO getProcess(QName processId) {\n-        return _store.get(processId);\n-    }\n-\n-    public ProcessDAO createTransientProcess(Long id) {\n-        ProcessDaoImpl process = new ProcessDaoImpl(this, _store, null, null, null, 0);\n-\n-        return process;\n-    }\n-\n-    public ProcessDAO createProcess(QName pid, QName type, String guid, long version) {\n-        ProcessDaoImpl process = new ProcessDaoImpl(this,_store,pid,type, guid,version);\n-        _store.put(pid,process);\n-        return process;\n+  private static final Log __log = LogFactory.getLog(BpelDAOConnectionImpl.class);\n+\n+  private Scheduler _scheduler;\n+  private Map<QName, ProcessDaoImpl> _store;\n+  private List<BpelEvent> _events = new LinkedList<BpelEvent>();\n+  long _mexTtl;\n+\n+  private static Map<String, MessageExchangeDAO> _mexStore =\n+    Collections.synchronizedMap(new HashMap<String, MessageExchangeDAO>());\n+  protected static Map<String, Long> _mexAge = new ConcurrentHashMap<String, Long>();\n+  private static AtomicLong counter = new AtomicLong(Long.MAX_VALUE / 2);\n+  private static volatile long _lastRemoval = 0;\n+\n+  BpelDAOConnectionImpl(Map<QName, ProcessDaoImpl> store, Scheduler scheduler, long mexTtl) {\n+    _store = store;\n+    _scheduler = scheduler;\n+    _mexTtl = mexTtl;\n+  }\n+\n+  public ProcessDAO getProcess(QName processId) {\n+    return _store.get(processId);\n+  }\n+\n+  public ProcessDAO createTransientProcess(Long id) {\n+    ProcessDaoImpl process = new ProcessDaoImpl(this, _store, null, null, null, 0);\n+\n+    return process;\n+  }\n+\n+  public ProcessDAO createProcess(QName pid, QName type, String guid, long version) {\n+    ProcessDaoImpl process = new ProcessDaoImpl(this, _store, pid, type, guid, version);\n+    _store.put(pid, process);\n+    return process;\n+  }\n+\n+  public ProcessInstanceDAO getInstance(Long iid) {\n+    for (ProcessDaoImpl proc : _store.values()) {\n+      ProcessInstanceDAO instance = proc._instances.get(iid);\n+      if (instance != null) {\n+        return instance;\n+      }\n     }\n-\n-    public ProcessInstanceDAO getInstance(Long iid) {\n-        for (ProcessDaoImpl proc : _store.values()) {\n-            ProcessInstanceDAO instance = proc._instances.get(iid);\n-            if (instance != null)\n-                return instance;\n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  public int getNumInstances(QName processId) {\n+    ProcessDAO process = getProcess(processId);\n+    if (process != null) {\n+      return process.getNumInstances();\n+    } else {\n+      return -1;\n     }\n+  }\n \n-    public int getNumInstances(QName processId) {\n-        ProcessDAO process = getProcess(processId);\n-        if (process != null)\n-            return process.getNumInstances();\n-        else return -1;\n+  @SuppressWarnings(\"unchecked\")\n+  public Collection<ProcessInstanceDAO> instanceQuery(InstanceFilter filter) {\n+    if (filter.getLimit() == 0) {\n+      return Collections.EMPTY_LIST;\n     }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<ProcessInstanceDAO> instanceQuery(InstanceFilter filter) {\n-        if(filter.getLimit()==0) {\n-            return Collections.EMPTY_LIST;\n-        }\n-        List<ProcessInstanceDAO> matched = new ArrayList<ProcessInstanceDAO>();\n-        // Selecting\n-        selectionCompleted:\n-        for (ProcessDaoImpl proc : _store.values()) {\n-            boolean pmatch = true;\n-            if (filter.getNameFilter() != null\n-                    && !equalsOrWildcardMatch(filter.getNameFilter(), proc.getProcessId().getLocalPart()))\n-                pmatch = false;\n-            if (filter.getNamespaceFilter() != null\n-                    && !equalsOrWildcardMatch(filter.getNamespaceFilter(), proc.getProcessId().getNamespaceURI()))\n-                pmatch = false;\n-\n-            if (pmatch) {\n-                for (ProcessInstanceDAO inst : proc._instances.values()) {\n-                    boolean match = true;\n-\n-                    if (filter.getStatusFilter() != null) {\n-                        boolean statusMatch = false;\n-                        for (Short status : filter.convertFilterState()) {\n-                            if (inst.getState() == status.byteValue()) statusMatch = true;\n-                        }\n-                        if (!statusMatch) match = false;\n-                    }\n-                    if (filter.getStartedDateFilter() != null\n-                            && !dateMatch(filter.getStartedDateFilter(), inst.getCreateTime(), filter))\n-                        match = false;\n-                    if (filter.getLastActiveDateFilter() != null\n-                            && !dateMatch(filter.getLastActiveDateFilter(), inst.getLastActiveTime(), filter))\n-                        match = false;\n+    List<ProcessInstanceDAO> matched = new ArrayList<ProcessInstanceDAO>();\n+    // Selecting\n+    selectionCompleted:\n+    for (ProcessDaoImpl proc : _store.values()) {\n+      boolean pmatch = true;\n+      if (filter.getNameFilter() != null\n+        && !equalsOrWildcardMatch(filter.getNameFilter(), proc.getProcessId().getLocalPart())) {\n+        pmatch = false;\n+      }\n+      if (filter.getNamespaceFilter() != null\n+        && !equalsOrWildcardMatch(filter.getNamespaceFilter(), proc.getProcessId().getNamespaceURI())) {\n+        pmatch = false;\n+      }\n+\n+      if (pmatch) {\n+        for (ProcessInstanceDAO inst : proc._instances.values()) {\n+          boolean match = true;\n+\n+          if (filter.getStatusFilter() != null) {\n+            boolean statusMatch = false;\n+            for (Short status : filter.convertFilterState()) {\n+              if (inst.getState() == status.byteValue()) {\n+                statusMatch = true;\n+              }\n+            }\n+            if (!statusMatch) {\n+              match = false;\n+            }\n+          }\n+          if (filter.getStartedDateFilter() != null\n+            && !dateMatch(filter.getStartedDateFilter(), inst.getCreateTime(), filter)) {\n+            match = false;\n+          }\n+          if (filter.getLastActiveDateFilter() != null\n+            && !dateMatch(filter.getLastActiveDateFilter(), inst.getLastActiveTime(), filter)) {\n+            match = false;\n+          }\n \n //                    if (filter.getPropertyValuesFilter() != null) {\n //                        for (Map.Entry propEntry : filter.getPropertyValuesFilter().entrySet()) {\n@@ -142,246 +155,281 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n //                        }\n //                    }\n \n-                    if (match) {\n-                        matched.add(inst);\n-                        if(matched.size()==filter.getLimit()) {\n-                            break selectionCompleted;\n-                        }\n-                    }\n-                }\n+          if (match) {\n+            matched.add(inst);\n+            if (matched.size() == filter.getLimit()) {\n+              break selectionCompleted;\n             }\n+          }\n         }\n-        // And ordering\n-        if (filter.getOrders() != null) {\n-            final List<String> orders = filter.getOrders();\n-\n-            Collections.sort(matched, new Comparator<ProcessInstanceDAO>() {\n-                public int compare(ProcessInstanceDAO o1, ProcessInstanceDAO o2) {\n-                    for (String orderKey: orders) {\n-                        int result = compareInstanceUsingKey(orderKey, o1, o2);\n-                        if (result != 0) return result;\n-                    }\n-                    return 0;\n-                }\n-            });\n-        }\n-\n-        return matched;\n+      }\n     }\n-\n-    /**\n-     * Close this DAO connection.\n-     */\n-    public void close() {\n-    }\n-\n-    public Collection<ProcessDAO> processQuery(ProcessFilter filter) {\n-        throw new UnsupportedOperationException(\"Can't query process configuration using a transient DAO.\");\n-    }\n-\n-    public MessageExchangeDAO createMessageExchange(char dir) {\n-        final String id = Long.toString(counter.getAndIncrement());\n-        MessageExchangeDAO mex = new MessageExchangeDAOImpl(dir,id);\n-        long now = System.currentTimeMillis();\n-        _mexStore.put(id,mex);\n-        _mexAge.put(id, now);\n-\n-        if (now > _lastRemoval + (_mexTtl / 10)) {\n-            _lastRemoval = now;\n-            Object[] oldMexs = _mexAge.keySet().toArray();\n-            for (int i=oldMexs.length-1; i>0; i--) {\n-                String oldMex = (String) oldMexs[i];\n-                Long age = _mexAge.get(oldMex);\n-                if (age != null && now-age > _mexTtl) {\n-                    removeMessageExchange(oldMex);\n-                    _mexAge.remove(oldMex);\n-                }\n+    // And ordering\n+    if (filter.getOrders() != null) {\n+      final List<String> orders = filter.getOrders();\n+\n+      Collections.sort(matched, new Comparator<ProcessInstanceDAO>() {\n+        public int compare(ProcessInstanceDAO o1, ProcessInstanceDAO o2) {\n+          for (String orderKey : orders) {\n+            int result = compareInstanceUsingKey(orderKey, o1, o2);\n+            if (result != 0) {\n+              return result;\n             }\n+          }\n+          return 0;\n         }\n-\n-        // Removing right away on rollback\n-        onRollback(new Runnable() {\n-            public void run() {\n-                removeMessageExchange(id);\n-                _mexAge.remove(id);\n-            }\n-        });\n-\n-        return mex;\n+      });\n     }\n \n-    public MessageExchangeDAO getMessageExchange(String mexid) {\n-        return _mexStore.get(mexid);\n-    }\n-\n-    private int compareInstanceUsingKey(String key, ProcessInstanceDAO instanceDAO1, ProcessInstanceDAO instanceDAO2) {\n-        String s1 = null;\n-        String s2 = null;\n-        boolean ascending = true;\n-        String orderKey = key;\n-        if (key.startsWith(\"+\") || key.startsWith(\"-\")) {\n-            orderKey = key.substring(1, key.length());\n-            if (key.startsWith(\"-\")) ascending = false;\n-        }\n-        ProcessDAO process1 = getProcess(instanceDAO1.getProcess().getProcessId());\n-        ProcessDAO process2 = getProcess(instanceDAO2.getProcess().getProcessId());\n-        if (\"pid\".equals(orderKey)) {\n-            s1 = process1.getProcessId().toString();\n-            s2 = process2.getProcessId().toString();\n-        } else if (\"name\".equals(orderKey)) {\n-            s1 = process1.getProcessId().getLocalPart();\n-            s2 = process2.getProcessId().getLocalPart();\n-        } else if (\"namespace\".equals(orderKey)) {\n-            s1 = process1.getProcessId().getNamespaceURI();\n-            s2 = process2.getProcessId().getNamespaceURI();\n-        } else if (\"version\".equals(orderKey)) {\n-            s1 = \"\"+process1.getVersion();\n-            s2 = \"\"+process2.getVersion();\n-        } else if (\"status\".equals(orderKey)) {\n-            s1 = \"\"+instanceDAO1.getState();\n-            s2 = \"\"+instanceDAO2.getState();\n-        } else if (\"started\".equals(orderKey)) {\n-            s1 = ISO8601DateParser.format(instanceDAO1.getCreateTime());\n-            s2 = ISO8601DateParser.format(instanceDAO2.getCreateTime());\n-        } else if (\"last-active\".equals(orderKey)) {\n-            s1 = ISO8601DateParser.format(instanceDAO1.getLastActiveTime());\n-            s2 = ISO8601DateParser.format(instanceDAO2.getLastActiveTime());\n-        }\n-        if (ascending) return s1.compareTo(s2);\n-        else return s2.compareTo(s1);\n-    }\n-\n-    private boolean equalsOrWildcardMatch(String s1, String s2) {\n-        if (s1 == null || s2 == null) return false;\n-        if (s1.equals(s2)) return true;\n-        if (s1.endsWith(\"*\")) {\n-            if (s2.startsWith(s1.substring(0, s1.length() - 1))) return true;\n-        }\n-        if (s2.endsWith(\"*\")) {\n-            if (s1.startsWith(s2.substring(0, s2.length() - 1))) return true;\n+    return matched;\n+  }\n+\n+  /**\n+   * Close this DAO connection.\n+   */\n+  public void close() {\n+  }\n+\n+  public Collection<ProcessDAO> processQuery(ProcessFilter filter) {\n+    throw new UnsupportedOperationException(\"Can't query process configuration using a transient DAO.\");\n+  }\n+\n+  public MessageExchangeDAO createMessageExchange(char dir) {\n+    final String id = Long.toString(counter.getAndIncrement());\n+    MessageExchangeDAO mex = new MessageExchangeDAOImpl(dir, id);\n+    long now = System.currentTimeMillis();\n+    _mexStore.put(id, mex);\n+    _mexAge.put(id, now);\n+\n+    if (now > _lastRemoval + (_mexTtl / 10)) {\n+      _lastRemoval = now;\n+      Object[] oldMexs = _mexAge.keySet().toArray();\n+      for (int i = oldMexs.length - 1; i > 0; i--) {\n+        String oldMex = (String) oldMexs[i];\n+        Long age = _mexAge.get(oldMex);\n+        if (age != null && now - age > _mexTtl) {\n+          removeMessageExchange(oldMex);\n+          _mexAge.remove(oldMex);\n         }\n-        return false;\n+      }\n     }\n \n-    public boolean dateMatch(List<String> dateFilters, Date instanceDate,  InstanceFilter filter) {\n-        boolean match = true;\n-        for (String ddf : dateFilters) {\n-            String isoDate = ISO8601DateParser.format(instanceDate);\n-            String critDate = Filter.getDateWithoutOp(ddf);\n-            if (ddf.startsWith(\"=\")) {\n-                if (!isoDate.startsWith(critDate)) match = false;\n-            } else if (ddf.startsWith(\"<=\")) {\n-                if (!isoDate.startsWith(critDate) && isoDate.compareTo(critDate) > 0) match = false;\n-            } else if (ddf.startsWith(\">=\")) {\n-                if (!isoDate.startsWith(critDate) && isoDate.compareTo(critDate) < 0) match = false;\n-            } else if (ddf.startsWith(\"<\")) {\n-                if (isoDate.compareTo(critDate) > 0) match = false;\n-            } else if (ddf.startsWith(\">\")) {\n-                if (isoDate.compareTo(critDate) < 0) match = false;\n-            }\n-        }\n-        return match;\n+    // Removing right away on rollback\n+    onRollback(new Runnable() {\n+      public void run() {\n+        removeMessageExchange(id);\n+        _mexAge.remove(id);\n+      }\n+    });\n+\n+    return mex;\n+  }\n+\n+  public MessageExchangeDAO getMessageExchange(String mexid) {\n+    return _mexStore.get(mexid);\n+  }\n+\n+  private int compareInstanceUsingKey(String key, ProcessInstanceDAO instanceDAO1, ProcessInstanceDAO instanceDAO2) {\n+    String s1 = null;\n+    String s2 = null;\n+    boolean ascending = true;\n+    String orderKey = key;\n+    if (key.startsWith(\"+\") || key.startsWith(\"-\")) {\n+      orderKey = key.substring(1, key.length());\n+      if (key.startsWith(\"-\")) {\n+        ascending = false;\n+      }\n     }\n-\n-\n-    public ScopeDAO getScope(Long siidl) {\n-        for (ProcessDaoImpl process : _store.values()) {\n-            for (ProcessInstanceDAO instance : process._instances.values()) {\n-                if (instance.getScope(siidl) != null) return instance.getScope(siidl);\n-            }\n-        }\n-        return null;\n+    ProcessDAO process1 = getProcess(instanceDAO1.getProcess().getProcessId());\n+    ProcessDAO process2 = getProcess(instanceDAO2.getProcess().getProcessId());\n+    if (\"pid\".equals(orderKey)) {\n+      s1 = process1.getProcessId().toString();\n+      s2 = process2.getProcessId().toString();\n+    } else if (\"name\".equals(orderKey)) {\n+      s1 = process1.getProcessId().getLocalPart();\n+      s2 = process2.getProcessId().getLocalPart();\n+    } else if (\"namespace\".equals(orderKey)) {\n+      s1 = process1.getProcessId().getNamespaceURI();\n+      s2 = process2.getProcessId().getNamespaceURI();\n+    } else if (\"version\".equals(orderKey)) {\n+      s1 = \"\" + process1.getVersion();\n+      s2 = \"\" + process2.getVersion();\n+    } else if (\"status\".equals(orderKey)) {\n+      s1 = \"\" + instanceDAO1.getState();\n+      s2 = \"\" + instanceDAO2.getState();\n+    } else if (\"started\".equals(orderKey)) {\n+      s1 = ISO8601DateParser.format(instanceDAO1.getCreateTime());\n+      s2 = ISO8601DateParser.format(instanceDAO2.getCreateTime());\n+    } else if (\"last-active\".equals(orderKey)) {\n+      s1 = ISO8601DateParser.format(instanceDAO1.getLastActiveTime());\n+      s2 = ISO8601DateParser.format(instanceDAO2.getLastActiveTime());\n     }\n-\n-\n-    public void insertBpelEvent(BpelEvent event, ProcessDAO processConfiguration, ProcessInstanceDAO instance) {\n-        _events.add(event);\n+    if (ascending) {\n+      return s1.compareTo(s2);\n+    } else {\n+      return s2.compareTo(s1);\n     }\n+  }\n \n-\n-    public List<Date> bpelEventTimelineQuery(InstanceFilter ifilter, BpelEventFilter efilter) {\n-        // TODO : Provide more correct implementation:\n-        ArrayList<Date> dates = new ArrayList<Date>();\n-        CollectionsX.transform(dates, _events, new UnaryFunction<BpelEvent,Date>() {\n-            public Date apply(BpelEvent x) {\n-                return x.getTimestamp();\n-            }\n-        });\n-        return dates;\n+  private boolean equalsOrWildcardMatch(String s1, String s2) {\n+    if (s1 == null || s2 == null) {\n+      return false;\n     }\n-\n-\n-    public List<BpelEvent> bpelEventQuery(InstanceFilter ifilter, BpelEventFilter efilter) {\n-        // TODO : Provide a more correct (filtering) implementation:\n-        return _events;\n+    if (s1.equals(s2)) {\n+      return true;\n     }\n-\n-    /**\n-     * @see org.apache.ode.bpel.dao.BpelDAOConnection#instanceQuery(String)\n-     */\n-    public Collection<ProcessInstanceDAO> instanceQuery(String expression) {\n-        //TODO\n-        throw new UnsupportedOperationException();\n+    if (s1.endsWith(\"*\")) {\n+      if (s2.startsWith(s1.substring(0, s1.length() - 1))) {\n+        return true;\n+      }\n     }\n-\n-    public Long instanceCount(InstanceFilter criteria) {\n-        throw new UnsupportedOperationException();\n+    if (s2.endsWith(\"*\")) {\n+      if (s1.startsWith(s2.substring(0, s2.length() - 1))) {\n+        return true;\n+      }\n     }\n-\n-    static void removeMessageExchange(String mexId) {\n-        // Cleaning up mex\n-        if (__log.isDebugEnabled()) __log.debug(\"Removing mex \" + mexId + \" from memory store.\");\n-        MessageExchangeDAO mex = _mexStore.remove(mexId);\n-        if (mex == null)\n-            __log.warn(\"Couldn't find mex \" + mexId + \" for cleanup.\");\n-        _mexAge.remove(mexId);\n+    return false;\n+  }\n+\n+  public boolean dateMatch(List<String> dateFilters, Date instanceDate, InstanceFilter filter) {\n+    boolean match = true;\n+    for (String ddf : dateFilters) {\n+      String isoDate = ISO8601DateParser.format(instanceDate);\n+      String critDate = Filter.getDateWithoutOp(ddf);\n+      if (ddf.startsWith(\"=\")) {\n+        if (!isoDate.startsWith(critDate)) {\n+          match = false;\n+        }\n+      } else if (ddf.startsWith(\"<=\")) {\n+        if (!isoDate.startsWith(critDate) && isoDate.compareTo(critDate) > 0) {\n+          match = false;\n+        }\n+      } else if (ddf.startsWith(\">=\")) {\n+        if (!isoDate.startsWith(critDate) && isoDate.compareTo(critDate) < 0) {\n+          match = false;\n+        }\n+      } else if (ddf.startsWith(\"<\")) {\n+        if (isoDate.compareTo(critDate) > 0) {\n+          match = false;\n+        }\n+      } else if (ddf.startsWith(\">\")) {\n+        if (isoDate.compareTo(critDate) < 0) {\n+          match = false;\n+        }\n+      }\n     }\n+    return match;\n+  }\n \n-    public void defer(final Runnable runnable) {\n-        _scheduler.registerSynchronizer(new Scheduler.Synchronizer() {\n-            public void afterCompletion(boolean success) {\n-            }\n-            public void beforeCompletion() {\n-                runnable.run();\n-            }\n-        });\n-    }\n-    public void onRollback(final Runnable runnable) {\n-        _scheduler.registerSynchronizer(new Scheduler.Synchronizer() {\n-            public void afterCompletion(boolean success) {\n-                if (!success) runnable.run();\n-            }\n-            public void beforeCompletion() {\n-            }\n-        });\n-    }\n \n-    public Map<Long, Collection<CorrelationSetDAO>> getCorrelationSets(Collection<ProcessInstanceDAO> instances) {\n-        Map<Long, Collection<CorrelationSetDAO>> map = new HashMap<Long, Collection<CorrelationSetDAO>>();\n-        for (ProcessInstanceDAO instance: instances) {\n-            Long id = instance.getInstanceId();\n-            Collection<CorrelationSetDAO> existing = map.get(id);\n-            if (existing == null) {\n-                existing = new ArrayList<CorrelationSetDAO>();\n-                map.put(id, existing);\n-            }\n-            existing.addAll(instance.getCorrelationSets());\n+  public ScopeDAO getScope(Long siidl) {\n+    for (ProcessDaoImpl process : _store.values()) {\n+      for (ProcessInstanceDAO instance : process._instances.values()) {\n+        if (instance.getScope(siidl) != null) {\n+          return instance.getScope(siidl);\n         }\n-        return map;\n+      }\n     }\n-\n-    public Collection<CorrelationSetDAO> getActiveCorrelationSets() {\n-        throw new UnsupportedOperationException();\n+    return null;\n+  }\n+\n+\n+  public void insertBpelEvent(BpelEvent event, ProcessDAO processConfiguration, ProcessInstanceDAO instance) {\n+    _events.add(event);\n+  }\n+\n+\n+  public List<Date> bpelEventTimelineQuery(InstanceFilter ifilter, BpelEventFilter efilter) {\n+    // TODO : Provide more correct implementation:\n+    ArrayList<Date> dates = new ArrayList<Date>();\n+    CollectionsX.transform(dates, _events, new UnaryFunction<BpelEvent, Date>() {\n+      public Date apply(BpelEvent x) {\n+        return x.getTimestamp();\n+      }\n+    });\n+    return dates;\n+  }\n+\n+\n+  public List<BpelEvent> bpelEventQuery(InstanceFilter ifilter, BpelEventFilter efilter) {\n+    // TODO : Provide a more correct (filtering) implementation:\n+    return _events;\n+  }\n+\n+  /**\n+   * @see org.apache.ode.bpel.dao.BpelDAOConnection#instanceQuery(String)\n+   */\n+  public Collection<ProcessInstanceDAO> instanceQuery(String expression) {\n+    //TODO\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public Long instanceCount(InstanceFilter criteria) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  static void removeMessageExchange(String mexId) {\n+    // Cleaning up mex\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(\"Removing mex \" + mexId + \" from memory store.\");\n     }\n-\n-    public ProcessManagementDaoImpl getProcessManagement() {\n-        return new ProcessManagementDaoImpl();\n+    MessageExchangeDAO mex = _mexStore.remove(mexId);\n+    if (mex == null) {\n+      __log.warn(\"Couldn't find mex \" + mexId + \" for cleanup.\");\n     }\n-\n-    public AttachmentDAO getAttachmentDAO(Long attachmentID, MessageExchangeDAO mex) {\n-        String message = \"Method is not implemented.\";\n-        UnsupportedOperationException ex = new UnsupportedOperationException(message);\n-        __log.warn(message, ex);\n-        throw ex;\n+    _mexAge.remove(mexId);\n+  }\n+\n+  public void defer(final Runnable runnable) {\n+    _scheduler.registerSynchronizer(new Scheduler.Synchronizer() {\n+      public void afterCompletion(boolean success) {\n+      }\n+\n+      public void beforeCompletion() {\n+        runnable.run();\n+      }\n+    });\n+  }\n+\n+  public void onRollback(final Runnable runnable) {\n+    _scheduler.registerSynchronizer(new Scheduler.Synchronizer() {\n+      public void afterCompletion(boolean success) {\n+        if (!success) {\n+          runnable.run();\n+        }\n+      }\n+\n+      public void beforeCompletion() {\n+      }\n+    });\n+  }\n+\n+  public Map<Long, Collection<CorrelationSetDAO>> getCorrelationSets(Collection<ProcessInstanceDAO> instances) {\n+    Map<Long, Collection<CorrelationSetDAO>> map = new HashMap<Long, Collection<CorrelationSetDAO>>();\n+    for (ProcessInstanceDAO instance : instances) {\n+      Long id = instance.getInstanceId();\n+      Collection<CorrelationSetDAO> existing = map.get(id);\n+      if (existing == null) {\n+        existing = new ArrayList<CorrelationSetDAO>();\n+        map.put(id, existing);\n+      }\n+      existing.addAll(instance.getCorrelationSets());\n     }\n+    return map;\n+  }\n+\n+  public Collection<CorrelationSetDAO> getActiveCorrelationSets() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ProcessManagementDaoImpl getProcessManagement() {\n+    return new ProcessManagementDaoImpl();\n+  }\n+\n+  public AttachmentDAO getAttachmentDAO(Long attachmentID, MessageExchangeDAO mex) {\n+    String message = \"Method is not implemented.\";\n+    UnsupportedOperationException ex = new UnsupportedOperationException(message);\n+    __log.warn(message, ex);\n+    throw ex;\n+  }\n }\n",
            "diff_size": 446
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "51",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "105",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "107",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 146).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "122",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 137).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "124",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/283/BpelDAOConnectionImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/283/BpelDAOConnectionImpl.java\nindex d0579006400..ec3e4969a4c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/283/BpelDAOConnectionImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/283/BpelDAOConnectionImpl.java\n@@ -88,7 +88,8 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n         ProcessDAO process = getProcess(processId);\n         if (process != null)\n             return process.getNumInstances();\n-        else return -1;\n+        else\n+    return -1;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n@@ -101,11 +102,9 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n         selectionCompleted:\n         for (ProcessDaoImpl proc : _store.values()) {\n             boolean pmatch = true;\n-            if (filter.getNameFilter() != null\n-                    && !equalsOrWildcardMatch(filter.getNameFilter(), proc.getProcessId().getLocalPart()))\n+            if (filter.getNameFilter() != null && !equalsOrWildcardMatch(filter.getNameFilter(), proc.getProcessId().getLocalPart()))\n                 pmatch = false;\n-            if (filter.getNamespaceFilter() != null\n-                    && !equalsOrWildcardMatch(filter.getNamespaceFilter(), proc.getProcessId().getNamespaceURI()))\n+            if (filter.getNamespaceFilter() != null && !equalsOrWildcardMatch(filter.getNamespaceFilter(), proc.getProcessId().getNamespaceURI()))\n                 pmatch = false;\n \n             if (pmatch) {\n@@ -115,34 +114,18 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n                     if (filter.getStatusFilter() != null) {\n                         boolean statusMatch = false;\n                         for (Short status : filter.convertFilterState()) {\n-                            if (inst.getState() == status.byteValue()) statusMatch = true;\n+                            if (inst.getState() == status.byteValue())\n+    statusMatch = true;\n                         }\n                         if (!statusMatch) match = false;\n                     }\n-                    if (filter.getStartedDateFilter() != null\n-                            && !dateMatch(filter.getStartedDateFilter(), inst.getCreateTime(), filter))\n+                    if (filter.getStartedDateFilter() != null && !dateMatch(filter.getStartedDateFilter(), inst.getCreateTime(), filter))\n                         match = false;\n-                    if (filter.getLastActiveDateFilter() != null\n-                            && !dateMatch(filter.getLastActiveDateFilter(), inst.getLastActiveTime(), filter))\n+                    if (filter.getLastActiveDateFilter() != null && !dateMatch(filter.getLastActiveDateFilter(), inst.getLastActiveTime(), filter))\n                         match = false;\n \n-//                    if (filter.getPropertyValuesFilter() != null) {\n-//                        for (Map.Entry propEntry : filter.getPropertyValuesFilter().entrySet()) {\n-//                            boolean entryMatched = false;\n-//                            for (ProcessPropertyDAO prop : proc.getProperties()) {\n-//                                if (prop.getName().equals(propEntry.getKey())\n-//                                        && (propEntry.getValue().equals(prop.getMixedContent())\n-//                                        || propEntry.getValue().equals(prop.getSimpleContent()))) {\n-//                                    entryMatched = true;\n-//                                }\n-//                            }\n-//                            if (!entryMatched) {\n-//                                match = false;\n-//                            }\n-//                        }\n-//                    }\n-\n-                    if (match) {\n+    //                    if (fil\n+if (match) {\n                         matched.add(inst);\n                         if(matched.size()==filter.getLimit()) {\n                             break selectionCompleted;\n@@ -221,7 +204,8 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n         String orderKey = key;\n         if (key.startsWith(\"+\") || key.startsWith(\"-\")) {\n             orderKey = key.substring(1, key.length());\n-            if (key.startsWith(\"-\")) ascending = false;\n+            if (key.startsWith(\"-\"))\n+    ascending = false;\n         }\n         ProcessDAO process1 = getProcess(instanceDAO1.getProcess().getProcessId());\n         ProcessDAO process2 = getProcess(instanceDAO2.getProcess().getProcessId());\n@@ -263,13 +247,14 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n         return false;\n     }\n \n-    public boolean dateMatch(List<String> dateFilters, Date instanceDate,  InstanceFilter filter) {\n+    public boolean dateMatch(List<String> dateFilters, Date instanceDate, InstanceFilter filter) {\n         boolean match = true;\n         for (String ddf : dateFilters) {\n             String isoDate = ISO8601DateParser.format(instanceDate);\n             String critDate = Filter.getDateWithoutOp(ddf);\n             if (ddf.startsWith(\"=\")) {\n-                if (!isoDate.startsWith(critDate)) match = false;\n+                if (!isoDate.startsWith(critDate))\n+    match = false;\n             } else if (ddf.startsWith(\"<=\")) {\n                 if (!isoDate.startsWith(critDate) && isoDate.compareTo(critDate) > 0) match = false;\n             } else if (ddf.startsWith(\">=\")) {\n@@ -384,4 +369,4 @@ class BpelDAOConnectionImpl implements BpelDAOConnection {\n         __log.warn(message, ex);\n         throw ex;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 35
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "51",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "51",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}