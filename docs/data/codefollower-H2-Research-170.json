{
    "project_name": "codefollower-H2-Research",
    "error_id": "170",
    "information": {
        "errors": [
            {
                "line": "340",
                "column": "60",
                "severity": "warning",
                "message": "',' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "            int scale = Math.max(l.getScale(), r.getScale());\n            int displaySize = Math.max(l.getDisplaySize(), r.getDisplaySize());\n            String columnName = ColumnNamer.getColumnName(l,i);\n            Column col = new Column(columnName, type, prec, scale, displaySize);\n            Expression e = new ExpressionColumn(session.getDatabase(), col);\n            expressions.add(e);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/170/SelectUnion.java\nindex d1b4ee2a713..a4aa507964c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/170/SelectUnion.java\n@@ -337,7 +337,7 @@ public class SelectUnion extends Query {\n             long prec = Math.max(l.getPrecision(), r.getPrecision());\n             int scale = Math.max(l.getScale(), r.getScale());\n             int displaySize = Math.max(l.getDisplaySize(), r.getDisplaySize());\n-            String columnName = ColumnNamer.getColumnName(l,i);\n+            String columnName = ColumnNamer.getColumnName(l, i);\n             Column col = new Column(columnName, type, prec, scale, displaySize);\n             Expression e = new ExpressionColumn(session.getDatabase(), col);\n             expressions.add(e);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/170/SelectUnion.java\nindex d1b4ee2a713..1db30f795bb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/170/SelectUnion.java\n@@ -3,10 +3,12 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.command.dml;\n \n import java.util.ArrayList;\n import java.util.HashSet;\n+\n import org.h2.api.ErrorCode;\n import org.h2.command.CommandInterface;\n import org.h2.engine.Session;\n@@ -38,525 +40,525 @@ import org.h2.value.ValueNull;\n  */\n public class SelectUnion extends Query {\n \n-    /**\n-     * The type of a UNION statement.\n-     */\n-    public static final int UNION = 0;\n-\n-    /**\n-     * The type of a UNION ALL statement.\n-     */\n-    public static final int UNION_ALL = 1;\n-\n-    /**\n-     * The type of an EXCEPT statement.\n-     */\n-    public static final int EXCEPT = 2;\n-\n-    /**\n-     * The type of an INTERSECT statement.\n-     */\n-    public static final int INTERSECT = 3;\n-\n-    private int unionType;\n-    private final Query left;\n-    private Query right;\n-    private ArrayList<Expression> expressions;\n-    private Expression[] expressionArray;\n-    private ArrayList<SelectOrderBy> orderList;\n-    private SortOrder sort;\n-    private boolean isPrepared, checkInit;\n-    private boolean isForUpdate;\n-\n-    public SelectUnion(Session session, Query query) {\n-        super(session);\n-        this.left = query;\n-    }\n-\n-    @Override\n-    public boolean isUnion() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void prepareJoinBatch() {\n-        left.prepareJoinBatch();\n-        right.prepareJoinBatch();\n-    }\n-\n-    public void setUnionType(int type) {\n-        this.unionType = type;\n-    }\n-\n-    public int getUnionType() {\n-        return unionType;\n-    }\n-\n-    public void setRight(Query select) {\n-        right = select;\n-    }\n-\n-    public Query getLeft() {\n-        return left;\n-    }\n-\n-    public Query getRight() {\n-        return right;\n-    }\n-\n-    @Override\n-    public void setSQL(String sql) {\n-        this.sqlStatement = sql;\n-    }\n-\n-    @Override\n-    public void setOrder(ArrayList<SelectOrderBy> order) {\n-        orderList = order;\n+  /**\n+   * The type of a UNION statement.\n+   */\n+  public static final int UNION = 0;\n+\n+  /**\n+   * The type of a UNION ALL statement.\n+   */\n+  public static final int UNION_ALL = 1;\n+\n+  /**\n+   * The type of an EXCEPT statement.\n+   */\n+  public static final int EXCEPT = 2;\n+\n+  /**\n+   * The type of an INTERSECT statement.\n+   */\n+  public static final int INTERSECT = 3;\n+\n+  private int unionType;\n+  private final Query left;\n+  private Query right;\n+  private ArrayList<Expression> expressions;\n+  private Expression[] expressionArray;\n+  private ArrayList<SelectOrderBy> orderList;\n+  private SortOrder sort;\n+  private boolean isPrepared, checkInit;\n+  private boolean isForUpdate;\n+\n+  public SelectUnion(Session session, Query query) {\n+    super(session);\n+    this.left = query;\n+  }\n+\n+  @Override\n+  public boolean isUnion() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void prepareJoinBatch() {\n+    left.prepareJoinBatch();\n+    right.prepareJoinBatch();\n+  }\n+\n+  public void setUnionType(int type) {\n+    this.unionType = type;\n+  }\n+\n+  public int getUnionType() {\n+    return unionType;\n+  }\n+\n+  public void setRight(Query select) {\n+    right = select;\n+  }\n+\n+  public Query getLeft() {\n+    return left;\n+  }\n+\n+  public Query getRight() {\n+    return right;\n+  }\n+\n+  @Override\n+  public void setSQL(String sql) {\n+    this.sqlStatement = sql;\n+  }\n+\n+  @Override\n+  public void setOrder(ArrayList<SelectOrderBy> order) {\n+    orderList = order;\n+  }\n+\n+  @Override\n+  public boolean hasOrder() {\n+    return orderList != null || sort != null;\n+  }\n+\n+  private Value[] convert(Value[] values, int columnCount) {\n+    Value[] newValues;\n+    if (columnCount == values.length) {\n+      // re-use the array if possible\n+      newValues = values;\n+    } else {\n+      // create a new array if needed,\n+      // for the value hash set\n+      newValues = new Value[columnCount];\n+    }\n+    for (int i = 0; i < columnCount; i++) {\n+      Expression e = expressions.get(i);\n+      newValues[i] = values[i].convertTo(e.getType());\n+    }\n+    return newValues;\n+  }\n+\n+  @Override\n+  public ResultInterface queryMeta() {\n+    int columnCount = left.getColumnCount();\n+    LocalResult result = new LocalResult(session, expressionArray, columnCount);\n+    result.done();\n+    return result;\n+  }\n+\n+  public LocalResult getEmptyResult() {\n+    int columnCount = left.getColumnCount();\n+    return new LocalResult(session, expressionArray, columnCount);\n+  }\n+\n+  @Override\n+  protected ResultInterface queryWithoutCache(int maxRows, ResultTarget target) {\n+    if (maxRows != 0) {\n+      // maxRows is set (maxRows 0 means no limit)\n+      int l;\n+      if (limitExpr == null) {\n+        l = -1;\n+      } else {\n+        Value v = limitExpr.getValue(session);\n+        l = v == ValueNull.INSTANCE ? -1 : v.getInt();\n+      }\n+      if (l < 0) {\n+        // for limitExpr, 0 means no rows, and -1 means no limit\n+        l = maxRows;\n+      } else {\n+        l = Math.min(l, maxRows);\n+      }\n+      limitExpr = ValueExpression.get(ValueInt.get(l));\n+    }\n+    if (session.getDatabase().getSettings().optimizeInsertFromSelect) {\n+      if (unionType == UNION_ALL && target != null) {\n+        if (sort == null && !distinct && maxRows == 0 &&\n+            offsetExpr == null && limitExpr == null) {\n+          left.query(0, target);\n+          right.query(0, target);\n+          return null;\n+        }\n+      }\n+    }\n+    int columnCount = left.getColumnCount();\n+    if (session.isLazyQueryExecution() && unionType == UNION_ALL && !distinct &&\n+        sort == null && !randomAccessResult && !isForUpdate &&\n+        offsetExpr == null && isReadOnly()) {\n+      int limit = -1;\n+      if (limitExpr != null) {\n+        Value v = limitExpr.getValue(session);\n+        if (v != ValueNull.INSTANCE) {\n+          limit = v.getInt();\n+        }\n+      }\n+      // limit 0 means no rows\n+      if (limit != 0) {\n+        LazyResultUnion lazyResult = new LazyResultUnion(expressionArray, columnCount);\n+        if (limit > 0) {\n+          lazyResult.setLimit(limit);\n+        }\n+        return lazyResult;\n+      }\n+    }\n+    LocalResult result = new LocalResult(session, expressionArray, columnCount);\n+    if (sort != null) {\n+      result.setSortOrder(sort);\n+    }\n+    if (distinct) {\n+      left.setDistinct(true);\n+      right.setDistinct(true);\n+      result.setDistinct();\n+    }\n+    if (randomAccessResult) {\n+      result.setRandomAccess();\n+    }\n+    switch (unionType) {\n+      case UNION:\n+      case EXCEPT:\n+        left.setDistinct(true);\n+        right.setDistinct(true);\n+        result.setDistinct();\n+        break;\n+      case UNION_ALL:\n+        break;\n+      case INTERSECT:\n+        left.setDistinct(true);\n+        right.setDistinct(true);\n+        break;\n+      default:\n+        DbException.throwInternalError(\"type=\" + unionType);\n+    }\n+    ResultInterface l = left.query(0);\n+    ResultInterface r = right.query(0);\n+    l.reset();\n+    r.reset();\n+    switch (unionType) {\n+      case UNION_ALL:\n+      case UNION: {\n+        while (l.next()) {\n+          result.addRow(convert(l.currentRow(), columnCount));\n+        }\n+        while (r.next()) {\n+          result.addRow(convert(r.currentRow(), columnCount));\n+        }\n+        break;\n+      }\n+      case EXCEPT: {\n+        while (l.next()) {\n+          result.addRow(convert(l.currentRow(), columnCount));\n+        }\n+        while (r.next()) {\n+          result.removeDistinct(convert(r.currentRow(), columnCount));\n+        }\n+        break;\n+      }\n+      case INTERSECT: {\n+        LocalResult temp = new LocalResult(session, expressionArray, columnCount);\n+        temp.setDistinct();\n+        temp.setRandomAccess();\n+        while (l.next()) {\n+          temp.addRow(convert(l.currentRow(), columnCount));\n+        }\n+        while (r.next()) {\n+          Value[] values = convert(r.currentRow(), columnCount);\n+          if (temp.containsDistinct(values)) {\n+            result.addRow(values);\n+          }\n+        }\n+        temp.close();\n+        break;\n+      }\n+      default:\n+        DbException.throwInternalError(\"type=\" + unionType);\n+    }\n+    if (offsetExpr != null) {\n+      result.setOffset(offsetExpr.getValue(session).getInt());\n+    }\n+    if (limitExpr != null) {\n+      Value v = limitExpr.getValue(session);\n+      if (v != ValueNull.INSTANCE) {\n+        result.setLimit(v.getInt());\n+      }\n+    }\n+    l.close();\n+    r.close();\n+    result.done();\n+    if (target != null) {\n+      while (result.next()) {\n+        target.addRow(result.currentRow());\n+      }\n+      result.close();\n+      return null;\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public void init() {\n+    if (SysProperties.CHECK && checkInit) {\n+      DbException.throwInternalError();\n+    }\n+    checkInit = true;\n+    left.init();\n+    right.init();\n+    int len = left.getColumnCount();\n+    if (len != right.getColumnCount()) {\n+      throw DbException.get(ErrorCode.COLUMN_COUNT_DOES_NOT_MATCH);\n+    }\n+    ArrayList<Expression> le = left.getExpressions();\n+    // set the expressions to get the right column count and names,\n+    // but can't validate at this time\n+    expressions = New.arrayList();\n+    for (int i = 0; i < len; i++) {\n+      Expression l = le.get(i);\n+      expressions.add(l);\n+    }\n+  }\n+\n+  @Override\n+  public void prepare() {\n+    if (isPrepared) {\n+      // sometimes a subquery is prepared twice (CREATE TABLE AS SELECT)\n+      return;\n+    }\n+    if (SysProperties.CHECK && !checkInit) {\n+      DbException.throwInternalError(\"not initialized\");\n+    }\n+    isPrepared = true;\n+    left.prepare();\n+    right.prepare();\n+    int len = left.getColumnCount();\n+    // set the correct expressions now\n+    expressions = New.arrayList();\n+    ArrayList<Expression> le = left.getExpressions();\n+    ArrayList<Expression> re = right.getExpressions();\n+    for (int i = 0; i < len; i++) {\n+      Expression l = le.get(i);\n+      Expression r = re.get(i);\n+      int type = Value.getHigherOrder(l.getType(), r.getType());\n+      long prec = Math.max(l.getPrecision(), r.getPrecision());\n+      int scale = Math.max(l.getScale(), r.getScale());\n+      int displaySize = Math.max(l.getDisplaySize(), r.getDisplaySize());\n+      String columnName = ColumnNamer.getColumnName(l, i);\n+      Column col = new Column(columnName, type, prec, scale, displaySize);\n+      Expression e = new ExpressionColumn(session.getDatabase(), col);\n+      expressions.add(e);\n+    }\n+    if (orderList != null) {\n+      initOrder(session, expressions, null, orderList, getColumnCount(), true, null);\n+      sort = prepareOrder(orderList, expressions.size());\n+      orderList = null;\n+    }\n+    expressionArray = new Expression[expressions.size()];\n+    expressions.toArray(expressionArray);\n+  }\n+\n+  @Override\n+  public double getCost() {\n+    return left.getCost() + right.getCost();\n+  }\n+\n+  @Override\n+  public HashSet<Table> getTables() {\n+    HashSet<Table> set = left.getTables();\n+    set.addAll(right.getTables());\n+    return set;\n+  }\n+\n+  @Override\n+  public ArrayList<Expression> getExpressions() {\n+    return expressions;\n+  }\n+\n+  @Override\n+  public void setForUpdate(boolean forUpdate) {\n+    left.setForUpdate(forUpdate);\n+    right.setForUpdate(forUpdate);\n+    isForUpdate = forUpdate;\n+  }\n+\n+  @Override\n+  public int getColumnCount() {\n+    return left.getColumnCount();\n+  }\n+\n+  @Override\n+  public void mapColumns(ColumnResolver resolver, int level) {\n+    left.mapColumns(resolver, level);\n+    right.mapColumns(resolver, level);\n+  }\n+\n+  @Override\n+  public void setEvaluatable(TableFilter tableFilter, boolean b) {\n+    left.setEvaluatable(tableFilter, b);\n+    right.setEvaluatable(tableFilter, b);\n+  }\n+\n+  @Override\n+  public void addGlobalCondition(Parameter param, int columnId,\n+                                 int comparisonType) {\n+    addParameter(param);\n+    switch (unionType) {\n+      case UNION_ALL:\n+      case UNION:\n+      case INTERSECT: {\n+        left.addGlobalCondition(param, columnId, comparisonType);\n+        right.addGlobalCondition(param, columnId, comparisonType);\n+        break;\n+      }\n+      case EXCEPT: {\n+        left.addGlobalCondition(param, columnId, comparisonType);\n+        break;\n+      }\n+      default:\n+        DbException.throwInternalError(\"type=\" + unionType);\n+    }\n+  }\n+\n+  @Override\n+  public String getPlanSQL() {\n+    StringBuilder buff = new StringBuilder();\n+    buff.append('(').append(left.getPlanSQL()).append(')');\n+    switch (unionType) {\n+      case UNION_ALL:\n+        buff.append(\"\\nUNION ALL\\n\");\n+        break;\n+      case UNION:\n+        buff.append(\"\\nUNION\\n\");\n+        break;\n+      case INTERSECT:\n+        buff.append(\"\\nINTERSECT\\n\");\n+        break;\n+      case EXCEPT:\n+        buff.append(\"\\nEXCEPT\\n\");\n+        break;\n+      default:\n+        DbException.throwInternalError(\"type=\" + unionType);\n+    }\n+    buff.append('(').append(right.getPlanSQL()).append(')');\n+    Expression[] exprList = expressions.toArray(new Expression[expressions.size()]);\n+    if (sort != null) {\n+      buff.append(\"\\nORDER BY \").append(sort.getSQL(exprList, exprList.length));\n+    }\n+    if (limitExpr != null) {\n+      buff.append(\"\\nLIMIT \").append(\n+          StringUtils.unEnclose(limitExpr.getSQL()));\n+      if (offsetExpr != null) {\n+        buff.append(\"\\nOFFSET \").append(\n+            StringUtils.unEnclose(offsetExpr.getSQL()));\n+      }\n+    }\n+    if (sampleSizeExpr != null) {\n+      buff.append(\"\\nSAMPLE_SIZE \").append(\n+          StringUtils.unEnclose(sampleSizeExpr.getSQL()));\n+    }\n+    if (isForUpdate) {\n+      buff.append(\"\\nFOR UPDATE\");\n+    }\n+    return buff.toString();\n+  }\n+\n+  @Override\n+  public boolean isEverything(ExpressionVisitor visitor) {\n+    return left.isEverything(visitor) && right.isEverything(visitor);\n+  }\n+\n+  @Override\n+  public boolean isReadOnly() {\n+    return left.isReadOnly() && right.isReadOnly();\n+  }\n+\n+  @Override\n+  public void updateAggregate(Session s) {\n+    left.updateAggregate(s);\n+    right.updateAggregate(s);\n+  }\n+\n+  @Override\n+  public void fireBeforeSelectTriggers() {\n+    left.fireBeforeSelectTriggers();\n+    right.fireBeforeSelectTriggers();\n+  }\n+\n+  @Override\n+  public int getType() {\n+    return CommandInterface.SELECT;\n+  }\n+\n+  @Override\n+  public boolean allowGlobalConditions() {\n+    return left.allowGlobalConditions() && right.allowGlobalConditions();\n+  }\n+\n+  /**\n+   * Lazy execution for this union.\n+   */\n+  private final class LazyResultUnion extends LazyResult {\n+\n+    int columnCount;\n+    ResultInterface l;\n+    ResultInterface r;\n+    boolean leftDone;\n+    boolean rightDone;\n+\n+    LazyResultUnion(Expression[] expressions, int columnCount) {\n+      super(expressions);\n+      this.columnCount = columnCount;\n     }\n \n     @Override\n-    public boolean hasOrder() {\n-        return orderList != null || sort != null;\n-    }\n-\n-    private Value[] convert(Value[] values, int columnCount) {\n-        Value[] newValues;\n-        if (columnCount == values.length) {\n-            // re-use the array if possible\n-            newValues = values;\n-        } else {\n-            // create a new array if needed,\n-            // for the value hash set\n-            newValues = new Value[columnCount];\n-        }\n-        for (int i = 0; i < columnCount; i++) {\n-            Expression e = expressions.get(i);\n-            newValues[i] = values[i].convertTo(e.getType());\n-        }\n-        return newValues;\n+    public int getVisibleColumnCount() {\n+      return columnCount;\n     }\n \n     @Override\n-    public ResultInterface queryMeta() {\n-        int columnCount = left.getColumnCount();\n-        LocalResult result = new LocalResult(session, expressionArray, columnCount);\n-        result.done();\n-        return result;\n-    }\n-\n-    public LocalResult getEmptyResult() {\n-        int columnCount = left.getColumnCount();\n-        return new LocalResult(session, expressionArray, columnCount);\n+    protected Value[] fetchNextRow() {\n+      if (rightDone) {\n+        return null;\n+      }\n+      if (!leftDone) {\n+        if (l == null) {\n+          l = left.query(0);\n+          l.reset();\n+        }\n+        if (l.next()) {\n+          return l.currentRow();\n+        }\n+        leftDone = true;\n+      }\n+      if (r == null) {\n+        r = right.query(0);\n+        r.reset();\n+      }\n+      if (r.next()) {\n+        return r.currentRow();\n+      }\n+      rightDone = true;\n+      return null;\n     }\n \n     @Override\n-    protected ResultInterface queryWithoutCache(int maxRows, ResultTarget target) {\n-        if (maxRows != 0) {\n-            // maxRows is set (maxRows 0 means no limit)\n-            int l;\n-            if (limitExpr == null) {\n-                l = -1;\n-            } else {\n-                Value v = limitExpr.getValue(session);\n-                l = v == ValueNull.INSTANCE ? -1 : v.getInt();\n-            }\n-            if (l < 0) {\n-                // for limitExpr, 0 means no rows, and -1 means no limit\n-                l = maxRows;\n-            } else {\n-                l = Math.min(l, maxRows);\n-            }\n-            limitExpr = ValueExpression.get(ValueInt.get(l));\n-        }\n-        if (session.getDatabase().getSettings().optimizeInsertFromSelect) {\n-            if (unionType == UNION_ALL && target != null) {\n-                if (sort == null && !distinct && maxRows == 0 &&\n-                        offsetExpr == null && limitExpr == null) {\n-                    left.query(0, target);\n-                    right.query(0, target);\n-                    return null;\n-                }\n-            }\n-        }\n-        int columnCount = left.getColumnCount();\n-        if (session.isLazyQueryExecution() && unionType == UNION_ALL && !distinct &&\n-                sort == null && !randomAccessResult && !isForUpdate &&\n-                offsetExpr == null && isReadOnly()) {\n-            int limit = -1;\n-            if (limitExpr != null) {\n-                Value v = limitExpr.getValue(session);\n-                if (v != ValueNull.INSTANCE) {\n-                    limit = v.getInt();\n-                }\n-            }\n-            // limit 0 means no rows\n-            if (limit != 0) {\n-                LazyResultUnion lazyResult = new LazyResultUnion(expressionArray, columnCount);\n-                if (limit > 0) {\n-                    lazyResult.setLimit(limit);\n-                }\n-                return lazyResult;\n-            }\n-        }\n-        LocalResult result = new LocalResult(session, expressionArray, columnCount);\n-        if (sort != null) {\n-            result.setSortOrder(sort);\n-        }\n-        if (distinct) {\n-            left.setDistinct(true);\n-            right.setDistinct(true);\n-            result.setDistinct();\n-        }\n-        if (randomAccessResult) {\n-            result.setRandomAccess();\n-        }\n-        switch (unionType) {\n-        case UNION:\n-        case EXCEPT:\n-            left.setDistinct(true);\n-            right.setDistinct(true);\n-            result.setDistinct();\n-            break;\n-        case UNION_ALL:\n-            break;\n-        case INTERSECT:\n-            left.setDistinct(true);\n-            right.setDistinct(true);\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + unionType);\n-        }\n-        ResultInterface l = left.query(0);\n-        ResultInterface r = right.query(0);\n-        l.reset();\n-        r.reset();\n-        switch (unionType) {\n-        case UNION_ALL:\n-        case UNION: {\n-            while (l.next()) {\n-                result.addRow(convert(l.currentRow(), columnCount));\n-            }\n-            while (r.next()) {\n-                result.addRow(convert(r.currentRow(), columnCount));\n-            }\n-            break;\n-        }\n-        case EXCEPT: {\n-            while (l.next()) {\n-                result.addRow(convert(l.currentRow(), columnCount));\n-            }\n-            while (r.next()) {\n-                result.removeDistinct(convert(r.currentRow(), columnCount));\n-            }\n-            break;\n-        }\n-        case INTERSECT: {\n-            LocalResult temp = new LocalResult(session, expressionArray, columnCount);\n-            temp.setDistinct();\n-            temp.setRandomAccess();\n-            while (l.next()) {\n-                temp.addRow(convert(l.currentRow(), columnCount));\n-            }\n-            while (r.next()) {\n-                Value[] values = convert(r.currentRow(), columnCount);\n-                if (temp.containsDistinct(values)) {\n-                    result.addRow(values);\n-                }\n-            }\n-            temp.close();\n-            break;\n-        }\n-        default:\n-            DbException.throwInternalError(\"type=\" + unionType);\n-        }\n-        if (offsetExpr != null) {\n-            result.setOffset(offsetExpr.getValue(session).getInt());\n-        }\n-        if (limitExpr != null) {\n-            Value v = limitExpr.getValue(session);\n-            if (v != ValueNull.INSTANCE) {\n-                result.setLimit(v.getInt());\n-            }\n-        }\n+    public void close() {\n+      super.close();\n+      if (l != null) {\n         l.close();\n+      }\n+      if (r != null) {\n         r.close();\n-        result.done();\n-        if (target != null) {\n-            while (result.next()) {\n-                target.addRow(result.currentRow());\n-            }\n-            result.close();\n-            return null;\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public void init() {\n-        if (SysProperties.CHECK && checkInit) {\n-            DbException.throwInternalError();\n-        }\n-        checkInit = true;\n-        left.init();\n-        right.init();\n-        int len = left.getColumnCount();\n-        if (len != right.getColumnCount()) {\n-            throw DbException.get(ErrorCode.COLUMN_COUNT_DOES_NOT_MATCH);\n-        }\n-        ArrayList<Expression> le = left.getExpressions();\n-        // set the expressions to get the right column count and names,\n-        // but can't validate at this time\n-        expressions = New.arrayList();\n-        for (int i = 0; i < len; i++) {\n-            Expression l = le.get(i);\n-            expressions.add(l);\n-        }\n-    }\n-\n-    @Override\n-    public void prepare() {\n-        if (isPrepared) {\n-            // sometimes a subquery is prepared twice (CREATE TABLE AS SELECT)\n-            return;\n-        }\n-        if (SysProperties.CHECK && !checkInit) {\n-            DbException.throwInternalError(\"not initialized\");\n-        }\n-        isPrepared = true;\n-        left.prepare();\n-        right.prepare();\n-        int len = left.getColumnCount();\n-        // set the correct expressions now\n-        expressions = New.arrayList();\n-        ArrayList<Expression> le = left.getExpressions();\n-        ArrayList<Expression> re = right.getExpressions();\n-        for (int i = 0; i < len; i++) {\n-            Expression l = le.get(i);\n-            Expression r = re.get(i);\n-            int type = Value.getHigherOrder(l.getType(), r.getType());\n-            long prec = Math.max(l.getPrecision(), r.getPrecision());\n-            int scale = Math.max(l.getScale(), r.getScale());\n-            int displaySize = Math.max(l.getDisplaySize(), r.getDisplaySize());\n-            String columnName = ColumnNamer.getColumnName(l,i);\n-            Column col = new Column(columnName, type, prec, scale, displaySize);\n-            Expression e = new ExpressionColumn(session.getDatabase(), col);\n-            expressions.add(e);\n-        }\n-        if (orderList != null) {\n-            initOrder(session, expressions, null, orderList, getColumnCount(), true, null);\n-            sort = prepareOrder(orderList, expressions.size());\n-            orderList = null;\n-        }\n-        expressionArray = new Expression[expressions.size()];\n-        expressions.toArray(expressionArray);\n-    }\n-\n-    @Override\n-    public double getCost() {\n-        return left.getCost() + right.getCost();\n+      }\n     }\n \n     @Override\n-    public HashSet<Table> getTables() {\n-        HashSet<Table> set = left.getTables();\n-        set.addAll(right.getTables());\n-        return set;\n-    }\n-\n-    @Override\n-    public ArrayList<Expression> getExpressions() {\n-        return expressions;\n-    }\n-\n-    @Override\n-    public void setForUpdate(boolean forUpdate) {\n-        left.setForUpdate(forUpdate);\n-        right.setForUpdate(forUpdate);\n-        isForUpdate = forUpdate;\n-    }\n-\n-    @Override\n-    public int getColumnCount() {\n-        return left.getColumnCount();\n-    }\n-\n-    @Override\n-    public void mapColumns(ColumnResolver resolver, int level) {\n-        left.mapColumns(resolver, level);\n-        right.mapColumns(resolver, level);\n-    }\n-\n-    @Override\n-    public void setEvaluatable(TableFilter tableFilter, boolean b) {\n-        left.setEvaluatable(tableFilter, b);\n-        right.setEvaluatable(tableFilter, b);\n-    }\n-\n-    @Override\n-    public void addGlobalCondition(Parameter param, int columnId,\n-            int comparisonType) {\n-        addParameter(param);\n-        switch (unionType) {\n-        case UNION_ALL:\n-        case UNION:\n-        case INTERSECT: {\n-            left.addGlobalCondition(param, columnId, comparisonType);\n-            right.addGlobalCondition(param, columnId, comparisonType);\n-            break;\n-        }\n-        case EXCEPT: {\n-            left.addGlobalCondition(param, columnId, comparisonType);\n-            break;\n-        }\n-        default:\n-            DbException.throwInternalError(\"type=\" + unionType);\n-        }\n-    }\n-\n-    @Override\n-    public String getPlanSQL() {\n-        StringBuilder buff = new StringBuilder();\n-        buff.append('(').append(left.getPlanSQL()).append(')');\n-        switch (unionType) {\n-        case UNION_ALL:\n-            buff.append(\"\\nUNION ALL\\n\");\n-            break;\n-        case UNION:\n-            buff.append(\"\\nUNION\\n\");\n-            break;\n-        case INTERSECT:\n-            buff.append(\"\\nINTERSECT\\n\");\n-            break;\n-        case EXCEPT:\n-            buff.append(\"\\nEXCEPT\\n\");\n-            break;\n-        default:\n-            DbException.throwInternalError(\"type=\" + unionType);\n-        }\n-        buff.append('(').append(right.getPlanSQL()).append(')');\n-        Expression[] exprList = expressions.toArray(new Expression[expressions.size()]);\n-        if (sort != null) {\n-            buff.append(\"\\nORDER BY \").append(sort.getSQL(exprList, exprList.length));\n-        }\n-        if (limitExpr != null) {\n-            buff.append(\"\\nLIMIT \").append(\n-                    StringUtils.unEnclose(limitExpr.getSQL()));\n-            if (offsetExpr != null) {\n-                buff.append(\"\\nOFFSET \").append(\n-                        StringUtils.unEnclose(offsetExpr.getSQL()));\n-            }\n-        }\n-        if (sampleSizeExpr != null) {\n-            buff.append(\"\\nSAMPLE_SIZE \").append(\n-                    StringUtils.unEnclose(sampleSizeExpr.getSQL()));\n-        }\n-        if (isForUpdate) {\n-            buff.append(\"\\nFOR UPDATE\");\n-        }\n-        return buff.toString();\n-    }\n-\n-    @Override\n-    public boolean isEverything(ExpressionVisitor visitor) {\n-        return left.isEverything(visitor) && right.isEverything(visitor);\n-    }\n-\n-    @Override\n-    public boolean isReadOnly() {\n-        return left.isReadOnly() && right.isReadOnly();\n-    }\n-\n-    @Override\n-    public void updateAggregate(Session s) {\n-        left.updateAggregate(s);\n-        right.updateAggregate(s);\n-    }\n-\n-    @Override\n-    public void fireBeforeSelectTriggers() {\n-        left.fireBeforeSelectTriggers();\n-        right.fireBeforeSelectTriggers();\n-    }\n-\n-    @Override\n-    public int getType() {\n-        return CommandInterface.SELECT;\n-    }\n-\n-    @Override\n-    public boolean allowGlobalConditions() {\n-        return left.allowGlobalConditions() && right.allowGlobalConditions();\n-    }\n-\n-    /**\n-     * Lazy execution for this union.\n-     */\n-    private final class LazyResultUnion extends LazyResult {\n-\n-        int columnCount;\n-        ResultInterface l;\n-        ResultInterface r;\n-        boolean leftDone;\n-        boolean rightDone;\n-\n-        LazyResultUnion(Expression[] expressions, int columnCount) {\n-            super(expressions);\n-            this.columnCount = columnCount;\n-        }\n-\n-        @Override\n-        public int getVisibleColumnCount() {\n-            return columnCount;\n-        }\n-\n-        @Override\n-        protected Value[] fetchNextRow() {\n-            if (rightDone) {\n-                return null;\n-            }\n-            if (!leftDone) {\n-                if (l == null) {\n-                    l = left.query(0);\n-                    l.reset();\n-                }\n-                if (l.next()) {\n-                    return l.currentRow();\n-                }\n-                leftDone = true;\n-            }\n-            if (r == null) {\n-                r = right.query(0);\n-                r.reset();\n-            }\n-            if (r.next()) {\n-                return r.currentRow();\n-            }\n-            rightDone = true;\n-            return null;\n-        }\n-\n-        @Override\n-        public void close() {\n-            super.close();\n-            if (l != null) {\n-                l.close();\n-            }\n-            if (r != null) {\n-                r.close();\n-            }\n-        }\n-\n-        @Override\n-        public void reset() {\n-            super.reset();\n-            if (l != null) {\n-                l.reset();\n-            }\n-            if (r != null) {\n-                r.reset();\n-            }\n-            leftDone = false;\n-            rightDone = false;\n-        }\n+    public void reset() {\n+      super.reset();\n+      if (l != null) {\n+        l.reset();\n+      }\n+      if (r != null) {\n+        r.reset();\n+      }\n+      leftDone = false;\n+      rightDone = false;\n     }\n+  }\n }\n",
            "diff_size": 914
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/170/SelectUnion.java\nindex d1b4ee2a713..fc90c5b6c31 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/170/SelectUnion.java\n@@ -180,8 +180,7 @@ public class SelectUnion extends Query {\n         }\n         int columnCount = left.getColumnCount();\n         if (session.isLazyQueryExecution() && unionType == UNION_ALL && !distinct &&\n-                sort == null && !randomAccessResult && !isForUpdate &&\n-                offsetExpr == null && isReadOnly()) {\n+                sort == null && !randomAccessResult && !isForUpdate && offsetExpr == null && isReadOnly()) {\n             int limit = -1;\n             if (limitExpr != null) {\n                 Value v = limitExpr.getValue(session);\n@@ -337,7 +336,7 @@ public class SelectUnion extends Query {\n             long prec = Math.max(l.getPrecision(), r.getPrecision());\n             int scale = Math.max(l.getScale(), r.getScale());\n             int displaySize = Math.max(l.getDisplaySize(), r.getDisplaySize());\n-            String columnName = ColumnNamer.getColumnName(l,i);\n+            String columnName = ColumnNamer.getColumnName(l, i);\n             Column col = new Column(columnName, type, prec, scale, displaySize);\n             Expression e = new ExpressionColumn(session.getDatabase(), col);\n             expressions.add(e);\n@@ -559,4 +558,4 @@ public class SelectUnion extends Query {\n             rightDone = false;\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/170/SelectUnion.java\nindex d1b4ee2a713..6430ff00fb7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/170/SelectUnion.java\n@@ -36,28 +36,37 @@ import org.h2.value.ValueNull;\n /**\n  * Represents a union SELECT statement.\n  */\n+\n+\n public class SelectUnion extends Query {\n \n     /**\n      * The type of a UNION statement.\n      */\n+\n+\n     public static final int UNION = 0;\n \n     /**\n      * The type of a UNION ALL statement.\n      */\n+\n+\n     public static final int UNION_ALL = 1;\n \n     /**\n      * The type of an EXCEPT statement.\n      */\n+\n+\n     public static final int EXCEPT = 2;\n \n     /**\n      * The type of an INTERSECT statement.\n      */\n-    public static final int INTERSECT = 3;\n \n+\n+    public static final int INTERSECT = 3;\n     private int unionType;\n     private final Query left;\n     private Query right;\n@@ -84,22 +93,27 @@ public class SelectUnion extends Query {\n         right.prepareJoinBatch();\n     }\n \n+\n     public void setUnionType(int type) {\n         this.unionType = type;\n     }\n \n+\n     public int getUnionType() {\n         return unionType;\n     }\n \n+\n     public void setRight(Query select) {\n         right = select;\n     }\n \n+\n     public Query getLeft() {\n         return left;\n     }\n \n+\n     public Query getRight() {\n         return right;\n     }\n@@ -144,6 +158,7 @@ public class SelectUnion extends Query {\n         return result;\n     }\n \n+\n     public LocalResult getEmptyResult() {\n         int columnCount = left.getColumnCount();\n         return new LocalResult(session, expressionArray, columnCount);\n@@ -170,8 +185,7 @@ public class SelectUnion extends Query {\n         }\n         if (session.getDatabase().getSettings().optimizeInsertFromSelect) {\n             if (unionType == UNION_ALL && target != null) {\n-                if (sort == null && !distinct && maxRows == 0 &&\n-                        offsetExpr == null && limitExpr == null) {\n+                if (sort == null && !distinct && maxRows == 0 && offsetExpr == null && limitExpr == null) {\n                     left.query(0, target);\n                     right.query(0, target);\n                     return null;\n@@ -179,9 +193,7 @@ public class SelectUnion extends Query {\n             }\n         }\n         int columnCount = left.getColumnCount();\n-        if (session.isLazyQueryExecution() && unionType == UNION_ALL && !distinct &&\n-                sort == null && !randomAccessResult && !isForUpdate &&\n-                offsetExpr == null && isReadOnly()) {\n+        if (session.isLazyQueryExecution() && unionType == UNION_ALL && !distinct && sort == null && !randomAccessResult && !isForUpdate && offsetExpr == null && isReadOnly()) {\n             int limit = -1;\n             if (limitExpr != null) {\n                 Value v = limitExpr.getValue(session);\n@@ -337,13 +349,15 @@ public class SelectUnion extends Query {\n             long prec = Math.max(l.getPrecision(), r.getPrecision());\n             int scale = Math.max(l.getScale(), r.getScale());\n             int displaySize = Math.max(l.getDisplaySize(), r.getDisplaySize());\n-            String columnName = ColumnNamer.getColumnName(l,i);\n+            String columnName = ColumnNamer.getColumnName(l, i);\n             Column col = new Column(columnName, type, prec, scale, displaySize);\n             Expression e = new ExpressionColumn(session.getDatabase(), col);\n             expressions.add(e);\n         }\n         if (orderList != null) {\n-            initOrder(session, expressions, null, orderList, getColumnCount(), true, null);\n+            initOrder(session, expressions,\n+                          null, orderList, getColumnCount(), true,\n+                          null);\n             sort = prepareOrder(orderList, expressions.size());\n             orderList = null;\n         }\n@@ -393,8 +407,7 @@ public class SelectUnion extends Query {\n     }\n \n     @Override\n-    public void addGlobalCondition(Parameter param, int columnId,\n-            int comparisonType) {\n+    public void addGlobalCondition(Parameter param, int columnId, int comparisonType) {\n         addParameter(param);\n         switch (unionType) {\n         case UNION_ALL:\n@@ -439,16 +452,13 @@ public class SelectUnion extends Query {\n             buff.append(\"\\nORDER BY \").append(sort.getSQL(exprList, exprList.length));\n         }\n         if (limitExpr != null) {\n-            buff.append(\"\\nLIMIT \").append(\n-                    StringUtils.unEnclose(limitExpr.getSQL()));\n+            buff.append(\"\\nLIMIT \").append(StringUtils.unEnclose(limitExpr.getSQL()));\n             if (offsetExpr != null) {\n-                buff.append(\"\\nOFFSET \").append(\n-                        StringUtils.unEnclose(offsetExpr.getSQL()));\n+                buff.append(\"\\nOFFSET \").append(StringUtils.unEnclose(offsetExpr.getSQL()));\n             }\n         }\n         if (sampleSizeExpr != null) {\n-            buff.append(\"\\nSAMPLE_SIZE \").append(\n-                    StringUtils.unEnclose(sampleSizeExpr.getSQL()));\n+            buff.append(\"\\nSAMPLE_SIZE \").append(StringUtils.unEnclose(sampleSizeExpr.getSQL()));\n         }\n         if (isForUpdate) {\n             buff.append(\"\\nFOR UPDATE\");\n@@ -491,12 +501,22 @@ public class SelectUnion extends Query {\n     /**\n      * Lazy execution for this union.\n      */\n+\n     private final class LazyResultUnion extends LazyResult {\n \n+\n         int columnCount;\n+\n+\n         ResultInterface l;\n+\n+\n         ResultInterface r;\n+\n+\n         boolean leftDone;\n+\n+\n         boolean rightDone;\n \n         LazyResultUnion(Expression[] expressions, int columnCount) {\n@@ -558,5 +578,7 @@ public class SelectUnion extends Query {\n             leftDone = false;\n             rightDone = false;\n         }\n+\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 47
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/170/SelectUnion.java\nindex d1b4ee2a713..a4aa507964c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/170/SelectUnion.java\n@@ -337,7 +337,7 @@ public class SelectUnion extends Query {\n             long prec = Math.max(l.getPrecision(), r.getPrecision());\n             int scale = Math.max(l.getScale(), r.getScale());\n             int displaySize = Math.max(l.getDisplaySize(), r.getDisplaySize());\n-            String columnName = ColumnNamer.getColumnName(l,i);\n+            String columnName = ColumnNamer.getColumnName(l, i);\n             Column col = new Column(columnName, type, prec, scale, displaySize);\n             Expression e = new ExpressionColumn(session.getDatabase(), col);\n             expressions.add(e);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/170/SelectUnion.java\nindex d1b4ee2a713..a4aa507964c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/170/SelectUnion.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/170/SelectUnion.java\n@@ -337,7 +337,7 @@ public class SelectUnion extends Query {\n             long prec = Math.max(l.getPrecision(), r.getPrecision());\n             int scale = Math.max(l.getScale(), r.getScale());\n             int displaySize = Math.max(l.getDisplaySize(), r.getDisplaySize());\n-            String columnName = ColumnNamer.getColumnName(l,i);\n+            String columnName = ColumnNamer.getColumnName(l, i);\n             Column col = new Column(columnName, type, prec, scale, displaySize);\n             Expression e = new ExpressionColumn(session.getDatabase(), col);\n             expressions.add(e);\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}