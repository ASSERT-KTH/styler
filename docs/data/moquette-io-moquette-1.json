{
    "project_name": "moquette-io-moquette",
    "error_id": "1",
    "information": {
        "errors": [
            {
                "line": "169",
                "severity": "warning",
                "message": "Line is longer than 120 characters (found 123).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "            authenticator, m_authorizator, subscriptions,\n            allowAnonymous, allowZeroByteClientId, reauthorizeSubscriptionsOnConnect, internalRepublisher);\n        disconnectHandler = new DisconnectHandler(connectionDescriptors, sessionsRepository, subscriptions, m_interceptor);\n        LOG.info(\"Initialized\");\n    }\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "169",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/1/ProtocolProcessor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/1/ProtocolProcessor.java\nindex d91ca4c816f..40ad67c7d90 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/1/ProtocolProcessor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/1/ProtocolProcessor.java\n@@ -57,529 +57,513 @@ import static io.netty.handler.codec.mqtt.MqttQoS.*;\n /**\n  * Class responsible to handle the logic of MQTT protocol it's the director of the protocol\n  * execution.\n- *\n+ * <p>\n  * Used by the front facing class ProtocolProcessorBootstrapper.\n  */\n public class ProtocolProcessor {\n \n-    private enum SubscriptionState {\n-        STORED, VERIFIED\n+  private enum SubscriptionState {\n+    STORED, VERIFIED\n+  }\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ProtocolProcessor.class);\n+\n+  private IConnectionsManager connectionDescriptors;\n+  private ConcurrentMap<RunningSubscription, SubscriptionState> subscriptionInCourse;\n+\n+  private ISubscriptionsDirectory subscriptions;\n+  private IAuthorizator m_authorizator;\n+\n+  private IMessagesStore m_messagesStore;\n+\n+  private ISessionsStore m_sessionsStore;\n+\n+  private BrokerInterceptor m_interceptor;\n+\n+  private Qos0PublishHandler qos0PublishHandler;\n+  private Qos1PublishHandler qos1PublishHandler;\n+  private Qos2PublishHandler qos2PublishHandler;\n+  private MessagesPublisher messagesPublisher;\n+  private InternalRepublisher internalRepublisher;\n+  SessionsRepository sessionsRepository;\n+\n+  private ConnectHandler connectHandler;\n+  private DisconnectHandler disconnectHandler;\n+\n+  ProtocolProcessor() {\n+  }\n+\n+  public void init(ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore,\n+                   IAuthenticator authenticator, boolean allowAnonymous, IAuthorizator authorizator,\n+                   BrokerInterceptor interceptor, SessionsRepository sessionsRepository,\n+                   boolean reauthorizeSubscriptionsOnConnect) {\n+    init(subscriptions, storageService, sessionsStore, authenticator, allowAnonymous, false,\n+        authorizator, interceptor, sessionsRepository, reauthorizeSubscriptionsOnConnect);\n+  }\n+\n+  public void init(ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore,\n+                   IAuthenticator authenticator, boolean allowAnonymous, boolean allowZeroByteClientId,\n+                   IAuthorizator authorizator, BrokerInterceptor interceptor, SessionsRepository sessionsRepository,\n+                   boolean reauthorizeSubscriptionsOnConnect) {\n+    init(new ConnectionDescriptorStore(), subscriptions, storageService, sessionsStore,\n+        authenticator, allowAnonymous, allowZeroByteClientId, authorizator, interceptor, sessionsRepository,\n+        reauthorizeSubscriptionsOnConnect);\n+  }\n+\n+  /**\n+   * @param subscriptions         the subscription store where are stored all the existing clients subscriptions.\n+   * @param storageService        the persistent store to use for save/load of messages for QoS1 and QoS2 handling.\n+   * @param sessionsStore         the clients sessions store, used to persist subscriptions.\n+   * @param authenticator         the authenticator used in connect messages.\n+   * @param allowAnonymous        true connection to clients without credentials.\n+   * @param allowZeroByteClientId true to allow clients connect without a clientid\n+   * @param authorizator          used to apply ACL policies to publishes and subscriptions.\n+   * @param interceptor           to notify events to an intercept handler\n+   */\n+  void init(IConnectionsManager connectionDescriptors, ISubscriptionsDirectory subscriptions,\n+            IMessagesStore storageService, ISessionsStore sessionsStore, IAuthenticator authenticator,\n+            boolean allowAnonymous, boolean allowZeroByteClientId, IAuthorizator authorizator,\n+            BrokerInterceptor interceptor, SessionsRepository sessionsRepository,\n+            boolean reauthorizeSubscriptionsOnConnect) {\n+    LOG.info(\"Initializing MQTT protocol processor..\");\n+    this.connectionDescriptors = connectionDescriptors;\n+    this.subscriptionInCourse = new ConcurrentHashMap<>();\n+    this.m_interceptor = interceptor;\n+    this.subscriptions = subscriptions;\n+    m_authorizator = authorizator;\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Initial subscriptions tree={}\", subscriptions.dumpTree());\n     }\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(ProtocolProcessor.class);\n-\n-    private IConnectionsManager connectionDescriptors;\n-    private ConcurrentMap<RunningSubscription, SubscriptionState> subscriptionInCourse;\n-\n-    private ISubscriptionsDirectory subscriptions;\n-    private IAuthorizator m_authorizator;\n-\n-    private IMessagesStore m_messagesStore;\n-\n-    private ISessionsStore m_sessionsStore;\n-\n-    private BrokerInterceptor m_interceptor;\n-\n-    private Qos0PublishHandler qos0PublishHandler;\n-    private Qos1PublishHandler qos1PublishHandler;\n-    private Qos2PublishHandler qos2PublishHandler;\n-    private MessagesPublisher messagesPublisher;\n-    private InternalRepublisher internalRepublisher;\n-    SessionsRepository sessionsRepository;\n-\n-    private ConnectHandler connectHandler;\n-    private DisconnectHandler disconnectHandler;\n-\n-    ProtocolProcessor() {\n+    m_messagesStore = storageService;\n+    m_sessionsStore = sessionsStore;\n+\n+    this.sessionsRepository = sessionsRepository;\n+\n+    LOG.debug(\"Initializing messages publisher...\");\n+    final PersistentQueueMessageSender messageSender = new PersistentQueueMessageSender(this.connectionDescriptors);\n+    this.messagesPublisher = new MessagesPublisher(connectionDescriptors, messageSender,\n+        subscriptions, this.sessionsRepository);\n+\n+    LOG.debug(\"Initializing QoS publish handlers...\");\n+    this.qos0PublishHandler = new Qos0PublishHandler(m_authorizator, m_messagesStore, m_interceptor,\n+        this.messagesPublisher);\n+    this.qos1PublishHandler = new Qos1PublishHandler(m_authorizator, m_messagesStore, m_interceptor,\n+        this.connectionDescriptors, this.messagesPublisher);\n+    this.qos2PublishHandler = new Qos2PublishHandler(m_authorizator, subscriptions, m_messagesStore, m_interceptor,\n+        this.connectionDescriptors, this.messagesPublisher, this.sessionsRepository);\n+\n+    LOG.debug(\"Initializing internal republisher...\");\n+    this.internalRepublisher = new InternalRepublisher(messageSender);\n+\n+    connectHandler = new ConnectHandler(connectionDescriptors, m_interceptor, sessionsRepository, m_sessionsStore,\n+        authenticator, m_authorizator, subscriptions,\n+        allowAnonymous, allowZeroByteClientId, reauthorizeSubscriptionsOnConnect, internalRepublisher);\n+    disconnectHandler = new DisconnectHandler(connectionDescriptors, sessionsRepository, subscriptions, m_interceptor);\n+    LOG.info(\"Initialized\");\n+  }\n+\n+  public void processConnect(Channel channel, MqttConnectMessage connectMessage) {\n+    this.connectHandler.processConnect(channel, connectMessage);\n+  }\n+\n+  public void processPubAck(Channel channel, MqttPubAckMessage msg) {\n+    String clientID = NettyUtils.clientID(channel);\n+    int messageID = msg.variableHeader().messageId();\n+    String username = NettyUtils.userName(channel);\n+    LOG.trace(\"retrieving inflight for messageID <{}>\", messageID);\n+\n+    ClientSession targetSession = this.sessionsRepository.sessionForClient(clientID);\n+    StoredMessage inflightMsg = targetSession.inFlightAcknowledged(messageID);\n+\n+    String topic = inflightMsg.getTopic();\n+    InterceptAcknowledgedMessage wrapped = new InterceptAcknowledgedMessage(inflightMsg, topic, username,\n+        messageID);\n+    m_interceptor.notifyMessageAcknowledged(wrapped);\n+  }\n+\n+  public static IMessagesStore.StoredMessage asStoredMessage(MqttPublishMessage msg) {\n+    // TODO ugly, too much array copy\n+    ByteBuf payload = msg.payload();\n+    byte[] payloadContent = readBytesAndRewind(payload);\n+\n+    IMessagesStore.StoredMessage stored = new IMessagesStore.StoredMessage(payloadContent,\n+        msg.fixedHeader().qosLevel(), msg.variableHeader().topicName());\n+    stored.setRetained(msg.fixedHeader().isRetain());\n+    return stored;\n+  }\n+\n+  private static IMessagesStore.StoredMessage asStoredMessage(WillMessage will) {\n+    IMessagesStore.StoredMessage pub = new IMessagesStore.StoredMessage(will.getPayload().array(), will.getQos(),\n+        will.getTopic());\n+    pub.setRetained(will.isRetained());\n+    return pub;\n+  }\n+\n+  public void processPublish(Channel channel, MqttPublishMessage msg) {\n+    final MqttQoS qos = msg.fixedHeader().qosLevel();\n+    final String clientId = NettyUtils.clientID(channel);\n+    LOG.info(\"Processing PUBLISH message. CId={}, topic={}, messageId={}, qos={}\", clientId,\n+        msg.variableHeader().topicName(), msg.variableHeader().messageId(), qos);\n+    switch (qos) {\n+      case AT_MOST_ONCE:\n+        this.qos0PublishHandler.receivedPublishQos0(channel, msg);\n+        break;\n+      case AT_LEAST_ONCE:\n+        this.qos1PublishHandler.receivedPublishQos1(channel, msg);\n+        break;\n+      case EXACTLY_ONCE:\n+        this.qos2PublishHandler.receivedPublishQos2(channel, msg);\n+        break;\n+      default:\n+        LOG.error(\"Unknown QoS-Type:{}\", qos);\n+        break;\n     }\n-\n-    public void init(ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore,\n-                     IAuthenticator authenticator, boolean allowAnonymous, IAuthorizator authorizator,\n-                     BrokerInterceptor interceptor, SessionsRepository sessionsRepository,\n-                     boolean reauthorizeSubscriptionsOnConnect) {\n-        init(subscriptions, storageService, sessionsStore, authenticator, allowAnonymous, false,\n-             authorizator, interceptor, sessionsRepository, reauthorizeSubscriptionsOnConnect);\n+  }\n+\n+  /**\n+   * Intended usage is only for embedded versions of the broker, where the hosting application\n+   * want to use the broker to send a publish message. Inspired by {@link #processPublish} but\n+   * with some changes to avoid security check, and the handshake phases for Qos1 and Qos2. It\n+   * also doesn't notifyTopicPublished because using internally the owner should already know\n+   * where it's publishing.\n+   *\n+   * @param msg      the message to publish.\n+   * @param clientId the clientID\n+   */\n+  public void internalPublish(MqttPublishMessage msg, final String clientId) {\n+    final MqttQoS qos = msg.fixedHeader().qosLevel();\n+    final Topic topic = new Topic(msg.variableHeader().topicName());\n+    LOG.info(\"Sending PUBLISH message. Topic={}, qos={}\", topic, qos);\n+\n+    IMessagesStore.StoredMessage toStoreMsg = asStoredMessage(msg);\n+    if (clientId == null || clientId.isEmpty()) {\n+      toStoreMsg.setClientID(\"BROKER_SELF\");\n+    } else {\n+      toStoreMsg.setClientID(clientId);\n     }\n+    this.messagesPublisher.publish2Subscribers(toStoreMsg, topic);\n \n-    public void init(ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore,\n-                     IAuthenticator authenticator, boolean allowAnonymous, boolean allowZeroByteClientId,\n-                     IAuthorizator authorizator, BrokerInterceptor interceptor, SessionsRepository sessionsRepository,\n-                     boolean reauthorizeSubscriptionsOnConnect) {\n-        init(new ConnectionDescriptorStore(), subscriptions, storageService, sessionsStore,\n-             authenticator, allowAnonymous, allowZeroByteClientId, authorizator, interceptor, sessionsRepository,\n-             reauthorizeSubscriptionsOnConnect);\n+    if (!msg.fixedHeader().isRetain()) {\n+      return;\n     }\n-\n-    /**\n-     * @param subscriptions\n-     *            the subscription store where are stored all the existing clients subscriptions.\n-     * @param storageService\n-     *            the persistent store to use for save/load of messages for QoS1 and QoS2 handling.\n-     * @param sessionsStore\n-     *            the clients sessions store, used to persist subscriptions.\n-     * @param authenticator\n-     *            the authenticator used in connect messages.\n-     * @param allowAnonymous\n-     *            true connection to clients without credentials.\n-     * @param allowZeroByteClientId\n-     *            true to allow clients connect without a clientid\n-     * @param authorizator\n-     *            used to apply ACL policies to publishes and subscriptions.\n-     * @param interceptor\n-     *            to notify events to an intercept handler\n-     */\n-    void init(IConnectionsManager connectionDescriptors, ISubscriptionsDirectory subscriptions,\n-              IMessagesStore storageService, ISessionsStore sessionsStore, IAuthenticator authenticator,\n-              boolean allowAnonymous, boolean allowZeroByteClientId, IAuthorizator authorizator,\n-              BrokerInterceptor interceptor, SessionsRepository sessionsRepository,\n-              boolean reauthorizeSubscriptionsOnConnect) {\n-        LOG.info(\"Initializing MQTT protocol processor..\");\n-        this.connectionDescriptors = connectionDescriptors;\n-        this.subscriptionInCourse = new ConcurrentHashMap<>();\n-        this.m_interceptor = interceptor;\n-        this.subscriptions = subscriptions;\n-        m_authorizator = authorizator;\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Initial subscriptions tree={}\", subscriptions.dumpTree());\n-        }\n-        m_messagesStore = storageService;\n-        m_sessionsStore = sessionsStore;\n-\n-        this.sessionsRepository = sessionsRepository;\n-\n-        LOG.debug(\"Initializing messages publisher...\");\n-        final PersistentQueueMessageSender messageSender = new PersistentQueueMessageSender(this.connectionDescriptors);\n-        this.messagesPublisher = new MessagesPublisher(connectionDescriptors, messageSender,\n-            subscriptions, this.sessionsRepository);\n-\n-        LOG.debug(\"Initializing QoS publish handlers...\");\n-        this.qos0PublishHandler = new Qos0PublishHandler(m_authorizator, m_messagesStore, m_interceptor,\n-                this.messagesPublisher);\n-        this.qos1PublishHandler = new Qos1PublishHandler(m_authorizator, m_messagesStore, m_interceptor,\n-                this.connectionDescriptors, this.messagesPublisher);\n-        this.qos2PublishHandler = new Qos2PublishHandler(m_authorizator, subscriptions, m_messagesStore, m_interceptor,\n-                this.connectionDescriptors, this.messagesPublisher, this.sessionsRepository);\n-\n-        LOG.debug(\"Initializing internal republisher...\");\n-        this.internalRepublisher = new InternalRepublisher(messageSender);\n-\n-        connectHandler = new ConnectHandler(connectionDescriptors, m_interceptor, sessionsRepository, m_sessionsStore,\n-            authenticator, m_authorizator, subscriptions,\n-            allowAnonymous, allowZeroByteClientId, reauthorizeSubscriptionsOnConnect, internalRepublisher);\n-        disconnectHandler = new DisconnectHandler(connectionDescriptors, sessionsRepository, subscriptions, m_interceptor);\n-        LOG.info(\"Initialized\");\n+    if (qos == AT_MOST_ONCE || msg.payload().readableBytes() == 0) {\n+      // QoS == 0 && retain => clean old retained\n+      m_messagesStore.cleanRetained(topic);\n+      return;\n     }\n-\n-    public void processConnect(Channel channel, MqttConnectMessage connectMessage) {\n-        this.connectHandler.processConnect(channel, connectMessage);\n+    m_messagesStore.storeRetained(topic, toStoreMsg);\n+  }\n+\n+  /**\n+   * Specialized version to publish will testament message.\n+   */\n+  private void forwardPublishWill(WillMessage will, String clientID) {\n+    LOG.info(\"Publishing will message. CId={}, topic={}\", clientID, will.getTopic());\n+    // it has just to publish the message downstream to the subscribers\n+    // NB it's a will publish, it needs a PacketIdentifier for this conn, default to 1\n+    IMessagesStore.StoredMessage tobeStored = asStoredMessage(will);\n+    tobeStored.setClientID(clientID);\n+    Topic topic = new Topic(tobeStored.getTopic());\n+    this.messagesPublisher.publish2Subscribers(tobeStored, topic);\n+\n+    //Stores retained message to the topic\n+    if (will.isRetained()) {\n+      m_messagesStore.storeRetained(topic, tobeStored);\n     }\n+  }\n \n-    public void processPubAck(Channel channel, MqttPubAckMessage msg) {\n-        String clientID = NettyUtils.clientID(channel);\n-        int messageID = msg.variableHeader().messageId();\n-        String username = NettyUtils.userName(channel);\n-        LOG.trace(\"retrieving inflight for messageID <{}>\", messageID);\n-\n-        ClientSession targetSession = this.sessionsRepository.sessionForClient(clientID);\n-        StoredMessage inflightMsg = targetSession.inFlightAcknowledged(messageID);\n-\n-        String topic = inflightMsg.getTopic();\n-        InterceptAcknowledgedMessage wrapped = new InterceptAcknowledgedMessage(inflightMsg, topic, username,\n-                                                                                messageID);\n-        m_interceptor.notifyMessageAcknowledged(wrapped);\n+  static MqttQoS lowerQosToTheSubscriptionDesired(Subscription sub, MqttQoS qos) {\n+    if (qos.value() > sub.getRequestedQos().value()) {\n+      qos = sub.getRequestedQos();\n     }\n-\n-    public static IMessagesStore.StoredMessage asStoredMessage(MqttPublishMessage msg) {\n-        // TODO ugly, too much array copy\n-        ByteBuf payload = msg.payload();\n-        byte[] payloadContent = readBytesAndRewind(payload);\n-\n-        IMessagesStore.StoredMessage stored = new IMessagesStore.StoredMessage(payloadContent,\n-                msg.fixedHeader().qosLevel(), msg.variableHeader().topicName());\n-        stored.setRetained(msg.fixedHeader().isRetain());\n-        return stored;\n+    return qos;\n+  }\n+\n+  /**\n+   * Second phase of a publish QoS2 protocol, sent by publisher to the broker. Search the stored\n+   * message and publish to all interested subscribers.\n+   *\n+   * @param channel the channel of the incoming message.\n+   * @param msg     the decoded pubrel message.\n+   */\n+  public void processPubRel(Channel channel, MqttMessage msg) {\n+    this.qos2PublishHandler.processPubRel(channel, msg);\n+  }\n+\n+  public void processPubRec(Channel channel, MqttMessage msg) {\n+    String clientID = NettyUtils.clientID(channel);\n+    int messageID = messageId(msg);\n+    LOG.debug(\"Processing PUBREC message. CId={}, messageId={}\", clientID, messageID);\n+    ClientSession targetSession = this.sessionsRepository.sessionForClient(clientID);\n+    // remove from the inflight and move to the QoS2 second phase queue\n+    StoredMessage ackedMsg = targetSession.inFlightAcknowledged(messageID);\n+    targetSession.moveInFlightToSecondPhaseAckWaiting(messageID, ackedMsg);\n+    // once received a PUBREC reply with a PUBREL(messageID)\n+    LOG.debug(\"Processing PUBREC message. CId={}, messageId={}\", clientID, messageID);\n+\n+    MqttFixedHeader pubRelHeader = new MqttFixedHeader(MqttMessageType.PUBREL, false, AT_LEAST_ONCE, false, 0);\n+    MqttMessage pubRelMessage = new MqttMessage(pubRelHeader, from(messageID));\n+    channel.writeAndFlush(pubRelMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n+  }\n+\n+  public void processPubComp(Channel channel, MqttMessage msg) {\n+    String clientID = NettyUtils.clientID(channel);\n+    int messageID = messageId(msg);\n+    LOG.debug(\"Processing PUBCOMP message. CId={}, messageId={}\", clientID, messageID);\n+    // once received the PUBCOMP then remove the message from the temp memory\n+    ClientSession targetSession = this.sessionsRepository.sessionForClient(clientID);\n+    StoredMessage inflightMsg = targetSession.completeReleasedPublish(messageID);\n+    String username = NettyUtils.userName(channel);\n+    String topic = inflightMsg.getTopic();\n+    final InterceptAcknowledgedMessage interceptAckMsg = new InterceptAcknowledgedMessage(inflightMsg, topic,\n+        username, messageID);\n+    m_interceptor.notifyMessageAcknowledged(interceptAckMsg);\n+  }\n+\n+  public void processDisconnect(Channel channel) {\n+    final String clientID = NettyUtils.clientID(channel);\n+    LOG.debug(\"Processing DISCONNECT message. CId={}\", clientID);\n+    channel.flush();\n+    disconnectHandler.processDisconnect(channel, clientID);\n+  }\n+\n+  public void processConnectionLost(String clientID, Channel channel) {\n+    LOG.info(\"Lost connection with client <{}>\", clientID);\n+    ConnectionDescriptor oldConnDescr = new ConnectionDescriptor(clientID, channel, true);\n+    connectionDescriptors.removeConnection(oldConnDescr);\n+    // publish the Will message (if any) for the clientID\n+    final ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n+    WillMessage will = clientSession.willMessage();\n+    if (will != null) {\n+      forwardPublishWill(will, clientID);\n+      clientSession.removeWill();\n     }\n \n-    private static IMessagesStore.StoredMessage asStoredMessage(WillMessage will) {\n-        IMessagesStore.StoredMessage pub = new IMessagesStore.StoredMessage(will.getPayload().array(), will.getQos(),\n-                will.getTopic());\n-        pub.setRetained(will.isRetained());\n-        return pub;\n+    String username = NettyUtils.userName(channel);\n+    m_interceptor.notifyClientConnectionLost(clientID, username);\n+  }\n+\n+  /**\n+   * Remove the clientID from topic subscription, if not previously subscribed, doesn't reply any\n+   * error.\n+   *\n+   * @param channel the channel of the incoming message.\n+   * @param msg     the decoded unsubscribe message.\n+   */\n+  public void processUnsubscribe(Channel channel, MqttUnsubscribeMessage msg) {\n+    List<String> topics = msg.payload().topics();\n+    String clientID = NettyUtils.clientID(channel);\n+\n+    LOG.debug(\"Processing UNSUBSCRIBE message. CId={}, topics={}\", clientID, topics);\n+\n+    ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n+    for (String t : topics) {\n+      Topic topic = new Topic(t);\n+      boolean validTopic = topic.isValid();\n+      if (!validTopic) {\n+        // close the connection, not valid topicFilter is a protocol violation\n+        channel.close().addListener(CLOSE_ON_FAILURE);\n+        LOG.error(\"Topic filter is not valid. CId={}, topics={}, badTopicFilter={}\", clientID, topics, topic);\n+        return;\n+      }\n+\n+      LOG.trace(\"Removing subscription. CId={}, topic={}\", clientID, topic);\n+      subscriptions.removeSubscription(topic, clientID);\n+      clientSession.unsubscribeFrom(topic);\n+      String username = NettyUtils.userName(channel);\n+      m_interceptor.notifyTopicUnsubscribed(topic.toString(), clientID, username);\n     }\n \n-    public void processPublish(Channel channel, MqttPublishMessage msg) {\n-        final MqttQoS qos = msg.fixedHeader().qosLevel();\n-        final String clientId = NettyUtils.clientID(channel);\n-        LOG.info(\"Processing PUBLISH message. CId={}, topic={}, messageId={}, qos={}\", clientId,\n-                 msg.variableHeader().topicName(), msg.variableHeader().messageId(), qos);\n-        switch (qos) {\n-            case AT_MOST_ONCE:\n-                this.qos0PublishHandler.receivedPublishQos0(channel, msg);\n-                break;\n-            case AT_LEAST_ONCE:\n-                this.qos1PublishHandler.receivedPublishQos1(channel, msg);\n-                break;\n-            case EXACTLY_ONCE:\n-                this.qos2PublishHandler.receivedPublishQos2(channel, msg);\n-                break;\n-            default:\n-                LOG.error(\"Unknown QoS-Type:{}\", qos);\n-                break;\n-        }\n+    // ack the client\n+    int messageID = msg.variableHeader().messageId();\n+    MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBACK, false, AT_MOST_ONCE,\n+        false, 0);\n+    MqttUnsubAckMessage ackMessage = new MqttUnsubAckMessage(fixedHeader, from(messageID));\n+\n+    LOG.debug(\"Sending UNSUBACK message. CId={}, topics={}, messageId={}\", clientID, topics, messageID);\n+    channel.writeAndFlush(ackMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n+    LOG.info(\"Client <{}> unsubscribed from topics <{}>\", clientID, topics);\n+  }\n+\n+  public void processSubscribe(Channel channel, MqttSubscribeMessage msg) {\n+    String clientID = NettyUtils.clientID(channel);\n+    int messageID = messageId(msg);\n+    LOG.debug(\"Processing SUBSCRIBE message. CId={}, messageId={}\", clientID, messageID);\n+\n+    RunningSubscription executionKey = new RunningSubscription(clientID, messageID);\n+    SubscriptionState currentStatus = subscriptionInCourse.putIfAbsent(executionKey, SubscriptionState.VERIFIED);\n+    if (currentStatus != null) {\n+      LOG.warn(\"Client sent another SUBSCRIBE message while this one was being processed CId={}, messageId={}\",\n+          clientID, messageID);\n+      return;\n     }\n-\n-    /**\n-     * Intended usage is only for embedded versions of the broker, where the hosting application\n-     * want to use the broker to send a publish message. Inspired by {@link #processPublish} but\n-     * with some changes to avoid security check, and the handshake phases for Qos1 and Qos2. It\n-     * also doesn't notifyTopicPublished because using internally the owner should already know\n-     * where it's publishing.\n-     *\n-     * @param msg\n-     *            the message to publish.\n-     * @param clientId\n-     *            the clientID\n-     */\n-    public void internalPublish(MqttPublishMessage msg, final String clientId) {\n-        final MqttQoS qos = msg.fixedHeader().qosLevel();\n-        final Topic topic = new Topic(msg.variableHeader().topicName());\n-        LOG.info(\"Sending PUBLISH message. Topic={}, qos={}\", topic, qos);\n-\n-        IMessagesStore.StoredMessage toStoreMsg = asStoredMessage(msg);\n-        if (clientId == null || clientId.isEmpty()) {\n-            toStoreMsg.setClientID(\"BROKER_SELF\");\n-        } else {\n-            toStoreMsg.setClientID(clientId);\n-        }\n-        this.messagesPublisher.publish2Subscribers(toStoreMsg, topic);\n-\n-        if (!msg.fixedHeader().isRetain()) {\n-            return;\n-        }\n-        if (qos == AT_MOST_ONCE || msg.payload().readableBytes() == 0) {\n-            // QoS == 0 && retain => clean old retained\n-            m_messagesStore.cleanRetained(topic);\n-            return;\n-        }\n-        m_messagesStore.storeRetained(topic, toStoreMsg);\n+    String username = NettyUtils.userName(channel);\n+    List<MqttTopicSubscription> ackTopics = doVerify(clientID, username, msg);\n+    MqttSubAckMessage ackMessage = doAckMessageFromValidateFilters(ackTopics, messageID);\n+    if (!this.subscriptionInCourse.replace(executionKey, SubscriptionState.VERIFIED, SubscriptionState.STORED)) {\n+      LOG.warn(\"Client sent another SUBSCRIBE message while the topic filters were being verified CId={}, \" +\n+          \"messageId={}\", clientID, messageID);\n+      return;\n     }\n \n-    /**\n-     * Specialized version to publish will testament message.\n-     */\n-    private void forwardPublishWill(WillMessage will, String clientID) {\n-        LOG.info(\"Publishing will message. CId={}, topic={}\", clientID, will.getTopic());\n-        // it has just to publish the message downstream to the subscribers\n-        // NB it's a will publish, it needs a PacketIdentifier for this conn, default to 1\n-        IMessagesStore.StoredMessage tobeStored = asStoredMessage(will);\n-        tobeStored.setClientID(clientID);\n-        Topic topic = new Topic(tobeStored.getTopic());\n-        this.messagesPublisher.publish2Subscribers(tobeStored, topic);\n-\n-        //Stores retained message to the topic\n-        if (will.isRetained()) {\n-            m_messagesStore.storeRetained(topic, tobeStored);\n-        }\n-     }\n+    LOG.debug(\"Creating and storing subscriptions CId={}, messageId={}, topics={}\", clientID, messageID, ackTopics);\n \n-    static MqttQoS lowerQosToTheSubscriptionDesired(Subscription sub, MqttQoS qos) {\n-        if (qos.value() > sub.getRequestedQos().value()) {\n-            qos = sub.getRequestedQos();\n-        }\n-        return qos;\n-    }\n-\n-    /**\n-     * Second phase of a publish QoS2 protocol, sent by publisher to the broker. Search the stored\n-     * message and publish to all interested subscribers.\n-     *\n-     * @param channel\n-     *            the channel of the incoming message.\n-     * @param msg\n-     *            the decoded pubrel message.\n-     */\n-    public void processPubRel(Channel channel, MqttMessage msg) {\n-        this.qos2PublishHandler.processPubRel(channel, msg);\n-    }\n+    List<Subscription> newSubscriptions = doStoreSubscription(ackTopics, clientID);\n \n-    public void processPubRec(Channel channel, MqttMessage msg) {\n-        String clientID = NettyUtils.clientID(channel);\n-        int messageID = messageId(msg);\n-        LOG.debug(\"Processing PUBREC message. CId={}, messageId={}\", clientID, messageID);\n-        ClientSession targetSession = this.sessionsRepository.sessionForClient(clientID);\n-        // remove from the inflight and move to the QoS2 second phase queue\n-        StoredMessage ackedMsg = targetSession.inFlightAcknowledged(messageID);\n-        targetSession.moveInFlightToSecondPhaseAckWaiting(messageID, ackedMsg);\n-        // once received a PUBREC reply with a PUBREL(messageID)\n-        LOG.debug(\"Processing PUBREC message. CId={}, messageId={}\", clientID, messageID);\n-\n-        MqttFixedHeader pubRelHeader = new MqttFixedHeader(MqttMessageType.PUBREL, false, AT_LEAST_ONCE, false, 0);\n-        MqttMessage pubRelMessage = new MqttMessage(pubRelHeader, from(messageID));\n-        channel.writeAndFlush(pubRelMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n+    // save session, persist subscriptions from session\n+    for (Subscription subscription : newSubscriptions) {\n+      subscriptions.add(subscription);\n     }\n \n-    public void processPubComp(Channel channel, MqttMessage msg) {\n-        String clientID = NettyUtils.clientID(channel);\n-        int messageID = messageId(msg);\n-        LOG.debug(\"Processing PUBCOMP message. CId={}, messageId={}\", clientID, messageID);\n-        // once received the PUBCOMP then remove the message from the temp memory\n-        ClientSession targetSession = this.sessionsRepository.sessionForClient(clientID);\n-        StoredMessage inflightMsg = targetSession.completeReleasedPublish(messageID);\n-        String username = NettyUtils.userName(channel);\n-        String topic = inflightMsg.getTopic();\n-        final InterceptAcknowledgedMessage interceptAckMsg = new InterceptAcknowledgedMessage(inflightMsg, topic,\n-            username, messageID);\n-        m_interceptor.notifyMessageAcknowledged(interceptAckMsg);\n-    }\n+    LOG.debug(\"Sending SUBACK response CId={}, messageId={}\", clientID, messageID);\n+    channel.writeAndFlush(ackMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n \n-    public void processDisconnect(Channel channel) {\n-        final String clientID = NettyUtils.clientID(channel);\n-        LOG.debug(\"Processing DISCONNECT message. CId={}\", clientID);\n-        channel.flush();\n-        disconnectHandler.processDisconnect(channel, clientID);\n+    // fire the persisted messages in session\n+    for (Subscription subscription : newSubscriptions) {\n+      publishRetainedMessagesInSession(subscription, username);\n     }\n \n-    public void processConnectionLost(String clientID, Channel channel) {\n-        LOG.info(\"Lost connection with client <{}>\", clientID);\n-        ConnectionDescriptor oldConnDescr = new ConnectionDescriptor(clientID, channel, true);\n-        connectionDescriptors.removeConnection(oldConnDescr);\n-        // publish the Will message (if any) for the clientID\n-        final ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n-        WillMessage will = clientSession.willMessage();\n-        if (will != null) {\n-            forwardPublishWill(will, clientID);\n-            clientSession.removeWill();\n-        }\n-\n-        String username = NettyUtils.userName(channel);\n-        m_interceptor.notifyClientConnectionLost(clientID, username);\n+    boolean success = this.subscriptionInCourse.remove(executionKey, SubscriptionState.STORED);\n+    if (!success) {\n+      LOG.warn(\"Unable to perform the final subscription state update CId={}, messageId={}\", clientID, messageID);\n+    } else {\n+      LOG.info(\"Client <{}> subscribed to topics\", clientID);\n     }\n-\n-    /**\n-     * Remove the clientID from topic subscription, if not previously subscribed, doesn't reply any\n-     * error.\n-     *\n-     * @param channel\n-     *            the channel of the incoming message.\n-     * @param msg\n-     *            the decoded unsubscribe message.\n-     */\n-    public void processUnsubscribe(Channel channel, MqttUnsubscribeMessage msg) {\n-        List<String> topics = msg.payload().topics();\n-        String clientID = NettyUtils.clientID(channel);\n-\n-        LOG.debug(\"Processing UNSUBSCRIBE message. CId={}, topics={}\", clientID, topics);\n-\n-        ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n-        for (String t : topics) {\n-            Topic topic = new Topic(t);\n-            boolean validTopic = topic.isValid();\n-            if (!validTopic) {\n-                // close the connection, not valid topicFilter is a protocol violation\n-                channel.close().addListener(CLOSE_ON_FAILURE);\n-                LOG.error(\"Topic filter is not valid. CId={}, topics={}, badTopicFilter={}\", clientID, topics, topic);\n-                return;\n-            }\n-\n-            LOG.trace(\"Removing subscription. CId={}, topic={}\", clientID, topic);\n-            subscriptions.removeSubscription(topic, clientID);\n-            clientSession.unsubscribeFrom(topic);\n-            String username = NettyUtils.userName(channel);\n-            m_interceptor.notifyTopicUnsubscribed(topic.toString(), clientID, username);\n-        }\n-\n-        // ack the client\n-        int messageID = msg.variableHeader().messageId();\n-        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBACK, false, AT_MOST_ONCE,\n-                                                         false, 0);\n-        MqttUnsubAckMessage ackMessage = new MqttUnsubAckMessage(fixedHeader, from(messageID));\n-\n-        LOG.debug(\"Sending UNSUBACK message. CId={}, topics={}, messageId={}\", clientID, topics, messageID);\n-        channel.writeAndFlush(ackMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n-        LOG.info(\"Client <{}> unsubscribed from topics <{}>\", clientID, topics);\n+  }\n+\n+  private List<Subscription> doStoreSubscription(List<MqttTopicSubscription> ackTopics, String clientID) {\n+    ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n+\n+    List<Subscription> newSubscriptions = new ArrayList<>();\n+    for (MqttTopicSubscription req : ackTopics) {\n+      // TODO this is SUPER UGLY\n+      if (req.qualityOfService() == FAILURE) {\n+        continue;\n+      }\n+      final Topic topic = new Topic(req.topicName());\n+      Subscription newSubscription = new Subscription(clientID, topic, req.qualityOfService());\n+\n+      clientSession.subscribe(newSubscription);\n+      newSubscriptions.add(newSubscription);\n     }\n-\n-    public void processSubscribe(Channel channel, MqttSubscribeMessage msg) {\n-        String clientID = NettyUtils.clientID(channel);\n-        int messageID = messageId(msg);\n-        LOG.debug(\"Processing SUBSCRIBE message. CId={}, messageId={}\", clientID, messageID);\n-\n-        RunningSubscription executionKey = new RunningSubscription(clientID, messageID);\n-        SubscriptionState currentStatus = subscriptionInCourse.putIfAbsent(executionKey, SubscriptionState.VERIFIED);\n-        if (currentStatus != null) {\n-            LOG.warn(\"Client sent another SUBSCRIBE message while this one was being processed CId={}, messageId={}\",\n-                clientID, messageID);\n-            return;\n-        }\n-        String username = NettyUtils.userName(channel);\n-        List<MqttTopicSubscription> ackTopics = doVerify(clientID, username, msg);\n-        MqttSubAckMessage ackMessage = doAckMessageFromValidateFilters(ackTopics, messageID);\n-        if (!this.subscriptionInCourse.replace(executionKey, SubscriptionState.VERIFIED, SubscriptionState.STORED)) {\n-            LOG.warn(\"Client sent another SUBSCRIBE message while the topic filters were being verified CId={}, \" +\n-                \"messageId={}\", clientID, messageID);\n-            return;\n-        }\n-\n-        LOG.debug(\"Creating and storing subscriptions CId={}, messageId={}, topics={}\", clientID, messageID, ackTopics);\n-\n-        List<Subscription> newSubscriptions = doStoreSubscription(ackTopics, clientID);\n-\n-        // save session, persist subscriptions from session\n-        for (Subscription subscription : newSubscriptions) {\n-            subscriptions.add(subscription);\n-        }\n-\n-        LOG.debug(\"Sending SUBACK response CId={}, messageId={}\", clientID, messageID);\n-        channel.writeAndFlush(ackMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n-\n-        // fire the persisted messages in session\n-        for (Subscription subscription : newSubscriptions) {\n-            publishRetainedMessagesInSession(subscription, username);\n-        }\n-\n-        boolean success = this.subscriptionInCourse.remove(executionKey, SubscriptionState.STORED);\n-        if (!success) {\n-            LOG.warn(\"Unable to perform the final subscription state update CId={}, messageId={}\", clientID, messageID);\n+    return newSubscriptions;\n+  }\n+\n+  /**\n+   * @param clientID the clientID\n+   * @param username the username\n+   * @param msg      the subscribe message to verify\n+   * @return the list of verified topics for the given subscribe message.\n+   */\n+  private List<MqttTopicSubscription> doVerify(String clientID, String username, MqttSubscribeMessage msg) {\n+    ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n+    List<MqttTopicSubscription> ackTopics = new ArrayList<>();\n+\n+    final int messageId = messageId(msg);\n+    for (MqttTopicSubscription req : msg.payload().topicSubscriptions()) {\n+      Topic topic = new Topic(req.topicName());\n+      if (!m_authorizator.canRead(topic, username, clientSession.clientID)) {\n+        // send SUBACK with 0x80, the user hasn't credentials to read the topic\n+        LOG.warn(\"Client does not have read permissions on the topic CId={}, username={}, messageId={}, \" +\n+            \"topic={}\", clientID, username, messageId, topic);\n+        ackTopics.add(new MqttTopicSubscription(topic.toString(), FAILURE));\n+      } else {\n+        MqttQoS qos;\n+        if (topic.isValid()) {\n+          LOG.debug(\"Client will be subscribed to the topic CId={}, username={}, messageId={}, topic={}\",\n+              clientID, username, messageId, topic);\n+          qos = req.qualityOfService();\n         } else {\n-            LOG.info(\"Client <{}> subscribed to topics\", clientID);\n-        }\n-    }\n-\n-    private List<Subscription> doStoreSubscription(List<MqttTopicSubscription> ackTopics, String clientID) {\n-        ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n-\n-        List<Subscription> newSubscriptions = new ArrayList<>();\n-        for (MqttTopicSubscription req : ackTopics) {\n-            // TODO this is SUPER UGLY\n-            if (req.qualityOfService() == FAILURE) {\n-                continue;\n-            }\n-            final Topic topic = new Topic(req.topicName());\n-            Subscription newSubscription = new Subscription(clientID, topic, req.qualityOfService());\n-\n-            clientSession.subscribe(newSubscription);\n-            newSubscriptions.add(newSubscription);\n+          LOG.warn(\"Topic filter is not valid CId={}, username={}, messageId={}, topic={}\", clientID,\n+              username, messageId, topic);\n+          qos = FAILURE;\n         }\n-        return newSubscriptions;\n+        ackTopics.add(new MqttTopicSubscription(topic.toString(), qos));\n+      }\n     }\n-\n-    /**\n-     * @param clientID\n-     *            the clientID\n-     * @param username\n-     *            the username\n-     * @param msg\n-     *            the subscribe message to verify\n-     * @return the list of verified topics for the given subscribe message.\n-     */\n-    private List<MqttTopicSubscription> doVerify(String clientID, String username, MqttSubscribeMessage msg) {\n-        ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n-        List<MqttTopicSubscription> ackTopics = new ArrayList<>();\n-\n-        final int messageId = messageId(msg);\n-        for (MqttTopicSubscription req : msg.payload().topicSubscriptions()) {\n-            Topic topic = new Topic(req.topicName());\n-            if (!m_authorizator.canRead(topic, username, clientSession.clientID)) {\n-                // send SUBACK with 0x80, the user hasn't credentials to read the topic\n-                LOG.warn(\"Client does not have read permissions on the topic CId={}, username={}, messageId={}, \" +\n-                    \"topic={}\", clientID, username, messageId, topic);\n-                ackTopics.add(new MqttTopicSubscription(topic.toString(), FAILURE));\n-            } else {\n-                MqttQoS qos;\n-                if (topic.isValid()) {\n-                    LOG.debug(\"Client will be subscribed to the topic CId={}, username={}, messageId={}, topic={}\",\n-                        clientID, username, messageId, topic);\n-                    qos = req.qualityOfService();\n-                } else {\n-                    LOG.warn(\"Topic filter is not valid CId={}, username={}, messageId={}, topic={}\", clientID,\n-                        username, messageId, topic);\n-                    qos = FAILURE;\n-                }\n-                ackTopics.add(new MqttTopicSubscription(topic.toString(), qos));\n-            }\n-        }\n-        return ackTopics;\n+    return ackTopics;\n+  }\n+\n+  /**\n+   * Create the SUBACK response from a list of topicFilters\n+   */\n+  private MqttSubAckMessage doAckMessageFromValidateFilters(List<MqttTopicSubscription> topicFilters, int messageId) {\n+    List<Integer> grantedQoSLevels = new ArrayList<>();\n+    for (MqttTopicSubscription req : topicFilters) {\n+      grantedQoSLevels.add(req.qualityOfService().value());\n     }\n \n-    /**\n-     * Create the SUBACK response from a list of topicFilters\n-     */\n-    private MqttSubAckMessage doAckMessageFromValidateFilters(List<MqttTopicSubscription> topicFilters, int messageId) {\n-        List<Integer> grantedQoSLevels = new ArrayList<>();\n-        for (MqttTopicSubscription req : topicFilters) {\n-            grantedQoSLevels.add(req.qualityOfService().value());\n-        }\n+    MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, AT_MOST_ONCE, false, 0);\n+    MqttSubAckPayload payload = new MqttSubAckPayload(grantedQoSLevels);\n+    return new MqttSubAckMessage(fixedHeader, from(messageId), payload);\n+  }\n \n-        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, AT_MOST_ONCE, false, 0);\n-        MqttSubAckPayload payload = new MqttSubAckPayload(grantedQoSLevels);\n-        return new MqttSubAckMessage(fixedHeader, from(messageId), payload);\n-    }\n-\n-    private void publishRetainedMessagesInSession(Subscription newSubscription, String username) {\n-        LOG.debug(\"Retrieving retained messages CId={}, topics={}\", newSubscription.getClientId(),\n-                newSubscription.getTopicFilter());\n+  private void publishRetainedMessagesInSession(Subscription newSubscription, String username) {\n+    LOG.debug(\"Retrieving retained messages CId={}, topics={}\", newSubscription.getClientId(),\n+        newSubscription.getTopicFilter());\n \n-        // scans retained messages to be published to the new subscription\n-        // TODO this is ugly, it does a linear scan on potential big dataset\n-        Collection<IMessagesStore.StoredMessage> messages = m_messagesStore\n-                .searchMatching(key -> key.match(newSubscription.getTopicFilter()));\n-\n-        if (!messages.isEmpty()) {\n-            LOG.info(\"Publishing retained messages CId={}, topics={}, messagesNo={}\",\n-                newSubscription.getClientId(), newSubscription.getTopicFilter(), messages.size());\n-        }\n-        ClientSession targetSession = this.sessionsRepository.sessionForClient(newSubscription.getClientId());\n+    // scans retained messages to be published to the new subscription\n+    // TODO this is ugly, it does a linear scan on potential big dataset\n+    Collection<IMessagesStore.StoredMessage> messages = m_messagesStore\n+        .searchMatching(key -> key.match(newSubscription.getTopicFilter()));\n \n-        // adapt the message QoS to subscriber's accepted accepted\n-        for (IMessagesStore.StoredMessage msg : messages) {\n-            int lowestQoS = Math.min(msg.getQos().value(), newSubscription.getRequestedQos().value());\n-            MqttQoS qosToPublish = MqttQoS.valueOf(lowestQoS);\n-            msg.setQos(qosToPublish);\n-        }\n-\n-        this.internalRepublisher.publishRetained(targetSession, messages);\n-\n-        // notify the Observables\n-        m_interceptor.notifyTopicSubscribed(newSubscription, username);\n+    if (!messages.isEmpty()) {\n+      LOG.info(\"Publishing retained messages CId={}, topics={}, messagesNo={}\",\n+          newSubscription.getClientId(), newSubscription.getTopicFilter(), messages.size());\n     }\n+    ClientSession targetSession = this.sessionsRepository.sessionForClient(newSubscription.getClientId());\n \n-    public void notifyChannelWritable(Channel channel) {\n-        String clientID = NettyUtils.clientID(channel);\n-        ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n-        boolean emptyQueue = false;\n-        while (channel.isWritable() && !emptyQueue) {\n-            EnqueuedMessage msg = clientSession.poll();\n-            if (msg == null) {\n-                emptyQueue = true;\n-            } else {\n-                // recreate a publish from stored publish in queue\n-                MqttPublishMessage pubMsg = createPublishForQos(msg.msg.getTopic(), msg.msg.getQos(),\n-                                                                msg.msg.getPayload(), msg.msg.isRetained(),\n-                                                                msg.messageId);\n-                channel.write(pubMsg).addListener(FIRE_EXCEPTION_ON_FAILURE);\n-            }\n-        }\n-        channel.flush();\n+    // adapt the message QoS to subscriber's accepted accepted\n+    for (IMessagesStore.StoredMessage msg : messages) {\n+      int lowestQoS = Math.min(msg.getQos().value(), newSubscription.getRequestedQos().value());\n+      MqttQoS qosToPublish = MqttQoS.valueOf(lowestQoS);\n+      msg.setQos(qosToPublish);\n     }\n \n-    public void addInterceptHandler(InterceptHandler interceptHandler) {\n-        this.m_interceptor.addInterceptHandler(interceptHandler);\n+    this.internalRepublisher.publishRetained(targetSession, messages);\n+\n+    // notify the Observables\n+    m_interceptor.notifyTopicSubscribed(newSubscription, username);\n+  }\n+\n+  public void notifyChannelWritable(Channel channel) {\n+    String clientID = NettyUtils.clientID(channel);\n+    ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n+    boolean emptyQueue = false;\n+    while (channel.isWritable() && !emptyQueue) {\n+      EnqueuedMessage msg = clientSession.poll();\n+      if (msg == null) {\n+        emptyQueue = true;\n+      } else {\n+        // recreate a publish from stored publish in queue\n+        MqttPublishMessage pubMsg = createPublishForQos(msg.msg.getTopic(), msg.msg.getQos(),\n+            msg.msg.getPayload(), msg.msg.isRetained(),\n+            msg.messageId);\n+        channel.write(pubMsg).addListener(FIRE_EXCEPTION_ON_FAILURE);\n+      }\n     }\n+    channel.flush();\n+  }\n \n-    public void removeInterceptHandler(InterceptHandler interceptHandler) {\n-        this.m_interceptor.removeInterceptHandler(interceptHandler);\n-    }\n+  public void addInterceptHandler(InterceptHandler interceptHandler) {\n+    this.m_interceptor.addInterceptHandler(interceptHandler);\n+  }\n \n-    public IMessagesStore getMessagesStore() {\n-        return m_messagesStore;\n-    }\n+  public void removeInterceptHandler(InterceptHandler interceptHandler) {\n+    this.m_interceptor.removeInterceptHandler(interceptHandler);\n+  }\n \n-    public ISessionsStore getSessionsStore() {\n-        return m_sessionsStore;\n-    }\n+  public IMessagesStore getMessagesStore() {\n+    return m_messagesStore;\n+  }\n+\n+  public ISessionsStore getSessionsStore() {\n+    return m_sessionsStore;\n+  }\n \n-    public void shutdown() {\n-        if (m_interceptor != null)\n-            m_interceptor.stop();\n+  public void shutdown() {\n+    if (m_interceptor != null) {\n+      m_interceptor.stop();\n     }\n+  }\n }\n",
            "diff_size": 746
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "169",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "187",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "212",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 170).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/1/ProtocolProcessor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/1/ProtocolProcessor.java\nindex d91ca4c816f..66fc6839e8a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/1/ProtocolProcessor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/1/ProtocolProcessor.java\n@@ -184,9 +184,8 @@ public class ProtocolProcessor {\n         StoredMessage inflightMsg = targetSession.inFlightAcknowledged(messageID);\n \n         String topic = inflightMsg.getTopic();\n-        InterceptAcknowledgedMessage wrapped = new InterceptAcknowledgedMessage(inflightMsg, topic, username,\n-                                                                                messageID);\n-        m_interceptor.notifyMessageAcknowledged(wrapped);\n+        InterceptAcknowledgedMessage wrapped = new InterceptAcknowledgedMessage(inflightMsg, topic, username, messageID);\n+m_interceptor.notifyMessageAcknowledged(wrapped);\n     }\n \n     public static IMessagesStore.StoredMessage asStoredMessage(MqttPublishMessage msg) {\n@@ -210,9 +209,8 @@ public class ProtocolProcessor {\n     public void processPublish(Channel channel, MqttPublishMessage msg) {\n         final MqttQoS qos = msg.fixedHeader().qosLevel();\n         final String clientId = NettyUtils.clientID(channel);\n-        LOG.info(\"Processing PUBLISH message. CId={}, topic={}, messageId={}, qos={}\", clientId,\n-                 msg.variableHeader().topicName(), msg.variableHeader().messageId(), qos);\n-        switch (qos) {\n+        LOG.info(\"Processing PUBLISH message. CId={}, topic={}, messageId={}, qos={}\", clientId, msg.variableHeader().topicName(), msg.variableHeader().messageId(), qos);\n+switch (qos) {\n             case AT_MOST_ONCE:\n                 this.qos0PublishHandler.receivedPublishQos0(channel, msg);\n                 break;\n@@ -280,9 +278,9 @@ public class ProtocolProcessor {\n         if (will.isRetained()) {\n             m_messagesStore.storeRetained(topic, tobeStored);\n         }\n-     }\n+    }\n \n-    static MqttQoS lowerQosToTheSubscriptionDesired(Subscription sub, MqttQoS qos) {\n+static MqttQoS lowerQosToTheSubscriptionDesired(Subscription sub, MqttQoS qos) {\n         if (qos.value() > sub.getRequestedQos().value()) {\n             qos = sub.getRequestedQos();\n         }\n@@ -390,9 +388,8 @@ public class ProtocolProcessor {\n \n         // ack the client\n         int messageID = msg.variableHeader().messageId();\n-        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBACK, false, AT_MOST_ONCE,\n-                                                         false, 0);\n-        MqttUnsubAckMessage ackMessage = new MqttUnsubAckMessage(fixedHeader, from(messageID));\n+        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBACK, false, AT_MOST_ONCE, false, 0);\n+MqttUnsubAckMessage ackMessage = new MqttUnsubAckMessage(fixedHeader, from(messageID));\n \n         LOG.debug(\"Sending UNSUBACK message. CId={}, topics={}, messageId={}\", clientID, topics, messageID);\n         channel.writeAndFlush(ackMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n@@ -556,7 +553,7 @@ public class ProtocolProcessor {\n                 MqttPublishMessage pubMsg = createPublishForQos(msg.msg.getTopic(), msg.msg.getQos(),\n                                                                 msg.msg.getPayload(), msg.msg.isRetained(),\n                                                                 msg.messageId);\n-                channel.write(pubMsg).addListener(FIRE_EXCEPTION_ON_FAILURE);\n+channel.write(pubMsg).addListener(FIRE_EXCEPTION_ON_FAILURE);\n             }\n         }\n         channel.flush();\n@@ -582,4 +579,4 @@ public class ProtocolProcessor {\n         if (m_interceptor != null)\n             m_interceptor.stop();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 13
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "59",
                    "severity": "warning",
                    "message": "two or more consecutive empty lines",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpMultilineCheck"
                },
                {
                    "line": "89",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 317).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "90",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "93",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 348).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "94",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 228).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "116",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 384).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "131",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "133",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "134",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 157).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "145",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 260).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "146",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "162",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "170",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 159).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "176",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "184",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 170).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "301",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 135).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "385",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 131).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "448",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "499",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 143).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "501",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "528",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 161).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/1/ProtocolProcessor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/1/ProtocolProcessor.java\nindex d91ca4c816f..dfcfbbf321a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/1/ProtocolProcessor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/1/ProtocolProcessor.java\n@@ -37,14 +37,12 @@ import io.netty.channel.Channel;\n import io.netty.handler.codec.mqtt.*;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-\n import static io.moquette.server.ConnectionDescriptor.ConnectionState.*;\n import static io.moquette.spi.impl.InternalRepublisher.createPublishForQos;\n import static io.moquette.spi.impl.Utils.messageId;\n@@ -60,6 +58,8 @@ import static io.netty.handler.codec.mqtt.MqttQoS.*;\n  *\n  * Used by the front facing class ProtocolProcessorBootstrapper.\n  */\n+\n+\n public class ProtocolProcessor {\n \n     private enum SubscriptionState {\n@@ -67,47 +67,31 @@ public class ProtocolProcessor {\n     }\n \n     private static final Logger LOG = LoggerFactory.getLogger(ProtocolProcessor.class);\n-\n     private IConnectionsManager connectionDescriptors;\n     private ConcurrentMap<RunningSubscription, SubscriptionState> subscriptionInCourse;\n-\n     private ISubscriptionsDirectory subscriptions;\n     private IAuthorizator m_authorizator;\n-\n     private IMessagesStore m_messagesStore;\n-\n     private ISessionsStore m_sessionsStore;\n-\n     private BrokerInterceptor m_interceptor;\n-\n     private Qos0PublishHandler qos0PublishHandler;\n     private Qos1PublishHandler qos1PublishHandler;\n     private Qos2PublishHandler qos2PublishHandler;\n     private MessagesPublisher messagesPublisher;\n     private InternalRepublisher internalRepublisher;\n     SessionsRepository sessionsRepository;\n-\n     private ConnectHandler connectHandler;\n     private DisconnectHandler disconnectHandler;\n \n     ProtocolProcessor() {\n     }\n \n-    public void init(ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore,\n-                     IAuthenticator authenticator, boolean allowAnonymous, IAuthorizator authorizator,\n-                     BrokerInterceptor interceptor, SessionsRepository sessionsRepository,\n-                     boolean reauthorizeSubscriptionsOnConnect) {\n-        init(subscriptions, storageService, sessionsStore, authenticator, allowAnonymous, false,\n-             authorizator, interceptor, sessionsRepository, reauthorizeSubscriptionsOnConnect);\n+    public void init(ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore, IAuthenticator authenticator, boolean allowAnonymous, IAuthorizator authorizator, BrokerInterceptor interceptor, SessionsRepository sessionsRepository, boolean reauthorizeSubscriptionsOnConnect) {\n+        init(subscriptions, storageService, sessionsStore, authenticator, allowAnonymous, false, authorizator, interceptor, sessionsRepository, reauthorizeSubscriptionsOnConnect);\n     }\n \n-    public void init(ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore,\n-                     IAuthenticator authenticator, boolean allowAnonymous, boolean allowZeroByteClientId,\n-                     IAuthorizator authorizator, BrokerInterceptor interceptor, SessionsRepository sessionsRepository,\n-                     boolean reauthorizeSubscriptionsOnConnect) {\n-        init(new ConnectionDescriptorStore(), subscriptions, storageService, sessionsStore,\n-             authenticator, allowAnonymous, allowZeroByteClientId, authorizator, interceptor, sessionsRepository,\n-             reauthorizeSubscriptionsOnConnect);\n+    public void init(ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore, IAuthenticator authenticator, boolean allowAnonymous, boolean allowZeroByteClientId, IAuthorizator authorizator, BrokerInterceptor interceptor, SessionsRepository sessionsRepository, boolean reauthorizeSubscriptionsOnConnect) {\n+        init(new ConnectionDescriptorStore(), subscriptions, storageService, sessionsStore, authenticator, allowAnonymous, allowZeroByteClientId, authorizator, interceptor, sessionsRepository, reauthorizeSubscriptionsOnConnect);\n     }\n \n     /**\n@@ -128,11 +112,8 @@ public class ProtocolProcessor {\n      * @param interceptor\n      *            to notify events to an intercept handler\n      */\n-    void init(IConnectionsManager connectionDescriptors, ISubscriptionsDirectory subscriptions,\n-              IMessagesStore storageService, ISessionsStore sessionsStore, IAuthenticator authenticator,\n-              boolean allowAnonymous, boolean allowZeroByteClientId, IAuthorizator authorizator,\n-              BrokerInterceptor interceptor, SessionsRepository sessionsRepository,\n-              boolean reauthorizeSubscriptionsOnConnect) {\n+\n+    void init(IConnectionsManager connectionDescriptors, ISubscriptionsDirectory subscriptions, IMessagesStore storageService, ISessionsStore sessionsStore, IAuthenticator authenticator, boolean allowAnonymous, boolean allowZeroByteClientId, IAuthorizator authorizator, BrokerInterceptor interceptor, SessionsRepository sessionsRepository, boolean reauthorizeSubscriptionsOnConnect) {\n         LOG.info(\"Initializing MQTT protocol processor..\");\n         this.connectionDescriptors = connectionDescriptors;\n         this.subscriptionInCourse = new ConcurrentHashMap<>();\n@@ -144,28 +125,24 @@ public class ProtocolProcessor {\n         }\n         m_messagesStore = storageService;\n         m_sessionsStore = sessionsStore;\n-\n         this.sessionsRepository = sessionsRepository;\n-\n         LOG.debug(\"Initializing messages publisher...\");\n         final PersistentQueueMessageSender messageSender = new PersistentQueueMessageSender(this.connectionDescriptors);\n-        this.messagesPublisher = new MessagesPublisher(connectionDescriptors, messageSender,\n-            subscriptions, this.sessionsRepository);\n-\n+        this.messagesPublisher = new MessagesPublisher(connectionDescriptors, messageSender, subscriptions, this.sessionsRepository);\n         LOG.debug(\"Initializing QoS publish handlers...\");\n-        this.qos0PublishHandler = new Qos0PublishHandler(m_authorizator, m_messagesStore, m_interceptor,\n-                this.messagesPublisher);\n-        this.qos1PublishHandler = new Qos1PublishHandler(m_authorizator, m_messagesStore, m_interceptor,\n-                this.connectionDescriptors, this.messagesPublisher);\n-        this.qos2PublishHandler = new Qos2PublishHandler(m_authorizator, subscriptions, m_messagesStore, m_interceptor,\n-                this.connectionDescriptors, this.messagesPublisher, this.sessionsRepository);\n-\n+        this.qos0PublishHandler = new Qos0PublishHandler(m_authorizator, m_messagesStore, m_interceptor, this.messagesPublisher);\n+        this.qos1PublishHandler = new Qos1PublishHandler(m_authorizator, m_messagesStore, m_interceptor, this.connectionDescriptors, this.messagesPublisher);\n+        this.qos2PublishHandler = new Qos2PublishHandler(\n+            m_authorizator,\n+            subscriptions,\n+            m_messagesStore,\n+            m_interceptor,\n+            this.connectionDescriptors,\n+            this.messagesPublisher,\n+            this.sessionsRepository);\n         LOG.debug(\"Initializing internal republisher...\");\n         this.internalRepublisher = new InternalRepublisher(messageSender);\n-\n-        connectHandler = new ConnectHandler(connectionDescriptors, m_interceptor, sessionsRepository, m_sessionsStore,\n-            authenticator, m_authorizator, subscriptions,\n-            allowAnonymous, allowZeroByteClientId, reauthorizeSubscriptionsOnConnect, internalRepublisher);\n+        connectHandler = new ConnectHandler(connectionDescriptors, m_interceptor, sessionsRepository, m_sessionsStore, authenticator, m_authorizator, subscriptions, allowAnonymous, allowZeroByteClientId, reauthorizeSubscriptionsOnConnect, internalRepublisher);\n         disconnectHandler = new DisconnectHandler(connectionDescriptors, sessionsRepository, subscriptions, m_interceptor);\n         LOG.info(\"Initialized\");\n     }\n@@ -179,13 +156,10 @@ public class ProtocolProcessor {\n         int messageID = msg.variableHeader().messageId();\n         String username = NettyUtils.userName(channel);\n         LOG.trace(\"retrieving inflight for messageID <{}>\", messageID);\n-\n         ClientSession targetSession = this.sessionsRepository.sessionForClient(clientID);\n         StoredMessage inflightMsg = targetSession.inFlightAcknowledged(messageID);\n-\n         String topic = inflightMsg.getTopic();\n-        InterceptAcknowledgedMessage wrapped = new InterceptAcknowledgedMessage(inflightMsg, topic, username,\n-                                                                                messageID);\n+        InterceptAcknowledgedMessage wrapped = new InterceptAcknowledgedMessage(inflightMsg, topic, username, messageID);\n         m_interceptor.notifyMessageAcknowledged(wrapped);\n     }\n \n@@ -193,16 +167,13 @@ public class ProtocolProcessor {\n         // TODO ugly, too much array copy\n         ByteBuf payload = msg.payload();\n         byte[] payloadContent = readBytesAndRewind(payload);\n-\n-        IMessagesStore.StoredMessage stored = new IMessagesStore.StoredMessage(payloadContent,\n-                msg.fixedHeader().qosLevel(), msg.variableHeader().topicName());\n+        IMessagesStore.StoredMessage stored = new IMessagesStore.StoredMessage(payloadContent, msg.fixedHeader().qosLevel(), msg.variableHeader().topicName());\n         stored.setRetained(msg.fixedHeader().isRetain());\n         return stored;\n     }\n \n     private static IMessagesStore.StoredMessage asStoredMessage(WillMessage will) {\n-        IMessagesStore.StoredMessage pub = new IMessagesStore.StoredMessage(will.getPayload().array(), will.getQos(),\n-                will.getTopic());\n+        IMessagesStore.StoredMessage pub = new IMessagesStore.StoredMessage(will.getPayload().array(), will.getQos(), will.getTopic());\n         pub.setRetained(will.isRetained());\n         return pub;\n     }\n@@ -210,8 +181,7 @@ public class ProtocolProcessor {\n     public void processPublish(Channel channel, MqttPublishMessage msg) {\n         final MqttQoS qos = msg.fixedHeader().qosLevel();\n         final String clientId = NettyUtils.clientID(channel);\n-        LOG.info(\"Processing PUBLISH message. CId={}, topic={}, messageId={}, qos={}\", clientId,\n-                 msg.variableHeader().topicName(), msg.variableHeader().messageId(), qos);\n+        LOG.info(\"Processing PUBLISH message. CId={}, topic={}, messageId={}, qos={}\", clientId, msg.variableHeader().topicName(), msg.variableHeader().messageId(), qos);\n         switch (qos) {\n             case AT_MOST_ONCE:\n                 this.qos0PublishHandler.receivedPublishQos0(channel, msg);\n@@ -240,11 +210,11 @@ public class ProtocolProcessor {\n      * @param clientId\n      *            the clientID\n      */\n+\n     public void internalPublish(MqttPublishMessage msg, final String clientId) {\n         final MqttQoS qos = msg.fixedHeader().qosLevel();\n         final Topic topic = new Topic(msg.variableHeader().topicName());\n         LOG.info(\"Sending PUBLISH message. Topic={}, qos={}\", topic, qos);\n-\n         IMessagesStore.StoredMessage toStoreMsg = asStoredMessage(msg);\n         if (clientId == null || clientId.isEmpty()) {\n             toStoreMsg.setClientID(\"BROKER_SELF\");\n@@ -252,10 +222,10 @@ public class ProtocolProcessor {\n             toStoreMsg.setClientID(clientId);\n         }\n         this.messagesPublisher.publish2Subscribers(toStoreMsg, topic);\n-\n         if (!msg.fixedHeader().isRetain()) {\n             return;\n         }\n+\n         if (qos == AT_MOST_ONCE || msg.payload().readableBytes() == 0) {\n             // QoS == 0 && retain => clean old retained\n             m_messagesStore.cleanRetained(topic);\n@@ -267,6 +237,7 @@ public class ProtocolProcessor {\n     /**\n      * Specialized version to publish will testament message.\n      */\n+\n     private void forwardPublishWill(WillMessage will, String clientID) {\n         LOG.info(\"Publishing will message. CId={}, topic={}\", clientID, will.getTopic());\n         // it has just to publish the message downstream to the subscribers\n@@ -280,7 +251,7 @@ public class ProtocolProcessor {\n         if (will.isRetained()) {\n             m_messagesStore.storeRetained(topic, tobeStored);\n         }\n-     }\n+    }\n \n     static MqttQoS lowerQosToTheSubscriptionDesired(Subscription sub, MqttQoS qos) {\n         if (qos.value() > sub.getRequestedQos().value()) {\n@@ -298,6 +269,7 @@ public class ProtocolProcessor {\n      * @param msg\n      *            the decoded pubrel message.\n      */\n+\n     public void processPubRel(Channel channel, MqttMessage msg) {\n         this.qos2PublishHandler.processPubRel(channel, msg);\n     }\n@@ -312,7 +284,6 @@ public class ProtocolProcessor {\n         targetSession.moveInFlightToSecondPhaseAckWaiting(messageID, ackedMsg);\n         // once received a PUBREC reply with a PUBREL(messageID)\n         LOG.debug(\"Processing PUBREC message. CId={}, messageId={}\", clientID, messageID);\n-\n         MqttFixedHeader pubRelHeader = new MqttFixedHeader(MqttMessageType.PUBREL, false, AT_LEAST_ONCE, false, 0);\n         MqttMessage pubRelMessage = new MqttMessage(pubRelHeader, from(messageID));\n         channel.writeAndFlush(pubRelMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n@@ -327,8 +298,7 @@ public class ProtocolProcessor {\n         StoredMessage inflightMsg = targetSession.completeReleasedPublish(messageID);\n         String username = NettyUtils.userName(channel);\n         String topic = inflightMsg.getTopic();\n-        final InterceptAcknowledgedMessage interceptAckMsg = new InterceptAcknowledgedMessage(inflightMsg, topic,\n-            username, messageID);\n+        final InterceptAcknowledgedMessage interceptAckMsg = new InterceptAcknowledgedMessage(inflightMsg, topic, username, messageID);\n         m_interceptor.notifyMessageAcknowledged(interceptAckMsg);\n     }\n \n@@ -364,12 +334,11 @@ public class ProtocolProcessor {\n      * @param msg\n      *            the decoded unsubscribe message.\n      */\n+\n     public void processUnsubscribe(Channel channel, MqttUnsubscribeMessage msg) {\n         List<String> topics = msg.payload().topics();\n         String clientID = NettyUtils.clientID(channel);\n-\n         LOG.debug(\"Processing UNSUBSCRIBE message. CId={}, topics={}\", clientID, topics);\n-\n         ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n         for (String t : topics) {\n             Topic topic = new Topic(t);\n@@ -380,7 +349,6 @@ public class ProtocolProcessor {\n                 LOG.error(\"Topic filter is not valid. CId={}, topics={}, badTopicFilter={}\", clientID, topics, topic);\n                 return;\n             }\n-\n             LOG.trace(\"Removing subscription. CId={}, topic={}\", clientID, topic);\n             subscriptions.removeSubscription(topic, clientID);\n             clientSession.unsubscribeFrom(topic);\n@@ -390,10 +358,8 @@ public class ProtocolProcessor {\n \n         // ack the client\n         int messageID = msg.variableHeader().messageId();\n-        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBACK, false, AT_MOST_ONCE,\n-                                                         false, 0);\n+        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBACK, false, AT_MOST_ONCE, false, 0);\n         MqttUnsubAckMessage ackMessage = new MqttUnsubAckMessage(fixedHeader, from(messageID));\n-\n         LOG.debug(\"Sending UNSUBACK message. CId={}, topics={}, messageId={}\", clientID, topics, messageID);\n         channel.writeAndFlush(ackMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n         LOG.info(\"Client <{}> unsubscribed from topics <{}>\", clientID, topics);\n@@ -403,32 +369,31 @@ public class ProtocolProcessor {\n         String clientID = NettyUtils.clientID(channel);\n         int messageID = messageId(msg);\n         LOG.debug(\"Processing SUBSCRIBE message. CId={}, messageId={}\", clientID, messageID);\n-\n         RunningSubscription executionKey = new RunningSubscription(clientID, messageID);\n         SubscriptionState currentStatus = subscriptionInCourse.putIfAbsent(executionKey, SubscriptionState.VERIFIED);\n         if (currentStatus != null) {\n             LOG.warn(\"Client sent another SUBSCRIBE message while this one was being processed CId={}, messageId={}\",\n-                clientID, messageID);\n+                clientID,\n+                messageID);\n             return;\n         }\n+\n         String username = NettyUtils.userName(channel);\n         List<MqttTopicSubscription> ackTopics = doVerify(clientID, username, msg);\n         MqttSubAckMessage ackMessage = doAckMessageFromValidateFilters(ackTopics, messageID);\n         if (!this.subscriptionInCourse.replace(executionKey, SubscriptionState.VERIFIED, SubscriptionState.STORED)) {\n-            LOG.warn(\"Client sent another SUBSCRIBE message while the topic filters were being verified CId={}, \" +\n-                \"messageId={}\", clientID, messageID);\n+            LOG.warn(\"Client sent another SUBSCRIBE message while the topic filters were being verified CId={}, \" + \"messageId={}\",\n+                clientID,\n+                messageID);\n             return;\n         }\n-\n         LOG.debug(\"Creating and storing subscriptions CId={}, messageId={}, topics={}\", clientID, messageID, ackTopics);\n-\n         List<Subscription> newSubscriptions = doStoreSubscription(ackTopics, clientID);\n \n         // save session, persist subscriptions from session\n         for (Subscription subscription : newSubscriptions) {\n             subscriptions.add(subscription);\n         }\n-\n         LOG.debug(\"Sending SUBACK response CId={}, messageId={}\", clientID, messageID);\n         channel.writeAndFlush(ackMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);\n \n@@ -447,16 +412,15 @@ public class ProtocolProcessor {\n \n     private List<Subscription> doStoreSubscription(List<MqttTopicSubscription> ackTopics, String clientID) {\n         ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n-\n         List<Subscription> newSubscriptions = new ArrayList<>();\n         for (MqttTopicSubscription req : ackTopics) {\n             // TODO this is SUPER UGLY\n             if (req.qualityOfService() == FAILURE) {\n+\n                 continue;\n             }\n             final Topic topic = new Topic(req.topicName());\n             Subscription newSubscription = new Subscription(clientID, topic, req.qualityOfService());\n-\n             clientSession.subscribe(newSubscription);\n             newSubscriptions.add(newSubscription);\n         }\n@@ -472,27 +436,36 @@ public class ProtocolProcessor {\n      *            the subscribe message to verify\n      * @return the list of verified topics for the given subscribe message.\n      */\n+\n     private List<MqttTopicSubscription> doVerify(String clientID, String username, MqttSubscribeMessage msg) {\n         ClientSession clientSession = this.sessionsRepository.sessionForClient(clientID);\n         List<MqttTopicSubscription> ackTopics = new ArrayList<>();\n-\n         final int messageId = messageId(msg);\n         for (MqttTopicSubscription req : msg.payload().topicSubscriptions()) {\n             Topic topic = new Topic(req.topicName());\n             if (!m_authorizator.canRead(topic, username, clientSession.clientID)) {\n                 // send SUBACK with 0x80, the user hasn't credentials to read the topic\n-                LOG.warn(\"Client does not have read permissions on the topic CId={}, username={}, messageId={}, \" +\n-                    \"topic={}\", clientID, username, messageId, topic);\n+                LOG.warn(\"Client does not have read permissions on the topic CId={}, username={}, messageId={}, \" + \"topic={}\",\n+                    clientID,\n+                    username,\n+                    messageId,\n+                    topic);\n                 ackTopics.add(new MqttTopicSubscription(topic.toString(), FAILURE));\n             } else {\n                 MqttQoS qos;\n                 if (topic.isValid()) {\n                     LOG.debug(\"Client will be subscribed to the topic CId={}, username={}, messageId={}, topic={}\",\n-                        clientID, username, messageId, topic);\n+                        clientID,\n+                        username,\n+                        messageId,\n+                        topic);\n                     qos = req.qualityOfService();\n                 } else {\n-                    LOG.warn(\"Topic filter is not valid CId={}, username={}, messageId={}, topic={}\", clientID,\n-                        username, messageId, topic);\n+                    LOG.warn(\"Topic filter is not valid CId={}, username={}, messageId={}, topic={}\",\n+                        clientID,\n+                        username,\n+                        messageId,\n+                        topic);\n                     qos = FAILURE;\n                 }\n                 ackTopics.add(new MqttTopicSubscription(topic.toString(), qos));\n@@ -504,6 +477,7 @@ public class ProtocolProcessor {\n     /**\n      * Create the SUBACK response from a list of topicFilters\n      */\n+\n     private MqttSubAckMessage doAckMessageFromValidateFilters(List<MqttTopicSubscription> topicFilters, int messageId) {\n         List<Integer> grantedQoSLevels = new ArrayList<>();\n         for (MqttTopicSubscription req : topicFilters) {\n@@ -516,18 +490,17 @@ public class ProtocolProcessor {\n     }\n \n     private void publishRetainedMessagesInSession(Subscription newSubscription, String username) {\n-        LOG.debug(\"Retrieving retained messages CId={}, topics={}\", newSubscription.getClientId(),\n-                newSubscription.getTopicFilter());\n+        LOG.debug(\"Retrieving retained messages CId={}, topics={}\",\n+            newSubscription.getClientId(),\n+            newSubscription.getTopicFilter());\n \n         // scans retained messages to be published to the new subscription\n         // TODO this is ugly, it does a linear scan on potential big dataset\n-        Collection<IMessagesStore.StoredMessage> messages = m_messagesStore\n-                .searchMatching(key -> key.match(newSubscription.getTopicFilter()));\n-\n+        Collection<IMessagesStore.StoredMessage> messages = m_messagesStore.searchMatching(key -> key.match(newSubscription.getTopicFilter()));\n         if (!messages.isEmpty()) {\n-            LOG.info(\"Publishing retained messages CId={}, topics={}, messagesNo={}\",\n-                newSubscription.getClientId(), newSubscription.getTopicFilter(), messages.size());\n+            LOG.info(\"Publishing retained messages CId={}, topics={}, messagesNo={}\", newSubscription.getClientId(), newSubscription.getTopicFilter(), messages.size());\n         }\n+\n         ClientSession targetSession = this.sessionsRepository.sessionForClient(newSubscription.getClientId());\n \n         // adapt the message QoS to subscriber's accepted accepted\n@@ -536,7 +509,6 @@ public class ProtocolProcessor {\n             MqttQoS qosToPublish = MqttQoS.valueOf(lowestQoS);\n             msg.setQos(qosToPublish);\n         }\n-\n         this.internalRepublisher.publishRetained(targetSession, messages);\n \n         // notify the Observables\n@@ -553,9 +525,7 @@ public class ProtocolProcessor {\n                 emptyQueue = true;\n             } else {\n                 // recreate a publish from stored publish in queue\n-                MqttPublishMessage pubMsg = createPublishForQos(msg.msg.getTopic(), msg.msg.getQos(),\n-                                                                msg.msg.getPayload(), msg.msg.isRetained(),\n-                                                                msg.messageId);\n+                MqttPublishMessage pubMsg = createPublishForQos(msg.msg.getTopic(), msg.msg.getQos(), msg.msg.getPayload(), msg.msg.isRetained(), msg.messageId);\n                 channel.write(pubMsg).addListener(FIRE_EXCEPTION_ON_FAILURE);\n             }\n         }\n@@ -582,4 +552,4 @@ public class ProtocolProcessor {\n         if (m_interceptor != null)\n             m_interceptor.stop();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 120
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "169",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 123).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}