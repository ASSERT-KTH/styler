{
    "project_name": "wso2-attic-commons",
    "error_id": "343",
    "information": {
        "errors": [
            {
                "line": "109",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 129).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "     * @param <T> return type\n     * @param transaction transaction to execute\n     * @param timeout, The value of the timeout in seconds. If the value is zero, the transaction service uses the default value.\n     * @return result\n     * @throws Exception\n     */",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "109",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "113",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 130).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/343/Scheduler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/343/Scheduler.java\nindex a6fc08d1c0c..66d3df25d9f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/343/Scheduler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/343/Scheduler.java\n@@ -34,286 +34,317 @@ import org.apache.ode.bpel.common.CorrelationKeySet;\n  * The BPEL scheduler.\n  */\n public interface Scheduler {\n-    void setJobProcessor(JobProcessor processor) throws ContextException;\n-\n-    void setPolledRunnableProcesser(JobProcessor polledRunnableProcessor);\n-\n+  void setJobProcessor(JobProcessor processor) throws ContextException;\n+\n+  void setPolledRunnableProcesser(JobProcessor polledRunnableProcessor);\n+\n+  /**\n+   * Schedule a persisted job. Persisted jobs MUST survive system failure.\n+   * They also must not be scheduled unless the transaction associated with\n+   * the calling thread commits.\n+   *\n+   * @param jobDetail information about the job\n+   * @param when      when the job should run (<code>null</code> means now)\n+   * @return unique job identifier\n+   */\n+  String schedulePersistedJob(JobDetails jobDetail, Date when)\n+    throws ContextException;\n+\n+\n+  /**\n+   * Schedule a Runnable that will be executed on a dedicated thread pool.\n+   *\n+   * @param runnable\n+   * @param when\n+   * @return\n+   * @throws ContextException\n+   */\n+  String scheduleMapSerializableRunnable(MapSerializableRunnable runnable, Date when) throws ContextException;\n+\n+  /**\n+   * Schedule a volatile (non-persisted) job. Volatile jobs should not be\n+   * saved in the database and should not survive system crash. Volatile\n+   * jobs scheduled from a transactional context should be scheduled\n+   * regardless of whether the transaction commits.\n+   *\n+   * @param transacted should the job be executed in a transaction?\n+   * @param jobDetail  information about the job\n+   * @param when       does the job should be executed?\n+   * @return unique (as far as the scheduler is concerned) job identifier\n+   */\n+  String scheduleVolatileJob(boolean transacted, JobDetails jobDetail, Date when) throws ContextException;\n+\n+  /**\n+   * Schedule a volatile job for right now\n+   *\n+   * @see #scheduleVolatileJob(boolean, java.util.Map, java.util.Date)\n+   */\n+  String scheduleVolatileJob(boolean transacted, JobDetails jobDetail) throws ContextException;\n+\n+  /**\n+   * Make a good effort to cancel the job. If its already running no big\n+   * deal.\n+   *\n+   * @param jobId job identifier of the job\n+   */\n+  void cancelJob(String jobId) throws ContextException;\n+\n+  /**\n+   * Execute a {@link Callable} in a transactional context. If the callable\n+   * throws an exception, then the transaction will be rolled back, otherwise\n+   * the transaction will commit.\n+   *\n+   * @param <T>         return type\n+   * @param transaction transaction to execute\n+   * @return result\n+   * @throws Exception\n+   */\n+  <T> T execTransaction(Callable<T> transaction)\n+    throws Exception, ContextException;\n+\n+  /**\n+   * Execute a {@link Callable} in a transactional context. If the callable\n+   * throws an exception, then the transaction will be rolled back, otherwise\n+   * the transaction will commit. Also, modify the value of the timeout value\n+   * that is associated with the transactions started by the current thread.\n+   *\n+   * @param <T>         return type\n+   * @param transaction transaction to execute\n+   * @param timeout,    The value of the timeout in seconds. If the value is zero, the transaction service uses the default value.\n+   * @return result\n+   * @throws Exception\n+   */\n+  <T> T execTransaction(Callable<T> transaction, int timeout)\n+    throws Exception, ContextException;\n+\n+  void setRollbackOnly() throws Exception;\n+\n+  /**\n+   * Same as execTransaction but executes in a different thread to guarantee\n+   * isolation from the main execution thread.\n+   *\n+   * @param transaction\n+   * @return\n+   * @throws Exception\n+   * @throws ContextException\n+   */\n+  <T> Future<T> execIsolatedTransaction(final Callable<T> transaction)\n+    throws Exception, ContextException;\n+\n+  /**\n+   * @return true if the current thread is associated with a transaction.\n+   */\n+  boolean isTransacted();\n+\n+  /**\n+   * Register a transaction synchronizer.\n+   *\n+   * @param synch synchronizer\n+   * @throws ContextException\n+   */\n+  void registerSynchronizer(Synchronizer synch) throws ContextException;\n+\n+  void start();\n+\n+  void stop();\n+\n+  void shutdown();\n+\n+  public interface Synchronizer {\n     /**\n-     * Schedule a persisted job. Persisted jobs MUST survive system failure.\n-     * They also must not be scheduled unless the transaction associated with\n-     * the calling thread commits.\n-     * @param jobDetail information about the job\n-     * @param when when the job should run (<code>null</code> means now)\n-     * @return unique job identifier\n+     * Called after the transaction is completed.\n+     *\n+     * @param success indicates whether the transaction was comitted\n      */\n-    String schedulePersistedJob(JobDetails jobDetail,Date when)\n-            throws ContextException ;\n-\n+    void afterCompletion(boolean success);\n \n     /**\n-     * Schedule a Runnable that will be executed on a dedicated thread pool.\n-     * @param runnable\n-     * @param when\n-     * @return\n-     * @throws ContextException\n+     * Called before the transaction is completed.\n      */\n-    String scheduleMapSerializableRunnable(MapSerializableRunnable runnable, Date when) throws ContextException;\n-\n+    void beforeCompletion();\n+  }\n+\n+  /**\n+   * Interface implemented by the object responsible for job execution.\n+   *\n+   * @author mszefler\n+   */\n+  public interface JobProcessor {\n     /**\n-     * Schedule a volatile (non-persisted) job. Volatile jobs should not be\n-     * saved in the database and should not survive system crash. Volatile\n-     * jobs scheduled from a transactional context should be scheduled\n-     * regardless of whether the transaction commits.\n+     * Implements execution of the job.\n      *\n-     * @param transacted should the job be executed in a transaction?\n-     * @param jobDetail information about the job\n-     * @param when does the job should be executed?\n-     * @return unique (as far as the scheduler is concerned) job identifier\n+     * @param jobInfo the job information\n+     * @throws JobProcessorException\n      */\n-    String scheduleVolatileJob(boolean transacted, JobDetails jobDetail, Date when) throws ContextException;\n+    void onScheduledJob(JobInfo jobInfo) throws JobProcessorException;\n+  }\n+\n+  public enum JobType {\n+    TIMER,\n+    RESUME,\n+    INVOKE_INTERNAL,\n+    INVOKE_RESPONSE,\n+    MATCHER,\n+    INVOKE_CHECK,\n+    MEX_MATCHER\n+  }\n+\n+  public static class JobDetails {\n+    public Long instanceId;\n+    public String mexId;\n+    public String processId;\n+    public String type;\n+    public String channel;\n+    public String correlatorId;\n+    public String correlationKeySet;\n+    public Integer retryCount;\n+    public Boolean inMem;\n+    public Map<String, Object> detailsExt = new HashMap<String, Object>();\n+\n+    public Boolean getInMem() {\n+      return inMem == null ? false : inMem;\n+    }\n \n-    /**\n-     * Schedule a volatile job for right now\n-     * @see #scheduleVolatileJob(boolean, java.util.Map, java.util.Date)\n-     */\n-    String scheduleVolatileJob(boolean transacted, JobDetails jobDetail) throws ContextException;\n+    public void setInMem(Boolean inMem) {\n+      this.inMem = inMem;\n+    }\n \n-    /**\n-     * Make a good effort to cancel the job. If its already running no big\n-     * deal.\n-     * @param jobId job identifier of the job\n-     */\n-    void cancelJob(String jobId) throws ContextException;\n+    public String getMexId() {\n+      return mexId;\n+    }\n \n-    /**\n-     * Execute a {@link Callable} in a transactional context. If the callable\n-     * throws an exception, then the transaction will be rolled back, otherwise\n-     * the transaction will commit.\n-     *\n-     * @param <T> return type\n-     * @param transaction transaction to execute\n-     * @return result\n-     * @throws Exception\n-     */\n-    <T> T execTransaction(Callable<T> transaction)\n-            throws Exception, ContextException;\n+    public void setMexId(String mexId) {\n+      this.mexId = mexId;\n+    }\n \n-    /**\n-     * Execute a {@link Callable} in a transactional context. If the callable\n-     * throws an exception, then the transaction will be rolled back, otherwise\n-     * the transaction will commit. Also, modify the value of the timeout value\n-     * that is associated with the transactions started by the current thread.\n-     *\n-     * @param <T> return type\n-     * @param transaction transaction to execute\n-     * @param timeout, The value of the timeout in seconds. If the value is zero, the transaction service uses the default value.\n-     * @return result\n-     * @throws Exception\n-     */\n-    <T> T execTransaction(Callable<T> transaction, int timeout)\n-            throws Exception, ContextException;\n+    public QName getProcessId() {\n+      return processId == null ? null : QName.valueOf(processId);\n+    }\n \n-    void setRollbackOnly() throws Exception;\n+    public void setProcessId(QName processId) {\n+      this.processId = \"\" + processId;\n+    }\n \n-    /**\n-     * Same as execTransaction but executes in a different thread to guarantee\n-     * isolation from the main execution thread.\n-     * @param transaction\n-     * @return\n-     * @throws Exception\n-     * @throws ContextException\n-     */\n-    <T> Future<T> execIsolatedTransaction(final Callable<T> transaction)\n-            throws Exception, ContextException;\n+    public JobType getType() {\n+      return JobType.valueOf(type);\n+    }\n \n-    /**\n-     * @return true if the current thread is associated with a transaction.\n-     */\n-    boolean isTransacted();\n+    public void setType(JobType type) {\n+      this.type = type.toString();\n+    }\n \n-    /**\n-     * Register a transaction synchronizer.\n-     * @param synch synchronizer\n-     * @throws ContextException\n-     */\n-    void registerSynchronizer(Synchronizer synch) throws ContextException;\n+    public String getChannel() {\n+      return channel;\n+    }\n \n-    void start();\n+    public void setChannel(String channel) {\n+      this.channel = channel;\n+    }\n \n-    void stop();\n+    public String getCorrelatorId() {\n+      return correlatorId;\n+    }\n \n-    void shutdown();\n+    public void setCorrelatorId(String correlatorId) {\n+      this.correlatorId = correlatorId;\n+    }\n \n-    public interface Synchronizer {\n-        /**\n-         * Called after the transaction is completed.\n-         * @param success indicates whether the transaction was comitted\n-         */\n-        void afterCompletion(boolean success);\n+    public CorrelationKeySet getCorrelationKeySet() {\n+      return new CorrelationKeySet(correlationKeySet);\n+    }\n \n-        /**\n-         * Called before the transaction is completed.\n-         */\n-        void beforeCompletion();\n+    public void setCorrelationKeySet(CorrelationKeySet correlationKeySet) {\n+      this.correlationKeySet = correlationKeySet == null ? null : correlationKeySet.toCanonicalString();\n     }\n \n-    /**\n-     * Interface implemented by the object responsible for job execution.\n-     * @author mszefler\n-     */\n-    public interface JobProcessor {\n-         /**\n-          * Implements execution of the job.\n-          * @param jobInfo the job information\n-          * @throws JobProcessorException\n-          */\n-        void onScheduledJob(JobInfo jobInfo) throws JobProcessorException;\n+    public Integer getRetryCount() {\n+      return retryCount == null ? 0 : retryCount;\n     }\n \n-    public enum JobType {\n-        TIMER,\n-        RESUME,\n-        INVOKE_INTERNAL,\n-        INVOKE_RESPONSE,\n-        MATCHER,\n-        INVOKE_CHECK,\n-        MEX_MATCHER\n+    public void setRetryCount(Integer retryCount) {\n+      this.retryCount = retryCount;\n     }\n \n-    public static class JobDetails {\n-        public Long instanceId;\n-        public String mexId;\n-        public String processId;\n-        public String type;\n-        public String channel;\n-        public String correlatorId;\n-        public String correlationKeySet;\n-        public Integer retryCount;\n-        public Boolean inMem;\n-        public Map<String, Object> detailsExt = new HashMap<String, Object>();\n-\n-        public Boolean getInMem() {\n-            return inMem == null ? false : inMem;\n-        }\n-        public void setInMem(Boolean inMem) {\n-            this.inMem = inMem;\n-        }\n-        public String getMexId() {\n-            return mexId;\n-        }\n-        public void setMexId(String mexId) {\n-            this.mexId = mexId;\n-        }\n-        public QName getProcessId() {\n-            return processId == null ? null : QName.valueOf(processId);\n-        }\n-        public void setProcessId(QName processId) {\n-            this.processId = \"\" + processId;\n-        }\n-        public JobType getType() {\n-            return JobType.valueOf(type);\n-        }\n-        public void setType(JobType type) {\n-            this.type = type.toString();\n-        }\n-        public String getChannel() {\n-            return channel;\n-        }\n-        public void setChannel(String channel) {\n-            this.channel = channel;\n-        }\n-        public String getCorrelatorId() {\n-            return correlatorId;\n-        }\n-        public void setCorrelatorId(String correlatorId) {\n-            this.correlatorId = correlatorId;\n-        }\n-        public CorrelationKeySet getCorrelationKeySet() {\n-            return new CorrelationKeySet(correlationKeySet);\n-        }\n-        public void setCorrelationKeySet(CorrelationKeySet correlationKeySet) {\n-            this.correlationKeySet = correlationKeySet == null ? null : correlationKeySet.toCanonicalString();\n-        }\n-        public Integer getRetryCount() {\n-            return retryCount == null ? 0 : retryCount;\n-        }\n-        public void setRetryCount(Integer retryCount) {\n-            this.retryCount = retryCount;\n-        }\n-        public Long getInstanceId() {\n-            return instanceId;\n-        }\n-        public void setInstanceId(Long instanceId) {\n-            this.instanceId = instanceId;\n-        }\n-        public Map<String, Object> getDetailsExt() {\n-            return detailsExt;\n-        }\n-        public void setDetailsExt(Map<String, Object> detailsExt) {\n-            this.detailsExt = detailsExt;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"JobDetails(\"\n-            + \" instanceId: \" + instanceId\n-            + \" mexId: \" + mexId\n-            + \" processId: \" + processId\n-            + \" type: \" + type\n-            + \" channel: \" + channel\n-            + \" correlatorId: \" + correlatorId\n-            + \" correlationKeySet: \" + correlationKeySet\n-            + \" retryCount: \" + retryCount\n-            + \" inMem: \" + inMem\n-            + \" detailsExt: \" + detailsExt\n-            + \")\";\n-        }\n+    public Long getInstanceId() {\n+      return instanceId;\n     }\n \n-    /**\n-     * Wrapper containing information about a scheduled job.\n-     * @author mszefler\n-     */\n-    public static class JobInfo implements Serializable {\n-        private static final long serialVersionUID = 1L;\n-        public final String jobName;\n-        public final int retryCount;\n-        public final JobDetails jobDetail;\n-\n-        public JobInfo(String jobName, JobDetails jobDetail, int retryCount) {\n-            this.jobName = jobName;\n-            this.jobDetail = jobDetail;\n-            this.retryCount = retryCount;\n-        }\n-\n-        public String toString() {\n-            return jobName + \"[\"+retryCount +\"]: \" + jobDetail;\n-        }\n+    public void setInstanceId(Long instanceId) {\n+      this.instanceId = instanceId;\n     }\n \n-    /**\n-     * Exception thrown by the {@link JobProcessor} to indicate failure in job\n-     * processing.\n-     * @author mszefler\n-     */\n-    public class JobProcessorException extends RuntimeException {\n-        private static final long serialVersionUID = 1L;\n-        public final boolean retry;\n-\n-        public JobProcessorException(boolean retry) {\n-            this.retry = retry;\n-        }\n-\n-        public JobProcessorException(Throwable cause, boolean retry) {\n-            super(cause);\n-            this.retry = retry;\n-        }\n+    public Map<String, Object> getDetailsExt() {\n+      return detailsExt;\n+    }\n+\n+    public void setDetailsExt(Map<String, Object> detailsExt) {\n+      this.detailsExt = detailsExt;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"JobDetails(\"\n+        + \" instanceId: \" + instanceId\n+        + \" mexId: \" + mexId\n+        + \" processId: \" + processId\n+        + \" type: \" + type\n+        + \" channel: \" + channel\n+        + \" correlatorId: \" + correlatorId\n+        + \" correlationKeySet: \" + correlationKeySet\n+        + \" retryCount: \" + retryCount\n+        + \" inMem: \" + inMem\n+        + \" detailsExt: \" + detailsExt\n+        + \")\";\n+    }\n+  }\n+\n+  /**\n+   * Wrapper containing information about a scheduled job.\n+   *\n+   * @author mszefler\n+   */\n+  public static class JobInfo implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+    public final String jobName;\n+    public final int retryCount;\n+    public final JobDetails jobDetail;\n+\n+    public JobInfo(String jobName, JobDetails jobDetail, int retryCount) {\n+      this.jobName = jobName;\n+      this.jobDetail = jobDetail;\n+      this.retryCount = retryCount;\n     }\n \n-    public interface MapSerializableRunnable extends Runnable, Serializable {\n-        void storeToDetails(JobDetails details);\n-        void restoreFromDetails(JobDetails details);\n+    public String toString() {\n+      return jobName + \"[\" + retryCount + \"]: \" + jobDetail;\n     }\n-    \n-    public void acquireTransactionLocks();\n+  }\n+\n+  /**\n+   * Exception thrown by the {@link JobProcessor} to indicate failure in job\n+   * processing.\n+   *\n+   * @author mszefler\n+   */\n+  public class JobProcessorException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+    public final boolean retry;\n+\n+    public JobProcessorException(boolean retry) {\n+      this.retry = retry;\n+    }\n+\n+    public JobProcessorException(Throwable cause, boolean retry) {\n+      super(cause);\n+      this.retry = retry;\n+    }\n+  }\n+\n+  public interface MapSerializableRunnable extends Runnable, Serializable {\n+    void storeToDetails(JobDetails details);\n+\n+    void restoreFromDetails(JobDetails details);\n+  }\n+\n+  public void acquireTransactionLocks();\n }\n",
            "diff_size": 453
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "109",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/343/Scheduler.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/343/Scheduler.java\nindex a6fc08d1c0c..a4ca2152953 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/343/Scheduler.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/343/Scheduler.java\n@@ -46,7 +46,7 @@ public interface Scheduler {\n      * @param when when the job should run (<code>null</code> means now)\n      * @return unique job identifier\n      */\n-    String schedulePersistedJob(JobDetails jobDetail,Date when)\n+    String schedulePersistedJob(JobDetails jobDetail, Date when)\n             throws ContextException ;\n \n \n@@ -162,12 +162,13 @@ public interface Scheduler {\n      * @author mszefler\n      */\n     public interface JobProcessor {\n-         /**\n+\n+ /**\n           * Implements execution of the job.\n           * @param jobInfo the job information\n           * @throws JobProcessorException\n           */\n-        void onScheduledJob(JobInfo jobInfo) throws JobProcessorException;\n+void onScheduledJob(JobInfo jobInfo) throws JobProcessorException;\n     }\n \n     public enum JobType {\n@@ -287,7 +288,7 @@ public interface Scheduler {\n         }\n \n         public String toString() {\n-            return jobName + \"[\"+retryCount +\"]: \" + jobDetail;\n+            return jobName + \"[\"+retryCount+ \"]: \" + jobDetail;\n         }\n     }\n \n@@ -316,4 +317,4 @@ public interface Scheduler {\n     }\n     \n     public void acquireTransactionLocks();\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 6
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "109",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "109",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 129).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}