{
    "project_name": "IQSS-dataverse",
    "error_id": "25",
    "information": {
        "errors": [
            {
                "line": "190",
                "column": "9",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "        String idStatus = DRAFT;\n        if(dvObject.isReleased()) {\n        \tidStatus = PUBLIC;\n        } \n        if ( idStatus != null ) {\n            switch ( idStatus ) {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "197",
                    "column": "19",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/25/DOIDataCiteServiceBean.java\nindex e7dd49a6926..ec9399d42b2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/25/DOIDataCiteServiceBean.java\n@@ -187,7 +187,7 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n         //ToDo - PidUtils currently has a DataCite API call that would get the status at DataCite for this identifier - that could be more accurate than assuming based on whether the dvObject has been published\n         String idStatus = DRAFT;\n         if(dvObject.isReleased()) {\n-        \tidStatus = PUBLIC;\n+        idStatus = PUBLIC;\n         } \n         if ( idStatus != null ) {\n             switch ( idStatus ) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/25/DOIDataCiteServiceBean.java\nindex e7dd49a6926..5af89684d0c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/25/DOIDataCiteServiceBean.java\n@@ -18,264 +18,265 @@ import org.apache.commons.httpclient.HttpStatus;\n \n \n /**\n- *\n  * @author luopc\n  */\n @Stateless\n public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n \n-    private static final Logger logger = Logger.getLogger(DOIDataCiteServiceBean.class.getCanonicalName());\n-    \n-    private static final String PUBLIC = \"public\";\n-    private static final String FINDABLE = \"findable\";\n-    private static final String RESERVED = \"reserved\";\n-    private static final String DRAFT = \"draft\";\n+  private static final Logger logger = Logger.getLogger(DOIDataCiteServiceBean.class.getCanonicalName());\n \n-    @EJB\n-    DOIDataCiteRegisterService doiDataCiteRegisterService;\n+  private static final String PUBLIC = \"public\";\n+  private static final String FINDABLE = \"findable\";\n+  private static final String RESERVED = \"reserved\";\n+  private static final String DRAFT = \"draft\";\n \n-    public DOIDataCiteServiceBean() {\n+  @EJB\n+  DOIDataCiteRegisterService doiDataCiteRegisterService;\n+\n+  public DOIDataCiteServiceBean() {\n+  }\n+\n+  @Override\n+  public boolean registerWhenPublished() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean alreadyExists(DvObject dvObject) {\n+    if (dvObject == null) {\n+      logger.severe(\"Null DvObject sent to alreadyExists().\");\n+      return false;\n     }\n+    return alreadyExists(dvObject.getGlobalId());\n+  }\n \n-    @Override\n-    public boolean registerWhenPublished() {\n-        return false;\n+  @Override\n+  public boolean alreadyExists(GlobalId pid) {\n+    logger.log(Level.FINE, \"alreadyExists\");\n+    if (pid == null || pid.asString().isEmpty()) {\n+      logger.fine(\"No identifier sent.\");\n+      return false;\n     }\n+    boolean alreadyExists;\n+    String identifier = pid.asString();\n+    try {\n+      alreadyExists = doiDataCiteRegisterService.testDOIExists(identifier);\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"alreadyExists failed\");\n+      return false;\n+    }\n+    return alreadyExists;\n+  }\n+\n \n-    @Override\n-    public boolean alreadyExists(DvObject dvObject) {\n-        if(dvObject==null) {\n-            logger.severe(\"Null DvObject sent to alreadyExists().\");\n-            return false;\n-        }\n-        return alreadyExists(dvObject.getGlobalId());\n+  @Override\n+  public String createIdentifier(DvObject dvObject) throws Exception {\n+    logger.log(Level.FINE, \"createIdentifier\");\n+    if (dvObject.getIdentifier() == null || dvObject.getIdentifier().isEmpty()) {\n+      dvObject = generateIdentifier(dvObject);\n     }\n+    String identifier = getIdentifier(dvObject);\n+    Map<String, String> metadata = getMetadataForCreateIndicator(dvObject);\n+    metadata.put(\"_status\", \"reserved\");\n+    try {\n+      String retString = doiDataCiteRegisterService.reserveIdentifier(identifier, metadata, dvObject);\n+      logger.log(Level.FINE, \"create DOI identifier retString : \" + retString);\n+      return retString;\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Identifier not created: create failed\", e);\n+      throw e;\n+    }\n+  }\n \n-    @Override\n-    public boolean alreadyExists(GlobalId pid) {\n-        logger.log(Level.FINE,\"alreadyExists\");\n-        if(pid==null || pid.asString().isEmpty()) {\n-            logger.fine(\"No identifier sent.\");\n-            return false;\n-        }\n-        boolean alreadyExists;\n-        String identifier = pid.asString();\n-        try{\n-            alreadyExists = doiDataCiteRegisterService.testDOIExists(identifier); \n-        } catch (Exception e){\n-            logger.log(Level.WARNING, \"alreadyExists failed\");\n-            return false;\n-        }\n-        return  alreadyExists;\n+  @Override\n+  public HashMap getIdentifierMetadata(DvObject dvObject) {\n+    logger.log(Level.FINE, \"getIdentifierMetadata\");\n+    String identifier = getIdentifier(dvObject);\n+    HashMap<String, String> metadata = new HashMap<>();\n+    try {\n+      metadata = doiDataCiteRegisterService.getMetadata(identifier);\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"getIdentifierMetadata failed\", e);\n     }\n-    \n+    return metadata;\n+  }\n+\n \n-    @Override\n-    public String createIdentifier(DvObject dvObject) throws Exception {\n-        logger.log(Level.FINE,\"createIdentifier\");\n-        if(dvObject.getIdentifier() == null || dvObject.getIdentifier().isEmpty() ){\n-            dvObject = generateIdentifier(dvObject);\n-        }\n-        String identifier = getIdentifier(dvObject);\n-        Map<String, String> metadata = getMetadataForCreateIndicator(dvObject);\n-        metadata.put(\"_status\", \"reserved\");\n-        try {\n-            String retString = doiDataCiteRegisterService.reserveIdentifier(identifier, metadata, dvObject);\n-            logger.log(Level.FINE, \"create DOI identifier retString : \" + retString);\n-            return retString;\n-        } catch (Exception e) {\n-            logger.log(Level.WARNING, \"Identifier not created: create failed\", e);\n-            throw e;\n-        }\n+  /**\n+   * Looks up the metadata for a Global Identifier\n+   *\n+   * @param protocol   the identifier system, e.g. \"doi\"\n+   * @param authority  the namespace that the authority manages in the identifier system\n+   * @param identifier the local identifier part\n+   * @return a Map of metadata. It is empty when the lookup failed, e.g. when\n+   * the identifier does not exist.\n+   */\n+  @Override\n+  public HashMap<String, String> lookupMetadataFromIdentifier(String protocol, String authority, String identifier) {\n+    logger.log(Level.FINE, \"lookupMetadataFromIdentifier\");\n+    String identifierOut = getIdentifierForLookup(protocol, authority, identifier);\n+    HashMap<String, String> metadata = new HashMap<>();\n+    try {\n+      metadata = doiDataCiteRegisterService.getMetadata(identifierOut);\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"None existing so we can use this identifier\");\n+      logger.log(Level.WARNING, \"identifier: {0}\", identifierOut);\n     }\n+    return metadata;\n+  }\n \n-    @Override\n-    public HashMap getIdentifierMetadata(DvObject dvObject) {\n-        logger.log(Level.FINE,\"getIdentifierMetadata\");\n-        String identifier = getIdentifier(dvObject);\n-        HashMap<String, String> metadata = new HashMap<>();\n-        try {\n-            metadata = doiDataCiteRegisterService.getMetadata(identifier);\n-        } catch (Exception e) {\n-            logger.log(Level.WARNING, \"getIdentifierMetadata failed\", e);\n-        }\n-        return metadata;\n+\n+  /**\n+   * Modifies the DOI metadata for a Dataset\n+   *\n+   * @param dvObject the dvObject whose metadata needs to be modified\n+   * @return the Dataset identifier, or null if the modification failed\n+   * @throws java.lang.Exception\n+   */\n+  @Override\n+  public String modifyIdentifierTargetURL(DvObject dvObject) throws Exception {\n+    logger.log(Level.FINE, \"modifyIdentifier\");\n+    String identifier = getIdentifier(dvObject);\n+    try {\n+      HashMap<String, String> metadata = doiDataCiteRegisterService.getMetadata(identifier);\n+      doiDataCiteRegisterService.modifyIdentifier(identifier, metadata, dvObject);\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"modifyMetadata failed\", e);\n+      throw e;\n     }\n-    \n+    return identifier;\n+  }\n \n-    /**\n-     * Looks up the metadata for a Global Identifier\n-     * @param protocol the identifier system, e.g. \"doi\"\n-     * @param authority the namespace that the authority manages in the identifier system\n-     * @param identifier the local identifier part\n-     * @return a Map of metadata. It is empty when the lookup failed, e.g. when\n-     * the identifier does not exist.\n-     */\n-    @Override\n-    public HashMap<String, String> lookupMetadataFromIdentifier(String protocol, String authority, String identifier) {\n-        logger.log(Level.FINE,\"lookupMetadataFromIdentifier\");\n-        String identifierOut = getIdentifierForLookup(protocol, authority, identifier);\n-        HashMap<String, String> metadata = new HashMap<>();\n-        try {\n-            metadata = doiDataCiteRegisterService.getMetadata(identifierOut);\n-        } catch (Exception e) {\n-            logger.log(Level.WARNING, \"None existing so we can use this identifier\");\n-            logger.log(Level.WARNING, \"identifier: {0}\", identifierOut);\n-        }\n-        return metadata;\n+  public void deleteRecordFromCache(Dataset datasetIn) {\n+    logger.log(Level.FINE, \"deleteRecordFromCache\");\n+    String identifier = getIdentifier(datasetIn);\n+    HashMap doiMetadata = new HashMap();\n+    try {\n+      doiMetadata = doiDataCiteRegisterService.getMetadata(identifier);\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"get matadata failed cannot delete\");\n+      logger.log(Level.WARNING, \"String {0}\", e.toString());\n+      logger.log(Level.WARNING, \"localized message {0}\", e.getLocalizedMessage());\n+      logger.log(Level.WARNING, \"cause\", e.getCause());\n+      logger.log(Level.WARNING, \"message {0}\", e.getMessage());\n     }\n \n+    String idStatus = (String) doiMetadata.get(\"_status\");\n \n-    /**\n-     * Modifies the DOI metadata for a Dataset\n-     * @param dvObject the dvObject whose metadata needs to be modified\n-     * @return the Dataset identifier, or null if the modification failed\n-     * @throws java.lang.Exception\n-     */\n-    @Override\n-    public String modifyIdentifierTargetURL(DvObject dvObject) throws Exception {\n-        logger.log(Level.FINE,\"modifyIdentifier\");\n-        String identifier = getIdentifier(dvObject);\n-        try {\n-           HashMap<String, String> metadata = doiDataCiteRegisterService.getMetadata(identifier);\n-            doiDataCiteRegisterService.modifyIdentifier(identifier, metadata, dvObject);\n-        } catch (Exception e) {\n-            logger.log(Level.WARNING, \"modifyMetadata failed\", e);\n-            throw e;\n-        }\n-        return identifier;\n+    if (idStatus == null || idStatus.equals(\"reserved\")) {\n+      logger.log(Level.WARNING, \"Delete status is reserved..\");\n+      try {\n+        doiDataCiteRegisterService.deleteIdentifier(identifier);\n+      } catch (Exception e) {\n+        logger.log(Level.WARNING, \"delete failed\");\n+        logger.log(Level.WARNING, \"String {0}\", e.toString());\n+        logger.log(Level.WARNING, \"localized message {0}\", e.getLocalizedMessage());\n+        logger.log(Level.WARNING, \"cause\", e.getCause());\n+        logger.log(Level.WARNING, \"message {0}\", e.getMessage());\n+        throw new RuntimeException(e);\n+      }\n     }\n-    \n-    public void deleteRecordFromCache(Dataset datasetIn){\n-        logger.log(Level.FINE,\"deleteRecordFromCache\");\n-        String identifier = getIdentifier(datasetIn);\n-        HashMap doiMetadata = new HashMap();\n-        try {\n-            doiMetadata = doiDataCiteRegisterService.getMetadata(identifier);\n-        } catch (Exception e) {\n-            logger.log(Level.WARNING, \"get matadata failed cannot delete\");\n-            logger.log(Level.WARNING, \"String {0}\", e.toString());\n-            logger.log(Level.WARNING, \"localized message {0}\", e.getLocalizedMessage());\n-            logger.log(Level.WARNING, \"cause\", e.getCause());\n-            logger.log(Level.WARNING, \"message {0}\", e.getMessage());\n-        }\n+  }\n \n-        String idStatus = (String) doiMetadata.get(\"_status\");\n+  /*\n+   * Deletes a DOI if it is in DRAFT/RESERVED state or removes metadata and changes it from PUBLIC/FINDABLE to REGISTERED.\n+   */\n+  @Override\n+  public void deleteIdentifier(DvObject dvObject) throws IOException, HttpException {\n+    logger.log(Level.FINE, \"deleteIdentifier\");\n+    String identifier = getIdentifier(dvObject);\n+    //ToDo - PidUtils currently has a DataCite API call that would get the status at DataCite for this identifier - that could be more accurate than assuming based on whether the dvObject has been published\n+    String idStatus = DRAFT;\n+    if (dvObject.isReleased()) {\n+      idStatus = PUBLIC;\n+    }\n+    if (idStatus != null) {\n+      switch (idStatus) {\n+        case RESERVED:\n+        case DRAFT:\n+          logger.log(Level.INFO, \"Delete status is reserved..\");\n+          //service only removes the identifier from the cache (since it was written before DOIs could be registered in draft state)\n+          doiDataCiteRegisterService.deleteIdentifier(identifier);\n+          //So we call the deleteDraftIdentifier method below until things are refactored\n+          deleteDraftIdentifier(dvObject);\n+          break;\n \n-        if (idStatus == null || idStatus.equals(\"reserved\")) {\n-            logger.log(Level.WARNING, \"Delete status is reserved..\");\n-            try {\n-                doiDataCiteRegisterService.deleteIdentifier(identifier);\n-            } catch (Exception e) {\n-                logger.log(Level.WARNING, \"delete failed\");\n-                logger.log(Level.WARNING, \"String {0}\", e.toString());\n-                logger.log(Level.WARNING, \"localized message {0}\",  e.getLocalizedMessage());\n-                logger.log(Level.WARNING, \"cause\", e.getCause());\n-                logger.log(Level.WARNING, \"message {0}\", e.getMessage());\n-                throw new RuntimeException(e);\n-            }\n-        }\n+        case PUBLIC:\n+        case FINDABLE:\n+          //if public then it has been released set to unavailable and reset target to n2t url\n+          Map<String, String> metadata = addDOIMetadataForDestroyedDataset(dvObject);\n+          metadata.put(\"_status\", \"registered\");\n+          metadata.put(\"_target\", getTargetUrl(dvObject));\n+          doiDataCiteRegisterService.deactivateIdentifier(identifier, metadata, dvObject);\n+          break;\n+      }\n     }\n+  }\n \n-    /*\n-     * Deletes a DOI if it is in DRAFT/RESERVED state or removes metadata and changes it from PUBLIC/FINDABLE to REGISTERED.\n-     */\n-    @Override\n-    public void deleteIdentifier(DvObject dvObject) throws IOException, HttpException {\n-        logger.log(Level.FINE,\"deleteIdentifier\");\n-        String identifier = getIdentifier(dvObject);\n-        //ToDo - PidUtils currently has a DataCite API call that would get the status at DataCite for this identifier - that could be more accurate than assuming based on whether the dvObject has been published\n-        String idStatus = DRAFT;\n-        if(dvObject.isReleased()) {\n-        \tidStatus = PUBLIC;\n-        } \n-        if ( idStatus != null ) {\n-            switch ( idStatus ) {\n-                case RESERVED:\n-                case DRAFT:    \n-                    logger.log(Level.INFO, \"Delete status is reserved..\");\n-                  \t//service only removes the identifier from the cache (since it was written before DOIs could be registered in draft state)\n-                    doiDataCiteRegisterService.deleteIdentifier(identifier);\n-                    //So we call the deleteDraftIdentifier method below until things are refactored\n-                    deleteDraftIdentifier(dvObject);\n-                    break;\n+  /**\n+   * Deletes DOI from the DataCite side, if possible. Only \"draft\" DOIs can be\n+   * deleted.\n+   */\n+  private void deleteDraftIdentifier(DvObject dvObject) throws IOException {\n \n-                case PUBLIC:\n-                case FINDABLE:\n-                    //if public then it has been released set to unavailable and reset target to n2t url\n-                    Map<String, String> metadata = addDOIMetadataForDestroyedDataset(dvObject);\n-                    metadata.put(\"_status\", \"registered\");\n-                    metadata.put(\"_target\", getTargetUrl(dvObject));                   \n-                    doiDataCiteRegisterService.deactivateIdentifier(identifier, metadata, dvObject);\n-                    break;\n-            }\n-        }\n-    }\n-        \n+    //ToDo - incorporate into DataCiteRESTfulClient\n+    String baseUrl = systemConfig.getDataCiteRestApiUrlString();\n+    String username = System.getProperty(\"doi.username\");\n+    String password = System.getProperty(\"doi.password\");\n+    GlobalId doi = dvObject.getGlobalId();\n     /**\n-     * Deletes DOI from the DataCite side, if possible. Only \"draft\" DOIs can be\n-     * deleted.\n+     * Deletes the DOI from DataCite if it can. Returns 204 if PID was deleted\n+     * (only possible for \"draft\" DOIs), 405 (method not allowed) if the DOI\n+     * wasn't deleted (because it's in \"findable\" state, for example, 404 if the\n+     * DOI wasn't found, and possibly other status codes such as 500 if DataCite\n+     * is down.\n      */\n-    private void deleteDraftIdentifier(DvObject dvObject) throws IOException {\n-    \t\n-    \t//ToDo - incorporate into DataCiteRESTfulClient\n-        String baseUrl = systemConfig.getDataCiteRestApiUrlString();\n-        String username = System.getProperty(\"doi.username\");\n-        String password = System.getProperty(\"doi.password\");\n-        GlobalId doi = dvObject.getGlobalId();\n-        /**\n-         * Deletes the DOI from DataCite if it can. Returns 204 if PID was deleted\n-         * (only possible for \"draft\" DOIs), 405 (method not allowed) if the DOI\n-         * wasn't deleted (because it's in \"findable\" state, for example, 404 if the\n-         * DOI wasn't found, and possibly other status codes such as 500 if DataCite\n-         * is down.\n-         */\n \n-            URL url = new URL(baseUrl + \"/dois/\" + doi.getAuthority() + \"/\" + doi.getIdentifier());\n-            HttpURLConnection connection = null;\n-            connection = (HttpURLConnection) url.openConnection();\n-            connection.setRequestMethod(\"DELETE\");\n-            String userpass = username + \":\" + password;\n-            String basicAuth = \"Basic \" + new String(Base64.getEncoder().encode(userpass.getBytes()));\n-            connection.setRequestProperty(\"Authorization\", basicAuth);\n-            int status = connection.getResponseCode();\n-            if(status!=HttpStatus.SC_NO_CONTENT) {\n-            \tlogger.warning(\"Incorrect Response Status from DataCite: \" + status + \" : \" + connection.getResponseMessage());\n-            \tthrow new HttpException(\"Status: \" + status);\n-            }\n-            logger.fine(\"deleteDoi status for \" + doi.asString() + \": \" + status);\n+    URL url = new URL(baseUrl + \"/dois/\" + doi.getAuthority() + \"/\" + doi.getIdentifier());\n+    HttpURLConnection connection = null;\n+    connection = (HttpURLConnection) url.openConnection();\n+    connection.setRequestMethod(\"DELETE\");\n+    String userpass = username + \":\" + password;\n+    String basicAuth = \"Basic \" + new String(Base64.getEncoder().encode(userpass.getBytes()));\n+    connection.setRequestProperty(\"Authorization\", basicAuth);\n+    int status = connection.getResponseCode();\n+    if (status != HttpStatus.SC_NO_CONTENT) {\n+      logger.warning(\"Incorrect Response Status from DataCite: \" + status + \" : \" + connection.getResponseMessage());\n+      throw new HttpException(\"Status: \" + status);\n     }\n+    logger.fine(\"deleteDoi status for \" + doi.asString() + \": \" + status);\n+  }\n \n-    @Override\n-    public boolean publicizeIdentifier(DvObject dvObject) {\n-        logger.log(Level.FINE,\"updateIdentifierStatus\");\n-        if(dvObject.getIdentifier() == null || dvObject.getIdentifier().isEmpty() ){\n-            dvObject = generateIdentifier(dvObject);\n-        }\n-        String identifier = getIdentifier(dvObject);\n-        Map<String, String> metadata = getUpdateMetadata(dvObject);\n-        metadata.put(\"_status\", PUBLIC);\n-        metadata.put(\"datacite.publicationyear\", generateYear(dvObject));\n-        metadata.put(\"_target\", getTargetUrl(dvObject));\n-        try {\n-            doiDataCiteRegisterService.registerIdentifier(identifier, metadata, dvObject);\n-            return true;\n-        } catch (Exception e) {\n-            logger.log(Level.WARNING, \"modifyMetadata failed: \" + e.getMessage(), e);\n-            return false;\n-        }\n+  @Override\n+  public boolean publicizeIdentifier(DvObject dvObject) {\n+    logger.log(Level.FINE, \"updateIdentifierStatus\");\n+    if (dvObject.getIdentifier() == null || dvObject.getIdentifier().isEmpty()) {\n+      dvObject = generateIdentifier(dvObject);\n     }\n-\n-    \n-    @Override\n-    public List<String> getProviderInformation(){\n-        ArrayList <String> providerInfo = new ArrayList<>();\n-        String providerName = \"DataCite\";\n-        String providerLink = \"http://status.datacite.org\";\n-        providerInfo.add(providerName);\n-        providerInfo.add(providerLink);\n-        return providerInfo;\n+    String identifier = getIdentifier(dvObject);\n+    Map<String, String> metadata = getUpdateMetadata(dvObject);\n+    metadata.put(\"_status\", PUBLIC);\n+    metadata.put(\"datacite.publicationyear\", generateYear(dvObject));\n+    metadata.put(\"_target\", getTargetUrl(dvObject));\n+    try {\n+      doiDataCiteRegisterService.registerIdentifier(identifier, metadata, dvObject);\n+      return true;\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"modifyMetadata failed: \" + e.getMessage(), e);\n+      return false;\n     }\n+  }\n+\n+\n+  @Override\n+  public List<String> getProviderInformation() {\n+    ArrayList<String> providerInfo = new ArrayList<>();\n+    String providerName = \"DataCite\";\n+    String providerLink = \"http://status.datacite.org\";\n+    providerInfo.add(providerName);\n+    providerInfo.add(providerLink);\n+    return providerInfo;\n+  }\n \n \n }\n",
            "diff_size": 323
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/25/DOIDataCiteServiceBean.java\nindex e7dd49a6926..65b51a29815 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/25/DOIDataCiteServiceBean.java\n@@ -12,7 +12,6 @@ import java.util.logging.Level;\n import java.util.logging.Logger;\n import javax.ejb.EJB;\n import javax.ejb.Stateless;\n-\n import org.apache.commons.httpclient.HttpException;\n import org.apache.commons.httpclient.HttpStatus;\n \n@@ -21,11 +20,12 @@ import org.apache.commons.httpclient.HttpStatus;\n  *\n  * @author luopc\n  */\n+\n+\n @Stateless\n public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n \n     private static final Logger logger = Logger.getLogger(DOIDataCiteServiceBean.class.getCanonicalName());\n-    \n     private static final String PUBLIC = \"public\";\n     private static final String FINDABLE = \"findable\";\n     private static final String RESERVED = \"reserved\";\n@@ -34,8 +34,7 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n     @EJB\n     DOIDataCiteRegisterService doiDataCiteRegisterService;\n \n-    public DOIDataCiteServiceBean() {\n-    }\n+    public DOIDataCiteServiceBean() {}\n \n     @Override\n     public boolean registerWhenPublished() {\n@@ -44,7 +43,7 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n \n     @Override\n     public boolean alreadyExists(DvObject dvObject) {\n-        if(dvObject==null) {\n+        if (dvObject == null) {\n             logger.severe(\"Null DvObject sent to alreadyExists().\");\n             return false;\n         }\n@@ -53,29 +52,30 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n \n     @Override\n     public boolean alreadyExists(GlobalId pid) {\n-        logger.log(Level.FINE,\"alreadyExists\");\n-        if(pid==null || pid.asString().isEmpty()) {\n+        logger.log(Level.FINE, \"alreadyExists\");\n+        if (pid == null || pid.asString().isEmpty()) {\n             logger.fine(\"No identifier sent.\");\n             return false;\n         }\n+\n         boolean alreadyExists;\n         String identifier = pid.asString();\n-        try{\n-            alreadyExists = doiDataCiteRegisterService.testDOIExists(identifier); \n-        } catch (Exception e){\n+        try {\n+            alreadyExists = doiDataCiteRegisterService.testDOIExists(identifier);\n+        } catch (Exception e) {\n             logger.log(Level.WARNING, \"alreadyExists failed\");\n             return false;\n         }\n-        return  alreadyExists;\n+        return alreadyExists;\n     }\n-    \n \n     @Override\n     public String createIdentifier(DvObject dvObject) throws Exception {\n-        logger.log(Level.FINE,\"createIdentifier\");\n-        if(dvObject.getIdentifier() == null || dvObject.getIdentifier().isEmpty() ){\n+        logger.log(Level.FINE, \"createIdentifier\");\n+        if (dvObject.getIdentifier() == null || dvObject.getIdentifier().isEmpty()) {\n             dvObject = generateIdentifier(dvObject);\n         }\n+\n         String identifier = getIdentifier(dvObject);\n         Map<String, String> metadata = getMetadataForCreateIndicator(dvObject);\n         metadata.put(\"_status\", \"reserved\");\n@@ -91,7 +91,7 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n \n     @Override\n     public HashMap getIdentifierMetadata(DvObject dvObject) {\n-        logger.log(Level.FINE,\"getIdentifierMetadata\");\n+        logger.log(Level.FINE, \"getIdentifierMetadata\");\n         String identifier = getIdentifier(dvObject);\n         HashMap<String, String> metadata = new HashMap<>();\n         try {\n@@ -111,9 +111,10 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n      * @return a Map of metadata. It is empty when the lookup failed, e.g. when\n      * the identifier does not exist.\n      */\n+\n     @Override\n     public HashMap<String, String> lookupMetadataFromIdentifier(String protocol, String authority, String identifier) {\n-        logger.log(Level.FINE,\"lookupMetadataFromIdentifier\");\n+        logger.log(Level.FINE, \"lookupMetadataFromIdentifier\");\n         String identifierOut = getIdentifierForLookup(protocol, authority, identifier);\n         HashMap<String, String> metadata = new HashMap<>();\n         try {\n@@ -132,12 +133,13 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n      * @return the Dataset identifier, or null if the modification failed\n      * @throws java.lang.Exception\n      */\n+\n     @Override\n     public String modifyIdentifierTargetURL(DvObject dvObject) throws Exception {\n-        logger.log(Level.FINE,\"modifyIdentifier\");\n+        logger.log(Level.FINE, \"modifyIdentifier\");\n         String identifier = getIdentifier(dvObject);\n         try {\n-           HashMap<String, String> metadata = doiDataCiteRegisterService.getMetadata(identifier);\n+            HashMap<String, String> metadata = doiDataCiteRegisterService.getMetadata(identifier);\n             doiDataCiteRegisterService.modifyIdentifier(identifier, metadata, dvObject);\n         } catch (Exception e) {\n             logger.log(Level.WARNING, \"modifyMetadata failed\", e);\n@@ -145,9 +147,9 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n         }\n         return identifier;\n     }\n-    \n-    public void deleteRecordFromCache(Dataset datasetIn){\n-        logger.log(Level.FINE,\"deleteRecordFromCache\");\n+\n+    public void deleteRecordFromCache(Dataset datasetIn) {\n+        logger.log(Level.FINE, \"deleteRecordFromCache\");\n         String identifier = getIdentifier(datasetIn);\n         HashMap doiMetadata = new HashMap();\n         try {\n@@ -161,7 +163,6 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n         }\n \n         String idStatus = (String) doiMetadata.get(\"_status\");\n-\n         if (idStatus == null || idStatus.equals(\"reserved\")) {\n             logger.log(Level.WARNING, \"Delete status is reserved..\");\n             try {\n@@ -169,7 +170,7 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n             } catch (Exception e) {\n                 logger.log(Level.WARNING, \"delete failed\");\n                 logger.log(Level.WARNING, \"String {0}\", e.toString());\n-                logger.log(Level.WARNING, \"localized message {0}\",  e.getLocalizedMessage());\n+                logger.log(Level.WARNING, \"localized message {0}\", e.getLocalizedMessage());\n                 logger.log(Level.WARNING, \"cause\", e.getCause());\n                 logger.log(Level.WARNING, \"message {0}\", e.getMessage());\n                 throw new RuntimeException(e);\n@@ -180,32 +181,33 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n     /*\n      * Deletes a DOI if it is in DRAFT/RESERVED state or removes metadata and changes it from PUBLIC/FINDABLE to REGISTERED.\n      */\n+\n     @Override\n     public void deleteIdentifier(DvObject dvObject) throws IOException, HttpException {\n-        logger.log(Level.FINE,\"deleteIdentifier\");\n+        logger.log(Level.FINE, \"deleteIdentifier\");\n         String identifier = getIdentifier(dvObject);\n         //ToDo - PidUtils currently has a DataCite API call that would get the status at DataCite for this identifier - that could be more accurate than assuming based on whether the dvObject has been published\n         String idStatus = DRAFT;\n-        if(dvObject.isReleased()) {\n-        \tidStatus = PUBLIC;\n-        } \n-        if ( idStatus != null ) {\n-            switch ( idStatus ) {\n+        if (dvObject.isReleased()) {\n+            idStatus = PUBLIC;\n+        }\n+\n+        if (idStatus != null) {\n+            switch (idStatus) {\n                 case RESERVED:\n-                case DRAFT:    \n+                case DRAFT:\n                     logger.log(Level.INFO, \"Delete status is reserved..\");\n-                  \t//service only removes the identifier from the cache (since it was written before DOIs could be registered in draft state)\n+                    //service only removes the identifier from the cache (since it was written before DOIs could be registered in draft state)\n                     doiDataCiteRegisterService.deleteIdentifier(identifier);\n                     //So we call the deleteDraftIdentifier method below until things are refactored\n                     deleteDraftIdentifier(dvObject);\n                     break;\n-\n                 case PUBLIC:\n                 case FINDABLE:\n                     //if public then it has been released set to unavailable and reset target to n2t url\n                     Map<String, String> metadata = addDOIMetadataForDestroyedDataset(dvObject);\n                     metadata.put(\"_status\", \"registered\");\n-                    metadata.put(\"_target\", getTargetUrl(dvObject));                   \n+                    metadata.put(\"_target\", getTargetUrl(dvObject));\n                     doiDataCiteRegisterService.deactivateIdentifier(identifier, metadata, dvObject);\n                     break;\n             }\n@@ -216,9 +218,10 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n      * Deletes DOI from the DataCite side, if possible. Only \"draft\" DOIs can be\n      * deleted.\n      */\n+\n     private void deleteDraftIdentifier(DvObject dvObject) throws IOException {\n-    \t\n-    \t//ToDo - incorporate into DataCiteRESTfulClient\n+        \n+        //ToDo - incorporate into DataCiteRESTfulClient\n         String baseUrl = systemConfig.getDataCiteRestApiUrlString();\n         String username = System.getProperty(\"doi.username\");\n         String password = System.getProperty(\"doi.password\");\n@@ -230,28 +233,29 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n          * DOI wasn't found, and possibly other status codes such as 500 if DataCite\n          * is down.\n          */\n+        URL url = new URL(baseUrl + \"/dois/\" + doi.getAuthority() + \"/\" + doi.getIdentifier());\n+        HttpURLConnection connection = null;\n+        connection = (HttpURLConnection) url.openConnection();\n+        connection.setRequestMethod(\"DELETE\");\n+        String userpass = username + \":\" + password;\n+        String basicAuth = \"Basic \" + new String(Base64.getEncoder().encode(userpass.getBytes()));\n+        connection.setRequestProperty(\"Authorization\", basicAuth);\n \n-            URL url = new URL(baseUrl + \"/dois/\" + doi.getAuthority() + \"/\" + doi.getIdentifier());\n-            HttpURLConnection connection = null;\n-            connection = (HttpURLConnection) url.openConnection();\n-            connection.setRequestMethod(\"DELETE\");\n-            String userpass = username + \":\" + password;\n-            String basicAuth = \"Basic \" + new String(Base64.getEncoder().encode(userpass.getBytes()));\n-            connection.setRequestProperty(\"Authorization\", basicAuth);\n-            int status = connection.getResponseCode();\n-            if(status!=HttpStatus.SC_NO_CONTENT) {\n-            \tlogger.warning(\"Incorrect Response Status from DataCite: \" + status + \" : \" + connection.getResponseMessage());\n-            \tthrow new HttpException(\"Status: \" + status);\n-            }\n-            logger.fine(\"deleteDoi status for \" + doi.asString() + \": \" + status);\n+        int status = connection.getResponseCode();\n+        if (status != HttpStatus.SC_NO_CONTENT) {\n+            logger.warning(\"Incorrect Response Status from DataCite: \" + status + \" : \" + connection.getResponseMessage());\n+            throw new HttpException(\"Status: \" + status);\n+        }\n+        logger.fine(\"deleteDoi status for \" + doi.asString() + \": \" + status);\n     }\n \n     @Override\n     public boolean publicizeIdentifier(DvObject dvObject) {\n-        logger.log(Level.FINE,\"updateIdentifierStatus\");\n-        if(dvObject.getIdentifier() == null || dvObject.getIdentifier().isEmpty() ){\n+        logger.log(Level.FINE, \"updateIdentifierStatus\");\n+        if (dvObject.getIdentifier() == null || dvObject.getIdentifier().isEmpty()) {\n             dvObject = generateIdentifier(dvObject);\n         }\n+\n         String identifier = getIdentifier(dvObject);\n         Map<String, String> metadata = getUpdateMetadata(dvObject);\n         metadata.put(\"_status\", PUBLIC);\n@@ -266,10 +270,9 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n         }\n     }\n \n-    \n     @Override\n-    public List<String> getProviderInformation(){\n-        ArrayList <String> providerInfo = new ArrayList<>();\n+    public List<String> getProviderInformation() {\n+        ArrayList<String> providerInfo = new ArrayList<>();\n         String providerName = \"DataCite\";\n         String providerLink = \"http://status.datacite.org\";\n         providerInfo.add(providerName);\n@@ -277,5 +280,4 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n         return providerInfo;\n     }\n \n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 72
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "197",
                    "column": "19",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/25/DOIDataCiteServiceBean.java\nindex e7dd49a6926..ec9399d42b2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/25/DOIDataCiteServiceBean.java\n@@ -187,7 +187,7 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n         //ToDo - PidUtils currently has a DataCite API call that would get the status at DataCite for this identifier - that could be more accurate than assuming based on whether the dvObject has been published\n         String idStatus = DRAFT;\n         if(dvObject.isReleased()) {\n-        \tidStatus = PUBLIC;\n+        idStatus = PUBLIC;\n         } \n         if ( idStatus != null ) {\n             switch ( idStatus ) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "197",
                    "column": "19",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/25/DOIDataCiteServiceBean.java\nindex e7dd49a6926..6da8cd90e8f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/25/DOIDataCiteServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/25/DOIDataCiteServiceBean.java\n@@ -187,7 +187,7 @@ public class DOIDataCiteServiceBean extends AbstractGlobalIdServiceBean {\n         //ToDo - PidUtils currently has a DataCite API call that would get the status at DataCite for this identifier - that could be more accurate than assuming based on whether the dvObject has been published\n         String idStatus = DRAFT;\n         if(dvObject.isReleased()) {\n-        \tidStatus = PUBLIC;\n+            idStatus = PUBLIC;\n         } \n         if ( idStatus != null ) {\n             switch ( idStatus ) {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}