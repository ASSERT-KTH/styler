{
    "project_name": "codefollower-H2-Research",
    "error_id": "164",
    "information": {
        "errors": [
            {
                "line": "436",
                "column": "31",
                "severity": "warning",
                "message": "'typecast' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "            if (JdbcUtils.customDataTypesHandler != null) {\n                byte[] b = v.getBytesNoCopy();\n                buff.put((byte)CUSTOM_DATA_TYPE).\n                    putVarInt(type).\n                    putVarInt(b.length).\n                    put(b);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/164/ValueDataType.java\nindex df6bed6bb2d..ab4a88be496 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/164/ValueDataType.java\n@@ -433,7 +433,7 @@ public class ValueDataType implements DataType {\n         default:\n             if (JdbcUtils.customDataTypesHandler != null) {\n                 byte[] b = v.getBytesNoCopy();\n-                buff.put((byte)CUSTOM_DATA_TYPE).\n+                buff.put((byte) CUSTOM_DATA_TYPE).\n                     putVarInt(type).\n                     putVarInt(b.length).\n                     put(b);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/164/ValueDataType.java\nindex df6bed6bb2d..5e79b7d2181 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/164/ValueDataType.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.mvstore.db;\n \n import java.math.BigDecimal;\n@@ -12,6 +13,7 @@ import java.sql.ResultSet;\n import java.sql.ResultSetMetaData;\n import java.sql.SQLException;\n import java.util.Arrays;\n+\n import org.h2.api.ErrorCode;\n import org.h2.message.DbException;\n import org.h2.mvstore.DataUtils;\n@@ -55,614 +57,614 @@ import org.h2.value.ValueUuid;\n  */\n public class ValueDataType implements DataType {\n \n-    private static final int INT_0_15 = 32;\n-    private static final int LONG_0_7 = 48;\n-    private static final int DECIMAL_0_1 = 56;\n-    private static final int DECIMAL_SMALL_0 = 58;\n-    private static final int DECIMAL_SMALL = 59;\n-    private static final int DOUBLE_0_1 = 60;\n-    private static final int FLOAT_0_1 = 62;\n-    private static final int BOOLEAN_FALSE = 64;\n-    private static final int BOOLEAN_TRUE = 65;\n-    private static final int INT_NEG = 66;\n-    private static final int LONG_NEG = 67;\n-    private static final int STRING_0_31 = 68;\n-    private static final int BYTES_0_31 = 100;\n-    private static final int SPATIAL_KEY_2D = 132;\n-    private static final int CUSTOM_DATA_TYPE = 133;\n+  private static final int INT_0_15 = 32;\n+  private static final int LONG_0_7 = 48;\n+  private static final int DECIMAL_0_1 = 56;\n+  private static final int DECIMAL_SMALL_0 = 58;\n+  private static final int DECIMAL_SMALL = 59;\n+  private static final int DOUBLE_0_1 = 60;\n+  private static final int FLOAT_0_1 = 62;\n+  private static final int BOOLEAN_FALSE = 64;\n+  private static final int BOOLEAN_TRUE = 65;\n+  private static final int INT_NEG = 66;\n+  private static final int LONG_NEG = 67;\n+  private static final int STRING_0_31 = 68;\n+  private static final int BYTES_0_31 = 100;\n+  private static final int SPATIAL_KEY_2D = 132;\n+  private static final int CUSTOM_DATA_TYPE = 133;\n \n-    final DataHandler handler;\n-    final CompareMode compareMode;\n-    final int[] sortTypes;\n-    SpatialDataType spatialType;\n+  final DataHandler handler;\n+  final CompareMode compareMode;\n+  final int[] sortTypes;\n+  SpatialDataType spatialType;\n \n-    public ValueDataType(CompareMode compareMode, DataHandler handler,\n-            int[] sortTypes) {\n-        this.compareMode = compareMode;\n-        this.handler = handler;\n-        this.sortTypes = sortTypes;\n-    }\n+  public ValueDataType(CompareMode compareMode, DataHandler handler,\n+                       int[] sortTypes) {\n+    this.compareMode = compareMode;\n+    this.handler = handler;\n+    this.sortTypes = sortTypes;\n+  }\n \n-    private SpatialDataType getSpatialDataType() {\n-        if (spatialType == null) {\n-            spatialType = new SpatialDataType(2);\n-        }\n-        return spatialType;\n+  private SpatialDataType getSpatialDataType() {\n+    if (spatialType == null) {\n+      spatialType = new SpatialDataType(2);\n     }\n+    return spatialType;\n+  }\n \n-    @Override\n-    public int compare(Object a, Object b) {\n-        if (a == b) {\n-            return 0;\n-        }\n-        if (a instanceof ValueArray && b instanceof ValueArray) {\n-            Value[] ax = ((ValueArray) a).getList();\n-            Value[] bx = ((ValueArray) b).getList();\n-            int al = ax.length;\n-            int bl = bx.length;\n-            int len = Math.min(al, bl);\n-            for (int i = 0; i < len; i++) {\n-                int sortType = sortTypes == null ? SortOrder.ASCENDING : sortTypes[i];\n-                int comp = compareValues(ax[i], bx[i], sortType);\n-                if (comp != 0) {\n-                    return comp;\n-                }\n-            }\n-            if (len < al) {\n-                return -1;\n-            } else if (len < bl) {\n-                return 1;\n-            }\n-            return 0;\n-        }\n-        return compareValues((Value) a, (Value) b, SortOrder.ASCENDING);\n+  @Override\n+  public int compare(Object a, Object b) {\n+    if (a == b) {\n+      return 0;\n     }\n-\n-    private int compareValues(Value a, Value b, int sortType) {\n-        if (a == b) {\n-            return 0;\n-        }\n-        // null is never stored;\n-        // comparison with null is used to retrieve all entries\n-        // in which case null is always lower than all entries\n-        // (even for descending ordered indexes)\n-        if (a == null) {\n-            return -1;\n-        } else if (b == null) {\n-            return 1;\n-        }\n-        boolean aNull = a == ValueNull.INSTANCE;\n-        boolean bNull = b == ValueNull.INSTANCE;\n-        if (aNull || bNull) {\n-            return SortOrder.compareNull(aNull, sortType);\n-        }\n-        int comp = a.compareTypeSafe(b, compareMode);\n-        if ((sortType & SortOrder.DESCENDING) != 0) {\n-            comp = -comp;\n-        }\n-        return comp;\n+    if (a instanceof ValueArray && b instanceof ValueArray) {\n+      Value[] ax = ((ValueArray) a).getList();\n+      Value[] bx = ((ValueArray) b).getList();\n+      int al = ax.length;\n+      int bl = bx.length;\n+      int len = Math.min(al, bl);\n+      for (int i = 0; i < len; i++) {\n+        int sortType = sortTypes == null ? SortOrder.ASCENDING : sortTypes[i];\n+        int comp = compareValues(ax[i], bx[i], sortType);\n+        if (comp != 0) {\n+          return comp;\n+        }\n+      }\n+      if (len < al) {\n+        return -1;\n+      } else if (len < bl) {\n+        return 1;\n+      }\n+      return 0;\n     }\n+    return compareValues((Value) a, (Value) b, SortOrder.ASCENDING);\n+  }\n \n-    @Override\n-    public int getMemory(Object obj) {\n-        if (obj instanceof SpatialKey) {\n-            return getSpatialDataType().getMemory(obj);\n-        }\n-        return getMemory((Value) obj);\n+  private int compareValues(Value a, Value b, int sortType) {\n+    if (a == b) {\n+      return 0;\n     }\n-\n-    private static int getMemory(Value v) {\n-        return v == null ? 0 : v.getMemory();\n+    // null is never stored;\n+    // comparison with null is used to retrieve all entries\n+    // in which case null is always lower than all entries\n+    // (even for descending ordered indexes)\n+    if (a == null) {\n+      return -1;\n+    } else if (b == null) {\n+      return 1;\n+    }\n+    boolean aNull = a == ValueNull.INSTANCE;\n+    boolean bNull = b == ValueNull.INSTANCE;\n+    if (aNull || bNull) {\n+      return SortOrder.compareNull(aNull, sortType);\n+    }\n+    int comp = a.compareTypeSafe(b, compareMode);\n+    if ((sortType & SortOrder.DESCENDING) != 0) {\n+      comp = -comp;\n     }\n+    return comp;\n+  }\n \n-    @Override\n-    public void read(ByteBuffer buff, Object[] obj, int len, boolean key) {\n-        for (int i = 0; i < len; i++) {\n-            obj[i] = read(buff);\n-        }\n+  @Override\n+  public int getMemory(Object obj) {\n+    if (obj instanceof SpatialKey) {\n+      return getSpatialDataType().getMemory(obj);\n     }\n+    return getMemory((Value) obj);\n+  }\n \n-    @Override\n-    public void write(WriteBuffer buff, Object[] obj, int len, boolean key) {\n-        for (int i = 0; i < len; i++) {\n-            write(buff, obj[i]);\n-        }\n+  private static int getMemory(Value v) {\n+    return v == null ? 0 : v.getMemory();\n+  }\n+\n+  @Override\n+  public void read(ByteBuffer buff, Object[] obj, int len, boolean key) {\n+    for (int i = 0; i < len; i++) {\n+      obj[i] = read(buff);\n     }\n+  }\n \n-    @Override\n-    public Object read(ByteBuffer buff) {\n-        return readValue(buff);\n+  @Override\n+  public void write(WriteBuffer buff, Object[] obj, int len, boolean key) {\n+    for (int i = 0; i < len; i++) {\n+      write(buff, obj[i]);\n     }\n+  }\n \n-    @Override\n-    public void write(WriteBuffer buff, Object obj) {\n-        if (obj instanceof SpatialKey) {\n-            buff.put((byte) SPATIAL_KEY_2D);\n-            getSpatialDataType().write(buff, obj);\n-            return;\n-        }\n-        Value x = (Value) obj;\n-        writeValue(buff, x);\n+  @Override\n+  public Object read(ByteBuffer buff) {\n+    return readValue(buff);\n+  }\n+\n+  @Override\n+  public void write(WriteBuffer buff, Object obj) {\n+    if (obj instanceof SpatialKey) {\n+      buff.put((byte) SPATIAL_KEY_2D);\n+      getSpatialDataType().write(buff, obj);\n+      return;\n     }\n+    Value x = (Value) obj;\n+    writeValue(buff, x);\n+  }\n \n-    private void writeValue(WriteBuffer buff, Value v) {\n-        if (v == ValueNull.INSTANCE) {\n-            buff.put((byte) 0);\n-            return;\n-        }\n-        int type = v.getType();\n-        switch (type) {\n-        case Value.BOOLEAN:\n-            buff.put((byte) (v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE));\n-            break;\n-        case Value.BYTE:\n-            buff.put((byte) type).put(v.getByte());\n-            break;\n-        case Value.SHORT:\n-            buff.put((byte) type).putShort(v.getShort());\n-            break;\n-        case Value.ENUM:\n-        case Value.INT: {\n-            int x = v.getInt();\n-            if (x < 0) {\n-                buff.put((byte) INT_NEG).putVarInt(-x);\n-            } else if (x < 16) {\n-                buff.put((byte) (INT_0_15 + x));\n-            } else {\n-                buff.put((byte) type).putVarInt(x);\n-            }\n-            break;\n-        }\n-        case Value.LONG: {\n-            long x = v.getLong();\n-            if (x < 0) {\n-                buff.put((byte) LONG_NEG).putVarLong(-x);\n-            } else if (x < 8) {\n-                buff.put((byte) (LONG_0_7 + x));\n-            } else {\n-                buff.put((byte) type).putVarLong(x);\n-            }\n-            break;\n-        }\n-        case Value.DECIMAL: {\n-            BigDecimal x = v.getBigDecimal();\n-            if (BigDecimal.ZERO.equals(x)) {\n-                buff.put((byte) DECIMAL_0_1);\n-            } else if (BigDecimal.ONE.equals(x)) {\n-                buff.put((byte) (DECIMAL_0_1 + 1));\n+  private void writeValue(WriteBuffer buff, Value v) {\n+    if (v == ValueNull.INSTANCE) {\n+      buff.put((byte) 0);\n+      return;\n+    }\n+    int type = v.getType();\n+    switch (type) {\n+      case Value.BOOLEAN:\n+        buff.put((byte) (v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE));\n+        break;\n+      case Value.BYTE:\n+        buff.put((byte) type).put(v.getByte());\n+        break;\n+      case Value.SHORT:\n+        buff.put((byte) type).putShort(v.getShort());\n+        break;\n+      case Value.ENUM:\n+      case Value.INT: {\n+        int x = v.getInt();\n+        if (x < 0) {\n+          buff.put((byte) INT_NEG).putVarInt(-x);\n+        } else if (x < 16) {\n+          buff.put((byte) (INT_0_15 + x));\n+        } else {\n+          buff.put((byte) type).putVarInt(x);\n+        }\n+        break;\n+      }\n+      case Value.LONG: {\n+        long x = v.getLong();\n+        if (x < 0) {\n+          buff.put((byte) LONG_NEG).putVarLong(-x);\n+        } else if (x < 8) {\n+          buff.put((byte) (LONG_0_7 + x));\n+        } else {\n+          buff.put((byte) type).putVarLong(x);\n+        }\n+        break;\n+      }\n+      case Value.DECIMAL: {\n+        BigDecimal x = v.getBigDecimal();\n+        if (BigDecimal.ZERO.equals(x)) {\n+          buff.put((byte) DECIMAL_0_1);\n+        } else if (BigDecimal.ONE.equals(x)) {\n+          buff.put((byte) (DECIMAL_0_1 + 1));\n+        } else {\n+          int scale = x.scale();\n+          BigInteger b = x.unscaledValue();\n+          int bits = b.bitLength();\n+          if (bits <= 63) {\n+            if (scale == 0) {\n+              buff.put((byte) DECIMAL_SMALL_0).\n+                  putVarLong(b.longValue());\n             } else {\n-                int scale = x.scale();\n-                BigInteger b = x.unscaledValue();\n-                int bits = b.bitLength();\n-                if (bits <= 63) {\n-                    if (scale == 0) {\n-                        buff.put((byte) DECIMAL_SMALL_0).\n-                            putVarLong(b.longValue());\n-                    } else {\n-                        buff.put((byte) DECIMAL_SMALL).\n-                            putVarInt(scale).\n-                            putVarLong(b.longValue());\n-                    }\n-                } else {\n-                    byte[] bytes = b.toByteArray();\n-                    buff.put((byte) type).\n-                        putVarInt(scale).\n-                        putVarInt(bytes.length).\n-                        put(bytes);\n-                }\n+              buff.put((byte) DECIMAL_SMALL).\n+                  putVarInt(scale).\n+                  putVarLong(b.longValue());\n             }\n-            break;\n-        }\n-        case Value.TIME: {\n-            ValueTime t = (ValueTime) v;\n-            long nanos = t.getNanos();\n-            long millis = nanos / 1000000;\n-            nanos -= millis * 1000000;\n+          } else {\n+            byte[] bytes = b.toByteArray();\n             buff.put((byte) type).\n-                putVarLong(millis).\n-                putVarLong(nanos);\n-            break;\n-        }\n-        case Value.DATE: {\n-            long x = ((ValueDate) v).getDateValue();\n-            buff.put((byte) type).putVarLong(x);\n-            break;\n-        }\n-        case Value.TIMESTAMP: {\n-            ValueTimestamp ts = (ValueTimestamp) v;\n-            long dateValue = ts.getDateValue();\n-            long nanos = ts.getTimeNanos();\n-            long millis = nanos / 1000000;\n-            nanos -= millis * 1000000;\n-            buff.put((byte) type).\n-                putVarLong(dateValue).\n-                putVarLong(millis).\n-                putVarLong(nanos);\n-            break;\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            long dateValue = ts.getDateValue();\n-            long nanos = ts.getTimeNanos();\n-            long millis = nanos / 1000000;\n-            nanos -= millis * 1000000;\n-            buff.put((byte) type).\n-                putVarLong(dateValue).\n-                putVarLong(millis).\n-                putVarLong(nanos).\n-                putVarInt(ts.getTimeZoneOffsetMins());\n-            break;\n-        }\n-        case Value.JAVA_OBJECT: {\n-            byte[] b = v.getBytesNoCopy();\n-            buff.put((byte) type).\n-                putVarInt(b.length).\n-                put(b);\n-            break;\n-        }\n-        case Value.BYTES: {\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            if (len < 32) {\n-                buff.put((byte) (BYTES_0_31 + len)).\n-                    put(b);\n-            } else {\n-                buff.put((byte) type).\n-                    putVarInt(b.length).\n-                    put(b);\n-            }\n-            break;\n-        }\n-        case Value.UUID: {\n-            ValueUuid uuid = (ValueUuid) v;\n+                putVarInt(scale).\n+                putVarInt(bytes.length).\n+                put(bytes);\n+          }\n+        }\n+        break;\n+      }\n+      case Value.TIME: {\n+        ValueTime t = (ValueTime) v;\n+        long nanos = t.getNanos();\n+        long millis = nanos / 1000000;\n+        nanos -= millis * 1000000;\n+        buff.put((byte) type).\n+            putVarLong(millis).\n+            putVarLong(nanos);\n+        break;\n+      }\n+      case Value.DATE: {\n+        long x = ((ValueDate) v).getDateValue();\n+        buff.put((byte) type).putVarLong(x);\n+        break;\n+      }\n+      case Value.TIMESTAMP: {\n+        ValueTimestamp ts = (ValueTimestamp) v;\n+        long dateValue = ts.getDateValue();\n+        long nanos = ts.getTimeNanos();\n+        long millis = nanos / 1000000;\n+        nanos -= millis * 1000000;\n+        buff.put((byte) type).\n+            putVarLong(dateValue).\n+            putVarLong(millis).\n+            putVarLong(nanos);\n+        break;\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+        long dateValue = ts.getDateValue();\n+        long nanos = ts.getTimeNanos();\n+        long millis = nanos / 1000000;\n+        nanos -= millis * 1000000;\n+        buff.put((byte) type).\n+            putVarLong(dateValue).\n+            putVarLong(millis).\n+            putVarLong(nanos).\n+            putVarInt(ts.getTimeZoneOffsetMins());\n+        break;\n+      }\n+      case Value.JAVA_OBJECT: {\n+        byte[] b = v.getBytesNoCopy();\n+        buff.put((byte) type).\n+            putVarInt(b.length).\n+            put(b);\n+        break;\n+      }\n+      case Value.BYTES: {\n+        byte[] b = v.getBytesNoCopy();\n+        int len = b.length;\n+        if (len < 32) {\n+          buff.put((byte) (BYTES_0_31 + len)).\n+              put(b);\n+        } else {\n+          buff.put((byte) type).\n+              putVarInt(b.length).\n+              put(b);\n+        }\n+        break;\n+      }\n+      case Value.UUID: {\n+        ValueUuid uuid = (ValueUuid) v;\n+        buff.put((byte) type).\n+            putLong(uuid.getHigh()).\n+            putLong(uuid.getLow());\n+        break;\n+      }\n+      case Value.STRING: {\n+        String s = v.getString();\n+        int len = s.length();\n+        if (len < 32) {\n+          buff.put((byte) (STRING_0_31 + len)).\n+              putStringData(s, len);\n+        } else {\n+          buff.put((byte) type);\n+          writeString(buff, s);\n+        }\n+        break;\n+      }\n+      case Value.STRING_IGNORECASE:\n+      case Value.STRING_FIXED:\n+        buff.put((byte) type);\n+        writeString(buff, v.getString());\n+        break;\n+      case Value.DOUBLE: {\n+        double x = v.getDouble();\n+        if (x == 1.0d) {\n+          buff.put((byte) (DOUBLE_0_1 + 1));\n+        } else {\n+          long d = Double.doubleToLongBits(x);\n+          if (d == ValueDouble.ZERO_BITS) {\n+            buff.put((byte) DOUBLE_0_1);\n+          } else {\n             buff.put((byte) type).\n-                putLong(uuid.getHigh()).\n-                putLong(uuid.getLow());\n-            break;\n-        }\n-        case Value.STRING: {\n-            String s = v.getString();\n-            int len = s.length();\n-            if (len < 32) {\n-                buff.put((byte) (STRING_0_31 + len)).\n-                    putStringData(s, len);\n-            } else {\n-                buff.put((byte) type);\n-                writeString(buff, s);\n-            }\n-            break;\n-        }\n-        case Value.STRING_IGNORECASE:\n-        case Value.STRING_FIXED:\n-            buff.put((byte) type);\n-            writeString(buff, v.getString());\n-            break;\n-        case Value.DOUBLE: {\n-            double x = v.getDouble();\n-            if (x == 1.0d) {\n-                buff.put((byte) (DOUBLE_0_1 + 1));\n-            } else {\n-                long d = Double.doubleToLongBits(x);\n-                if (d == ValueDouble.ZERO_BITS) {\n-                    buff.put((byte) DOUBLE_0_1);\n-                } else {\n-                    buff.put((byte) type).\n-                        putVarLong(Long.reverse(d));\n-                }\n-            }\n-            break;\n-        }\n-        case Value.FLOAT: {\n-            float x = v.getFloat();\n-            if (x == 1.0f) {\n-                buff.put((byte) (FLOAT_0_1 + 1));\n-            } else {\n-                int f = Float.floatToIntBits(x);\n-                if (f == ValueFloat.ZERO_BITS) {\n-                    buff.put((byte) FLOAT_0_1);\n-                } else {\n-                    buff.put((byte) type).\n-                        putVarInt(Integer.reverse(f));\n-                }\n-            }\n-            break;\n-        }\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            buff.put((byte) type);\n-            ValueLobDb lob = (ValueLobDb) v;\n-            byte[] small = lob.getSmall();\n-            if (small == null) {\n-                buff.putVarInt(-3).\n-                    putVarInt(lob.getTableId()).\n-                    putVarLong(lob.getLobId()).\n-                    putVarLong(lob.getPrecision());\n-            } else {\n-                buff.putVarInt(small.length).\n-                    put(small);\n-            }\n-            break;\n-        }\n-        case Value.ARRAY: {\n-            Value[] list = ((ValueArray) v).getList();\n-            buff.put((byte) type).putVarInt(list.length);\n-            for (Value x : list) {\n-                writeValue(buff, x);\n-            }\n-            break;\n-        }\n-        case Value.RESULT_SET: {\n-            buff.put((byte) type);\n-            try {\n-                ResultSet rs = ((ValueResultSet) v).getResultSet();\n-                rs.beforeFirst();\n-                ResultSetMetaData meta = rs.getMetaData();\n-                int columnCount = meta.getColumnCount();\n-                buff.putVarInt(columnCount);\n-                for (int i = 0; i < columnCount; i++) {\n-                    writeString(buff, meta.getColumnName(i + 1));\n-                    buff.putVarInt(meta.getColumnType(i + 1)).\n-                        putVarInt(meta.getPrecision(i + 1)).\n-                        putVarInt(meta.getScale(i + 1));\n-                }\n-                while (rs.next()) {\n-                    buff.put((byte) 1);\n-                    for (int i = 0; i < columnCount; i++) {\n-                        int t = org.h2.value.DataType.\n-                                getValueTypeFromResultSet(meta, i + 1);\n-                        Value val = org.h2.value.DataType.readValue(\n-                                null, rs, i + 1, t);\n-                        writeValue(buff, val);\n-                    }\n-                }\n-                buff.put((byte) 0);\n-                rs.beforeFirst();\n-            } catch (SQLException e) {\n-                throw DbException.convert(e);\n-            }\n-            break;\n-        }\n-        case Value.GEOMETRY: {\n-            byte[] b = v.getBytes();\n-            int len = b.length;\n+                putVarLong(Long.reverse(d));\n+          }\n+        }\n+        break;\n+      }\n+      case Value.FLOAT: {\n+        float x = v.getFloat();\n+        if (x == 1.0f) {\n+          buff.put((byte) (FLOAT_0_1 + 1));\n+        } else {\n+          int f = Float.floatToIntBits(x);\n+          if (f == ValueFloat.ZERO_BITS) {\n+            buff.put((byte) FLOAT_0_1);\n+          } else {\n             buff.put((byte) type).\n-                putVarInt(len).\n-                put(b);\n-            break;\n-        }\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                byte[] b = v.getBytesNoCopy();\n-                buff.put((byte)CUSTOM_DATA_TYPE).\n-                    putVarInt(type).\n-                    putVarInt(b.length).\n-                    put(b);\n-                break;\n+                putVarInt(Integer.reverse(f));\n+          }\n+        }\n+        break;\n+      }\n+      case Value.BLOB:\n+      case Value.CLOB: {\n+        buff.put((byte) type);\n+        ValueLobDb lob = (ValueLobDb) v;\n+        byte[] small = lob.getSmall();\n+        if (small == null) {\n+          buff.putVarInt(-3).\n+              putVarInt(lob.getTableId()).\n+              putVarLong(lob.getLobId()).\n+              putVarLong(lob.getPrecision());\n+        } else {\n+          buff.putVarInt(small.length).\n+              put(small);\n+        }\n+        break;\n+      }\n+      case Value.ARRAY: {\n+        Value[] list = ((ValueArray) v).getList();\n+        buff.put((byte) type).putVarInt(list.length);\n+        for (Value x : list) {\n+          writeValue(buff, x);\n+        }\n+        break;\n+      }\n+      case Value.RESULT_SET: {\n+        buff.put((byte) type);\n+        try {\n+          ResultSet rs = ((ValueResultSet) v).getResultSet();\n+          rs.beforeFirst();\n+          ResultSetMetaData meta = rs.getMetaData();\n+          int columnCount = meta.getColumnCount();\n+          buff.putVarInt(columnCount);\n+          for (int i = 0; i < columnCount; i++) {\n+            writeString(buff, meta.getColumnName(i + 1));\n+            buff.putVarInt(meta.getColumnType(i + 1)).\n+                putVarInt(meta.getPrecision(i + 1)).\n+                putVarInt(meta.getScale(i + 1));\n+          }\n+          while (rs.next()) {\n+            buff.put((byte) 1);\n+            for (int i = 0; i < columnCount; i++) {\n+              int t = org.h2.value.DataType.\n+                  getValueTypeFromResultSet(meta, i + 1);\n+              Value val = org.h2.value.DataType.readValue(\n+                  null, rs, i + 1, t);\n+              writeValue(buff, val);\n             }\n-            DbException.throwInternalError(\"type=\" + v.getType());\n-        }\n+          }\n+          buff.put((byte) 0);\n+          rs.beforeFirst();\n+        } catch (SQLException e) {\n+          throw DbException.convert(e);\n+        }\n+        break;\n+      }\n+      case Value.GEOMETRY: {\n+        byte[] b = v.getBytes();\n+        int len = b.length;\n+        buff.put((byte) type).\n+            putVarInt(len).\n+            put(b);\n+        break;\n+      }\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          byte[] b = v.getBytesNoCopy();\n+          buff.put((byte) CUSTOM_DATA_TYPE).\n+              putVarInt(type).\n+              putVarInt(b.length).\n+              put(b);\n+          break;\n+        }\n+        DbException.throwInternalError(\"type=\" + v.getType());\n     }\n+  }\n \n-    private static void writeString(WriteBuffer buff, String s) {\n-        int len = s.length();\n-        buff.putVarInt(len).putStringData(s, len);\n-    }\n+  private static void writeString(WriteBuffer buff, String s) {\n+    int len = s.length();\n+    buff.putVarInt(len).putStringData(s, len);\n+  }\n \n-    /**\n-     * Read a value.\n-     *\n-     * @return the value\n-     */\n-    private Object readValue(ByteBuffer buff) {\n-        int type = buff.get() & 255;\n-        switch (type) {\n-        case Value.NULL:\n-            return ValueNull.INSTANCE;\n-        case BOOLEAN_TRUE:\n-            return ValueBoolean.get(true);\n-        case BOOLEAN_FALSE:\n-            return ValueBoolean.get(false);\n-        case INT_NEG:\n-            return ValueInt.get(-readVarInt(buff));\n-        case Value.ENUM:\n-        case Value.INT:\n-            return ValueInt.get(readVarInt(buff));\n-        case LONG_NEG:\n-            return ValueLong.get(-readVarLong(buff));\n-        case Value.LONG:\n-            return ValueLong.get(readVarLong(buff));\n-        case Value.BYTE:\n-            return ValueByte.get(buff.get());\n-        case Value.SHORT:\n-            return ValueShort.get(buff.getShort());\n-        case DECIMAL_0_1:\n-            return ValueDecimal.ZERO;\n-        case DECIMAL_0_1 + 1:\n-            return ValueDecimal.ONE;\n-        case DECIMAL_SMALL_0:\n-            return ValueDecimal.get(BigDecimal.valueOf(\n-                    readVarLong(buff)));\n-        case DECIMAL_SMALL: {\n-            int scale = readVarInt(buff);\n-            return ValueDecimal.get(BigDecimal.valueOf(\n-                    readVarLong(buff), scale));\n-        }\n-        case Value.DECIMAL: {\n-            int scale = readVarInt(buff);\n-            int len = readVarInt(buff);\n-            byte[] buff2 = Utils.newBytes(len);\n-            buff.get(buff2, 0, len);\n-            BigInteger b = new BigInteger(buff2);\n-            return ValueDecimal.get(new BigDecimal(b, scale));\n-        }\n-        case Value.DATE: {\n-            return ValueDate.fromDateValue(readVarLong(buff));\n-        }\n-        case Value.TIME: {\n-            long nanos = readVarLong(buff) * 1000000 + readVarLong(buff);\n-            return ValueTime.fromNanos(nanos);\n-        }\n-        case Value.TIMESTAMP: {\n-            long dateValue = readVarLong(buff);\n-            long nanos = readVarLong(buff) * 1000000 + readVarLong(buff);\n-            return ValueTimestamp.fromDateValueAndNanos(dateValue, nanos);\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            long dateValue = readVarLong(buff);\n-            long nanos = readVarLong(buff) * 1000000 + readVarLong(buff);\n-            short tz = (short) readVarInt(buff);\n-            return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n-        }\n-        case Value.BYTES: {\n-            int len = readVarInt(buff);\n-            byte[] b = Utils.newBytes(len);\n-            buff.get(b, 0, len);\n-            return ValueBytes.getNoCopy(b);\n-        }\n-        case Value.JAVA_OBJECT: {\n-            int len = readVarInt(buff);\n-            byte[] b = Utils.newBytes(len);\n-            buff.get(b, 0, len);\n-            return ValueJavaObject.getNoCopy(null, b, handler);\n-        }\n-        case Value.UUID:\n-            return ValueUuid.get(buff.getLong(), buff.getLong());\n-        case Value.STRING:\n-            return ValueString.get(readString(buff));\n-        case Value.STRING_IGNORECASE:\n-            return ValueStringIgnoreCase.get(readString(buff));\n-        case Value.STRING_FIXED:\n-            return ValueStringFixed.get(readString(buff));\n-        case FLOAT_0_1:\n-            return ValueFloat.get(0);\n-        case FLOAT_0_1 + 1:\n-            return ValueFloat.get(1);\n-        case DOUBLE_0_1:\n-            return ValueDouble.get(0);\n-        case DOUBLE_0_1 + 1:\n-            return ValueDouble.get(1);\n-        case Value.DOUBLE:\n-            return ValueDouble.get(Double.longBitsToDouble(\n-                    Long.reverse(readVarLong(buff))));\n-        case Value.FLOAT:\n-            return ValueFloat.get(Float.intBitsToFloat(\n-                    Integer.reverse(readVarInt(buff))));\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            int smallLen = readVarInt(buff);\n-            if (smallLen >= 0) {\n-                byte[] small = Utils.newBytes(smallLen);\n-                buff.get(small, 0, smallLen);\n-                return ValueLobDb.createSmallLob(type, small);\n-            } else if (smallLen == -3) {\n-                int tableId = readVarInt(buff);\n-                long lobId = readVarLong(buff);\n-                long precision = readVarLong(buff);\n-                return ValueLobDb.create(type,\n-                        handler, tableId, lobId, null, precision);\n-            } else {\n-                throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                        \"lob type: \" + smallLen);\n-            }\n-        }\n-        case Value.ARRAY: {\n-            int len = readVarInt(buff);\n-            Value[] list = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                list[i] = (Value) readValue(buff);\n-            }\n-            return ValueArray.get(list);\n-        }\n-        case Value.RESULT_SET: {\n-            SimpleResultSet rs = new SimpleResultSet();\n-            rs.setAutoClose(false);\n-            int columns = readVarInt(buff);\n-            for (int i = 0; i < columns; i++) {\n-                rs.addColumn(readString(buff),\n-                        readVarInt(buff),\n-                        readVarInt(buff),\n-                        readVarInt(buff));\n-            }\n-            while (buff.get() != 0) {\n-                Object[] o = new Object[columns];\n-                for (int i = 0; i < columns; i++) {\n-                    o[i] = ((Value) readValue(buff)).getObject();\n-                }\n-                rs.addRow(o);\n-            }\n-            return ValueResultSet.get(rs);\n-        }\n-        case Value.GEOMETRY: {\n-            int len = readVarInt(buff);\n-            byte[] b = Utils.newBytes(len);\n-            buff.get(b, 0, len);\n-            return ValueGeometry.get(b);\n-        }\n-        case SPATIAL_KEY_2D:\n-            return getSpatialDataType().read(buff);\n-        case CUSTOM_DATA_TYPE: {\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                int customType = readVarInt(buff);\n-                int len = readVarInt(buff);\n-                byte[] b = Utils.newBytes(len);\n-                buff.get(b, 0, len);\n-                return JdbcUtils.customDataTypesHandler.convert(\n-                        ValueBytes.getNoCopy(b), customType);\n-            }\n-            throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n-                    \"No CustomDataTypesHandler has been set up\");\n-        }\n-        default:\n-            if (type >= INT_0_15 && type < INT_0_15 + 16) {\n-                return ValueInt.get(type - INT_0_15);\n-            } else if (type >= LONG_0_7 && type < LONG_0_7 + 8) {\n-                return ValueLong.get(type - LONG_0_7);\n-            } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n-                int len = type - BYTES_0_31;\n-                byte[] b = Utils.newBytes(len);\n-                buff.get(b, 0, len);\n-                return ValueBytes.getNoCopy(b);\n-            } else if (type >= STRING_0_31 && type < STRING_0_31 + 32) {\n-                return ValueString.get(readString(buff, type - STRING_0_31));\n-            }\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n-        }\n+  /**\n+   * Read a value.\n+   *\n+   * @return the value\n+   */\n+  private Object readValue(ByteBuffer buff) {\n+    int type = buff.get() & 255;\n+    switch (type) {\n+      case Value.NULL:\n+        return ValueNull.INSTANCE;\n+      case BOOLEAN_TRUE:\n+        return ValueBoolean.get(true);\n+      case BOOLEAN_FALSE:\n+        return ValueBoolean.get(false);\n+      case INT_NEG:\n+        return ValueInt.get(-readVarInt(buff));\n+      case Value.ENUM:\n+      case Value.INT:\n+        return ValueInt.get(readVarInt(buff));\n+      case LONG_NEG:\n+        return ValueLong.get(-readVarLong(buff));\n+      case Value.LONG:\n+        return ValueLong.get(readVarLong(buff));\n+      case Value.BYTE:\n+        return ValueByte.get(buff.get());\n+      case Value.SHORT:\n+        return ValueShort.get(buff.getShort());\n+      case DECIMAL_0_1:\n+        return ValueDecimal.ZERO;\n+      case DECIMAL_0_1 + 1:\n+        return ValueDecimal.ONE;\n+      case DECIMAL_SMALL_0:\n+        return ValueDecimal.get(BigDecimal.valueOf(\n+            readVarLong(buff)));\n+      case DECIMAL_SMALL: {\n+        int scale = readVarInt(buff);\n+        return ValueDecimal.get(BigDecimal.valueOf(\n+            readVarLong(buff), scale));\n+      }\n+      case Value.DECIMAL: {\n+        int scale = readVarInt(buff);\n+        int len = readVarInt(buff);\n+        byte[] buff2 = Utils.newBytes(len);\n+        buff.get(buff2, 0, len);\n+        BigInteger b = new BigInteger(buff2);\n+        return ValueDecimal.get(new BigDecimal(b, scale));\n+      }\n+      case Value.DATE: {\n+        return ValueDate.fromDateValue(readVarLong(buff));\n+      }\n+      case Value.TIME: {\n+        long nanos = readVarLong(buff) * 1000000 + readVarLong(buff);\n+        return ValueTime.fromNanos(nanos);\n+      }\n+      case Value.TIMESTAMP: {\n+        long dateValue = readVarLong(buff);\n+        long nanos = readVarLong(buff) * 1000000 + readVarLong(buff);\n+        return ValueTimestamp.fromDateValueAndNanos(dateValue, nanos);\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        long dateValue = readVarLong(buff);\n+        long nanos = readVarLong(buff) * 1000000 + readVarLong(buff);\n+        short tz = (short) readVarInt(buff);\n+        return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n+      }\n+      case Value.BYTES: {\n+        int len = readVarInt(buff);\n+        byte[] b = Utils.newBytes(len);\n+        buff.get(b, 0, len);\n+        return ValueBytes.getNoCopy(b);\n+      }\n+      case Value.JAVA_OBJECT: {\n+        int len = readVarInt(buff);\n+        byte[] b = Utils.newBytes(len);\n+        buff.get(b, 0, len);\n+        return ValueJavaObject.getNoCopy(null, b, handler);\n+      }\n+      case Value.UUID:\n+        return ValueUuid.get(buff.getLong(), buff.getLong());\n+      case Value.STRING:\n+        return ValueString.get(readString(buff));\n+      case Value.STRING_IGNORECASE:\n+        return ValueStringIgnoreCase.get(readString(buff));\n+      case Value.STRING_FIXED:\n+        return ValueStringFixed.get(readString(buff));\n+      case FLOAT_0_1:\n+        return ValueFloat.get(0);\n+      case FLOAT_0_1 + 1:\n+        return ValueFloat.get(1);\n+      case DOUBLE_0_1:\n+        return ValueDouble.get(0);\n+      case DOUBLE_0_1 + 1:\n+        return ValueDouble.get(1);\n+      case Value.DOUBLE:\n+        return ValueDouble.get(Double.longBitsToDouble(\n+            Long.reverse(readVarLong(buff))));\n+      case Value.FLOAT:\n+        return ValueFloat.get(Float.intBitsToFloat(\n+            Integer.reverse(readVarInt(buff))));\n+      case Value.BLOB:\n+      case Value.CLOB: {\n+        int smallLen = readVarInt(buff);\n+        if (smallLen >= 0) {\n+          byte[] small = Utils.newBytes(smallLen);\n+          buff.get(small, 0, smallLen);\n+          return ValueLobDb.createSmallLob(type, small);\n+        } else if (smallLen == -3) {\n+          int tableId = readVarInt(buff);\n+          long lobId = readVarLong(buff);\n+          long precision = readVarLong(buff);\n+          return ValueLobDb.create(type,\n+              handler, tableId, lobId, null, precision);\n+        } else {\n+          throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n+              \"lob type: \" + smallLen);\n+        }\n+      }\n+      case Value.ARRAY: {\n+        int len = readVarInt(buff);\n+        Value[] list = new Value[len];\n+        for (int i = 0; i < len; i++) {\n+          list[i] = (Value) readValue(buff);\n+        }\n+        return ValueArray.get(list);\n+      }\n+      case Value.RESULT_SET: {\n+        SimpleResultSet rs = new SimpleResultSet();\n+        rs.setAutoClose(false);\n+        int columns = readVarInt(buff);\n+        for (int i = 0; i < columns; i++) {\n+          rs.addColumn(readString(buff),\n+              readVarInt(buff),\n+              readVarInt(buff),\n+              readVarInt(buff));\n+        }\n+        while (buff.get() != 0) {\n+          Object[] o = new Object[columns];\n+          for (int i = 0; i < columns; i++) {\n+            o[i] = ((Value) readValue(buff)).getObject();\n+          }\n+          rs.addRow(o);\n+        }\n+        return ValueResultSet.get(rs);\n+      }\n+      case Value.GEOMETRY: {\n+        int len = readVarInt(buff);\n+        byte[] b = Utils.newBytes(len);\n+        buff.get(b, 0, len);\n+        return ValueGeometry.get(b);\n+      }\n+      case SPATIAL_KEY_2D:\n+        return getSpatialDataType().read(buff);\n+      case CUSTOM_DATA_TYPE: {\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          int customType = readVarInt(buff);\n+          int len = readVarInt(buff);\n+          byte[] b = Utils.newBytes(len);\n+          buff.get(b, 0, len);\n+          return JdbcUtils.customDataTypesHandler.convert(\n+              ValueBytes.getNoCopy(b), customType);\n+        }\n+        throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n+            \"No CustomDataTypesHandler has been set up\");\n+      }\n+      default:\n+        if (type >= INT_0_15 && type < INT_0_15 + 16) {\n+          return ValueInt.get(type - INT_0_15);\n+        } else if (type >= LONG_0_7 && type < LONG_0_7 + 8) {\n+          return ValueLong.get(type - LONG_0_7);\n+        } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n+          int len = type - BYTES_0_31;\n+          byte[] b = Utils.newBytes(len);\n+          buff.get(b, 0, len);\n+          return ValueBytes.getNoCopy(b);\n+        } else if (type >= STRING_0_31 && type < STRING_0_31 + 32) {\n+          return ValueString.get(readString(buff, type - STRING_0_31));\n+        }\n+        throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n     }\n+  }\n \n-    private static int readVarInt(ByteBuffer buff) {\n-        return DataUtils.readVarInt(buff);\n-    }\n+  private static int readVarInt(ByteBuffer buff) {\n+    return DataUtils.readVarInt(buff);\n+  }\n \n-    private static long readVarLong(ByteBuffer buff) {\n-        return DataUtils.readVarLong(buff);\n-    }\n+  private static long readVarLong(ByteBuffer buff) {\n+    return DataUtils.readVarLong(buff);\n+  }\n \n-    private static String readString(ByteBuffer buff, int len) {\n-        return DataUtils.readString(buff, len);\n-    }\n+  private static String readString(ByteBuffer buff, int len) {\n+    return DataUtils.readString(buff, len);\n+  }\n \n-    private static String readString(ByteBuffer buff) {\n-        int len = readVarInt(buff);\n-        return DataUtils.readString(buff, len);\n-    }\n+  private static String readString(ByteBuffer buff) {\n+    int len = readVarInt(buff);\n+    return DataUtils.readString(buff, len);\n+  }\n \n-    @Override\n-    public int hashCode() {\n-        return compareMode.hashCode() ^ Arrays.hashCode(sortTypes);\n-    }\n+  @Override\n+  public int hashCode() {\n+    return compareMode.hashCode() ^ Arrays.hashCode(sortTypes);\n+  }\n \n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == this) {\n-            return true;\n-        } else if (!(obj instanceof ValueDataType)) {\n-            return false;\n-        }\n-        ValueDataType v = (ValueDataType) obj;\n-        if (!compareMode.equals(v.compareMode)) {\n-            return false;\n-        }\n-        return Arrays.equals(sortTypes, v.sortTypes);\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (obj == this) {\n+      return true;\n+    } else if (!(obj instanceof ValueDataType)) {\n+      return false;\n+    }\n+    ValueDataType v = (ValueDataType) obj;\n+    if (!compareMode.equals(v.compareMode)) {\n+      return false;\n     }\n+    return Arrays.equals(sortTypes, v.sortTypes);\n+  }\n \n }\n",
            "diff_size": 727
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/164/ValueDataType.java\nindex df6bed6bb2d..4fa2200f80b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/164/ValueDataType.java\n@@ -408,8 +408,7 @@ public class ValueDataType implements DataType {\n                 while (rs.next()) {\n                     buff.put((byte) 1);\n                     for (int i = 0; i < columnCount; i++) {\n-                        int t = org.h2.value.DataType.\n-                                getValueTypeFromResultSet(meta, i + 1);\n+                        int t = org.h2.value.DataType.getValueTypeFromResultSet(meta, i + 1);\n                         Value val = org.h2.value.DataType.readValue(\n                                 null, rs, i + 1, t);\n                         writeValue(buff, val);\n@@ -433,7 +432,7 @@ public class ValueDataType implements DataType {\n         default:\n             if (JdbcUtils.customDataTypesHandler != null) {\n                 byte[] b = v.getBytesNoCopy();\n-                buff.put((byte)CUSTOM_DATA_TYPE).\n+                buff.put((byte) CUSTOM_DATA_TYPE).\n                     putVarInt(type).\n                     putVarInt(b.length).\n                     put(b);\n@@ -665,4 +664,4 @@ public class ValueDataType implements DataType {\n         return Arrays.equals(sortTypes, v.sortTypes);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/164/ValueDataType.java\nindex df6bed6bb2d..5a0a19672b4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/164/ValueDataType.java\n@@ -53,6 +53,8 @@ import org.h2.value.ValueUuid;\n /**\n  * A row type.\n  */\n+\n+\n public class ValueDataType implements DataType {\n \n     private static final int INT_0_15 = 32;\n@@ -71,13 +73,20 @@ public class ValueDataType implements DataType {\n     private static final int SPATIAL_KEY_2D = 132;\n     private static final int CUSTOM_DATA_TYPE = 133;\n \n+\n     final DataHandler handler;\n+\n+\n     final CompareMode compareMode;\n+\n+\n     final int[] sortTypes;\n+\n+\n     SpatialDataType spatialType;\n \n-    public ValueDataType(CompareMode compareMode, DataHandler handler,\n-            int[] sortTypes) {\n+    public ValueDataType(CompareMode compareMode,\n+        DataHandler handler, int[] sortTypes) {\n         this.compareMode = compareMode;\n         this.handler = handler;\n         this.sortTypes = sortTypes;\n@@ -208,7 +217,7 @@ public class ValueDataType implements DataType {\n                 buff.put((byte) INT_NEG).putVarInt(-x);\n             } else if (x < 16) {\n                 buff.put((byte) (INT_0_15 + x));\n-            } else {\n+                        } else {\n                 buff.put((byte) type).putVarInt(x);\n             }\n             break;\n@@ -219,7 +228,7 @@ public class ValueDataType implements DataType {\n                 buff.put((byte) LONG_NEG).putVarLong(-x);\n             } else if (x < 8) {\n                 buff.put((byte) (LONG_0_7 + x));\n-            } else {\n+                         } else {\n                 buff.put((byte) type).putVarLong(x);\n             }\n             break;\n@@ -230,25 +239,19 @@ public class ValueDataType implements DataType {\n                 buff.put((byte) DECIMAL_0_1);\n             } else if (BigDecimal.ONE.equals(x)) {\n                 buff.put((byte) (DECIMAL_0_1 + 1));\n-            } else {\n+                            } else {\n                 int scale = x.scale();\n                 BigInteger b = x.unscaledValue();\n                 int bits = b.bitLength();\n                 if (bits <= 63) {\n                     if (scale == 0) {\n-                        buff.put((byte) DECIMAL_SMALL_0).\n-                            putVarLong(b.longValue());\n+                        buff.put((byte) DECIMAL_SMALL_0).putVarLong(b.longValue());\n                     } else {\n-                        buff.put((byte) DECIMAL_SMALL).\n-                            putVarInt(scale).\n-                            putVarLong(b.longValue());\n+                        buff.put((byte) DECIMAL_SMALL).putVarInt(scale).putVarLong(b.longValue());\n                     }\n                 } else {\n                     byte[] bytes = b.toByteArray();\n-                    buff.put((byte) type).\n-                        putVarInt(scale).\n-                        putVarInt(bytes.length).\n-                        put(bytes);\n+                    buff.put((byte) type).putVarInt(scale).putVarInt(bytes.length).put(bytes);\n                 }\n             }\n             break;\n@@ -258,9 +261,7 @@ public class ValueDataType implements DataType {\n             long nanos = t.getNanos();\n             long millis = nanos / 1000000;\n             nanos -= millis * 1000000;\n-            buff.put((byte) type).\n-                putVarLong(millis).\n-                putVarLong(nanos);\n+            buff.put((byte) type).putVarLong(millis).putVarLong(nanos);\n             break;\n         }\n         case Value.DATE: {\n@@ -274,10 +275,7 @@ public class ValueDataType implements DataType {\n             long nanos = ts.getTimeNanos();\n             long millis = nanos / 1000000;\n             nanos -= millis * 1000000;\n-            buff.put((byte) type).\n-                putVarLong(dateValue).\n-                putVarLong(millis).\n-                putVarLong(nanos);\n+            buff.put((byte) type).putVarLong(dateValue).putVarLong(millis).putVarLong(nanos);\n             break;\n         }\n         case Value.TIMESTAMP_TZ: {\n@@ -286,46 +284,34 @@ public class ValueDataType implements DataType {\n             long nanos = ts.getTimeNanos();\n             long millis = nanos / 1000000;\n             nanos -= millis * 1000000;\n-            buff.put((byte) type).\n-                putVarLong(dateValue).\n-                putVarLong(millis).\n-                putVarLong(nanos).\n-                putVarInt(ts.getTimeZoneOffsetMins());\n+            buff.put((byte) type).putVarLong(dateValue).putVarLong(millis).putVarLong(nanos).putVarInt(ts.getTimeZoneOffsetMins());\n             break;\n         }\n         case Value.JAVA_OBJECT: {\n             byte[] b = v.getBytesNoCopy();\n-            buff.put((byte) type).\n-                putVarInt(b.length).\n-                put(b);\n+            buff.put((byte) type).putVarInt(b.length).put(b);\n             break;\n         }\n         case Value.BYTES: {\n             byte[] b = v.getBytesNoCopy();\n             int len = b.length;\n             if (len < 32) {\n-                buff.put((byte) (BYTES_0_31 + len)).\n-                    put(b);\n+                buff.put((byte) (BYTES_0_31 + len)).put(b);\n             } else {\n-                buff.put((byte) type).\n-                    putVarInt(b.length).\n-                    put(b);\n+                buff.put((byte) type).putVarInt(b.length).put(b);\n             }\n             break;\n         }\n         case Value.UUID: {\n             ValueUuid uuid = (ValueUuid) v;\n-            buff.put((byte) type).\n-                putLong(uuid.getHigh()).\n-                putLong(uuid.getLow());\n+            buff.put((byte) type).putLong(uuid.getHigh()).putLong(uuid.getLow());\n             break;\n         }\n         case Value.STRING: {\n             String s = v.getString();\n             int len = s.length();\n             if (len < 32) {\n-                buff.put((byte) (STRING_0_31 + len)).\n-                    putStringData(s, len);\n+                buff.put((byte) (STRING_0_31 + len)).putStringData(s, len);\n             } else {\n                 buff.put((byte) type);\n                 writeString(buff, s);\n@@ -346,8 +332,7 @@ public class ValueDataType implements DataType {\n                 if (d == ValueDouble.ZERO_BITS) {\n                     buff.put((byte) DOUBLE_0_1);\n                 } else {\n-                    buff.put((byte) type).\n-                        putVarLong(Long.reverse(d));\n+                    buff.put((byte) type).putVarLong(Long.reverse(d));\n                 }\n             }\n             break;\n@@ -361,8 +346,7 @@ public class ValueDataType implements DataType {\n                 if (f == ValueFloat.ZERO_BITS) {\n                     buff.put((byte) FLOAT_0_1);\n                 } else {\n-                    buff.put((byte) type).\n-                        putVarInt(Integer.reverse(f));\n+                    buff.put((byte) type).putVarInt(Integer.reverse(f));\n                 }\n             }\n             break;\n@@ -373,13 +357,9 @@ public class ValueDataType implements DataType {\n             ValueLobDb lob = (ValueLobDb) v;\n             byte[] small = lob.getSmall();\n             if (small == null) {\n-                buff.putVarInt(-3).\n-                    putVarInt(lob.getTableId()).\n-                    putVarLong(lob.getLobId()).\n-                    putVarLong(lob.getPrecision());\n+                buff.putVarInt(-3).putVarInt(lob.getTableId()).putVarLong(lob.getLobId()).putVarLong(lob.getPrecision());\n             } else {\n-                buff.putVarInt(small.length).\n-                    put(small);\n+                buff.putVarInt(small.length).put(small);\n             }\n             break;\n         }\n@@ -401,17 +381,13 @@ public class ValueDataType implements DataType {\n                 buff.putVarInt(columnCount);\n                 for (int i = 0; i < columnCount; i++) {\n                     writeString(buff, meta.getColumnName(i + 1));\n-                    buff.putVarInt(meta.getColumnType(i + 1)).\n-                        putVarInt(meta.getPrecision(i + 1)).\n-                        putVarInt(meta.getScale(i + 1));\n+                    buff.putVarInt(meta.getColumnType(i + 1)).putVarInt(meta.getPrecision(i + 1)).putVarInt(meta.getScale(i + 1));\n                 }\n                 while (rs.next()) {\n                     buff.put((byte) 1);\n                     for (int i = 0; i < columnCount; i++) {\n-                        int t = org.h2.value.DataType.\n-                                getValueTypeFromResultSet(meta, i + 1);\n-                        Value val = org.h2.value.DataType.readValue(\n-                                null, rs, i + 1, t);\n+                        int t = org.h2.value.DataType.getValueTypeFromResultSet(meta, i + 1);\n+                        Value val = org.h2.value.DataType.readValue(null, rs, i + 1, t);\n                         writeValue(buff, val);\n                     }\n                 }\n@@ -425,18 +401,13 @@ public class ValueDataType implements DataType {\n         case Value.GEOMETRY: {\n             byte[] b = v.getBytes();\n             int len = b.length;\n-            buff.put((byte) type).\n-                putVarInt(len).\n-                put(b);\n+            buff.put((byte) type).putVarInt(len).put(b);\n             break;\n         }\n         default:\n             if (JdbcUtils.customDataTypesHandler != null) {\n                 byte[] b = v.getBytesNoCopy();\n-                buff.put((byte)CUSTOM_DATA_TYPE).\n-                    putVarInt(type).\n-                    putVarInt(b.length).\n-                    put(b);\n+                buff.put((byte) CUSTOM_DATA_TYPE).putVarInt(type).putVarInt(b.length).put(b);\n                 break;\n             }\n             DbException.throwInternalError(\"type=\" + v.getType());\n@@ -453,6 +424,7 @@ public class ValueDataType implements DataType {\n      *\n      * @return the value\n      */\n+\n     private Object readValue(ByteBuffer buff) {\n         int type = buff.get() & 255;\n         switch (type) {\n@@ -480,12 +452,10 @@ public class ValueDataType implements DataType {\n         case DECIMAL_0_1 + 1:\n             return ValueDecimal.ONE;\n         case DECIMAL_SMALL_0:\n-            return ValueDecimal.get(BigDecimal.valueOf(\n-                    readVarLong(buff)));\n+            return ValueDecimal.get(BigDecimal.valueOf(readVarLong(buff)));\n         case DECIMAL_SMALL: {\n             int scale = readVarInt(buff);\n-            return ValueDecimal.get(BigDecimal.valueOf(\n-                    readVarLong(buff), scale));\n+            return ValueDecimal.get(BigDecimal.valueOf(readVarLong(buff), scale));\n         }\n         case Value.DECIMAL: {\n             int scale = readVarInt(buff);\n@@ -542,11 +512,9 @@ public class ValueDataType implements DataType {\n         case DOUBLE_0_1 + 1:\n             return ValueDouble.get(1);\n         case Value.DOUBLE:\n-            return ValueDouble.get(Double.longBitsToDouble(\n-                    Long.reverse(readVarLong(buff))));\n+            return ValueDouble.get(Double.longBitsToDouble(Long.reverse(readVarLong(buff))));\n         case Value.FLOAT:\n-            return ValueFloat.get(Float.intBitsToFloat(\n-                    Integer.reverse(readVarInt(buff))));\n+            return ValueFloat.get(Float.intBitsToFloat(Integer.reverse(readVarInt(buff))));\n         case Value.BLOB:\n         case Value.CLOB: {\n             int smallLen = readVarInt(buff);\n@@ -558,11 +526,9 @@ public class ValueDataType implements DataType {\n                 int tableId = readVarInt(buff);\n                 long lobId = readVarLong(buff);\n                 long precision = readVarLong(buff);\n-                return ValueLobDb.create(type,\n-                        handler, tableId, lobId, null, precision);\n-            } else {\n-                throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                        \"lob type: \" + smallLen);\n+                return ValueLobDb.create(type, handler, tableId, lobId, null, precision);\n+                         } else {\n+                throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"lob type: \" + smallLen);\n             }\n         }\n         case Value.ARRAY: {\n@@ -578,10 +544,7 @@ public class ValueDataType implements DataType {\n             rs.setAutoClose(false);\n             int columns = readVarInt(buff);\n             for (int i = 0; i < columns; i++) {\n-                rs.addColumn(readString(buff),\n-                        readVarInt(buff),\n-                        readVarInt(buff),\n-                        readVarInt(buff));\n+                rs.addColumn(readString(buff), readVarInt(buff), readVarInt(buff), readVarInt(buff));\n             }\n             while (buff.get() != 0) {\n                 Object[] o = new Object[columns];\n@@ -606,25 +569,24 @@ public class ValueDataType implements DataType {\n                 int len = readVarInt(buff);\n                 byte[] b = Utils.newBytes(len);\n                 buff.get(b, 0, len);\n-                return JdbcUtils.customDataTypesHandler.convert(\n-                        ValueBytes.getNoCopy(b), customType);\n+                return JdbcUtils.customDataTypesHandler.convert(ValueBytes.getNoCopy(b), customType);\n             }\n             throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n-                    \"No CustomDataTypesHandler has been set up\");\n+                                  \"No CustomDataTypesHandler has been set up\");\n         }\n         default:\n             if (type >= INT_0_15 && type < INT_0_15 + 16) {\n                 return ValueInt.get(type - INT_0_15);\n             } else if (type >= LONG_0_7 && type < LONG_0_7 + 8) {\n                 return ValueLong.get(type - LONG_0_7);\n-            } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n-                int len = type - BYTES_0_31;\n-                byte[] b = Utils.newBytes(len);\n-                buff.get(b, 0, len);\n-                return ValueBytes.getNoCopy(b);\n+        } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n+                       int len = type - BYTES_0_31;\n+                       byte[] b = Utils.newBytes(len);\n+                       buff.get(b, 0, len);\n+                       return ValueBytes.getNoCopy(b);\n             } else if (type >= STRING_0_31 && type < STRING_0_31 + 32) {\n-                return ValueString.get(readString(buff, type - STRING_0_31));\n-            }\n+                   return ValueString.get(readString(buff, type - STRING_0_31));\n+               }\n             throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n         }\n     }\n@@ -665,4 +627,4 @@ public class ValueDataType implements DataType {\n         return Arrays.equals(sortTypes, v.sortTypes);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 101
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/164/ValueDataType.java\nindex df6bed6bb2d..ab4a88be496 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/164/ValueDataType.java\n@@ -433,7 +433,7 @@ public class ValueDataType implements DataType {\n         default:\n             if (JdbcUtils.customDataTypesHandler != null) {\n                 byte[] b = v.getBytesNoCopy();\n-                buff.put((byte)CUSTOM_DATA_TYPE).\n+                buff.put((byte) CUSTOM_DATA_TYPE).\n                     putVarInt(type).\n                     putVarInt(b.length).\n                     put(b);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/164/ValueDataType.java\nindex df6bed6bb2d..ab4a88be496 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/164/ValueDataType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/164/ValueDataType.java\n@@ -433,7 +433,7 @@ public class ValueDataType implements DataType {\n         default:\n             if (JdbcUtils.customDataTypesHandler != null) {\n                 byte[] b = v.getBytesNoCopy();\n-                buff.put((byte)CUSTOM_DATA_TYPE).\n+                buff.put((byte) CUSTOM_DATA_TYPE).\n                     putVarInt(type).\n                     putVarInt(b.length).\n                     put(b);\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}