{
    "project_name": "Internet2-grouper",
    "error_id": "11",
    "information": {
        "errors": [
            {
                "line": "480",
                "column": "9",
                "severity": "warning",
                "message": "'}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
            }
        ]
    },
    "source_code": "            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\n            this.setEquals(false);\n        }\n        // 'Switch' on type of array, to dispatch to the correct handler\n        // This handles multi dimensional arrays of the same depth\n        else if (lhs instanceof long[]) {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "480",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler/11/EqualsBuilder.java\nindex f02aebb379e..241f00d62aa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler/11/EqualsBuilder.java\n@@ -477,8 +477,7 @@ public class EqualsBuilder implements Builder<Boolean> {\n         } else if (lhs.getClass() != rhs.getClass()) {\r\n             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n             this.setEquals(false);\r\n-        }\r\n-        // 'Switch' on type of array, to dispatch to the correct handler\r\n+        } // 'Switch' on type of array, to dispatch to the correct handler\r\n         // This handles multi dimensional arrays of the same depth\r\n         else if (lhs instanceof long[]) {\r\n             append((long[]) lhs, (long[]) rhs);\r\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "481",
                    "column": "5",
                    "severity": "warning",
                    "message": "'}' at column 5 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/intellij/11/EqualsBuilder.java\nindex f02aebb379e..32a2fbfe4e4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/intellij/11/EqualsBuilder.java\n@@ -1,12 +1,12 @@\n /**\r\n  * Copyright 2014 Internet2\r\n- *\r\n+ * <p>\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  * you may not use this file except in compliance with the License.\r\n  * You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n+ * <p>\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ * <p>\r\n  * Unless required by applicable law or agreed to in writing, software\r\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n@@ -29,6 +29,7 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n+\r\n package edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.builder;\r\n \r\n import java.lang.reflect.AccessibleObject;\r\n@@ -97,863 +98,863 @@ import edu.internet2.middleware.grouperClientExt.org.apache.commons.lang3.tuple.\n  */\r\n public class EqualsBuilder implements Builder<Boolean> {\r\n \r\n-    /**\r\n-     * <p>\r\n-     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n-\r\n-    /*\r\n-     * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n-     * we are in the process of calculating.\r\n-     *\r\n-     * So we generate a one-to-one mapping from the original object to a new object.\r\n-     *\r\n-     * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n-     * are equal, so we also need to ensure that the replacement objects are only equal\r\n-     * if the original objects are identical.\r\n-     *\r\n-     * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n-     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n-     *\r\n-     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n-     * to disambiguate the duplicate ids.\r\n-     */\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns the registry of object pairs being traversed by the reflection\r\n-     * methods in the current thread.\r\n-     * </p>\r\n-     *\r\n-     * @return Set the registry of objects being traversed\r\n-     * @since 3.0\r\n-     */\r\n-    static Set<Pair<IDKey, IDKey>> getRegistry() {\r\n-        return REGISTRY.get();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Converters value pair into a register pair.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object\r\n-     * @param rhs the other object\r\n-     *\r\n-     * @return the pair\r\n-     */\r\n-    static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\r\n-        IDKey left = new IDKey(lhs);\r\n-        IDKey right = new IDKey(rhs);\r\n-        return Pair.of(left, right);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Returns <code>true</code> if the registry contains the given object pair.\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     * Objects might be swapped therefore a check is needed if the object pair\r\n-     * is registered in given or swapped order.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object to lookup in registry\r\n-     * @param rhs the other object to lookup on registry\r\n-     * @return boolean <code>true</code> if the registry contains the given object.\r\n-     * @since 3.0\r\n-     */\r\n-    static boolean isRegistered(Object lhs, Object rhs) {\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-        Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\r\n-\r\n-        return registry != null\r\n-                && (registry.contains(pair) || registry.contains(swappedPair));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Registers the given object pair.\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs <code>this</code> object to register\r\n-     * @param rhs the other object to register\r\n-     */\r\n-    static void register(Object lhs, Object rhs) {\r\n-        synchronized (EqualsBuilder.class) {\r\n-            if (getRegistry() == null) {\r\n-                REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\r\n-            }\r\n-        }\r\n-\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-        registry.add(pair);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Unregisters the given object pair.\r\n-     * </p>\r\n-     *\r\n-     * <p>\r\n-     * Used by the reflection methods to avoid infinite loops.\r\n-     *\r\n-     * @param lhs <code>this</code> object to unregister\r\n-     * @param rhs the other object to unregister\r\n-     * @since 3.0\r\n-     */\r\n-    static void unregister(Object lhs, Object rhs) {\r\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n-        if (registry != null) {\r\n-            Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n-            registry.remove(pair);\r\n-            synchronized (EqualsBuilder.class) {\r\n-                //read again\r\n-                registry = getRegistry();\r\n-                if (registry != null && registry.isEmpty()) {\r\n-                    REGISTRY.remove();\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * If the fields tested are equals.\r\n-     * The default value is <code>true</code>.\r\n-     */\r\n-    private boolean isEquals = true;\r\n-\r\n-    /**\r\n-     * <p>Constructor for EqualsBuilder.</p>\r\n-     *\r\n-     * <p>Starts off assuming that equals is <code>true</code>.</p>\r\n-     * @see Object#equals(Object)\r\n-     */\r\n-    public EqualsBuilder() {\r\n-        // do nothing for now.\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>Transient members will be not be tested, as they are likely derived\r\n-     * fields, and not part of the value of the Object.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param excludeFields  Collection of String field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\r\n-        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>Transient members will be not be tested, as they are likely derived\r\n-     * fields, and not part of the value of the Object.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\r\n-        return reflectionEquals(lhs, rhs, false, null, excludeFields);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>If the TestTransients parameter is set to <code>true</code>, transient\r\n-     * members will be tested, otherwise they are ignored, as they are likely\r\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n-     *\r\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param testTransients  whether to include transient fields\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\r\n-        return reflectionEquals(lhs, rhs, testTransients, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n-     * are equal.</p>\r\n-     *\r\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n-     * fields. This means that it will throw a security exception if run under\r\n-     * a security manager, if the permissions are not set up correctly. It is also\r\n-     * not as efficient as testing explicitly.</p>\r\n-     *\r\n-     * <p>If the testTransients parameter is set to <code>true</code>, transient\r\n-     * members will be tested, otherwise they are ignored, as they are likely\r\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n-     *\r\n-     * <p>Static fields will not be included. Superclass fields will be appended\r\n-     * up to and including the specified superclass. A null superclass is treated\r\n-     * as java.lang.Object.</p>\r\n-     *\r\n-     * @param lhs  <code>this</code> object\r\n-     * @param rhs  the other object\r\n-     * @param testTransients  whether to include transient fields\r\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\r\n-     *  may be <code>null</code>\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     * @return <code>true</code> if the two Objects have tested equals.\r\n-     * @since 2.0\r\n-     */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\r\n-            String... excludeFields) {\r\n-        if (lhs == rhs) {\r\n-            return true;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            return false;\r\n-        }\r\n-        // Find the leaf class since there may be transients in the leaf\r\n-        // class or in classes between the leaf and root.\r\n-        // If we are not testing transients or a subclass has no ivars,\r\n-        // then a subclass can test equals to a superclass.\r\n-        Class<?> lhsClass = lhs.getClass();\r\n-        Class<?> rhsClass = rhs.getClass();\r\n-        Class<?> testClass;\r\n-        if (lhsClass.isInstance(rhs)) {\r\n-            testClass = lhsClass;\r\n-            if (!rhsClass.isInstance(lhs)) {\r\n-                // rhsClass is a subclass of lhsClass\r\n-                testClass = rhsClass;\r\n-            }\r\n-        } else if (rhsClass.isInstance(lhs)) {\r\n-            testClass = rhsClass;\r\n-            if (!lhsClass.isInstance(rhs)) {\r\n-                // lhsClass is a subclass of rhsClass\r\n-                testClass = lhsClass;\r\n-            }\r\n-        } else {\r\n-            // The two classes are not related.\r\n-            return false;\r\n-        }\r\n-        EqualsBuilder equalsBuilder = new EqualsBuilder();\r\n-        try {\r\n-            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n-            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\r\n-                testClass = testClass.getSuperclass();\r\n-                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n-            }\r\n-        } catch (IllegalArgumentException e) {\r\n-            // In this case, we tried to test a subclass vs. a superclass and\r\n-            // the subclass has ivars or the ivars are transient and\r\n-            // we are testing transients.\r\n-            // If a subclass has ivars that we are trying to test them, we get an\r\n-            // exception and we know that the objects are not equal.\r\n-            return false;\r\n-        }\r\n-        return equalsBuilder.isEquals();\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Appends the fields and values defined by the given object of the\r\n-     * given Class.</p>\r\n-     *\r\n-     * @param lhs  the left hand object\r\n-     * @param rhs  the right hand object\r\n-     * @param clazz  the class to append details of\r\n-     * @param builder  the builder to append to\r\n-     * @param useTransients  whether to test transient fields\r\n-     * @param excludeFields  array of field names to exclude from testing\r\n-     */\r\n-    private static void reflectionAppend(\r\n-        Object lhs,\r\n-        Object rhs,\r\n-        Class<?> clazz,\r\n-        EqualsBuilder builder,\r\n-        boolean useTransients,\r\n-        String[] excludeFields) {\r\n-\r\n-        if (isRegistered(lhs, rhs)) {\r\n-            return;\r\n-        }\r\n-\r\n-        try {\r\n-            register(lhs, rhs);\r\n-            Field[] fields = clazz.getDeclaredFields();\r\n-            AccessibleObject.setAccessible(fields, true);\r\n-            for (int i = 0; i < fields.length && builder.isEquals; i++) {\r\n-                Field f = fields[i];\r\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\r\n-                    && (f.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\r\n-                    && (!Modifier.isStatic(f.getModifiers()))) {\r\n-                    try {\r\n-                        builder.append(f.get(lhs), f.get(rhs));\r\n-                    } catch (IllegalAccessException e) {\r\n-                        //this can't happen. Would get a Security exception instead\r\n-                        //throw a runtime exception in case the impossible happens.\r\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\r\n-                    }\r\n-                }\r\n-            }\r\n-        } finally {\r\n-            unregister(lhs, rhs);\r\n-        }\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\r\n-     *\r\n-     * @param superEquals  the result of calling <code>super.equals()</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     * @since 2.0\r\n-     */\r\n-    public EqualsBuilder appendSuper(boolean superEquals) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = superEquals;\r\n-        return this;\r\n-    }\r\n-\r\n-    //-------------------------------------------------------------------------\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>Object</code>s are equal using their\r\n-     * <code>equals</code> method.</p>\r\n-     *\r\n-     * @param lhs  the left hand object\r\n-     * @param rhs  the right hand object\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(Object lhs, Object rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        Class<?> lhsClass = lhs.getClass();\r\n-        if (!lhsClass.isArray()) {\r\n-            // The simple case, not an array, just test the element\r\n-            isEquals = lhs.equals(rhs);\r\n-        } else if (lhs.getClass() != rhs.getClass()) {\r\n-            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n-            this.setEquals(false);\r\n-        }\r\n-        // 'Switch' on type of array, to dispatch to the correct handler\r\n-        // This handles multi dimensional arrays of the same depth\r\n-        else if (lhs instanceof long[]) {\r\n-            append((long[]) lhs, (long[]) rhs);\r\n-        } else if (lhs instanceof int[]) {\r\n-            append((int[]) lhs, (int[]) rhs);\r\n-        } else if (lhs instanceof short[]) {\r\n-            append((short[]) lhs, (short[]) rhs);\r\n-        } else if (lhs instanceof char[]) {\r\n-            append((char[]) lhs, (char[]) rhs);\r\n-        } else if (lhs instanceof byte[]) {\r\n-            append((byte[]) lhs, (byte[]) rhs);\r\n-        } else if (lhs instanceof double[]) {\r\n-            append((double[]) lhs, (double[]) rhs);\r\n-        } else if (lhs instanceof float[]) {\r\n-            append((float[]) lhs, (float[]) rhs);\r\n-        } else if (lhs instanceof boolean[]) {\r\n-            append((boolean[]) lhs, (boolean[]) rhs);\r\n-        } else {\r\n-            // Not an array of primitives\r\n-            append((Object[]) lhs, (Object[]) rhs);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>\r\n-     * Test if two <code>long</code> s are equal.\r\n-     * </p>\r\n-     *\r\n-     * @param lhs\r\n-     *                  the left hand <code>long</code>\r\n-     * @param rhs\r\n-     *                  the right hand <code>long</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(long lhs, long rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>int</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>int</code>\r\n-     * @param rhs  the right hand <code>int</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(int lhs, int rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>short</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>short</code>\r\n-     * @param rhs  the right hand <code>short</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(short lhs, short rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>char</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>char</code>\r\n-     * @param rhs  the right hand <code>char</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(char lhs, char rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>byte</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>byte</code>\r\n-     * @param rhs  the right hand <code>byte</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(byte lhs, byte rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>double</code>s are equal by testing that the\r\n-     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\r\n-     *\r\n-     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n-     *\r\n-     * <p>It is compatible with the hash code generated by\r\n-     * <code>HashCodeBuilder</code>.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>double</code>\r\n-     * @param rhs  the right hand <code>double</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(double lhs, double rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>float</code>s are equal byt testing that the\r\n-     * pattern of bits returned by doubleToLong are equal.</p>\r\n-     *\r\n-     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n-     *\r\n-     * <p>It is compatible with the hash code generated by\r\n-     * <code>HashCodeBuilder</code>.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>float</code>\r\n-     * @param rhs  the right hand <code>float</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(float lhs, float rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Test if two <code>booleans</code>s are equal.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>boolean</code>\r\n-     * @param rhs  the right hand <code>boolean</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-      */\r\n-    public EqualsBuilder append(boolean lhs, boolean rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        isEquals = (lhs == rhs);\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\r\n-     *\r\n-     * <p>This also will be called for the top level of\r\n-     * multi-dimensional, ragged, and multi-typed arrays.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>Object[]</code>\r\n-     * @param rhs  the right hand <code>Object[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>long</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(long, long)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>long[]</code>\r\n-     * @param rhs  the right hand <code>long[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(long[] lhs, long[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>int</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(int, int)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>int[]</code>\r\n-     * @param rhs  the right hand <code>int[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(int[] lhs, int[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>short</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(short, short)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>short[]</code>\r\n-     * @param rhs  the right hand <code>short[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(short[] lhs, short[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>char</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(char, char)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>char[]</code>\r\n-     * @param rhs  the right hand <code>char[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(char[] lhs, char[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>byte</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(byte, byte)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>byte[]</code>\r\n-     * @param rhs  the right hand <code>byte[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>double</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(double, double)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>double[]</code>\r\n-     * @param rhs  the right hand <code>double[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(double[] lhs, double[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>float</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(float, float)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>float[]</code>\r\n-     * @param rhs  the right hand <code>float[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(float[] lhs, float[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Deep comparison of array of <code>boolean</code>. Length and all\r\n-     * values are compared.</p>\r\n-     *\r\n-     * <p>The method {@link #append(boolean, boolean)} is used.</p>\r\n-     *\r\n-     * @param lhs  the left hand <code>boolean[]</code>\r\n-     * @param rhs  the right hand <code>boolean[]</code>\r\n-     * @return EqualsBuilder - used to chain calls.\r\n-     */\r\n-    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\r\n-        if (isEquals == false) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == rhs) {\r\n-            return this;\r\n-        }\r\n-        if (lhs == null || rhs == null) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            this.setEquals(false);\r\n-            return this;\r\n-        }\r\n-        for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n-            append(lhs[i], rhs[i]);\r\n-        }\r\n-        return this;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Returns <code>true</code> if the fields that have been checked\r\n-     * are all equal.</p>\r\n-     *\r\n-     * @return boolean\r\n-     */\r\n-    public boolean isEquals() {\r\n-        return this.isEquals;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Returns <code>true</code> if the fields that have been checked\r\n-     * are all equal.</p>\r\n-     *\r\n-     * @return <code>true</code> if all of the fields that have been checked\r\n-     *         are equal, <code>false</code> otherwise.\r\n-     *\r\n-     * @since 3.0\r\n-     */\r\n-    public Boolean build() {\r\n-        return Boolean.valueOf(isEquals());\r\n-    }\r\n-\r\n-    /**\r\n-     * Sets the <code>isEquals</code> value.\r\n-     *\r\n-     * @param isEquals The value to set.\r\n-     * @since 2.1\r\n-     */\r\n-    protected void setEquals(boolean isEquals) {\r\n-        this.isEquals = isEquals;\r\n-    }\r\n-\r\n-    /**\r\n-     * Reset the EqualsBuilder so you can use the same object again\r\n-     * @since 2.5\r\n-     */\r\n-    public void reset() {\r\n-        this.isEquals = true;\r\n-    }\r\n+  /**\r\n+   * <p>\r\n+   * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @since 3.0\r\n+   */\r\n+  private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n+\r\n+  /*\r\n+   * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n+   * we are in the process of calculating.\r\n+   *\r\n+   * So we generate a one-to-one mapping from the original object to a new object.\r\n+   *\r\n+   * Now HashSet uses equals() to determine if two elements with the same hashcode really\r\n+   * are equal, so we also need to ensure that the replacement objects are only equal\r\n+   * if the original objects are identical.\r\n+   *\r\n+   * The original implementation (2.4 and before) used the System.indentityHashCode()\r\n+   * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\r\n+   *\r\n+   * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\r\n+   * to disambiguate the duplicate ids.\r\n+   */\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Returns the registry of object pairs being traversed by the reflection\r\n+   * methods in the current thread.\r\n+   * </p>\r\n+   *\r\n+   * @return Set the registry of objects being traversed\r\n+   * @since 3.0\r\n+   */\r\n+  static Set<Pair<IDKey, IDKey>> getRegistry() {\r\n+    return REGISTRY.get();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Converters value pair into a register pair.\r\n+   * </p>\r\n+   *\r\n+   * @param lhs <code>this</code> object\r\n+   * @param rhs the other object\r\n+   *\r\n+   * @return the pair\r\n+   */\r\n+  static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\r\n+    IDKey left = new IDKey(lhs);\r\n+    IDKey right = new IDKey(rhs);\r\n+    return Pair.of(left, right);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Returns <code>true</code> if the registry contains the given object pair.\r\n+   * Used by the reflection methods to avoid infinite loops.\r\n+   * Objects might be swapped therefore a check is needed if the object pair\r\n+   * is registered in given or swapped order.\r\n+   * </p>\r\n+   *\r\n+   * @param lhs <code>this</code> object to lookup in registry\r\n+   * @param rhs the other object to lookup on registry\r\n+   * @return boolean <code>true</code> if the registry contains the given object.\r\n+   * @since 3.0\r\n+   */\r\n+  static boolean isRegistered(Object lhs, Object rhs) {\r\n+    Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n+    Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n+    Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\r\n+\r\n+    return registry != null\r\n+      && (registry.contains(pair) || registry.contains(swappedPair));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Registers the given object pair.\r\n+   * Used by the reflection methods to avoid infinite loops.\r\n+   * </p>\r\n+   *\r\n+   * @param lhs <code>this</code> object to register\r\n+   * @param rhs the other object to register\r\n+   */\r\n+  static void register(Object lhs, Object rhs) {\r\n+    synchronized (EqualsBuilder.class) {\r\n+      if (getRegistry() == null) {\r\n+        REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\r\n+      }\r\n+    }\r\n+\r\n+    Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n+    Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n+    registry.add(pair);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Unregisters the given object pair.\r\n+   * </p>\r\n+   *\r\n+   * <p>\r\n+   * Used by the reflection methods to avoid infinite loops.\r\n+   *\r\n+   * @param lhs <code>this</code> object to unregister\r\n+   * @param rhs the other object to unregister\r\n+   * @since 3.0\r\n+   */\r\n+  static void unregister(Object lhs, Object rhs) {\r\n+    Set<Pair<IDKey, IDKey>> registry = getRegistry();\r\n+    if (registry != null) {\r\n+      Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n+      registry.remove(pair);\r\n+      synchronized (EqualsBuilder.class) {\r\n+        //read again\r\n+        registry = getRegistry();\r\n+        if (registry != null && registry.isEmpty()) {\r\n+          REGISTRY.remove();\r\n+        }\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * If the fields tested are equals.\r\n+   * The default value is <code>true</code>.\r\n+   */\r\n+  private boolean isEquals = true;\r\n+\r\n+  /**\r\n+   * <p>Constructor for EqualsBuilder.</p>\r\n+   *\r\n+   * <p>Starts off assuming that equals is <code>true</code>.</p>\r\n+   * @see Object#equals(Object)\r\n+   */\r\n+  public EqualsBuilder() {\r\n+    // do nothing for now.\r\n+  }\r\n+\r\n+  //-------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n+   * are equal.</p>\r\n+   *\r\n+   * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n+   * fields. This means that it will throw a security exception if run under\r\n+   * a security manager, if the permissions are not set up correctly. It is also\r\n+   * not as efficient as testing explicitly.</p>\r\n+   *\r\n+   * <p>Transient members will be not be tested, as they are likely derived\r\n+   * fields, and not part of the value of the Object.</p>\r\n+   *\r\n+   * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n+   *\r\n+   * @param lhs  <code>this</code> object\r\n+   * @param rhs  the other object\r\n+   * @param excludeFields  Collection of String field names to exclude from testing\r\n+   * @return <code>true</code> if the two Objects have tested equals.\r\n+   */\r\n+  public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\r\n+    return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n+   * are equal.</p>\r\n+   *\r\n+   * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n+   * fields. This means that it will throw a security exception if run under\r\n+   * a security manager, if the permissions are not set up correctly. It is also\r\n+   * not as efficient as testing explicitly.</p>\r\n+   *\r\n+   * <p>Transient members will be not be tested, as they are likely derived\r\n+   * fields, and not part of the value of the Object.</p>\r\n+   *\r\n+   * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n+   *\r\n+   * @param lhs  <code>this</code> object\r\n+   * @param rhs  the other object\r\n+   * @param excludeFields  array of field names to exclude from testing\r\n+   * @return <code>true</code> if the two Objects have tested equals.\r\n+   */\r\n+  public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\r\n+    return reflectionEquals(lhs, rhs, false, null, excludeFields);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n+   * are equal.</p>\r\n+   *\r\n+   * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n+   * fields. This means that it will throw a security exception if run under\r\n+   * a security manager, if the permissions are not set up correctly. It is also\r\n+   * not as efficient as testing explicitly.</p>\r\n+   *\r\n+   * <p>If the TestTransients parameter is set to <code>true</code>, transient\r\n+   * members will be tested, otherwise they are ignored, as they are likely\r\n+   * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n+   *\r\n+   * <p>Static fields will not be tested. Superclass fields will be included.</p>\r\n+   *\r\n+   * @param lhs  <code>this</code> object\r\n+   * @param rhs  the other object\r\n+   * @param testTransients  whether to include transient fields\r\n+   * @return <code>true</code> if the two Objects have tested equals.\r\n+   */\r\n+  public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\r\n+    return reflectionEquals(lhs, rhs, testTransients, null);\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>This method uses reflection to determine if the two <code>Object</code>s\r\n+   * are equal.</p>\r\n+   *\r\n+   * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\r\n+   * fields. This means that it will throw a security exception if run under\r\n+   * a security manager, if the permissions are not set up correctly. It is also\r\n+   * not as efficient as testing explicitly.</p>\r\n+   *\r\n+   * <p>If the testTransients parameter is set to <code>true</code>, transient\r\n+   * members will be tested, otherwise they are ignored, as they are likely\r\n+   * derived fields, and not part of the value of the <code>Object</code>.</p>\r\n+   *\r\n+   * <p>Static fields will not be included. Superclass fields will be appended\r\n+   * up to and including the specified superclass. A null superclass is treated\r\n+   * as java.lang.Object.</p>\r\n+   *\r\n+   * @param lhs  <code>this</code> object\r\n+   * @param rhs  the other object\r\n+   * @param testTransients  whether to include transient fields\r\n+   * @param reflectUpToClass  the superclass to reflect up to (inclusive),\r\n+   *  may be <code>null</code>\r\n+   * @param excludeFields  array of field names to exclude from testing\r\n+   * @return <code>true</code> if the two Objects have tested equals.\r\n+   * @since 2.0\r\n+   */\r\n+  public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\r\n+                                         String... excludeFields) {\r\n+    if (lhs == rhs) {\r\n+      return true;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      return false;\r\n+    }\r\n+    // Find the leaf class since there may be transients in the leaf\r\n+    // class or in classes between the leaf and root.\r\n+    // If we are not testing transients or a subclass has no ivars,\r\n+    // then a subclass can test equals to a superclass.\r\n+    Class<?> lhsClass = lhs.getClass();\r\n+    Class<?> rhsClass = rhs.getClass();\r\n+    Class<?> testClass;\r\n+    if (lhsClass.isInstance(rhs)) {\r\n+      testClass = lhsClass;\r\n+      if (!rhsClass.isInstance(lhs)) {\r\n+        // rhsClass is a subclass of lhsClass\r\n+        testClass = rhsClass;\r\n+      }\r\n+    } else if (rhsClass.isInstance(lhs)) {\r\n+      testClass = rhsClass;\r\n+      if (!lhsClass.isInstance(rhs)) {\r\n+        // lhsClass is a subclass of rhsClass\r\n+        testClass = lhsClass;\r\n+      }\r\n+    } else {\r\n+      // The two classes are not related.\r\n+      return false;\r\n+    }\r\n+    EqualsBuilder equalsBuilder = new EqualsBuilder();\r\n+    try {\r\n+      reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n+      while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\r\n+        testClass = testClass.getSuperclass();\r\n+        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\r\n+      }\r\n+    } catch (IllegalArgumentException e) {\r\n+      // In this case, we tried to test a subclass vs. a superclass and\r\n+      // the subclass has ivars or the ivars are transient and\r\n+      // we are testing transients.\r\n+      // If a subclass has ivars that we are trying to test them, we get an\r\n+      // exception and we know that the objects are not equal.\r\n+      return false;\r\n+    }\r\n+    return equalsBuilder.isEquals();\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Appends the fields and values defined by the given object of the\r\n+   * given Class.</p>\r\n+   *\r\n+   * @param lhs  the left hand object\r\n+   * @param rhs  the right hand object\r\n+   * @param clazz  the class to append details of\r\n+   * @param builder  the builder to append to\r\n+   * @param useTransients  whether to test transient fields\r\n+   * @param excludeFields  array of field names to exclude from testing\r\n+   */\r\n+  private static void reflectionAppend(\r\n+    Object lhs,\r\n+    Object rhs,\r\n+    Class<?> clazz,\r\n+    EqualsBuilder builder,\r\n+    boolean useTransients,\r\n+    String[] excludeFields) {\r\n+\r\n+    if (isRegistered(lhs, rhs)) {\r\n+      return;\r\n+    }\r\n+\r\n+    try {\r\n+      register(lhs, rhs);\r\n+      Field[] fields = clazz.getDeclaredFields();\r\n+      AccessibleObject.setAccessible(fields, true);\r\n+      for (int i = 0; i < fields.length && builder.isEquals; i++) {\r\n+        Field f = fields[i];\r\n+        if (!ArrayUtils.contains(excludeFields, f.getName())\r\n+          && (f.getName().indexOf('$') == -1)\r\n+          && (useTransients || !Modifier.isTransient(f.getModifiers()))\r\n+          && (!Modifier.isStatic(f.getModifiers()))) {\r\n+          try {\r\n+            builder.append(f.get(lhs), f.get(rhs));\r\n+          } catch (IllegalAccessException e) {\r\n+            //this can't happen. Would get a Security exception instead\r\n+            //throw a runtime exception in case the impossible happens.\r\n+            throw new InternalError(\"Unexpected IllegalAccessException\");\r\n+          }\r\n+        }\r\n+      }\r\n+    } finally {\r\n+      unregister(lhs, rhs);\r\n+    }\r\n+  }\r\n+\r\n+  //-------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\r\n+   *\r\n+   * @param superEquals  the result of calling <code>super.equals()</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   * @since 2.0\r\n+   */\r\n+  public EqualsBuilder appendSuper(boolean superEquals) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = superEquals;\r\n+    return this;\r\n+  }\r\n+\r\n+  //-------------------------------------------------------------------------\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>Object</code>s are equal using their\r\n+   * <code>equals</code> method.</p>\r\n+   *\r\n+   * @param lhs  the left hand object\r\n+   * @param rhs  the right hand object\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(Object lhs, Object rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    Class<?> lhsClass = lhs.getClass();\r\n+    if (!lhsClass.isArray()) {\r\n+      // The simple case, not an array, just test the element\r\n+      isEquals = lhs.equals(rhs);\r\n+    } else if (lhs.getClass() != rhs.getClass()) {\r\n+      // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n+      this.setEquals(false);\r\n+    }\r\n+    // 'Switch' on type of array, to dispatch to the correct handler\r\n+    // This handles multi dimensional arrays of the same depth\r\n+    else if (lhs instanceof long[]) {\r\n+      append((long[]) lhs, (long[]) rhs);\r\n+    } else if (lhs instanceof int[]) {\r\n+      append((int[]) lhs, (int[]) rhs);\r\n+    } else if (lhs instanceof short[]) {\r\n+      append((short[]) lhs, (short[]) rhs);\r\n+    } else if (lhs instanceof char[]) {\r\n+      append((char[]) lhs, (char[]) rhs);\r\n+    } else if (lhs instanceof byte[]) {\r\n+      append((byte[]) lhs, (byte[]) rhs);\r\n+    } else if (lhs instanceof double[]) {\r\n+      append((double[]) lhs, (double[]) rhs);\r\n+    } else if (lhs instanceof float[]) {\r\n+      append((float[]) lhs, (float[]) rhs);\r\n+    } else if (lhs instanceof boolean[]) {\r\n+      append((boolean[]) lhs, (boolean[]) rhs);\r\n+    } else {\r\n+      // Not an array of primitives\r\n+      append((Object[]) lhs, (Object[]) rhs);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>\r\n+   * Test if two <code>long</code> s are equal.\r\n+   * </p>\r\n+   *\r\n+   * @param lhs\r\n+   *                  the left hand <code>long</code>\r\n+   * @param rhs\r\n+   *                  the right hand <code>long</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(long lhs, long rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>int</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>int</code>\r\n+   * @param rhs  the right hand <code>int</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(int lhs, int rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>short</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>short</code>\r\n+   * @param rhs  the right hand <code>short</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(short lhs, short rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>char</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>char</code>\r\n+   * @param rhs  the right hand <code>char</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(char lhs, char rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>byte</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>byte</code>\r\n+   * @param rhs  the right hand <code>byte</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(byte lhs, byte rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>double</code>s are equal by testing that the\r\n+   * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\r\n+   *\r\n+   * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n+   *\r\n+   * <p>It is compatible with the hash code generated by\r\n+   * <code>HashCodeBuilder</code>.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>double</code>\r\n+   * @param rhs  the right hand <code>double</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(double lhs, double rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>float</code>s are equal byt testing that the\r\n+   * pattern of bits returned by doubleToLong are equal.</p>\r\n+   *\r\n+   * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\r\n+   *\r\n+   * <p>It is compatible with the hash code generated by\r\n+   * <code>HashCodeBuilder</code>.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>float</code>\r\n+   * @param rhs  the right hand <code>float</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(float lhs, float rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Test if two <code>booleans</code>s are equal.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>boolean</code>\r\n+   * @param rhs  the right hand <code>boolean</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(boolean lhs, boolean rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    isEquals = (lhs == rhs);\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\r\n+   *\r\n+   * <p>This also will be called for the top level of\r\n+   * multi-dimensional, ragged, and multi-typed arrays.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>Object[]</code>\r\n+   * @param rhs  the right hand <code>Object[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(Object[] lhs, Object[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>long</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(long, long)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>long[]</code>\r\n+   * @param rhs  the right hand <code>long[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(long[] lhs, long[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>int</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(int, int)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>int[]</code>\r\n+   * @param rhs  the right hand <code>int[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(int[] lhs, int[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>short</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(short, short)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>short[]</code>\r\n+   * @param rhs  the right hand <code>short[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(short[] lhs, short[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>char</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(char, char)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>char[]</code>\r\n+   * @param rhs  the right hand <code>char[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(char[] lhs, char[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>byte</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(byte, byte)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>byte[]</code>\r\n+   * @param rhs  the right hand <code>byte[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(byte[] lhs, byte[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>double</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(double, double)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>double[]</code>\r\n+   * @param rhs  the right hand <code>double[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(double[] lhs, double[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>float</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(float, float)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>float[]</code>\r\n+   * @param rhs  the right hand <code>float[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(float[] lhs, float[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Deep comparison of array of <code>boolean</code>. Length and all\r\n+   * values are compared.</p>\r\n+   *\r\n+   * <p>The method {@link #append(boolean, boolean)} is used.</p>\r\n+   *\r\n+   * @param lhs  the left hand <code>boolean[]</code>\r\n+   * @param rhs  the right hand <code>boolean[]</code>\r\n+   * @return EqualsBuilder - used to chain calls.\r\n+   */\r\n+  public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\r\n+    if (isEquals == false) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == rhs) {\r\n+      return this;\r\n+    }\r\n+    if (lhs == null || rhs == null) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    if (lhs.length != rhs.length) {\r\n+      this.setEquals(false);\r\n+      return this;\r\n+    }\r\n+    for (int i = 0; i < lhs.length && isEquals; ++i) {\r\n+      append(lhs[i], rhs[i]);\r\n+    }\r\n+    return this;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Returns <code>true</code> if the fields that have been checked\r\n+   * are all equal.</p>\r\n+   *\r\n+   * @return boolean\r\n+   */\r\n+  public boolean isEquals() {\r\n+    return this.isEquals;\r\n+  }\r\n+\r\n+  /**\r\n+   * <p>Returns <code>true</code> if the fields that have been checked\r\n+   * are all equal.</p>\r\n+   *\r\n+   * @return <code>true</code> if all of the fields that have been checked\r\n+   *         are equal, <code>false</code> otherwise.\r\n+   *\r\n+   * @since 3.0\r\n+   */\r\n+  public Boolean build() {\r\n+    return Boolean.valueOf(isEquals());\r\n+  }\r\n+\r\n+  /**\r\n+   * Sets the <code>isEquals</code> value.\r\n+   *\r\n+   * @param isEquals The value to set.\r\n+   * @since 2.1\r\n+   */\r\n+  protected void setEquals(boolean isEquals) {\r\n+    this.isEquals = isEquals;\r\n+  }\r\n+\r\n+  /**\r\n+   * Reset the EqualsBuilder so you can use the same object again\r\n+   * @since 2.5\r\n+   */\r\n+  public void reset() {\r\n+    this.isEquals = true;\r\n+  }\r\n }\r\n",
            "diff_size": 864
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "107",
                    "column": "60",
                    "severity": "warning",
                    "message": "'>' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "414",
                    "severity": "warning",
                    "message": "Line is longer than 200 characters (found 211).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "474",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/naturalize/11/EqualsBuilder.java\nindex f02aebb379e..a673c1c0cd4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/naturalize/11/EqualsBuilder.java\n@@ -104,7 +104,7 @@ public class EqualsBuilder implements Builder<Boolean> {\n      *\r\n      * @since 3.0\r\n      */\r\n-    private static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n+    private static final ThreadLocal<Set<Pair<IDKey, IDKey >>> REGISTRY = new ThreadLocal<Set<Pair<IDKey, IDKey>>>();\r\n \r\n     /*\r\n      * NOTE: we cannot store the actual objects in a HashSet, as that would use the very hashCode()\r\n@@ -170,8 +170,7 @@ public class EqualsBuilder implements Builder<Boolean> {\n         Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\r\n         Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\r\n \r\n-        return registry != null\r\n-                && (registry.contains(pair) || registry.contains(swappedPair));\r\n+        return registry != null && (registry.contains(pair) || registry.contains(swappedPair));\r\n     }\r\n \r\n     /**\r\n@@ -336,8 +335,7 @@ public class EqualsBuilder implements Builder<Boolean> {\n      * @return <code>true</code> if the two Objects have tested equals.\r\n      * @since 2.0\r\n      */\r\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\r\n-            String... excludeFields) {\r\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass, String... excludeFields) {\r\n         if (lhs == rhs) {\r\n             return true;\r\n         }\r\n@@ -402,9 +400,8 @@ public class EqualsBuilder implements Builder<Boolean> {\n         Class<?> clazz,\r\n         EqualsBuilder builder,\r\n         boolean useTransients,\r\n-        String[] excludeFields) {\r\n-\r\n-        if (isRegistered(lhs, rhs)) {\r\n+        String[] excludeFields) {\n+    if (isRegistered(lhs, rhs)) {\r\n             return;\r\n         }\r\n \r\n@@ -414,11 +411,8 @@ public class EqualsBuilder implements Builder<Boolean> {\n             AccessibleObject.setAccessible(fields, true);\r\n             for (int i = 0; i < fields.length && builder.isEquals; i++) {\r\n                 Field f = fields[i];\r\n-                if (!ArrayUtils.contains(excludeFields, f.getName())\r\n-                    && (f.getName().indexOf('$') == -1)\r\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\r\n-                    && (!Modifier.isStatic(f.getModifiers()))) {\r\n-                    try {\r\n+                if (!ArrayUtils.contains(excludeFields, f.getName()) && (f.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(f.getModifiers())) && (!Modifier.isStatic(f.getModifiers()))) {\n+    try {\r\n                         builder.append(f.get(lhs), f.get(rhs));\r\n                     } catch (IllegalAccessException e) {\r\n                         //this can't happen. Would get a Security exception instead\r\n@@ -956,4 +950,4 @@ public class EqualsBuilder implements Builder<Boolean> {\n     public void reset() {\r\n         this.isEquals = true;\r\n     }\r\n-}\r\n+}\n\\ No newline at end of file\n",
            "diff_size": 14
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "480",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_random/11/EqualsBuilder.java\nindex f02aebb379e..241f00d62aa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_random/11/EqualsBuilder.java\n@@ -477,8 +477,7 @@ public class EqualsBuilder implements Builder<Boolean> {\n         } else if (lhs.getClass() != rhs.getClass()) {\r\n             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n             this.setEquals(false);\r\n-        }\r\n-        // 'Switch' on type of array, to dispatch to the correct handler\r\n+        } // 'Switch' on type of array, to dispatch to the correct handler\r\n         // This handles multi dimensional arrays of the same depth\r\n         else if (lhs instanceof long[]) {\r\n             append((long[]) lhs, (long[]) rhs);\r\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "479",
                    "column": "34",
                    "severity": "warning",
                    "message": "';' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                },
                {
                    "line": "479",
                    "column": "35",
                    "severity": "warning",
                    "message": "'}' at column 35 should have line break before.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_three_grams/11/EqualsBuilder.java\nindex f02aebb379e..753031887d7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/errored/1/11/EqualsBuilder.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Internet2-grouper/styler_three_grams/11/EqualsBuilder.java\n@@ -476,8 +476,7 @@ public class EqualsBuilder implements Builder<Boolean> {\n             isEquals = lhs.equals(rhs);\r\n         } else if (lhs.getClass() != rhs.getClass()) {\r\n             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n-            this.setEquals(false);\r\n-        }\r\n+            this.setEquals(false);}\r\n         // 'Switch' on type of array, to dispatch to the correct handler\r\n         // This handles multi dimensional arrays of the same depth\r\n         else if (lhs instanceof long[]) {\r\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}