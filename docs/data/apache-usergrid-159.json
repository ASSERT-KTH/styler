{
    "project_name": "apache-usergrid",
    "error_id": "159",
    "information": {
        "errors": [
            {
                "line": "51",
                "severity": "warning",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "\n/**\n * Should be referenced by services as a SchedulerService instance. Only the internal job \n * runtime should refer to this as a JobAccessor\n */\npublic class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobRuntimeService {",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "51",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "110",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "150",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "203",
                    "column": "13",
                    "severity": "warning",
                    "message": "'}' at column 13 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "229",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "298",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "355",
                    "column": "9",
                    "severity": "warning",
                    "message": "'}' at column 9 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "377",
                    "column": "21",
                    "severity": "warning",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.TypecastParenPadCheck"
                },
                {
                    "line": "377",
                    "column": "28",
                    "severity": "warning",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.TypecastParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/errored/1/159/SchedulerServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/intellij/159/SchedulerServiceImpl.java\nindex a44b4a0dce5..11bd70c734f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/errored/1/159/SchedulerServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/intellij/159/SchedulerServiceImpl.java\n@@ -14,6 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.usergrid.batch.service;\n \n \n@@ -48,7 +49,7 @@ import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.util.Assert;\n \n /**\n- * Should be referenced by services as a SchedulerService instance. Only the internal job \n+ * Should be referenced by services as a SchedulerService instance. Only the internal job\n  * runtime should refer to this as a JobAccessor\n  */\n public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobRuntimeService {\n@@ -59,19 +60,23 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n \n     private static final String JOB_NAME = \"jobName\";\n \n-    private static final Logger LOG = LoggerFactory.getLogger( SchedulerServiceImpl.class );\n+    private static final Logger LOG = LoggerFactory.getLogger(SchedulerServiceImpl.class);\n \n     private static final String DEFAULT_QUEUE_NAME = \"/jobs\";\n \n     private QueueManagerFactory qmf;\n+\n     private EntityManagerFactory emf;\n \n     private String jobQueueName = DEFAULT_QUEUE_NAME;\n \n     private QueueManager qm;\n+\n     private EntityManager em;\n \n-    /** Timeout for how long to set the transaction timeout from the queue. Default is 30000 */\n+    /**\n+     * Timeout for how long to set the transaction timeout from the queue. Default is 30000\n+     */\n     private long jobTimeout = 30000;\n \n \n@@ -90,39 +95,40 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * long, org.apache.usergrid.persistence.Entity)\n      */\n     @Override\n-    public JobData createJob( String jobName, long fireTime, JobData jobData ) {\n-        Assert.notNull( jobName, \"jobName is required\" );\n-        Assert.notNull( jobData, \"jobData is required\" );\n+    public JobData createJob(String jobName, long fireTime, JobData jobData) {\n+        Assert.notNull(jobName, \"jobName is required\");\n+        Assert.notNull(jobData, \"jobData is required\");\n \n         try {\n-            jobData.setJobName( jobName );\n-            JobData job = getEm().create( jobData );\n-            JobStat stat = getEm().create( new JobStat( jobName, job.getUuid() ) );\n+            jobData.setJobName(jobName);\n+            JobData job = getEm().create(jobData);\n+            JobStat stat = getEm().create(new JobStat(jobName, job.getUuid()));\n \n-            scheduleJob( jobName, fireTime, job.getUuid(), stat.getUuid() );\n+            scheduleJob(jobName, fireTime, job.getUuid(), stat.getUuid());\n \n             return job;\n-        }\n-        catch ( Exception e ) {\n-            throw new JobRuntimeException( e );\n+        } catch (Exception e) {\n+            throw new JobRuntimeException(e);\n         }\n     }\n \n \n-    /** Schedule the job internally */\n-    private void scheduleJob( String jobName, long fireTime, UUID jobDataId, UUID jobStatId ) {\n-        Assert.notNull( jobName, \"jobName is required\" );\n-        Assert.isTrue( fireTime > -1, \"fireTime must be positive\" );\n-        Assert.notNull( jobDataId, \"jobDataId is required\" );\n-        Assert.notNull( jobStatId, \"jobStatId is required\" );\n+    /**\n+     * Schedule the job internally\n+     */\n+    private void scheduleJob(String jobName, long fireTime, UUID jobDataId, UUID jobStatId) {\n+        Assert.notNull(jobName, \"jobName is required\");\n+        Assert.isTrue(fireTime > -1, \"fireTime must be positive\");\n+        Assert.notNull(jobDataId, \"jobDataId is required\");\n+        Assert.notNull(jobStatId, \"jobStatId is required\");\n \n         Message message = new Message();\n-        message.setTimestamp( fireTime );\n-        message.setStringProperty( JOB_NAME, jobName );\n-        message.setProperty( JOB_ID, jobDataId );\n-        message.setProperty( STATS_ID, jobStatId );\n+        message.setTimestamp(fireTime);\n+        message.setStringProperty(JOB_NAME, jobName);\n+        message.setProperty(JOB_ID, jobDataId);\n+        message.setProperty(STATS_ID, jobStatId);\n \n-        getQm().postToQueue( jobQueueName, message );\n+        getQm().postToQueue(jobQueueName, message);\n     }\n \n \n@@ -132,18 +138,17 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * @see org.apache.usergrid.batch.service.SchedulerService#deleteJob(java.util.UUID)\n      */\n     @Override\n-    public void deleteJob( UUID jobId ) {\n+    public void deleteJob(UUID jobId) {\n         /**\n          * just delete our target job data. This is easier than attempting to delete\n          * from the queue. The runner should catch this and treat the queued message\n          * as discarded\n          */\n         try {\n-            LOG.debug( \"deleteJob {}\", jobId );\n-            getEm().delete( new SimpleEntityRef( \"jobData\", jobId ) );\n-        }\n-        catch ( Exception e ) {\n-            throw new JobRuntimeException( e );\n+            LOG.debug(\"deleteJob {}\", jobId);\n+            getEm().delete(new SimpleEntityRef(\"jobData\", jobId));\n+        } catch (Exception e) {\n+            throw new JobRuntimeException(e);\n         }\n     }\n \n@@ -154,55 +159,54 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * @see org.apache.usergrid.batch.repository.JobAccessor#getJobs(int)\n      */\n     @Override\n-    public List<JobDescriptor> getJobs( int size ) {\n+    public List<JobDescriptor> getJobs(int size) {\n         QueueQuery query = new QueueQuery();\n-        query.setTimeout( jobTimeout );\n-        query.setLimit( size );\n+        query.setTimeout(jobTimeout);\n+        query.setLimit(size);\n \n-        QueueResults jobs = getQm().getFromQueue( jobQueueName, query );\n+        QueueResults jobs = getQm().getFromQueue(jobQueueName, query);\n \n-        List<JobDescriptor> results = new ArrayList<JobDescriptor>( jobs.size() );\n+        List<JobDescriptor> results = new ArrayList<JobDescriptor>(jobs.size());\n \n-        for ( Message job : jobs.getMessages() ) {\n+        for (Message job : jobs.getMessages()) {\n \n-            UUID jobUuid = UUID.fromString( job.getStringProperty( JOB_ID ) );\n-            UUID statsUuid = UUID.fromString( job.getStringProperty( STATS_ID ) );\n-            String jobName = job.getStringProperty( JOB_NAME );\n+            UUID jobUuid = UUID.fromString(job.getStringProperty(JOB_ID));\n+            UUID statsUuid = UUID.fromString(job.getStringProperty(STATS_ID));\n+            String jobName = job.getStringProperty(JOB_NAME);\n \n             try {\n-                JobData data = getEm().get( jobUuid, JobData.class );\n+                JobData data = getEm().get(jobUuid, JobData.class);\n \n-                JobStat stats = getEm().get( statsUuid, JobStat.class );\n+                JobStat stats = getEm().get(statsUuid, JobStat.class);\n \n                 /**\n                  * no job data, which is required even if empty to signal the job should\n                  * still fire. Ignore this job\n                  */\n-                if ( data == null || stats == null ) {\n-                    LOG.info( \"Received job with data id '{}' from the queue, but no data was found.  Dropping job\",\n-                            jobUuid );\n-                    getQm().deleteTransaction( jobQueueName, job.getTransaction(), null );\n+                if (data == null || stats == null) {\n+                    LOG.info(\"Received job with data id '{}' from the queue, but no data was found.  Dropping job\",\n+                        jobUuid);\n+                    getQm().deleteTransaction(jobQueueName, job.getTransaction(), null);\n \n-                    if ( data != null ) {\n-                        getEm().delete( data );\n+                    if (data != null) {\n+                        getEm().delete(data);\n                     }\n \n-                    if ( stats != null ) {\n-                        getEm().delete( stats );\n+                    if (stats != null) {\n+                        getEm().delete(stats);\n                     }\n \n                     continue;\n                 }\n \n-                results.add( new JobDescriptor( jobName, job.getUuid(), job.getTransaction(), data, stats, this ) );\n-            }\n-            catch ( Exception e ) {\n+                results.add(new JobDescriptor(jobName, job.getUuid(), job.getTransaction(), data, stats, this));\n+            } catch (Exception e) {\n                 // log and skip. This is a catastrophic runtime error if we see an\n                 // exception here. We don't want to cause job loss, so leave the job in\n                 // the Q.\n                 LOG.error(\n-                        \"Unable to retrieve job data for jobname {}, job id {}, stats id {}.  Skipping to avoid job \"\n-                                + \"loss\", new Object[] { jobName, jobUuid, statsUuid, e } );\n+                    \"Unable to retrieve job data for jobname {}, job id {}, stats id {}.  Skipping to avoid job \"\n+                        + \"loss\", new Object[] {jobName, jobUuid, statsUuid, e});\n             }\n         }\n \n@@ -211,21 +215,20 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n \n \n     @Override\n-    public void heartbeat( JobRuntime execution, long delay ) {\n-        LOG.debug( \"renew transaction {}\", execution.getTransactionId() );\n+    public void heartbeat(JobRuntime execution, long delay) {\n+        LOG.debug(\"renew transaction {}\", execution.getTransactionId());\n         try {\n             // @TODO - what's the point to this sychronized block on an argument?\n-            synchronized ( execution ) {\n-                UUID newId = getQm().renewTransaction( jobQueueName, execution.getTransactionId(),\n-                        new QueueQuery().withTimeout( delay ) );\n+            synchronized (execution) {\n+                UUID newId = getQm().renewTransaction(jobQueueName, execution.getTransactionId(),\n+                    new QueueQuery().withTimeout(delay));\n \n-                execution.setTransactionId( newId );\n-                LOG.debug( \"renewed transaction {}\", newId );\n+                execution.setTransactionId(newId);\n+                LOG.debug(\"renewed transaction {}\", newId);\n             }\n-        }\n-        catch ( TransactionNotFoundException e ) {\n-            LOG.error( \"Could not renew transaction\", e );\n-            throw new JobRuntimeException( \"Could not renew transaction during heartbeat\", e );\n+        } catch (TransactionNotFoundException e) {\n+            LOG.error(\"Could not renew transaction\", e);\n+            throw new JobRuntimeException(\"Could not renew transaction during heartbeat\", e);\n         }\n     }\n \n@@ -234,8 +237,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * @see org.apache.usergrid.batch.service.JobRuntimeService#heartbeat(org.apache.usergrid.batch.JobRuntime)\n      */\n     @Override\n-    public void heartbeat( JobRuntime execution ) {\n-        heartbeat( execution, jobTimeout );\n+    public void heartbeat(JobRuntime execution) {\n+        heartbeat(execution, jobTimeout);\n     }\n \n \n@@ -246,8 +249,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * JobExecutionImpl)\n      */\n     @Override\n-    public void delay( JobRuntime execution ) {\n-        delayRetry( execution.getExecution(), execution.getDelay() );\n+    public void delay(JobRuntime execution) {\n+        delayRetry(execution.getExecution(), execution.getDelay());\n     }\n \n \n@@ -259,7 +262,7 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * )\n      */\n     @Override\n-    public void save( JobExecution bulkJobExecution ) {\n+    public void save(JobExecution bulkJobExecution) {\n \n         JobData data = bulkJobExecution.getJobData();\n         JobStat stat = bulkJobExecution.getJobStats();\n@@ -269,33 +272,32 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n         try {\n \n             // we're done. Mark the transaction as complete and delete the job info\n-            if ( jobStatus == Status.COMPLETED ) {\n-                LOG.info( \"Job {} is complete id: {}\", data.getJobName(), bulkJobExecution.getTransactionId() );\n-                getQm().deleteTransaction( jobQueueName, bulkJobExecution.getTransactionId(), null );\n-                LOG.debug( \"delete job data {}\", data.getUuid() );\n-                getEm().delete( data );\n+            if (jobStatus == Status.COMPLETED) {\n+                LOG.info(\"Job {} is complete id: {}\", data.getJobName(), bulkJobExecution.getTransactionId());\n+                getQm().deleteTransaction(jobQueueName, bulkJobExecution.getTransactionId(), null);\n+                LOG.debug(\"delete job data {}\", data.getUuid());\n+                getEm().delete(data);\n             }\n \n             // the job failed too many times. Delete the transaction to prevent it\n             // running again and save it for querying later\n-            else if ( jobStatus == Status.DEAD ) {\n-                LOG.warn( \"Job {} is dead.  Removing\", data.getJobName() );\n-                getQm().deleteTransaction( jobQueueName, bulkJobExecution.getTransactionId(), null );\n-                getEm().update( data );\n+            else if (jobStatus == Status.DEAD) {\n+                LOG.warn(\"Job {} is dead.  Removing\", data.getJobName());\n+                getQm().deleteTransaction(jobQueueName, bulkJobExecution.getTransactionId(), null);\n+                getEm().update(data);\n             }\n \n             // update the job for the next run\n             else {\n-                getEm().update( data );\n+                getEm().update(data);\n             }\n \n-            LOG.info( \"Updating stats for job {}\", data.getJobName() );\n+            LOG.info(\"Updating stats for job {}\", data.getJobName());\n \n-            getEm().update( stat );\n-        }\n-        catch ( Exception e ) {\n+            getEm().update(stat);\n+        } catch (Exception e) {\n             // should never happen\n-            throw new JobRuntimeException( String.format( \"Unable to delete job data with id %s\", data.getUuid() ), e );\n+            throw new JobRuntimeException(String.format(\"Unable to delete job data with id %s\", data.getUuid()), e);\n         }\n     }\n \n@@ -307,13 +309,13 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * persistence.Query)\n      */\n     @Override\n-    public Results queryJobData( Query query ) throws Exception {\n+    public Results queryJobData(Query query) throws Exception {\n \n-        if ( query == null ) {\n+        if (query == null) {\n             query = new Query();\n         }\n \n-        return getEm().searchCollection( getEm().getApplicationRef(), \"job_data\", query );\n+        return getEm().searchCollection(getEm().getApplicationRef(), \"job_data\", query);\n     }\n \n \n@@ -325,7 +327,7 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * .JobExecution, long)\n      */\n     @Override\n-    public void delayRetry( JobExecution execution, long delay ) {\n+    public void delayRetry(JobExecution execution, long delay) {\n \n         JobData data = execution.getJobData();\n         JobStat stat = execution.getJobStats();\n@@ -333,27 +335,26 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n         try {\n \n             // if it's a dead status, it's failed too many times, just kill the job\n-            if ( execution.getStatus() == Status.DEAD ) {\n-                getQm().deleteTransaction( jobQueueName, execution.getTransactionId(), null );\n-                getEm().update( data );\n-                getEm().update( stat );\n+            if (execution.getStatus() == Status.DEAD) {\n+                getQm().deleteTransaction(jobQueueName, execution.getTransactionId(), null);\n+                getEm().update(data);\n+                getEm().update(stat);\n                 return;\n             }\n \n             // re-schedule the job to run again in the future\n-            scheduleJob( execution.getJobName(), System.currentTimeMillis() + delay, data.getUuid(), stat.getUuid() );\n+            scheduleJob(execution.getJobName(), System.currentTimeMillis() + delay, data.getUuid(), stat.getUuid());\n \n             // delete the pending transaction\n-            getQm().deleteTransaction( jobQueueName, execution.getTransactionId(), null );\n+            getQm().deleteTransaction(jobQueueName, execution.getTransactionId(), null);\n \n             // update the data for the next run\n \n-            getEm().update( data );\n-            getEm().update( stat );\n-        }\n-        catch ( Exception e ) {\n+            getEm().update(data);\n+            getEm().update(stat);\n+        } catch (Exception e) {\n             // should never happen\n-            throw new JobRuntimeException( String.format( \"Unable to delete job data with id %s\", data.getUuid() ), e );\n+            throw new JobRuntimeException(String.format(\"Unable to delete job data with id %s\", data.getUuid()), e);\n         }\n     }\n \n@@ -362,59 +363,67 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * @see org.apache.usergrid.batch.service.SchedulerService#getStatsForJob(java.lang.String, java.util.UUID)\n      */\n     @Override\n-    public JobStat getStatsForJob( String jobName, UUID jobId ) throws Exception {\n-        EntityManager em = emf.getEntityManager( emf.getManagementAppId() );\n+    public JobStat getStatsForJob(String jobName, UUID jobId) throws Exception {\n+        EntityManager em = emf.getEntityManager(emf.getManagementAppId());\n \n \n         Query query = new Query();\n-        query.addEqualityFilter( JOB_NAME, jobName );\n-        query.addEqualityFilter( JOB_ID, jobId );\n+        query.addEqualityFilter(JOB_NAME, jobName);\n+        query.addEqualityFilter(JOB_ID, jobId);\n \n-        Results r = em.searchCollection( em.getApplicationRef(), \"job_stats\", query );\n+        Results r = em.searchCollection(em.getApplicationRef(), \"job_stats\", query);\n \n-        if ( r.size() == 1 ) {\n-            return ( JobStat ) r.getEntity();\n+        if (r.size() == 1) {\n+            return (JobStat) r.getEntity();\n         }\n \n         return null;\n     }\n \n \n-    /** @param qmf the qmf to set */\n+    /**\n+     * @param qmf the qmf to set\n+     */\n     @Autowired\n-    public void setQmf( QueueManagerFactory qmf ) {\n+    public void setQmf(QueueManagerFactory qmf) {\n         this.qmf = qmf;\n     }\n \n \n-    /** @param emf the emf to set */\n+    /**\n+     * @param emf the emf to set\n+     */\n     @Autowired\n-    public void setEmf( EntityManagerFactory emf ) {\n+    public void setEmf(EntityManagerFactory emf) {\n         this.emf = emf;\n     }\n \n \n-    /** @param jobQueueName the jobQueueName to set */\n-    public void setJobQueueName( String jobQueueName ) {\n+    /**\n+     * @param jobQueueName the jobQueueName to set\n+     */\n+    public void setJobQueueName(String jobQueueName) {\n         this.jobQueueName = jobQueueName;\n     }\n \n \n-    /** @param timeout the timeout to set */\n-    public void setJobTimeout( long timeout ) {\n+    /**\n+     * @param timeout the timeout to set\n+     */\n+    public void setJobTimeout(long timeout) {\n         this.jobTimeout = timeout;\n     }\n \n     public QueueManager getQm() {\n-        if ( qm == null ) {\n-            this.qm = qmf.getQueueManager( emf.getManagementAppId());\n+        if (qm == null) {\n+            this.qm = qmf.getQueueManager(emf.getManagementAppId());\n         }\n         return qm;\n     }\n \n     public EntityManager getEm() {\n-        if ( em == null  ) {\n-            this.em = emf.getEntityManager( emf.getManagementAppId());\n+        if (em == null) {\n+            this.em = emf.getEntityManager(emf.getManagementAppId());\n         }\n         return em;\n     }\n",
            "diff_size": 134
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "51",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/errored/1/159/SchedulerServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/naturalize/159/SchedulerServiceImpl.java\nindex a44b4a0dce5..5537ea5fa5a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/errored/1/159/SchedulerServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/naturalize/159/SchedulerServiceImpl.java\n@@ -407,14 +407,14 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n \n     public QueueManager getQm() {\n         if ( qm == null ) {\n-            this.qm = qmf.getQueueManager( emf.getManagementAppId());\n+            this.qm = qmf.getQueueManager( emf.getManagementAppId() );\n         }\n         return qm;\n     }\n \n     public EntityManager getEm() {\n-        if ( em == null  ) {\n-            this.em = emf.getEntityManager( emf.getManagementAppId());\n+        if ( em == null ) {\n+            this.em = emf.getEntityManager( emf.getManagementAppId() );\n         }\n         return em;\n     }\n@@ -423,4 +423,4 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n     public void refreshIndex() {\n         getEm().refreshIndex();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "48",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "194",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 145).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "212",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/errored/1/159/SchedulerServiceImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/codebuff/159/SchedulerServiceImpl.java\nindex a44b4a0dce5..6fff2ea8001 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/errored/1/159/SchedulerServiceImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/apache-usergrid/codebuff/159/SchedulerServiceImpl.java\n@@ -20,8 +20,6 @@ package org.apache.usergrid.batch.service;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.UUID;\n-\n-\n import org.apache.usergrid.batch.JobExecution;\n import org.apache.usergrid.batch.JobExecution.Status;\n import org.apache.usergrid.batch.JobRuntime;\n@@ -41,7 +39,6 @@ import org.apache.usergrid.persistence.SimpleEntityRef;\n import org.apache.usergrid.persistence.entities.JobData;\n import org.apache.usergrid.persistence.entities.JobStat;\n import org.apache.usergrid.persistence.exceptions.TransactionNotFoundException;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n@@ -51,23 +48,18 @@ import org.springframework.util.Assert;\n  * Should be referenced by services as a SchedulerService instance. Only the internal job \n  * runtime should refer to this as a JobAccessor\n  */\n+\n+\n public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobRuntimeService {\n \n     private static final String STATS_ID = \"statsId\";\n-\n     private static final String JOB_ID = \"jobId\";\n-\n     private static final String JOB_NAME = \"jobName\";\n-\n     private static final Logger LOG = LoggerFactory.getLogger( SchedulerServiceImpl.class );\n-\n     private static final String DEFAULT_QUEUE_NAME = \"/jobs\";\n-\n     private QueueManagerFactory qmf;\n     private EntityManagerFactory emf;\n-\n     private String jobQueueName = DEFAULT_QUEUE_NAME;\n-\n     private QueueManager qm;\n     private EntityManager em;\n \n@@ -78,6 +70,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n     /**\n      *\n      */\n+\n+\n     public SchedulerServiceImpl() {\n     }\n \n@@ -89,6 +83,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * org.apache.usergrid.batch.service.SchedulerService#createJob(java.lang.String,\n      * long, org.apache.usergrid.persistence.Entity)\n      */\n+\n+\n     @Override\n     public JobData createJob( String jobName, long fireTime, JobData jobData ) {\n         Assert.notNull( jobName, \"jobName is required\" );\n@@ -96,11 +92,10 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n \n         try {\n             jobData.setJobName( jobName );\n+\n             JobData job = getEm().create( jobData );\n             JobStat stat = getEm().create( new JobStat( jobName, job.getUuid() ) );\n-\n             scheduleJob( jobName, fireTime, job.getUuid(), stat.getUuid() );\n-\n             return job;\n         }\n         catch ( Exception e ) {\n@@ -110,6 +105,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n \n \n     /** Schedule the job internally */\n+\n+\n     private void scheduleJob( String jobName, long fireTime, UUID jobDataId, UUID jobStatId ) {\n         Assert.notNull( jobName, \"jobName is required\" );\n         Assert.isTrue( fireTime > -1, \"fireTime must be positive\" );\n@@ -121,7 +118,6 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n         message.setStringProperty( JOB_NAME, jobName );\n         message.setProperty( JOB_ID, jobDataId );\n         message.setProperty( STATS_ID, jobStatId );\n-\n         getQm().postToQueue( jobQueueName, message );\n     }\n \n@@ -131,6 +127,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      *\n      * @see org.apache.usergrid.batch.service.SchedulerService#deleteJob(java.util.UUID)\n      */\n+\n+\n     @Override\n     public void deleteJob( UUID jobId ) {\n         /**\n@@ -153,6 +151,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      *\n      * @see org.apache.usergrid.batch.repository.JobAccessor#getJobs(int)\n      */\n+\n+\n     @Override\n     public List<JobDescriptor> getJobs( int size ) {\n         QueueQuery query = new QueueQuery();\n@@ -160,18 +160,13 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n         query.setLimit( size );\n \n         QueueResults jobs = getQm().getFromQueue( jobQueueName, query );\n-\n         List<JobDescriptor> results = new ArrayList<JobDescriptor>( jobs.size() );\n-\n         for ( Message job : jobs.getMessages() ) {\n-\n             UUID jobUuid = UUID.fromString( job.getStringProperty( JOB_ID ) );\n             UUID statsUuid = UUID.fromString( job.getStringProperty( STATS_ID ) );\n             String jobName = job.getStringProperty( JOB_NAME );\n-\n             try {\n                 JobData data = getEm().get( jobUuid, JobData.class );\n-\n                 JobStat stats = getEm().get( statsUuid, JobStat.class );\n \n                 /**\n@@ -180,32 +175,27 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n                  */\n                 if ( data == null || stats == null ) {\n                     LOG.info( \"Received job with data id '{}' from the queue, but no data was found.  Dropping job\",\n-                            jobUuid );\n+                        jobUuid );\n                     getQm().deleteTransaction( jobQueueName, job.getTransaction(), null );\n-\n                     if ( data != null ) {\n                         getEm().delete( data );\n                     }\n-\n                     if ( stats != null ) {\n                         getEm().delete( stats );\n                     }\n-\n                     continue;\n                 }\n-\n                 results.add( new JobDescriptor( jobName, job.getUuid(), job.getTransaction(), data, stats, this ) );\n             }\n             catch ( Exception e ) {\n                 // log and skip. This is a catastrophic runtime error if we see an\n                 // exception here. We don't want to cause job loss, so leave the job in\n                 // the Q.\n-                LOG.error(\n-                        \"Unable to retrieve job data for jobname {}, job id {}, stats id {}.  Skipping to avoid job \"\n-                                + \"loss\", new Object[] { jobName, jobUuid, statsUuid, e } );\n+                LOG.error( \"Unable to retrieve job data for jobname {}, job id {}, stats id {}.  Skipping to avoid job \" + \"loss\", new Object[] {\n+                    jobName, jobUuid, statsUuid, e\n+                } );\n             }\n         }\n-\n         return results;\n     }\n \n@@ -213,12 +203,13 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n     @Override\n     public void heartbeat( JobRuntime execution, long delay ) {\n         LOG.debug( \"renew transaction {}\", execution.getTransactionId() );\n+\n         try {\n             // @TODO - what's the point to this sychronized block on an argument?\n-            synchronized ( execution ) {\n-                UUID newId = getQm().renewTransaction( jobQueueName, execution.getTransactionId(),\n-                        new QueueQuery().withTimeout( delay ) );\n \n+\n+            synchronized ( execution ) {\n+                UUID newId = getQm().renewTransaction( jobQueueName, execution.getTransactionId(), new QueueQuery().withTimeout( delay ) );\n                 execution.setTransactionId( newId );\n                 LOG.debug( \"renewed transaction {}\", newId );\n             }\n@@ -233,6 +224,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n     /* (non-Javadoc)\n      * @see org.apache.usergrid.batch.service.JobRuntimeService#heartbeat(org.apache.usergrid.batch.JobRuntime)\n      */\n+\n+\n     @Override\n     public void heartbeat( JobRuntime execution ) {\n         heartbeat( execution, jobTimeout );\n@@ -245,6 +238,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * @see org.apache.usergrid.batch.service.SchedulerService#delay(org.apache.usergrid.batch.\n      * JobExecutionImpl)\n      */\n+\n+\n     @Override\n     public void delay( JobRuntime execution ) {\n         delayRetry( execution.getExecution(), execution.getDelay() );\n@@ -258,14 +253,13 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * org.apache.usergrid.batch.repository.JobAccessor#save(org.apache.usergrid.batch.JobExecution\n      * )\n      */\n+\n+\n     @Override\n     public void save( JobExecution bulkJobExecution ) {\n-\n         JobData data = bulkJobExecution.getJobData();\n         JobStat stat = bulkJobExecution.getJobStats();\n-\n         Status jobStatus = bulkJobExecution.getStatus();\n-\n         try {\n \n             // we're done. Mark the transaction as complete and delete the job info\n@@ -288,9 +282,7 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n             else {\n                 getEm().update( data );\n             }\n-\n             LOG.info( \"Updating stats for job {}\", data.getJobName() );\n-\n             getEm().update( stat );\n         }\n         catch ( Exception e ) {\n@@ -306,13 +298,13 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * @see org.apache.usergrid.batch.service.SchedulerService#queryJobData(org.apache.usergrid.\n      * persistence.Query)\n      */\n+\n+\n     @Override\n     public Results queryJobData( Query query ) throws Exception {\n-\n         if ( query == null ) {\n             query = new Query();\n         }\n-\n         return getEm().searchCollection( getEm().getApplicationRef(), \"job_data\", query );\n     }\n \n@@ -324,12 +316,12 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n      * org.apache.usergrid.batch.repository.JobAccessor#delayRetry(org.apache.usergrid.batch\n      * .JobExecution, long)\n      */\n+\n+\n     @Override\n     public void delayRetry( JobExecution execution, long delay ) {\n-\n         JobData data = execution.getJobData();\n         JobStat stat = execution.getJobStats();\n-\n         try {\n \n             // if it's a dead status, it's failed too many times, just kill the job\n@@ -347,7 +339,6 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n             getQm().deleteTransaction( jobQueueName, execution.getTransactionId(), null );\n \n             // update the data for the next run\n-\n             getEm().update( data );\n             getEm().update( stat );\n         }\n@@ -361,26 +352,26 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n     /* (non-Javadoc)\n      * @see org.apache.usergrid.batch.service.SchedulerService#getStatsForJob(java.lang.String, java.util.UUID)\n      */\n+\n+\n     @Override\n     public JobStat getStatsForJob( String jobName, UUID jobId ) throws Exception {\n         EntityManager em = emf.getEntityManager( emf.getManagementAppId() );\n-\n-\n         Query query = new Query();\n         query.addEqualityFilter( JOB_NAME, jobName );\n         query.addEqualityFilter( JOB_ID, jobId );\n \n         Results r = em.searchCollection( em.getApplicationRef(), \"job_stats\", query );\n-\n         if ( r.size() == 1 ) {\n             return ( JobStat ) r.getEntity();\n         }\n-\n         return null;\n     }\n \n \n     /** @param qmf the qmf to set */\n+\n+\n     @Autowired\n     public void setQmf( QueueManagerFactory qmf ) {\n         this.qmf = qmf;\n@@ -388,6 +379,8 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n \n \n     /** @param emf the emf to set */\n+\n+\n     @Autowired\n     public void setEmf( EntityManagerFactory emf ) {\n         this.emf = emf;\n@@ -395,32 +388,39 @@ public class SchedulerServiceImpl implements SchedulerService, JobAccessor, JobR\n \n \n     /** @param jobQueueName the jobQueueName to set */\n+\n+\n     public void setJobQueueName( String jobQueueName ) {\n         this.jobQueueName = jobQueueName;\n     }\n \n \n     /** @param timeout the timeout to set */\n+\n+\n     public void setJobTimeout( long timeout ) {\n         this.jobTimeout = timeout;\n     }\n \n+\n     public QueueManager getQm() {\n         if ( qm == null ) {\n-            this.qm = qmf.getQueueManager( emf.getManagementAppId());\n+            this.qm = qmf.getQueueManager( emf.getManagementAppId() );\n         }\n         return qm;\n     }\n \n+\n     public EntityManager getEm() {\n-        if ( em == null  ) {\n-            this.em = emf.getEntityManager( emf.getManagementAppId());\n+        if ( em == null ) {\n+            this.em = emf.getEntityManager( emf.getManagementAppId() );\n         }\n         return em;\n     }\n \n+\n     @Override\n     public void refreshIndex() {\n         getEm().refreshIndex();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 88
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "51",
                    "severity": "warning",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}