{
    "project_name": "Roboy-roboy_dialog",
    "error_id": "9",
    "information": {
        "errors": [
            {
                "line": "21",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/**\n * Takes the definition and the head, then induce rules through alignment\n * \n * @author sidaw\n */\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "21",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "53",
                    "column": "5",
                    "severity": "error",
                    "message": "';' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/9/DefinitionAligner.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/intellij/9/DefinitionAligner.java\nindex 8c8a71f8e36..c041c3208cc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/9/DefinitionAligner.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/intellij/9/DefinitionAligner.java\n@@ -18,217 +18,252 @@ import fig.basic.Option;\n \n /**\n  * Takes the definition and the head, then induce rules through alignment\n- * \n+ *\n  * @author sidaw\n  */\n \n public class DefinitionAligner {\n-  public static class Options {\n-    @Option(gloss = \"categories that can serve as rules\")\n-    public Set<String> alignedCats = new HashSet<String>();\n-    @Option(gloss = \"phrase size\")\n-    public int phraseSize = 2;\n-    @Option(gloss = \"max length difference\")\n-    public int maxLengthDifference = 3;\n-    @Option(gloss = \"max set exclusion length\")\n-    public int maxSetExclusionLength = 2;\n-    @Option(gloss = \"max exact exclusion length\")\n-    public int maxExactExclusionLength = 5;\n-    @Option(gloss = \"window size\")\n-    public int windowSize = 1;\n-\n-    @Option(gloss = \"strategies\")\n-    public Set<Strategies> strategies = Sets.newHashSet(Strategies.SetExclusion, Strategies.ExactExclusion);\n-    @Option(gloss = \"maximum matches\")\n-    public int maxMatches = 3;\n-    @Option(gloss = \"verbose\")\n-    public int verbose = 0;\n-\n-  }\n-\n-  public enum Strategies {\n-    SetExclusion, ExactExclusion, cmdSet\n-  };\n-\n-  public static Options opts = new Options();\n-\n-  public class Match {\n-    @Override\n-    public String toString() {\n-      return \"Match [deriv=\" + deriv + \", start=\" + start + \", end=\" + end + \"]\";\n+    public static class Options {\n+        @Option(gloss = \"categories that can serve as rules\")\n+        public Set<String> alignedCats = new HashSet<String>();\n+        @Option(gloss = \"phrase size\")\n+        public int phraseSize = 2;\n+        @Option(gloss = \"max length difference\")\n+        public int maxLengthDifference = 3;\n+        @Option(gloss = \"max set exclusion length\")\n+        public int maxSetExclusionLength = 2;\n+        @Option(gloss = \"max exact exclusion length\")\n+        public int maxExactExclusionLength = 5;\n+        @Option(gloss = \"window size\")\n+        public int windowSize = 1;\n+\n+        @Option(gloss = \"strategies\")\n+        public Set<Strategies> strategies = Sets.newHashSet(Strategies.SetExclusion, Strategies.ExactExclusion);\n+        @Option(gloss = \"maximum matches\")\n+        public int maxMatches = 3;\n+        @Option(gloss = \"verbose\")\n+        public int verbose = 0;\n+\n     }\n \n-    public Match(Derivation def, int start, int end) {\n-      deriv = def;\n-      this.start = start;\n-      this.end = end;\n-      deriv.grammarInfo.start = start;\n-      deriv.grammarInfo.end = end;\n+    public enum Strategies {\n+        SetExclusion, ExactExclusion, cmdSet\n     }\n \n-    Derivation deriv;\n-    int start;\n-    int end;\n-  }\n+    ;\n \n-  List<String> headTokens;\n-  List<String> defTokens;\n+    public static Options opts = new Options();\n \n-  public static List<Rule> getRules(List<String> head, List<String> def, Derivation deriv, List<Derivation> chartList) {\n-    if (opts.verbose > 0)\n-      LogInfo.logs(\"DefinitionAligner.chartList: %s\", chartList);\n+    public class Match {\n+        @Override\n+        public String toString() {\n+            return \"Match [deriv=\" + deriv + \", start=\" + start + \", end=\" + end + \"]\";\n+        }\n \n-    DefinitionAligner aligner = new DefinitionAligner(head, def, deriv, chartList);\n+        public Match(Derivation def, int start, int end) {\n+            deriv = def;\n+            this.start = start;\n+            this.end = end;\n+            deriv.grammarInfo.start = start;\n+            deriv.grammarInfo.end = end;\n+        }\n \n-    List<Rule> allAlignedRules = Lists.newArrayList();\n-    if (opts.verbose > 0)\n-      LogInfo.logs(\"DefinitionAligner.allMatches.size(): %d\", aligner.allMatches.size());\n+        Derivation deriv;\n+        int start;\n+        int end;\n+    }\n \n-    for (int i = 0; i < aligner.allMatches.size() && i <= opts.maxMatches; i++) {\n-      Match match = aligner.allMatches.get(i);\n+    List<String> headTokens;\n+    List<String> defTokens;\n \n-      List<Derivation> filteredList = chartList.stream()\n-          .filter(d -> d.start >= match.deriv.start && d.end <= match.deriv.end).collect(Collectors.toList());\n+    public static List<Rule> getRules(List<String> head, List<String> def, Derivation deriv,\n+                                      List<Derivation> chartList) {\n+        if (opts.verbose > 0) {\n+            LogInfo.logs(\"DefinitionAligner.chartList: %s\", chartList);\n+        }\n \n-      // filter out core\n-      List<Derivation> currentParses = chartList.stream().filter(d -> {\n-        if (opts.verbose > 1)\n-          LogInfo.logs(\"DefinitionAligner.chartList.d: %s\", d);\n-        return (d.start == match.start && d.end == match.end);\n-      }).collect(Collectors.toList());\n+        DefinitionAligner aligner = new DefinitionAligner(head, def, deriv, chartList);\n \n-      if (opts.verbose > 1)\n-        LogInfo.logs(\"DefinitionAligner.Match: %s\", match);\n-      if (opts.verbose > 1)\n-        LogInfo.logs(\"DefinitionAligner.currentParses: %s\", currentParses);\n+        List<Rule> allAlignedRules = Lists.newArrayList();\n+        if (opts.verbose > 0) {\n+            LogInfo.logs(\"DefinitionAligner.allMatches.size(): %d\", aligner.allMatches.size());\n+        }\n \n-      if (GrammarInducer.getParseStatus(currentParses) != ParseStatus.Core) {\n-        if (opts.verbose > 1)\n-          LogInfo.logs(\"DefinitionAligner.NotCore: %s\", currentParses);\n-        GrammarInducer grammarInducer = new GrammarInducer(head, match.deriv, filteredList);\n-        allAlignedRules.addAll(grammarInducer.getRules());\n-      }\n+        for (int i = 0; i < aligner.allMatches.size() && i <= opts.maxMatches; i++) {\n+            Match match = aligner.allMatches.get(i);\n+\n+            List<Derivation> filteredList = chartList.stream()\n+                .filter(d -> d.start >= match.deriv.start && d.end <= match.deriv.end).collect(Collectors.toList());\n+\n+            // filter out core\n+            List<Derivation> currentParses = chartList.stream().filter(d -> {\n+                if (opts.verbose > 1) {\n+                    LogInfo.logs(\"DefinitionAligner.chartList.d: %s\", d);\n+                }\n+                return (d.start == match.start && d.end == match.end);\n+            }).collect(Collectors.toList());\n+\n+            if (opts.verbose > 1) {\n+                LogInfo.logs(\"DefinitionAligner.Match: %s\", match);\n+            }\n+            if (opts.verbose > 1) {\n+                LogInfo.logs(\"DefinitionAligner.currentParses: %s\", currentParses);\n+            }\n+\n+            if (GrammarInducer.getParseStatus(currentParses) != ParseStatus.Core) {\n+                if (opts.verbose > 1) {\n+                    LogInfo.logs(\"DefinitionAligner.NotCore: %s\", currentParses);\n+                }\n+                GrammarInducer grammarInducer = new GrammarInducer(head, match.deriv, filteredList);\n+                allAlignedRules.addAll(grammarInducer.getRules());\n+            }\n+        }\n+        return allAlignedRules;\n     }\n-    return allAlignedRules;\n-  }\n-\n-  public List<Match> allMatches = new ArrayList<>();\n-  private Map<String, List<Derivation>> chartMap;\n-\n-  public DefinitionAligner(List<String> headTokens, List<String> defTokens, Derivation def,\n-      List<Derivation> chartList) {\n-    this.headTokens = headTokens;\n-    this.defTokens = defTokens;\n-    this.chartMap = GrammarInducer.makeChartMap(chartList);\n-    if (opts.verbose > 0)\n-      LogInfo.logs(\"DefinitionAligner: head '%s' as body: '%s'\", headTokens, defTokens);\n-    if (Math.abs(headTokens.size() - defTokens.size()) >= 4)\n-      return;\n-    recursiveMatch(def);\n-  }\n-\n-  void recursiveMatch(Derivation def) {\n-    // LogInfo.logs(\"Considering (%d,%d): %s\", def.start, def.end, def);\n-    for (int start = 0; start < headTokens.size(); start++) {\n-      for (int end = headTokens.size(); end > start; end--) {\n-        // LogInfo.logs(\"Testing (%d,%d)\", start, end);\n-        if (end == headTokens.size() && start == 0)\n-          continue;\n-        if (isMatch(def, start, end)) {\n-          if (opts.verbose > 0)\n-            LogInfo.logs(\"Matched head(%d,%d)=%s with deriv(%d,%d)=%s: %s\", start, end, headTokens.subList(start, end),\n-                def.start, def.end, defTokens.subList(def.start, def.end), def);\n-          allMatches.add(new Match(def, start, end));\n-          return;\n-        }\n-      }\n+\n+    public List<Match> allMatches = new ArrayList<>();\n+    private Map<String, List<Derivation>> chartMap;\n+\n+    public DefinitionAligner(List<String> headTokens, List<String> defTokens, Derivation def,\n+                             List<Derivation> chartList) {\n+        this.headTokens = headTokens;\n+        this.defTokens = defTokens;\n+        this.chartMap = GrammarInducer.makeChartMap(chartList);\n+        if (opts.verbose > 0) {\n+            LogInfo.logs(\"DefinitionAligner: head '%s' as body: '%s'\", headTokens, defTokens);\n+        }\n+        if (Math.abs(headTokens.size() - defTokens.size()) >= 4) {\n+            return;\n+        }\n+        recursiveMatch(def);\n     }\n \n-    for (Derivation d : def.children) {\n-      recursiveMatch(d);\n+    void recursiveMatch(Derivation def) {\n+        // LogInfo.logs(\"Considering (%d,%d): %s\", def.start, def.end, def);\n+        for (int start = 0; start < headTokens.size(); start++) {\n+            for (int end = headTokens.size(); end > start; end--) {\n+                // LogInfo.logs(\"Testing (%d,%d)\", start, end);\n+                if (end == headTokens.size() && start == 0) {\n+                    continue;\n+                }\n+                if (isMatch(def, start, end)) {\n+                    if (opts.verbose > 0) {\n+                        LogInfo.logs(\"Matched head(%d,%d)=%s with deriv(%d,%d)=%s: %s\", start, end,\n+                            headTokens.subList(start, end),\n+                            def.start, def.end, defTokens.subList(def.start, def.end), def);\n+                    }\n+                    allMatches.add(new Match(def, start, end));\n+                    return;\n+                }\n+            }\n+        }\n+\n+        for (Derivation d : def.children) {\n+            recursiveMatch(d);\n+        }\n+    }\n+\n+    boolean isMatch(Derivation def, int start, int end) {\n+        if (def.start == -1 || def.end == -1) {\n+            return false;\n+        }\n+        if (chartMap.containsKey(GrammarInducer.catFormulaKey(def))) {\n+            return false;\n+        }\n+        if (opts.verbose > 0) {\n+            LogInfo.logs(\"checkingLengths (%d, %d) - (%d, %d)\", start, end, def.start, def.end);\n+        }\n+        if (Math.abs((end - start) - (def.end - def.start)) >= opts.maxLengthDifference) {\n+            return false;\n+        }\n+        if (opts.strategies.contains(Strategies.ExactExclusion) && exactExclusion(def, start, end)) {\n+            return true;\n+        }\n+        if (opts.strategies.contains(Strategies.SetExclusion) && setExclusion(def, start, end)) {\n+            return true;\n+        }\n+        if (opts.strategies.contains(Strategies.cmdSet) && cmdSet(def, start, end)) {\n+            return true;\n+        }\n+\n+        return false;\n     }\n-  }\n-\n-  boolean isMatch(Derivation def, int start, int end) {\n-    if (def.start == -1 || def.end == -1)\n-      return false;\n-    if (chartMap.containsKey(GrammarInducer.catFormulaKey(def)))\n-      return false;\n-    if (opts.verbose > 0)\n-      LogInfo.logs(\"checkingLengths (%d, %d) - (%d, %d)\", start, end, def.start, def.end);\n-    if (Math.abs((end - start) - (def.end - def.start)) >= opts.maxLengthDifference)\n-      return false;\n-    if (opts.strategies.contains(Strategies.ExactExclusion) && exactExclusion(def, start, end))\n-      return true;\n-    if (opts.strategies.contains(Strategies.SetExclusion) && setExclusion(def, start, end))\n-      return true;\n-    if (opts.strategies.contains(Strategies.cmdSet) && cmdSet(def, start, end))\n-      return true;\n-\n-    return false;\n-  }\n-\n-  private boolean setExclusion(Derivation def, int start, int end) {\n-    // the span under consideration does not match anythign\n-    if (end - start > opts.maxSetExclusionLength)\n-      return false;\n-    if (!headTokens.subList(start, end).stream().noneMatch(t -> defTokens.contains(t)))\n-      return false;\n-    if (!defTokens.subList(def.start, def.end).stream().noneMatch(t -> headTokens.contains(t)))\n-      return false;\n-\n-    // everything before and afterwards are accounted for\n-    if (!headTokens.subList(0, start).stream().allMatch(t -> defTokens.contains(t)))\n-      return false;\n-    if (!headTokens.subList(end, headTokens.size()).stream().allMatch(t -> defTokens.contains(t)))\n-      return false;\n-    return true;\n-  }\n-\n-  private List<String> window(int lower, int upper, List<String> list) {\n-    List<String> ret = new ArrayList<>();\n-    for (int i = lower; i < upper; i++) {\n-      if (i < 0 || i >= list.size())\n-        ret.add(\"(*)\");\n-      else\n-        ret.add(list.get(i));\n+\n+    private boolean setExclusion(Derivation def, int start, int end) {\n+        // the span under consideration does not match anythign\n+        if (end - start > opts.maxSetExclusionLength) {\n+            return false;\n+        }\n+        if (!headTokens.subList(start, end).stream().noneMatch(t -> defTokens.contains(t))) {\n+            return false;\n+        }\n+        if (!defTokens.subList(def.start, def.end).stream().noneMatch(t -> headTokens.contains(t))) {\n+            return false;\n+        }\n+\n+        // everything before and afterwards are accounted for\n+        if (!headTokens.subList(0, start).stream().allMatch(t -> defTokens.contains(t))) {\n+            return false;\n+        }\n+        if (!headTokens.subList(end, headTokens.size()).stream().allMatch(t -> defTokens.contains(t))) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private List<String> window(int lower, int upper, List<String> list) {\n+        List<String> ret = new ArrayList<>();\n+        for (int i = lower; i < upper; i++) {\n+            if (i < 0 || i >= list.size()) {\n+                ret.add(\"(*)\");\n+            } else {\n+                ret.add(list.get(i));\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    private boolean exactExclusion(Derivation def, int start, int end) {\n+        if (opts.verbose > 0) {\n+            LogInfo.log(\"In exactExclusion\");\n+        }\n+        if (end - start > opts.maxExactExclusionLength) {\n+            return false;\n+        }\n+\n+        boolean prefixEq = window(start - opts.windowSize, start, headTokens)\n+            .equals(window(def.start - opts.windowSize, def.start, defTokens));\n+        boolean sufixEq = window(end, end + opts.windowSize, headTokens)\n+            .equals(window(def.end, def.end + opts.windowSize, defTokens));\n+        if (opts.verbose > 0) {\n+            LogInfo.logs(\"%b : %b\", prefixEq, sufixEq);\n+        }\n+        if (opts.verbose > 0) {\n+            LogInfo.logs(\"(%d,%d)-head(%d,%d): %b %b %s %s\", def.start, def.end, start, end, prefixEq, sufixEq,\n+                window(end, end + opts.windowSize, headTokens), window(def.end, def.end + opts.windowSize, defTokens));\n+        }\n+        if (!prefixEq || !sufixEq) {\n+            return false;\n+        }\n+        if (headTokens.subList(start, end).equals(defTokens.subList(def.start, def.end))) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    // exact match plus big\n+    private boolean cmdSet(Derivation def, int start, int end) {\n+        if (opts.verbose > 0) {\n+            LogInfo.log(\"In exactPlusBig\");\n+        }\n+        // match only beginning and end\n+        boolean cmdSet = (end == headTokens.size()) && (start > 0) && def.end == defTokens.size() && def.start > 0;\n+        if (cmdSet && headTokens.subList(0, start).equals(defTokens.subList(0, start))) {\n+            return true;\n+        }\n+\n+        return false;\n     }\n-    return ret;\n-  }\n-\n-  private boolean exactExclusion(Derivation def, int start, int end) {\n-    if (opts.verbose > 0)\n-      LogInfo.log(\"In exactExclusion\");\n-    if (end - start > opts.maxExactExclusionLength)\n-      return false;\n-\n-    boolean prefixEq = window(start - opts.windowSize, start, headTokens)\n-        .equals(window(def.start - opts.windowSize, def.start, defTokens));\n-    boolean sufixEq = window(end, end + opts.windowSize, headTokens)\n-        .equals(window(def.end, def.end + opts.windowSize, defTokens));\n-    if (opts.verbose > 0)\n-      LogInfo.logs(\"%b : %b\", prefixEq, sufixEq);\n-    if (opts.verbose > 0)\n-      LogInfo.logs(\"(%d,%d)-head(%d,%d): %b %b %s %s\", def.start, def.end, start, end, prefixEq, sufixEq,\n-          window(end, end + opts.windowSize, headTokens), window(def.end, def.end + opts.windowSize, defTokens));\n-    if (!prefixEq || !sufixEq)\n-      return false;\n-    if (headTokens.subList(start, end).equals(defTokens.subList(def.start, def.end)))\n-      return false;\n-\n-    return true;\n-  }\n-\n-  // exact match plus big\n-  private boolean cmdSet(Derivation def, int start, int end) {\n-    if (opts.verbose > 0)\n-      LogInfo.log(\"In exactPlusBig\");\n-    // match only beginning and end\n-    boolean cmdSet = (end == headTokens.size()) && (start > 0) && def.end == defTokens.size() && def.start > 0;\n-    if (cmdSet && headTokens.subList(0, start).equals(defTokens.subList(0, start)))\n-      return true;\n-\n-    return false;\n-  }\n \n }\n",
            "diff_size": 304
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "21",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/9/DefinitionAligner.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/naturalize/9/DefinitionAligner.java\nindex 8c8a71f8e36..0232d620319 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/9/DefinitionAligner.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/naturalize/9/DefinitionAligner.java\n@@ -138,7 +138,7 @@ public class DefinitionAligner {\n           if (opts.verbose > 0)\n             LogInfo.logs(\"Matched head(%d,%d)=%s with deriv(%d,%d)=%s: %s\", start, end, headTokens.subList(start, end),\n                 def.start, def.end, defTokens.subList(def.start, def.end), def);\n-          allMatches.add(new Match(def, start, end));\n+allMatches.add(new Match(def, start, end));\n           return;\n         }\n       }\n@@ -202,21 +202,18 @@ public class DefinitionAligner {\n     if (end - start > opts.maxExactExclusionLength)\n       return false;\n \n-    boolean prefixEq = window(start - opts.windowSize, start, headTokens)\n-        .equals(window(def.start - opts.windowSize, def.start, defTokens));\n-    boolean sufixEq = window(end, end + opts.windowSize, headTokens)\n-        .equals(window(def.end, def.end + opts.windowSize, defTokens));\n+    boolean prefixEq = window(start - opts.windowSize, start, headTokens).equals(window(def.start - opts.windowSize, def.start, defTokens));\n+boolean sufixEq = window(end, end + opts.windowSize, headTokens).equals(window(def.end, def.end + opts.windowSize, defTokens));\n     if (opts.verbose > 0)\n       LogInfo.logs(\"%b : %b\", prefixEq, sufixEq);\n     if (opts.verbose > 0)\n       LogInfo.logs(\"(%d,%d)-head(%d,%d): %b %b %s %s\", def.start, def.end, start, end, prefixEq, sufixEq,\n           window(end, end + opts.windowSize, headTokens), window(def.end, def.end + opts.windowSize, defTokens));\n-    if (!prefixEq || !sufixEq)\n+if (!prefixEq || !sufixEq)\n       return false;\n     if (headTokens.subList(start, end).equals(defTokens.subList(def.start, def.end)))\n       return false;\n-\n-    return true;\n+  return true;\n   }\n \n   // exact match plus big\n@@ -231,4 +228,4 @@ public class DefinitionAligner {\n     return false;\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 9
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "19",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/9/DefinitionAligner.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/codebuff/9/DefinitionAligner.java\nindex 8c8a71f8e36..459538f97c5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/9/DefinitionAligner.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/codebuff/9/DefinitionAligner.java\n@@ -6,10 +6,8 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.stream.Collectors;\n-\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-\n import edu.stanford.nlp.sempre.Derivation;\n import edu.stanford.nlp.sempre.Rule;\n import edu.stanford.nlp.sempre.interactive.GrammarInducer.ParseStatus;\n@@ -22,6 +20,7 @@ import fig.basic.Option;\n  * @author sidaw\n  */\n \n+\n public class DefinitionAligner {\n   public static class Options {\n     @Option(gloss = \"categories that can serve as rules\")\n@@ -36,19 +35,15 @@ public class DefinitionAligner {\n     public int maxExactExclusionLength = 5;\n     @Option(gloss = \"window size\")\n     public int windowSize = 1;\n-\n     @Option(gloss = \"strategies\")\n     public Set<Strategies> strategies = Sets.newHashSet(Strategies.SetExclusion, Strategies.ExactExclusion);\n     @Option(gloss = \"maximum matches\")\n     public int maxMatches = 3;\n     @Option(gloss = \"verbose\")\n     public int verbose = 0;\n-\n   }\n \n-  public enum Strategies {\n-    SetExclusion, ExactExclusion, cmdSet\n-  };\n+  public enum Strategies { SetExclusion, ExactExclusion, cmdSet };\n \n   public static Options opts = new Options();\n \n@@ -79,32 +74,29 @@ public class DefinitionAligner {\n       LogInfo.logs(\"DefinitionAligner.chartList: %s\", chartList);\n \n     DefinitionAligner aligner = new DefinitionAligner(head, def, deriv, chartList);\n-\n     List<Rule> allAlignedRules = Lists.newArrayList();\n     if (opts.verbose > 0)\n       LogInfo.logs(\"DefinitionAligner.allMatches.size(): %d\", aligner.allMatches.size());\n-\n     for (int i = 0; i < aligner.allMatches.size() && i <= opts.maxMatches; i++) {\n       Match match = aligner.allMatches.get(i);\n-\n-      List<Derivation> filteredList = chartList.stream()\n-          .filter(d -> d.start >= match.deriv.start && d.end <= match.deriv.end).collect(Collectors.toList());\n+      List<Derivation> filteredList = chartList.stream().filter(d -> d.start >= match.deriv.start && d.end <= match.deriv.end)\n+                                                        .collect(Collectors.toList());\n \n       // filter out core\n       List<Derivation> currentParses = chartList.stream().filter(d -> {\n         if (opts.verbose > 1)\n           LogInfo.logs(\"DefinitionAligner.chartList.d: %s\", d);\n         return (d.start == match.start && d.end == match.end);\n-      }).collect(Collectors.toList());\n-\n+      })\n+                                                         .collect(Collectors.toList());\n       if (opts.verbose > 1)\n         LogInfo.logs(\"DefinitionAligner.Match: %s\", match);\n       if (opts.verbose > 1)\n         LogInfo.logs(\"DefinitionAligner.currentParses: %s\", currentParses);\n-\n       if (GrammarInducer.getParseStatus(currentParses) != ParseStatus.Core) {\n         if (opts.verbose > 1)\n           LogInfo.logs(\"DefinitionAligner.NotCore: %s\", currentParses);\n+\n         GrammarInducer grammarInducer = new GrammarInducer(head, match.deriv, filteredList);\n         allAlignedRules.addAll(grammarInducer.getRules());\n       }\n@@ -115,8 +107,9 @@ public class DefinitionAligner {\n   public List<Match> allMatches = new ArrayList<>();\n   private Map<String, List<Derivation>> chartMap;\n \n-  public DefinitionAligner(List<String> headTokens, List<String> defTokens, Derivation def,\n-      List<Derivation> chartList) {\n+  public DefinitionAligner(List<String> headTokens,\n+                           List<String> defTokens,\n+                           Derivation def, List<Derivation> chartList) {\n     this.headTokens = headTokens;\n     this.defTokens = defTokens;\n     this.chartMap = GrammarInducer.makeChartMap(chartList);\n@@ -132,18 +125,15 @@ public class DefinitionAligner {\n     for (int start = 0; start < headTokens.size(); start++) {\n       for (int end = headTokens.size(); end > start; end--) {\n         // LogInfo.logs(\"Testing (%d,%d)\", start, end);\n-        if (end == headTokens.size() && start == 0)\n-          continue;\n+        if (end == headTokens.size() && start == 0) continue;\n         if (isMatch(def, start, end)) {\n           if (opts.verbose > 0)\n-            LogInfo.logs(\"Matched head(%d,%d)=%s with deriv(%d,%d)=%s: %s\", start, end, headTokens.subList(start, end),\n-                def.start, def.end, defTokens.subList(def.start, def.end), def);\n+            LogInfo.logs(\"Matched head(%d,%d)=%s with deriv(%d,%d)=%s: %s\", start, end, headTokens.subList(start, end), def.start, def.end, defTokens.subList(def.start, def.end), def);\n           allMatches.add(new Match(def, start, end));\n           return;\n         }\n       }\n     }\n-\n     for (Derivation d : def.children) {\n       recursiveMatch(d);\n     }\n@@ -164,7 +154,6 @@ public class DefinitionAligner {\n       return true;\n     if (opts.strategies.contains(Strategies.cmdSet) && cmdSet(def, start, end))\n       return true;\n-\n     return false;\n   }\n \n@@ -172,15 +161,19 @@ public class DefinitionAligner {\n     // the span under consideration does not match anythign\n     if (end - start > opts.maxSetExclusionLength)\n       return false;\n-    if (!headTokens.subList(start, end).stream().noneMatch(t -> defTokens.contains(t)))\n+    if (!headTokens.subList(start, end).stream()\n+                                       .noneMatch(t -> defTokens.contains(t)))\n       return false;\n-    if (!defTokens.subList(def.start, def.end).stream().noneMatch(t -> headTokens.contains(t)))\n+    if (!defTokens.subList(def.start, def.end).stream()\n+                                              .noneMatch(t -> headTokens.contains(t)))\n       return false;\n \n     // everything before and afterwards are accounted for\n-    if (!headTokens.subList(0, start).stream().allMatch(t -> defTokens.contains(t)))\n+    if (!headTokens.subList(0, start).stream()\n+                                     .allMatch(t -> defTokens.contains(t)))\n       return false;\n-    if (!headTokens.subList(end, headTokens.size()).stream().allMatch(t -> defTokens.contains(t)))\n+    if (!headTokens.subList(end, headTokens.size()).stream()\n+                                                   .allMatch(t -> defTokens.contains(t)))\n       return false;\n     return true;\n   }\n@@ -202,33 +195,29 @@ public class DefinitionAligner {\n     if (end - start > opts.maxExactExclusionLength)\n       return false;\n \n-    boolean prefixEq = window(start - opts.windowSize, start, headTokens)\n-        .equals(window(def.start - opts.windowSize, def.start, defTokens));\n-    boolean sufixEq = window(end, end + opts.windowSize, headTokens)\n-        .equals(window(def.end, def.end + opts.windowSize, defTokens));\n+    boolean prefixEq = window(start - opts.windowSize, start, headTokens).equals(window(def.start - opts.windowSize, def.start, defTokens));\n+    boolean sufixEq = window(end, end + opts.windowSize, headTokens).equals(window(def.end, def.end + opts.windowSize, defTokens));\n     if (opts.verbose > 0)\n       LogInfo.logs(\"%b : %b\", prefixEq, sufixEq);\n     if (opts.verbose > 0)\n-      LogInfo.logs(\"(%d,%d)-head(%d,%d): %b %b %s %s\", def.start, def.end, start, end, prefixEq, sufixEq,\n-          window(end, end + opts.windowSize, headTokens), window(def.end, def.end + opts.windowSize, defTokens));\n+      LogInfo.logs(\"(%d,%d)-head(%d,%d): %b %b %s %s\", def.start, def.end, start, end, prefixEq, sufixEq, window(end, end + opts.windowSize, headTokens), window(def.end, def.end + opts.windowSize, defTokens));\n     if (!prefixEq || !sufixEq)\n       return false;\n     if (headTokens.subList(start, end).equals(defTokens.subList(def.start, def.end)))\n       return false;\n-\n     return true;\n   }\n \n   // exact match plus big\n+\n   private boolean cmdSet(Derivation def, int start, int end) {\n     if (opts.verbose > 0)\n       LogInfo.log(\"In exactPlusBig\");\n     // match only beginning and end\n+\n     boolean cmdSet = (end == headTokens.size()) && (start > 0) && def.end == defTokens.size() && def.start > 0;\n     if (cmdSet && headTokens.subList(0, start).equals(defTokens.subList(0, start)))\n       return true;\n-\n     return false;\n   }\n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 46
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "21",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "21",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}