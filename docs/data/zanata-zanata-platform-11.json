{
    "project_name": "zanata-zanata-platform",
    "error_id": "11",
    "information": {
        "errors": [
            {
                "line": "374",
                "column": "40",
                "severity": "error",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "            toTargetHeader.setDocument(doc);\n            transferFromPoTargetHeader(fromTargetHeader, toTargetHeader,\n                    MergeType.IMPORT); // return\n            // value\n            // not\n            // needed",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/11/ResourceUtils.java\nindex b5d24bde0cc..352a6bca680 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/11/ResourceUtils.java\n@@ -371,8 +371,9 @@ public class ResourceUtils implements Serializable {\n             toTargetHeader.setTargetLanguage(locale);\n             toTargetHeader.setDocument(doc);\n             transferFromPoTargetHeader(fromTargetHeader, toTargetHeader,\n-                    MergeType.IMPORT); // return\n-            // value\n+                    MergeType.IMPORT);\n+                    // return                                                                                       // value\n+                     // value\n             // not\n             // needed\n             entityManager.persist(toTargetHeader);\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "376",
                    "column": "28",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/11/ResourceUtils.java\nindex b5d24bde0cc..c355d6d9b70 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/11/ResourceUtils.java\n@@ -81,1351 +81,1337 @@ import static org.apache.commons.lang3.StringUtils.isNotEmpty;\n @Named(\"resourceUtils\")\n @RequestScoped\n public class ResourceUtils implements Serializable {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(ResourceUtils.class);\n-    private static final long serialVersionUID = -969189290416018542L;\n-\n-    /**\n-     * Newline character used for multi-line comments\n-     */\n-    private static final char NEWLINE = '\\n';\n-    private static final String ZANATA_GENERATOR_PREFIX = \"Zanata\";\n-    private static final String ZANATA_TAG = \"#zanata\";\n-    private static final String PO_DATE_FORMAT = \"yyyy-MM-dd hh:mmZ\";\n-    private static final String PO_DEFAULT_CONTENT_TYPE =\n-            \"text/plain; charset=UTF-8\";\n-\n-    /**\n-     * PO Header entries\n-     */\n-    private static final String LAST_TRANSLATOR_HDR = \"Last-Translator\";\n-    private static final String PO_REVISION_DATE_HDR =\n-            HeaderFields.KEY_PoRevisionDate;\n-    private static final String LANGUAGE_TEAM_HDR =\n-            HeaderFields.KEY_LanguageTeam;\n-    private static final String X_GENERATOR_HDR = \"X-Generator\";\n-    private static final String LANGUAGE_HDR = HeaderFields.KEY_Language;\n-    private static final String CONTENT_TYPE_HDR = HeaderFields.KEY_ContentType;\n-    private static final String PLURAL_FORMS_HDR = \"Plural-Forms\";\n-    // TODO we should need only one regex, with a capture group for nplurals\n-    private static final Pattern PLURAL_FORM_PATTERN =\n-            Pattern.compile(\"nplurals=[0-9]+;\\\\s?plural=*\");\n-    private static final Pattern NPLURALS_TAG_PATTERN =\n-            Pattern.compile(\"nplurals=\");\n-    private static final Pattern NPLURALS_PATTERN =\n-            Pattern.compile(\"nplurals=[0-9]+\");\n-    private static final String PLURALS_FILE = \"pluralforms.properties\";\n-    private static final int DEFAULT_NPLURALS = 1;\n-    private static final String DEFAULT_PLURAL_FORM = \"nplurals=1; plural=0\";\n-    public static final int MAX_TARGET_CONTENTS = 6;\n-    private Properties pluralForms;\n-    public static final String COPIED_BY_ZANATA_NAME = \"Copied by Zanata\";\n-    public static final String COPIED_BY_ZANATA_NAME_EMAIL =\n-            \"copied-by-zanata@zanata.org\";\n-    @SuppressFBWarnings(\"SE_BAD_FIELD\")\n-    @Inject\n-    private EntityManager entityManager;\n-    @Inject\n-    private LocaleDAO localeDAO;\n-\n-    @PostConstruct\n-    public void create() {\n-        try {\n-            if (pluralForms == null) {\n-                pluralForms = new Properties();\n-                pluralForms.load(this.getClass().getClassLoader()\n-                        .getResourceAsStream(PLURALS_FILE));\n-            }\n-        } catch (IOException e) {\n-            log.error(\"There was an error loading plural forms.\", e);\n-        }\n+  private static final org.slf4j.Logger log =\n+    org.slf4j.LoggerFactory.getLogger(ResourceUtils.class);\n+  private static final long serialVersionUID = -969189290416018542L;\n+\n+  /**\n+   * Newline character used for multi-line comments\n+   */\n+  private static final char NEWLINE = '\\n';\n+  private static final String ZANATA_GENERATOR_PREFIX = \"Zanata\";\n+  private static final String ZANATA_TAG = \"#zanata\";\n+  private static final String PO_DATE_FORMAT = \"yyyy-MM-dd hh:mmZ\";\n+  private static final String PO_DEFAULT_CONTENT_TYPE =\n+    \"text/plain; charset=UTF-8\";\n+\n+  /**\n+   * PO Header entries\n+   */\n+  private static final String LAST_TRANSLATOR_HDR = \"Last-Translator\";\n+  private static final String PO_REVISION_DATE_HDR =\n+    HeaderFields.KEY_PoRevisionDate;\n+  private static final String LANGUAGE_TEAM_HDR =\n+    HeaderFields.KEY_LanguageTeam;\n+  private static final String X_GENERATOR_HDR = \"X-Generator\";\n+  private static final String LANGUAGE_HDR = HeaderFields.KEY_Language;\n+  private static final String CONTENT_TYPE_HDR = HeaderFields.KEY_ContentType;\n+  private static final String PLURAL_FORMS_HDR = \"Plural-Forms\";\n+  // TODO we should need only one regex, with a capture group for nplurals\n+  private static final Pattern PLURAL_FORM_PATTERN =\n+    Pattern.compile(\"nplurals=[0-9]+;\\\\s?plural=*\");\n+  private static final Pattern NPLURALS_TAG_PATTERN =\n+    Pattern.compile(\"nplurals=\");\n+  private static final Pattern NPLURALS_PATTERN =\n+    Pattern.compile(\"nplurals=[0-9]+\");\n+  private static final String PLURALS_FILE = \"pluralforms.properties\";\n+  private static final int DEFAULT_NPLURALS = 1;\n+  private static final String DEFAULT_PLURAL_FORM = \"nplurals=1; plural=0\";\n+  public static final int MAX_TARGET_CONTENTS = 6;\n+  private Properties pluralForms;\n+  public static final String COPIED_BY_ZANATA_NAME = \"Copied by Zanata\";\n+  public static final String COPIED_BY_ZANATA_NAME_EMAIL =\n+    \"copied-by-zanata@zanata.org\";\n+  @SuppressFBWarnings(\"SE_BAD_FIELD\")\n+  @Inject\n+  private EntityManager entityManager;\n+  @Inject\n+  private LocaleDAO localeDAO;\n+\n+  @PostConstruct\n+  public void create() {\n+    try {\n+      if (pluralForms == null) {\n+        pluralForms = new Properties();\n+        pluralForms.load(this.getClass().getClassLoader()\n+          .getResourceAsStream(PLURALS_FILE));\n+      }\n+    } catch (IOException e) {\n+      log.error(\"There was an error loading plural forms.\", e);\n     }\n-\n-    Properties getPluralForms() {\n-        return pluralForms;\n-    }\n-\n-    /**\n-     * Merges the list of TextFlows into the target HDocument, adding and\n-     * obsoleting TextFlows as necessary.\n-     *\n-     * @param from\n-     * @param to\n-     * @return\n-     */\n-    boolean transferFromTextFlows(List<TextFlow> from, HDocument to,\n-            Set<String> enabledExtensions, int nextDocRev) {\n-        boolean changed = false;\n-        to.getTextFlows().clear();\n-        Set<String> incomingIds = new HashSet<String>();\n-        Set<String> previousIds =\n-                new HashSet<String>(to.getAllTextFlows().keySet());\n-        int count = 0;\n-        for (TextFlow tf : from) {\n-            if (!incomingIds.add(tf.getId())) {\n-                Response response = Response.status(Status.BAD_REQUEST).entity(\n-                        \"encountered TextFlow with duplicate ID \" + tf.getId())\n-                        .build();\n-                log.warn(\n-                        \"encountered TextFlow with duplicate ID {}\", tf.getId());\n-                throw new WebApplicationException(response);\n-            }\n-            HTextFlow textFlow;\n-            if (previousIds.contains(tf.getId())) {\n-                previousIds.remove(tf.getId());\n-                textFlow = to.getAllTextFlows().get(tf.getId());\n-                textFlow.setObsolete(false);\n-                to.getTextFlows().add(textFlow);\n-                // avoid changing revision when resurrecting an unchanged TF\n-                if (transferFromTextFlow(tf, textFlow, enabledExtensions)) {\n-                    // content\n-                    // has\n-                    // changed\n-                    textFlow.setRevision(nextDocRev);\n-                    changed = true;\n-                    for (HTextFlowTarget targ : textFlow.getTargets()\n-                            .values()) {\n-                        // if (targ.getState() != ContentState.New)\n-                        if (targ.getState().isTranslated()) {\n-                            targ.setState(ContentState.NeedReview);\n-                            targ.setVersionNum(targ.getVersionNum() + 1);\n-                        }\n-                    }\n-                    log.debug(\"TextFlow with id {} has changed\", tf.getId());\n-                }\n-            } else {\n-                textFlow = new HTextFlow();\n-                textFlow.setDocument(to);\n-                textFlow.setResId(tf.getId());\n-                textFlow.setRevision(nextDocRev);\n-                transferFromTextFlow(tf, textFlow, enabledExtensions);\n-                changed = true;\n-                to.getAllTextFlows().put(textFlow.getResId(), textFlow);\n-                to.getTextFlows().add(textFlow);\n-                entityManager.persist(textFlow);\n-                log.debug(\"TextFlow with id {} is new\", tf.getId());\n-            }\n-            count++;\n-            if (count % 100 == 0) {\n-                entityManager.flush();\n-            }\n-            // FIXME we can't clear entityManager here. See\n-            // org.zanata.feature.rest.CopyTransTest.testPushTranslationAndCopyTrans.\n-            // If you clear, last copyTran REST call will trigger exception on\n-            // the server (hDocument.getTextFlows() will contain null entries -\n-            // corrupted collection.\n-            // see\n-            // https://github.com/zanata/zanata-server/pull/571#issuecomment-55547577)\n-            /*\n-             * if (count % 500 == 0) { // this in some cases seem to slow down\n-             * overall performance entityManager.clear(); to =\n-             * entityManager.find(HDocument.class, to.getId()); }\n-             */\n-        }\n-        // set remaining textflows to obsolete.\n-        for (String id : previousIds) {\n-            HTextFlow textFlow = to.getAllTextFlows().get(id);\n-            if (!textFlow.isObsolete()) {\n-                changed = true;\n-                log.debug(\"TextFlow with id {} is now obsolete\", id);\n-                textFlow.setRevision(to.getRevision());\n-                textFlow.setObsolete(true);\n+  }\n+\n+  Properties getPluralForms() {\n+    return pluralForms;\n+  }\n+\n+  /**\n+   * Merges the list of TextFlows into the target HDocument, adding and\n+   * obsoleting TextFlows as necessary.\n+   *\n+   * @param from\n+   * @param to\n+   * @return\n+   */\n+  boolean transferFromTextFlows(List<TextFlow> from, HDocument to,\n+                                Set<String> enabledExtensions, int nextDocRev) {\n+    boolean changed = false;\n+    to.getTextFlows().clear();\n+    Set<String> incomingIds = new HashSet<String>();\n+    Set<String> previousIds =\n+      new HashSet<String>(to.getAllTextFlows().keySet());\n+    int count = 0;\n+    for (TextFlow tf : from) {\n+      if (!incomingIds.add(tf.getId())) {\n+        Response response = Response.status(Status.BAD_REQUEST).entity(\n+          \"encountered TextFlow with duplicate ID \" + tf.getId())\n+          .build();\n+        log.warn(\n+          \"encountered TextFlow with duplicate ID {}\", tf.getId());\n+        throw new WebApplicationException(response);\n+      }\n+      HTextFlow textFlow;\n+      if (previousIds.contains(tf.getId())) {\n+        previousIds.remove(tf.getId());\n+        textFlow = to.getAllTextFlows().get(tf.getId());\n+        textFlow.setObsolete(false);\n+        to.getTextFlows().add(textFlow);\n+        // avoid changing revision when resurrecting an unchanged TF\n+        if (transferFromTextFlow(tf, textFlow, enabledExtensions)) {\n+          // content\n+          // has\n+          // changed\n+          textFlow.setRevision(nextDocRev);\n+          changed = true;\n+          for (HTextFlowTarget targ : textFlow.getTargets()\n+            .values()) {\n+            // if (targ.getState() != ContentState.New)\n+            if (targ.getState().isTranslated()) {\n+              targ.setState(ContentState.NeedReview);\n+              targ.setVersionNum(targ.getVersionNum() + 1);\n             }\n-        }\n-        if (changed)\n-            to.setRevision(nextDocRev);\n-        return changed;\n-    }\n-\n-    /**\n-     * Merges from the DTO Resource into HDocument, adding and obsoleting\n-     * textflows, including metadata and the specified extensions\n-     *\n-     * @param from\n-     * @param to\n-     * @param enabledExtensions\n-     * @return\n-     */\n-    public boolean transferFromResource(Resource from, HDocument to,\n-            Set<String> enabledExtensions, HLocale locale, int nextDocRev) {\n-        boolean changed = false;\n-        changed |= transferFromResourceMetadata(from, to, enabledExtensions,\n-                locale, nextDocRev);\n-        changed |= transferFromTextFlows(from.getTextFlows(), to,\n-                enabledExtensions, nextDocRev);\n-        return changed;\n-    }\n-\n-    /**\n-     * Transfers metadata and the specified extensions from DTO\n-     * AbstractResourceMeta into HDocument\n-     *\n-     * @param from\n-     * @param to\n-     * @param enabledExtensions\n-     * @return\n-     */\n-    public boolean transferFromResourceMetadata(AbstractResourceMeta from,\n-            HDocument to, Set<String> enabledExtensions, HLocale locale,\n-            int nextDocRev) {\n-        boolean changed = false;\n-        // name\n-        if (!equals(from.getName(), to.getDocId())) {\n-            to.setFullPath(from.getName());\n-            changed = true;\n-        }\n-        // locale\n-        if (!equals(from.getLang(), to.getLocale().getLocaleId())) {\n-            log.debug(\"locale: {}\", from.getLang());\n-            to.setLocale(locale);\n-            changed = true;\n-        }\n-        // contentType\n-        if (!equals(from.getContentType(), to.getContentType())) {\n-            to.setContentType(from.getContentType());\n-            changed = true;\n-        }\n-        // handle extensions\n-        changed |= transferFromResourceExtensions(from.getExtensions(true), to,\n-                enabledExtensions);\n-        if (changed)\n-            to.setRevision(nextDocRev);\n-        return changed;\n-    }\n-\n-    /**\n-     * Transfers the specified extensions from DTO AbstractResourceMeta into\n-     * HDocument\n-     *\n-     * @param from\n-     * @param to\n-     * @param enabledExtensions\n-     * @return\n-     * @see #transferFromResource\n-     */\n-    private boolean transferFromResourceExtensions(\n-            ExtensionSet<AbstractResourceMetaExtension> from, HDocument to,\n-            Set<String> enabledExtensions) {\n-        boolean changed = false;\n-        if (enabledExtensions.contains(PoHeader.ID)) {\n-            PoHeader poHeaderExt = from.findByType(PoHeader.class);\n-            if (poHeaderExt != null) {\n-                HPoHeader poHeader = to.getPoHeader();\n-                if (poHeader == null) {\n-                    log.debug(\"create a new HPoHeader\");\n-                    poHeader = new HPoHeader();\n-                }\n-                changed |= transferFromPoHeader(poHeaderExt, poHeader);\n-                if (to.getPoHeader() == null && changed) {\n-                    to.setPoHeader(poHeader);\n-                }\n-            }\n-        }\n-        return changed;\n-    }\n-\n-    /**\n-     * Transfers enabled extensions from TranslationsResource into HDocument for\n-     * a single locale\n-     *\n-     * @param from\n-     * @param doc\n-     * @param enabledExtensions\n-     * @param locale\n-     * @param mergeType\n-     * @return\n-     * @see #transferToTranslationsResourceExtensions\n-     */\n-    public boolean transferFromTranslationsResourceExtensions(\n-            ExtensionSet<TranslationsResourceExtension> from, HDocument doc,\n-            Set<String> enabledExtensions, HLocale locale,\n-            MergeType mergeType) {\n-        boolean changed = false;\n-        if (enabledExtensions.contains(PoTargetHeader.ID)) {\n-            PoTargetHeader fromTargetHeader =\n-                    from.findByType(PoTargetHeader.class);\n-            if (fromTargetHeader != null) {\n-                log.debug(\"found PO header for locale: {}\", locale);\n-                try {\n-                    changed = tryGetOrCreateTargetHeader(doc, locale, mergeType,\n-                            changed, fromTargetHeader);\n-                } catch (org.hibernate.exception.ConstraintViolationException e) {\n-                    entityManager.refresh(doc);\n-                    changed = tryGetOrCreateTargetHeader(doc, locale, mergeType,\n-                            changed, fromTargetHeader);\n-                }\n-            } else {\n-                changed |= doc.getPoTargetHeaders().remove(locale) != null;\n-            }\n-        }\n-        return changed;\n+          }\n+          log.debug(\"TextFlow with id {} has changed\", tf.getId());\n+        }\n+      } else {\n+        textFlow = new HTextFlow();\n+        textFlow.setDocument(to);\n+        textFlow.setResId(tf.getId());\n+        textFlow.setRevision(nextDocRev);\n+        transferFromTextFlow(tf, textFlow, enabledExtensions);\n+        changed = true;\n+        to.getAllTextFlows().put(textFlow.getResId(), textFlow);\n+        to.getTextFlows().add(textFlow);\n+        entityManager.persist(textFlow);\n+        log.debug(\"TextFlow with id {} is new\", tf.getId());\n+      }\n+      count++;\n+      if (count % 100 == 0) {\n+        entityManager.flush();\n+      }\n+      // FIXME we can't clear entityManager here. See\n+      // org.zanata.feature.rest.CopyTransTest.testPushTranslationAndCopyTrans.\n+      // If you clear, last copyTran REST call will trigger exception on\n+      // the server (hDocument.getTextFlows() will contain null entries -\n+      // corrupted collection.\n+      // see\n+      // https://github.com/zanata/zanata-server/pull/571#issuecomment-55547577)\n+      /*\n+       * if (count % 500 == 0) { // this in some cases seem to slow down\n+       * overall performance entityManager.clear(); to =\n+       * entityManager.find(HDocument.class, to.getId()); }\n+       */\n     }\n-\n-    private boolean tryGetOrCreateTargetHeader(HDocument doc, HLocale locale,\n-            MergeType mergeType, boolean changed,\n-            PoTargetHeader fromTargetHeader) {\n-        HPoTargetHeader toTargetHeader = doc.getPoTargetHeaders().get(locale);\n-        if (toTargetHeader == null) {\n-            changed = true;\n-            toTargetHeader = new HPoTargetHeader();\n-            toTargetHeader.setTargetLanguage(locale);\n-            toTargetHeader.setDocument(doc);\n-            transferFromPoTargetHeader(fromTargetHeader, toTargetHeader,\n-                    MergeType.IMPORT); // return\n-            // value\n-            // not\n-            // needed\n-            entityManager.persist(toTargetHeader);\n-            entityManager.flush();\n-        } else {\n-            changed |= transferFromPoTargetHeader(fromTargetHeader,\n-                    toTargetHeader, mergeType);\n+    // set remaining textflows to obsolete.\n+    for (String id : previousIds) {\n+      HTextFlow textFlow = to.getAllTextFlows().get(id);\n+      if (!textFlow.isObsolete()) {\n+        changed = true;\n+        log.debug(\"TextFlow with id {} is now obsolete\", id);\n+        textFlow.setRevision(to.getRevision());\n+        textFlow.setObsolete(true);\n+      }\n+    }\n+    if (changed) {\n+      to.setRevision(nextDocRev);\n+    }\n+    return changed;\n+  }\n+\n+  /**\n+   * Merges from the DTO Resource into HDocument, adding and obsoleting\n+   * textflows, including metadata and the specified extensions\n+   *\n+   * @param from\n+   * @param to\n+   * @param enabledExtensions\n+   * @return\n+   */\n+  public boolean transferFromResource(Resource from, HDocument to,\n+                                      Set<String> enabledExtensions, HLocale locale, int nextDocRev) {\n+    boolean changed = false;\n+    changed |= transferFromResourceMetadata(from, to, enabledExtensions,\n+      locale, nextDocRev);\n+    changed |= transferFromTextFlows(from.getTextFlows(), to,\n+      enabledExtensions, nextDocRev);\n+    return changed;\n+  }\n+\n+  /**\n+   * Transfers metadata and the specified extensions from DTO\n+   * AbstractResourceMeta into HDocument\n+   *\n+   * @param from\n+   * @param to\n+   * @param enabledExtensions\n+   * @return\n+   */\n+  public boolean transferFromResourceMetadata(AbstractResourceMeta from,\n+                                              HDocument to, Set<String> enabledExtensions, HLocale locale,\n+                                              int nextDocRev) {\n+    boolean changed = false;\n+    // name\n+    if (!equals(from.getName(), to.getDocId())) {\n+      to.setFullPath(from.getName());\n+      changed = true;\n+    }\n+    // locale\n+    if (!equals(from.getLang(), to.getLocale().getLocaleId())) {\n+      log.debug(\"locale: {}\", from.getLang());\n+      to.setLocale(locale);\n+      changed = true;\n+    }\n+    // contentType\n+    if (!equals(from.getContentType(), to.getContentType())) {\n+      to.setContentType(from.getContentType());\n+      changed = true;\n+    }\n+    // handle extensions\n+    changed |= transferFromResourceExtensions(from.getExtensions(true), to,\n+      enabledExtensions);\n+    if (changed) {\n+      to.setRevision(nextDocRev);\n+    }\n+    return changed;\n+  }\n+\n+  /**\n+   * Transfers the specified extensions from DTO AbstractResourceMeta into\n+   * HDocument\n+   *\n+   * @param from\n+   * @param to\n+   * @param enabledExtensions\n+   * @return\n+   * @see #transferFromResource\n+   */\n+  private boolean transferFromResourceExtensions(\n+    ExtensionSet<AbstractResourceMetaExtension> from, HDocument to,\n+    Set<String> enabledExtensions) {\n+    boolean changed = false;\n+    if (enabledExtensions.contains(PoHeader.ID)) {\n+      PoHeader poHeaderExt = from.findByType(PoHeader.class);\n+      if (poHeaderExt != null) {\n+        HPoHeader poHeader = to.getPoHeader();\n+        if (poHeader == null) {\n+          log.debug(\"create a new HPoHeader\");\n+          poHeader = new HPoHeader();\n+        }\n+        changed |= transferFromPoHeader(poHeaderExt, poHeader);\n+        if (to.getPoHeader() == null && changed) {\n+          to.setPoHeader(poHeader);\n+        }\n+      }\n+    }\n+    return changed;\n+  }\n+\n+  /**\n+   * Transfers enabled extensions from TranslationsResource into HDocument for\n+   * a single locale\n+   *\n+   * @param from\n+   * @param doc\n+   * @param enabledExtensions\n+   * @param locale\n+   * @param mergeType\n+   * @return\n+   * @see #transferToTranslationsResourceExtensions\n+   */\n+  public boolean transferFromTranslationsResourceExtensions(\n+    ExtensionSet<TranslationsResourceExtension> from, HDocument doc,\n+    Set<String> enabledExtensions, HLocale locale,\n+    MergeType mergeType) {\n+    boolean changed = false;\n+    if (enabledExtensions.contains(PoTargetHeader.ID)) {\n+      PoTargetHeader fromTargetHeader =\n+        from.findByType(PoTargetHeader.class);\n+      if (fromTargetHeader != null) {\n+        log.debug(\"found PO header for locale: {}\", locale);\n+        try {\n+          changed = tryGetOrCreateTargetHeader(doc, locale, mergeType,\n+            changed, fromTargetHeader);\n+        } catch (org.hibernate.exception.ConstraintViolationException e) {\n+          entityManager.refresh(doc);\n+          changed = tryGetOrCreateTargetHeader(doc, locale, mergeType,\n+            changed, fromTargetHeader);\n+        }\n+      } else {\n+        changed |= doc.getPoTargetHeaders().remove(locale) != null;\n+      }\n+    }\n+    return changed;\n+  }\n+\n+  private boolean tryGetOrCreateTargetHeader(HDocument doc, HLocale locale,\n+                                             MergeType mergeType, boolean changed,\n+                                             PoTargetHeader fromTargetHeader) {\n+    HPoTargetHeader toTargetHeader = doc.getPoTargetHeaders().get(locale);\n+    if (toTargetHeader == null) {\n+      changed = true;\n+      toTargetHeader = new HPoTargetHeader();\n+      toTargetHeader.setTargetLanguage(locale);\n+      toTargetHeader.setDocument(doc);\n+      transferFromPoTargetHeader(fromTargetHeader, toTargetHeader,\n+        MergeType.IMPORT); // return\n+      // value\n+      // not\n+      // needed\n+      entityManager.persist(toTargetHeader);\n+      entityManager.flush();\n+    } else {\n+      changed |= transferFromPoTargetHeader(fromTargetHeader,\n+        toTargetHeader, mergeType);\n+    }\n+    return changed;\n+  }\n+\n+  private boolean transferFromTextFlowExtensions(TextFlow from, HTextFlow to,\n+                                                 Set<String> enabledExtensions) {\n+    boolean changed = false;\n+    ExtensionSet<TextFlowExtension> extensions = from.getExtensions(true);\n+    if (enabledExtensions.contains(PotEntryHeader.ID)) {\n+      PotEntryHeader entryHeader =\n+        extensions.findByType(PotEntryHeader.class);\n+      if (entryHeader != null) {\n+        HPotEntryData hEntryHeader = to.getPotEntryData();\n+        if (hEntryHeader == null) {\n+          changed = true;\n+          hEntryHeader = new HPotEntryData();\n+          to.setPotEntryData(hEntryHeader);\n+          log.debug(\"set potentryheader\");\n+        }\n+        changed |= transferFromPotEntryHeader(entryHeader, hEntryHeader,\n+          from);\n+      }\n+    }\n+    if (enabledExtensions.contains(SimpleComment.ID)) {\n+      SimpleComment comment = extensions.findByType(SimpleComment.class);\n+      if (comment != null) {\n+        HSimpleComment hComment = to.getComment();\n+        if (hComment == null) {\n+          hComment = new HSimpleComment();\n         }\n-        return changed;\n-    }\n-\n-    private boolean transferFromTextFlowExtensions(TextFlow from, HTextFlow to,\n-            Set<String> enabledExtensions) {\n-        boolean changed = false;\n-        ExtensionSet<TextFlowExtension> extensions = from.getExtensions(true);\n-        if (enabledExtensions.contains(PotEntryHeader.ID)) {\n-            PotEntryHeader entryHeader =\n-                    extensions.findByType(PotEntryHeader.class);\n-            if (entryHeader != null) {\n-                HPotEntryData hEntryHeader = to.getPotEntryData();\n-                if (hEntryHeader == null) {\n-                    changed = true;\n-                    hEntryHeader = new HPotEntryData();\n-                    to.setPotEntryData(hEntryHeader);\n-                    log.debug(\"set potentryheader\");\n-                }\n-                changed |= transferFromPotEntryHeader(entryHeader, hEntryHeader,\n-                        from);\n-            }\n+        if (!equals(comment.getValue(), hComment.getComment())) {\n+          changed = true;\n+          hComment.setComment(comment.getValue());\n+          to.setComment(hComment);\n+          log.debug(\"set comment:{}\", comment.getValue());\n         }\n-        if (enabledExtensions.contains(SimpleComment.ID)) {\n-            SimpleComment comment = extensions.findByType(SimpleComment.class);\n-            if (comment != null) {\n-                HSimpleComment hComment = to.getComment();\n-                if (hComment == null) {\n-                    hComment = new HSimpleComment();\n-                }\n-                if (!equals(comment.getValue(), hComment.getComment())) {\n-                    changed = true;\n-                    hComment.setComment(comment.getValue());\n-                    to.setComment(hComment);\n-                    log.debug(\"set comment:{}\", comment.getValue());\n-                }\n+      }\n+    }\n+    return changed;\n+  }\n+\n+  /**\n+   * @param from\n+   * @param to\n+   * @param textFlow\n+   * @return\n+   * @see #transferToPotEntryHeader(HPotEntryData, PotEntryHeader)\n+   */\n+  private boolean transferFromPotEntryHeader(PotEntryHeader from,\n+                                             HPotEntryData to, TextFlow textFlow) {\n+    boolean changed = false;\n+    if (!equals(from.getContext(), to.getContext())) {\n+      changed = true;\n+      to.setContext(from.getContext());\n+    }\n+    List<String> flagList = from.getFlags();\n+    // rhbz1012502 - should not store fuzzy tag in source document\n+    if (flagList.contains(\"fuzzy\")) {\n+      throw new WebApplicationException(String.format(\n+        \"Please remove fuzzy flags from document. First fuzzy flag was found on text flow %s with content %s\",\n+        textFlow.getId(), textFlow.getContents()), 422);\n+    }\n+    String flags = StringUtil.concat(flagList, ',');\n+    if (flagList.isEmpty()) {\n+      flags = null;\n+    }\n+    if (!equals(flags, to.getFlags())) {\n+      changed = true;\n+      to.setFlags(flags);\n+    }\n+    List<String> refList = from.getReferences();\n+    String refs = StringUtil.concat(from.getReferences(), ',');\n+    if (refList.isEmpty()) {\n+      refs = null;\n+    }\n+    if (!equals(refs, to.getReferences())) {\n+      changed = true;\n+      to.setReferences(refs);\n+    }\n+    return changed;\n+  }\n+\n+  /**\n+   * @param from\n+   * @param to\n+   * @param mergeType\n+   * @return\n+   * @see #transferFromTranslationsResourceExtensions\n+   * @see #transferToPoTargetHeader\n+   */\n+  private boolean transferFromPoTargetHeader(PoTargetHeader from,\n+                                             HPoTargetHeader to, MergeType mergeType) {\n+    boolean changed = pushPoTargetComment(from, to, mergeType);\n+    // TODO we should probably block PoHeader/POT-specific entries\n+    // ie POT-Creation-Date, Project-Id-Version, Report-Msgid-Bugs-To\n+    String entries = PoUtility.listToHeader(from.getEntries());\n+    if (!equals(entries, to.getEntries())) {\n+      to.setEntries(entries);\n+      changed = true;\n+    }\n+    return changed;\n+  }\n+\n+  /**\n+   * @param fromHeader\n+   * @param toHeader\n+   * @param mergeType\n+   * @return\n+   * @see #pullPoTargetComment\n+   */\n+  protected boolean pushPoTargetComment(PoTargetHeader fromHeader,\n+                                        HPoTargetHeader toHeader, MergeType mergeType) {\n+    boolean changed = false;\n+    HSimpleComment hComment = toHeader.getComment();\n+    if (hComment == null) {\n+      hComment = new HSimpleComment();\n+    }\n+    String fromComment = fromHeader.getComment();\n+    String toComment = hComment.getComment();\n+    if (!equals(fromComment, toComment)) {\n+      // skip #zanata lines\n+      List<String> fromLines = splitLines(fromComment, ZANATA_TAG);\n+      StringBuilder sb = new StringBuilder(fromComment.length());\n+      switch (mergeType) {\n+      case IMPORT:\n+        for (String line : fromLines) {\n+          if (sb.length() != 0) {\n+            sb.append(NEWLINE);\n+          }\n+          sb.append(line);\n+          changed = true;\n+        }\n+        break;\n+\n+      default:\n+        // AUTO or anything else will merge comments\n+        // to merge, we just append new lines, skip old lines\n+        List<String> toLines = Collections.emptyList();\n+        if (toComment != null) {\n+          sb.append(toComment);\n+          toLines = splitLines(toComment, null);\n+        }\n+        for (String line : fromLines) {\n+          if (!toLines.contains(line)) {\n+            if (sb.length() != 0) {\n+              sb.append(NEWLINE);\n             }\n-        }\n-        return changed;\n-    }\n-\n-    /**\n-     * @see #transferToPotEntryHeader(HPotEntryData, PotEntryHeader)\n-     * @param from\n-     * @param to\n-     * @param textFlow\n-     * @return\n-     */\n-    private boolean transferFromPotEntryHeader(PotEntryHeader from,\n-            HPotEntryData to, TextFlow textFlow) {\n-        boolean changed = false;\n-        if (!equals(from.getContext(), to.getContext())) {\n-            changed = true;\n-            to.setContext(from.getContext());\n-        }\n-        List<String> flagList = from.getFlags();\n-        // rhbz1012502 - should not store fuzzy tag in source document\n-        if (flagList.contains(\"fuzzy\")) {\n-            throw new WebApplicationException(String.format(\n-                    \"Please remove fuzzy flags from document. First fuzzy flag was found on text flow %s with content %s\",\n-                    textFlow.getId(), textFlow.getContents()), 422);\n-        }\n-        String flags = StringUtil.concat(flagList, ',');\n-        if (flagList.isEmpty()) {\n-            flags = null;\n-        }\n-        if (!equals(flags, to.getFlags())) {\n-            changed = true;\n-            to.setFlags(flags);\n-        }\n-        List<String> refList = from.getReferences();\n-        String refs = StringUtil.concat(from.getReferences(), ',');\n-        if (refList.isEmpty()) {\n-            refs = null;\n-        }\n-        if (!equals(refs, to.getReferences())) {\n-            changed = true;\n-            to.setReferences(refs);\n-        }\n-        return changed;\n-    }\n-\n-    /**\n-     * @param from\n-     * @param to\n-     * @param mergeType\n-     * @return\n-     * @see #transferFromTranslationsResourceExtensions\n-     * @see #transferToPoTargetHeader\n-     */\n-    private boolean transferFromPoTargetHeader(PoTargetHeader from,\n-            HPoTargetHeader to, MergeType mergeType) {\n-        boolean changed = pushPoTargetComment(from, to, mergeType);\n-        // TODO we should probably block PoHeader/POT-specific entries\n-        // ie POT-Creation-Date, Project-Id-Version, Report-Msgid-Bugs-To\n-        String entries = PoUtility.listToHeader(from.getEntries());\n-        if (!equals(entries, to.getEntries())) {\n-            to.setEntries(entries);\n+            sb.append(line);\n             changed = true;\n+          }\n         }\n-        return changed;\n-    }\n-\n-    /**\n-     * @param fromHeader\n-     * @param toHeader\n-     * @param mergeType\n-     * @return\n-     * @see #pullPoTargetComment\n-     */\n-    protected boolean pushPoTargetComment(PoTargetHeader fromHeader,\n-            HPoTargetHeader toHeader, MergeType mergeType) {\n-        boolean changed = false;\n-        HSimpleComment hComment = toHeader.getComment();\n-        if (hComment == null) {\n-            hComment = new HSimpleComment();\n-        }\n-        String fromComment = fromHeader.getComment();\n-        String toComment = hComment.getComment();\n-        if (!equals(fromComment, toComment)) {\n-            // skip #zanata lines\n-            List<String> fromLines = splitLines(fromComment, ZANATA_TAG);\n-            StringBuilder sb = new StringBuilder(fromComment.length());\n-            switch (mergeType) {\n-            case IMPORT:\n-                for (String line : fromLines) {\n-                    if (sb.length() != 0)\n-                        sb.append(NEWLINE);\n-                    sb.append(line);\n-                    changed = true;\n-                }\n-                break;\n-\n-            default:\n-                // AUTO or anything else will merge comments\n-                // to merge, we just append new lines, skip old lines\n-                List<String> toLines = Collections.emptyList();\n-                if (toComment != null) {\n-                    sb.append(toComment);\n-                    toLines = splitLines(toComment, null);\n-                }\n-                for (String line : fromLines) {\n-                    if (!toLines.contains(line)) {\n-                        if (sb.length() != 0)\n-                            sb.append(NEWLINE);\n-                        sb.append(line);\n-                        changed = true;\n-                    }\n-                }\n-                break;\n+        break;\n \n-            }\n-            if (changed) {\n-                hComment.setComment(sb.toString());\n-                toHeader.setComment(hComment);\n-            }\n-        }\n-        return changed;\n-    }\n-\n-    /**\n-     * splits s into lines, skipping any which contain tagToSkip\n-     *\n-     * @param s\n-     * @param tagToSkip\n-     * @return\n-     */\n-    static List<String> splitLines(String s, String tagToSkip) {\n-        if (s.isEmpty()) {\n-            return Collections.emptyList();\n-        }\n-        try {\n-            List<String> lineList = new ArrayList<String>(s.length() / 40);\n-            BufferedReader reader = new BufferedReader(new StringReader(s));\n-            String line;\n-            while ((line = reader.readLine()) != null) {\n-                if (tagToSkip == null || !line.contains(tagToSkip)) {\n-                    lineList.add(line);\n-                }\n-            }\n-            return lineList;\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n+      }\n+      if (changed) {\n+        hComment.setComment(sb.toString());\n+        toHeader.setComment(hComment);\n+      }\n     }\n-\n-    private boolean transferFromPoHeader(PoHeader from, HPoHeader to) {\n-        boolean changed = false;\n-        HSimpleComment comment = to.getComment();\n-        if (comment == null) {\n-            comment = new HSimpleComment();\n-        }\n-        if (!equals(from.getComment(), comment.getComment())) {\n-            changed = true;\n-            comment.setComment(from.getComment());\n-            to.setComment(comment);\n-        }\n-        String entries = PoUtility.listToHeader(from.getEntries());\n-        if (!equals(entries, to.getEntries())) {\n-            to.setEntries(entries);\n-            changed = true;\n-        }\n-        return changed;\n+    return changed;\n+  }\n+\n+  /**\n+   * splits s into lines, skipping any which contain tagToSkip\n+   *\n+   * @param s\n+   * @param tagToSkip\n+   * @return\n+   */\n+  static List<String> splitLines(String s, String tagToSkip) {\n+    if (s.isEmpty()) {\n+      return Collections.emptyList();\n     }\n-\n-    public static <T> boolean equals(T a, T b) {\n-        if (a == null && b == null) {\n-            return true;\n-        }\n-        if (a == null || b == null) {\n-            return false;\n-        }\n-        return a.equals(b);\n+    try {\n+      List<String> lineList = new ArrayList<String>(s.length() / 40);\n+      BufferedReader reader = new BufferedReader(new StringReader(s));\n+      String line;\n+      while ((line = reader.readLine()) != null) {\n+        if (tagToSkip == null || !line.contains(tagToSkip)) {\n+          lineList.add(line);\n+        }\n+      }\n+      return lineList;\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n     }\n+  }\n \n-    private boolean transferFromTextFlow(TextFlow from, HTextFlow to,\n-            Set<String> enabledExtensions) {\n-        boolean changed = false;\n-        if (!equals(from.getContents(), to.getContents())) {\n-            to.setContents(from.getContents());\n-            changed = true;\n-        }\n-        if (!equals(from.isPlural(), to.isPlural())) {\n-            to.setPlural(from.isPlural());\n-            changed = true;\n-        }\n-        // TODO from.getLang()\n-        transferFromTextFlowExtensions(from, to, enabledExtensions);\n-        return changed;\n+  private boolean transferFromPoHeader(PoHeader from, HPoHeader to) {\n+    boolean changed = false;\n+    HSimpleComment comment = to.getComment();\n+    if (comment == null) {\n+      comment = new HSimpleComment();\n     }\n-\n-    public void transferToResource(HDocument from, Resource to) {\n-        transferToAbstractResourceMeta(from, to);\n+    if (!equals(from.getComment(), comment.getComment())) {\n+      changed = true;\n+      comment.setComment(from.getComment());\n+      to.setComment(comment);\n     }\n-\n-    private void transferToPoHeader(HPoHeader from, PoHeader to) {\n-        if (from.getComment() != null) {\n-            to.setComment(from.getComment().getComment());\n-        }\n-        to.getEntries().addAll(PoUtility.headerToList(from.getEntries()));\n-    }\n-\n-    /**\n-     * @param from\n-     * @param to\n-     * @param hTargets\n-     * @param locale\n-     * @see #transferToTranslationsResourceExtensions\n-     * @see #transferFromPoTargetHeader\n-     */\n-    private void transferToPoTargetHeader(HPoTargetHeader from,\n-            PoTargetHeader to, List<HTextFlowTarget> hTargets, HLocale locale) {\n-        pullPoTargetComment(from, to, hTargets);\n-        to.getEntries().addAll(this.headerToList(from.getEntries()));\n-        populateHeaderEntries(to.getEntries(), hTargets, locale);\n-    }\n-\n-    /**\n-     * Transforms a set of header entries from a String to a list of POJOs.\n-     *\n-     * @param entries\n-     *            The header entries' string.\n-     */\n-    private List<HeaderEntry> headerToList(final String entries) {\n-        return PoUtility.headerToList(entries);\n-    }\n-\n-    /**\n-     * Populates a list of header entries with values stored in the system. For\n-     * certain headers, the original value will remain if present.\n-     *\n-     * @param headerEntries\n-     *            The header entries to be populated.\n-     * @param hTargets\n-     *            The Text Flow Targets that the header applies to.\n-     * @param locale\n-     *            The locale that is bein\n-     */\n-    private void populateHeaderEntries(final List<HeaderEntry> headerEntries,\n-            final List<HTextFlowTarget> hTargets, final HLocale locale) {\n-        final Map<String, HeaderEntry> containedHeaders =\n-                new LinkedHashMap<String, HeaderEntry>(headerEntries.size());\n-        HTextFlowTarget lastChangedTarget = getLastChangedTarget(hTargets);\n-        // Collect the existing header entries\n-        for (HeaderEntry entry : headerEntries) {\n-            containedHeaders.put(entry.getKey(), entry);\n-        }\n-        // Add / Replace headers\n-        Date revisionDate =\n-                this.getRevisionDate(headerEntries, lastChangedTarget);\n-        HeaderEntry headerEntry = containedHeaders.get(PO_REVISION_DATE_HDR);\n-        if (headerEntry == null) {\n-            headerEntry = new HeaderEntry(PO_REVISION_DATE_HDR,\n-                    this.toPoHeaderString(revisionDate));\n-            headerEntries.add(headerEntry);\n-        } else {\n-            headerEntry.setValue(this.toPoHeaderString(revisionDate));\n-        }\n-        headerEntry = containedHeaders.get(LAST_TRANSLATOR_HDR);\n-        if (headerEntry == null) {\n-            headerEntry = new HeaderEntry(LAST_TRANSLATOR_HDR,\n-                    this.getLastTranslator(lastChangedTarget, headerEntries));\n-            headerEntries.add(headerEntry);\n-        } else {\n-            headerEntry.setValue(\n-                    this.getLastTranslator(lastChangedTarget, headerEntries));\n-        }\n-        headerEntry = containedHeaders.get(LANGUAGE_TEAM_HDR);\n-        if (headerEntry == null) {\n-            headerEntry = new HeaderEntry(LANGUAGE_TEAM_HDR,\n-                    this.getLanguageTeam(locale));\n-            headerEntries.add(headerEntry);\n-        } else {\n-            // Keep the original value if provided\n-        }\n-        headerEntry = containedHeaders.get(LANGUAGE_HDR);\n-        if (headerEntry == null) {\n-            headerEntry =\n-                    new HeaderEntry(LANGUAGE_HDR, this.getLanguage(locale));\n-            headerEntries.add(headerEntry);\n-        } else {\n-            headerEntry.setValue(this.getLanguage(locale));\n-        }\n-        headerEntry = containedHeaders.get(X_GENERATOR_HDR);\n-        if (headerEntry == null) {\n-            headerEntry =\n-                    new HeaderEntry(X_GENERATOR_HDR, this.getSystemVersion());\n-            headerEntries.add(headerEntry);\n-        } else {\n-            headerEntry.setValue(this.getSystemVersion());\n-        }\n-        headerEntry = containedHeaders.get(CONTENT_TYPE_HDR);\n-        if (headerEntry == null) {\n-            headerEntry =\n-                    new HeaderEntry(CONTENT_TYPE_HDR, PO_DEFAULT_CONTENT_TYPE);\n-            headerEntries.add(headerEntry);\n-        } else {\n-            headerEntry.setValue(PO_DEFAULT_CONTENT_TYPE);\n-        }\n-        headerEntry = containedHeaders.get(PLURAL_FORMS_HDR);\n-        if (headerEntry == null || isBlank(headerEntry.getValue())) {\n-            headerEntry = new HeaderEntry(PLURAL_FORMS_HDR,\n-                    this.getPluralForms(locale));\n-            headerEntries.add(headerEntry);\n-        } else {\n-            // Keep the original if provided\n-        }\n+    String entries = PoUtility.listToHeader(from.getEntries());\n+    if (!equals(entries, to.getEntries())) {\n+      to.setEntries(entries);\n+      changed = true;\n     }\n+    return changed;\n+  }\n \n-    /**\n-     * Finds and returns the Revision Date stored in a PO file's header entries.\n-     *\n-     * @param headerEntries\n-     *            A single PO file's header entries.\n-     * @return The Revision Date header value, or null if no such header is\n-     *         found or the date cannot be parsed.\n-     */\n-    private Date getHeaderRevisionDate(final List<HeaderEntry> headerEntries) {\n-        Date poFileRevisionDate = null;\n-        for (HeaderEntry entry : headerEntries) {\n-            if (entry.getKey().equalsIgnoreCase(PO_REVISION_DATE_HDR)) {\n-                SimpleDateFormat dateFormat =\n-                        new SimpleDateFormat(PO_DATE_FORMAT);\n-                try {\n-                    poFileRevisionDate = dateFormat.parse(entry.getValue());\n-                } catch (ParseException e) {\n-                    // found the header but date could not be parsed\n-                }\n-                break;\n-            }\n-        }\n-        return poFileRevisionDate;\n+  public static <T> boolean equals(T a, T b) {\n+    if (a == null && b == null) {\n+      return true;\n     }\n-\n-    private String\n-            getHeaderLastTranslator(final List<HeaderEntry> headerEntries) {\n-        for (HeaderEntry entry : headerEntries) {\n-            if (entry.getKey().equalsIgnoreCase(LAST_TRANSLATOR_HDR)) {\n-                return entry.getValue();\n-            }\n-        }\n-        return \"\";\n-    }\n-\n-    /**\n-     * Returns a PO file's Revision Date based on the values stored in the\n-     * file's header and in the last translated target. If the system cannot\n-     * determine a suitable Revision date, a null value is returned.\n-     */\n-    private Date getRevisionDate(final List<HeaderEntry> headerEntries,\n-            final HTextFlowTarget lastTranslated) {\n-        Date poFileRevisionDate = this.getHeaderRevisionDate(headerEntries);\n-        Date translationsRevisionDate = null;\n-        if (lastTranslated != null) {\n-            translationsRevisionDate = lastTranslated.getLastChanged();\n-        }\n-        if (translationsRevisionDate != null) {\n-            if (poFileRevisionDate != null) {\n-                return translationsRevisionDate.after(poFileRevisionDate)\n-                        ? translationsRevisionDate : poFileRevisionDate;\n-            } else {\n-                return translationsRevisionDate;\n-            }\n-        } else {\n-            return poFileRevisionDate == null ? null : poFileRevisionDate;\n-        }\n+    if (a == null || b == null) {\n+      return false;\n     }\n-\n-    /**\n-     * @param translations\n-     *            - List of HTextFlowTarget\n-     * @return last changed/updated HTextFlowTarget from the list\n-     */\n-    private HTextFlowTarget\n-            getLastChangedTarget(final List<HTextFlowTarget> translations) {\n-        Date lastUpdate = new Date(Long.MIN_VALUE);\n-        HTextFlowTarget lastChanged = null;\n-        for (HTextFlowTarget tft : translations) {\n-            if (tft.getLastChanged().after(lastUpdate)) {\n-                lastChanged = tft;\n-                lastUpdate = tft.getLastChanged();\n-            }\n-        }\n-        return lastChanged;\n-    }\n-\n-    /**\n-     * Gets the last translator header value for a set of header entries and the\n-     * last translated target.\n-     *\n-     * @param lastTranslated\n-     *            The most currently translated target.\n-     * @param headerEntries\n-     *            The PO header entries.\n-     * @return A string with the value of the last translator.\n-     */\n-    private String getLastTranslator(final HTextFlowTarget lastTranslated,\n-            final List<HeaderEntry> headerEntries) {\n-        Date headerRevisionDate = this.getHeaderRevisionDate(headerEntries);\n-        String lastTranslator = this.getHeaderLastTranslator(headerEntries);\n-        if (lastTranslated != null) {\n-            HPerson lastTranslatedBy = lastTranslated.getTranslator();\n-            Date lastModifiedDate = lastTranslated.getLastChanged();\n-            if (lastTranslatedBy != null) {\n-                if (lastModifiedDate == null\n-                        || lastModifiedDate.after(headerRevisionDate)) {\n-                    /**\n-                     * Use translator details from last translated target if the\n-                     * lastModifiedDate is null or if lastModifiedDate is after\n-                     * date in header entries\n-                     */\n-                    lastTranslator =\n-                            generateLastTranslator(lastTranslatedBy.getName(),\n-                                    lastTranslatedBy.getEmail());\n-                }\n-            } else {\n-                /**\n-                 * When last translated target is being created in Zanata\n-                 * without user (e.g upload, copyTrans), set translator to be\n-                 * Zanata\n-                 */\n-                lastTranslator = generateLastTranslator(COPIED_BY_ZANATA_NAME,\n-                        COPIED_BY_ZANATA_NAME_EMAIL);\n-            }\n-        }\n-        return lastTranslator;\n-    }\n-\n-    /**\n-     * @param name\n-     *            - name of person\n-     * @param email\n-     *            - email of person\n-     * @return {name} <{email}>\n-     */\n-    private String generateLastTranslator(String name, String email) {\n-        return name + \" <\" + email + \">\";\n-    }\n-\n-    /**\n-     * Returns a string representation of a Date for use in a PO file header.\n-     *\n-     * @param aDate\n-     *            Date object to include in the Header\n-     * @return A string with the value of the date suitable for a PO file\n-     *         header.\n-     */\n-    private String toPoHeaderString(Date aDate) {\n-        if (aDate != null) {\n-            SimpleDateFormat dateFormat = new SimpleDateFormat(PO_DATE_FORMAT);\n-            return dateFormat.format(aDate);\n-        } else {\n-            return \"\";\n-        }\n+    return a.equals(b);\n+  }\n+\n+  private boolean transferFromTextFlow(TextFlow from, HTextFlow to,\n+                                       Set<String> enabledExtensions) {\n+    boolean changed = false;\n+    if (!equals(from.getContents(), to.getContents())) {\n+      to.setContents(from.getContents());\n+      changed = true;\n     }\n-\n-    /**\n-     * Returns the Language Team PO file header for a given locale.\n-     */\n-    private String getLanguageTeam(final HLocale hLocale) {\n-        return hLocale.retrieveDisplayName();\n+    if (!equals(from.isPlural(), to.isPlural())) {\n+      to.setPlural(from.isPlural());\n+      changed = true;\n     }\n-\n-    /**\n-     * Retrieves the language PO file header for a given locale.\n-     *\n-     * @param locale\n-     */\n-    String getLanguage(HLocale locale) {\n-        return StringUtils.replace(locale.getLocaleId().toString(), \"-\", \"_\");\n+    // TODO from.getLang()\n+    transferFromTextFlowExtensions(from, to, enabledExtensions);\n+    return changed;\n+  }\n+\n+  public void transferToResource(HDocument from, Resource to) {\n+    transferToAbstractResourceMeta(from, to);\n+  }\n+\n+  private void transferToPoHeader(HPoHeader from, PoHeader to) {\n+    if (from.getComment() != null) {\n+      to.setComment(from.getComment().getComment());\n     }\n-\n-    /**\n-     * Returns the application version.\n-     */\n-    private String getSystemVersion() {\n-        try {\n-            return ZANATA_GENERATOR_PREFIX + \" \"\n-                    + (ServiceLocator.instance()\n-                            .getInstance(ApplicationConfiguration.class))\n-                                    .getVersion();\n-        } catch (Exception e) {\n-            return ZANATA_GENERATOR_PREFIX + \" UNKNOWN\";\n-        }\n+    to.getEntries().addAll(PoUtility.headerToList(from.getEntries()));\n+  }\n+\n+  /**\n+   * @param from\n+   * @param to\n+   * @param hTargets\n+   * @param locale\n+   * @see #transferToTranslationsResourceExtensions\n+   * @see #transferFromPoTargetHeader\n+   */\n+  private void transferToPoTargetHeader(HPoTargetHeader from,\n+                                        PoTargetHeader to, List<HTextFlowTarget> hTargets, HLocale locale) {\n+    pullPoTargetComment(from, to, hTargets);\n+    to.getEntries().addAll(this.headerToList(from.getEntries()));\n+    populateHeaderEntries(to.getEntries(), hTargets, locale);\n+  }\n+\n+  /**\n+   * Transforms a set of header entries from a String to a list of POJOs.\n+   *\n+   * @param entries The header entries' string.\n+   */\n+  private List<HeaderEntry> headerToList(final String entries) {\n+    return PoUtility.headerToList(entries);\n+  }\n+\n+  /**\n+   * Populates a list of header entries with values stored in the system. For\n+   * certain headers, the original value will remain if present.\n+   *\n+   * @param headerEntries The header entries to be populated.\n+   * @param hTargets      The Text Flow Targets that the header applies to.\n+   * @param locale        The locale that is bein\n+   */\n+  private void populateHeaderEntries(final List<HeaderEntry> headerEntries,\n+                                     final List<HTextFlowTarget> hTargets, final HLocale locale) {\n+    final Map<String, HeaderEntry> containedHeaders =\n+      new LinkedHashMap<String, HeaderEntry>(headerEntries.size());\n+    HTextFlowTarget lastChangedTarget = getLastChangedTarget(hTargets);\n+    // Collect the existing header entries\n+    for (HeaderEntry entry : headerEntries) {\n+      containedHeaders.put(entry.getKey(), entry);\n     }\n-\n-    /**\n-     * Returns the appropriate plural form for a given Locale. Returns a default\n-     * value if there is no plural form information for the provided locale.\n-     */\n-    public String getPluralForms(HLocale locale) {\n-        return getPluralForms(locale.getLocaleId());\n-    }\n-\n-    /**\n-     * Returns the appropriate plural form for a given Locale Id. Returns a\n-     * default value if there is no plural form information for the provided\n-     * locale id.\n-     *\n-     * @see {@link ResourceUtils#getPluralForms(org.zanata.common.LocaleId, boolean, boolean)}\n-     */\n-    public String getPluralForms(LocaleId localeId) {\n-        return getPluralForms(localeId, true, true);\n-    }\n-\n-    /**\n-     * Returns the appropriate plural from for a given locale Id.\n-     *\n-     * From HLocale.plurals if available, else from pluralforms.properties\n-     *\n-     * @return A default value if useDefault is True. Otherwise, null.\n-     */\n-    public String getPluralForms(LocaleId localeId, boolean checkDB,\n-            boolean useDefault) {\n-        if (checkDB) {\n-            String dbPluralForms = getPluralFormsFromDB(localeId);\n-            if (isNotEmpty(dbPluralForms)) {\n-                return dbPluralForms;\n-            }\n-        }\n-        final char[] alternateSeparators = { '.', '@' };\n-        String javaLocale = localeId.toJavaName().toLowerCase();\n-        // Replace all alternate separators for the \"_\" (Java) separator.\n-        for (char sep : alternateSeparators) {\n-            javaLocale = javaLocale.replace(sep, '_');\n-        }\n-        if (pluralForms.containsKey(javaLocale)) {\n-            return pluralForms.getProperty(javaLocale);\n-        }\n-        // Try out every combination. e.g: for xxx_yyy_zzz, try xxx_yyyy_zzz,\n-        // then\n-        // xxx_yyy, then xxx\n-        while (javaLocale.indexOf('_') > 0) {\n-            javaLocale = javaLocale.substring(0, javaLocale.lastIndexOf('_'));\n-            if (pluralForms.containsKey(javaLocale)) {\n-                return pluralForms.getProperty(javaLocale);\n-            }\n-        }\n-        if (useDefault) {\n-            return DEFAULT_PLURAL_FORM;\n-        } else {\n-            return null;\n-        }\n+    // Add / Replace headers\n+    Date revisionDate =\n+      this.getRevisionDate(headerEntries, lastChangedTarget);\n+    HeaderEntry headerEntry = containedHeaders.get(PO_REVISION_DATE_HDR);\n+    if (headerEntry == null) {\n+      headerEntry = new HeaderEntry(PO_REVISION_DATE_HDR,\n+        this.toPoHeaderString(revisionDate));\n+      headerEntries.add(headerEntry);\n+    } else {\n+      headerEntry.setValue(this.toPoHeaderString(revisionDate));\n     }\n-\n-    public int getNumPlurals(HDocument document, HLocale hLocale) {\n-        HPoTargetHeader headers = document.getPoTargetHeaders().get(hLocale);\n-        String headerEntries = headers != null ? headers.getEntries() : \"\";\n-        return getNumPlurals(headerEntries, hLocale.getLocaleId());\n-    }\n-\n-    /**\n-     * return plural count info from 1) PO Header entry if available, else 2)\n-     * HLocale.plurals if available, else 3) pluralforms.properties, else 4)\n-     * assume no plural forms (nplurals=1)\n-     *\n-     * @param poHeaders\n-     *            - HPoTargetHeader.entries\n-     * @param localeId\n-     *            - locale identifier\n-     */\n-    int getNumPlurals(@Nullable String poHeaders, LocaleId localeId) {\n-        if (!isEmpty(poHeaders)) {\n-            Properties headerList = loadHeaders(poHeaders);\n-            String pluralFormsHeader = headerList.getProperty(PLURAL_FORMS_HDR);\n-            if (pluralFormsHeader != null) {\n-                if (!pluralFormsHeader.isEmpty()) {\n-                    try {\n-                        // try to parse plurals from the header\n-                        return extractNPlurals(pluralFormsHeader);\n-                    } catch (NumberFormatException | PluralParseException e) {\n-                        log.debug(\"Unable to parse plurals\", e);\n-                        // TODO return a warning to the user when uploading\n-                        log.warn(\n-                                \"Error parsing plural forms header; using defaults for locale {}; headers: {}\",\n-                                localeId, poHeaders);\n-                    }\n-                } else {\n-                    // TODO return a warning to the user when uploading\n-                    log.warn(\n-                            \"Empty plural forms header; using defaults for locale {}; headers: {}\",\n-                            localeId, poHeaders);\n-                }\n-            } else {\n-                // otherwise (no header) use the locale default\n-                log.debug(\n-                        \"No plural forms header; using defaults for locale {}; headers: {}\",\n-                        localeId, poHeaders);\n-            }\n-        }\n-        String localePluralForms = getPluralFormsForLocale(localeId);\n-        if (localePluralForms == null) {\n-            log.warn(\n-                    \"Assuming no plurals for locale {}; no plural info found in database or in {}; headers: {}\",\n-                    localeId, PLURALS_FILE, poHeaders);\n-            return DEFAULT_NPLURALS;\n-        }\n-        return extractNPlurals(localePluralForms);\n+    headerEntry = containedHeaders.get(LAST_TRANSLATOR_HDR);\n+    if (headerEntry == null) {\n+      headerEntry = new HeaderEntry(LAST_TRANSLATOR_HDR,\n+        this.getLastTranslator(lastChangedTarget, headerEntries));\n+      headerEntries.add(headerEntry);\n+    } else {\n+      headerEntry.setValue(\n+        this.getLastTranslator(lastChangedTarget, headerEntries));\n     }\n-\n-    private Properties loadHeaders(String poHeaders) {\n-        try {\n-            Properties headerList = new Properties();\n-            headerList.load(new StringReader(poHeaders));\n-            return headerList;\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n+    headerEntry = containedHeaders.get(LANGUAGE_TEAM_HDR);\n+    if (headerEntry == null) {\n+      headerEntry = new HeaderEntry(LANGUAGE_TEAM_HDR,\n+        this.getLanguageTeam(locale));\n+      headerEntries.add(headerEntry);\n+    } else {\n+      // Keep the original value if provided\n     }\n-\n-    /**\n-     * Returns HLocale.plurals if available, else value in\n-     * pluralforms.properties\n-     *\n-     * @param localeId\n-     *            id of the locale\n-     * @return the plural forms string\n-     * @throws RuntimeException\n-     *             if no plural forms are found\n-     */\n-    @Nullable\n-    private String getPluralFormsForLocale(LocaleId localeId) {\n-        String pluralForms;\n-        pluralForms = getPluralFormsFromDB(localeId);\n-        if (isEmpty(pluralForms)) {\n-            pluralForms = getPluralFormsFromFile(localeId);\n-        }\n-        return pluralForms;\n+    headerEntry = containedHeaders.get(LANGUAGE_HDR);\n+    if (headerEntry == null) {\n+      headerEntry =\n+        new HeaderEntry(LANGUAGE_HDR, this.getLanguage(locale));\n+      headerEntries.add(headerEntry);\n+    } else {\n+      headerEntry.setValue(this.getLanguage(locale));\n     }\n-\n-    /**\n-     * @return plural forms from HLocale, null if not found\n-     */\n-    @Nullable\n-    String getPluralFormsFromDB(LocaleId localeId) {\n-        HLocale hLocale = localeDAO.findByLocaleId(localeId);\n-        if (hLocale != null && isNotEmpty(hLocale.getPluralForms())) {\n-            return hLocale.getPluralForms();\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get plural forms from pluralforms.properties\n-     *\n-     * @param localeId\n-     */\n-    @Nullable\n-    String getPluralFormsFromFile(@Nonnull LocaleId localeId) {\n-        return getPluralForms(localeId, false, false);\n-    }\n-\n-    /**\n-     * Process pluralforms string and return plural count.\n-     *\n-     * @param pluralForms\n-     *            string to parse\n-     */\n-    int extractNPlurals(@Nonnull String pluralForms)\n-            throws NumberFormatException, PluralParseException {\n-        Matcher nPluralsMatcher = NPLURALS_PATTERN.matcher(pluralForms);\n-        if (nPluralsMatcher.find()) {\n-            String nPluralsString = nPluralsMatcher.group();\n-            Matcher nPluralsValueMatcher =\n-                    NPLURALS_TAG_PATTERN.matcher(nPluralsString);\n-            nPluralsString = nPluralsValueMatcher.replaceAll(\"\");\n-            if (isNotEmpty(nPluralsString)) {\n-                return Integer.parseInt(nPluralsString);\n-            }\n-        }\n-        throw new PluralParseException(\n-                \"can\\'t find valid nplurals in plural forms string: \"\n-                        + pluralForms);\n-    }\n-\n-    /**\n-     * Return if pluralForms is valid (positive value)\n-     *\n-     * @param pluralForms\n-     *            string to check\n-     */\n-    public boolean isValidPluralForms(@Nonnull String pluralForms) {\n-        if (!PLURAL_FORM_PATTERN.matcher(pluralForms).find()) {\n-            return false;\n-        }\n-        Matcher nPluralsMatcher = NPLURALS_PATTERN.matcher(pluralForms);\n-        String nPluralsString = \"\";\n-        while (nPluralsMatcher.find()) {\n-            nPluralsString = nPluralsMatcher.group();\n-            Matcher nPluralsValueMatcher =\n-                    NPLURALS_TAG_PATTERN.matcher(nPluralsString);\n-            nPluralsString = nPluralsValueMatcher.replaceAll(\"\");\n-            break;\n-        }\n+    headerEntry = containedHeaders.get(X_GENERATOR_HDR);\n+    if (headerEntry == null) {\n+      headerEntry =\n+        new HeaderEntry(X_GENERATOR_HDR, this.getSystemVersion());\n+      headerEntries.add(headerEntry);\n+    } else {\n+      headerEntry.setValue(this.getSystemVersion());\n+    }\n+    headerEntry = containedHeaders.get(CONTENT_TYPE_HDR);\n+    if (headerEntry == null) {\n+      headerEntry =\n+        new HeaderEntry(CONTENT_TYPE_HDR, PO_DEFAULT_CONTENT_TYPE);\n+      headerEntries.add(headerEntry);\n+    } else {\n+      headerEntry.setValue(PO_DEFAULT_CONTENT_TYPE);\n+    }\n+    headerEntry = containedHeaders.get(PLURAL_FORMS_HDR);\n+    if (headerEntry == null || isBlank(headerEntry.getValue())) {\n+      headerEntry = new HeaderEntry(PLURAL_FORMS_HDR,\n+        this.getPluralForms(locale));\n+      headerEntries.add(headerEntry);\n+    } else {\n+      // Keep the original if provided\n+    }\n+  }\n+\n+  /**\n+   * Finds and returns the Revision Date stored in a PO file's header entries.\n+   *\n+   * @param headerEntries A single PO file's header entries.\n+   * @return The Revision Date header value, or null if no such header is\n+   * found or the date cannot be parsed.\n+   */\n+  private Date getHeaderRevisionDate(final List<HeaderEntry> headerEntries) {\n+    Date poFileRevisionDate = null;\n+    for (HeaderEntry entry : headerEntries) {\n+      if (entry.getKey().equalsIgnoreCase(PO_REVISION_DATE_HDR)) {\n+        SimpleDateFormat dateFormat =\n+          new SimpleDateFormat(PO_DATE_FORMAT);\n         try {\n-            if (isNotEmpty(nPluralsString)) {\n-                int count = Integer.parseInt(nPluralsString);\n-                return count >= 1 && count <= MAX_TARGET_CONTENTS;\n-            }\n-        } catch (NumberFormatException e) {\n-            // invalid string for integer\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * @param fromHeader\n-     * @param toHeader\n-     * @see #pushPoTargetComment\n-     */\n-    protected void pullPoTargetComment(HPoTargetHeader fromHeader,\n-            PoTargetHeader toHeader, List<HTextFlowTarget> hTargets) {\n-        StringBuilder sb = new StringBuilder();\n-        HSimpleComment comment = fromHeader.getComment();\n-        if (comment != null) {\n-            sb.append(comment.getComment());\n-        }\n-        // generate #zanata credit comments\n-        // order by year, then alphabetically\n-        Set<TranslatorCredit> zanataCredits = new TreeSet<TranslatorCredit>();\n-        for (HTextFlowTarget tft : hTargets) {\n-            HPerson person = tft.getLastModifiedBy();\n-            if (person != null) {\n-                Calendar lastChanged = Calendar.getInstance();\n-                lastChanged.setTime(tft.getLastChanged());\n-                int year = lastChanged.get(Calendar.YEAR);\n-                TranslatorCredit credit = new TranslatorCredit();\n-                credit.setEmail(person.getEmail());\n-                credit.setName(person.getName());\n-                credit.setYear(year);\n-                zanataCredits.add(credit);\n-            }\n-        }\n-        for (TranslatorCredit credit : zanataCredits) {\n-            if (sb.length() != 0)\n-                sb.append(NEWLINE);\n-            sb.append(credit);\n-            sb.append(' ');\n-            sb.append(ZANATA_TAG);\n+          poFileRevisionDate = dateFormat.parse(entry.getValue());\n+        } catch (ParseException e) {\n+          // found the header but date could not be parsed\n         }\n-        toHeader.setComment(sb.toString());\n+        break;\n+      }\n     }\n-\n-    public void transferToTextFlow(HTextFlow from, TextFlow to) {\n-        if (from.isPlural()) {\n-            to.setContents(from.getContents());\n-        } else {\n-            to.setContents(from.getContents().get(0));\n-        }\n-        to.setRevision(from.getRevision());\n-        to.setPlural(from.isPlural());\n-        // TODO HTextFlow should have a lang\n-        // to.setLang(from.get)\n-    }\n-\n-    public void transferToAbstractResourceMeta(HDocument from,\n-            AbstractResourceMeta to) {\n-        to.setContentType(from.getContentType());\n-        to.setLang(from.getLocale().getLocaleId());\n-        to.setName(from.getDocId());\n-        // TODO ADD support within the hibernate model for multiple resource\n-        // types\n-        to.setType(ResourceType.FILE);\n-        to.setRevision(from.getRevision());\n-    }\n-\n-    public void transferToResourceExtensions(HDocument from,\n-            ExtensionSet<AbstractResourceMetaExtension> to,\n-            Set<String> enabledExtensions) {\n-        if (enabledExtensions.contains(PoHeader.ID)) {\n-            PoHeader poHeaderExt = new PoHeader();\n-            if (from.getPoHeader() != null) {\n-                transferToPoHeader(from.getPoHeader(), poHeaderExt);\n-                to.add(poHeaderExt);\n-            }\n-        }\n+    return poFileRevisionDate;\n+  }\n+\n+  private String\n+  getHeaderLastTranslator(final List<HeaderEntry> headerEntries) {\n+    for (HeaderEntry entry : headerEntries) {\n+      if (entry.getKey().equalsIgnoreCase(LAST_TRANSLATOR_HDR)) {\n+        return entry.getValue();\n+      }\n     }\n-\n-    /**\n-     * @param from\n-     * @param to\n-     * @param enabledExtensions\n-     * @param locale\n-     * @see #transferFromTranslationsResourceExtensions\n-     * @return true only if extensions were found\n-     */\n-    public boolean transferToTranslationsResourceExtensions(HDocument from,\n-            ExtensionSet<TranslationsResourceExtension> to,\n-            Set<String> enabledExtensions, HLocale locale,\n-            List<HTextFlowTarget> hTargets) {\n-        boolean found = false;\n-        if (enabledExtensions.contains(PoTargetHeader.ID)) {\n-            log.debug(\"PoTargetHeader requested\");\n-            PoTargetHeader poTargetHeader = new PoTargetHeader();\n-            HPoTargetHeader fromHeader = from.getPoTargetHeaders().get(locale);\n-            if (fromHeader != null) {\n-                found = true;\n-                log.debug(\"PoTargetHeader found\");\n-            } else {\n-                // If no header is found, use a default empty header for\n-                // generation\n-                // purposes\n-                fromHeader = new HPoTargetHeader();\n-                fromHeader.setEntries(\"\");\n-            }\n-            transferToPoTargetHeader(fromHeader, poTargetHeader, hTargets,\n-                    locale);\n-            to.add(poTargetHeader);\n-        }\n-        return found;\n+    return \"\";\n+  }\n+\n+  /**\n+   * Returns a PO file's Revision Date based on the values stored in the\n+   * file's header and in the last translated target. If the system cannot\n+   * determine a suitable Revision date, a null value is returned.\n+   */\n+  private Date getRevisionDate(final List<HeaderEntry> headerEntries,\n+                               final HTextFlowTarget lastTranslated) {\n+    Date poFileRevisionDate = this.getHeaderRevisionDate(headerEntries);\n+    Date translationsRevisionDate = null;\n+    if (lastTranslated != null) {\n+      translationsRevisionDate = lastTranslated.getLastChanged();\n     }\n-\n-    public void transferToTextFlowExtensions(HTextFlow from,\n-            ExtensionSet<TextFlowExtension> to, Set<String> enabledExtensions) {\n-        if (enabledExtensions.contains(PotEntryHeader.ID)\n-                && from.getPotEntryData() != null) {\n-            PotEntryHeader header = new PotEntryHeader();\n-            transferToPotEntryHeader(from.getPotEntryData(), header);\n-            log.debug(\"set header:{}\", from.getPotEntryData());\n-            to.add(header);\n-        }\n-        if (enabledExtensions.contains(SimpleComment.ID)\n-                && from.getComment() != null) {\n-            SimpleComment comment =\n-                    new SimpleComment(from.getComment().getComment());\n-            log.debug(\"set comment:{}\", from.getComment().getComment());\n-            to.add(comment);\n-        }\n+    if (translationsRevisionDate != null) {\n+      if (poFileRevisionDate != null) {\n+        return translationsRevisionDate.after(poFileRevisionDate)\n+          ? translationsRevisionDate : poFileRevisionDate;\n+      } else {\n+        return translationsRevisionDate;\n+      }\n+    } else {\n+      return poFileRevisionDate == null ? null : poFileRevisionDate;\n     }\n-\n-    /**\n-     * @see #transferFromPotEntryHeader(org.zanata.rest.dto.extensions.gettext.PotEntryHeader,\n-     *      org.zanata.model.po.HPotEntryData,\n-     *      org.zanata.rest.dto.resource.TextFlow)\n-     * @param from\n-     * @param to\n-     */\n-    private void transferToPotEntryHeader(HPotEntryData from,\n-            PotEntryHeader to) {\n-        to.setContext(from.getContext());\n-        List<String> flags = new ArrayList<String>(0);\n-        if (from.getFlags() != null) {\n-            flags = StringUtil.split(from.getFlags(), \",\");\n-        }\n-        to.getFlags().addAll(flags);\n-        List<String> refs = new ArrayList<String>(0);\n-        if (from.getReferences() != null) {\n-            refs = StringUtil.split(from.getReferences(), \",\");\n-        }\n-        to.getReferences().addAll(refs);\n-    }\n-\n-    /**\n-     * @param from\n-     * @param to\n-     * @param enabledExtensions\n-     * @todo merge with {@link #transferToTextFlowTarget}\n-     */\n-    public void transferToTextFlowTargetExtensions(HTextFlowTarget from,\n-            ExtensionSet<TextFlowTargetExtension> to,\n-            Set<String> enabledExtensions) {\n-        if (enabledExtensions.contains(SimpleComment.ID)\n-                && from.getComment() != null) {\n-            SimpleComment comment =\n-                    new SimpleComment(from.getComment().getComment());\n-            to.add(comment);\n-        }\n+  }\n+\n+  /**\n+   * @param translations - List of HTextFlowTarget\n+   * @return last changed/updated HTextFlowTarget from the list\n+   */\n+  private HTextFlowTarget\n+  getLastChangedTarget(final List<HTextFlowTarget> translations) {\n+    Date lastUpdate = new Date(Long.MIN_VALUE);\n+    HTextFlowTarget lastChanged = null;\n+    for (HTextFlowTarget tft : translations) {\n+      if (tft.getLastChanged().after(lastUpdate)) {\n+        lastChanged = tft;\n+        lastUpdate = tft.getLastChanged();\n+      }\n     }\n-\n-    public String encodeDocId(String id) {\n-        String other = StringUtils.replace(id, \"/\", \",\");\n-        try {\n-            other = URLEncoder.encode(other, \"UTF-8\");\n-            return StringUtils.replace(other, \"%2C\", \",\");\n-        } catch (UnsupportedEncodingException e) {\n-            throw new RuntimeException(e);\n-        }\n+    return lastChanged;\n+  }\n+\n+  /**\n+   * Gets the last translator header value for a set of header entries and the\n+   * last translated target.\n+   *\n+   * @param lastTranslated The most currently translated target.\n+   * @param headerEntries  The PO header entries.\n+   * @return A string with the value of the last translator.\n+   */\n+  private String getLastTranslator(final HTextFlowTarget lastTranslated,\n+                                   final List<HeaderEntry> headerEntries) {\n+    Date headerRevisionDate = this.getHeaderRevisionDate(headerEntries);\n+    String lastTranslator = this.getHeaderLastTranslator(headerEntries);\n+    if (lastTranslated != null) {\n+      HPerson lastTranslatedBy = lastTranslated.getTranslator();\n+      Date lastModifiedDate = lastTranslated.getLastChanged();\n+      if (lastTranslatedBy != null) {\n+        if (lastModifiedDate == null\n+          || lastModifiedDate.after(headerRevisionDate)) {\n+          /**\n+           * Use translator details from last translated target if the\n+           * lastModifiedDate is null or if lastModifiedDate is after\n+           * date in header entries\n+           */\n+          lastTranslator =\n+            generateLastTranslator(lastTranslatedBy.getName(),\n+              lastTranslatedBy.getEmail());\n+        }\n+      } else {\n+        /**\n+         * When last translated target is being created in Zanata\n+         * without user (e.g upload, copyTrans), set translator to be\n+         * Zanata\n+         */\n+        lastTranslator = generateLastTranslator(COPIED_BY_ZANATA_NAME,\n+          COPIED_BY_ZANATA_NAME_EMAIL);\n+      }\n     }\n-\n-    public String decodeDocId(String id) {\n-        try {\n-            String other = URLDecoder.decode(id, \"UTF-8\");\n-            return StringUtils.replace(other, \",\", \"/\");\n-        } catch (UnsupportedEncodingException e) {\n-            throw new RuntimeException(e);\n-        }\n+    return lastTranslator;\n+  }\n+\n+  /**\n+   * @param name  - name of person\n+   * @param email - email of person\n+   * @return {name} <{email}>\n+   */\n+  private String generateLastTranslator(String name, String email) {\n+    return name + \" <\" + email + \">\";\n+  }\n+\n+  /**\n+   * Returns a string representation of a Date for use in a PO file header.\n+   *\n+   * @param aDate Date object to include in the Header\n+   * @return A string with the value of the date suitable for a PO file\n+   * header.\n+   */\n+  private String toPoHeaderString(Date aDate) {\n+    if (aDate != null) {\n+      SimpleDateFormat dateFormat = new SimpleDateFormat(PO_DATE_FORMAT);\n+      return dateFormat.format(aDate);\n+    } else {\n+      return \"\";\n     }\n-\n-    /**\n-     * @todo merge with {@link #transferToTextFlowTargetExtensions}\n-     */\n-    @SuppressWarnings(\"deprecation\")\n-    public void transferToTextFlowTarget(HTextFlowTarget from,\n-            TextFlowTarget to, boolean markTranslatedAsApproved) {\n-        if (from.getTextFlow().isPlural()) {\n-            to.setContents(from.getContents());\n-        } else if (!from.getContents().isEmpty()) {\n-            to.setContents(from.getContents().get(0));\n+  }\n+\n+  /**\n+   * Returns the Language Team PO file header for a given locale.\n+   */\n+  private String getLanguageTeam(final HLocale hLocale) {\n+    return hLocale.retrieveDisplayName();\n+  }\n+\n+  /**\n+   * Retrieves the language PO file header for a given locale.\n+   *\n+   * @param locale\n+   */\n+  String getLanguage(HLocale locale) {\n+    return StringUtils.replace(locale.getLocaleId().toString(), \"-\", \"_\");\n+  }\n+\n+  /**\n+   * Returns the application version.\n+   */\n+  private String getSystemVersion() {\n+    try {\n+      return ZANATA_GENERATOR_PREFIX + \" \"\n+        + (ServiceLocator.instance()\n+        .getInstance(ApplicationConfiguration.class))\n+        .getVersion();\n+    } catch (Exception e) {\n+      return ZANATA_GENERATOR_PREFIX + \" UNKNOWN\";\n+    }\n+  }\n+\n+  /**\n+   * Returns the appropriate plural form for a given Locale. Returns a default\n+   * value if there is no plural form information for the provided locale.\n+   */\n+  public String getPluralForms(HLocale locale) {\n+    return getPluralForms(locale.getLocaleId());\n+  }\n+\n+  /**\n+   * Returns the appropriate plural form for a given Locale Id. Returns a\n+   * default value if there is no plural form information for the provided\n+   * locale id.\n+   *\n+   * @see {@link ResourceUtils#getPluralForms(org.zanata.common.LocaleId, boolean, boolean)}\n+   */\n+  public String getPluralForms(LocaleId localeId) {\n+    return getPluralForms(localeId, true, true);\n+  }\n+\n+  /**\n+   * Returns the appropriate plural from for a given locale Id.\n+   * <p>\n+   * From HLocale.plurals if available, else from pluralforms.properties\n+   *\n+   * @return A default value if useDefault is True. Otherwise, null.\n+   */\n+  public String getPluralForms(LocaleId localeId, boolean checkDB,\n+                               boolean useDefault) {\n+    if (checkDB) {\n+      String dbPluralForms = getPluralFormsFromDB(localeId);\n+      if (isNotEmpty(dbPluralForms)) {\n+        return dbPluralForms;\n+      }\n+    }\n+    final char[] alternateSeparators = {'.', '@'};\n+    String javaLocale = localeId.toJavaName().toLowerCase();\n+    // Replace all alternate separators for the \"_\" (Java) separator.\n+    for (char sep : alternateSeparators) {\n+      javaLocale = javaLocale.replace(sep, '_');\n+    }\n+    if (pluralForms.containsKey(javaLocale)) {\n+      return pluralForms.getProperty(javaLocale);\n+    }\n+    // Try out every combination. e.g: for xxx_yyy_zzz, try xxx_yyyy_zzz,\n+    // then\n+    // xxx_yyy, then xxx\n+    while (javaLocale.indexOf('_') > 0) {\n+      javaLocale = javaLocale.substring(0, javaLocale.lastIndexOf('_'));\n+      if (pluralForms.containsKey(javaLocale)) {\n+        return pluralForms.getProperty(javaLocale);\n+      }\n+    }\n+    if (useDefault) {\n+      return DEFAULT_PLURAL_FORM;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public int getNumPlurals(HDocument document, HLocale hLocale) {\n+    HPoTargetHeader headers = document.getPoTargetHeaders().get(hLocale);\n+    String headerEntries = headers != null ? headers.getEntries() : \"\";\n+    return getNumPlurals(headerEntries, hLocale.getLocaleId());\n+  }\n+\n+  /**\n+   * return plural count info from 1) PO Header entry if available, else 2)\n+   * HLocale.plurals if available, else 3) pluralforms.properties, else 4)\n+   * assume no plural forms (nplurals=1)\n+   *\n+   * @param poHeaders - HPoTargetHeader.entries\n+   * @param localeId  - locale identifier\n+   */\n+  int getNumPlurals(@Nullable String poHeaders, LocaleId localeId) {\n+    if (!isEmpty(poHeaders)) {\n+      Properties headerList = loadHeaders(poHeaders);\n+      String pluralFormsHeader = headerList.getProperty(PLURAL_FORMS_HDR);\n+      if (pluralFormsHeader != null) {\n+        if (!pluralFormsHeader.isEmpty()) {\n+          try {\n+            // try to parse plurals from the header\n+            return extractNPlurals(pluralFormsHeader);\n+          } catch (NumberFormatException | PluralParseException e) {\n+            log.debug(\"Unable to parse plurals\", e);\n+            // TODO return a warning to the user when uploading\n+            log.warn(\n+              \"Error parsing plural forms header; using defaults for locale {}; headers: {}\",\n+              localeId, poHeaders);\n+          }\n         } else {\n-            to.setContents(Collections.<String> emptyList());\n-        }\n-        // TODO rhbz953734 - at the moment we will map review state into old\n-        // state for compatibility\n-        to.setState(mapContentState(from.getState(), markTranslatedAsApproved));\n-        to.setRevision(from.getVersionNum());\n-        to.setTextFlowRevision(from.getTextFlowRevision());\n-        HPerson translator = from.getTranslator();\n-        if (translator != null) {\n-            to.setTranslator(\n-                    new Person(translator.getEmail(), translator.getName()));\n-        }\n+          // TODO return a warning to the user when uploading\n+          log.warn(\n+            \"Empty plural forms header; using defaults for locale {}; headers: {}\",\n+            localeId, poHeaders);\n+        }\n+      } else {\n+        // otherwise (no header) use the locale default\n+        log.debug(\n+          \"No plural forms header; using defaults for locale {}; headers: {}\",\n+          localeId, poHeaders);\n+      }\n+    }\n+    String localePluralForms = getPluralFormsForLocale(localeId);\n+    if (localePluralForms == null) {\n+      log.warn(\n+        \"Assuming no plurals for locale {}; no plural info found in database or in {}; headers: {}\",\n+        localeId, PLURALS_FILE, poHeaders);\n+      return DEFAULT_NPLURALS;\n+    }\n+    return extractNPlurals(localePluralForms);\n+  }\n+\n+  private Properties loadHeaders(String poHeaders) {\n+    try {\n+      Properties headerList = new Properties();\n+      headerList.load(new StringReader(poHeaders));\n+      return headerList;\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Returns HLocale.plurals if available, else value in\n+   * pluralforms.properties\n+   *\n+   * @param localeId id of the locale\n+   * @return the plural forms string\n+   * @throws RuntimeException if no plural forms are found\n+   */\n+  @Nullable\n+  private String getPluralFormsForLocale(LocaleId localeId) {\n+    String pluralForms;\n+    pluralForms = getPluralFormsFromDB(localeId);\n+    if (isEmpty(pluralForms)) {\n+      pluralForms = getPluralFormsFromFile(localeId);\n+    }\n+    return pluralForms;\n+  }\n+\n+  /**\n+   * @return plural forms from HLocale, null if not found\n+   */\n+  @Nullable\n+  String getPluralFormsFromDB(LocaleId localeId) {\n+    HLocale hLocale = localeDAO.findByLocaleId(localeId);\n+    if (hLocale != null && isNotEmpty(hLocale.getPluralForms())) {\n+      return hLocale.getPluralForms();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Get plural forms from pluralforms.properties\n+   *\n+   * @param localeId\n+   */\n+  @Nullable\n+  String getPluralFormsFromFile(@Nonnull LocaleId localeId) {\n+    return getPluralForms(localeId, false, false);\n+  }\n+\n+  /**\n+   * Process pluralforms string and return plural count.\n+   *\n+   * @param pluralForms string to parse\n+   */\n+  int extractNPlurals(@Nonnull String pluralForms)\n+    throws NumberFormatException, PluralParseException {\n+    Matcher nPluralsMatcher = NPLURALS_PATTERN.matcher(pluralForms);\n+    if (nPluralsMatcher.find()) {\n+      String nPluralsString = nPluralsMatcher.group();\n+      Matcher nPluralsValueMatcher =\n+        NPLURALS_TAG_PATTERN.matcher(nPluralsString);\n+      nPluralsString = nPluralsValueMatcher.replaceAll(\"\");\n+      if (isNotEmpty(nPluralsString)) {\n+        return Integer.parseInt(nPluralsString);\n+      }\n+    }\n+    throw new PluralParseException(\n+      \"can\\'t find valid nplurals in plural forms string: \"\n+        + pluralForms);\n+  }\n+\n+  /**\n+   * Return if pluralForms is valid (positive value)\n+   *\n+   * @param pluralForms string to check\n+   */\n+  public boolean isValidPluralForms(@Nonnull String pluralForms) {\n+    if (!PLURAL_FORM_PATTERN.matcher(pluralForms).find()) {\n+      return false;\n     }\n+    Matcher nPluralsMatcher = NPLURALS_PATTERN.matcher(pluralForms);\n+    String nPluralsString = \"\";\n+    while (nPluralsMatcher.find()) {\n+      nPluralsString = nPluralsMatcher.group();\n+      Matcher nPluralsValueMatcher =\n+        NPLURALS_TAG_PATTERN.matcher(nPluralsString);\n+      nPluralsString = nPluralsValueMatcher.replaceAll(\"\");\n+      break;\n+    }\n+    try {\n+      if (isNotEmpty(nPluralsString)) {\n+        int count = Integer.parseInt(nPluralsString);\n+        return count >= 1 && count <= MAX_TARGET_CONTENTS;\n+      }\n+    } catch (NumberFormatException e) {\n+      // invalid string for integer\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * @param fromHeader\n+   * @param toHeader\n+   * @see #pushPoTargetComment\n+   */\n+  protected void pullPoTargetComment(HPoTargetHeader fromHeader,\n+                                     PoTargetHeader toHeader, List<HTextFlowTarget> hTargets) {\n+    StringBuilder sb = new StringBuilder();\n+    HSimpleComment comment = fromHeader.getComment();\n+    if (comment != null) {\n+      sb.append(comment.getComment());\n+    }\n+    // generate #zanata credit comments\n+    // order by year, then alphabetically\n+    Set<TranslatorCredit> zanataCredits = new TreeSet<TranslatorCredit>();\n+    for (HTextFlowTarget tft : hTargets) {\n+      HPerson person = tft.getLastModifiedBy();\n+      if (person != null) {\n+        Calendar lastChanged = Calendar.getInstance();\n+        lastChanged.setTime(tft.getLastChanged());\n+        int year = lastChanged.get(Calendar.YEAR);\n+        TranslatorCredit credit = new TranslatorCredit();\n+        credit.setEmail(person.getEmail());\n+        credit.setName(person.getName());\n+        credit.setYear(year);\n+        zanataCredits.add(credit);\n+      }\n+    }\n+    for (TranslatorCredit credit : zanataCredits) {\n+      if (sb.length() != 0) {\n+        sb.append(NEWLINE);\n+      }\n+      sb.append(credit);\n+      sb.append(' ');\n+      sb.append(ZANATA_TAG);\n+    }\n+    toHeader.setComment(sb.toString());\n+  }\n+\n+  public void transferToTextFlow(HTextFlow from, TextFlow to) {\n+    if (from.isPlural()) {\n+      to.setContents(from.getContents());\n+    } else {\n+      to.setContents(from.getContents().get(0));\n+    }\n+    to.setRevision(from.getRevision());\n+    to.setPlural(from.isPlural());\n+    // TODO HTextFlow should have a lang\n+    // to.setLang(from.get)\n+  }\n+\n+  public void transferToAbstractResourceMeta(HDocument from,\n+                                             AbstractResourceMeta to) {\n+    to.setContentType(from.getContentType());\n+    to.setLang(from.getLocale().getLocaleId());\n+    to.setName(from.getDocId());\n+    // TODO ADD support within the hibernate model for multiple resource\n+    // types\n+    to.setType(ResourceType.FILE);\n+    to.setRevision(from.getRevision());\n+  }\n+\n+  public void transferToResourceExtensions(HDocument from,\n+                                           ExtensionSet<AbstractResourceMetaExtension> to,\n+                                           Set<String> enabledExtensions) {\n+    if (enabledExtensions.contains(PoHeader.ID)) {\n+      PoHeader poHeaderExt = new PoHeader();\n+      if (from.getPoHeader() != null) {\n+        transferToPoHeader(from.getPoHeader(), poHeaderExt);\n+        to.add(poHeaderExt);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @param from\n+   * @param to\n+   * @param enabledExtensions\n+   * @param locale\n+   * @return true only if extensions were found\n+   * @see #transferFromTranslationsResourceExtensions\n+   */\n+  public boolean transferToTranslationsResourceExtensions(HDocument from,\n+                                                          ExtensionSet<TranslationsResourceExtension> to,\n+                                                          Set<String> enabledExtensions, HLocale locale,\n+                                                          List<HTextFlowTarget> hTargets) {\n+    boolean found = false;\n+    if (enabledExtensions.contains(PoTargetHeader.ID)) {\n+      log.debug(\"PoTargetHeader requested\");\n+      PoTargetHeader poTargetHeader = new PoTargetHeader();\n+      HPoTargetHeader fromHeader = from.getPoTargetHeaders().get(locale);\n+      if (fromHeader != null) {\n+        found = true;\n+        log.debug(\"PoTargetHeader found\");\n+      } else {\n+        // If no header is found, use a default empty header for\n+        // generation\n+        // purposes\n+        fromHeader = new HPoTargetHeader();\n+        fromHeader.setEntries(\"\");\n+      }\n+      transferToPoTargetHeader(fromHeader, poTargetHeader, hTargets,\n+        locale);\n+      to.add(poTargetHeader);\n+    }\n+    return found;\n+  }\n+\n+  public void transferToTextFlowExtensions(HTextFlow from,\n+                                           ExtensionSet<TextFlowExtension> to, Set<String> enabledExtensions) {\n+    if (enabledExtensions.contains(PotEntryHeader.ID)\n+      && from.getPotEntryData() != null) {\n+      PotEntryHeader header = new PotEntryHeader();\n+      transferToPotEntryHeader(from.getPotEntryData(), header);\n+      log.debug(\"set header:{}\", from.getPotEntryData());\n+      to.add(header);\n+    }\n+    if (enabledExtensions.contains(SimpleComment.ID)\n+      && from.getComment() != null) {\n+      SimpleComment comment =\n+        new SimpleComment(from.getComment().getComment());\n+      log.debug(\"set comment:{}\", from.getComment().getComment());\n+      to.add(comment);\n+    }\n+  }\n+\n+  /**\n+   * @param from\n+   * @param to\n+   * @see #transferFromPotEntryHeader(org.zanata.rest.dto.extensions.gettext.PotEntryHeader,\n+   * org.zanata.model.po.HPotEntryData,\n+   * org.zanata.rest.dto.resource.TextFlow)\n+   */\n+  private void transferToPotEntryHeader(HPotEntryData from,\n+                                        PotEntryHeader to) {\n+    to.setContext(from.getContext());\n+    List<String> flags = new ArrayList<String>(0);\n+    if (from.getFlags() != null) {\n+      flags = StringUtil.split(from.getFlags(), \",\");\n+    }\n+    to.getFlags().addAll(flags);\n+    List<String> refs = new ArrayList<String>(0);\n+    if (from.getReferences() != null) {\n+      refs = StringUtil.split(from.getReferences(), \",\");\n+    }\n+    to.getReferences().addAll(refs);\n+  }\n+\n+  /**\n+   * @param from\n+   * @param to\n+   * @param enabledExtensions\n+   * @todo merge with {@link #transferToTextFlowTarget}\n+   */\n+  public void transferToTextFlowTargetExtensions(HTextFlowTarget from,\n+                                                 ExtensionSet<TextFlowTargetExtension> to,\n+                                                 Set<String> enabledExtensions) {\n+    if (enabledExtensions.contains(SimpleComment.ID)\n+      && from.getComment() != null) {\n+      SimpleComment comment =\n+        new SimpleComment(from.getComment().getComment());\n+      to.add(comment);\n+    }\n+  }\n+\n+  public String encodeDocId(String id) {\n+    String other = StringUtils.replace(id, \"/\", \",\");\n+    try {\n+      other = URLEncoder.encode(other, \"UTF-8\");\n+      return StringUtils.replace(other, \"%2C\", \",\");\n+    } catch (UnsupportedEncodingException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  public String decodeDocId(String id) {\n+    try {\n+      String other = URLDecoder.decode(id, \"UTF-8\");\n+      return StringUtils.replace(other, \",\", \"/\");\n+    } catch (UnsupportedEncodingException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * @todo merge with {@link #transferToTextFlowTargetExtensions}\n+   */\n+  @SuppressWarnings(\"deprecation\")\n+  public void transferToTextFlowTarget(HTextFlowTarget from,\n+                                       TextFlowTarget to, boolean markTranslatedAsApproved) {\n+    if (from.getTextFlow().isPlural()) {\n+      to.setContents(from.getContents());\n+    } else if (!from.getContents().isEmpty()) {\n+      to.setContents(from.getContents().get(0));\n+    } else {\n+      to.setContents(Collections.<String>emptyList());\n+    }\n+    // TODO rhbz953734 - at the moment we will map review state into old\n+    // state for compatibility\n+    to.setState(mapContentState(from.getState(), markTranslatedAsApproved));\n+    to.setRevision(from.getVersionNum());\n+    to.setTextFlowRevision(from.getTextFlowRevision());\n+    HPerson translator = from.getTranslator();\n+    if (translator != null) {\n+      to.setTranslator(\n+        new Person(translator.getEmail(), translator.getName()));\n+    }\n+  }\n \n-    private static ContentState mapContentState(ContentState realState,\n-            boolean markTranslatedAsApproved) {\n-        if (markTranslatedAsApproved) {\n-            switch (realState) {\n-            case Translated:\n-                return ContentState.Approved;\n+  private static ContentState mapContentState(ContentState realState,\n+                                              boolean markTranslatedAsApproved) {\n+    if (markTranslatedAsApproved) {\n+      switch (realState) {\n+      case Translated:\n+        return ContentState.Approved;\n \n-            case Rejected:\n-                return ContentState.NeedReview;\n+      case Rejected:\n+        return ContentState.NeedReview;\n \n-            default:\n-                return realState;\n-            }\n-        }\n+      default:\n         return realState;\n+      }\n     }\n-\n-    public Resource buildResource(HDocument document) {\n-        Set<String> extensions = new HashSet<String>();\n-        extensions.add(\"gettext\");\n-        extensions.add(\"comment\");\n-        Resource entity = new Resource(document.getDocId());\n-        this.transferToResource(document, entity);\n-        // handle extensions\n-        this.transferToResourceExtensions(document, entity.getExtensions(true),\n-                extensions);\n-        for (HTextFlow htf : document.getTextFlows()) {\n-            TextFlow tf = new TextFlow(htf.getResId(),\n-                    document.getLocale().getLocaleId());\n-            this.transferToTextFlowExtensions(htf, tf.getExtensions(true),\n-                    extensions);\n-            this.transferToTextFlow(htf, tf);\n-            entity.getTextFlows().add(tf);\n-        }\n-        return entity;\n-    }\n-\n-    /**\n-     * @param transRes\n-     * @param document\n-     * @param locale\n-     * @param enabledExtensions\n-     * @param hTargets\n-     * @param apiVersion\n-     *            TODO this will take api version in the future\n-     * @return true only if some data was found (text flow targets, or some\n-     *         metadata extensions)\n-     */\n-    public boolean transferToTranslationsResource(TranslationsResource transRes,\n-            HDocument document, HLocale locale, Set<String> enabledExtensions,\n-            List<HTextFlowTarget> hTargets, boolean markTranslatedAsApproved) {\n-        boolean found = this.transferToTranslationsResourceExtensions(document,\n-                transRes.getExtensions(true), enabledExtensions, locale,\n-                hTargets);\n-        for (HTextFlowTarget hTarget : hTargets) {\n-            found = true;\n-            TextFlowTarget target = new TextFlowTarget();\n-            target.setResId(hTarget.getTextFlow().getResId());\n-            this.transferToTextFlowTarget(hTarget, target, markTranslatedAsApproved);\n-            this.transferToTextFlowTargetExtensions(hTarget,\n-                    target.getExtensions(true), enabledExtensions);\n-            transRes.getTextFlowTargets().add(target);\n-        }\n-        return found;\n-    }\n-\n-    /**\n-     * Ensures that any extensions sent with the current query are valid for\n-     * this context.\n-     *\n-     * @param requestedExt\n-     *            Extensions to be validated\n-     */\n-    public static void validateExtensions(Set<String> requestedExt) {\n-        Set<String> validExtensions = ExtensionType.asStringSet();\n-        if (!CollectionUtils.isSubCollection(requestedExt, validExtensions)) {\n-            @SuppressWarnings(\"unchecked\")\n-            Collection<String> invalidExtensions =\n-                    CollectionUtils.subtract(requestedExt, validExtensions);\n-            Response response =\n-                    Response.status(Status.BAD_REQUEST)\n-                            .entity(\"Unsupported Extensions within this context: \"\n-                                    + StringUtils.join(invalidExtensions, \",\"))\n-                            .build();\n-            throw new WebApplicationException(response);\n-        }\n+    return realState;\n+  }\n+\n+  public Resource buildResource(HDocument document) {\n+    Set<String> extensions = new HashSet<String>();\n+    extensions.add(\"gettext\");\n+    extensions.add(\"comment\");\n+    Resource entity = new Resource(document.getDocId());\n+    this.transferToResource(document, entity);\n+    // handle extensions\n+    this.transferToResourceExtensions(document, entity.getExtensions(true),\n+      extensions);\n+    for (HTextFlow htf : document.getTextFlows()) {\n+      TextFlow tf = new TextFlow(htf.getResId(),\n+        document.getLocale().getLocaleId());\n+      this.transferToTextFlowExtensions(htf, tf.getExtensions(true),\n+        extensions);\n+      this.transferToTextFlow(htf, tf);\n+      entity.getTextFlows().add(tf);\n     }\n+    return entity;\n+  }\n+\n+  /**\n+   * @param transRes\n+   * @param document\n+   * @param locale\n+   * @param enabledExtensions\n+   * @param hTargets\n+   * @param apiVersion        TODO this will take api version in the future\n+   * @return true only if some data was found (text flow targets, or some\n+   * metadata extensions)\n+   */\n+  public boolean transferToTranslationsResource(TranslationsResource transRes,\n+                                                HDocument document, HLocale locale, Set<String> enabledExtensions,\n+                                                List<HTextFlowTarget> hTargets, boolean markTranslatedAsApproved) {\n+    boolean found = this.transferToTranslationsResourceExtensions(document,\n+      transRes.getExtensions(true), enabledExtensions, locale,\n+      hTargets);\n+    for (HTextFlowTarget hTarget : hTargets) {\n+      found = true;\n+      TextFlowTarget target = new TextFlowTarget();\n+      target.setResId(hTarget.getTextFlow().getResId());\n+      this.transferToTextFlowTarget(hTarget, target, markTranslatedAsApproved);\n+      this.transferToTextFlowTargetExtensions(hTarget,\n+        target.getExtensions(true), enabledExtensions);\n+      transRes.getTextFlowTargets().add(target);\n+    }\n+    return found;\n+  }\n+\n+  /**\n+   * Ensures that any extensions sent with the current query are valid for\n+   * this context.\n+   *\n+   * @param requestedExt Extensions to be validated\n+   */\n+  public static void validateExtensions(Set<String> requestedExt) {\n+    Set<String> validExtensions = ExtensionType.asStringSet();\n+    if (!CollectionUtils.isSubCollection(requestedExt, validExtensions)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Collection<String> invalidExtensions =\n+        CollectionUtils.subtract(requestedExt, validExtensions);\n+      Response response =\n+        Response.status(Status.BAD_REQUEST)\n+          .entity(\"Unsupported Extensions within this context: \"\n+            + StringUtils.join(invalidExtensions, \",\"))\n+          .build();\n+      throw new WebApplicationException(response);\n+    }\n+  }\n \n-    public static class PluralParseException extends RuntimeException {\n-        private static final long serialVersionUID = 1L;\n+  public static class PluralParseException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n \n-        public PluralParseException(String string) {\n-            super(string);\n-        }\n+    public PluralParseException(String string) {\n+      super(string);\n     }\n+  }\n }\n",
            "diff_size": 2137
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "360",
                    "column": "93",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/11/ResourceUtils.java\nindex b5d24bde0cc..e7a2c69ffaf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/11/ResourceUtils.java\n@@ -31,7 +31,6 @@ import javax.persistence.EntityManager;\n import javax.ws.rs.WebApplicationException;\n import javax.ws.rs.core.Response;\n import javax.ws.rs.core.Response.Status;\n-\n import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n import org.apache.commons.collections.CollectionUtils;\n import org.apache.commons.lang3.StringUtils;\n@@ -78,11 +77,11 @@ import static org.apache.commons.lang3.StringUtils.isEmpty;\n import static org.apache.commons.lang3.StringUtils.isNotEmpty;\n // TODO move plural logic out of ResourceUtils into a dedicated class\n \n+\n @Named(\"resourceUtils\")\n @RequestScoped\n public class ResourceUtils implements Serializable {\n-    private static final org.slf4j.Logger log =\n-            org.slf4j.LoggerFactory.getLogger(ResourceUtils.class);\n+    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(ResourceUtils.class);\n     private static final long serialVersionUID = -969189290416018542L;\n \n     /**\n@@ -92,49 +91,40 @@ public class ResourceUtils implements Serializable {\n     private static final String ZANATA_GENERATOR_PREFIX = \"Zanata\";\n     private static final String ZANATA_TAG = \"#zanata\";\n     private static final String PO_DATE_FORMAT = \"yyyy-MM-dd hh:mmZ\";\n-    private static final String PO_DEFAULT_CONTENT_TYPE =\n-            \"text/plain; charset=UTF-8\";\n+    private static final String PO_DEFAULT_CONTENT_TYPE = \"text/plain; charset=UTF-8\";\n \n     /**\n      * PO Header entries\n      */\n     private static final String LAST_TRANSLATOR_HDR = \"Last-Translator\";\n-    private static final String PO_REVISION_DATE_HDR =\n-            HeaderFields.KEY_PoRevisionDate;\n-    private static final String LANGUAGE_TEAM_HDR =\n-            HeaderFields.KEY_LanguageTeam;\n+    private static final String PO_REVISION_DATE_HDR = HeaderFields.KEY_PoRevisionDate;\n+    private static final String LANGUAGE_TEAM_HDR = HeaderFields.KEY_LanguageTeam;\n     private static final String X_GENERATOR_HDR = \"X-Generator\";\n     private static final String LANGUAGE_HDR = HeaderFields.KEY_Language;\n     private static final String CONTENT_TYPE_HDR = HeaderFields.KEY_ContentType;\n     private static final String PLURAL_FORMS_HDR = \"Plural-Forms\";\n     // TODO we should need only one regex, with a capture group for nplurals\n-    private static final Pattern PLURAL_FORM_PATTERN =\n-            Pattern.compile(\"nplurals=[0-9]+;\\\\s?plural=*\");\n-    private static final Pattern NPLURALS_TAG_PATTERN =\n-            Pattern.compile(\"nplurals=\");\n-    private static final Pattern NPLURALS_PATTERN =\n-            Pattern.compile(\"nplurals=[0-9]+\");\n+    private static final Pattern PLURAL_FORM_PATTERN = Pattern.compile(\"nplurals=[0-9]+;\\\\s?plural=*\");\n+    private static final Pattern NPLURALS_TAG_PATTERN = Pattern.compile(\"nplurals=\");\n+    private static final Pattern NPLURALS_PATTERN = Pattern.compile(\"nplurals=[0-9]+\");\n     private static final String PLURALS_FILE = \"pluralforms.properties\";\n     private static final int DEFAULT_NPLURALS = 1;\n     private static final String DEFAULT_PLURAL_FORM = \"nplurals=1; plural=0\";\n     public static final int MAX_TARGET_CONTENTS = 6;\n     private Properties pluralForms;\n     public static final String COPIED_BY_ZANATA_NAME = \"Copied by Zanata\";\n-    public static final String COPIED_BY_ZANATA_NAME_EMAIL =\n-            \"copied-by-zanata@zanata.org\";\n+    public static final String COPIED_BY_ZANATA_NAME_EMAIL = \"copied-by-zanata@zanata.org\";\n     @SuppressFBWarnings(\"SE_BAD_FIELD\")\n     @Inject\n     private EntityManager entityManager;\n     @Inject\n     private LocaleDAO localeDAO;\n-\n     @PostConstruct\n     public void create() {\n         try {\n             if (pluralForms == null) {\n                 pluralForms = new Properties();\n-                pluralForms.load(this.getClass().getClassLoader()\n-                        .getResourceAsStream(PLURALS_FILE));\n+                pluralForms.load(this.getClass().getClassLoader().getResourceAsStream(PLURALS_FILE));\n             }\n         } catch (IOException e) {\n             log.error(\"There was an error loading plural forms.\", e);\n@@ -153,21 +143,19 @@ public class ResourceUtils implements Serializable {\n      * @param to\n      * @return\n      */\n-    boolean transferFromTextFlows(List<TextFlow> from, HDocument to,\n+\n+    boolean transferFromTextFlows(List<TextFlow> from,\n+        HDocument to,\n             Set<String> enabledExtensions, int nextDocRev) {\n         boolean changed = false;\n         to.getTextFlows().clear();\n         Set<String> incomingIds = new HashSet<String>();\n-        Set<String> previousIds =\n-                new HashSet<String>(to.getAllTextFlows().keySet());\n+        Set<String> previousIds = new HashSet<String>(to.getAllTextFlows().keySet());\n         int count = 0;\n         for (TextFlow tf : from) {\n             if (!incomingIds.add(tf.getId())) {\n-                Response response = Response.status(Status.BAD_REQUEST).entity(\n-                        \"encountered TextFlow with duplicate ID \" + tf.getId())\n-                        .build();\n-                log.warn(\n-                        \"encountered TextFlow with duplicate ID {}\", tf.getId());\n+                Response response = Response.status(Status.BAD_REQUEST).entity(\"encountered TextFlow with duplicate ID \" + tf.getId()).build();\n+                log.warn(\"encountered TextFlow with duplicate ID {}\", tf.getId());\n                 throw new WebApplicationException(response);\n             }\n             HTextFlow textFlow;\n@@ -183,8 +171,7 @@ public class ResourceUtils implements Serializable {\n                     // changed\n                     textFlow.setRevision(nextDocRev);\n                     changed = true;\n-                    for (HTextFlowTarget targ : textFlow.getTargets()\n-                            .values()) {\n+                    for (HTextFlowTarget targ : textFlow.getTargets().values()) {\n                         // if (targ.getState() != ContentState.New)\n                         if (targ.getState().isTranslated()) {\n                             targ.setState(ContentState.NeedReview);\n@@ -246,13 +233,14 @@ public class ResourceUtils implements Serializable {\n      * @param enabledExtensions\n      * @return\n      */\n-    public boolean transferFromResource(Resource from, HDocument to,\n-            Set<String> enabledExtensions, HLocale locale, int nextDocRev) {\n+\n+    public boolean transferFromResource(Resource from,\n+           HDocument to,\n+           Set<String> enabledExtensions,\n+           HLocale locale, int nextDocRev) {\n         boolean changed = false;\n-        changed |= transferFromResourceMetadata(from, to, enabledExtensions,\n-                locale, nextDocRev);\n-        changed |= transferFromTextFlows(from.getTextFlows(), to,\n-                enabledExtensions, nextDocRev);\n+        changed |= transferFromResourceMetadata(from, to, enabledExtensions, locale, nextDocRev);\n+        changed |= transferFromTextFlows(from.getTextFlows(), to, enabledExtensions, nextDocRev);\n         return changed;\n     }\n \n@@ -265,9 +253,11 @@ public class ResourceUtils implements Serializable {\n      * @param enabledExtensions\n      * @return\n      */\n+\n     public boolean transferFromResourceMetadata(AbstractResourceMeta from,\n-            HDocument to, Set<String> enabledExtensions, HLocale locale,\n-            int nextDocRev) {\n+           HDocument to,\n+           Set<String> enabledExtensions,\n+           HLocale locale, int nextDocRev) {\n         boolean changed = false;\n         // name\n         if (!equals(from.getName(), to.getDocId())) {\n@@ -286,8 +276,7 @@ public class ResourceUtils implements Serializable {\n             changed = true;\n         }\n         // handle extensions\n-        changed |= transferFromResourceExtensions(from.getExtensions(true), to,\n-                enabledExtensions);\n+        changed |= transferFromResourceExtensions(from.getExtensions(true), to, enabledExtensions);\n         if (changed)\n             to.setRevision(nextDocRev);\n         return changed;\n@@ -303,9 +292,9 @@ public class ResourceUtils implements Serializable {\n      * @return\n      * @see #transferFromResource\n      */\n-    private boolean transferFromResourceExtensions(\n-            ExtensionSet<AbstractResourceMetaExtension> from, HDocument to,\n-            Set<String> enabledExtensions) {\n+\n+    private boolean transferFromResourceExtensions(ExtensionSet<AbstractResourceMetaExtension> from,\n+            HDocument to, Set<String> enabledExtensions) {\n         boolean changed = false;\n         if (enabledExtensions.contains(PoHeader.ID)) {\n             PoHeader poHeaderExt = from.findByType(PoHeader.class);\n@@ -336,23 +325,21 @@ public class ResourceUtils implements Serializable {\n      * @return\n      * @see #transferToTranslationsResourceExtensions\n      */\n-    public boolean transferFromTranslationsResourceExtensions(\n-            ExtensionSet<TranslationsResourceExtension> from, HDocument doc,\n-            Set<String> enabledExtensions, HLocale locale,\n-            MergeType mergeType) {\n+\n+    public boolean transferFromTranslationsResourceExtensions(ExtensionSet<TranslationsResourceExtension> from,\n+           HDocument doc,\n+           Set<String> enabledExtensions,\n+           HLocale locale, MergeType mergeType) {\n         boolean changed = false;\n         if (enabledExtensions.contains(PoTargetHeader.ID)) {\n-            PoTargetHeader fromTargetHeader =\n-                    from.findByType(PoTargetHeader.class);\n+            PoTargetHeader fromTargetHeader = from.findByType(PoTargetHeader.class);\n             if (fromTargetHeader != null) {\n                 log.debug(\"found PO header for locale: {}\", locale);\n                 try {\n-                    changed = tryGetOrCreateTargetHeader(doc, locale, mergeType,\n-                            changed, fromTargetHeader);\n+                    changed = tryGetOrCreateTargetHeader(doc, locale, mergeType, changed, fromTargetHeader);\n                 } catch (org.hibernate.exception.ConstraintViolationException e) {\n                     entityManager.refresh(doc);\n-                    changed = tryGetOrCreateTargetHeader(doc, locale, mergeType,\n-                            changed, fromTargetHeader);\n+                    changed = tryGetOrCreateTargetHeader(doc, locale, mergeType, changed, fromTargetHeader);\n                 }\n             } else {\n                 changed |= doc.getPoTargetHeaders().remove(locale) != null;\n@@ -361,36 +348,32 @@ public class ResourceUtils implements Serializable {\n         return changed;\n     }\n \n-    private boolean tryGetOrCreateTargetHeader(HDocument doc, HLocale locale,\n-            MergeType mergeType, boolean changed,\n-            PoTargetHeader fromTargetHeader) {\n+    private boolean tryGetOrCreateTargetHeader(HDocument doc,\n+            HLocale locale,\n+            MergeType mergeType, boolean changed, PoTargetHeader fromTargetHeader) {\n         HPoTargetHeader toTargetHeader = doc.getPoTargetHeaders().get(locale);\n         if (toTargetHeader == null) {\n             changed = true;\n             toTargetHeader = new HPoTargetHeader();\n             toTargetHeader.setTargetLanguage(locale);\n             toTargetHeader.setDocument(doc);\n-            transferFromPoTargetHeader(fromTargetHeader, toTargetHeader,\n-                    MergeType.IMPORT); // return\n+            transferFromPoTargetHeader(fromTargetHeader, toTargetHeader, MergeType.IMPORT); // return\n             // value\n             // not\n             // needed\n             entityManager.persist(toTargetHeader);\n             entityManager.flush();\n         } else {\n-            changed |= transferFromPoTargetHeader(fromTargetHeader,\n-                    toTargetHeader, mergeType);\n+            changed |= transferFromPoTargetHeader(fromTargetHeader, toTargetHeader, mergeType);\n         }\n         return changed;\n     }\n \n-    private boolean transferFromTextFlowExtensions(TextFlow from, HTextFlow to,\n-            Set<String> enabledExtensions) {\n+    private boolean transferFromTextFlowExtensions(TextFlow from, HTextFlow to, Set<String> enabledExtensions) {\n         boolean changed = false;\n         ExtensionSet<TextFlowExtension> extensions = from.getExtensions(true);\n         if (enabledExtensions.contains(PotEntryHeader.ID)) {\n-            PotEntryHeader entryHeader =\n-                    extensions.findByType(PotEntryHeader.class);\n+            PotEntryHeader entryHeader = extensions.findByType(PotEntryHeader.class);\n             if (entryHeader != null) {\n                 HPotEntryData hEntryHeader = to.getPotEntryData();\n                 if (hEntryHeader == null) {\n@@ -399,8 +382,7 @@ public class ResourceUtils implements Serializable {\n                     to.setPotEntryData(hEntryHeader);\n                     log.debug(\"set potentryheader\");\n                 }\n-                changed |= transferFromPotEntryHeader(entryHeader, hEntryHeader,\n-                        from);\n+                changed |= transferFromPotEntryHeader(entryHeader, hEntryHeader, from);\n             }\n         }\n         if (enabledExtensions.contains(SimpleComment.ID)) {\n@@ -428,8 +410,8 @@ public class ResourceUtils implements Serializable {\n      * @param textFlow\n      * @return\n      */\n-    private boolean transferFromPotEntryHeader(PotEntryHeader from,\n-            HPotEntryData to, TextFlow textFlow) {\n+\n+    private boolean transferFromPotEntryHeader(PotEntryHeader from, HPotEntryData to, TextFlow textFlow) {\n         boolean changed = false;\n         if (!equals(from.getContext(), to.getContext())) {\n             changed = true;\n@@ -438,9 +420,7 @@ public class ResourceUtils implements Serializable {\n         List<String> flagList = from.getFlags();\n         // rhbz1012502 - should not store fuzzy tag in source document\n         if (flagList.contains(\"fuzzy\")) {\n-            throw new WebApplicationException(String.format(\n-                    \"Please remove fuzzy flags from document. First fuzzy flag was found on text flow %s with content %s\",\n-                    textFlow.getId(), textFlow.getContents()), 422);\n+            throw new WebApplicationException(String.format(\"Please remove fuzzy flags from document. First fuzzy flag was found on text flow %s with content %s\", textFlow.getId(), textFlow.getContents()), 422);\n         }\n         String flags = StringUtil.concat(flagList, ',');\n         if (flagList.isEmpty()) {\n@@ -470,8 +450,8 @@ public class ResourceUtils implements Serializable {\n      * @see #transferFromTranslationsResourceExtensions\n      * @see #transferToPoTargetHeader\n      */\n-    private boolean transferFromPoTargetHeader(PoTargetHeader from,\n-            HPoTargetHeader to, MergeType mergeType) {\n+\n+    private boolean transferFromPoTargetHeader(PoTargetHeader from, HPoTargetHeader to, MergeType mergeType) {\n         boolean changed = pushPoTargetComment(from, to, mergeType);\n         // TODO we should probably block PoHeader/POT-specific entries\n         // ie POT-Creation-Date, Project-Id-Version, Report-Msgid-Bugs-To\n@@ -490,8 +470,8 @@ public class ResourceUtils implements Serializable {\n      * @return\n      * @see #pullPoTargetComment\n      */\n-    protected boolean pushPoTargetComment(PoTargetHeader fromHeader,\n-            HPoTargetHeader toHeader, MergeType mergeType) {\n+\n+    protected boolean pushPoTargetComment(PoTargetHeader fromHeader, HPoTargetHeader toHeader, MergeType mergeType) {\n         boolean changed = false;\n         HSimpleComment hComment = toHeader.getComment();\n         if (hComment == null) {\n@@ -504,33 +484,31 @@ public class ResourceUtils implements Serializable {\n             List<String> fromLines = splitLines(fromComment, ZANATA_TAG);\n             StringBuilder sb = new StringBuilder(fromComment.length());\n             switch (mergeType) {\n-            case IMPORT:\n-                for (String line : fromLines) {\n-                    if (sb.length() != 0)\n-                        sb.append(NEWLINE);\n-                    sb.append(line);\n-                    changed = true;\n-                }\n-                break;\n-\n-            default:\n-                // AUTO or anything else will merge comments\n-                // to merge, we just append new lines, skip old lines\n-                List<String> toLines = Collections.emptyList();\n-                if (toComment != null) {\n-                    sb.append(toComment);\n-                    toLines = splitLines(toComment, null);\n-                }\n-                for (String line : fromLines) {\n-                    if (!toLines.contains(line)) {\n+                case IMPORT:\n+                    for (String line : fromLines) {\n                         if (sb.length() != 0)\n                             sb.append(NEWLINE);\n                         sb.append(line);\n                         changed = true;\n                     }\n-                }\n-                break;\n-\n+                    break;\n+                default:\n+                // AUTO or anything else will merge comments\n+                // to merge, we just append new lines, skip old lines\n+                    List<String> toLines = Collections.emptyList();\n+                    if (toComment != null) {\n+                        sb.append(toComment);\n+                        toLines = splitLines(toComment, null);\n+                    }\n+                    for (String line : fromLines) {\n+                        if (!toLines.contains(line)) {\n+                            if (sb.length() != 0)\n+                                sb.append(NEWLINE);\n+                            sb.append(line);\n+                            changed = true;\n+                        }\n+                    }\n+                    break;\n             }\n             if (changed) {\n                 hComment.setComment(sb.toString());\n@@ -547,6 +525,7 @@ public class ResourceUtils implements Serializable {\n      * @param tagToSkip\n      * @return\n      */\n+\n     static List<String> splitLines(String s, String tagToSkip) {\n         if (s.isEmpty()) {\n             return Collections.emptyList();\n@@ -595,8 +574,7 @@ public class ResourceUtils implements Serializable {\n         return a.equals(b);\n     }\n \n-    private boolean transferFromTextFlow(TextFlow from, HTextFlow to,\n-            Set<String> enabledExtensions) {\n+    private boolean transferFromTextFlow(TextFlow from, HTextFlow to, Set<String> enabledExtensions) {\n         boolean changed = false;\n         if (!equals(from.getContents(), to.getContents())) {\n             to.setContents(from.getContents());\n@@ -630,8 +608,10 @@ public class ResourceUtils implements Serializable {\n      * @see #transferToTranslationsResourceExtensions\n      * @see #transferFromPoTargetHeader\n      */\n+\n     private void transferToPoTargetHeader(HPoTargetHeader from,\n-            PoTargetHeader to, List<HTextFlowTarget> hTargets, HLocale locale) {\n+            PoTargetHeader to,\n+            List<HTextFlowTarget> hTargets, HLocale locale) {\n         pullPoTargetComment(from, to, hTargets);\n         to.getEntries().addAll(this.headerToList(from.getEntries()));\n         populateHeaderEntries(to.getEntries(), hTargets, locale);\n@@ -643,6 +623,7 @@ public class ResourceUtils implements Serializable {\n      * @param entries\n      *            The header entries' string.\n      */\n+\n     private List<HeaderEntry> headerToList(final String entries) {\n         return PoUtility.headerToList(entries);\n     }\n@@ -658,22 +639,22 @@ public class ResourceUtils implements Serializable {\n      * @param locale\n      *            The locale that is bein\n      */\n+\n     private void populateHeaderEntries(final List<HeaderEntry> headerEntries,\n-            final List<HTextFlowTarget> hTargets, final HLocale locale) {\n-        final Map<String, HeaderEntry> containedHeaders =\n-                new LinkedHashMap<String, HeaderEntry>(headerEntries.size());\n+final List<HTextFlowTarget> hTargets,\n+   final HLocale locale) {\n+        final Map<String, HeaderEntry> containedHeaders = new LinkedHashMap<String, HeaderEntry>(headerEntries.size());\n         HTextFlowTarget lastChangedTarget = getLastChangedTarget(hTargets);\n         // Collect the existing header entries\n         for (HeaderEntry entry : headerEntries) {\n             containedHeaders.put(entry.getKey(), entry);\n         }\n         // Add / Replace headers\n-        Date revisionDate =\n-                this.getRevisionDate(headerEntries, lastChangedTarget);\n+        Date revisionDate = this.getRevisionDate(headerEntries, lastChangedTarget);\n         HeaderEntry headerEntry = containedHeaders.get(PO_REVISION_DATE_HDR);\n         if (headerEntry == null) {\n             headerEntry = new HeaderEntry(PO_REVISION_DATE_HDR,\n-                    this.toPoHeaderString(revisionDate));\n+                this.toPoHeaderString(revisionDate));\n             headerEntries.add(headerEntry);\n         } else {\n             headerEntry.setValue(this.toPoHeaderString(revisionDate));\n@@ -681,51 +662,47 @@ public class ResourceUtils implements Serializable {\n         headerEntry = containedHeaders.get(LAST_TRANSLATOR_HDR);\n         if (headerEntry == null) {\n             headerEntry = new HeaderEntry(LAST_TRANSLATOR_HDR,\n-                    this.getLastTranslator(lastChangedTarget, headerEntries));\n+                this.getLastTranslator(lastChangedTarget, headerEntries));\n             headerEntries.add(headerEntry);\n         } else {\n-            headerEntry.setValue(\n-                    this.getLastTranslator(lastChangedTarget, headerEntries));\n+            headerEntry.setValue(this.getLastTranslator(lastChangedTarget, headerEntries));\n         }\n         headerEntry = containedHeaders.get(LANGUAGE_TEAM_HDR);\n         if (headerEntry == null) {\n-            headerEntry = new HeaderEntry(LANGUAGE_TEAM_HDR,\n-                    this.getLanguageTeam(locale));\n+            headerEntry = new HeaderEntry(LANGUAGE_TEAM_HDR, this.getLanguageTeam(locale));\n             headerEntries.add(headerEntry);\n         } else {\n             // Keep the original value if provided\n+\n         }\n         headerEntry = containedHeaders.get(LANGUAGE_HDR);\n         if (headerEntry == null) {\n-            headerEntry =\n-                    new HeaderEntry(LANGUAGE_HDR, this.getLanguage(locale));\n+            headerEntry = new HeaderEntry(LANGUAGE_HDR, this.getLanguage(locale));\n             headerEntries.add(headerEntry);\n         } else {\n             headerEntry.setValue(this.getLanguage(locale));\n         }\n         headerEntry = containedHeaders.get(X_GENERATOR_HDR);\n         if (headerEntry == null) {\n-            headerEntry =\n-                    new HeaderEntry(X_GENERATOR_HDR, this.getSystemVersion());\n+            headerEntry = new HeaderEntry(X_GENERATOR_HDR, this.getSystemVersion());\n             headerEntries.add(headerEntry);\n         } else {\n             headerEntry.setValue(this.getSystemVersion());\n         }\n         headerEntry = containedHeaders.get(CONTENT_TYPE_HDR);\n         if (headerEntry == null) {\n-            headerEntry =\n-                    new HeaderEntry(CONTENT_TYPE_HDR, PO_DEFAULT_CONTENT_TYPE);\n+            headerEntry = new HeaderEntry(CONTENT_TYPE_HDR, PO_DEFAULT_CONTENT_TYPE);\n             headerEntries.add(headerEntry);\n         } else {\n             headerEntry.setValue(PO_DEFAULT_CONTENT_TYPE);\n         }\n         headerEntry = containedHeaders.get(PLURAL_FORMS_HDR);\n         if (headerEntry == null || isBlank(headerEntry.getValue())) {\n-            headerEntry = new HeaderEntry(PLURAL_FORMS_HDR,\n-                    this.getPluralForms(locale));\n+            headerEntry = new HeaderEntry(PLURAL_FORMS_HDR, this.getPluralForms(locale));\n             headerEntries.add(headerEntry);\n         } else {\n             // Keep the original if provided\n+\n         }\n     }\n \n@@ -737,16 +714,17 @@ public class ResourceUtils implements Serializable {\n      * @return The Revision Date header value, or null if no such header is\n      *         found or the date cannot be parsed.\n      */\n+\n     private Date getHeaderRevisionDate(final List<HeaderEntry> headerEntries) {\n         Date poFileRevisionDate = null;\n         for (HeaderEntry entry : headerEntries) {\n             if (entry.getKey().equalsIgnoreCase(PO_REVISION_DATE_HDR)) {\n-                SimpleDateFormat dateFormat =\n-                        new SimpleDateFormat(PO_DATE_FORMAT);\n+                SimpleDateFormat dateFormat = new SimpleDateFormat(PO_DATE_FORMAT);\n                 try {\n                     poFileRevisionDate = dateFormat.parse(entry.getValue());\n                 } catch (ParseException e) {\n                     // found the header but date could not be parsed\n+\n                 }\n                 break;\n             }\n@@ -754,8 +732,7 @@ public class ResourceUtils implements Serializable {\n         return poFileRevisionDate;\n     }\n \n-    private String\n-            getHeaderLastTranslator(final List<HeaderEntry> headerEntries) {\n+    private String getHeaderLastTranslator(final List<HeaderEntry> headerEntries) {\n         for (HeaderEntry entry : headerEntries) {\n             if (entry.getKey().equalsIgnoreCase(LAST_TRANSLATOR_HDR)) {\n                 return entry.getValue();\n@@ -769,8 +746,9 @@ public class ResourceUtils implements Serializable {\n      * file's header and in the last translated target. If the system cannot\n      * determine a suitable Revision date, a null value is returned.\n      */\n+\n     private Date getRevisionDate(final List<HeaderEntry> headerEntries,\n-            final HTextFlowTarget lastTranslated) {\n+        final HTextFlowTarget lastTranslated) {\n         Date poFileRevisionDate = this.getHeaderRevisionDate(headerEntries);\n         Date translationsRevisionDate = null;\n         if (lastTranslated != null) {\n@@ -778,13 +756,13 @@ public class ResourceUtils implements Serializable {\n         }\n         if (translationsRevisionDate != null) {\n             if (poFileRevisionDate != null) {\n-                return translationsRevisionDate.after(poFileRevisionDate)\n-                        ? translationsRevisionDate : poFileRevisionDate;\n+                return translationsRevisionDate.after(poFileRevisionDate) ? translationsRevisionDate : poFileRevisionDate;\n             } else {\n                 return translationsRevisionDate;\n             }\n         } else {\n-            return poFileRevisionDate == null ? null : poFileRevisionDate;\n+            return poFileRevisionDate == null ? null\n+                : poFileRevisionDate;\n         }\n     }\n \n@@ -793,8 +771,8 @@ public class ResourceUtils implements Serializable {\n      *            - List of HTextFlowTarget\n      * @return last changed/updated HTextFlowTarget from the list\n      */\n-    private HTextFlowTarget\n-            getLastChangedTarget(final List<HTextFlowTarget> translations) {\n+\n+    private HTextFlowTarget getLastChangedTarget(final List<HTextFlowTarget> translations) {\n         Date lastUpdate = new Date(Long.MIN_VALUE);\n         HTextFlowTarget lastChanged = null;\n         for (HTextFlowTarget tft : translations) {\n@@ -816,24 +794,22 @@ public class ResourceUtils implements Serializable {\n      *            The PO header entries.\n      * @return A string with the value of the last translator.\n      */\n+\n     private String getLastTranslator(final HTextFlowTarget lastTranslated,\n-            final List<HeaderEntry> headerEntries) {\n+        final List<HeaderEntry> headerEntries) {\n         Date headerRevisionDate = this.getHeaderRevisionDate(headerEntries);\n         String lastTranslator = this.getHeaderLastTranslator(headerEntries);\n         if (lastTranslated != null) {\n             HPerson lastTranslatedBy = lastTranslated.getTranslator();\n             Date lastModifiedDate = lastTranslated.getLastChanged();\n             if (lastTranslatedBy != null) {\n-                if (lastModifiedDate == null\n-                        || lastModifiedDate.after(headerRevisionDate)) {\n+                if (lastModifiedDate == null || lastModifiedDate.after(headerRevisionDate)) {\n                     /**\n                      * Use translator details from last translated target if the\n                      * lastModifiedDate is null or if lastModifiedDate is after\n                      * date in header entries\n                      */\n-                    lastTranslator =\n-                            generateLastTranslator(lastTranslatedBy.getName(),\n-                                    lastTranslatedBy.getEmail());\n+                    lastTranslator = generateLastTranslator(lastTranslatedBy.getName(), lastTranslatedBy.getEmail());\n                 }\n             } else {\n                 /**\n@@ -841,8 +817,7 @@ public class ResourceUtils implements Serializable {\n                  * without user (e.g upload, copyTrans), set translator to be\n                  * Zanata\n                  */\n-                lastTranslator = generateLastTranslator(COPIED_BY_ZANATA_NAME,\n-                        COPIED_BY_ZANATA_NAME_EMAIL);\n+                lastTranslator = generateLastTranslator(COPIED_BY_ZANATA_NAME, COPIED_BY_ZANATA_NAME_EMAIL);\n             }\n         }\n         return lastTranslator;\n@@ -855,6 +830,7 @@ public class ResourceUtils implements Serializable {\n      *            - email of person\n      * @return {name} <{email}>\n      */\n+\n     private String generateLastTranslator(String name, String email) {\n         return name + \" <\" + email + \">\";\n     }\n@@ -867,6 +843,7 @@ public class ResourceUtils implements Serializable {\n      * @return A string with the value of the date suitable for a PO file\n      *         header.\n      */\n+\n     private String toPoHeaderString(Date aDate) {\n         if (aDate != null) {\n             SimpleDateFormat dateFormat = new SimpleDateFormat(PO_DATE_FORMAT);\n@@ -879,6 +856,7 @@ public class ResourceUtils implements Serializable {\n     /**\n      * Returns the Language Team PO file header for a given locale.\n      */\n+\n     private String getLanguageTeam(final HLocale hLocale) {\n         return hLocale.retrieveDisplayName();\n     }\n@@ -888,6 +866,7 @@ public class ResourceUtils implements Serializable {\n      *\n      * @param locale\n      */\n+\n     String getLanguage(HLocale locale) {\n         return StringUtils.replace(locale.getLocaleId().toString(), \"-\", \"_\");\n     }\n@@ -895,12 +874,10 @@ public class ResourceUtils implements Serializable {\n     /**\n      * Returns the application version.\n      */\n+\n     private String getSystemVersion() {\n         try {\n-            return ZANATA_GENERATOR_PREFIX + \" \"\n-                    + (ServiceLocator.instance()\n-                            .getInstance(ApplicationConfiguration.class))\n-                                    .getVersion();\n+            return ZANATA_GENERATOR_PREFIX + \" \" + (ServiceLocator.instance().getInstance(ApplicationConfiguration.class)).getVersion();\n         } catch (Exception e) {\n             return ZANATA_GENERATOR_PREFIX + \" UNKNOWN\";\n         }\n@@ -910,6 +887,7 @@ public class ResourceUtils implements Serializable {\n      * Returns the appropriate plural form for a given Locale. Returns a default\n      * value if there is no plural form information for the provided locale.\n      */\n+\n     public String getPluralForms(HLocale locale) {\n         return getPluralForms(locale.getLocaleId());\n     }\n@@ -921,6 +899,7 @@ public class ResourceUtils implements Serializable {\n      *\n      * @see {@link ResourceUtils#getPluralForms(org.zanata.common.LocaleId, boolean, boolean)}\n      */\n+\n     public String getPluralForms(LocaleId localeId) {\n         return getPluralForms(localeId, true, true);\n     }\n@@ -932,8 +911,8 @@ public class ResourceUtils implements Serializable {\n      *\n      * @return A default value if useDefault is True. Otherwise, null.\n      */\n-    public String getPluralForms(LocaleId localeId, boolean checkDB,\n-            boolean useDefault) {\n+\n+    public String getPluralForms(LocaleId localeId, boolean checkDB, boolean useDefault) {\n         if (checkDB) {\n             String dbPluralForms = getPluralFormsFromDB(localeId);\n             if (isNotEmpty(dbPluralForms)) {\n@@ -981,6 +960,7 @@ public class ResourceUtils implements Serializable {\n      * @param localeId\n      *            - locale identifier\n      */\n+\n     int getNumPlurals(@Nullable String poHeaders, LocaleId localeId) {\n         if (!isEmpty(poHeaders)) {\n             Properties headerList = loadHeaders(poHeaders);\n@@ -993,28 +973,20 @@ public class ResourceUtils implements Serializable {\n                     } catch (NumberFormatException | PluralParseException e) {\n                         log.debug(\"Unable to parse plurals\", e);\n                         // TODO return a warning to the user when uploading\n-                        log.warn(\n-                                \"Error parsing plural forms header; using defaults for locale {}; headers: {}\",\n-                                localeId, poHeaders);\n+                        log.warn(\"Error parsing plural forms header; using defaults for locale {}; headers: {}\", localeId, poHeaders);\n                     }\n                 } else {\n                     // TODO return a warning to the user when uploading\n-                    log.warn(\n-                            \"Empty plural forms header; using defaults for locale {}; headers: {}\",\n-                            localeId, poHeaders);\n+                    log.warn(\"Empty plural forms header; using defaults for locale {}; headers: {}\", localeId, poHeaders);\n                 }\n             } else {\n                 // otherwise (no header) use the locale default\n-                log.debug(\n-                        \"No plural forms header; using defaults for locale {}; headers: {}\",\n-                        localeId, poHeaders);\n+                log.debug(\"No plural forms header; using defaults for locale {}; headers: {}\", localeId, poHeaders);\n             }\n         }\n         String localePluralForms = getPluralFormsForLocale(localeId);\n         if (localePluralForms == null) {\n-            log.warn(\n-                    \"Assuming no plurals for locale {}; no plural info found in database or in {}; headers: {}\",\n-                    localeId, PLURALS_FILE, poHeaders);\n+            log.warn(\"Assuming no plurals for locale {}; no plural info found in database or in {}; headers: {}\", localeId, PLURALS_FILE, poHeaders);\n             return DEFAULT_NPLURALS;\n         }\n         return extractNPlurals(localePluralForms);\n@@ -1040,6 +1012,7 @@ public class ResourceUtils implements Serializable {\n      * @throws RuntimeException\n      *             if no plural forms are found\n      */\n+\n     @Nullable\n     private String getPluralFormsForLocale(LocaleId localeId) {\n         String pluralForms;\n@@ -1053,6 +1026,7 @@ public class ResourceUtils implements Serializable {\n     /**\n      * @return plural forms from HLocale, null if not found\n      */\n+\n     @Nullable\n     String getPluralFormsFromDB(LocaleId localeId) {\n         HLocale hLocale = localeDAO.findByLocaleId(localeId);\n@@ -1067,6 +1041,7 @@ public class ResourceUtils implements Serializable {\n      *\n      * @param localeId\n      */\n+\n     @Nullable\n     String getPluralFormsFromFile(@Nonnull LocaleId localeId) {\n         return getPluralForms(localeId, false, false);\n@@ -1078,21 +1053,18 @@ public class ResourceUtils implements Serializable {\n      * @param pluralForms\n      *            string to parse\n      */\n-    int extractNPlurals(@Nonnull String pluralForms)\n-            throws NumberFormatException, PluralParseException {\n+\n+    int extractNPlurals(@Nonnull String pluralForms) throws NumberFormatException, PluralParseException {\n         Matcher nPluralsMatcher = NPLURALS_PATTERN.matcher(pluralForms);\n         if (nPluralsMatcher.find()) {\n             String nPluralsString = nPluralsMatcher.group();\n-            Matcher nPluralsValueMatcher =\n-                    NPLURALS_TAG_PATTERN.matcher(nPluralsString);\n+            Matcher nPluralsValueMatcher = NPLURALS_TAG_PATTERN.matcher(nPluralsString);\n             nPluralsString = nPluralsValueMatcher.replaceAll(\"\");\n             if (isNotEmpty(nPluralsString)) {\n                 return Integer.parseInt(nPluralsString);\n             }\n         }\n-        throw new PluralParseException(\n-                \"can\\'t find valid nplurals in plural forms string: \"\n-                        + pluralForms);\n+        throw new PluralParseException(\"can\\'t find valid nplurals in plural forms string: \" + pluralForms);\n     }\n \n     /**\n@@ -1101,6 +1073,7 @@ public class ResourceUtils implements Serializable {\n      * @param pluralForms\n      *            string to check\n      */\n+\n     public boolean isValidPluralForms(@Nonnull String pluralForms) {\n         if (!PLURAL_FORM_PATTERN.matcher(pluralForms).find()) {\n             return false;\n@@ -1109,8 +1082,7 @@ public class ResourceUtils implements Serializable {\n         String nPluralsString = \"\";\n         while (nPluralsMatcher.find()) {\n             nPluralsString = nPluralsMatcher.group();\n-            Matcher nPluralsValueMatcher =\n-                    NPLURALS_TAG_PATTERN.matcher(nPluralsString);\n+            Matcher nPluralsValueMatcher = NPLURALS_TAG_PATTERN.matcher(nPluralsString);\n             nPluralsString = nPluralsValueMatcher.replaceAll(\"\");\n             break;\n         }\n@@ -1121,6 +1093,7 @@ public class ResourceUtils implements Serializable {\n             }\n         } catch (NumberFormatException e) {\n             // invalid string for integer\n+\n         }\n         return false;\n     }\n@@ -1130,8 +1103,8 @@ public class ResourceUtils implements Serializable {\n      * @param toHeader\n      * @see #pushPoTargetComment\n      */\n-    protected void pullPoTargetComment(HPoTargetHeader fromHeader,\n-            PoTargetHeader toHeader, List<HTextFlowTarget> hTargets) {\n+\n+    protected void pullPoTargetComment(HPoTargetHeader fromHeader, PoTargetHeader toHeader, List<HTextFlowTarget> hTargets) {\n         StringBuilder sb = new StringBuilder();\n         HSimpleComment comment = fromHeader.getComment();\n         if (comment != null) {\n@@ -1175,8 +1148,7 @@ public class ResourceUtils implements Serializable {\n         // to.setLang(from.get)\n     }\n \n-    public void transferToAbstractResourceMeta(HDocument from,\n-            AbstractResourceMeta to) {\n+    public void transferToAbstractResourceMeta(HDocument from, AbstractResourceMeta to) {\n         to.setContentType(from.getContentType());\n         to.setLang(from.getLocale().getLocaleId());\n         to.setName(from.getDocId());\n@@ -1187,8 +1159,7 @@ public class ResourceUtils implements Serializable {\n     }\n \n     public void transferToResourceExtensions(HDocument from,\n-            ExtensionSet<AbstractResourceMetaExtension> to,\n-            Set<String> enabledExtensions) {\n+           ExtensionSet<AbstractResourceMetaExtension> to, Set<String> enabledExtensions) {\n         if (enabledExtensions.contains(PoHeader.ID)) {\n             PoHeader poHeaderExt = new PoHeader();\n             if (from.getPoHeader() != null) {\n@@ -1206,10 +1177,11 @@ public class ResourceUtils implements Serializable {\n      * @see #transferFromTranslationsResourceExtensions\n      * @return true only if extensions were found\n      */\n+\n     public boolean transferToTranslationsResourceExtensions(HDocument from,\n-            ExtensionSet<TranslationsResourceExtension> to,\n-            Set<String> enabledExtensions, HLocale locale,\n-            List<HTextFlowTarget> hTargets) {\n+           ExtensionSet<TranslationsResourceExtension> to,\n+           Set<String> enabledExtensions,\n+           HLocale locale, List<HTextFlowTarget> hTargets) {\n         boolean found = false;\n         if (enabledExtensions.contains(PoTargetHeader.ID)) {\n             log.debug(\"PoTargetHeader requested\");\n@@ -1225,26 +1197,21 @@ public class ResourceUtils implements Serializable {\n                 fromHeader = new HPoTargetHeader();\n                 fromHeader.setEntries(\"\");\n             }\n-            transferToPoTargetHeader(fromHeader, poTargetHeader, hTargets,\n-                    locale);\n+            transferToPoTargetHeader(fromHeader, poTargetHeader, hTargets, locale);\n             to.add(poTargetHeader);\n         }\n         return found;\n     }\n \n-    public void transferToTextFlowExtensions(HTextFlow from,\n-            ExtensionSet<TextFlowExtension> to, Set<String> enabledExtensions) {\n-        if (enabledExtensions.contains(PotEntryHeader.ID)\n-                && from.getPotEntryData() != null) {\n+    public void transferToTextFlowExtensions(HTextFlow from, ExtensionSet<TextFlowExtension> to, Set<String> enabledExtensions) {\n+        if (enabledExtensions.contains(PotEntryHeader.ID) && from.getPotEntryData() != null) {\n             PotEntryHeader header = new PotEntryHeader();\n             transferToPotEntryHeader(from.getPotEntryData(), header);\n             log.debug(\"set header:{}\", from.getPotEntryData());\n             to.add(header);\n         }\n-        if (enabledExtensions.contains(SimpleComment.ID)\n-                && from.getComment() != null) {\n-            SimpleComment comment =\n-                    new SimpleComment(from.getComment().getComment());\n+        if (enabledExtensions.contains(SimpleComment.ID) && from.getComment() != null) {\n+            SimpleComment comment = new SimpleComment(from.getComment().getComment());\n             log.debug(\"set comment:{}\", from.getComment().getComment());\n             to.add(comment);\n         }\n@@ -1257,8 +1224,8 @@ public class ResourceUtils implements Serializable {\n      * @param from\n      * @param to\n      */\n-    private void transferToPotEntryHeader(HPotEntryData from,\n-            PotEntryHeader to) {\n+\n+    private void transferToPotEntryHeader(HPotEntryData from, PotEntryHeader to) {\n         to.setContext(from.getContext());\n         List<String> flags = new ArrayList<String>(0);\n         if (from.getFlags() != null) {\n@@ -1278,13 +1245,11 @@ public class ResourceUtils implements Serializable {\n      * @param enabledExtensions\n      * @todo merge with {@link #transferToTextFlowTarget}\n      */\n+\n     public void transferToTextFlowTargetExtensions(HTextFlowTarget from,\n-            ExtensionSet<TextFlowTargetExtension> to,\n-            Set<String> enabledExtensions) {\n-        if (enabledExtensions.contains(SimpleComment.ID)\n-                && from.getComment() != null) {\n-            SimpleComment comment =\n-                    new SimpleComment(from.getComment().getComment());\n+           ExtensionSet<TextFlowTargetExtension> to, Set<String> enabledExtensions) {\n+        if (enabledExtensions.contains(SimpleComment.ID) && from.getComment() != null) {\n+            SimpleComment comment = new SimpleComment(from.getComment().getComment());\n             to.add(comment);\n         }\n     }\n@@ -1311,9 +1276,9 @@ public class ResourceUtils implements Serializable {\n     /**\n      * @todo merge with {@link #transferToTextFlowTargetExtensions}\n      */\n+\n     @SuppressWarnings(\"deprecation\")\n-    public void transferToTextFlowTarget(HTextFlowTarget from,\n-            TextFlowTarget to, boolean markTranslatedAsApproved) {\n+    public void transferToTextFlowTarget(HTextFlowTarget from, TextFlowTarget to, boolean markTranslatedAsApproved) {\n         if (from.getTextFlow().isPlural()) {\n             to.setContents(from.getContents());\n         } else if (!from.getContents().isEmpty()) {\n@@ -1328,21 +1293,17 @@ public class ResourceUtils implements Serializable {\n         to.setTextFlowRevision(from.getTextFlowRevision());\n         HPerson translator = from.getTranslator();\n         if (translator != null) {\n-            to.setTranslator(\n-                    new Person(translator.getEmail(), translator.getName()));\n+            to.setTranslator(new Person(translator.getEmail(), translator.getName()));\n         }\n     }\n \n-    private static ContentState mapContentState(ContentState realState,\n-            boolean markTranslatedAsApproved) {\n+    private static ContentState mapContentState(ContentState realState, boolean markTranslatedAsApproved) {\n         if (markTranslatedAsApproved) {\n             switch (realState) {\n             case Translated:\n                 return ContentState.Approved;\n-\n             case Rejected:\n                 return ContentState.NeedReview;\n-\n             default:\n                 return realState;\n             }\n@@ -1357,13 +1318,10 @@ public class ResourceUtils implements Serializable {\n         Resource entity = new Resource(document.getDocId());\n         this.transferToResource(document, entity);\n         // handle extensions\n-        this.transferToResourceExtensions(document, entity.getExtensions(true),\n-                extensions);\n+        this.transferToResourceExtensions(document, entity.getExtensions(true), extensions);\n         for (HTextFlow htf : document.getTextFlows()) {\n-            TextFlow tf = new TextFlow(htf.getResId(),\n-                    document.getLocale().getLocaleId());\n-            this.transferToTextFlowExtensions(htf, tf.getExtensions(true),\n-                    extensions);\n+            TextFlow tf = new TextFlow(htf.getResId(), document.getLocale().getLocaleId());\n+            this.transferToTextFlowExtensions(htf, tf.getExtensions(true), extensions);\n             this.transferToTextFlow(htf, tf);\n             entity.getTextFlows().add(tf);\n         }\n@@ -1381,19 +1339,19 @@ public class ResourceUtils implements Serializable {\n      * @return true only if some data was found (text flow targets, or some\n      *         metadata extensions)\n      */\n+\n     public boolean transferToTranslationsResource(TranslationsResource transRes,\n-            HDocument document, HLocale locale, Set<String> enabledExtensions,\n-            List<HTextFlowTarget> hTargets, boolean markTranslatedAsApproved) {\n-        boolean found = this.transferToTranslationsResourceExtensions(document,\n-                transRes.getExtensions(true), enabledExtensions, locale,\n-                hTargets);\n+           HDocument document,\n+           HLocale locale,\n+           Set<String> enabledExtensions,\n+           List<HTextFlowTarget> hTargets, boolean markTranslatedAsApproved) {\n+        boolean found = this.transferToTranslationsResourceExtensions(document, transRes.getExtensions(true), enabledExtensions, locale, hTargets);\n         for (HTextFlowTarget hTarget : hTargets) {\n             found = true;\n             TextFlowTarget target = new TextFlowTarget();\n             target.setResId(hTarget.getTextFlow().getResId());\n             this.transferToTextFlowTarget(hTarget, target, markTranslatedAsApproved);\n-            this.transferToTextFlowTargetExtensions(hTarget,\n-                    target.getExtensions(true), enabledExtensions);\n+            this.transferToTextFlowTargetExtensions(hTarget, target.getExtensions(true), enabledExtensions);\n             transRes.getTextFlowTargets().add(target);\n         }\n         return found;\n@@ -1406,17 +1364,13 @@ public class ResourceUtils implements Serializable {\n      * @param requestedExt\n      *            Extensions to be validated\n      */\n+\n     public static void validateExtensions(Set<String> requestedExt) {\n         Set<String> validExtensions = ExtensionType.asStringSet();\n         if (!CollectionUtils.isSubCollection(requestedExt, validExtensions)) {\n             @SuppressWarnings(\"unchecked\")\n-            Collection<String> invalidExtensions =\n-                    CollectionUtils.subtract(requestedExt, validExtensions);\n-            Response response =\n-                    Response.status(Status.BAD_REQUEST)\n-                            .entity(\"Unsupported Extensions within this context: \"\n-                                    + StringUtils.join(invalidExtensions, \",\"))\n-                            .build();\n+            Collection<String> invalidExtensions = CollectionUtils.subtract(requestedExt, validExtensions);\n+            Response response = Response.status(Status.BAD_REQUEST).entity(\"Unsupported Extensions within this context: \" + StringUtils.join(invalidExtensions, \",\")).build();\n             throw new WebApplicationException(response);\n         }\n     }\n@@ -1428,4 +1382,4 @@ public class ResourceUtils implements Serializable {\n             super(string);\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 274
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "374",
                    "column": "38",
                    "severity": "error",
                    "message": "';' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                },
                {
                    "line": "374",
                    "column": "39",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/11/ResourceUtils.java\nindex b5d24bde0cc..a2f1bd377be 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/11/ResourceUtils.java\n@@ -371,7 +371,7 @@ public class ResourceUtils implements Serializable {\n             toTargetHeader.setTargetLanguage(locale);\n             toTargetHeader.setDocument(doc);\n             transferFromPoTargetHeader(fromTargetHeader, toTargetHeader,\n-                    MergeType.IMPORT); // return\n+                    MergeType.IMPORT);// return\n             // value\n             // not\n             // needed\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/11/ResourceUtils.java\nindex b5d24bde0cc..352a6bca680 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/11/ResourceUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/11/ResourceUtils.java\n@@ -371,8 +371,9 @@ public class ResourceUtils implements Serializable {\n             toTargetHeader.setTargetLanguage(locale);\n             toTargetHeader.setDocument(doc);\n             transferFromPoTargetHeader(fromTargetHeader, toTargetHeader,\n-                    MergeType.IMPORT); // return\n-            // value\n+                    MergeType.IMPORT);\n+                    // return                                                                                       // value\n+                     // value\n             // not\n             // needed\n             entityManager.persist(toTargetHeader);\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}