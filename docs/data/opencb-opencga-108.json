{
    "project_name": "opencb-opencga",
    "error_id": "108",
    "information": {
        "errors": [
            {
                "line": "441",
                "severity": "error",
                "message": "Line is longer than 140 characters (found 147).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\n    /**\n     * This method attempts to load storage configuration from OpenCGA installation folder, if not exists then loads JAR storage-configuration.yml.\n     *\n     * @throws IOException If any IO problem occurs\n     */",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "441",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "442",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 145).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/108/OpenCgaAnalysis.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/108/OpenCgaAnalysis.java\nindex 4c3ac66fe64..b0b26a2329f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/108/OpenCgaAnalysis.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/108/OpenCgaAnalysis.java\n@@ -59,404 +59,405 @@ import static org.opencb.opencga.core.analysis.OpenCgaAnalysisExecutor.EXECUTOR_\n \n public abstract class OpenCgaAnalysis {\n \n-    protected CatalogManager catalogManager;\n-    protected Configuration configuration;\n-    protected StorageConfiguration storageConfiguration;\n-    protected VariantStorageManager variantStorageManager;\n-\n-    protected String opencgaHome;\n-    protected String sessionId;\n-\n-    protected ObjectMap params;\n-    protected ObjectMap executorParams;\n-    protected List<AnalysisExecutor.Source> sourceTypes;\n-    protected List<AnalysisExecutor.Framework> availableFrameworks;\n-    protected Logger logger;\n-    private Path outDir;\n-    private Path scratchDir;\n-    private final Logger privateLogger = LoggerFactory.getLogger(OpenCgaAnalysis.class);\n-\n-    private AnalysisResultManager arm;\n-\n-    public OpenCgaAnalysis() {\n-    }\n-\n-    public final OpenCgaAnalysis setUp(String opencgaHome, CatalogManager catalogManager, StorageEngineFactory engineFactory,\n-                                       ObjectMap params, Path outDir, String sessionId) {\n-        VariantStorageManager manager = new VariantStorageManager(catalogManager, engineFactory);\n-        return setUp(opencgaHome, catalogManager, manager, params, outDir, sessionId);\n-    }\n-\n-    public final OpenCgaAnalysis setUp(String opencgaHome, CatalogManager catalogManager, VariantStorageManager variantStorageManager,\n-                                       ObjectMap params, Path outDir, String sessionId) {\n-        this.opencgaHome = opencgaHome;\n-        this.catalogManager = catalogManager;\n-        this.configuration = catalogManager.getConfiguration();\n-        this.variantStorageManager = variantStorageManager;\n-        this.storageConfiguration = variantStorageManager.getStorageConfiguration();\n-        this.sessionId = sessionId;\n-        this.params = params;\n-        this.executorParams = new ObjectMap();\n-        this.outDir = outDir;\n-\n-        return setUpFrameworksAndSource();\n-    }\n-\n-    public final OpenCgaAnalysis setUp(String opencgaHome, ObjectMap params, Path outDir, String sessionId)\n-            throws AnalysisException {\n-        this.opencgaHome = opencgaHome;\n-        this.sessionId = sessionId;\n-        this.params = params;\n-        this.executorParams = new ObjectMap();\n-        this.outDir = outDir;\n-\n-        try {\n-            loadConfiguration();\n-            loadStorageConfiguration();\n-\n-            this.catalogManager = new CatalogManager(configuration);\n-            this.variantStorageManager = new VariantStorageManager(catalogManager, StorageEngineFactory.get(storageConfiguration));\n-        } catch (IOException | CatalogException e) {\n-            throw new AnalysisException(e);\n-        }\n-\n-        return setUpFrameworksAndSource();\n-    }\n-\n-    private OpenCgaAnalysis setUpFrameworksAndSource() {\n-        logger = LoggerFactory.getLogger(this.getClass().toString());\n-\n-        availableFrameworks = new ArrayList<>();\n-        sourceTypes = new ArrayList<>();\n-        if (storageConfiguration.getDefaultStorageEngineId().equals(\"mongodb\")) {\n-            if (getAnalysisData().equals(Analysis.AnalysisType.VARIANT)) {\n-                sourceTypes.add(AnalysisExecutor.Source.MONGODB);\n-            }\n-        } else if (storageConfiguration.getDefaultStorageEngineId().equals(\"hadoop\")) {\n-            availableFrameworks.add(AnalysisExecutor.Framework.MAP_REDUCE);\n-            // TODO: Check from configuration if spark is available\n+  protected CatalogManager catalogManager;\n+  protected Configuration configuration;\n+  protected StorageConfiguration storageConfiguration;\n+  protected VariantStorageManager variantStorageManager;\n+\n+  protected String opencgaHome;\n+  protected String sessionId;\n+\n+  protected ObjectMap params;\n+  protected ObjectMap executorParams;\n+  protected List<AnalysisExecutor.Source> sourceTypes;\n+  protected List<AnalysisExecutor.Framework> availableFrameworks;\n+  protected Logger logger;\n+  private Path outDir;\n+  private Path scratchDir;\n+  private final Logger privateLogger = LoggerFactory.getLogger(OpenCgaAnalysis.class);\n+\n+  private AnalysisResultManager arm;\n+\n+  public OpenCgaAnalysis() {\n+  }\n+\n+  public final OpenCgaAnalysis setUp(String opencgaHome, CatalogManager catalogManager, StorageEngineFactory engineFactory,\n+                                     ObjectMap params, Path outDir, String sessionId) {\n+    VariantStorageManager manager = new VariantStorageManager(catalogManager, engineFactory);\n+    return setUp(opencgaHome, catalogManager, manager, params, outDir, sessionId);\n+  }\n+\n+  public final OpenCgaAnalysis setUp(String opencgaHome, CatalogManager catalogManager, VariantStorageManager variantStorageManager,\n+                                     ObjectMap params, Path outDir, String sessionId) {\n+    this.opencgaHome = opencgaHome;\n+    this.catalogManager = catalogManager;\n+    this.configuration = catalogManager.getConfiguration();\n+    this.variantStorageManager = variantStorageManager;\n+    this.storageConfiguration = variantStorageManager.getStorageConfiguration();\n+    this.sessionId = sessionId;\n+    this.params = params;\n+    this.executorParams = new ObjectMap();\n+    this.outDir = outDir;\n+\n+    return setUpFrameworksAndSource();\n+  }\n+\n+  public final OpenCgaAnalysis setUp(String opencgaHome, ObjectMap params, Path outDir, String sessionId)\n+      throws AnalysisException {\n+    this.opencgaHome = opencgaHome;\n+    this.sessionId = sessionId;\n+    this.params = params;\n+    this.executorParams = new ObjectMap();\n+    this.outDir = outDir;\n+\n+    try {\n+      loadConfiguration();\n+      loadStorageConfiguration();\n+\n+      this.catalogManager = new CatalogManager(configuration);\n+      this.variantStorageManager = new VariantStorageManager(catalogManager, StorageEngineFactory.get(storageConfiguration));\n+    } catch (IOException | CatalogException e) {\n+      throw new AnalysisException(e);\n+    }\n+\n+    return setUpFrameworksAndSource();\n+  }\n+\n+  private OpenCgaAnalysis setUpFrameworksAndSource() {\n+    logger = LoggerFactory.getLogger(this.getClass().toString());\n+\n+    availableFrameworks = new ArrayList<>();\n+    sourceTypes = new ArrayList<>();\n+    if (storageConfiguration.getDefaultStorageEngineId().equals(\"mongodb\")) {\n+      if (getAnalysisData().equals(Analysis.AnalysisType.VARIANT)) {\n+        sourceTypes.add(AnalysisExecutor.Source.MONGODB);\n+      }\n+    } else if (storageConfiguration.getDefaultStorageEngineId().equals(\"hadoop\")) {\n+      availableFrameworks.add(AnalysisExecutor.Framework.MAP_REDUCE);\n+      // TODO: Check from configuration if spark is available\n //            availableFrameworks.add(AnalysisExecutor.Framework.SPARK);\n-            if (getAnalysisData().equals(Analysis.AnalysisType.VARIANT)) {\n-                sourceTypes.add(AnalysisExecutor.Source.HBASE);\n-            }\n-        }\n-\n-        availableFrameworks.add(AnalysisExecutor.Framework.LOCAL);\n-        sourceTypes.add(AnalysisExecutor.Source.STORAGE);\n-        return this;\n-    }\n-\n-    /**\n-     * Execute the analysis. The analysis should have been properly setUp before being executed.\n-     *\n-     * @return AnalysisResult\n-     * @throws AnalysisException on error\n-     */\n-    public final AnalysisResult start() throws AnalysisException {\n-        arm = new AnalysisResultManager(getId(), outDir);\n-        arm.init(params, executorParams);\n+      if (getAnalysisData().equals(Analysis.AnalysisType.VARIANT)) {\n+        sourceTypes.add(AnalysisExecutor.Source.HBASE);\n+      }\n+    }\n+\n+    availableFrameworks.add(AnalysisExecutor.Framework.LOCAL);\n+    sourceTypes.add(AnalysisExecutor.Source.STORAGE);\n+    return this;\n+  }\n+\n+  /**\n+   * Execute the analysis. The analysis should have been properly setUp before being executed.\n+   *\n+   * @return AnalysisResult\n+   * @throws AnalysisException on error\n+   */\n+  public final AnalysisResult start() throws AnalysisException {\n+    arm = new AnalysisResultManager(getId(), outDir);\n+    arm.init(params, executorParams);\n+    try {\n+      if (scratchDir == null) {\n+        Path baseScratchDir = this.outDir; // TODO: Read from configuration\n         try {\n-            if (scratchDir == null) {\n-                Path baseScratchDir = this.outDir; // TODO: Read from configuration\n-                try {\n-                    scratchDir = Files.createDirectory(baseScratchDir.resolve(getId() + RandomStringUtils.random(10)));\n-                } catch (IOException e) {\n-                    throw new AnalysisException(e);\n-                }\n-            }\n-            check();\n-            arm.setParams(params); // params may be modified after check method\n-            arm.setSteps(getSteps());\n-            run();\n-            try {\n-                FileUtils.deleteDirectory(scratchDir.toFile());\n-            } catch (IOException e) {\n-                String warningMessage = \"Error deleting scratch folder \" + scratchDir + \" : \" + e.getMessage();\n-                logger.warn(warningMessage, e);\n-                arm.addWarning(warningMessage);\n-            }\n-            return arm.close();\n-        } catch (RuntimeException | AnalysisException e) {\n-            arm.close(e);\n-            throw e;\n-        }\n-    }\n-\n-    /**\n-     * Check that the given parameters are correct.\n-     * This method will be called before the {@link #run()}.\n-     *\n-     * @throws AnalysisException if the parameters are not correct\n-     */\n-    protected void check() throws AnalysisException {\n-    }\n-\n-    /**\n-     * Method to be implemented by subclasses with the actual execution of the analysis.\n-     * @throws AnalysisException on error\n-     */\n-    protected abstract void run() throws AnalysisException;\n-\n-    /**\n-     * @return the analysis id\n-     */\n-    public final String getId() {\n-        return this.getClass().getAnnotation(Analysis.class).id();\n-    }\n-\n-    /**\n-     * @return the analysis steps\n-     */\n-    public List<String> getSteps() {\n-        List<String> steps = new ArrayList<>();\n-        steps.add(getId());\n-        return steps;\n-    }\n-\n-    /**\n-     * @return the analysis id\n-     */\n-    public final Analysis.AnalysisType getAnalysisData() {\n-        return this.getClass().getAnnotation(Analysis.class).type();\n-    }\n-\n-    /**\n-     * @return Output directory of the job.\n-     */\n-    public final Path getOutDir() {\n-        return outDir;\n-    }\n-\n-    /**\n-     * @return Temporary scratch directory. Files generated in this folder will be deleted.\n-     */\n-    public final Path getScratchDir() {\n-        return scratchDir;\n-    }\n-\n-    public final OpenCgaAnalysis addSource(AnalysisExecutor.Source source) {\n-        if (sourceTypes == null) {\n-            sourceTypes = new ArrayList<>();\n-        }\n-        sourceTypes.add(source);\n-        return this;\n-    }\n-\n-    public final OpenCgaAnalysis addFramework(AnalysisExecutor.Framework framework) {\n-        if (availableFrameworks == null) {\n-            availableFrameworks = new ArrayList<>();\n-        }\n-        availableFrameworks.add(framework);\n-        return this;\n-    }\n-\n-    @FunctionalInterface\n-    protected interface StepRunnable {\n-        void run() throws AnalysisException;\n-    }\n-\n-    protected final void step(StepRunnable step) throws AnalysisException {\n-        step(getId(), step);\n-    }\n-\n-    protected final void step(String stepId, StepRunnable step) throws AnalysisException {\n-        if (checkStep(stepId)) {\n-            try {\n-                step.run();\n-            } catch (RuntimeException e) {\n-                throw new AnalysisException(\"Exception from step \" + stepId, e);\n-            }\n-        }\n-    }\n-\n-    protected final boolean checkStep(String stepId) throws AnalysisException {\n-        return arm.checkStep(stepId);\n-    }\n-\n-    protected final void errorStep() throws AnalysisException {\n-        arm.errorStep();\n-    }\n-\n-    protected final void addWarning(String warning) throws AnalysisException {\n-        arm.addWarning(warning);\n-    }\n-\n-    protected final void addError(Exception e) throws AnalysisException {\n-        arm.addError(e);\n-    }\n-\n-    protected final void addAttribute(String key, Object value) throws AnalysisException {\n-        arm.addAttribute(key, value);\n-    }\n-\n-    protected final void addFile(Path file, FileResult.FileType fileType) throws AnalysisException {\n-        arm.addFile(file, fileType);\n-    }\n-\n-    protected final List<FileResult> getOutputFiles() throws AnalysisException {\n-        return arm.read().getOutputFiles();\n-    }\n-\n-    protected final Class<? extends OpenCgaAnalysisExecutor> getAnalysisExecutorClass(String analysisExecutorId) {\n-        return getAnalysisExecutorClass(OpenCgaAnalysisExecutor.class, analysisExecutorId, null, null);\n-    }\n-\n-    protected final <T extends OpenCgaAnalysisExecutor> Class<? extends T> getAnalysisExecutorClass(\n-            Class<T> clazz, String analysisExecutorId, List<AnalysisExecutor.Source> sourceTypes,\n-            List<AnalysisExecutor.Framework> availableFrameworks) {\n-        Objects.requireNonNull(clazz);\n-        String analysisId = getId();\n-\n-        if (sourceTypes == null) {\n-            sourceTypes = this.sourceTypes;\n-        }\n-        if (CollectionUtils.isEmpty(availableFrameworks)) {\n-            availableFrameworks = this.availableFrameworks;\n-        }\n-\n-        Reflections reflections = new Reflections(new ConfigurationBuilder()\n-                .setScanners(\n-                        new SubTypesScanner(),\n-                        new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, AnalysisExecutor.class.getName())))\n-                .addUrls(ClasspathHelper.forJavaClassPath())\n-                .filterInputsBy(input -> input.endsWith(\".class\"))\n-        );\n-\n-        Set<Class<? extends T>> typesAnnotatedWith = reflections.getSubTypesOf(clazz);\n-        List<Class<? extends T>> matchedClasses = new ArrayList<>();\n-        for (Class<? extends T> aClass : typesAnnotatedWith) {\n-            AnalysisExecutor annotation = aClass.getAnnotation(AnalysisExecutor.class);\n-            if (annotation != null) {\n-                if (annotation.analysis().equals(analysisId)) {\n-                    if (StringUtils.isEmpty(analysisExecutorId) || analysisExecutorId.equals(annotation.id())) {\n-                        if (CollectionUtils.isEmpty(sourceTypes) || sourceTypes.contains(annotation.source())) {\n-                            if (CollectionUtils.isEmpty(availableFrameworks) || availableFrameworks.contains(annotation.framework())) {\n-                                matchedClasses.add(aClass);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if (matchedClasses.isEmpty()) {\n-            return null;\n-        } else if (matchedClasses.size() == 1) {\n-            return matchedClasses.get(0);\n-        } else {\n-            privateLogger.info(\"Found multiple OpenCgaAnalysisExecutor candidates.\");\n-            for (Class<? extends T> matchedClass : matchedClasses) {\n-                privateLogger.info(\" - \" + matchedClass);\n-            }\n-            privateLogger.info(\"Sort by framework and source preference.\");\n-\n-            // Prefer the executor that matches better with the source\n-            // Prefer the executor that matches better with the framework\n-            List<AnalysisExecutor.Framework> finalAvailableFrameworks =\n-                    availableFrameworks == null ? Collections.emptyList() : availableFrameworks;\n-            List<AnalysisExecutor.Source> finalSourceTypes =\n-                    sourceTypes == null ? Collections.emptyList() : sourceTypes;\n-\n-            Comparator<Class<? extends T>> comparator = Comparator.<Class<? extends T>>comparingInt(c1 -> {\n-                AnalysisExecutor annot1 = c1.getAnnotation(AnalysisExecutor.class);\n-                return finalAvailableFrameworks.indexOf(annot1.framework());\n-            }).thenComparingInt(c -> {\n-                AnalysisExecutor annot = c.getAnnotation(AnalysisExecutor.class);\n-                return finalSourceTypes.indexOf(annot.source());\n-            }).thenComparing(Class::getName);\n-\n-            matchedClasses.sort(comparator);\n-\n-            return matchedClasses.get(0);\n-        }\n-    }\n-\n-    protected final OpenCgaAnalysisExecutor getAnalysisExecutor()\n-            throws AnalysisExecutorException {\n-        return getAnalysisExecutor(OpenCgaAnalysisExecutor.class, null, null, null);\n-    }\n-\n-    protected final <T extends OpenCgaAnalysisExecutor> T getAnalysisExecutor(Class<T> clazz)\n-            throws AnalysisExecutorException {\n-        return getAnalysisExecutor(clazz, executorParams.getString(EXECUTOR_ID), null, null);\n-    }\n-\n-    protected final <T extends OpenCgaAnalysisExecutor> T getAnalysisExecutor(Class<T> clazz, String analysisExecutorId)\n-            throws AnalysisExecutorException {\n-        return getAnalysisExecutor(clazz, analysisExecutorId, null, null);\n-    }\n-\n-    protected final <T extends OpenCgaAnalysisExecutor> T getAnalysisExecutor(\n-            Class<T> clazz, String analysisExecutorId, List<AnalysisExecutor.Source> source,\n-            List<AnalysisExecutor.Framework> availableFrameworks)\n-            throws AnalysisExecutorException {\n-        Class<? extends T> executorClass = getAnalysisExecutorClass(clazz, analysisExecutorId, source, availableFrameworks);\n-        if (executorClass == null) {\n-            throw AnalysisExecutorException.executorNotFound(clazz, getId(), analysisExecutorId, source, availableFrameworks);\n+          scratchDir = Files.createDirectory(baseScratchDir.resolve(getId() + RandomStringUtils.random(10)));\n+        } catch (IOException e) {\n+          throw new AnalysisException(e);\n         }\n-        try {\n-            T t = executorClass.newInstance();\n-            privateLogger.info(\"Using OpenCgaAnalysisExecutor '\" + t.getId() + \"' : \" + executorClass);\n-\n-            String executorId = t.getId();\n-            if (executorParams == null) {\n-                executorParams = new ObjectMap();\n+      }\n+      check();\n+      arm.setParams(params); // params may be modified after check method\n+      arm.setSteps(getSteps());\n+      run();\n+      try {\n+        FileUtils.deleteDirectory(scratchDir.toFile());\n+      } catch (IOException e) {\n+        String warningMessage = \"Error deleting scratch folder \" + scratchDir + \" : \" + e.getMessage();\n+        logger.warn(warningMessage, e);\n+        arm.addWarning(warningMessage);\n+      }\n+      return arm.close();\n+    } catch (RuntimeException | AnalysisException e) {\n+      arm.close(e);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Check that the given parameters are correct.\n+   * This method will be called before the {@link #run()}.\n+   *\n+   * @throws AnalysisException if the parameters are not correct\n+   */\n+  protected void check() throws AnalysisException {\n+  }\n+\n+  /**\n+   * Method to be implemented by subclasses with the actual execution of the analysis.\n+   *\n+   * @throws AnalysisException on error\n+   */\n+  protected abstract void run() throws AnalysisException;\n+\n+  /**\n+   * @return the analysis id\n+   */\n+  public final String getId() {\n+    return this.getClass().getAnnotation(Analysis.class).id();\n+  }\n+\n+  /**\n+   * @return the analysis steps\n+   */\n+  public List<String> getSteps() {\n+    List<String> steps = new ArrayList<>();\n+    steps.add(getId());\n+    return steps;\n+  }\n+\n+  /**\n+   * @return the analysis id\n+   */\n+  public final Analysis.AnalysisType getAnalysisData() {\n+    return this.getClass().getAnnotation(Analysis.class).type();\n+  }\n+\n+  /**\n+   * @return Output directory of the job.\n+   */\n+  public final Path getOutDir() {\n+    return outDir;\n+  }\n+\n+  /**\n+   * @return Temporary scratch directory. Files generated in this folder will be deleted.\n+   */\n+  public final Path getScratchDir() {\n+    return scratchDir;\n+  }\n+\n+  public final OpenCgaAnalysis addSource(AnalysisExecutor.Source source) {\n+    if (sourceTypes == null) {\n+      sourceTypes = new ArrayList<>();\n+    }\n+    sourceTypes.add(source);\n+    return this;\n+  }\n+\n+  public final OpenCgaAnalysis addFramework(AnalysisExecutor.Framework framework) {\n+    if (availableFrameworks == null) {\n+      availableFrameworks = new ArrayList<>();\n+    }\n+    availableFrameworks.add(framework);\n+    return this;\n+  }\n+\n+  @FunctionalInterface\n+  protected interface StepRunnable {\n+    void run() throws AnalysisException;\n+  }\n+\n+  protected final void step(StepRunnable step) throws AnalysisException {\n+    step(getId(), step);\n+  }\n+\n+  protected final void step(String stepId, StepRunnable step) throws AnalysisException {\n+    if (checkStep(stepId)) {\n+      try {\n+        step.run();\n+      } catch (RuntimeException e) {\n+        throw new AnalysisException(\"Exception from step \" + stepId, e);\n+      }\n+    }\n+  }\n+\n+  protected final boolean checkStep(String stepId) throws AnalysisException {\n+    return arm.checkStep(stepId);\n+  }\n+\n+  protected final void errorStep() throws AnalysisException {\n+    arm.errorStep();\n+  }\n+\n+  protected final void addWarning(String warning) throws AnalysisException {\n+    arm.addWarning(warning);\n+  }\n+\n+  protected final void addError(Exception e) throws AnalysisException {\n+    arm.addError(e);\n+  }\n+\n+  protected final void addAttribute(String key, Object value) throws AnalysisException {\n+    arm.addAttribute(key, value);\n+  }\n+\n+  protected final void addFile(Path file, FileResult.FileType fileType) throws AnalysisException {\n+    arm.addFile(file, fileType);\n+  }\n+\n+  protected final List<FileResult> getOutputFiles() throws AnalysisException {\n+    return arm.read().getOutputFiles();\n+  }\n+\n+  protected final Class<? extends OpenCgaAnalysisExecutor> getAnalysisExecutorClass(String analysisExecutorId) {\n+    return getAnalysisExecutorClass(OpenCgaAnalysisExecutor.class, analysisExecutorId, null, null);\n+  }\n+\n+  protected final <T extends OpenCgaAnalysisExecutor> Class<? extends T> getAnalysisExecutorClass(\n+      Class<T> clazz, String analysisExecutorId, List<AnalysisExecutor.Source> sourceTypes,\n+      List<AnalysisExecutor.Framework> availableFrameworks) {\n+    Objects.requireNonNull(clazz);\n+    String analysisId = getId();\n+\n+    if (sourceTypes == null) {\n+      sourceTypes = this.sourceTypes;\n+    }\n+    if (CollectionUtils.isEmpty(availableFrameworks)) {\n+      availableFrameworks = this.availableFrameworks;\n+    }\n+\n+    Reflections reflections = new Reflections(new ConfigurationBuilder()\n+        .setScanners(\n+            new SubTypesScanner(),\n+            new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, AnalysisExecutor.class.getName())))\n+        .addUrls(ClasspathHelper.forJavaClassPath())\n+        .filterInputsBy(input -> input.endsWith(\".class\"))\n+    );\n+\n+    Set<Class<? extends T>> typesAnnotatedWith = reflections.getSubTypesOf(clazz);\n+    List<Class<? extends T>> matchedClasses = new ArrayList<>();\n+    for (Class<? extends T> aClass : typesAnnotatedWith) {\n+      AnalysisExecutor annotation = aClass.getAnnotation(AnalysisExecutor.class);\n+      if (annotation != null) {\n+        if (annotation.analysis().equals(analysisId)) {\n+          if (StringUtils.isEmpty(analysisExecutorId) || analysisExecutorId.equals(annotation.id())) {\n+            if (CollectionUtils.isEmpty(sourceTypes) || sourceTypes.contains(annotation.source())) {\n+              if (CollectionUtils.isEmpty(availableFrameworks) || availableFrameworks.contains(annotation.framework())) {\n+                matchedClasses.add(aClass);\n+              }\n             }\n-            executorParams.put(EXECUTOR_ID, executorId);\n-\n-            // Update executor ID\n-            if (arm != null) {\n-                arm.setExecutorInfo(new ExecutorInfo(executorId, executorClass, executorParams, t.getSource(), t.getFramework()));\n-            }\n-            t.setUp(arm, executorParams, outDir);\n-\n-            return t;\n-        } catch (InstantiationException | IllegalAccessException | AnalysisException e) {\n-            throw AnalysisExecutorException.cantInstantiate(executorClass, e);\n-        }\n-    }\n-\n-    protected final void setUpStorageEngineExecutor(String study) throws AnalysisException {\n-        executorParams.put(\"opencgaHome\", opencgaHome);\n-        executorParams.put(\"sessionId\", sessionId);\n-        try {\n-            DataStore dataStore = variantStorageManager.getDataStore(study, sessionId);\n-\n-            executorParams.put(\"storageEngineId\", dataStore.getStorageEngine());\n-            executorParams.put(\"dbName\", dataStore.getDbName());\n-        } catch (CatalogException e) {\n-            throw new AnalysisException(e);\n+          }\n         }\n-    }\n-\n-    /**\n-     * This method attempts to load general configuration from OpenCGA installation folder, if not exists then loads JAR configuration.yml.\n-     *\n-     * @throws IOException If any IO problem occurs\n-     */\n-    private void loadConfiguration() throws IOException {\n-        this.configuration = ConfigurationUtils.loadConfiguration(opencgaHome);\n-    }\n-\n-    /**\n-     * This method attempts to load storage configuration from OpenCGA installation folder, if not exists then loads JAR storage-configuration.yml.\n-     *\n-     * @throws IOException If any IO problem occurs\n-     */\n-    private void loadStorageConfiguration() throws IOException {\n-        this.storageConfiguration = ConfigurationUtils.loadStorageConfiguration(opencgaHome);\n-    }\n-\n-\n-    protected final Analyst getAnalyst(String token) throws AnalysisException {\n-        try {\n-            String userId = catalogManager.getUserManager().getUserId(token);\n-            DataResult<User> userQueryResult = catalogManager.getUserManager().get(userId, new QueryOptions(QueryOptions.INCLUDE,\n-                    Arrays.asList(UserDBAdaptor.QueryParams.EMAIL.key(), UserDBAdaptor.QueryParams.ORGANIZATION.key())), token);\n-\n-            return new Analyst(userId, userQueryResult.first().getEmail(), userQueryResult.first().getOrganization());\n-        } catch (CatalogException e) {\n-            throw new AnalysisException(e.getMessage(), e);\n-        }\n-    }\n+      }\n+    }\n+    if (matchedClasses.isEmpty()) {\n+      return null;\n+    } else if (matchedClasses.size() == 1) {\n+      return matchedClasses.get(0);\n+    } else {\n+      privateLogger.info(\"Found multiple OpenCgaAnalysisExecutor candidates.\");\n+      for (Class<? extends T> matchedClass : matchedClasses) {\n+        privateLogger.info(\" - \" + matchedClass);\n+      }\n+      privateLogger.info(\"Sort by framework and source preference.\");\n+\n+      // Prefer the executor that matches better with the source\n+      // Prefer the executor that matches better with the framework\n+      List<AnalysisExecutor.Framework> finalAvailableFrameworks =\n+          availableFrameworks == null ? Collections.emptyList() : availableFrameworks;\n+      List<AnalysisExecutor.Source> finalSourceTypes =\n+          sourceTypes == null ? Collections.emptyList() : sourceTypes;\n+\n+      Comparator<Class<? extends T>> comparator = Comparator.<Class<? extends T>>comparingInt(c1 -> {\n+        AnalysisExecutor annot1 = c1.getAnnotation(AnalysisExecutor.class);\n+        return finalAvailableFrameworks.indexOf(annot1.framework());\n+      }).thenComparingInt(c -> {\n+        AnalysisExecutor annot = c.getAnnotation(AnalysisExecutor.class);\n+        return finalSourceTypes.indexOf(annot.source());\n+      }).thenComparing(Class::getName);\n+\n+      matchedClasses.sort(comparator);\n+\n+      return matchedClasses.get(0);\n+    }\n+  }\n+\n+  protected final OpenCgaAnalysisExecutor getAnalysisExecutor()\n+      throws AnalysisExecutorException {\n+    return getAnalysisExecutor(OpenCgaAnalysisExecutor.class, null, null, null);\n+  }\n+\n+  protected final <T extends OpenCgaAnalysisExecutor> T getAnalysisExecutor(Class<T> clazz)\n+      throws AnalysisExecutorException {\n+    return getAnalysisExecutor(clazz, executorParams.getString(EXECUTOR_ID), null, null);\n+  }\n+\n+  protected final <T extends OpenCgaAnalysisExecutor> T getAnalysisExecutor(Class<T> clazz, String analysisExecutorId)\n+      throws AnalysisExecutorException {\n+    return getAnalysisExecutor(clazz, analysisExecutorId, null, null);\n+  }\n+\n+  protected final <T extends OpenCgaAnalysisExecutor> T getAnalysisExecutor(\n+      Class<T> clazz, String analysisExecutorId, List<AnalysisExecutor.Source> source,\n+      List<AnalysisExecutor.Framework> availableFrameworks)\n+      throws AnalysisExecutorException {\n+    Class<? extends T> executorClass = getAnalysisExecutorClass(clazz, analysisExecutorId, source, availableFrameworks);\n+    if (executorClass == null) {\n+      throw AnalysisExecutorException.executorNotFound(clazz, getId(), analysisExecutorId, source, availableFrameworks);\n+    }\n+    try {\n+      T t = executorClass.newInstance();\n+      privateLogger.info(\"Using OpenCgaAnalysisExecutor '\" + t.getId() + \"' : \" + executorClass);\n+\n+      String executorId = t.getId();\n+      if (executorParams == null) {\n+        executorParams = new ObjectMap();\n+      }\n+      executorParams.put(EXECUTOR_ID, executorId);\n+\n+      // Update executor ID\n+      if (arm != null) {\n+        arm.setExecutorInfo(new ExecutorInfo(executorId, executorClass, executorParams, t.getSource(), t.getFramework()));\n+      }\n+      t.setUp(arm, executorParams, outDir);\n+\n+      return t;\n+    } catch (InstantiationException | IllegalAccessException | AnalysisException e) {\n+      throw AnalysisExecutorException.cantInstantiate(executorClass, e);\n+    }\n+  }\n+\n+  protected final void setUpStorageEngineExecutor(String study) throws AnalysisException {\n+    executorParams.put(\"opencgaHome\", opencgaHome);\n+    executorParams.put(\"sessionId\", sessionId);\n+    try {\n+      DataStore dataStore = variantStorageManager.getDataStore(study, sessionId);\n+\n+      executorParams.put(\"storageEngineId\", dataStore.getStorageEngine());\n+      executorParams.put(\"dbName\", dataStore.getDbName());\n+    } catch (CatalogException e) {\n+      throw new AnalysisException(e);\n+    }\n+  }\n+\n+  /**\n+   * This method attempts to load general configuration from OpenCGA installation folder, if not exists then loads JAR configuration.yml.\n+   *\n+   * @throws IOException If any IO problem occurs\n+   */\n+  private void loadConfiguration() throws IOException {\n+    this.configuration = ConfigurationUtils.loadConfiguration(opencgaHome);\n+  }\n+\n+  /**\n+   * This method attempts to load storage configuration from OpenCGA installation folder, if not exists then loads JAR storage-configuration.yml.\n+   *\n+   * @throws IOException If any IO problem occurs\n+   */\n+  private void loadStorageConfiguration() throws IOException {\n+    this.storageConfiguration = ConfigurationUtils.loadStorageConfiguration(opencgaHome);\n+  }\n+\n+\n+  protected final Analyst getAnalyst(String token) throws AnalysisException {\n+    try {\n+      String userId = catalogManager.getUserManager().getUserId(token);\n+      DataResult<User> userQueryResult = catalogManager.getUserManager().get(userId, new QueryOptions(QueryOptions.INCLUDE,\n+          Arrays.asList(UserDBAdaptor.QueryParams.EMAIL.key(), UserDBAdaptor.QueryParams.ORGANIZATION.key())), token);\n+\n+      return new Analyst(userId, userQueryResult.first().getEmail(), userQueryResult.first().getOrganization());\n+    } catch (CatalogException e) {\n+      throw new AnalysisException(e.getMessage(), e);\n+    }\n+  }\n \n }\n",
            "diff_size": 651
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "354",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 148).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "357",
                    "column": "88",
                    "severity": "error",
                    "message": "'>' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "439",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/108/OpenCgaAnalysis.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/108/OpenCgaAnalysis.java\nindex 4c3ac66fe64..bb9c12ffc60 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/108/OpenCgaAnalysis.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/108/OpenCgaAnalysis.java\n@@ -83,7 +83,7 @@ public abstract class OpenCgaAnalysis {\n \n     public final OpenCgaAnalysis setUp(String opencgaHome, CatalogManager catalogManager, StorageEngineFactory engineFactory,\n                                        ObjectMap params, Path outDir, String sessionId) {\n-        VariantStorageManager manager = new VariantStorageManager(catalogManager, engineFactory);\n+    VariantStorageManager manager = new VariantStorageManager(catalogManager, engineFactory);\n         return setUp(opencgaHome, catalogManager, manager, params, outDir, sessionId);\n     }\n \n@@ -351,12 +351,10 @@ public abstract class OpenCgaAnalysis {\n \n             // Prefer the executor that matches better with the source\n             // Prefer the executor that matches better with the framework\n-            List<AnalysisExecutor.Framework> finalAvailableFrameworks =\n-                    availableFrameworks == null ? Collections.emptyList() : availableFrameworks;\n-            List<AnalysisExecutor.Source> finalSourceTypes =\n-                    sourceTypes == null ? Collections.emptyList() : sourceTypes;\n+            List<AnalysisExecutor.Framework> finalAvailableFrameworks = availableFrameworks == null ? Collections.emptyList() : availableFrameworks;\n+            List<AnalysisExecutor.Source> finalSourceTypes = sourceTypes == null ? Collections.emptyList() : sourceTypes;\n \n-            Comparator<Class<? extends T>> comparator = Comparator.<Class<? extends T>>comparingInt(c1 -> {\n+            Comparator<Class<? extends T>> comparator = Comparator.<Class<? extends T>> comparingInt(c1 -> {\n                 AnalysisExecutor annot1 = c1.getAnnotation(AnalysisExecutor.class);\n                 return finalAvailableFrameworks.indexOf(annot1.framework());\n             }).thenComparingInt(c -> {\n@@ -459,4 +457,4 @@ public abstract class OpenCgaAnalysis {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "441",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "441",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 147).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}