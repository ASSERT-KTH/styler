{
    "project_name": "codefollower-H2-Research",
    "error_id": "416",
    "information": {
        "errors": [
            {
                "line": "320",
                "column": "9",
                "severity": "warning",
                "message": "'if' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "\n    private String convertColumnName(String columnName) {\n        if(targetsMySql) {\n            // MySQL column names are not case-sensitive on any platform\n            columnName = StringUtils.toUpperEnglish(columnName);\n        } else if ((storesMixedCase || storesLowerCase) &&",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/416/TableLink.java\nindex ac9f4229bf1..8500b188ec3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/416/TableLink.java\n@@ -317,7 +317,7 @@ public class TableLink extends Table {\n     }\n \n     private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n+        if (targetsMySql) {\n             // MySQL column names are not case-sensitive on any platform\n             columnName = StringUtils.toUpperEnglish(columnName);\n         } else if ((storesMixedCase || storesLowerCase) &&\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "179",
                    "column": "50",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "505",
                    "column": "57",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                },
                {
                    "line": "622",
                    "column": "42",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/416/TableLink.java\nindex ac9f4229bf1..08fe47a1d33 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/416/TableLink.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.table;\n \n import java.sql.DatabaseMetaData;\n@@ -43,675 +44,675 @@ import org.h2.value.ValueTimestamp;\n  */\n public class TableLink extends Table {\n \n-    private static final int MAX_RETRY = 2;\n-\n-    private static final long ROW_COUNT_APPROXIMATION = 100_000;\n-\n-    private final String originalSchema;\n-    private String driver, url, user, password, originalTable, qualifiedTableName;\n-    private TableLinkConnection conn;\n-    private HashMap<String, PreparedStatement> preparedMap = new HashMap<>();\n-    private final ArrayList<Index> indexes = Utils.newSmallArrayList();\n-    private final boolean emitUpdates;\n-    private LinkedIndex linkedIndex;\n-    private DbException connectException;\n-    private boolean storesLowerCase;\n-    private boolean storesMixedCase;\n-    private boolean storesMixedCaseQuoted;\n-    private boolean supportsMixedCaseIdentifiers;\n-    private boolean globalTemporary;\n-    private boolean readOnly;\n-    private boolean targetsMySql;\n-\n-    public TableLink(Schema schema, int id, String name, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n-        super(schema, id, name, false, true);\n-        this.driver = driver;\n-        this.url = url;\n-        this.user = user;\n-        this.password = password;\n-        this.originalSchema = originalSchema;\n-        this.originalTable = originalTable;\n-        this.emitUpdates = emitUpdates;\n-        this.targetsMySql = isMySqlUrl(this.url);\n-        try {\n-            connect();\n-        } catch (DbException e) {\n-            if (!force) {\n-                throw e;\n-            }\n-            Column[] cols = { };\n-            setColumns(cols);\n-            linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols),\n-                    IndexType.createNonUnique(false));\n-            indexes.add(linkedIndex);\n-        }\n-    }\n-\n-    private void connect() {\n-        connectException = null;\n-        for (int retry = 0;; retry++) {\n-            try {\n-                conn = database.getLinkConnection(driver, url, user, password);\n-                synchronized (conn) {\n-                    try {\n-                        readMetaData();\n-                        return;\n-                    } catch (Exception e) {\n-                        // could be SQLException or RuntimeException\n-                        conn.close(true);\n-                        conn = null;\n-                        throw DbException.convert(e);\n-                    }\n-                }\n-            } catch (DbException e) {\n-                if (retry >= MAX_RETRY) {\n-                    connectException = e;\n-                    throw e;\n-                }\n-            }\n-        }\n-    }\n-\n-    private void readMetaData() throws SQLException {\n-        DatabaseMetaData meta = conn.getConnection().getMetaData();\n-        storesLowerCase = meta.storesLowerCaseIdentifiers();\n-        storesMixedCase = meta.storesMixedCaseIdentifiers();\n-        storesMixedCaseQuoted = meta.storesMixedCaseQuotedIdentifiers();\n-        supportsMixedCaseIdentifiers = meta.supportsMixedCaseIdentifiers();\n-        ResultSet rs = meta.getTables(null, originalSchema, originalTable, null);\n-        if (rs.next() && rs.next()) {\n-            throw DbException.get(ErrorCode.SCHEMA_NAME_MUST_MATCH, originalTable);\n-        }\n-        rs.close();\n-        rs = meta.getColumns(null, originalSchema, originalTable, null);\n-        int i = 0;\n-        ArrayList<Column> columnList = Utils.newSmallArrayList();\n-        HashMap<String, Column> columnMap = new HashMap<>();\n-        String catalog = null, schema = null;\n-        while (rs.next()) {\n-            String thisCatalog = rs.getString(\"TABLE_CAT\");\n-            if (catalog == null) {\n-                catalog = thisCatalog;\n-            }\n-            String thisSchema = rs.getString(\"TABLE_SCHEM\");\n-            if (schema == null) {\n-                schema = thisSchema;\n-            }\n-            if (!Objects.equals(catalog, thisCatalog) ||\n-                    !Objects.equals(schema, thisSchema)) {\n-                // if the table exists in multiple schemas or tables,\n-                // use the alternative solution\n-                columnMap.clear();\n-                columnList.clear();\n-                break;\n-            }\n-            String n = rs.getString(\"COLUMN_NAME\");\n-            n = convertColumnName(n);\n-            int sqlType = rs.getInt(\"DATA_TYPE\");\n-            String sqlTypeName = rs.getString(\"TYPE_NAME\");\n-            long precision = rs.getInt(\"COLUMN_SIZE\");\n-            precision = convertPrecision(sqlType, precision);\n-            int scale = rs.getInt(\"DECIMAL_DIGITS\");\n-            scale = convertScale(sqlType, scale);\n-            int type = DataType.convertSQLTypeToValueType(sqlType, sqlTypeName);\n-            Column col = new Column(n, TypeInfo.getTypeInfo(type, precision, scale, null));\n-            col.setTable(this, i++);\n-            columnList.add(col);\n-            columnMap.put(n, col);\n-        }\n-        rs.close();\n-        if (originalTable.indexOf('.') < 0 && !StringUtils.isNullOrEmpty(schema)) {\n-            qualifiedTableName = schema + \".\" + originalTable;\n-        } else {\n-            qualifiedTableName = originalTable;\n-        }\n-        // check if the table is accessible\n-\n-        try (Statement stat = conn.getConnection().createStatement()) {\n-            rs = stat.executeQuery(\"SELECT * FROM \" +\n-                    qualifiedTableName + \" T WHERE 1=0\");\n-            if (columnList.isEmpty()) {\n-                // alternative solution\n-                ResultSetMetaData rsMeta = rs.getMetaData();\n-                for (i = 0; i < rsMeta.getColumnCount();) {\n-                    String n = rsMeta.getColumnName(i + 1);\n-                    n = convertColumnName(n);\n-                    int sqlType = rsMeta.getColumnType(i + 1);\n-                    long precision = rsMeta.getPrecision(i + 1);\n-                    precision = convertPrecision(sqlType, precision);\n-                    int scale = rsMeta.getScale(i + 1);\n-                    scale = convertScale(sqlType, scale);\n-                    int type = DataType.getValueTypeFromResultSet(rsMeta, i + 1);\n-                    Column col = new Column(n, TypeInfo.getTypeInfo(type, precision, scale, null));\n-                    col.setTable(this, i++);\n-                    columnList.add(col);\n-                    columnMap.put(n, col);\n-                }\n-            }\n-            rs.close();\n-        } catch (Exception e) {\n-            throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, e,\n-                    originalTable + \"(\" + e.toString() + \")\");\n+  private static final int MAX_RETRY = 2;\n+\n+  private static final long ROW_COUNT_APPROXIMATION = 100_000;\n+\n+  private final String originalSchema;\n+  private String driver, url, user, password, originalTable, qualifiedTableName;\n+  private TableLinkConnection conn;\n+  private HashMap<String, PreparedStatement> preparedMap = new HashMap<>();\n+  private final ArrayList<Index> indexes = Utils.newSmallArrayList();\n+  private final boolean emitUpdates;\n+  private LinkedIndex linkedIndex;\n+  private DbException connectException;\n+  private boolean storesLowerCase;\n+  private boolean storesMixedCase;\n+  private boolean storesMixedCaseQuoted;\n+  private boolean supportsMixedCaseIdentifiers;\n+  private boolean globalTemporary;\n+  private boolean readOnly;\n+  private boolean targetsMySql;\n+\n+  public TableLink(Schema schema, int id, String name, String driver,\n+                   String url, String user, String password, String originalSchema,\n+                   String originalTable, boolean emitUpdates, boolean force) {\n+    super(schema, id, name, false, true);\n+    this.driver = driver;\n+    this.url = url;\n+    this.user = user;\n+    this.password = password;\n+    this.originalSchema = originalSchema;\n+    this.originalTable = originalTable;\n+    this.emitUpdates = emitUpdates;\n+    this.targetsMySql = isMySqlUrl(this.url);\n+    try {\n+      connect();\n+    } catch (DbException e) {\n+      if (!force) {\n+        throw e;\n+      }\n+      Column[] cols = {};\n+      setColumns(cols);\n+      linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols),\n+          IndexType.createNonUnique(false));\n+      indexes.add(linkedIndex);\n+    }\n+  }\n+\n+  private void connect() {\n+    connectException = null;\n+    for (int retry = 0; ; retry++) {\n+      try {\n+        conn = database.getLinkConnection(driver, url, user, password);\n+        synchronized (conn) {\n+          try {\n+            readMetaData();\n+            return;\n+          } catch (Exception e) {\n+            // could be SQLException or RuntimeException\n+            conn.close(true);\n+            conn = null;\n+            throw DbException.convert(e);\n+          }\n         }\n-        Column[] cols = columnList.toArray(new Column[0]);\n-        setColumns(cols);\n-        int id = getId();\n-        linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols),\n-                IndexType.createNonUnique(false));\n-        indexes.add(linkedIndex);\n-        try {\n-            rs = meta.getPrimaryKeys(null, originalSchema, originalTable);\n-        } catch (Exception e) {\n-            // Some ODBC bridge drivers don't support it:\n-            // some combinations of \"DataDirect SequeLink(R) for JDBC\"\n-            // http://www.datadirect.com/index.ssp\n-            rs = null;\n+      } catch (DbException e) {\n+        if (retry >= MAX_RETRY) {\n+          connectException = e;\n+          throw e;\n         }\n-        String pkName = \"\";\n-        ArrayList<Column> list;\n-        if (rs != null && rs.next()) {\n-            // the problem is, the rows are not sorted by KEY_SEQ\n-            list = Utils.newSmallArrayList();\n-            do {\n-                int idx = rs.getInt(\"KEY_SEQ\");\n-                if (pkName == null) {\n-                    pkName = rs.getString(\"PK_NAME\");\n-                }\n-                while (list.size() < idx) {\n-                    list.add(null);\n-                }\n-                String col = rs.getString(\"COLUMN_NAME\");\n-                col = convertColumnName(col);\n-                Column column = columnMap.get(col);\n-                if (idx == 0) {\n-                    // workaround for a bug in the SQLite JDBC driver\n-                    list.add(column);\n-                } else {\n-                    list.set(idx - 1, column);\n-                }\n-            } while (rs.next());\n-            addIndex(list, IndexType.createPrimaryKey(false, false));\n-            rs.close();\n+      }\n+    }\n+  }\n+\n+  private void readMetaData() throws SQLException {\n+    DatabaseMetaData meta = conn.getConnection().getMetaData();\n+    storesLowerCase = meta.storesLowerCaseIdentifiers();\n+    storesMixedCase = meta.storesMixedCaseIdentifiers();\n+    storesMixedCaseQuoted = meta.storesMixedCaseQuotedIdentifiers();\n+    supportsMixedCaseIdentifiers = meta.supportsMixedCaseIdentifiers();\n+    ResultSet rs = meta.getTables(null, originalSchema, originalTable, null);\n+    if (rs.next() && rs.next()) {\n+      throw DbException.get(ErrorCode.SCHEMA_NAME_MUST_MATCH, originalTable);\n+    }\n+    rs.close();\n+    rs = meta.getColumns(null, originalSchema, originalTable, null);\n+    int i = 0;\n+    ArrayList<Column> columnList = Utils.newSmallArrayList();\n+    HashMap<String, Column> columnMap = new HashMap<>();\n+    String catalog = null, schema = null;\n+    while (rs.next()) {\n+      String thisCatalog = rs.getString(\"TABLE_CAT\");\n+      if (catalog == null) {\n+        catalog = thisCatalog;\n+      }\n+      String thisSchema = rs.getString(\"TABLE_SCHEM\");\n+      if (schema == null) {\n+        schema = thisSchema;\n+      }\n+      if (!Objects.equals(catalog, thisCatalog) ||\n+          !Objects.equals(schema, thisSchema)) {\n+        // if the table exists in multiple schemas or tables,\n+        // use the alternative solution\n+        columnMap.clear();\n+        columnList.clear();\n+        break;\n+      }\n+      String n = rs.getString(\"COLUMN_NAME\");\n+      n = convertColumnName(n);\n+      int sqlType = rs.getInt(\"DATA_TYPE\");\n+      String sqlTypeName = rs.getString(\"TYPE_NAME\");\n+      long precision = rs.getInt(\"COLUMN_SIZE\");\n+      precision = convertPrecision(sqlType, precision);\n+      int scale = rs.getInt(\"DECIMAL_DIGITS\");\n+      scale = convertScale(sqlType, scale);\n+      int type = DataType.convertSQLTypeToValueType(sqlType, sqlTypeName);\n+      Column col = new Column(n, TypeInfo.getTypeInfo(type, precision, scale, null));\n+      col.setTable(this, i++);\n+      columnList.add(col);\n+      columnMap.put(n, col);\n+    }\n+    rs.close();\n+    if (originalTable.indexOf('.') < 0 && !StringUtils.isNullOrEmpty(schema)) {\n+      qualifiedTableName = schema + \".\" + originalTable;\n+    } else {\n+      qualifiedTableName = originalTable;\n+    }\n+    // check if the table is accessible\n+\n+    try (Statement stat = conn.getConnection().createStatement()) {\n+      rs = stat.executeQuery(\"SELECT * FROM \" +\n+          qualifiedTableName + \" T WHERE 1=0\");\n+      if (columnList.isEmpty()) {\n+        // alternative solution\n+        ResultSetMetaData rsMeta = rs.getMetaData();\n+        for (i = 0; i < rsMeta.getColumnCount(); ) {\n+          String n = rsMeta.getColumnName(i + 1);\n+          n = convertColumnName(n);\n+          int sqlType = rsMeta.getColumnType(i + 1);\n+          long precision = rsMeta.getPrecision(i + 1);\n+          precision = convertPrecision(sqlType, precision);\n+          int scale = rsMeta.getScale(i + 1);\n+          scale = convertScale(sqlType, scale);\n+          int type = DataType.getValueTypeFromResultSet(rsMeta, i + 1);\n+          Column col = new Column(n, TypeInfo.getTypeInfo(type, precision, scale, null));\n+          col.setTable(this, i++);\n+          columnList.add(col);\n+          columnMap.put(n, col);\n         }\n-        try {\n-            rs = meta.getIndexInfo(null, originalSchema, originalTable, false, true);\n-        } catch (Exception e) {\n-            // Oracle throws an exception if the table is not found or is a\n-            // SYNONYM\n-            rs = null;\n+      }\n+      rs.close();\n+    } catch (Exception e) {\n+      throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, e,\n+          originalTable + \"(\" + e.toString() + \")\");\n+    }\n+    Column[] cols = columnList.toArray(new Column[0]);\n+    setColumns(cols);\n+    int id = getId();\n+    linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols),\n+        IndexType.createNonUnique(false));\n+    indexes.add(linkedIndex);\n+    try {\n+      rs = meta.getPrimaryKeys(null, originalSchema, originalTable);\n+    } catch (Exception e) {\n+      // Some ODBC bridge drivers don't support it:\n+      // some combinations of \"DataDirect SequeLink(R) for JDBC\"\n+      // http://www.datadirect.com/index.ssp\n+      rs = null;\n+    }\n+    String pkName = \"\";\n+    ArrayList<Column> list;\n+    if (rs != null && rs.next()) {\n+      // the problem is, the rows are not sorted by KEY_SEQ\n+      list = Utils.newSmallArrayList();\n+      do {\n+        int idx = rs.getInt(\"KEY_SEQ\");\n+        if (pkName == null) {\n+          pkName = rs.getString(\"PK_NAME\");\n         }\n-        String indexName = null;\n-        list = Utils.newSmallArrayList();\n-        IndexType indexType = null;\n-        if (rs != null) {\n-            while (rs.next()) {\n-                if (rs.getShort(\"TYPE\") == DatabaseMetaData.tableIndexStatistic) {\n-                    // ignore index statistics\n-                    continue;\n-                }\n-                String newIndex = rs.getString(\"INDEX_NAME\");\n-                if (pkName.equals(newIndex)) {\n-                    continue;\n-                }\n-                if (indexName != null && !indexName.equals(newIndex)) {\n-                    addIndex(list, indexType);\n-                    indexName = null;\n-                }\n-                if (indexName == null) {\n-                    indexName = newIndex;\n-                    list.clear();\n-                }\n-                boolean unique = !rs.getBoolean(\"NON_UNIQUE\");\n-                indexType = unique ? IndexType.createUnique(false, false) :\n-                        IndexType.createNonUnique(false);\n-                String col = rs.getString(\"COLUMN_NAME\");\n-                col = convertColumnName(col);\n-                Column column = columnMap.get(col);\n-                list.add(column);\n-            }\n-            rs.close();\n-        }\n-        if (indexName != null) {\n-            addIndex(list, indexType);\n-        }\n-    }\n-\n-    private static long convertPrecision(int sqlType, long precision) {\n-        // workaround for an Oracle problem:\n-        // for DATE columns, the reported precision is 7\n-        // for DECIMAL columns, the reported precision is 0\n-        switch (sqlType) {\n-        case Types.DECIMAL:\n-        case Types.NUMERIC:\n-            if (precision == 0) {\n-                precision = 65535;\n-            }\n-            break;\n-        case Types.DATE:\n-            precision = Math.max(ValueDate.PRECISION, precision);\n-            break;\n-        case Types.TIMESTAMP:\n-            precision = Math.max(ValueTimestamp.MAXIMUM_PRECISION, precision);\n-            break;\n-        case Types.TIME:\n-            precision = Math.max(ValueTime.MAXIMUM_PRECISION, precision);\n-            break;\n+        while (list.size() < idx) {\n+          list.add(null);\n         }\n-        return precision;\n-    }\n-\n-    private static int convertScale(int sqlType, int scale) {\n-        // workaround for an Oracle problem:\n-        // for DECIMAL columns, the reported precision is -127\n-        switch (sqlType) {\n-        case Types.DECIMAL:\n-        case Types.NUMERIC:\n-            if (scale < 0) {\n-                scale = 32767;\n-            }\n-            break;\n-        }\n-        return scale;\n-    }\n-\n-    private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n-            // MySQL column names are not case-sensitive on any platform\n-            columnName = StringUtils.toUpperEnglish(columnName);\n-        } else if ((storesMixedCase || storesLowerCase) &&\n-                columnName.equals(StringUtils.toLowerEnglish(columnName))) {\n-            columnName = StringUtils.toUpperEnglish(columnName);\n-        } else if (storesMixedCase && !supportsMixedCaseIdentifiers) {\n-            // TeraData\n-            columnName = StringUtils.toUpperEnglish(columnName);\n-        } else if (storesMixedCase && storesMixedCaseQuoted) {\n-            // MS SQL Server (identifiers are case insensitive even if quoted)\n-            columnName = StringUtils.toUpperEnglish(columnName);\n-        }\n-        return columnName;\n-    }\n-\n-    private void addIndex(List<Column> list, IndexType indexType) {\n-        // bind the index to the leading recognized columns in the index\n-        // (null columns might come from a function-based index)\n-        int firstNull = list.indexOf(null);\n-        if (firstNull == 0) {\n-            trace.info(\"Omitting linked index - no recognized columns.\");\n-            return;\n-        } else if (firstNull > 0) {\n-            trace.info(\"Unrecognized columns in linked index. \" +\n-                    \"Registering the index against the leading {0} \" +\n-                    \"recognized columns of {1} total columns.\", firstNull, list.size());\n-            list = list.subList(0, firstNull);\n+        String col = rs.getString(\"COLUMN_NAME\");\n+        col = convertColumnName(col);\n+        Column column = columnMap.get(col);\n+        if (idx == 0) {\n+          // workaround for a bug in the SQLite JDBC driver\n+          list.add(column);\n+        } else {\n+          list.set(idx - 1, column);\n         }\n-        Column[] cols = list.toArray(new Column[0]);\n-        Index index = new LinkedIndex(this, 0, IndexColumn.wrap(cols), indexType);\n-        indexes.add(index);\n-    }\n-\n-    @Override\n-    public String getDropSQL() {\n-        StringBuilder builder = new StringBuilder(\"DROP TABLE IF EXISTS \");\n-        return getSQL(builder).toString();\n-    }\n-\n-    @Override\n-    public String getCreateSQL() {\n-        StringBuilder buff = new StringBuilder(\"CREATE FORCE \");\n-        if (isTemporary()) {\n-            if (globalTemporary) {\n-                buff.append(\"GLOBAL \");\n-            } else {\n-                buff.append(\"LOCAL \");\n-            }\n-            buff.append(\"TEMPORARY \");\n+      } while (rs.next());\n+      addIndex(list, IndexType.createPrimaryKey(false, false));\n+      rs.close();\n+    }\n+    try {\n+      rs = meta.getIndexInfo(null, originalSchema, originalTable, false, true);\n+    } catch (Exception e) {\n+      // Oracle throws an exception if the table is not found or is a\n+      // SYNONYM\n+      rs = null;\n+    }\n+    String indexName = null;\n+    list = Utils.newSmallArrayList();\n+    IndexType indexType = null;\n+    if (rs != null) {\n+      while (rs.next()) {\n+        if (rs.getShort(\"TYPE\") == DatabaseMetaData.tableIndexStatistic) {\n+          // ignore index statistics\n+          continue;\n         }\n-        buff.append(\"LINKED TABLE \");\n-        getSQL(buff);\n-        if (comment != null) {\n-            buff.append(\" COMMENT \");\n-            StringUtils.quoteStringSQL(buff, comment);\n+        String newIndex = rs.getString(\"INDEX_NAME\");\n+        if (pkName.equals(newIndex)) {\n+          continue;\n         }\n-        buff.append('(');\n-        StringUtils.quoteStringSQL(buff, driver).append(\", \");\n-        StringUtils.quoteStringSQL(buff, url).append(\", \");\n-        StringUtils.quoteStringSQL(buff, user).append(\", \");\n-        StringUtils.quoteStringSQL(buff, password).append(\", \");\n-        StringUtils.quoteStringSQL(buff, originalTable).append(')');\n-        if (emitUpdates) {\n-            buff.append(\" EMIT UPDATES\");\n+        if (indexName != null && !indexName.equals(newIndex)) {\n+          addIndex(list, indexType);\n+          indexName = null;\n         }\n-        if (readOnly) {\n-            buff.append(\" READONLY\");\n+        if (indexName == null) {\n+          indexName = newIndex;\n+          list.clear();\n         }\n-        buff.append(\" /*\").append(DbException.HIDE_SQL).append(\"*/\");\n-        return buff.toString();\n-    }\n-\n-    @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n-        throw DbException.getUnsupportedException(\"LINK\");\n-    }\n-\n-    @Override\n-    public boolean lock(Session session, boolean exclusive, boolean forceLockEvenInMvcc) {\n-        // nothing to do\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isLockedExclusively() {\n-        return false;\n-    }\n-\n-    @Override\n-    public Index getScanIndex(Session session) {\n-        return linkedIndex;\n-    }\n-\n-    private void checkReadOnly() {\n-        if (readOnly) {\n-            throw DbException.get(ErrorCode.DATABASE_IS_READ_ONLY);\n+        boolean unique = !rs.getBoolean(\"NON_UNIQUE\");\n+        indexType = unique ? IndexType.createUnique(false, false) :\n+            IndexType.createNonUnique(false);\n+        String col = rs.getString(\"COLUMN_NAME\");\n+        col = convertColumnName(col);\n+        Column column = columnMap.get(col);\n+        list.add(column);\n+      }\n+      rs.close();\n+    }\n+    if (indexName != null) {\n+      addIndex(list, indexType);\n+    }\n+  }\n+\n+  private static long convertPrecision(int sqlType, long precision) {\n+    // workaround for an Oracle problem:\n+    // for DATE columns, the reported precision is 7\n+    // for DECIMAL columns, the reported precision is 0\n+    switch (sqlType) {\n+      case Types.DECIMAL:\n+      case Types.NUMERIC:\n+        if (precision == 0) {\n+          precision = 65535;\n         }\n-    }\n-\n-    @Override\n-    public void removeRow(Session session, Row row) {\n-        checkReadOnly();\n-        getScanIndex(session).remove(session, row);\n-    }\n-\n-    @Override\n-    public void addRow(Session session, Row row) {\n-        checkReadOnly();\n-        getScanIndex(session).add(session, row);\n-    }\n-\n-    @Override\n-    public void close(Session session) {\n-        if (conn != null) {\n-            try {\n-                conn.close(false);\n-            } finally {\n-                conn = null;\n-            }\n+        break;\n+      case Types.DATE:\n+        precision = Math.max(ValueDate.PRECISION, precision);\n+        break;\n+      case Types.TIMESTAMP:\n+        precision = Math.max(ValueTimestamp.MAXIMUM_PRECISION, precision);\n+        break;\n+      case Types.TIME:\n+        precision = Math.max(ValueTime.MAXIMUM_PRECISION, precision);\n+        break;\n+    }\n+    return precision;\n+  }\n+\n+  private static int convertScale(int sqlType, int scale) {\n+    // workaround for an Oracle problem:\n+    // for DECIMAL columns, the reported precision is -127\n+    switch (sqlType) {\n+      case Types.DECIMAL:\n+      case Types.NUMERIC:\n+        if (scale < 0) {\n+          scale = 32767;\n         }\n-    }\n-\n-    @Override\n-    public synchronized long getRowCount(Session session) {\n-        //The foo alias is used to support the PostgreSQL syntax\n-        String sql = \"SELECT COUNT(*) FROM \" + qualifiedTableName + \" as foo\";\n-        try {\n-            PreparedStatement prep = execute(sql, null, false);\n-            ResultSet rs = prep.getResultSet();\n-            rs.next();\n-            long count = rs.getLong(1);\n-            rs.close();\n-            reusePreparedStatement(prep, sql);\n-            return count;\n-        } catch (Exception e) {\n-            throw wrapException(sql, e);\n-        }\n-    }\n-\n-    /**\n-     * Wrap a SQL exception that occurred while accessing a linked table.\n-     *\n-     * @param sql the SQL statement\n-     * @param ex the exception from the remote database\n-     * @return the wrapped exception\n-     */\n-    public static DbException wrapException(String sql, Exception ex) {\n-        SQLException e = DbException.toSQLException(ex);\n-        return DbException.get(ErrorCode.ERROR_ACCESSING_LINKED_TABLE_2,\n-                e, sql, e.toString());\n-    }\n-\n-    public String getQualifiedTable() {\n-        return qualifiedTableName;\n-    }\n-\n-    /**\n-     * Execute a SQL statement using the given parameters. Prepared\n-     * statements are kept in a hash map to avoid re-creating them.\n-     *\n-     * @param sql the SQL statement\n-     * @param params the parameters or null\n-     * @param reusePrepared if the prepared statement can be re-used immediately\n-     * @return the prepared statement, or null if it is re-used\n-     */\n-    public PreparedStatement execute(String sql, ArrayList<Value> params,\n-            boolean reusePrepared) {\n-        if (conn == null) {\n-            throw connectException;\n-        }\n-        for (int retry = 0;; retry++) {\n-            try {\n-                synchronized (conn) {\n-                    PreparedStatement prep = preparedMap.remove(sql);\n-                    if (prep == null) {\n-                        prep = conn.getConnection().prepareStatement(sql);\n-                    }\n-                    if (trace.isDebugEnabled()) {\n-                        StringBuilder builder = new StringBuilder(getName()).append(\":\\n\").append(sql);\n-                        if (params != null && !params.isEmpty()) {\n-                            builder.append(\" {\");\n-                            for (int i = 0, l = params.size(); i < l;) {\n-                                Value v = params.get(i);\n-                                if (i > 0) {\n-                                    builder.append(\", \");\n-                                }\n-                                builder.append(++i).append(\": \");\n-                                v.getSQL(builder);\n-                            }\n-                            builder.append('}');\n-                        }\n-                        builder.append(';');\n-                        trace.debug(builder.toString());\n-                    }\n-                    if (params != null) {\n-                        for (int i = 0, size = params.size(); i < size; i++) {\n-                            Value v = params.get(i);\n-                            v.set(prep, i + 1);\n-                        }\n-                    }\n-                    prep.execute();\n-                    if (reusePrepared) {\n-                        reusePreparedStatement(prep, sql);\n-                        return null;\n-                    }\n-                    return prep;\n-                }\n-            } catch (SQLException e) {\n-                if (retry >= MAX_RETRY) {\n-                    throw DbException.convert(e);\n+        break;\n+    }\n+    return scale;\n+  }\n+\n+  private String convertColumnName(String columnName) {\n+    if (targetsMySql) {\n+      // MySQL column names are not case-sensitive on any platform\n+      columnName = StringUtils.toUpperEnglish(columnName);\n+    } else if ((storesMixedCase || storesLowerCase) &&\n+        columnName.equals(StringUtils.toLowerEnglish(columnName))) {\n+      columnName = StringUtils.toUpperEnglish(columnName);\n+    } else if (storesMixedCase && !supportsMixedCaseIdentifiers) {\n+      // TeraData\n+      columnName = StringUtils.toUpperEnglish(columnName);\n+    } else if (storesMixedCase && storesMixedCaseQuoted) {\n+      // MS SQL Server (identifiers are case insensitive even if quoted)\n+      columnName = StringUtils.toUpperEnglish(columnName);\n+    }\n+    return columnName;\n+  }\n+\n+  private void addIndex(List<Column> list, IndexType indexType) {\n+    // bind the index to the leading recognized columns in the index\n+    // (null columns might come from a function-based index)\n+    int firstNull = list.indexOf(null);\n+    if (firstNull == 0) {\n+      trace.info(\"Omitting linked index - no recognized columns.\");\n+      return;\n+    } else if (firstNull > 0) {\n+      trace.info(\"Unrecognized columns in linked index. \" +\n+          \"Registering the index against the leading {0} \" +\n+          \"recognized columns of {1} total columns.\", firstNull, list.size());\n+      list = list.subList(0, firstNull);\n+    }\n+    Column[] cols = list.toArray(new Column[0]);\n+    Index index = new LinkedIndex(this, 0, IndexColumn.wrap(cols), indexType);\n+    indexes.add(index);\n+  }\n+\n+  @Override\n+  public String getDropSQL() {\n+    StringBuilder builder = new StringBuilder(\"DROP TABLE IF EXISTS \");\n+    return getSQL(builder).toString();\n+  }\n+\n+  @Override\n+  public String getCreateSQL() {\n+    StringBuilder buff = new StringBuilder(\"CREATE FORCE \");\n+    if (isTemporary()) {\n+      if (globalTemporary) {\n+        buff.append(\"GLOBAL \");\n+      } else {\n+        buff.append(\"LOCAL \");\n+      }\n+      buff.append(\"TEMPORARY \");\n+    }\n+    buff.append(\"LINKED TABLE \");\n+    getSQL(buff);\n+    if (comment != null) {\n+      buff.append(\" COMMENT \");\n+      StringUtils.quoteStringSQL(buff, comment);\n+    }\n+    buff.append('(');\n+    StringUtils.quoteStringSQL(buff, driver).append(\", \");\n+    StringUtils.quoteStringSQL(buff, url).append(\", \");\n+    StringUtils.quoteStringSQL(buff, user).append(\", \");\n+    StringUtils.quoteStringSQL(buff, password).append(\", \");\n+    StringUtils.quoteStringSQL(buff, originalTable).append(')');\n+    if (emitUpdates) {\n+      buff.append(\" EMIT UPDATES\");\n+    }\n+    if (readOnly) {\n+      buff.append(\" READONLY\");\n+    }\n+    buff.append(\" /*\").append(DbException.HIDE_SQL).append(\"*/\");\n+    return buff.toString();\n+  }\n+\n+  @Override\n+  public Index addIndex(Session session, String indexName, int indexId,\n+                        IndexColumn[] cols, IndexType indexType, boolean create,\n+                        String indexComment) {\n+    throw DbException.getUnsupportedException(\"LINK\");\n+  }\n+\n+  @Override\n+  public boolean lock(Session session, boolean exclusive, boolean forceLockEvenInMvcc) {\n+    // nothing to do\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean isLockedExclusively() {\n+    return false;\n+  }\n+\n+  @Override\n+  public Index getScanIndex(Session session) {\n+    return linkedIndex;\n+  }\n+\n+  private void checkReadOnly() {\n+    if (readOnly) {\n+      throw DbException.get(ErrorCode.DATABASE_IS_READ_ONLY);\n+    }\n+  }\n+\n+  @Override\n+  public void removeRow(Session session, Row row) {\n+    checkReadOnly();\n+    getScanIndex(session).remove(session, row);\n+  }\n+\n+  @Override\n+  public void addRow(Session session, Row row) {\n+    checkReadOnly();\n+    getScanIndex(session).add(session, row);\n+  }\n+\n+  @Override\n+  public void close(Session session) {\n+    if (conn != null) {\n+      try {\n+        conn.close(false);\n+      } finally {\n+        conn = null;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public synchronized long getRowCount(Session session) {\n+    //The foo alias is used to support the PostgreSQL syntax\n+    String sql = \"SELECT COUNT(*) FROM \" + qualifiedTableName + \" as foo\";\n+    try {\n+      PreparedStatement prep = execute(sql, null, false);\n+      ResultSet rs = prep.getResultSet();\n+      rs.next();\n+      long count = rs.getLong(1);\n+      rs.close();\n+      reusePreparedStatement(prep, sql);\n+      return count;\n+    } catch (Exception e) {\n+      throw wrapException(sql, e);\n+    }\n+  }\n+\n+  /**\n+   * Wrap a SQL exception that occurred while accessing a linked table.\n+   *\n+   * @param sql the SQL statement\n+   * @param ex  the exception from the remote database\n+   * @return the wrapped exception\n+   */\n+  public static DbException wrapException(String sql, Exception ex) {\n+    SQLException e = DbException.toSQLException(ex);\n+    return DbException.get(ErrorCode.ERROR_ACCESSING_LINKED_TABLE_2,\n+        e, sql, e.toString());\n+  }\n+\n+  public String getQualifiedTable() {\n+    return qualifiedTableName;\n+  }\n+\n+  /**\n+   * Execute a SQL statement using the given parameters. Prepared\n+   * statements are kept in a hash map to avoid re-creating them.\n+   *\n+   * @param sql           the SQL statement\n+   * @param params        the parameters or null\n+   * @param reusePrepared if the prepared statement can be re-used immediately\n+   * @return the prepared statement, or null if it is re-used\n+   */\n+  public PreparedStatement execute(String sql, ArrayList<Value> params,\n+                                   boolean reusePrepared) {\n+    if (conn == null) {\n+      throw connectException;\n+    }\n+    for (int retry = 0; ; retry++) {\n+      try {\n+        synchronized (conn) {\n+          PreparedStatement prep = preparedMap.remove(sql);\n+          if (prep == null) {\n+            prep = conn.getConnection().prepareStatement(sql);\n+          }\n+          if (trace.isDebugEnabled()) {\n+            StringBuilder builder = new StringBuilder(getName()).append(\":\\n\").append(sql);\n+            if (params != null && !params.isEmpty()) {\n+              builder.append(\" {\");\n+              for (int i = 0, l = params.size(); i < l; ) {\n+                Value v = params.get(i);\n+                if (i > 0) {\n+                  builder.append(\", \");\n                 }\n-                conn.close(true);\n-                connect();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void unlock(Session s) {\n-        // nothing to do\n-    }\n-\n-    @Override\n-    public void checkRename() {\n-        // ok\n-    }\n-\n-    @Override\n-    public void checkSupportAlter() {\n-        throw DbException.getUnsupportedException(\"LINK\");\n-    }\n-\n-    @Override\n-    public void truncate(Session session) {\n-        throw DbException.getUnsupportedException(\"LINK\");\n-    }\n-\n-    @Override\n-    public boolean canGetRowCount() {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean canDrop() {\n-        return true;\n-    }\n-\n-    @Override\n-    public TableType getTableType() {\n-        return TableType.TABLE_LINK;\n-    }\n-\n-    @Override\n-    public void removeChildrenAndResources(Session session) {\n-        super.removeChildrenAndResources(session);\n-        close(session);\n-        database.removeMeta(session, getId());\n-        driver = null;\n-        url = user = password = originalTable = null;\n-        preparedMap = null;\n-        invalidate();\n-    }\n-\n-    public boolean isOracle() {\n-        return url.startsWith(\"jdbc:oracle:\");\n-    }\n-\n-    private static boolean isMySqlUrl(String url) {\n-        return url.startsWith(\"jdbc:mysql:\")\n-                || url.startsWith(\"jdbc:mariadb:\");\n-    }\n-\n-    @Override\n-    public ArrayList<Index> getIndexes() {\n-        return indexes;\n-    }\n-\n-    @Override\n-    public long getMaxDataModificationId() {\n-        // data may have been modified externally\n-        return Long.MAX_VALUE;\n-    }\n-\n-    @Override\n-    public Index getUniqueIndex() {\n-        for (Index idx : indexes) {\n-            if (idx.getIndexType().isUnique()) {\n-                return idx;\n+                builder.append(++i).append(\": \");\n+                v.getSQL(builder);\n+              }\n+              builder.append('}');\n             }\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public void updateRows(Prepared prepared, Session session, RowList rows) {\n-        boolean deleteInsert;\n-        checkReadOnly();\n-        if (emitUpdates) {\n-            for (rows.reset(); rows.hasNext();) {\n-                prepared.checkCanceled();\n-                Row oldRow = rows.next();\n-                Row newRow = rows.next();\n-                linkedIndex.update(oldRow, newRow);\n-                session.log(this, UndoLogRecord.DELETE, oldRow);\n-                session.log(this, UndoLogRecord.INSERT, newRow);\n+            builder.append(';');\n+            trace.debug(builder.toString());\n+          }\n+          if (params != null) {\n+            for (int i = 0, size = params.size(); i < size; i++) {\n+              Value v = params.get(i);\n+              v.set(prep, i + 1);\n             }\n-            deleteInsert = false;\n-        } else {\n-            deleteInsert = true;\n-        }\n-        if (deleteInsert) {\n-            super.updateRows(prepared, session, rows);\n+          }\n+          prep.execute();\n+          if (reusePrepared) {\n+            reusePreparedStatement(prep, sql);\n+            return null;\n+          }\n+          return prep;\n         }\n-    }\n-\n-    public void setGlobalTemporary(boolean globalTemporary) {\n-        this.globalTemporary = globalTemporary;\n-    }\n-\n-    public void setReadOnly(boolean readOnly) {\n-        this.readOnly = readOnly;\n-    }\n-\n-    @Override\n-    public long getRowCountApproximation() {\n-        return ROW_COUNT_APPROXIMATION;\n-    }\n-\n-    @Override\n-    public long getDiskSpaceUsed() {\n-        return 0;\n-    }\n-\n-    /**\n-     * Add this prepared statement to the list of cached statements.\n-     *\n-     * @param prep the prepared statement\n-     * @param sql the SQL statement\n-     */\n-    public void reusePreparedStatement(PreparedStatement prep, String sql) {\n-        synchronized (conn) {\n-            preparedMap.put(sql, prep);\n+      } catch (SQLException e) {\n+        if (retry >= MAX_RETRY) {\n+          throw DbException.convert(e);\n         }\n-    }\n-\n-    @Override\n-    public boolean isDeterministic() {\n-        return false;\n-    }\n-\n-    /**\n-     * Linked tables don't know if they are readonly. This overwrites\n-     * the default handling.\n-     */\n-    @Override\n-    public void checkWritingAllowed() {\n-        // only the target database can verify this\n-    }\n-\n-    /**\n-     * Convert the values if required. Default values are not set (kept as\n-     * null).\n-     *\n-     * @param session the session\n-     * @param row the row\n-     */\n-    @Override\n-    public void validateConvertUpdateSequence(Session session, Row row) {\n-        for (int i = 0; i < columns.length; i++) {\n-            Value value = row.getValue(i);\n-            if (value != null) {\n-                // null means use the default value\n-                Column column = columns[i];\n-                Value v2 = column.validateConvertUpdateSequence(session, value);\n-                if (v2 != value) {\n-                    row.setValue(i, v2);\n-                }\n-            }\n+        conn.close(true);\n+        connect();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void unlock(Session s) {\n+    // nothing to do\n+  }\n+\n+  @Override\n+  public void checkRename() {\n+    // ok\n+  }\n+\n+  @Override\n+  public void checkSupportAlter() {\n+    throw DbException.getUnsupportedException(\"LINK\");\n+  }\n+\n+  @Override\n+  public void truncate(Session session) {\n+    throw DbException.getUnsupportedException(\"LINK\");\n+  }\n+\n+  @Override\n+  public boolean canGetRowCount() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean canDrop() {\n+    return true;\n+  }\n+\n+  @Override\n+  public TableType getTableType() {\n+    return TableType.TABLE_LINK;\n+  }\n+\n+  @Override\n+  public void removeChildrenAndResources(Session session) {\n+    super.removeChildrenAndResources(session);\n+    close(session);\n+    database.removeMeta(session, getId());\n+    driver = null;\n+    url = user = password = originalTable = null;\n+    preparedMap = null;\n+    invalidate();\n+  }\n+\n+  public boolean isOracle() {\n+    return url.startsWith(\"jdbc:oracle:\");\n+  }\n+\n+  private static boolean isMySqlUrl(String url) {\n+    return url.startsWith(\"jdbc:mysql:\")\n+        || url.startsWith(\"jdbc:mariadb:\");\n+  }\n+\n+  @Override\n+  public ArrayList<Index> getIndexes() {\n+    return indexes;\n+  }\n+\n+  @Override\n+  public long getMaxDataModificationId() {\n+    // data may have been modified externally\n+    return Long.MAX_VALUE;\n+  }\n+\n+  @Override\n+  public Index getUniqueIndex() {\n+    for (Index idx : indexes) {\n+      if (idx.getIndexType().isUnique()) {\n+        return idx;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public void updateRows(Prepared prepared, Session session, RowList rows) {\n+    boolean deleteInsert;\n+    checkReadOnly();\n+    if (emitUpdates) {\n+      for (rows.reset(); rows.hasNext(); ) {\n+        prepared.checkCanceled();\n+        Row oldRow = rows.next();\n+        Row newRow = rows.next();\n+        linkedIndex.update(oldRow, newRow);\n+        session.log(this, UndoLogRecord.DELETE, oldRow);\n+        session.log(this, UndoLogRecord.INSERT, newRow);\n+      }\n+      deleteInsert = false;\n+    } else {\n+      deleteInsert = true;\n+    }\n+    if (deleteInsert) {\n+      super.updateRows(prepared, session, rows);\n+    }\n+  }\n+\n+  public void setGlobalTemporary(boolean globalTemporary) {\n+    this.globalTemporary = globalTemporary;\n+  }\n+\n+  public void setReadOnly(boolean readOnly) {\n+    this.readOnly = readOnly;\n+  }\n+\n+  @Override\n+  public long getRowCountApproximation() {\n+    return ROW_COUNT_APPROXIMATION;\n+  }\n+\n+  @Override\n+  public long getDiskSpaceUsed() {\n+    return 0;\n+  }\n+\n+  /**\n+   * Add this prepared statement to the list of cached statements.\n+   *\n+   * @param prep the prepared statement\n+   * @param sql  the SQL statement\n+   */\n+  public void reusePreparedStatement(PreparedStatement prep, String sql) {\n+    synchronized (conn) {\n+      preparedMap.put(sql, prep);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isDeterministic() {\n+    return false;\n+  }\n+\n+  /**\n+   * Linked tables don't know if they are readonly. This overwrites\n+   * the default handling.\n+   */\n+  @Override\n+  public void checkWritingAllowed() {\n+    // only the target database can verify this\n+  }\n+\n+  /**\n+   * Convert the values if required. Default values are not set (kept as\n+   * null).\n+   *\n+   * @param session the session\n+   * @param row     the row\n+   */\n+  @Override\n+  public void validateConvertUpdateSequence(Session session, Row row) {\n+    for (int i = 0; i < columns.length; i++) {\n+      Value value = row.getValue(i);\n+      if (value != null) {\n+        // null means use the default value\n+        Column column = columns[i];\n+        Value v2 = column.validateConvertUpdateSequence(session, value);\n+        if (v2 != value) {\n+          row.setValue(i, v2);\n         }\n-    }\n-\n-    /**\n-     * Get or generate a default value for the given column. Default values are\n-     * not set (kept as null).\n-     *\n-     * @param session the session\n-     * @param column the column\n-     * @return the value\n-     */\n-    @Override\n-    public Value getDefaultValue(Session session, Column column) {\n-        return null;\n-    }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Get or generate a default value for the given column. Default values are\n+   * not set (kept as null).\n+   *\n+   * @param session the session\n+   * @param column  the column\n+   * @return the value\n+   */\n+  @Override\n+  public Value getDefaultValue(Session session, Column column) {\n+    return null;\n+  }\n \n }\n",
            "diff_size": 967
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/416/TableLink.java\nindex ac9f4229bf1..9bd79b78267 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/416/TableLink.java\n@@ -16,7 +16,6 @@ import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Objects;\n-\n import org.h2.api.ErrorCode;\n import org.h2.command.Prepared;\n import org.h2.engine.Session;\n@@ -41,16 +40,16 @@ import org.h2.value.ValueTimestamp;\n  * A linked table contains connection information for a table accessible by\n  * JDBC. The table may be stored in a different database.\n  */\n+\n+\n public class TableLink extends Table {\n \n     private static final int MAX_RETRY = 2;\n-\n     private static final long ROW_COUNT_APPROXIMATION = 100_000;\n-\n     private final String originalSchema;\n     private String driver, url, user, password, originalTable, qualifiedTableName;\n     private TableLinkConnection conn;\n-    private HashMap<String, PreparedStatement> preparedMap = new HashMap<>();\n+    private HashMap<String, PreparedStatement> preparedMap = new HashMap< >();\n     private final ArrayList<Index> indexes = Utils.newSmallArrayList();\n     private final boolean emitUpdates;\n     private LinkedIndex linkedIndex;\n@@ -63,9 +62,7 @@ public class TableLink extends Table {\n     private boolean readOnly;\n     private boolean targetsMySql;\n \n-    public TableLink(Schema schema, int id, String name, String driver,\n-            String url, String user, String password, String originalSchema,\n-            String originalTable, boolean emitUpdates, boolean force) {\n+    public TableLink(Schema schema, int id, String name, String driver, String url, String user, String password, String originalSchema, String originalTable, boolean emitUpdates, boolean force) {\n         super(schema, id, name, false, true);\n         this.driver = driver;\n         this.url = url;\n@@ -81,10 +78,9 @@ public class TableLink extends Table {\n             if (!force) {\n                 throw e;\n             }\n-            Column[] cols = { };\n+            Column[] cols = {};\n             setColumns(cols);\n-            linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols),\n-                    IndexType.createNonUnique(false));\n+            linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols), IndexType.createNonUnique(false));\n             indexes.add(linkedIndex);\n         }\n     }\n@@ -128,7 +124,7 @@ public class TableLink extends Table {\n         rs = meta.getColumns(null, originalSchema, originalTable, null);\n         int i = 0;\n         ArrayList<Column> columnList = Utils.newSmallArrayList();\n-        HashMap<String, Column> columnMap = new HashMap<>();\n+        HashMap<String, Column> columnMap = new HashMap< >();\n         String catalog = null, schema = null;\n         while (rs.next()) {\n             String thisCatalog = rs.getString(\"TABLE_CAT\");\n@@ -139,8 +135,7 @@ public class TableLink extends Table {\n             if (schema == null) {\n                 schema = thisSchema;\n             }\n-            if (!Objects.equals(catalog, thisCatalog) ||\n-                    !Objects.equals(schema, thisSchema)) {\n+            if (!Objects.equals(catalog, thisCatalog) || !Objects.equals(schema, thisSchema)) {\n                 // if the table exists in multiple schemas or tables,\n                 // use the alternative solution\n                 columnMap.clear();\n@@ -168,10 +163,8 @@ public class TableLink extends Table {\n             qualifiedTableName = originalTable;\n         }\n         // check if the table is accessible\n-\n         try (Statement stat = conn.getConnection().createStatement()) {\n-            rs = stat.executeQuery(\"SELECT * FROM \" +\n-                    qualifiedTableName + \" T WHERE 1=0\");\n+            rs = stat.executeQuery(\"SELECT * FROM \" + qualifiedTableName + \" T WHERE 1=0\");\n             if (columnList.isEmpty()) {\n                 // alternative solution\n                 ResultSetMetaData rsMeta = rs.getMetaData();\n@@ -192,14 +185,13 @@ public class TableLink extends Table {\n             }\n             rs.close();\n         } catch (Exception e) {\n-            throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, e,\n-                    originalTable + \"(\" + e.toString() + \")\");\n+            throw DbException.get(ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1, e, originalTable + \"(\"\n+            + e.toString() + \")\");\n         }\n         Column[] cols = columnList.toArray(new Column[0]);\n         setColumns(cols);\n         int id = getId();\n-        linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols),\n-                IndexType.createNonUnique(false));\n+        linkedIndex = new LinkedIndex(this, id, IndexColumn.wrap(cols), IndexType.createNonUnique(false));\n         indexes.add(linkedIndex);\n         try {\n             rs = meta.getPrimaryKeys(null, originalSchema, originalTable);\n@@ -264,8 +256,7 @@ public class TableLink extends Table {\n                     list.clear();\n                 }\n                 boolean unique = !rs.getBoolean(\"NON_UNIQUE\");\n-                indexType = unique ? IndexType.createUnique(false, false) :\n-                        IndexType.createNonUnique(false);\n+                indexType = unique ? IndexType.createUnique(false, false) : IndexType.createNonUnique(false);\n                 String col = rs.getString(\"COLUMN_NAME\");\n                 col = convertColumnName(col);\n                 Column column = columnMap.get(col);\n@@ -317,19 +308,18 @@ public class TableLink extends Table {\n     }\n \n     private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n+        if (targetsMySql) {\n             // MySQL column names are not case-sensitive on any platform\n             columnName = StringUtils.toUpperEnglish(columnName);\n-        } else if ((storesMixedCase || storesLowerCase) &&\n-                columnName.equals(StringUtils.toLowerEnglish(columnName))) {\n+        } else if ((storesMixedCase || storesLowerCase) && columnName.equals(StringUtils.toLowerEnglish(columnName))) {\n             columnName = StringUtils.toUpperEnglish(columnName);\n-        } else if (storesMixedCase && !supportsMixedCaseIdentifiers) {\n+                                                        } else if (storesMixedCase && !supportsMixedCaseIdentifiers) {\n             // TeraData\n-            columnName = StringUtils.toUpperEnglish(columnName);\n+                   columnName = StringUtils.toUpperEnglish(columnName);\n         } else if (storesMixedCase && storesMixedCaseQuoted) {\n             // MS SQL Server (identifiers are case insensitive even if quoted)\n-            columnName = StringUtils.toUpperEnglish(columnName);\n-        }\n+                                                                   columnName = StringUtils.toUpperEnglish(columnName);\n+                                                               }\n         return columnName;\n     }\n \n@@ -341,9 +331,7 @@ public class TableLink extends Table {\n             trace.info(\"Omitting linked index - no recognized columns.\");\n             return;\n         } else if (firstNull > 0) {\n-            trace.info(\"Unrecognized columns in linked index. \" +\n-                    \"Registering the index against the leading {0} \" +\n-                    \"recognized columns of {1} total columns.\", firstNull, list.size());\n+            trace.info(\"Unrecognized columns in linked index. \" + \"Registering the index against the leading {0} \" + \"recognized columns of {1} total columns.\", firstNull, list.size());\n             list = list.subList(0, firstNull);\n         }\n         Column[] cols = list.toArray(new Column[0]);\n@@ -391,9 +379,7 @@ public class TableLink extends Table {\n     }\n \n     @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n+    public Index addIndex(Session session, String indexName, int indexId, IndexColumn[] cols, IndexType indexType, boolean create, String indexComment) {\n         throw DbException.getUnsupportedException(\"LINK\");\n     }\n \n@@ -466,12 +452,14 @@ public class TableLink extends Table {\n      * @param ex the exception from the remote database\n      * @return the wrapped exception\n      */\n+\n+\n     public static DbException wrapException(String sql, Exception ex) {\n         SQLException e = DbException.toSQLException(ex);\n-        return DbException.get(ErrorCode.ERROR_ACCESSING_LINKED_TABLE_2,\n-                e, sql, e.toString());\n+        return DbException.get(ErrorCode.ERROR_ACCESSING_LINKED_TABLE_2, e, sql, e.toString());\n     }\n \n+\n     public String getQualifiedTable() {\n         return qualifiedTableName;\n     }\n@@ -485,8 +473,9 @@ public class TableLink extends Table {\n      * @param reusePrepared if the prepared statement can be re-used immediately\n      * @return the prepared statement, or null if it is re-used\n      */\n-    public PreparedStatement execute(String sql, ArrayList<Value> params,\n-            boolean reusePrepared) {\n+\n+\n+    public PreparedStatement execute(String sql, ArrayList<Value> params, boolean reusePrepared) {\n         if (conn == null) {\n             throw connectException;\n         }\n@@ -540,11 +529,13 @@ public class TableLink extends Table {\n     @Override\n     public void unlock(Session s) {\n         // nothing to do\n+\n     }\n \n     @Override\n     public void checkRename() {\n         // ok\n+\n     }\n \n     @Override\n@@ -583,13 +574,13 @@ public class TableLink extends Table {\n         invalidate();\n     }\n \n+\n     public boolean isOracle() {\n         return url.startsWith(\"jdbc:oracle:\");\n     }\n \n     private static boolean isMySqlUrl(String url) {\n-        return url.startsWith(\"jdbc:mysql:\")\n-                || url.startsWith(\"jdbc:mariadb:\");\n+        return url.startsWith(\"jdbc:mysql:\") || url.startsWith(\"jdbc:mariadb:\");\n     }\n \n     @Override\n@@ -635,10 +626,12 @@ public class TableLink extends Table {\n         }\n     }\n \n+\n     public void setGlobalTemporary(boolean globalTemporary) {\n         this.globalTemporary = globalTemporary;\n     }\n \n+\n     public void setReadOnly(boolean readOnly) {\n         this.readOnly = readOnly;\n     }\n@@ -659,6 +652,8 @@ public class TableLink extends Table {\n      * @param prep the prepared statement\n      * @param sql the SQL statement\n      */\n+\n+\n     public void reusePreparedStatement(PreparedStatement prep, String sql) {\n         synchronized (conn) {\n             preparedMap.put(sql, prep);\n@@ -674,9 +669,11 @@ public class TableLink extends Table {\n      * Linked tables don't know if they are readonly. This overwrites\n      * the default handling.\n      */\n+\n     @Override\n     public void checkWritingAllowed() {\n         // only the target database can verify this\n+\n     }\n \n     /**\n@@ -686,6 +683,7 @@ public class TableLink extends Table {\n      * @param session the session\n      * @param row the row\n      */\n+\n     @Override\n     public void validateConvertUpdateSequence(Session session, Row row) {\n         for (int i = 0; i < columns.length; i++) {\n@@ -709,9 +707,10 @@ public class TableLink extends Table {\n      * @param column the column\n      * @return the value\n      */\n+\n     @Override\n     public Value getDefaultValue(Session session, Column column) {\n         return null;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 59
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/416/TableLink.java\nindex ac9f4229bf1..8500b188ec3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/416/TableLink.java\n@@ -317,7 +317,7 @@ public class TableLink extends Table {\n     }\n \n     private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n+        if (targetsMySql) {\n             // MySQL column names are not case-sensitive on any platform\n             columnName = StringUtils.toUpperEnglish(columnName);\n         } else if ((storesMixedCase || storesLowerCase) &&\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/416/TableLink.java\nindex ac9f4229bf1..8500b188ec3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/416/TableLink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/416/TableLink.java\n@@ -317,7 +317,7 @@ public class TableLink extends Table {\n     }\n \n     private String convertColumnName(String columnName) {\n-        if(targetsMySql) {\n+        if (targetsMySql) {\n             // MySQL column names are not case-sensitive on any platform\n             columnName = StringUtils.toUpperEnglish(columnName);\n         } else if ((storesMixedCase || storesLowerCase) &&\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize"
    ]
}