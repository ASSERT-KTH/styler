{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "158",
    "information": {
        "errors": [
            {
                "line": "56",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "    extends ExprTokenizer\n{\n\tprivate final ExprContextStatic statEnv;\n\tprivate final HashMap<String, AxisExpr> axisTable;\n\tprivate final HashMap<String, Function> functionTable;\n\tprivate final HashMap<String, Relation> relationTable;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "57",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/158/ExprParser.java\nindex 2c7d53b6fed..1a97da540d0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/158/ExprParser.java\n@@ -53,7 +53,7 @@ import org.genxdm.xpath.v10.extend.ConvertibleNodeSetExpr;\n final class ExprParser \r\n     extends ExprTokenizer\r\n {\r\n-\tprivate final ExprContextStatic statEnv;\r\n+private final ExprContextStatic statEnv;\r\n \tprivate final HashMap<String, AxisExpr> axisTable;\r\n \tprivate final HashMap<String, Function> functionTable;\r\n \tprivate final HashMap<String, Relation> relationTable;\r\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/158/ExprParser.java\nindex 2c7d53b6fed..a700fd44f2f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/158/ExprParser.java\n@@ -3,7 +3,7 @@\n  * license details\r\n  * Portions copyright (c) 2002, Bill Lindsey : see copying.txt for license\r\n  * details\r\n- * \r\n+ *\r\n  * Portions copyright (c) 2009-2011 TIBCO Software Inc.\r\n  *\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n@@ -18,6 +18,7 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n+\r\n package org.genxdm.processor.xpath.v10.expressions;\r\n \r\n import java.lang.reflect.Array;\r\n@@ -50,791 +51,709 @@ import org.genxdm.xpath.v10.extend.ConvertibleNodeSetExpr;\n /**\r\n  * XPath expression parser / compiler extends the lexer ExprTokenizer\r\n  */\r\n-final class ExprParser \r\n-    extends ExprTokenizer\r\n-{\r\n-\tprivate final ExprContextStatic statEnv;\r\n-\tprivate final HashMap<String, AxisExpr> axisTable;\r\n-\tprivate final HashMap<String, Function> functionTable;\r\n-\tprivate final HashMap<String, Relation> relationTable;\r\n-\r\n-\tpublic ExprParser(final String expr, final ExprContextStatic statEnv, final HashMap<String, AxisExpr> axisTable, final HashMap<String, Function> functionTable,\r\n-\t\t\tfinal HashMap<String, Relation> relationTable)\r\n-\t{\r\n-\t\tsuper(expr);\r\n-\t\tthis.statEnv = statEnv;\r\n-\t\tthis.axisTable = axisTable;\r\n-\t\tthis.functionTable = functionTable;\r\n-\t\tthis.relationTable = relationTable;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// returns an expanded Name from the qName in\r\n-\t// currentTokenValue\r\n-\t//\r\n-\tprivate QName expandName() throws ExprParseException\r\n-\t{\r\n-\t\tfinal int index = currentTokenValue.indexOf(':');\r\n-\t\tfinal String prefix = (index == -1) ? XMLConstants.DEFAULT_NS_PREFIX : currentTokenValue.substring(0, index);\r\n-\t\tfinal String localName = currentTokenValue.substring(index + 1);\r\n-\t\tif (prefix.length() > 0)\r\n-\t\t{\r\n-\t\t\tfinal String ns = statEnv.getNamespace(prefix); // returns null if not bound.\r\n-\r\n-\t\t\tif (ns != null)\r\n-\t\t\t{\r\n-\t\t\t\treturn new QName(ns, localName, prefix);\r\n-\t\t\t}\r\n-\t\t\telse\r\n-\t\t\t{\r\n-\t\t\t\tthrow new ExprParseException(\"prefix '\" + prefix + \"' is not bound to a namespace.\");\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\t// In XPath 1.0, the default namespace for unqualified QName(s) is the namespace\r\n-\t\t\t// with a zero-length name. Note that in XPath 2.0 we would distinguish between\r\n-\t\t\t// function names, element and type names, and even variable names.\r\n-\t\t\treturn new QName(XMLConstants.NULL_NS_URI, localName, prefix);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t//\r\n-\t// gets the Namespace URI associated with the prefix in\r\n-\t// currentTokenValue\r\n-\t//\r\n-\tprivate String expandPrefix() throws ExprParseException\r\n-\t{\r\n-\t\tString ns = statEnv.getNamespace(currentTokenValue);\r\n-\t\tif (ns == null)\r\n-\t\t{\r\n-\t\t\tthrow new ExprParseException(\"undefined prefix\");\r\n-\t\t}\r\n-\t\treturn ns;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// Checks to ensure that the CurrentToken is ')', then\r\n-\t// lexes the next\r\n-\t//\r\n-\tprivate final void expectRpar() throws ExprParseException\r\n-\t{\r\n-\t\tif (currentToken != TOK_RPAR)\r\n-\t\t{\r\n-\t\t\tthrow new ExprParseException(\"expected )\");\r\n-\t\t}\r\n-\t\tnext();\r\n-\t}\r\n-\r\n-\t//\r\n-\t// Checks to ensure that the currentToken is ']', then\r\n-\t// lexes the next\r\n-\t//\r\n-\tprivate final void expectRsqb() throws ExprParseException\r\n-\t{\r\n-\t\tif (currentToken != TOK_RSQB)\r\n-\t\t{\r\n-\t\t\tthrow new ExprParseException(\"expected ]\");\r\n-\t\t}\r\n-\t\tnext();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * A ConvertibleExpr allows for the casting of one type to another for the purpose of making a comparison\r\n-\t */\r\n-\tConvertibleExprImpl makeRelationalExpr(final Relation rel, final ConvertibleExpr e1, final ConvertibleExpr e2) throws ExprParseException\r\n-\t{\r\n-\t\t// OPT: have some more expressions for non-variant cases\r\n-\t\tif (e1 instanceof NodeSetExpr || e2 instanceof NodeSetExpr || e1 instanceof VariantExpr || e2 instanceof VariantExpr)\r\n-\t\t{\r\n-\t\t\treturn new VariantRelationalExpr(rel, e1.makeVariantExpr(statEnv), e2.makeVariantExpr(statEnv));\r\n-\t\t}\r\n-\r\n-\t\tif (rel instanceof NumericRelation)\r\n-\t\t{\r\n-\t\t\treturn new NumberRelationalExpr(rel, e1.makeNumberExpr(statEnv), e2.makeNumberExpr(statEnv));\r\n-\t\t}\r\n-\r\n-\t\tif (e1 instanceof BooleanExpr || e2 instanceof BooleanExpr)\r\n-\t\t{\r\n-\t\t\treturn new BooleanRelationalExpr(rel, e1.makeBooleanExpr(statEnv), e2.makeBooleanExpr(statEnv));\r\n-\t\t}\r\n-\r\n-\t\tif (e1 instanceof NumberExpr || e2 instanceof NumberExpr)\r\n-\t\t{\r\n-\t\t\treturn new NumberRelationalExpr(rel, e1.makeNumberExpr(statEnv), e2.makeNumberExpr(statEnv));\r\n-\t\t}\r\n-\r\n-\t\treturn new StringRelationalExpr(rel, e1.makeStringExpr(statEnv), e2.makeStringExpr(statEnv));\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #25 AdditiveExpr\r\n-\t//\r\n-\tprivate ConvertibleExpr parseAdditiveExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseMultiplicativeExpr();\r\n-\t\tloop: for (;;)\r\n-\t\t{\r\n-\t\t\tswitch (currentToken)\r\n-\t\t\t{\r\n-\t\t\t\tcase TOK_PLUS:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new AddExpr(expr.makeNumberExpr(statEnv), parseMultiplicativeExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_MINUS:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new SubtractExpr(expr.makeNumberExpr(statEnv), parseMultiplicativeExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\tbreak loop;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #22\r\n-\t//\r\n-\tprivate ConvertibleExpr parseAndExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseEqualityExpr();\r\n-\t\twhile (currentToken == TOK_AND)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new AndExpr(expr.makeBooleanExpr(statEnv), parseEqualityExpr().makeBooleanExpr(statEnv));\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// parse the zero or more arguments to a function call\r\n-\t// XPath Productions #16 FunctionCall, and 17 Argument\r\n-\t// Production #17 (Argument) is an Expr (Production #14)\r\n-\t// which is in turn an OrExpr (Production #21)\r\n-\t//\r\n-\t// We return the Arguments as an array of ConvertibleExprs\r\n-\t//\r\n-\tprivate ConvertibleExpr[] parseArgs() throws ExprParseException\r\n-\t{\r\n-\t\tif (currentToken == TOK_RPAR)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn (ConvertibleExprImpl[])Array.newInstance(ConvertibleExprImpl.class, 0);\r\n-\t\t}\r\n-\t\tConvertibleExpr[] args = (ConvertibleExpr[])Array.newInstance(ConvertibleExprImpl.class, 1);\r\n-\t\tfor (;;)\r\n-\t\t{\r\n-\t\t\targs[args.length - 1] = parseOrExpr();\r\n-\t\t\tif (currentToken != TOK_COMMA)\r\n-\t\t\t{\r\n-\t\t\t\tbreak;\r\n-\t\t\t}\r\n-\t\t\tnext();\r\n-\t\t\tConvertibleExpr[] oldArgs = args;\r\n-\t\t\targs = (ConvertibleExprImpl[])Array.newInstance(ConvertibleExprImpl.class, oldArgs.length + 1);\r\n-\t\t\tSystem.arraycopy(oldArgs, 0, args, 0, oldArgs.length);\r\n-\t\t}\r\n-\t\texpectRpar(); // check currentToken to ensure it's \")\"\r\n-\t\treturn args;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #23\r\n-\t//\r\n-\tprivate ConvertibleExpr parseEqualityExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseRelationalExpr();\r\n-\t\tloop: for (;;)\r\n-\t\t{\r\n-\t\t\tswitch (currentToken)\r\n-\t\t\t{\r\n-\t\t\t\tcase TOK_EQUALS:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\"=\"), expr, parseRelationalExpr());\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_NOT_EQUALS:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\"!=\"), expr, parseRelationalExpr());\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\tbreak loop;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\tpublic ConvertibleExpr parseExpr() throws ExprParseException\r\n-\t{\r\n-\t\tnext();\r\n-\t\tConvertibleExpr expr = parseOrExpr();\r\n-\t\tif (currentToken != TOK_EOF)\r\n-\t\t{\r\n-\t\t\tthrow new ExprParseException(\"unexpected token\");\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #26\r\n-\t//\r\n-\tprivate ConvertibleExpr parseMultiplicativeExpr() throws ExprParseException\r\n-\t{\r\n-\t\t// get the first part\r\n-\t\tConvertibleExpr expr = parseUnaryExpr();\r\n-\t\tloop: for (;;)\r\n-\t\t{\r\n-\t\t\tswitch (currentToken)\r\n-\t\t\t{\r\n-\t\t\t\tcase TOK_DIV:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new DivideExpr(expr.makeNumberExpr(statEnv), parseUnaryExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_MOD:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new ModuloExpr(expr.makeNumberExpr(statEnv), parseUnaryExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_MULTIPLY:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new MultiplyExpr(expr.makeNumberExpr(statEnv), parseUnaryExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\tbreak loop;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #7\r\n-\t//\r\n-\t// Compile a node test for an XPath pattern step,\r\n-\t// up to, but not including any predicates\r\n-\t//\r\n-\t// WDL do not return null, even if the test is vacuous (e.g. \"node()\"\r\n-\t//\r\n-\t// TODO: Here we need the principal node kind.\r\n-\tprivate PathPatternBase parseNodeTest(final NodeKind principalNodeKind) throws ExprParseException\r\n-\t{\r\n-\t\tPathPatternBase nodeTest;\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_QNAME:\r\n-\t\t\t{\r\n-\t\t\t\tfinal QName name = expandName();\r\n-\t\t\t\tswitch (principalNodeKind)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tcase ELEMENT:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new ElementTest(name.getNamespaceURI(), name.getLocalPart());\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase ATTRIBUTE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new AttributeTest(name.getNamespaceURI(), name.getLocalPart());\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase NAMESPACE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new NamespaceTest();\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tdefault:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new AssertionError(principalNodeKind);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tbreak;\r\n-\t\t\tcase TOK_STAR:\r\n-\t\t\t{\r\n-\t\t\t\tswitch (principalNodeKind)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tcase ELEMENT:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new NodeTypeTest(NodeKind.ELEMENT);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase ATTRIBUTE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = null;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase NAMESPACE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = null;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tdefault:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new AssertionError(principalNodeKind);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tbreak;\r\n-\t\t\tcase TOK_NAME_COLON_STAR:\r\n-\t\t\t{\r\n-\t\t\t\tswitch (principalNodeKind)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tcase ELEMENT:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new ElementTest(expandPrefix(), null);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase ATTRIBUTE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new AttributeTest(expandPrefix(), null);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase NAMESPACE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new NamespaceTest();\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tdefault:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new AssertionError(principalNodeKind);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tbreak;\r\n-\t\t\tcase TOK_PROCESSING_INSTRUCTION_LPAR:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\tif (currentToken == TOK_LITERAL)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnodeTest = new ProcessingInstructionTest(expandName().getLocalPart());\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t}\r\n-\t\t\t\telse\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnodeTest = new NodeTypeTest(NodeKind.PROCESSING_INSTRUCTION);\r\n-\t\t\t\t}\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\treturn nodeTest;\r\n-\t\t\t}\r\n-\t\t\tcase TOK_COMMENT_LPAR:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\treturn new NodeTypeTest(NodeKind.COMMENT);\r\n-\t\t\t}\r\n-\t\t\tcase TOK_TEXT_LPAR: // text()\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\treturn new NodeTypeTest(NodeKind.TEXT);\r\n-\t\t\t}\r\n-\t\t\tcase TOK_NODE_LPAR: // node()\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\tswitch (principalNodeKind)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tcase ELEMENT:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\treturn new NodeTypeTest(null);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcase ATTRIBUTE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\treturn new NodeTypeTest(NodeKind.ATTRIBUTE);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcase NAMESPACE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\treturn new NodeTypeTest(NodeKind.NAMESPACE);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tdefault:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new AssertionError(principalNodeKind);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tdefault:\r\n-\t\t\t{\r\n-\t\t\t\tthrow new ExprParseException(\"expected node test\");\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\tnext();\r\n-\t\treturn nodeTest;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #21\r\n-\t//\r\n-\tprivate ConvertibleExpr parseOrExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseAndExpr();\r\n-\t\twhile (currentToken == TOK_OR)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new OrExpr(expr.makeBooleanExpr(statEnv), parseAndExpr().makeBooleanExpr(statEnv));\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #19\r\n-\t//\r\n-\tprivate ConvertibleExpr parsePathExpr() throws ExprParseException\r\n-\t{\r\n-\t\tif (tokenStartsStep())\r\n-\t\t{\r\n-\t\t\treturn parseRelativeLocationPath(); // XPath production #3\r\n-\t\t}\r\n-\r\n-\t\tif (currentToken == TOK_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\tif (tokenStartsStep())\r\n-\t\t\t{\r\n-\t\t\t\t// XPath production #2\r\n-\t\t\t\treturn new RootExpr(parseRelativeLocationPath());\r\n-\t\t\t}\r\n-\t\t\t// the root, by itself\r\n-\t\t\treturn new RootExpr(axisTable.get(\"self\"));\r\n-\t\t}\r\n-\t\tif (currentToken == TOK_SLASH_SLASH)\r\n-\t\t{\r\n-\r\n-\t\t\t// abbreviated absolute location XPath production #10\r\n-\t\t\tnext();\r\n-\t\t\treturn new RootExpr(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\r\n-\t\t}\r\n-\r\n-\t\t//\r\n-\t\t// if none of the above alternatives, we should be looking\r\n-\t\t// at a FilterExpression (production #20) followed by\r\n-\t\t// either a \"/\" or \"//\", and then a RelativeLocationPath\r\n-\t\t// (production #3)\r\n-\t\t//\r\n-\r\n-\t\tConvertibleExpr expr = parsePrimaryExpr();\r\n-\r\n-\t\t// Production 20 requires at least one primary expression\r\n-\t\t// and any number of predicates\r\n-\t\t// the TOK_LSQB (\"[\") starts a predicate\r\n-\r\n-\t\twhile (currentToken == TOK_LSQB)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new FilterExpr(expr.makeNodeSetExpr(statEnv), parseOrExpr().makePredicateExpr(statEnv));\r\n-\t\t\texpectRsqb();\r\n-\t\t}\r\n-\r\n-\t\tif (currentToken == TOK_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn expr.makeNodeSetExpr(statEnv).compose(parseRelativeLocationPath());\r\n-\t\t}\r\n-\t\telse if (currentToken == TOK_SLASH_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn expr.makeNodeSetExpr(statEnv).compose(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\r\n-\t\t}\r\n-\t\telse\r\n-\t\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// Productions #4 and #8\r\n-\t//\r\n-\tprivate ConvertibleNodeSetExprImpl parsePredicates(final AxisExpr axis, final Pattern nodeTest) throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleNodeSetExprImpl expr = axis;\r\n-\t\tif (nodeTest != null)\r\n-\t\t{\r\n-\t\t\texpr = new NodeTestExpr(expr, nodeTest);\r\n-\t\t}\r\n-\t\twhile (currentToken == TOK_LSQB)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new FilterExpr(expr, parseOrExpr().makePredicateExpr(statEnv));\r\n-\t\t\texpectRsqb();\r\n-\t\t}\r\n-\t\treturn axis.makeDocumentOrderExpr(expr);\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #15 PrimaryExpr\r\n-\t// a VariableReference (production #36) OR\r\n-\t// \"(\" Expr \")\" (prod #14) OR\r\n-\t// Literal (prod #29) OR\r\n-\t// Number (prod #30) OR\r\n-\t// FunctionCall (prod #16)\r\n-\t//\r\n-\tprivate ConvertibleExpr parsePrimaryExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr;\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_VARIABLE_REF:\r\n-\t\t\t\t// prod #36\r\n-\t\t\t{\r\n-\t\t\t\tfinal QName name = expandName();\r\n-\t\t\t\tif (statEnv.containsVariable(name))\r\n-\t\t\t\t{\r\n-\t\t\t\t\texpr = new VariableRefExpr(name);\r\n-\t\t\t\t}\r\n-\t\t\t\telse\r\n-\t\t\t\t{\r\n-\t\t\t\t\tthrow new ExprParseException(\"no such variable: \" + name + \" in $\" + currentTokenValue);\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t}\r\n-\r\n-\t\t\tcase TOK_LPAR:\r\n-\t\t\t{\r\n-\t\t\t\t// prod #14\r\n-\t\t\t\tnext();\r\n-\t\t\t\texpr = parseOrExpr();\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\treturn expr;\r\n-\t\t\t}\r\n-\r\n-\t\t\tcase TOK_LITERAL:\r\n-\t\t\t\t// prod #16 (handled by lexer)\r\n-\t\t\t\texpr = new LiteralExpr(currentTokenValue);\r\n-\t\t\tbreak;\r\n-\r\n-\t\t\tcase TOK_NUMBER:\r\n-\t\t\t\t// prod #30 (handled by lexer)\r\n-\t\t\t\texpr = new NumberConstantExpr(Converter.toNumber(currentTokenValue));\r\n-\t\t\tbreak;\r\n-\r\n-\t\t\tcase TOK_FUNCTION_LPAR:\r\n-\t\t\t\t// production #16 FunctionCall\r\n-\t\t\t{\r\n-\t\t\t\t// try a lookup to find if we have somebody who can make\r\n-\t\t\t\t// a CallExpression\r\n-\t\t\t\tFunction function = functionTable.get(currentTokenValue);\r\n-\r\n-\t\t\t\tif (function == null)\r\n-\t\t\t\t{\r\n-\t\t\t\t\t// \"current()\" is special, because we'll want\r\n-\t\t\t\t\t// to take note of the fact that this expr\r\n-\t\t\t\t\t// uses it\r\n-\t\t\t\t\tif (!currentTokenValue.equals(\"current\"))\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"no such function: \" + currentTokenValue);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"no such function: \" + currentTokenValue);\r\n-\t\t\t\t\t\t// usesCurrentFunction = true;\r\n-\t\t\t\t\t\t// function = currentFunction;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t\tnext();\r\n-\r\n-\t\t\t\treturn function.makeCallExpr(parseArgs(), statEnv);\r\n-\r\n-\t\t\t}\r\n-\r\n-\t\t\t\t// an extension function\r\n-\t\t\tcase TOK_CNAME_LPAR:\r\n-\t\t\t\t// also prod #16 FunctionCall\r\n-\t\t\t{\r\n-\t\t\t\tQName name = expandName();\r\n-\t\t\t\tnext();\r\n-\t\t\t\t// if (XT_NAMESPACE.equals(name.getNamespace()))\r\n-\t\t\t\t// {\r\n-\t\t\t\t//\r\n-\t\t\t\t// // xt: extension functions are constructed and\r\n-\t\t\t\t// // called just like builtin functions, rather\r\n-\t\t\t\t// // than the more loosely coupled extension mechanism\r\n-\t\t\t\t//\r\n-\t\t\t\t// Function function = (Function)extensionFunctionTable.get(name.getLocalPart());\r\n-\t\t\t\t// if (function != null)\r\n-\t\t\t\t// {\r\n-\t\t\t\t// return function.makeCallExpr(parseArgs(), node);\r\n-\t\t\t\t// }\r\n-\t\t\t\t// }\r\n-\t\t\t\tConvertibleExpr[] args = parseArgs();\r\n-\t\t\t\tVariantExpr[] variantArgs = (VariantExpr[])Array.newInstance(VariantExpr.class, args.length);\r\n-\t\t\t\tfor (int i = 0; i < args.length; i++)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tvariantArgs[i] = args[i].makeVariantExpr(statEnv);\r\n-\t\t\t\t}\r\n-\t\t\t\treturn new ExtensionFunctionCallExpr(name, variantArgs);\r\n-\t\t\t}\r\n-\t\t\tdefault:\r\n-\t\t\t{\r\n-\t\t\t\t// TODO: This CFG is not yielding helpful messages.\r\n-\t\t\t\tthrow new ExprParseException(\"Unexpected \\\"\".concat(ExprTokenizer.toString(currentToken)).concat(\"\\\"\"));\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\tnext();\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #24\r\n-\t//\r\n-\t// A RelationalExpr is an AdditiveExpr, possibly\r\n-\t// followed by a comparison operator and another\r\n-\t// RelationalExpr\r\n-\t//\r\n-\tprivate ConvertibleExpr parseRelationalExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseAdditiveExpr();\r\n-\t\tloop: for (;;)\r\n-\t\t{\r\n-\t\t\tswitch (currentToken)\r\n-\t\t\t{\r\n-\t\t\t\tcase TOK_GT:\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\">\"), expr, parseAdditiveExpr());\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_GTE:\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\">=\"), expr, parseAdditiveExpr());\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_LT:\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\">\"), parseAdditiveExpr(), expr);\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_LTE:\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\">=\"), parseAdditiveExpr(), expr);\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\tbreak loop;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// RelativeLocationPath -- XPath production #3\r\n-\t//\r\n-\tprivate ConvertibleNodeSetExpr parseRelativeLocationPath() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleNodeSetExprImpl step = parseStep();\r\n-\t\tif (currentToken == TOK_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn step.compose(parseRelativeLocationPath());\r\n-\t\t}\r\n-\t\tif (currentToken == TOK_SLASH_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn step.compose(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\r\n-\t\t}\r\n-\t\treturn step;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #4\r\n-\t//\r\n-\tprivate ConvertibleNodeSetExprImpl parseStep() throws ExprParseException\r\n-\t{\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_AXIS:\r\n-\t\t\t{\r\n-\t\t\t\tAxisExpr axis = axisTable.get(currentTokenValue);\r\n-\t\t\t\tif (axis == null)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tthrow new ExprParseException(\"no such axis\");\r\n-\t\t\t\t}\r\n-\t\t\t\tnext();\r\n-\t\t\t\treturn parsePredicates(axis, parseNodeTest(axis.getPrincipalNodeKind()));\r\n-\t\t\t}\r\n-\t\t\tcase TOK_DOT:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\treturn axisTable.get(\"self\");\r\n-\t\t\t}\r\n-\t\t\tcase TOK_DOT_DOT:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\treturn axisTable.get(\"parent\");\r\n-\t\t\t}\r\n-\t\t\tcase TOK_AT:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\treturn parsePredicates(axisTable.get(\"attribute\"), parseNodeTest(NodeKind.ATTRIBUTE));\r\n-\t\t\t}\r\n-\t\t\tdefault:\r\n-\t\t\t{\r\n-\t\t\t\treturn parsePredicates(axisTable.get(\"child\"), parseNodeTest(NodeKind.ELEMENT));\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #27\r\n-\t//\r\n-\t// we've recognized something which may be a\r\n-\t// unary operator (-) followed by an expression\r\n-\t// or a union expression (or group)\r\n-\t// or a path expression\r\n-\t//\r\n-\tprivate ConvertibleExpr parseUnaryExpr() throws ExprParseException\r\n-\t{\r\n-\t\tif (currentToken == TOK_MINUS)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn new NegateExpr(parseUnaryExpr().makeNumberExpr(statEnv));\r\n-\t\t}\r\n-\t\treturn parseUnionExpr();\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #18\r\n-\t//\r\n-\t// any expression which may contain alternative\r\n-\t// path expressions (separated by the or operator \"|\")\r\n-\t//\r\n-\tprivate ConvertibleExpr parseUnionExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parsePathExpr();\r\n-\t\twhile (currentToken == TOK_VBAR)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new UnionExpr(expr.makeNodeSetExpr(statEnv), parsePathExpr().makeNodeSetExpr(statEnv));\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t//\r\n-\tprivate boolean tokenStartsNodeTest()\r\n-\t{\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_QNAME:\r\n-\t\t\tcase TOK_STAR:\r\n-\t\t\tcase TOK_NAME_COLON_STAR:\r\n-\t\t\tcase TOK_PROCESSING_INSTRUCTION_LPAR:\r\n-\t\t\tcase TOK_COMMENT_LPAR:\r\n-\t\t\tcase TOK_TEXT_LPAR:\r\n-\t\t\tcase TOK_NODE_LPAR:\r\n-\t\t\t\treturn true;\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t//\r\n-\t//\r\n-\tprivate boolean tokenStartsStep()\r\n-\t{\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_AXIS:\r\n-\t\t\tcase TOK_DOT:\r\n-\t\t\tcase TOK_DOT_DOT:\r\n-\t\t\tcase TOK_AT:\r\n-\t\t\t\treturn true;\r\n-\t\t}\r\n-\t\treturn tokenStartsNodeTest();\r\n-\t}\r\n+final class ExprParser\r\n+    extends ExprTokenizer {\r\n+    private final ExprContextStatic statEnv;\r\n+\r\n+    private final HashMap<String, AxisExpr> axisTable;\r\n+\r\n+    private final HashMap<String, Function> functionTable;\r\n+\r\n+    private final HashMap<String, Relation> relationTable;\r\n+\r\n+    public ExprParser(final String expr, final ExprContextStatic statEnv,\r\n+                      final HashMap<String, AxisExpr> axisTable,\r\n+                      final HashMap<String, Function> functionTable,\r\n+                      final HashMap<String, Relation> relationTable) {\r\n+        super(expr);\r\n+        this.statEnv = statEnv;\r\n+        this.axisTable = axisTable;\r\n+        this.functionTable = functionTable;\r\n+        this.relationTable = relationTable;\r\n+    }\r\n+\r\n+    //\r\n+    // returns an expanded Name from the qName in\r\n+    // currentTokenValue\r\n+    //\r\n+    private QName expandName() throws ExprParseException {\r\n+        final int index = currentTokenValue.indexOf(':');\r\n+        final String prefix =\r\n+            (index == -1) ? XMLConstants.DEFAULT_NS_PREFIX : currentTokenValue.substring(0, index);\r\n+        final String localName = currentTokenValue.substring(index + 1);\r\n+        if (prefix.length() > 0) {\r\n+            final String ns = statEnv.getNamespace(prefix); // returns null if not bound.\r\n+\r\n+            if (ns != null) {\r\n+                return new QName(ns, localName, prefix);\r\n+            } else {\r\n+                throw new ExprParseException(\r\n+                    \"prefix '\" + prefix + \"' is not bound to a namespace.\");\r\n+            }\r\n+        } else {\r\n+            // In XPath 1.0, the default namespace for unqualified QName(s) is the namespace\r\n+            // with a zero-length name. Note that in XPath 2.0 we would distinguish between\r\n+            // function names, element and type names, and even variable names.\r\n+            return new QName(XMLConstants.NULL_NS_URI, localName, prefix);\r\n+        }\r\n+    }\r\n+\r\n+    //\r\n+    // gets the Namespace URI associated with the prefix in\r\n+    // currentTokenValue\r\n+    //\r\n+    private String expandPrefix() throws ExprParseException {\r\n+        String ns = statEnv.getNamespace(currentTokenValue);\r\n+        if (ns == null) {\r\n+            throw new ExprParseException(\"undefined prefix\");\r\n+        }\r\n+        return ns;\r\n+    }\r\n+\r\n+    //\r\n+    // Checks to ensure that the CurrentToken is ')', then\r\n+    // lexes the next\r\n+    //\r\n+    private final void expectRpar() throws ExprParseException {\r\n+        if (currentToken != TOK_RPAR) {\r\n+            throw new ExprParseException(\"expected )\");\r\n+        }\r\n+        next();\r\n+    }\r\n+\r\n+    //\r\n+    // Checks to ensure that the currentToken is ']', then\r\n+    // lexes the next\r\n+    //\r\n+    private final void expectRsqb() throws ExprParseException {\r\n+        if (currentToken != TOK_RSQB) {\r\n+            throw new ExprParseException(\"expected ]\");\r\n+        }\r\n+        next();\r\n+    }\r\n+\r\n+    /**\r\n+     * A ConvertibleExpr allows for the casting of one type to another for the purpose of making a comparison\r\n+     */\r\n+    ConvertibleExprImpl makeRelationalExpr(final Relation rel, final ConvertibleExpr e1,\r\n+                                           final ConvertibleExpr e2) throws ExprParseException {\r\n+        // OPT: have some more expressions for non-variant cases\r\n+        if (e1 instanceof NodeSetExpr || e2 instanceof NodeSetExpr || e1 instanceof VariantExpr ||\r\n+            e2 instanceof VariantExpr) {\r\n+            return new VariantRelationalExpr(rel, e1.makeVariantExpr(statEnv),\r\n+                e2.makeVariantExpr(statEnv));\r\n+        }\r\n+\r\n+        if (rel instanceof NumericRelation) {\r\n+            return new NumberRelationalExpr(rel, e1.makeNumberExpr(statEnv),\r\n+                e2.makeNumberExpr(statEnv));\r\n+        }\r\n+\r\n+        if (e1 instanceof BooleanExpr || e2 instanceof BooleanExpr) {\r\n+            return new BooleanRelationalExpr(rel, e1.makeBooleanExpr(statEnv),\r\n+                e2.makeBooleanExpr(statEnv));\r\n+        }\r\n+\r\n+        if (e1 instanceof NumberExpr || e2 instanceof NumberExpr) {\r\n+            return new NumberRelationalExpr(rel, e1.makeNumberExpr(statEnv),\r\n+                e2.makeNumberExpr(statEnv));\r\n+        }\r\n+\r\n+        return new StringRelationalExpr(rel, e1.makeStringExpr(statEnv),\r\n+            e2.makeStringExpr(statEnv));\r\n+    }\r\n+\r\n+    //\r\n+    // XPath production #25 AdditiveExpr\r\n+    //\r\n+    private ConvertibleExpr parseAdditiveExpr() throws ExprParseException {\r\n+        ConvertibleExpr expr = parseMultiplicativeExpr();\r\n+        loop:\r\n+        for (; ; ) {\r\n+            switch (currentToken) {\r\n+                case TOK_PLUS:\r\n+                    next();\r\n+                    expr = new AddExpr(expr.makeNumberExpr(statEnv),\r\n+                        parseMultiplicativeExpr().makeNumberExpr(statEnv));\r\n+                    break;\r\n+                case TOK_MINUS:\r\n+                    next();\r\n+                    expr = new SubtractExpr(expr.makeNumberExpr(statEnv),\r\n+                        parseMultiplicativeExpr().makeNumberExpr(statEnv));\r\n+                    break;\r\n+                default:\r\n+                    break loop;\r\n+            }\r\n+        }\r\n+        return expr;\r\n+    }\r\n+\r\n+    //\r\n+    // XPath production #22\r\n+    //\r\n+    private ConvertibleExpr parseAndExpr() throws ExprParseException {\r\n+        ConvertibleExpr expr = parseEqualityExpr();\r\n+        while (currentToken == TOK_AND) {\r\n+            next();\r\n+            expr = new AndExpr(expr.makeBooleanExpr(statEnv),\r\n+                parseEqualityExpr().makeBooleanExpr(statEnv));\r\n+        }\r\n+        return expr;\r\n+    }\r\n+\r\n+    //\r\n+    // parse the zero or more arguments to a function call\r\n+    // XPath Productions #16 FunctionCall, and 17 Argument\r\n+    // Production #17 (Argument) is an Expr (Production #14)\r\n+    // which is in turn an OrExpr (Production #21)\r\n+    //\r\n+    // We return the Arguments as an array of ConvertibleExprs\r\n+    //\r\n+    private ConvertibleExpr[] parseArgs() throws ExprParseException {\r\n+        if (currentToken == TOK_RPAR) {\r\n+            next();\r\n+            return (ConvertibleExprImpl[]) Array.newInstance(ConvertibleExprImpl.class, 0);\r\n+        }\r\n+        ConvertibleExpr[] args =\r\n+            (ConvertibleExpr[]) Array.newInstance(ConvertibleExprImpl.class, 1);\r\n+        for (; ; ) {\r\n+            args[args.length - 1] = parseOrExpr();\r\n+            if (currentToken != TOK_COMMA) {\r\n+                break;\r\n+            }\r\n+            next();\r\n+            ConvertibleExpr[] oldArgs = args;\r\n+            args = (ConvertibleExprImpl[]) Array\r\n+                .newInstance(ConvertibleExprImpl.class, oldArgs.length + 1);\r\n+            System.arraycopy(oldArgs, 0, args, 0, oldArgs.length);\r\n+        }\r\n+        expectRpar(); // check currentToken to ensure it's \")\"\r\n+        return args;\r\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #23\r\n+    //\r\n+    private ConvertibleExpr parseEqualityExpr() throws ExprParseException {\r\n+        ConvertibleExpr expr = parseRelationalExpr();\r\n+        loop:\r\n+        for (; ; ) {\r\n+            switch (currentToken) {\r\n+                case TOK_EQUALS:\r\n+                    next();\r\n+                    expr = makeRelationalExpr(relationTable.get(\"=\"), expr, parseRelationalExpr());\r\n+                    break;\r\n+                case TOK_NOT_EQUALS:\r\n+                    next();\r\n+                    expr = makeRelationalExpr(relationTable.get(\"!=\"), expr, parseRelationalExpr());\r\n+                    break;\r\n+                default:\r\n+                    break loop;\r\n+            }\r\n+        }\r\n+        return expr;\r\n+    }\r\n+\r\n+    public ConvertibleExpr parseExpr() throws ExprParseException {\r\n+        next();\r\n+        ConvertibleExpr expr = parseOrExpr();\r\n+        if (currentToken != TOK_EOF) {\r\n+            throw new ExprParseException(\"unexpected token\");\r\n+        }\r\n+        return expr;\r\n+    }\r\n+\r\n+    //\r\n+    // XPath production #26\r\n+    //\r\n+    private ConvertibleExpr parseMultiplicativeExpr() throws ExprParseException {\r\n+        // get the first part\r\n+        ConvertibleExpr expr = parseUnaryExpr();\r\n+        loop:\r\n+        for (; ; ) {\r\n+            switch (currentToken) {\r\n+                case TOK_DIV:\r\n+                    next();\r\n+                    expr = new DivideExpr(expr.makeNumberExpr(statEnv),\r\n+                        parseUnaryExpr().makeNumberExpr(statEnv));\r\n+                    break;\r\n+                case TOK_MOD:\r\n+                    next();\r\n+                    expr = new ModuloExpr(expr.makeNumberExpr(statEnv),\r\n+                        parseUnaryExpr().makeNumberExpr(statEnv));\r\n+                    break;\r\n+                case TOK_MULTIPLY:\r\n+                    next();\r\n+                    expr = new MultiplyExpr(expr.makeNumberExpr(statEnv),\r\n+                        parseUnaryExpr().makeNumberExpr(statEnv));\r\n+                    break;\r\n+                default:\r\n+                    break loop;\r\n+            }\r\n+        }\r\n+        return expr;\r\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #7\r\n+    //\r\n+    // Compile a node test for an XPath pattern step,\r\n+    // up to, but not including any predicates\r\n+    //\r\n+    // WDL do not return null, even if the test is vacuous (e.g. \"node()\"\r\n+    //\r\n+    // TODO: Here we need the principal node kind.\r\n+    private PathPatternBase parseNodeTest(final NodeKind principalNodeKind)\r\n+        throws ExprParseException {\r\n+        PathPatternBase nodeTest;\r\n+        switch (currentToken) {\r\n+            case TOK_QNAME: {\r\n+                final QName name = expandName();\r\n+                switch (principalNodeKind) {\r\n+                    case ELEMENT: {\r\n+                        nodeTest = new ElementTest(name.getNamespaceURI(), name.getLocalPart());\r\n+                    }\r\n+                    break;\r\n+                    case ATTRIBUTE: {\r\n+                        nodeTest = new AttributeTest(name.getNamespaceURI(), name.getLocalPart());\r\n+                    }\r\n+                    break;\r\n+                    case NAMESPACE: {\r\n+                        nodeTest = new NamespaceTest();\r\n+                    }\r\n+                    break;\r\n+                    default: {\r\n+                        throw new AssertionError(principalNodeKind);\r\n+                    }\r\n+                }\r\n+            }\r\n+            break;\r\n+            case TOK_STAR: {\r\n+                switch (principalNodeKind) {\r\n+                    case ELEMENT: {\r\n+                        nodeTest = new NodeTypeTest(NodeKind.ELEMENT);\r\n+                    }\r\n+                    break;\r\n+                    case ATTRIBUTE: {\r\n+                        nodeTest = null;\r\n+                    }\r\n+                    break;\r\n+                    case NAMESPACE: {\r\n+                        nodeTest = null;\r\n+                    }\r\n+                    break;\r\n+                    default: {\r\n+                        throw new AssertionError(principalNodeKind);\r\n+                    }\r\n+                }\r\n+            }\r\n+            break;\r\n+            case TOK_NAME_COLON_STAR: {\r\n+                switch (principalNodeKind) {\r\n+                    case ELEMENT: {\r\n+                        nodeTest = new ElementTest(expandPrefix(), null);\r\n+                    }\r\n+                    break;\r\n+                    case ATTRIBUTE: {\r\n+                        nodeTest = new AttributeTest(expandPrefix(), null);\r\n+                    }\r\n+                    break;\r\n+                    case NAMESPACE: {\r\n+                        nodeTest = new NamespaceTest();\r\n+                    }\r\n+                    break;\r\n+                    default: {\r\n+                        throw new AssertionError(principalNodeKind);\r\n+                    }\r\n+                }\r\n+            }\r\n+            break;\r\n+            case TOK_PROCESSING_INSTRUCTION_LPAR: {\r\n+                next();\r\n+                if (currentToken == TOK_LITERAL) {\r\n+                    nodeTest = new ProcessingInstructionTest(expandName().getLocalPart());\r\n+                    next();\r\n+                } else {\r\n+                    nodeTest = new NodeTypeTest(NodeKind.PROCESSING_INSTRUCTION);\r\n+                }\r\n+                expectRpar();\r\n+                return nodeTest;\r\n+            }\r\n+            case TOK_COMMENT_LPAR: {\r\n+                next();\r\n+                expectRpar();\r\n+                return new NodeTypeTest(NodeKind.COMMENT);\r\n+            }\r\n+            case TOK_TEXT_LPAR: // text()\r\n+            {\r\n+                next();\r\n+                expectRpar();\r\n+                return new NodeTypeTest(NodeKind.TEXT);\r\n+            }\r\n+            case TOK_NODE_LPAR: // node()\r\n+            {\r\n+                next();\r\n+                expectRpar();\r\n+                switch (principalNodeKind) {\r\n+                    case ELEMENT: {\r\n+                        return new NodeTypeTest(null);\r\n+                    }\r\n+                    case ATTRIBUTE: {\r\n+                        return new NodeTypeTest(NodeKind.ATTRIBUTE);\r\n+                    }\r\n+                    case NAMESPACE: {\r\n+                        return new NodeTypeTest(NodeKind.NAMESPACE);\r\n+                    }\r\n+                    default: {\r\n+                        throw new AssertionError(principalNodeKind);\r\n+                    }\r\n+                }\r\n+            }\r\n+            default: {\r\n+                throw new ExprParseException(\"expected node test\");\r\n+            }\r\n+        }\r\n+        next();\r\n+        return nodeTest;\r\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #21\r\n+    //\r\n+    private ConvertibleExpr parseOrExpr() throws ExprParseException {\r\n+        ConvertibleExpr expr = parseAndExpr();\r\n+        while (currentToken == TOK_OR) {\r\n+            next();\r\n+            expr =\r\n+                new OrExpr(expr.makeBooleanExpr(statEnv), parseAndExpr().makeBooleanExpr(statEnv));\r\n+        }\r\n+        return expr;\r\n+    }\r\n+\r\n+    //\r\n+    // XPath production #19\r\n+    //\r\n+    private ConvertibleExpr parsePathExpr() throws ExprParseException {\r\n+        if (tokenStartsStep()) {\r\n+            return parseRelativeLocationPath(); // XPath production #3\r\n+        }\r\n+\r\n+        if (currentToken == TOK_SLASH) {\r\n+            next();\r\n+            if (tokenStartsStep()) {\r\n+                // XPath production #2\r\n+                return new RootExpr(parseRelativeLocationPath());\r\n+            }\r\n+            // the root, by itself\r\n+            return new RootExpr(axisTable.get(\"self\"));\r\n+        }\r\n+        if (currentToken == TOK_SLASH_SLASH) {\r\n+\r\n+            // abbreviated absolute location XPath production #10\r\n+            next();\r\n+            return new RootExpr(\r\n+                axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\r\n+        }\r\n+\r\n+        //\r\n+        // if none of the above alternatives, we should be looking\r\n+        // at a FilterExpression (production #20) followed by\r\n+        // either a \"/\" or \"//\", and then a RelativeLocationPath\r\n+        // (production #3)\r\n+        //\r\n+\r\n+        ConvertibleExpr expr = parsePrimaryExpr();\r\n+\r\n+        // Production 20 requires at least one primary expression\r\n+        // and any number of predicates\r\n+        // the TOK_LSQB (\"[\") starts a predicate\r\n+\r\n+        while (currentToken == TOK_LSQB) {\r\n+            next();\r\n+            expr = new FilterExpr(expr.makeNodeSetExpr(statEnv),\r\n+                parseOrExpr().makePredicateExpr(statEnv));\r\n+            expectRsqb();\r\n+        }\r\n+\r\n+        if (currentToken == TOK_SLASH) {\r\n+            next();\r\n+            return expr.makeNodeSetExpr(statEnv).compose(parseRelativeLocationPath());\r\n+        } else if (currentToken == TOK_SLASH_SLASH) {\r\n+            next();\r\n+            return expr.makeNodeSetExpr(statEnv)\r\n+                .compose(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\r\n+        } else {\r\n+            return expr;\r\n+        }\r\n+    }\r\n+\r\n+    //\r\n+    // Productions #4 and #8\r\n+    //\r\n+    private ConvertibleNodeSetExprImpl parsePredicates(final AxisExpr axis, final Pattern nodeTest)\r\n+        throws ExprParseException {\r\n+        ConvertibleNodeSetExprImpl expr = axis;\r\n+        if (nodeTest != null) {\r\n+            expr = new NodeTestExpr(expr, nodeTest);\r\n+        }\r\n+        while (currentToken == TOK_LSQB) {\r\n+            next();\r\n+            expr = new FilterExpr(expr, parseOrExpr().makePredicateExpr(statEnv));\r\n+            expectRsqb();\r\n+        }\r\n+        return axis.makeDocumentOrderExpr(expr);\r\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #15 PrimaryExpr\r\n+    // a VariableReference (production #36) OR\r\n+    // \"(\" Expr \")\" (prod #14) OR\r\n+    // Literal (prod #29) OR\r\n+    // Number (prod #30) OR\r\n+    // FunctionCall (prod #16)\r\n+    //\r\n+    private ConvertibleExpr parsePrimaryExpr() throws ExprParseException {\r\n+        ConvertibleExpr expr;\r\n+        switch (currentToken) {\r\n+            case TOK_VARIABLE_REF:\r\n+                // prod #36\r\n+            {\r\n+                final QName name = expandName();\r\n+                if (statEnv.containsVariable(name)) {\r\n+                    expr = new VariableRefExpr(name);\r\n+                } else {\r\n+                    throw new ExprParseException(\r\n+                        \"no such variable: \" + name + \" in $\" + currentTokenValue);\r\n+                }\r\n+                break;\r\n+            }\r\n+\r\n+            case TOK_LPAR: {\r\n+                // prod #14\r\n+                next();\r\n+                expr = parseOrExpr();\r\n+                expectRpar();\r\n+                return expr;\r\n+            }\r\n+\r\n+            case TOK_LITERAL:\r\n+                // prod #16 (handled by lexer)\r\n+                expr = new LiteralExpr(currentTokenValue);\r\n+                break;\r\n+\r\n+            case TOK_NUMBER:\r\n+                // prod #30 (handled by lexer)\r\n+                expr = new NumberConstantExpr(Converter.toNumber(currentTokenValue));\r\n+                break;\r\n+\r\n+            case TOK_FUNCTION_LPAR:\r\n+                // production #16 FunctionCall\r\n+            {\r\n+                // try a lookup to find if we have somebody who can make\r\n+                // a CallExpression\r\n+                Function function = functionTable.get(currentTokenValue);\r\n+\r\n+                if (function == null) {\r\n+                    // \"current()\" is special, because we'll want\r\n+                    // to take note of the fact that this expr\r\n+                    // uses it\r\n+                    if (!currentTokenValue.equals(\"current\")) {\r\n+                        throw new ExprParseException(\"no such function: \" + currentTokenValue);\r\n+                    } else {\r\n+                        throw new ExprParseException(\"no such function: \" + currentTokenValue);\r\n+                        // usesCurrentFunction = true;\r\n+                        // function = currentFunction;\r\n+                    }\r\n+                }\r\n+                next();\r\n+\r\n+                return function.makeCallExpr(parseArgs(), statEnv);\r\n+\r\n+            }\r\n+\r\n+            // an extension function\r\n+            case TOK_CNAME_LPAR:\r\n+                // also prod #16 FunctionCall\r\n+            {\r\n+                QName name = expandName();\r\n+                next();\r\n+                // if (XT_NAMESPACE.equals(name.getNamespace()))\r\n+                // {\r\n+                //\r\n+                // // xt: extension functions are constructed and\r\n+                // // called just like builtin functions, rather\r\n+                // // than the more loosely coupled extension mechanism\r\n+                //\r\n+                // Function function = (Function)extensionFunctionTable.get(name.getLocalPart());\r\n+                // if (function != null)\r\n+                // {\r\n+                // return function.makeCallExpr(parseArgs(), node);\r\n+                // }\r\n+                // }\r\n+                ConvertibleExpr[] args = parseArgs();\r\n+                VariantExpr[] variantArgs =\r\n+                    (VariantExpr[]) Array.newInstance(VariantExpr.class, args.length);\r\n+                for (int i = 0; i < args.length; i++) {\r\n+                    variantArgs[i] = args[i].makeVariantExpr(statEnv);\r\n+                }\r\n+                return new ExtensionFunctionCallExpr(name, variantArgs);\r\n+            }\r\n+            default: {\r\n+                // TODO: This CFG is not yielding helpful messages.\r\n+                throw new ExprParseException(\r\n+                    \"Unexpected \\\"\".concat(ExprTokenizer.toString(currentToken)).concat(\"\\\"\"));\r\n+            }\r\n+        }\r\n+        next();\r\n+        return expr;\r\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #24\r\n+    //\r\n+    // A RelationalExpr is an AdditiveExpr, possibly\r\n+    // followed by a comparison operator and another\r\n+    // RelationalExpr\r\n+    //\r\n+    private ConvertibleExpr parseRelationalExpr() throws ExprParseException {\r\n+        ConvertibleExpr expr = parseAdditiveExpr();\r\n+        loop:\r\n+        for (; ; ) {\r\n+            switch (currentToken) {\r\n+                case TOK_GT: {\r\n+                    next();\r\n+                    expr = makeRelationalExpr(relationTable.get(\">\"), expr, parseAdditiveExpr());\r\n+                }\r\n+                break;\r\n+                case TOK_GTE: {\r\n+                    next();\r\n+                    expr = makeRelationalExpr(relationTable.get(\">=\"), expr, parseAdditiveExpr());\r\n+                }\r\n+                break;\r\n+                case TOK_LT: {\r\n+                    next();\r\n+                    expr = makeRelationalExpr(relationTable.get(\">\"), parseAdditiveExpr(), expr);\r\n+                }\r\n+                break;\r\n+                case TOK_LTE: {\r\n+                    next();\r\n+                    expr = makeRelationalExpr(relationTable.get(\">=\"), parseAdditiveExpr(), expr);\r\n+                }\r\n+                break;\r\n+                default:\r\n+                    break loop;\r\n+            }\r\n+        }\r\n+        return expr;\r\n+    }\r\n+\r\n+    //\r\n+    // RelativeLocationPath -- XPath production #3\r\n+    //\r\n+    private ConvertibleNodeSetExpr parseRelativeLocationPath() throws ExprParseException {\r\n+        ConvertibleNodeSetExprImpl step = parseStep();\r\n+        if (currentToken == TOK_SLASH) {\r\n+            next();\r\n+            return step.compose(parseRelativeLocationPath());\r\n+        }\r\n+        if (currentToken == TOK_SLASH_SLASH) {\r\n+            next();\r\n+            return step\r\n+                .compose(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\r\n+        }\r\n+        return step;\r\n+    }\r\n+\r\n+    //\r\n+    // XPath production #4\r\n+    //\r\n+    private ConvertibleNodeSetExprImpl parseStep() throws ExprParseException {\r\n+        switch (currentToken) {\r\n+            case TOK_AXIS: {\r\n+                AxisExpr axis = axisTable.get(currentTokenValue);\r\n+                if (axis == null) {\r\n+                    throw new ExprParseException(\"no such axis\");\r\n+                }\r\n+                next();\r\n+                return parsePredicates(axis, parseNodeTest(axis.getPrincipalNodeKind()));\r\n+            }\r\n+            case TOK_DOT: {\r\n+                next();\r\n+                return axisTable.get(\"self\");\r\n+            }\r\n+            case TOK_DOT_DOT: {\r\n+                next();\r\n+                return axisTable.get(\"parent\");\r\n+            }\r\n+            case TOK_AT: {\r\n+                next();\r\n+                return parsePredicates(axisTable.get(\"attribute\"),\r\n+                    parseNodeTest(NodeKind.ATTRIBUTE));\r\n+            }\r\n+            default: {\r\n+                return parsePredicates(axisTable.get(\"child\"), parseNodeTest(NodeKind.ELEMENT));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    //\r\n+    // XPath production #27\r\n+    //\r\n+    // we've recognized something which may be a\r\n+    // unary operator (-) followed by an expression\r\n+    // or a union expression (or group)\r\n+    // or a path expression\r\n+    //\r\n+    private ConvertibleExpr parseUnaryExpr() throws ExprParseException {\r\n+        if (currentToken == TOK_MINUS) {\r\n+            next();\r\n+            return new NegateExpr(parseUnaryExpr().makeNumberExpr(statEnv));\r\n+        }\r\n+        return parseUnionExpr();\r\n+    }\r\n+\r\n+    //\r\n+    // XPath production #18\r\n+    //\r\n+    // any expression which may contain alternative\r\n+    // path expressions (separated by the or operator \"|\")\r\n+    //\r\n+    private ConvertibleExpr parseUnionExpr() throws ExprParseException {\r\n+        ConvertibleExpr expr = parsePathExpr();\r\n+        while (currentToken == TOK_VBAR) {\r\n+            next();\r\n+            expr = new UnionExpr(expr.makeNodeSetExpr(statEnv),\r\n+                parsePathExpr().makeNodeSetExpr(statEnv));\r\n+        }\r\n+        return expr;\r\n+    }\r\n+\r\n+    //\r\n+    //\r\n+    private boolean tokenStartsNodeTest() {\r\n+        switch (currentToken) {\r\n+            case TOK_QNAME:\r\n+            case TOK_STAR:\r\n+            case TOK_NAME_COLON_STAR:\r\n+            case TOK_PROCESSING_INSTRUCTION_LPAR:\r\n+            case TOK_COMMENT_LPAR:\r\n+            case TOK_TEXT_LPAR:\r\n+            case TOK_NODE_LPAR:\r\n+                return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    //\r\n+    //\r\n+    private boolean tokenStartsStep() {\r\n+        switch (currentToken) {\r\n+            case TOK_AXIS:\r\n+            case TOK_DOT:\r\n+            case TOK_DOT_DOT:\r\n+            case TOK_AT:\r\n+                return true;\r\n+        }\r\n+        return tokenStartsNodeTest();\r\n+    }\r\n }\r\n",
            "diff_size": 789
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/158/ExprParser.java\nindex 2c7d53b6fed..5b7b405954c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/158/ExprParser.java\n@@ -18,823 +18,855 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n-package org.genxdm.processor.xpath.v10.expressions;\r\n-\r\n-import java.lang.reflect.Array;\r\n-import java.util.HashMap;\r\n-\r\n-import javax.xml.XMLConstants;\r\n-import javax.xml.namespace.QName;\r\n-\r\n-import org.genxdm.NodeKind;\r\n-import org.genxdm.processor.xpath.v10.patterns.PathPatternBase;\r\n-import org.genxdm.processor.xpath.v10.patterns.Pattern;\r\n-import org.genxdm.processor.xpath.v10.relations.NumericRelation;\r\n-import org.genxdm.processor.xpath.v10.relations.Relation;\r\n-import org.genxdm.processor.xpath.v10.tests.AttributeTest;\r\n-import org.genxdm.processor.xpath.v10.tests.ElementTest;\r\n-import org.genxdm.processor.xpath.v10.tests.NamespaceTest;\r\n-import org.genxdm.processor.xpath.v10.tests.NodeTypeTest;\r\n-import org.genxdm.processor.xpath.v10.tests.ProcessingInstructionTest;\r\n-import org.genxdm.xpath.v10.BooleanExpr;\r\n-import org.genxdm.xpath.v10.Converter;\r\n-import org.genxdm.xpath.v10.ExprContextStatic;\r\n-import org.genxdm.xpath.v10.ExprParseException;\r\n-import org.genxdm.xpath.v10.NodeSetExpr;\r\n-import org.genxdm.xpath.v10.NumberExpr;\r\n-import org.genxdm.xpath.v10.VariantExpr;\r\n-import org.genxdm.xpath.v10.extend.Function;\r\n-import org.genxdm.xpath.v10.extend.ConvertibleExpr;\r\n+package org.genxdm.processor.xpath.v10.expressions;\n+\n+import java.lang.reflect.Array;\n+import java.util.HashMap;\n+import javax.xml.XMLConstants;\n+import javax.xml.namespace.QName;\n+import org.genxdm.NodeKind;\n+import org.genxdm.processor.xpath.v10.patterns.PathPatternBase;\n+import org.genxdm.processor.xpath.v10.patterns.Pattern;\n+import org.genxdm.processor.xpath.v10.relations.NumericRelation;\n+import org.genxdm.processor.xpath.v10.relations.Relation;\n+import org.genxdm.processor.xpath.v10.tests.AttributeTest;\n+import org.genxdm.processor.xpath.v10.tests.ElementTest;\n+import org.genxdm.processor.xpath.v10.tests.NamespaceTest;\n+import org.genxdm.processor.xpath.v10.tests.NodeTypeTest;\n+import org.genxdm.processor.xpath.v10.tests.ProcessingInstructionTest;\n+import org.genxdm.xpath.v10.BooleanExpr;\n+import org.genxdm.xpath.v10.Converter;\n+import org.genxdm.xpath.v10.ExprContextStatic;\n+import org.genxdm.xpath.v10.ExprParseException;\n+import org.genxdm.xpath.v10.NodeSetExpr;\n+import org.genxdm.xpath.v10.NumberExpr;\n+import org.genxdm.xpath.v10.VariantExpr;\n+import org.genxdm.xpath.v10.extend.Function;\n+import org.genxdm.xpath.v10.extend.ConvertibleExpr;\n import org.genxdm.xpath.v10.extend.ConvertibleNodeSetExpr;\r\n \r\n /**\r\n  * XPath expression parser / compiler extends the lexer ExprTokenizer\r\n- */\r\n-final class ExprParser \r\n-    extends ExprTokenizer\r\n-{\r\n-\tprivate final ExprContextStatic statEnv;\r\n-\tprivate final HashMap<String, AxisExpr> axisTable;\r\n-\tprivate final HashMap<String, Function> functionTable;\r\n-\tprivate final HashMap<String, Relation> relationTable;\r\n-\r\n-\tpublic ExprParser(final String expr, final ExprContextStatic statEnv, final HashMap<String, AxisExpr> axisTable, final HashMap<String, Function> functionTable,\r\n-\t\t\tfinal HashMap<String, Relation> relationTable)\r\n-\t{\r\n-\t\tsuper(expr);\r\n-\t\tthis.statEnv = statEnv;\r\n-\t\tthis.axisTable = axisTable;\r\n-\t\tthis.functionTable = functionTable;\r\n-\t\tthis.relationTable = relationTable;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// returns an expanded Name from the qName in\r\n-\t// currentTokenValue\r\n-\t//\r\n-\tprivate QName expandName() throws ExprParseException\r\n-\t{\r\n-\t\tfinal int index = currentTokenValue.indexOf(':');\r\n-\t\tfinal String prefix = (index == -1) ? XMLConstants.DEFAULT_NS_PREFIX : currentTokenValue.substring(0, index);\r\n-\t\tfinal String localName = currentTokenValue.substring(index + 1);\r\n-\t\tif (prefix.length() > 0)\r\n-\t\t{\r\n-\t\t\tfinal String ns = statEnv.getNamespace(prefix); // returns null if not bound.\r\n-\r\n-\t\t\tif (ns != null)\r\n-\t\t\t{\r\n-\t\t\t\treturn new QName(ns, localName, prefix);\r\n-\t\t\t}\r\n-\t\t\telse\r\n-\t\t\t{\r\n-\t\t\t\tthrow new ExprParseException(\"prefix '\" + prefix + \"' is not bound to a namespace.\");\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\t// In XPath 1.0, the default namespace for unqualified QName(s) is the namespace\r\n-\t\t\t// with a zero-length name. Note that in XPath 2.0 we would distinguish between\r\n-\t\t\t// function names, element and type names, and even variable names.\r\n-\t\t\treturn new QName(XMLConstants.NULL_NS_URI, localName, prefix);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t//\r\n-\t// gets the Namespace URI associated with the prefix in\r\n-\t// currentTokenValue\r\n-\t//\r\n-\tprivate String expandPrefix() throws ExprParseException\r\n-\t{\r\n-\t\tString ns = statEnv.getNamespace(currentTokenValue);\r\n-\t\tif (ns == null)\r\n-\t\t{\r\n-\t\t\tthrow new ExprParseException(\"undefined prefix\");\r\n-\t\t}\r\n-\t\treturn ns;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// Checks to ensure that the CurrentToken is ')', then\r\n-\t// lexes the next\r\n-\t//\r\n-\tprivate final void expectRpar() throws ExprParseException\r\n-\t{\r\n-\t\tif (currentToken != TOK_RPAR)\r\n-\t\t{\r\n-\t\t\tthrow new ExprParseException(\"expected )\");\r\n-\t\t}\r\n-\t\tnext();\r\n-\t}\r\n-\r\n-\t//\r\n-\t// Checks to ensure that the currentToken is ']', then\r\n-\t// lexes the next\r\n-\t//\r\n-\tprivate final void expectRsqb() throws ExprParseException\r\n-\t{\r\n-\t\tif (currentToken != TOK_RSQB)\r\n-\t\t{\r\n-\t\t\tthrow new ExprParseException(\"expected ]\");\r\n-\t\t}\r\n-\t\tnext();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * A ConvertibleExpr allows for the casting of one type to another for the purpose of making a comparison\r\n-\t */\r\n-\tConvertibleExprImpl makeRelationalExpr(final Relation rel, final ConvertibleExpr e1, final ConvertibleExpr e2) throws ExprParseException\r\n-\t{\r\n-\t\t// OPT: have some more expressions for non-variant cases\r\n-\t\tif (e1 instanceof NodeSetExpr || e2 instanceof NodeSetExpr || e1 instanceof VariantExpr || e2 instanceof VariantExpr)\r\n-\t\t{\r\n-\t\t\treturn new VariantRelationalExpr(rel, e1.makeVariantExpr(statEnv), e2.makeVariantExpr(statEnv));\r\n-\t\t}\r\n-\r\n-\t\tif (rel instanceof NumericRelation)\r\n-\t\t{\r\n-\t\t\treturn new NumberRelationalExpr(rel, e1.makeNumberExpr(statEnv), e2.makeNumberExpr(statEnv));\r\n-\t\t}\r\n-\r\n-\t\tif (e1 instanceof BooleanExpr || e2 instanceof BooleanExpr)\r\n-\t\t{\r\n-\t\t\treturn new BooleanRelationalExpr(rel, e1.makeBooleanExpr(statEnv), e2.makeBooleanExpr(statEnv));\r\n-\t\t}\r\n-\r\n-\t\tif (e1 instanceof NumberExpr || e2 instanceof NumberExpr)\r\n-\t\t{\r\n-\t\t\treturn new NumberRelationalExpr(rel, e1.makeNumberExpr(statEnv), e2.makeNumberExpr(statEnv));\r\n-\t\t}\r\n-\r\n-\t\treturn new StringRelationalExpr(rel, e1.makeStringExpr(statEnv), e2.makeStringExpr(statEnv));\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #25 AdditiveExpr\r\n-\t//\r\n-\tprivate ConvertibleExpr parseAdditiveExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseMultiplicativeExpr();\r\n-\t\tloop: for (;;)\r\n-\t\t{\r\n-\t\t\tswitch (currentToken)\r\n-\t\t\t{\r\n-\t\t\t\tcase TOK_PLUS:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new AddExpr(expr.makeNumberExpr(statEnv), parseMultiplicativeExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_MINUS:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new SubtractExpr(expr.makeNumberExpr(statEnv), parseMultiplicativeExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\tbreak loop;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #22\r\n-\t//\r\n-\tprivate ConvertibleExpr parseAndExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseEqualityExpr();\r\n-\t\twhile (currentToken == TOK_AND)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new AndExpr(expr.makeBooleanExpr(statEnv), parseEqualityExpr().makeBooleanExpr(statEnv));\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// parse the zero or more arguments to a function call\r\n-\t// XPath Productions #16 FunctionCall, and 17 Argument\r\n-\t// Production #17 (Argument) is an Expr (Production #14)\r\n-\t// which is in turn an OrExpr (Production #21)\r\n-\t//\r\n-\t// We return the Arguments as an array of ConvertibleExprs\r\n-\t//\r\n-\tprivate ConvertibleExpr[] parseArgs() throws ExprParseException\r\n-\t{\r\n-\t\tif (currentToken == TOK_RPAR)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn (ConvertibleExprImpl[])Array.newInstance(ConvertibleExprImpl.class, 0);\r\n-\t\t}\r\n-\t\tConvertibleExpr[] args = (ConvertibleExpr[])Array.newInstance(ConvertibleExprImpl.class, 1);\r\n-\t\tfor (;;)\r\n-\t\t{\r\n-\t\t\targs[args.length - 1] = parseOrExpr();\r\n-\t\t\tif (currentToken != TOK_COMMA)\r\n-\t\t\t{\r\n-\t\t\t\tbreak;\r\n-\t\t\t}\r\n-\t\t\tnext();\r\n-\t\t\tConvertibleExpr[] oldArgs = args;\r\n-\t\t\targs = (ConvertibleExprImpl[])Array.newInstance(ConvertibleExprImpl.class, oldArgs.length + 1);\r\n-\t\t\tSystem.arraycopy(oldArgs, 0, args, 0, oldArgs.length);\r\n-\t\t}\r\n-\t\texpectRpar(); // check currentToken to ensure it's \")\"\r\n-\t\treturn args;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #23\r\n-\t//\r\n-\tprivate ConvertibleExpr parseEqualityExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseRelationalExpr();\r\n-\t\tloop: for (;;)\r\n-\t\t{\r\n-\t\t\tswitch (currentToken)\r\n-\t\t\t{\r\n-\t\t\t\tcase TOK_EQUALS:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\"=\"), expr, parseRelationalExpr());\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_NOT_EQUALS:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\"!=\"), expr, parseRelationalExpr());\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\tbreak loop;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\tpublic ConvertibleExpr parseExpr() throws ExprParseException\r\n-\t{\r\n-\t\tnext();\r\n-\t\tConvertibleExpr expr = parseOrExpr();\r\n-\t\tif (currentToken != TOK_EOF)\r\n-\t\t{\r\n-\t\t\tthrow new ExprParseException(\"unexpected token\");\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #26\r\n-\t//\r\n-\tprivate ConvertibleExpr parseMultiplicativeExpr() throws ExprParseException\r\n-\t{\r\n-\t\t// get the first part\r\n-\t\tConvertibleExpr expr = parseUnaryExpr();\r\n-\t\tloop: for (;;)\r\n-\t\t{\r\n-\t\t\tswitch (currentToken)\r\n-\t\t\t{\r\n-\t\t\t\tcase TOK_DIV:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new DivideExpr(expr.makeNumberExpr(statEnv), parseUnaryExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_MOD:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new ModuloExpr(expr.makeNumberExpr(statEnv), parseUnaryExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_MULTIPLY:\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = new MultiplyExpr(expr.makeNumberExpr(statEnv), parseUnaryExpr().makeNumberExpr(statEnv));\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\tbreak loop;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #7\r\n-\t//\r\n-\t// Compile a node test for an XPath pattern step,\r\n-\t// up to, but not including any predicates\r\n-\t//\r\n-\t// WDL do not return null, even if the test is vacuous (e.g. \"node()\"\r\n-\t//\r\n-\t// TODO: Here we need the principal node kind.\r\n-\tprivate PathPatternBase parseNodeTest(final NodeKind principalNodeKind) throws ExprParseException\r\n-\t{\r\n-\t\tPathPatternBase nodeTest;\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_QNAME:\r\n-\t\t\t{\r\n-\t\t\t\tfinal QName name = expandName();\r\n-\t\t\t\tswitch (principalNodeKind)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tcase ELEMENT:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new ElementTest(name.getNamespaceURI(), name.getLocalPart());\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase ATTRIBUTE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new AttributeTest(name.getNamespaceURI(), name.getLocalPart());\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase NAMESPACE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new NamespaceTest();\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tdefault:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new AssertionError(principalNodeKind);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tbreak;\r\n-\t\t\tcase TOK_STAR:\r\n-\t\t\t{\r\n-\t\t\t\tswitch (principalNodeKind)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tcase ELEMENT:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new NodeTypeTest(NodeKind.ELEMENT);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase ATTRIBUTE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = null;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase NAMESPACE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = null;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tdefault:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new AssertionError(principalNodeKind);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tbreak;\r\n-\t\t\tcase TOK_NAME_COLON_STAR:\r\n-\t\t\t{\r\n-\t\t\t\tswitch (principalNodeKind)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tcase ELEMENT:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new ElementTest(expandPrefix(), null);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase ATTRIBUTE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new AttributeTest(expandPrefix(), null);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tcase NAMESPACE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tnodeTest = new NamespaceTest();\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tbreak;\r\n-\t\t\t\t\tdefault:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new AssertionError(principalNodeKind);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tbreak;\r\n-\t\t\tcase TOK_PROCESSING_INSTRUCTION_LPAR:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\tif (currentToken == TOK_LITERAL)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnodeTest = new ProcessingInstructionTest(expandName().getLocalPart());\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t}\r\n-\t\t\t\telse\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnodeTest = new NodeTypeTest(NodeKind.PROCESSING_INSTRUCTION);\r\n-\t\t\t\t}\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\treturn nodeTest;\r\n-\t\t\t}\r\n-\t\t\tcase TOK_COMMENT_LPAR:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\treturn new NodeTypeTest(NodeKind.COMMENT);\r\n-\t\t\t}\r\n-\t\t\tcase TOK_TEXT_LPAR: // text()\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\treturn new NodeTypeTest(NodeKind.TEXT);\r\n-\t\t\t}\r\n-\t\t\tcase TOK_NODE_LPAR: // node()\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\tswitch (principalNodeKind)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tcase ELEMENT:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\treturn new NodeTypeTest(null);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcase ATTRIBUTE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\treturn new NodeTypeTest(NodeKind.ATTRIBUTE);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcase NAMESPACE:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\treturn new NodeTypeTest(NodeKind.NAMESPACE);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tdefault:\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new AssertionError(principalNodeKind);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tdefault:\r\n-\t\t\t{\r\n-\t\t\t\tthrow new ExprParseException(\"expected node test\");\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\tnext();\r\n-\t\treturn nodeTest;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #21\r\n-\t//\r\n-\tprivate ConvertibleExpr parseOrExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseAndExpr();\r\n-\t\twhile (currentToken == TOK_OR)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new OrExpr(expr.makeBooleanExpr(statEnv), parseAndExpr().makeBooleanExpr(statEnv));\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #19\r\n-\t//\r\n-\tprivate ConvertibleExpr parsePathExpr() throws ExprParseException\r\n-\t{\r\n-\t\tif (tokenStartsStep())\r\n-\t\t{\r\n-\t\t\treturn parseRelativeLocationPath(); // XPath production #3\r\n-\t\t}\r\n-\r\n-\t\tif (currentToken == TOK_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\tif (tokenStartsStep())\r\n-\t\t\t{\r\n-\t\t\t\t// XPath production #2\r\n-\t\t\t\treturn new RootExpr(parseRelativeLocationPath());\r\n-\t\t\t}\r\n-\t\t\t// the root, by itself\r\n-\t\t\treturn new RootExpr(axisTable.get(\"self\"));\r\n-\t\t}\r\n-\t\tif (currentToken == TOK_SLASH_SLASH)\r\n-\t\t{\r\n-\r\n-\t\t\t// abbreviated absolute location XPath production #10\r\n-\t\t\tnext();\r\n-\t\t\treturn new RootExpr(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\r\n-\t\t}\r\n-\r\n-\t\t//\r\n-\t\t// if none of the above alternatives, we should be looking\r\n-\t\t// at a FilterExpression (production #20) followed by\r\n-\t\t// either a \"/\" or \"//\", and then a RelativeLocationPath\r\n-\t\t// (production #3)\r\n-\t\t//\r\n-\r\n-\t\tConvertibleExpr expr = parsePrimaryExpr();\r\n-\r\n-\t\t// Production 20 requires at least one primary expression\r\n-\t\t// and any number of predicates\r\n-\t\t// the TOK_LSQB (\"[\") starts a predicate\r\n-\r\n-\t\twhile (currentToken == TOK_LSQB)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new FilterExpr(expr.makeNodeSetExpr(statEnv), parseOrExpr().makePredicateExpr(statEnv));\r\n-\t\t\texpectRsqb();\r\n-\t\t}\r\n-\r\n-\t\tif (currentToken == TOK_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn expr.makeNodeSetExpr(statEnv).compose(parseRelativeLocationPath());\r\n-\t\t}\r\n-\t\telse if (currentToken == TOK_SLASH_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn expr.makeNodeSetExpr(statEnv).compose(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\r\n-\t\t}\r\n-\t\telse\r\n-\t\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// Productions #4 and #8\r\n-\t//\r\n-\tprivate ConvertibleNodeSetExprImpl parsePredicates(final AxisExpr axis, final Pattern nodeTest) throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleNodeSetExprImpl expr = axis;\r\n-\t\tif (nodeTest != null)\r\n-\t\t{\r\n-\t\t\texpr = new NodeTestExpr(expr, nodeTest);\r\n-\t\t}\r\n-\t\twhile (currentToken == TOK_LSQB)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new FilterExpr(expr, parseOrExpr().makePredicateExpr(statEnv));\r\n-\t\t\texpectRsqb();\r\n-\t\t}\r\n-\t\treturn axis.makeDocumentOrderExpr(expr);\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #15 PrimaryExpr\r\n-\t// a VariableReference (production #36) OR\r\n-\t// \"(\" Expr \")\" (prod #14) OR\r\n-\t// Literal (prod #29) OR\r\n-\t// Number (prod #30) OR\r\n-\t// FunctionCall (prod #16)\r\n-\t//\r\n-\tprivate ConvertibleExpr parsePrimaryExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr;\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_VARIABLE_REF:\r\n-\t\t\t\t// prod #36\r\n-\t\t\t{\r\n-\t\t\t\tfinal QName name = expandName();\r\n-\t\t\t\tif (statEnv.containsVariable(name))\r\n-\t\t\t\t{\r\n-\t\t\t\t\texpr = new VariableRefExpr(name);\r\n-\t\t\t\t}\r\n-\t\t\t\telse\r\n-\t\t\t\t{\r\n-\t\t\t\t\tthrow new ExprParseException(\"no such variable: \" + name + \" in $\" + currentTokenValue);\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t}\r\n-\r\n-\t\t\tcase TOK_LPAR:\r\n-\t\t\t{\r\n-\t\t\t\t// prod #14\r\n-\t\t\t\tnext();\r\n-\t\t\t\texpr = parseOrExpr();\r\n-\t\t\t\texpectRpar();\r\n-\t\t\t\treturn expr;\r\n-\t\t\t}\r\n-\r\n-\t\t\tcase TOK_LITERAL:\r\n-\t\t\t\t// prod #16 (handled by lexer)\r\n-\t\t\t\texpr = new LiteralExpr(currentTokenValue);\r\n-\t\t\tbreak;\r\n-\r\n-\t\t\tcase TOK_NUMBER:\r\n-\t\t\t\t// prod #30 (handled by lexer)\r\n-\t\t\t\texpr = new NumberConstantExpr(Converter.toNumber(currentTokenValue));\r\n-\t\t\tbreak;\r\n-\r\n-\t\t\tcase TOK_FUNCTION_LPAR:\r\n-\t\t\t\t// production #16 FunctionCall\r\n-\t\t\t{\r\n-\t\t\t\t// try a lookup to find if we have somebody who can make\r\n-\t\t\t\t// a CallExpression\r\n-\t\t\t\tFunction function = functionTable.get(currentTokenValue);\r\n-\r\n-\t\t\t\tif (function == null)\r\n-\t\t\t\t{\r\n-\t\t\t\t\t// \"current()\" is special, because we'll want\r\n-\t\t\t\t\t// to take note of the fact that this expr\r\n-\t\t\t\t\t// uses it\r\n-\t\t\t\t\tif (!currentTokenValue.equals(\"current\"))\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"no such function: \" + currentTokenValue);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"no such function: \" + currentTokenValue);\r\n-\t\t\t\t\t\t// usesCurrentFunction = true;\r\n-\t\t\t\t\t\t// function = currentFunction;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t\tnext();\r\n-\r\n-\t\t\t\treturn function.makeCallExpr(parseArgs(), statEnv);\r\n-\r\n-\t\t\t}\r\n-\r\n-\t\t\t\t// an extension function\r\n-\t\t\tcase TOK_CNAME_LPAR:\r\n-\t\t\t\t// also prod #16 FunctionCall\r\n-\t\t\t{\r\n-\t\t\t\tQName name = expandName();\r\n-\t\t\t\tnext();\r\n-\t\t\t\t// if (XT_NAMESPACE.equals(name.getNamespace()))\r\n-\t\t\t\t// {\r\n-\t\t\t\t//\r\n-\t\t\t\t// // xt: extension functions are constructed and\r\n-\t\t\t\t// // called just like builtin functions, rather\r\n-\t\t\t\t// // than the more loosely coupled extension mechanism\r\n-\t\t\t\t//\r\n-\t\t\t\t// Function function = (Function)extensionFunctionTable.get(name.getLocalPart());\r\n-\t\t\t\t// if (function != null)\r\n-\t\t\t\t// {\r\n-\t\t\t\t// return function.makeCallExpr(parseArgs(), node);\r\n-\t\t\t\t// }\r\n-\t\t\t\t// }\r\n-\t\t\t\tConvertibleExpr[] args = parseArgs();\r\n-\t\t\t\tVariantExpr[] variantArgs = (VariantExpr[])Array.newInstance(VariantExpr.class, args.length);\r\n-\t\t\t\tfor (int i = 0; i < args.length; i++)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tvariantArgs[i] = args[i].makeVariantExpr(statEnv);\r\n-\t\t\t\t}\r\n-\t\t\t\treturn new ExtensionFunctionCallExpr(name, variantArgs);\r\n-\t\t\t}\r\n-\t\t\tdefault:\r\n-\t\t\t{\r\n-\t\t\t\t// TODO: This CFG is not yielding helpful messages.\r\n-\t\t\t\tthrow new ExprParseException(\"Unexpected \\\"\".concat(ExprTokenizer.toString(currentToken)).concat(\"\\\"\"));\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\tnext();\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath Production #24\r\n-\t//\r\n-\t// A RelationalExpr is an AdditiveExpr, possibly\r\n-\t// followed by a comparison operator and another\r\n-\t// RelationalExpr\r\n-\t//\r\n-\tprivate ConvertibleExpr parseRelationalExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parseAdditiveExpr();\r\n-\t\tloop: for (;;)\r\n-\t\t{\r\n-\t\t\tswitch (currentToken)\r\n-\t\t\t{\r\n-\t\t\t\tcase TOK_GT:\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\">\"), expr, parseAdditiveExpr());\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_GTE:\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\">=\"), expr, parseAdditiveExpr());\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_LT:\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\">\"), parseAdditiveExpr(), expr);\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase TOK_LTE:\r\n-\t\t\t\t{\r\n-\t\t\t\t\tnext();\r\n-\t\t\t\t\texpr = makeRelationalExpr(relationTable.get(\">=\"), parseAdditiveExpr(), expr);\r\n-\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\tbreak loop;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// RelativeLocationPath -- XPath production #3\r\n-\t//\r\n-\tprivate ConvertibleNodeSetExpr parseRelativeLocationPath() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleNodeSetExprImpl step = parseStep();\r\n-\t\tif (currentToken == TOK_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn step.compose(parseRelativeLocationPath());\r\n-\t\t}\r\n-\t\tif (currentToken == TOK_SLASH_SLASH)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn step.compose(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\r\n-\t\t}\r\n-\t\treturn step;\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #4\r\n-\t//\r\n-\tprivate ConvertibleNodeSetExprImpl parseStep() throws ExprParseException\r\n-\t{\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_AXIS:\r\n-\t\t\t{\r\n-\t\t\t\tAxisExpr axis = axisTable.get(currentTokenValue);\r\n-\t\t\t\tif (axis == null)\r\n-\t\t\t\t{\r\n-\t\t\t\t\tthrow new ExprParseException(\"no such axis\");\r\n-\t\t\t\t}\r\n-\t\t\t\tnext();\r\n-\t\t\t\treturn parsePredicates(axis, parseNodeTest(axis.getPrincipalNodeKind()));\r\n-\t\t\t}\r\n-\t\t\tcase TOK_DOT:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\treturn axisTable.get(\"self\");\r\n-\t\t\t}\r\n-\t\t\tcase TOK_DOT_DOT:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\treturn axisTable.get(\"parent\");\r\n-\t\t\t}\r\n-\t\t\tcase TOK_AT:\r\n-\t\t\t{\r\n-\t\t\t\tnext();\r\n-\t\t\t\treturn parsePredicates(axisTable.get(\"attribute\"), parseNodeTest(NodeKind.ATTRIBUTE));\r\n-\t\t\t}\r\n-\t\t\tdefault:\r\n-\t\t\t{\r\n-\t\t\t\treturn parsePredicates(axisTable.get(\"child\"), parseNodeTest(NodeKind.ELEMENT));\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #27\r\n-\t//\r\n-\t// we've recognized something which may be a\r\n-\t// unary operator (-) followed by an expression\r\n-\t// or a union expression (or group)\r\n-\t// or a path expression\r\n-\t//\r\n-\tprivate ConvertibleExpr parseUnaryExpr() throws ExprParseException\r\n-\t{\r\n-\t\tif (currentToken == TOK_MINUS)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\treturn new NegateExpr(parseUnaryExpr().makeNumberExpr(statEnv));\r\n-\t\t}\r\n-\t\treturn parseUnionExpr();\r\n-\t}\r\n-\r\n-\t//\r\n-\t// XPath production #18\r\n-\t//\r\n-\t// any expression which may contain alternative\r\n-\t// path expressions (separated by the or operator \"|\")\r\n-\t//\r\n-\tprivate ConvertibleExpr parseUnionExpr() throws ExprParseException\r\n-\t{\r\n-\t\tConvertibleExpr expr = parsePathExpr();\r\n-\t\twhile (currentToken == TOK_VBAR)\r\n-\t\t{\r\n-\t\t\tnext();\r\n-\t\t\texpr = new UnionExpr(expr.makeNodeSetExpr(statEnv), parsePathExpr().makeNodeSetExpr(statEnv));\r\n-\t\t}\r\n-\t\treturn expr;\r\n-\t}\r\n-\r\n-\t//\r\n-\t//\r\n-\tprivate boolean tokenStartsNodeTest()\r\n-\t{\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_QNAME:\r\n-\t\t\tcase TOK_STAR:\r\n-\t\t\tcase TOK_NAME_COLON_STAR:\r\n-\t\t\tcase TOK_PROCESSING_INSTRUCTION_LPAR:\r\n-\t\t\tcase TOK_COMMENT_LPAR:\r\n-\t\t\tcase TOK_TEXT_LPAR:\r\n-\t\t\tcase TOK_NODE_LPAR:\r\n-\t\t\t\treturn true;\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t//\r\n-\t//\r\n-\tprivate boolean tokenStartsStep()\r\n-\t{\r\n-\t\tswitch (currentToken)\r\n-\t\t{\r\n-\t\t\tcase TOK_AXIS:\r\n-\t\t\tcase TOK_DOT:\r\n-\t\t\tcase TOK_DOT_DOT:\r\n-\t\t\tcase TOK_AT:\r\n-\t\t\t\treturn true;\r\n-\t\t}\r\n-\t\treturn tokenStartsNodeTest();\r\n-\t}\r\n-}\r\n+ */\n+\n+final class ExprParser extends ExprTokenizer\n+{\n+    private final ExprContextStatic statEnv;\n+    private final HashMap<String, AxisExpr> axisTable;\n+    private final HashMap<String, Function> functionTable;\n+    private final HashMap<String, Relation> relationTable;\n+\n+    public ExprParser(final String expr, final ExprContextStatic statEnv, final HashMap<String, AxisExpr> axisTable, final HashMap<String, Function> functionTable, final HashMap<String, Relation> relationTable)\n+    {\n+        super(expr);\n+        this.statEnv = statEnv;\n+        this.axisTable = axisTable;\n+        this.functionTable = functionTable;\n+        this.relationTable = relationTable;\n+    }\r\n+\r\n+    //\r\n+    // returns an expanded Name from the qName in\r\n+    // currentTokenValue\r\n+    //\n+\n+    private QName expandName()\n+        throws ExprParseException\n+    {\n+        final int index = currentTokenValue.indexOf(':');\n+        final String prefix = (index == -1) ? XMLConstants.DEFAULT_NS_PREFIX : currentTokenValue.substring(0, index);\n+        final String localName = currentTokenValue.substring(index + 1);\n+        if (prefix.length() > 0)\n+        {\n+            final String ns = statEnv.getNamespace(prefix); // returns null if not bound.\n+            if (ns != null)\n+            {\n+                return new QName(ns, localName, prefix);\n+            }\n+            else\n+            {\n+                throw new ExprParseException(\"prefix '\" + prefix + \"' is not bound to a namespace.\");\n+            }\n+        }\n+        else\n+        {\r\n+            // In XPath 1.0, the default namespace for unqualified QName(s) is the namespace\r\n+            // with a zero-length name. Note that in XPath 2.0 we would distinguish between\r\n+            // function names, element and type names, and even variable names.\n+            return new QName(XMLConstants.NULL_NS_URI, localName, prefix);\n+        }\n+    }\r\n+\r\n+    //\r\n+    // gets the Namespace URI associated with the prefix in\r\n+    // currentTokenValue\r\n+    //\n+\n+    private String expandPrefix()\n+        throws ExprParseException\n+    {\n+        String ns = statEnv.getNamespace(currentTokenValue);\n+        if (ns == null)\n+        {\n+            throw new ExprParseException(\"undefined prefix\");\n+        }\n+        return ns;\n+    }\r\n+\r\n+    //\r\n+    // Checks to ensure that the CurrentToken is ')', then\r\n+    // lexes the next\r\n+    //\n+\n+    private final void expectRpar()\n+        throws ExprParseException\n+    {\n+        if (currentToken != TOK_RPAR)\n+        {\n+            throw new ExprParseException(\"expected )\");\n+        }\n+        next();\n+    }\r\n+\r\n+    //\r\n+    // Checks to ensure that the currentToken is ']', then\r\n+    // lexes the next\r\n+    //\n+\n+    private final void expectRsqb()\n+        throws ExprParseException\n+    {\n+        if (currentToken != TOK_RSQB)\n+        {\n+            throw new ExprParseException(\"expected ]\");\n+        }\n+        next();\n+    }\r\n+\r\n+    /**\r\n+     * A ConvertibleExpr allows for the casting of one type to another for the purpose of making a comparison\r\n+     */\n+\n+    ConvertibleExprImpl makeRelationalExpr(final Relation rel, final ConvertibleExpr e1, final ConvertibleExpr e2)\n+        throws ExprParseException\n+    {\r\n+        // OPT: have some more expressions for non-variant cases\n+        if (e1 instanceof NodeSetExpr || e2 instanceof NodeSetExpr || e1 instanceof VariantExpr || e2 instanceof VariantExpr)\n+        {\n+            return new VariantRelationalExpr(rel, e1.makeVariantExpr(statEnv), e2.makeVariantExpr(statEnv));\n+        }\n+        if (rel instanceof NumericRelation)\n+        {\n+            return new NumberRelationalExpr(rel, e1.makeNumberExpr(statEnv), e2.makeNumberExpr(statEnv));\n+        }\n+        if (e1 instanceof BooleanExpr || e2 instanceof BooleanExpr)\n+        {\n+            return new BooleanRelationalExpr(rel, e1.makeBooleanExpr(statEnv), e2.makeBooleanExpr(statEnv));\n+        }\n+        if (e1 instanceof NumberExpr || e2 instanceof NumberExpr)\n+        {\n+            return new NumberRelationalExpr(rel, e1.makeNumberExpr(statEnv), e2.makeNumberExpr(statEnv));\n+        }\n+        return new StringRelationalExpr(rel, e1.makeStringExpr(statEnv), e2.makeStringExpr(statEnv));\n+    }\r\n+\r\n+    //\r\n+    // XPath production #25 AdditiveExpr\r\n+    //\n+\n+    private ConvertibleExpr parseAdditiveExpr()\n+        throws ExprParseException\n+    {\n+        ConvertibleExpr expr = parseMultiplicativeExpr();\n+        loop:\n+        for (;;)\n+        {\n+            switch (currentToken)\n+            {\n+                case TOK_PLUS:\n+                next();\n+                expr = new AddExpr(expr.makeNumberExpr(statEnv), parseMultiplicativeExpr().makeNumberExpr(statEnv));\n+                break;\n+                case TOK_MINUS:\n+                next();\n+                expr = new SubtractExpr(expr.makeNumberExpr(statEnv), parseMultiplicativeExpr().makeNumberExpr(statEnv));\n+                break;\n+                default:\n+                break loop;\n+            }\n+        }\n+        return expr;\n+    }\r\n+\r\n+    //\r\n+    // XPath production #22\r\n+    //\n+\n+    private ConvertibleExpr parseAndExpr()\n+        throws ExprParseException\n+    {\n+        ConvertibleExpr expr = parseEqualityExpr();\n+        while (currentToken == TOK_AND)\n+        {\n+            next();\n+            expr = new AndExpr(expr.makeBooleanExpr(statEnv), parseEqualityExpr().makeBooleanExpr(statEnv));\n+        }\n+        return expr;\n+    }\r\n+\r\n+    //\r\n+    // parse the zero or more arguments to a function call\r\n+    // XPath Productions #16 FunctionCall, and 17 Argument\r\n+    // Production #17 (Argument) is an Expr (Production #14)\r\n+    // which is in turn an OrExpr (Production #21)\r\n+    //\r\n+    // We return the Arguments as an array of ConvertibleExprs\r\n+    //\n+\n+    private ConvertibleExpr[] parseArgs()\n+        throws ExprParseException\n+    {\n+        if (currentToken == TOK_RPAR)\n+        {\n+            next();\n+            return (ConvertibleExprImpl[])Array.newInstance(ConvertibleExprImpl.class, 0);\n+        }\n+        ConvertibleExpr[] args = (ConvertibleExpr[])Array.newInstance(ConvertibleExprImpl.class, 1);\n+        for (;;)\n+        {\n+            args[args.length - 1] = parseOrExpr();\n+            if (currentToken != TOK_COMMA)\n+            {\n+                break;\n+            }\n+            next();\n+            ConvertibleExpr[] oldArgs = args;\n+            args = (ConvertibleExprImpl[])Array.newInstance(ConvertibleExprImpl.class, oldArgs.length + 1);\n+            System.arraycopy(oldArgs, 0, args, 0, oldArgs.length);\n+        }\n+        expectRpar(); // check currentToken to ensure it's \")\"\n+        return args;\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #23\r\n+    //\n+\n+    private ConvertibleExpr parseEqualityExpr()\n+        throws ExprParseException\n+    {\n+        ConvertibleExpr expr = parseRelationalExpr();\n+        loop:\n+        for (;;)\n+        {\n+            switch (currentToken)\n+            {\n+                case TOK_EQUALS:\n+                next();\n+                expr = makeRelationalExpr(relationTable.get(\"=\"), expr, parseRelationalExpr());\n+                break;\n+                case TOK_NOT_EQUALS:\n+                next();\n+                expr = makeRelationalExpr(relationTable.get(\"!=\"), expr, parseRelationalExpr());\n+                break;\n+                default:\n+                break loop;\n+            }\n+        }\n+        return expr;\n+    }\n+\n+    public ConvertibleExpr parseExpr()\n+        throws ExprParseException\n+    {\n+        next();\n+        ConvertibleExpr expr = parseOrExpr();\n+        if (currentToken != TOK_EOF)\n+        {\n+            throw new ExprParseException(\"unexpected token\");\n+        }\n+        return expr;\n+    }\r\n+\r\n+    //\r\n+    // XPath production #26\r\n+    //\n+\n+    private ConvertibleExpr parseMultiplicativeExpr()\n+        throws ExprParseException\n+    {\r\n+        // get the first part\n+        ConvertibleExpr expr = parseUnaryExpr();\n+        loop:\n+        for (;;)\n+        {\n+            switch (currentToken)\n+            {\n+                case TOK_DIV:\n+                next();\n+                expr = new DivideExpr(expr.makeNumberExpr(statEnv), parseUnaryExpr().makeNumberExpr(statEnv));\n+                break;\n+                case TOK_MOD:\n+                next();\n+                expr = new ModuloExpr(expr.makeNumberExpr(statEnv), parseUnaryExpr().makeNumberExpr(statEnv));\n+                break;\n+                case TOK_MULTIPLY:\n+                next();\n+                expr = new MultiplyExpr(expr.makeNumberExpr(statEnv), parseUnaryExpr().makeNumberExpr(statEnv));\n+                break;\n+                default:\n+                break loop;\n+            }\n+        }\n+        return expr;\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #7\r\n+    //\r\n+    // Compile a node test for an XPath pattern step,\r\n+    // up to, but not including any predicates\r\n+    //\r\n+    // WDL do not return null, even if the test is vacuous (e.g. \"node()\"\r\n+    //\r\n+    // TODO: Here we need the principal node kind.\n+\n+    private PathPatternBase parseNodeTest(final NodeKind principalNodeKind)\n+        throws ExprParseException\n+    {\n+        PathPatternBase nodeTest;\n+\n+        switch (currentToken)\n+        {\n+            case TOK_QNAME:\n+            {\n+                final QName name = expandName();\n+\n+                switch (principalNodeKind)\n+                {\n+                    case ELEMENT:\n+                    {\n+                        nodeTest = new ElementTest(name.getNamespaceURI(), name.getLocalPart());\n+                    }\n+                    break;\n+                    case ATTRIBUTE:\n+                    {\n+                        nodeTest = new AttributeTest(name.getNamespaceURI(), name.getLocalPart());\n+                    }\n+                    break;\n+                    case NAMESPACE:\n+                    {\n+                        nodeTest = new NamespaceTest();\n+                    }\n+                    break;\n+                    default:\n+                    {\n+                        throw new AssertionError(principalNodeKind);\n+                    }\n+                }\n+            }\n+            break;\n+            case TOK_STAR:\n+            {\n+                switch (principalNodeKind)\n+                {\n+                    case ELEMENT:\n+                    {\n+                        nodeTest = new NodeTypeTest(NodeKind.ELEMENT);\n+                    }\n+                    break;\n+                    case ATTRIBUTE:\n+                    {\n+                        nodeTest = null;\n+                    }\n+                    break;\n+                    case NAMESPACE:\n+                    {\n+                        nodeTest = null;\n+                    }\n+                    break;\n+                    default:\n+                    {\n+                        throw new AssertionError(principalNodeKind);\n+                    }\n+                }\n+            }\n+            break;\n+            case TOK_NAME_COLON_STAR:\n+            {\n+                switch (principalNodeKind)\n+                {\n+                    case ELEMENT:\n+                    {\n+                        nodeTest = new ElementTest(expandPrefix(), null);\n+                    }\n+                    break;\n+                    case ATTRIBUTE:\n+                    {\n+                        nodeTest = new AttributeTest(expandPrefix(), null);\n+                    }\n+                    break;\n+                    case NAMESPACE:\n+                    {\n+                        nodeTest = new NamespaceTest();\n+                    }\n+                    break;\n+                    default:\n+                    {\n+                        throw new AssertionError(principalNodeKind);\n+                    }\n+                }\n+            }\n+            break;\n+            case TOK_PROCESSING_INSTRUCTION_LPAR:\n+            {\n+                next();\n+                if (currentToken == TOK_LITERAL)\n+                {\n+                    nodeTest = new ProcessingInstructionTest(expandName().getLocalPart());\n+                    next();\n+                }\n+                else\n+                {\n+                    nodeTest = new NodeTypeTest(NodeKind.PROCESSING_INSTRUCTION);\n+                }\n+                expectRpar();\n+                return nodeTest;\n+            }\n+            case TOK_COMMENT_LPAR:\n+            {\n+                next();\n+                expectRpar();\n+                return new NodeTypeTest(NodeKind.COMMENT);\n+            }\n+            case TOK_TEXT_LPAR: // text()\n+            {\n+                next();\n+                expectRpar();\n+                return new NodeTypeTest(NodeKind.TEXT);\n+            }\n+            case TOK_NODE_LPAR: // node()\n+            {\n+                next();\n+                expectRpar();\n+                switch (principalNodeKind)\n+                {\n+                    case ELEMENT:\n+                    {\n+                        return new NodeTypeTest(null);\n+                    }\n+                    case ATTRIBUTE:\n+                    {\n+                        return new NodeTypeTest(NodeKind.ATTRIBUTE);\n+                    }\n+                    case NAMESPACE:\n+                    {\n+                        return new NodeTypeTest(NodeKind.NAMESPACE);\n+                    }\n+                    default:\n+                    {\n+                        throw new AssertionError(principalNodeKind);\n+                    }\n+                }\n+            }\n+            default:\n+            {\n+                throw new ExprParseException(\"expected node test\");\n+            }\n+        }\n+        next();\n+        return nodeTest;\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #21\r\n+    //\n+\n+    private ConvertibleExpr parseOrExpr()\n+        throws ExprParseException\n+    {\n+        ConvertibleExpr expr = parseAndExpr();\n+        while (currentToken == TOK_OR)\n+        {\n+            next();\n+            expr = new OrExpr(expr.makeBooleanExpr(statEnv), parseAndExpr().makeBooleanExpr(statEnv));\n+        }\n+        return expr;\n+    }\r\n+\r\n+    //\r\n+    // XPath production #19\r\n+    //\n+\n+    private ConvertibleExpr parsePathExpr()\n+        throws ExprParseException\n+    {\n+        if (tokenStartsStep())\n+        {\n+            return parseRelativeLocationPath(); // XPath production #3\n+        }\n+        if (currentToken == TOK_SLASH)\n+        {\n+            next();\n+            if (tokenStartsStep())\n+            {\r\n+                // XPath production #2\n+                return new RootExpr(parseRelativeLocationPath());\n+            }\r\n+            // the root, by itself\n+            return new RootExpr(axisTable.get(\"self\"));\n+        }\n+        if (currentToken == TOK_SLASH_SLASH)\n+        {\r\n+\r\n+            // abbreviated absolute location XPath production #10\n+            next();\n+            return new RootExpr(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\n+        }\r\n+\r\n+        //\r\n+        // if none of the above alternatives, we should be looking\r\n+        // at a FilterExpression (production #20) followed by\r\n+        // either a \"/\" or \"//\", and then a RelativeLocationPath\r\n+        // (production #3)\r\n+        //\n+        ConvertibleExpr expr = parsePrimaryExpr();\r\n+\r\n+        // Production 20 requires at least one primary expression\r\n+        // and any number of predicates\r\n+        // the TOK_LSQB (\"[\") starts a predicate\n+        while (currentToken == TOK_LSQB)\n+        {\n+            next();\n+            expr = new FilterExpr(expr.makeNodeSetExpr(statEnv), parseOrExpr().makePredicateExpr(statEnv));\n+            expectRsqb();\n+        }\n+        if (currentToken == TOK_SLASH)\n+        {\n+            next();\n+            return expr.makeNodeSetExpr(statEnv).compose(parseRelativeLocationPath());\n+        }\n+        else if (currentToken == TOK_SLASH_SLASH)\n+        {\n+            next();\n+            return expr.makeNodeSetExpr(statEnv).compose(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\n+        }\n+        else\n+        return expr;\n+    }\r\n+\r\n+    //\r\n+    // Productions #4 and #8\r\n+    //\n+\n+    private ConvertibleNodeSetExprImpl parsePredicates(final AxisExpr axis, final Pattern nodeTest)\n+        throws ExprParseException\n+    {\n+        ConvertibleNodeSetExprImpl expr = axis;\n+        if (nodeTest != null)\n+        {\n+            expr = new NodeTestExpr(expr, nodeTest);\n+        }\n+\n+        while (currentToken == TOK_LSQB)\n+        {\n+            next();\n+            expr = new FilterExpr(expr, parseOrExpr().makePredicateExpr(statEnv));\n+            expectRsqb();\n+        }\n+        return axis.makeDocumentOrderExpr(expr);\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #15 PrimaryExpr\r\n+    // a VariableReference (production #36) OR\r\n+    // \"(\" Expr \")\" (prod #14) OR\r\n+    // Literal (prod #29) OR\r\n+    // Number (prod #30) OR\r\n+    // FunctionCall (prod #16)\r\n+    //\n+\n+    private ConvertibleExpr parsePrimaryExpr()\n+        throws ExprParseException\n+    {\n+        ConvertibleExpr expr;\n+\n+        switch (currentToken)\n+        {\n+            case TOK_VARIABLE_REF:\r\n+                // prod #36\n+            {\n+                final QName name = expandName();\n+                if (statEnv.containsVariable(name))\n+                {\n+                    expr = new VariableRefExpr(name);\n+                }\n+                else\n+                {\n+                    throw new ExprParseException(\"no such variable: \" + name + \" in $\" + currentTokenValue);\n+                }\n+                break;\n+            }\n+            case TOK_LPAR:\n+            {\r\n+                // prod #14\n+                next();\n+                expr = parseOrExpr();\n+                expectRpar();\n+                return expr;\n+            }\n+            case TOK_LITERAL:\r\n+                // prod #16 (handled by lexer)\n+            expr = new LiteralExpr(currentTokenValue);\n+            break;\n+            case TOK_NUMBER:\r\n+                // prod #30 (handled by lexer)\n+            expr = new NumberConstantExpr(Converter.toNumber(currentTokenValue));\n+            break;\n+            case TOK_FUNCTION_LPAR:\r\n+                // production #16 FunctionCall\n+            {\r\n+                // try a lookup to find if we have somebody who can make\r\n+                // a CallExpression\n+                Function function = functionTable.get(currentTokenValue);\n+                if (function == null)\n+                {\r\n+                    // \"current()\" is special, because we'll want\r\n+                    // to take note of the fact that this expr\r\n+                    // uses it\n+                    if (!currentTokenValue.equals(\"current\"))\n+                    {\n+                        throw new ExprParseException(\"no such function: \" + currentTokenValue);\n+                    }\n+                    else\n+                    {\n+                        throw new ExprParseException(\"no such function: \" + currentTokenValue);\r\n+                        // usesCurrentFunction = true;\r\n+                        // function = currentFunction;\n+                    }\n+                }\n+                next();\n+                return function.makeCallExpr(parseArgs(), statEnv);\n+            }\r\n+\r\n+                // an extension function\n+            case TOK_CNAME_LPAR:\r\n+                // also prod #16 FunctionCall\n+            {\n+                QName name = expandName();\n+                next();\r\n+                // if (XT_NAMESPACE.equals(name.getNamespace()))\r\n+                // {\r\n+                //\r\n+                // // xt: extension functions are constructed and\r\n+                // // called just like builtin functions, rather\r\n+                // // than the more loosely coupled extension mechanism\r\n+                //\r\n+                // Function function = (Function)extensionFunctionTable.get(name.getLocalPart());\r\n+                // if (function != null)\r\n+                // {\r\n+                // return function.makeCallExpr(parseArgs(), node);\r\n+                // }\r\n+                // }\n+                ConvertibleExpr[] args = parseArgs();\n+                VariantExpr[] variantArgs = (VariantExpr[])Array.newInstance(VariantExpr.class, args.length);\n+                for (int i = 0; i < args.length; i++)\n+                {\n+                    variantArgs[i] = args[i].makeVariantExpr(statEnv);\n+                }\n+                return new ExtensionFunctionCallExpr(name, variantArgs);\n+            }\n+            default:\n+            {\r\n+                // TODO: This CFG is not yielding helpful messages.\n+                throw new ExprParseException(\"Unexpected \\\"\".concat(ExprTokenizer.toString(currentToken)).concat(\"\\\"\"));\n+            }\n+        }\n+        next();\n+        return expr;\n+    }\r\n+\r\n+    //\r\n+    // XPath Production #24\r\n+    //\r\n+    // A RelationalExpr is an AdditiveExpr, possibly\r\n+    // followed by a comparison operator and another\r\n+    // RelationalExpr\r\n+    //\n+\n+    private ConvertibleExpr parseRelationalExpr()\n+        throws ExprParseException\n+    {\n+        ConvertibleExpr expr = parseAdditiveExpr();\n+        loop:\n+        for (;;)\n+        {\n+            switch (currentToken)\n+            {\n+                case TOK_GT:\n+                {\n+                    next();\n+                    expr = makeRelationalExpr(relationTable.get(\">\"), expr, parseAdditiveExpr());\n+                }\n+                break;\n+                case TOK_GTE:\n+                {\n+                    next();\n+                    expr = makeRelationalExpr(relationTable.get(\">=\"), expr, parseAdditiveExpr());\n+                }\n+                break;\n+                case TOK_LT:\n+                {\n+                    next();\n+                    expr = makeRelationalExpr(relationTable.get(\">\"), parseAdditiveExpr(), expr);\n+                }\n+                break;\n+                case TOK_LTE:\n+                {\n+                    next();\n+                    expr = makeRelationalExpr(relationTable.get(\">=\"), parseAdditiveExpr(), expr);\n+                }\n+                break;\n+                default:\n+                break loop;\n+            }\n+        }\n+        return expr;\n+    }\r\n+\r\n+    //\r\n+    // RelativeLocationPath -- XPath production #3\r\n+    //\n+\n+    private ConvertibleNodeSetExpr parseRelativeLocationPath()\n+        throws ExprParseException\n+    {\n+        ConvertibleNodeSetExprImpl step = parseStep();\n+        if (currentToken == TOK_SLASH)\n+        {\n+            next();\n+            return step.compose(parseRelativeLocationPath());\n+        }\n+        if (currentToken == TOK_SLASH_SLASH)\n+        {\n+            next();\n+            return step.compose(axisTable.get(\"descendant-or-self\").compose(parseRelativeLocationPath()));\n+        }\n+        return step;\n+    }\r\n+\r\n+    //\r\n+    // XPath production #4\r\n+    //\n+\n+    private ConvertibleNodeSetExprImpl parseStep()\n+        throws ExprParseException\n+    {\n+        switch (currentToken)\n+        {\n+            case TOK_AXIS:\n+            {\n+                AxisExpr axis = axisTable.get(currentTokenValue);\n+                if (axis == null)\n+                {\n+                    throw new ExprParseException(\"no such axis\");\n+                }\n+                next();\n+                return parsePredicates(axis, parseNodeTest(axis.getPrincipalNodeKind()));\n+            }\n+            case TOK_DOT:\n+            {\n+                next();\n+                return axisTable.get(\"self\");\n+            }\n+            case TOK_DOT_DOT:\n+            {\n+                next();\n+                return axisTable.get(\"parent\");\n+            }\n+            case TOK_AT:\n+            {\n+                next();\n+                return parsePredicates(axisTable.get(\"attribute\"), parseNodeTest(NodeKind.ATTRIBUTE));\n+            }\n+            default:\n+            {\n+                return parsePredicates(axisTable.get(\"child\"), parseNodeTest(NodeKind.ELEMENT));\n+            }\n+        }\n+    }\r\n+\r\n+    //\r\n+    // XPath production #27\r\n+    //\r\n+    // we've recognized something which may be a\r\n+    // unary operator (-) followed by an expression\r\n+    // or a union expression (or group)\r\n+    // or a path expression\r\n+    //\n+\n+    private ConvertibleExpr parseUnaryExpr()\n+        throws ExprParseException\n+    {\n+        if (currentToken == TOK_MINUS)\n+        {\n+            next();\n+            return new NegateExpr(parseUnaryExpr().makeNumberExpr(statEnv));\n+        }\n+        return parseUnionExpr();\n+    }\r\n+\r\n+    //\r\n+    // XPath production #18\r\n+    //\r\n+    // any expression which may contain alternative\r\n+    // path expressions (separated by the or operator \"|\")\r\n+    //\n+\n+    private ConvertibleExpr parseUnionExpr()\n+        throws ExprParseException\n+    {\n+        ConvertibleExpr expr = parsePathExpr();\n+        while (currentToken == TOK_VBAR)\n+        {\n+            next();\n+            expr = new UnionExpr(expr.makeNodeSetExpr(statEnv), parsePathExpr().makeNodeSetExpr(statEnv));\n+        }\n+        return expr;\n+    }\r\n+\r\n+    //\r\n+    //\n+\n+    private boolean tokenStartsNodeTest()\n+    {\n+        switch (currentToken)\n+        {\n+            case TOK_QNAME:\n+            case TOK_STAR:\n+            case TOK_NAME_COLON_STAR:\n+            case TOK_PROCESSING_INSTRUCTION_LPAR:\n+            case TOK_COMMENT_LPAR:\n+            case TOK_TEXT_LPAR:\n+            case TOK_NODE_LPAR:\n+                return true;\n+        }\n+        return false;\n+    }\r\n+\r\n+    //\r\n+    //\n+\n+    private boolean tokenStartsStep()\n+    {\n+        switch (currentToken)\n+        {\n+            case TOK_AXIS:\n+            case TOK_DOT:\n+            case TOK_DOT_DOT:\n+            case TOK_AT:\n+                return true;\n+        }\n+        return tokenStartsNodeTest();\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 850
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "57",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/158/ExprParser.java\nindex 2c7d53b6fed..1a97da540d0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/158/ExprParser.java\n@@ -53,7 +53,7 @@ import org.genxdm.xpath.v10.extend.ConvertibleNodeSetExpr;\n final class ExprParser \r\n     extends ExprTokenizer\r\n {\r\n-\tprivate final ExprContextStatic statEnv;\r\n+private final ExprContextStatic statEnv;\r\n \tprivate final HashMap<String, AxisExpr> axisTable;\r\n \tprivate final HashMap<String, Function> functionTable;\r\n \tprivate final HashMap<String, Relation> relationTable;\r\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "57",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/158/ExprParser.java\nindex 2c7d53b6fed..8670912b0a4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/158/ExprParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/158/ExprParser.java\n@@ -53,7 +53,7 @@ import org.genxdm.xpath.v10.extend.ConvertibleNodeSetExpr;\n final class ExprParser \r\n     extends ExprTokenizer\r\n {\r\n-\tprivate final ExprContextStatic statEnv;\r\n+    private final ExprContextStatic statEnv;\r\n \tprivate final HashMap<String, AxisExpr> axisTable;\r\n \tprivate final HashMap<String, Function> functionTable;\r\n \tprivate final HashMap<String, Relation> relationTable;\r\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}