{
    "project_name": "findbugsproject-findbugs",
    "error_id": "4",
    "information": {
        "errors": [
            {
                "line": "1023",
                "column": "13",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            InstructionHandle prev = handle.getPrev();\n            while(prev != null && prev.getInstruction().getOpcode() == Constants.DUP) {\n            \t// Some compilers generate DUP for field increment code like\n            \t// ALOAD_0 / DUP / GETFIELD x / ICONST_1 / IADD / PUTFIELD x\n                prev = prev.getPrev();\n            }",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1032",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/4/BetterCFGBuilder2.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/4/BetterCFGBuilder2.java\nindex c01bb2174a8..8e6a6209490 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/4/BetterCFGBuilder2.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/4/BetterCFGBuilder2.java\n@@ -1020,8 +1020,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n             // Assume that GETFIELD on this object is not PEI\n             InstructionHandle prev = handle.getPrev();\n             while(prev != null && prev.getInstruction().getOpcode() == Constants.DUP) {\n-            \t// Some compilers generate DUP for field increment code like\n-            \t// ALOAD_0 / DUP / GETFIELD x / ICONST_1 / IADD / PUTFIELD x\n+            // Some compilers generate DUP for field increment code like\n+             // ALOAD_0 / DUP / GETFIELD x / ICONST_1 / IADD / PUTFIELD x\n                 prev = prev.getPrev();\n             }\n             if(prev != null && prev.getInstruction().getOpcode() == Constants.ALOAD_0) {\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/4/BetterCFGBuilder2.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/4/BetterCFGBuilder2.java\nindex c01bb2174a8..f4a65ff4544 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/4/BetterCFGBuilder2.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/4/BetterCFGBuilder2.java\n@@ -111,10 +111,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Constructor.\n          *\n-         * @param start\n-         *            first instruction in the basic block\n-         * @param basicBlock\n-         *            the basic block to build\n+         * @param start      first instruction in the basic block\n+         * @param basicBlock the basic block to build\n          */\n         public WorkListItem(InstructionHandle start, BasicBlock basicBlock) {\n             this.start = start;\n@@ -150,11 +148,9 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Constructor.\n          *\n-         * @param target\n-         *            the target instruction in a calling subroutine\n-         * @param edgeType\n-         *            the type of edge that should be created when the\n-         *            subroutine is inlined into its calling context\n+         * @param target   the target instruction in a calling subroutine\n+         * @param edgeType the type of edge that should be created when the\n+         *                 subroutine is inlined into its calling context\n          */\n         public EscapeTarget(InstructionHandle target, @Edge.Type int edgeType) {\n             this.target = target;\n@@ -205,8 +201,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Constructor.\n          *\n-         * @param start\n-         *            the start instruction for the subroutine\n+         * @param start the start instruction for the subroutine\n          */\n         public Subroutine(InstructionHandle start) {\n             this.start = start;\n@@ -289,8 +284,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * instructions are part of which subroutines. No instruction may be\n          * part of more than one subroutine.\n          *\n-         * @param handle\n-         *            the instruction to be added to the subroutine\n+         * @param handle the instruction to be added to the subroutine\n          */\n         public void addInstruction(InstructionHandle handle) throws CFGBuilderException {\n             int position = handle.getPosition();\n@@ -314,8 +308,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * added which will populate it. Note that if start is an exception\n          * thrower, the block returned will be its ETB.\n          *\n-         * @param start\n-         *            the start instruction for the block\n+         * @param start the start instruction for the block\n          * @return the basic block for the instruction\n          */\n         public BasicBlock getBlock(InstructionHandle start) {\n@@ -338,8 +331,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Indicate that the method returns at the end of the given block.\n          *\n-         * @param block\n-         *            the returning block\n+         * @param block the returning block\n          */\n         public void setReturnBlock(BasicBlock block) {\n             returnBlockSet.set(block.getLabel());\n@@ -355,8 +347,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Indicate that System.exit() is called at the end of the given block.\n          *\n-         * @param block\n-         *            the exiting block\n+         * @param block the exiting block\n          */\n         public void setExitBlock(BasicBlock block) {\n             exitBlockSet.set(block.getLabel());\n@@ -373,8 +364,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * Indicate that an unhandled exception may be thrown by the given\n          * block.\n          *\n-         * @param block\n-         *            the block throwing an unhandled exception\n+         * @param block the block throwing an unhandled exception\n          */\n         public void setUnhandledExceptionBlock(BasicBlock block) {\n             unhandledExceptionBlockSet.set(block.getLabel());\n@@ -393,12 +383,9 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * If the control target is in another subroutine, an EscapeTarget is\n          * added.\n          *\n-         * @param sourceBlock\n-         *            the source basic block\n-         * @param target\n-         *            the control target\n-         * @param edgeType\n-         *            the type of control edge\n+         * @param sourceBlock the source basic block\n+         * @param target      the control target\n+         * @param edgeType    the type of control edge\n          */\n         public void addEdgeAndExplore(BasicBlock sourceBlock, InstructionHandle target, @Edge.Type int edgeType) {\n             if (usedInstructionSet.get(target.getPosition()) && !containsInstruction(target)) {\n@@ -419,19 +406,16 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Add an edge to the subroutine's CFG.\n          *\n-         * @param sourceBlock\n-         *            the source basic block\n-         * @param destBlock\n-         *            the destination basic block\n-         * @param edgeType\n-         *            the type of edge\n+         * @param sourceBlock the source basic block\n+         * @param destBlock   the destination basic block\n+         * @param edgeType    the type of edge\n          */\n         public void addEdge(BasicBlock sourceBlock, BasicBlock destBlock, @Edge.Type int edgeType) {\n             if (VERIFY_INTEGRITY) {\n                 if (destBlock.isExceptionHandler() && edgeType != HANDLED_EXCEPTION_EDGE) {\n                     throw new IllegalStateException(\"In method \" + SignatureConverter.convertMethodSignature(methodGen)\n-                            + \": exception handler \" + destBlock.getFirstInstruction() + \" reachable by non exception edge type \"\n-                            + edgeType);\n+                        + \": exception handler \" + destBlock.getFirstInstruction() + \" reachable by non exception edge type \"\n+                        + edgeType);\n                 }\n             }\n             cfgSub.createEdge(sourceBlock, destBlock, edgeType);\n@@ -440,8 +424,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get an Iterator over the EscapeTargets of given basic block.\n          *\n-         * @param sourceBlock\n-         *            the basic block\n+         * @param sourceBlock the basic block\n          * @return an Iterator over the EscapeTargets\n          */\n         public Iterator<EscapeTarget> escapeTargetIterator(BasicBlock sourceBlock) {\n@@ -472,12 +455,9 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Constructor.\n          *\n-         * @param caller\n-         *            the calling context\n-         * @param subroutine\n-         *            the subroutine being inlined\n-         * @param result\n-         *            the result CFG\n+         * @param caller     the calling context\n+         * @param subroutine the subroutine being inlined\n+         * @param result     the result CFG\n          */\n         public Context(@Nullable Context caller, Subroutine subroutine, CFG result) {\n             this.caller = caller;\n@@ -511,9 +491,9 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Add a basic block to the inlining work list.\n          *\n-        public void addItem(BasicBlock item) {\n-            workList.add(item);\n-        }*/\n+         public void addItem(BasicBlock item) {\n+         workList.add(item);\n+         }*/\n \n         /**\n          * Are there more work list items?\n@@ -533,10 +513,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * Map a basic block in a subroutine to the corresponding block in the\n          * resulting CFG.\n          *\n-         * @param subBlock\n-         *            the subroutine block\n-         * @param resultBlock\n-         *            the result CFG block\n+         * @param subBlock    the subroutine block\n+         * @param resultBlock the result CFG block\n          */\n         public void mapBlock(BasicBlock subBlock, BasicBlock resultBlock) {\n             blockMap.put(subBlock, resultBlock);\n@@ -546,8 +524,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * Get the block in the result CFG corresponding to the given subroutine\n          * block.\n          *\n-         * @param subBlock\n-         *            the subroutine block\n+         * @param subBlock the subroutine block\n          * @return the result CFG block\n          */\n         public BasicBlock getBlock(BasicBlock subBlock) {\n@@ -607,8 +584,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n     /**\n      * Constructor.\n      *\n-     * @param methodGen\n-     *            the method to build a CFG for\n+     * @param methodGen the method to build a CFG for\n      */\n     public BetterCFGBuilder2(@Nonnull MethodDescriptor descriptor, @Nonnull MethodGen methodGen) {\n         this.methodGen = methodGen;\n@@ -618,8 +594,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         ExceptionSetFactory exceptionSetFactory;\n         try {\n             exceptionSetFactory = analysisCache.getMethodAnalysis(ExceptionSetFactory.class, descriptor);\n-            merger = new StandardTypeMerger( AnalysisContext.currentAnalysisContext()\n-                    .getLookupFailureCallback(), exceptionSetFactory);\n+            merger = new StandardTypeMerger(AnalysisContext.currentAnalysisContext()\n+                .getLookupFailureCallback(), exceptionSetFactory);\n         } catch (CheckedAnalysisException e) {\n             AnalysisContext.logError(\"Unable to generate exceptionSetFactory for \" + descriptor, e);\n         }\n@@ -641,6 +617,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         return index;\n \n     }\n+\n     public void optimize(InstructionList instructionList) {\n         InstructionHandle head = instructionList.getStart();\n \n@@ -710,17 +687,17 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                         break;\n                     }\n                     InstructionHandle next3 = next2.getNext(); // ICONST\n-                    if (next3== null) {\n+                    if (next3 == null) {\n                         break;\n                     }\n                     InstructionHandle next4 = next3.getNext();\n                     if (next4 == null) {\n                         break;\n                     }\n-                    if (target.equals(next3)  && next2.getInstruction() instanceof GOTO\n-                            && next3.getInstruction() instanceof ICONST && next1.getTargeters().length == 0\n-                            && next2.getTargeters().length == 0 && next3.getTargeters().length == 1\n-                            && next4.getTargeters().length == 1) {\n+                    if (target.equals(next3) && next2.getInstruction() instanceof GOTO\n+                        && next3.getInstruction() instanceof ICONST && next1.getTargeters().length == 0\n+                        && next2.getTargeters().length == 0 && next3.getTargeters().length == 1\n+                        && next4.getTargeters().length == 1) {\n                         int c1 = ((ICONST) next1.getInstruction()).getValue().intValue();\n                         GOTO g = (GOTO) next2.getInstruction();\n                         int c2 = ((ICONST) next3.getInstruction()).getValue().intValue();\n@@ -820,8 +797,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * instructions are encountered, new Subroutines are added to the subroutine\n      * work list.\n      *\n-     * @param subroutine\n-     *            the subroutine\n+     * @param subroutine the subroutine\n      */\n     private void build(Subroutine subroutine) throws CFGBuilderException {\n         // Prime the work list\n@@ -940,12 +916,9 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n     /**\n      * Add exception edges for given instruction.\n      *\n-     * @param subroutine\n-     *            the subroutine containing the instruction\n-     * @param pei\n-     *            the instruction which throws an exception\n-     * @param etb\n-     *            the exception thrower block (ETB) for the instruction\n+     * @param subroutine the subroutine containing the instruction\n+     * @param pei        the instruction which throws an exception\n+     * @param etb        the exception thrower block (ETB) for the instruction\n      */\n     private void handleExceptions(Subroutine subroutine, InstructionHandle pei, BasicBlock etb) {\n         etb.setExceptionThrower(pei);\n@@ -982,8 +955,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n     /**\n      * Return whether or not the given instruction can throw exceptions.\n      *\n-     * @param handle\n-     *            the instruction\n+     * @param handle the instruction\n      * @return true if the instruction can throw an exception, false otherwise\n      * @throws CFGBuilderException\n      */\n@@ -1019,25 +991,25 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         if (ins instanceof GETFIELD && !methodGen.isStatic()) {\n             // Assume that GETFIELD on this object is not PEI\n             InstructionHandle prev = handle.getPrev();\n-            while(prev != null && prev.getInstruction().getOpcode() == Constants.DUP) {\n-            \t// Some compilers generate DUP for field increment code like\n-            \t// ALOAD_0 / DUP / GETFIELD x / ICONST_1 / IADD / PUTFIELD x\n+            while (prev != null && prev.getInstruction().getOpcode() == Constants.DUP) {\n+                // Some compilers generate DUP for field increment code like\n+                // ALOAD_0 / DUP / GETFIELD x / ICONST_1 / IADD / PUTFIELD x\n                 prev = prev.getPrev();\n             }\n-            if(prev != null && prev.getInstruction().getOpcode() == Constants.ALOAD_0) {\n+            if (prev != null && prev.getInstruction().getOpcode() == Constants.ALOAD_0) {\n                 return false;\n             }\n         }\n         if (ins instanceof PUTFIELD && !methodGen.isStatic()) {\n-        \t// Assume that PUTFIELD on this object is not PEI\n+            // Assume that PUTFIELD on this object is not PEI\n             int depth = 2;\n-            for(InstructionHandle prev = handle.getPrev(); prev != null; prev = prev.getPrev()) {\n+            for (InstructionHandle prev = handle.getPrev(); prev != null; prev = prev.getPrev()) {\n                 Instruction prevInst = prev.getInstruction();\n-                if(prevInst instanceof BranchInstruction) {\n-                    if(prevInst instanceof GotoInstruction) {\n+                if (prevInst instanceof BranchInstruction) {\n+                    if (prevInst instanceof GotoInstruction) {\n                         // Currently we support only jumps to the PUTFIELD itself\n                         // This will cover simple cases like this.a = flag ? foo : bar\n-                        if(((BranchInstruction) prevInst).getTarget() == handle) {\n+                        if (((BranchInstruction) prevInst).getTarget() == handle) {\n                             depth = 2;\n                         } else {\n                             return true;\n@@ -1049,10 +1021,10 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                     }\n                 }\n                 depth = depth - prevInst.produceStack(cpg) + prevInst.consumeStack(cpg);\n-                if(depth < 0) {\n-                    throw new CFGBuilderException(\"Invalid stack at \"+prev+\" when checking \"+handle);\n+                if (depth < 0) {\n+                    throw new CFGBuilderException(\"Invalid stack at \" + prev + \" when checking \" + handle);\n                 }\n-                if(depth == 0) {\n+                if (depth == 0) {\n                     return prevInst.getOpcode() != Constants.ALOAD_0;\n                 }\n             }\n@@ -1064,8 +1036,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n     /**\n      * Determine whether or not the given instruction is a control flow merge.\n      *\n-     * @param handle\n-     *            the instruction\n+     * @param handle the instruction\n      * @return true if the instruction is a control merge, false otherwise\n      */\n     private static boolean isMerge(InstructionHandle handle) {\n@@ -1107,8 +1078,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n     /**\n      * Inline a subroutine into a calling context.\n      *\n-     * @param context\n-     *            the Context\n+     * @param context the Context\n      */\n     public void inline(Context context) throws CFGBuilderException {\n \n@@ -1201,7 +1171,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n \n                 if (caller == null) {\n                     throw new CFGBuilderException(\"Unknown caller for escape target \" + targetInstruction + \" referenced by \"\n-                            + context.getSubroutine().getStartInstruction());\n+                        + context.getSubroutine().getStartInstruction());\n                 }\n \n                 // Find result block in caller\n",
            "diff_size": 89
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/4/BetterCFGBuilder2.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/codebuff/4/BetterCFGBuilder2.java\nindex c01bb2174a8..8b926e2b2bf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/4/BetterCFGBuilder2.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/codebuff/4/BetterCFGBuilder2.java\n@@ -27,10 +27,8 @@ import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-\n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n-\n import org.apache.bcel.Constants;\n import org.apache.bcel.classfile.ClassParser;\n import org.apache.bcel.classfile.JavaClass;\n@@ -69,7 +67,6 @@ import org.apache.bcel.generic.POP2;\n import org.apache.bcel.generic.PUTFIELD;\n import org.apache.bcel.generic.PUTSTATIC;\n import org.apache.bcel.generic.ReturnInstruction;\n-\n import edu.umd.cs.findbugs.SystemProperties;\n import edu.umd.cs.findbugs.ba.type.ExceptionSetFactory;\n import edu.umd.cs.findbugs.ba.type.StandardTypeMerger;\n@@ -90,8 +87,8 @@ import edu.umd.cs.findbugs.classfile.MethodDescriptor;\n  * @author David Hovemeyer\n  * @see CFG\n  */\n-public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n \n+public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n     private static final boolean DEBUG = SystemProperties.getBoolean(\"cfgbuilder.debug\");\n \n     /*\n@@ -103,6 +100,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n     /**\n      * A work list item for creating the CFG for a subroutine.\n      */\n+\n     private static class WorkListItem {\n         private final InstructionHandle start;\n \n@@ -116,6 +114,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param basicBlock\n          *            the basic block to build\n          */\n+\n+\n         public WorkListItem(InstructionHandle start, BasicBlock basicBlock) {\n             this.start = start;\n             this.basicBlock = basicBlock;\n@@ -124,6 +124,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the start instruction.\n          */\n+\n+\n         public InstructionHandle getStartInstruction() {\n             return start;\n         }\n@@ -131,6 +133,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the basic block.\n          */\n+\n         public BasicBlock getBasicBlock() {\n             return basicBlock;\n         }\n@@ -141,6 +144,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * control back to an outer (calling) subroutine. It will turn into a real\n      * edge during inlining.\n      */\n+\n+\n     private static class EscapeTarget {\n         private final InstructionHandle target;\n \n@@ -156,6 +161,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          *            the type of edge that should be created when the\n          *            subroutine is inlined into its calling context\n          */\n+\n+\n         public EscapeTarget(InstructionHandle target, @Edge.Type int edgeType) {\n             this.target = target;\n             this.edgeType = edgeType;\n@@ -164,6 +171,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the target instruction.\n          */\n+\n+\n         public InstructionHandle getTarget() {\n             return target;\n         }\n@@ -171,6 +180,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the edge type.\n          */\n+\n         public @Edge.Type\n         int getEdgeType() {\n             return edgeType;\n@@ -183,6 +193,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * inlined into the top level subroutine, resulting in an accurate CFG for\n      * the overall method.\n      */\n+\n+\n     private class Subroutine {\n         private final InstructionHandle start;\n \n@@ -208,6 +220,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param start\n          *            the start instruction for the subroutine\n          */\n+\n+\n         public Subroutine(InstructionHandle start) {\n             this.start = start;\n             this.instructionSet = new BitSet();\n@@ -223,6 +237,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the start instruction.\n          */\n+\n+\n         public InstructionHandle getStartInstruction() {\n             return start;\n         }\n@@ -230,6 +246,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Allocate a new basic block in the subroutine.\n          */\n+\n         public BasicBlock allocateBasicBlock() {\n             return cfgSub.allocate();\n         }\n@@ -237,6 +254,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Add a work list item for a basic block to be constructed.\n          */\n+\n         public void addItem(WorkListItem item) {\n             workList.add(item);\n         }\n@@ -244,6 +262,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Are there more work list items?\n          */\n+\n         public boolean hasMoreWork() {\n             return !workList.isEmpty();\n         }\n@@ -251,6 +270,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the next work list item.\n          */\n+\n         public WorkListItem nextItem() {\n             return workList.removeFirst();\n         }\n@@ -258,6 +278,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the entry block for the subroutine's CFG.\n          */\n+\n         public BasicBlock getEntry() {\n             return cfgSub.getEntry();\n         }\n@@ -265,6 +286,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the exit block for the subroutine's CFG.\n          */\n+\n         public BasicBlock getExit() {\n             return cfgSub.getExit();\n         }\n@@ -273,6 +295,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * Get the start block for the subroutine's CFG. (I.e., the block\n          * containing the start instruction.)\n          */\n+\n         public BasicBlock getStartBlock() {\n             return getBlock(start);\n         }\n@@ -280,6 +303,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the subroutine's CFG.\n          */\n+\n         public CFG getCFG() {\n             return cfgSub;\n         }\n@@ -292,6 +316,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param handle\n          *            the instruction to be added to the subroutine\n          */\n+\n         public void addInstruction(InstructionHandle handle) throws CFGBuilderException {\n             int position = handle.getPosition();\n             if (usedInstructionSet.get(position)) {\n@@ -304,6 +329,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Is the given instruction part of this subroutine?\n          */\n+\n         public boolean containsInstruction(InstructionHandle handle) {\n             return instructionSet.get(handle.getPosition());\n         }\n@@ -318,6 +344,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          *            the start instruction for the block\n          * @return the basic block for the instruction\n          */\n+\n         public BasicBlock getBlock(InstructionHandle start) {\n             BasicBlock block = blockMap.get(start);\n             if (block == null) {\n@@ -329,7 +356,6 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                 if (exceptionGen != null) {\n                     block.setExceptionGen(null, exceptionGen);\n                 }\n-\n                 addItem(new WorkListItem(start, block));\n             }\n             return block;\n@@ -341,6 +367,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param block\n          *            the returning block\n          */\n+\n         public void setReturnBlock(BasicBlock block) {\n             returnBlockSet.set(block.getLabel());\n         }\n@@ -348,6 +375,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Does the method return at the end of this block?\n          */\n+\n         public boolean isReturnBlock(BasicBlock block) {\n             return returnBlockSet.get(block.getLabel());\n         }\n@@ -358,6 +386,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param block\n          *            the exiting block\n          */\n+\n         public void setExitBlock(BasicBlock block) {\n             exitBlockSet.set(block.getLabel());\n         }\n@@ -365,6 +394,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Is System.exit() called at the end of this block?\n          */\n+\n         public boolean isExitBlock(BasicBlock block) {\n             return exitBlockSet.get(block.getLabel());\n         }\n@@ -376,6 +406,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param block\n          *            the block throwing an unhandled exception\n          */\n+\n         public void setUnhandledExceptionBlock(BasicBlock block) {\n             unhandledExceptionBlockSet.set(block.getLabel());\n         }\n@@ -383,6 +414,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Does this block throw an unhandled exception?\n          */\n+\n         public boolean isUnhandledExceptionBlock(BasicBlock block) {\n             return unhandledExceptionBlockSet.get(block.getLabel());\n         }\n@@ -400,6 +432,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param edgeType\n          *            the type of control edge\n          */\n+\n         public void addEdgeAndExplore(BasicBlock sourceBlock, InstructionHandle target, @Edge.Type int edgeType) {\n             if (usedInstructionSet.get(target.getPosition()) && !containsInstruction(target)) {\n                 // Control escapes this subroutine\n@@ -426,12 +459,11 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param edgeType\n          *            the type of edge\n          */\n+\n         public void addEdge(BasicBlock sourceBlock, BasicBlock destBlock, @Edge.Type int edgeType) {\n             if (VERIFY_INTEGRITY) {\n                 if (destBlock.isExceptionHandler() && edgeType != HANDLED_EXCEPTION_EDGE) {\n-                    throw new IllegalStateException(\"In method \" + SignatureConverter.convertMethodSignature(methodGen)\n-                            + \": exception handler \" + destBlock.getFirstInstruction() + \" reachable by non exception edge type \"\n-                            + edgeType);\n+                    throw new IllegalStateException(\"In method \" + SignatureConverter.convertMethodSignature(methodGen) + \": exception handler \" + destBlock.getFirstInstruction() + \" reachable by non exception edge type \" + edgeType);\n                 }\n             }\n             cfgSub.createEdge(sourceBlock, destBlock, edgeType);\n@@ -444,6 +476,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          *            the basic block\n          * @return an Iterator over the EscapeTargets\n          */\n+\n         public Iterator<EscapeTarget> escapeTargetIterator(BasicBlock sourceBlock) {\n             List<EscapeTarget> escapeTargetList = escapeTargetListMap.get(sourceBlock);\n             if (escapeTargetList == null) {\n@@ -458,6 +491,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * subroutine to be inlined. A stack of calling contexts is maintained in\n      * order to resolve EscapeTargets.\n      */\n+\n+\n     private static class Context {\n         private final Context caller;\n \n@@ -479,6 +514,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param result\n          *            the result CFG\n          */\n+\n+\n         public Context(@Nullable Context caller, Subroutine subroutine, CFG result) {\n             this.caller = caller;\n             this.subroutine = subroutine;\n@@ -490,6 +527,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the calling context.\n          */\n+\n+\n         public Context getCaller() {\n             return caller;\n         }\n@@ -497,6 +536,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the subroutine being inlined.\n          */\n+\n         public Subroutine getSubroutine() {\n             return subroutine;\n         }\n@@ -504,6 +544,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the result CFG.\n          */\n+\n         public CFG getResult() {\n             return result;\n         }\n@@ -518,6 +559,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Are there more work list items?\n          */\n+\n         public boolean hasMoreWork() {\n             return !workList.isEmpty();\n         }\n@@ -525,6 +567,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Get the next work list item (basic block to be inlined).\n          */\n+\n         public BasicBlock nextItem() {\n             return workList.removeFirst();\n         }\n@@ -538,6 +581,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          * @param resultBlock\n          *            the result CFG block\n          */\n+\n         public void mapBlock(BasicBlock subBlock, BasicBlock resultBlock) {\n             blockMap.put(subBlock, resultBlock);\n         }\n@@ -550,6 +594,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n          *            the subroutine block\n          * @return the result CFG block\n          */\n+\n         public BasicBlock getBlock(BasicBlock subBlock) {\n             BasicBlock resultBlock = blockMap.get(subBlock);\n             if (resultBlock == null) {\n@@ -563,9 +608,9 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         /**\n          * Check to ensure that this context is not the result of recursion.\n          */\n+\n         public void checkForRecursion() throws CFGBuilderException {\n             Context callerContext = caller;\n-\n             while (callerContext != null) {\n                 if (callerContext.subroutine == this.subroutine) {\n                     throw new CFGBuilderException(\"JSR recursion detected!\");\n@@ -581,6 +626,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * ----------------------------------------------------------------------\n      */\n \n+\n     private final MethodGen methodGen;\n \n     private final ConstantPoolGen cpg;\n@@ -594,6 +640,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n     private final IdentityHashMap<InstructionHandle, Subroutine> jsrSubroutineMap;\n \n     private final Map<FieldDescriptor, Integer> addedFields = new HashMap<FieldDescriptor, Integer>();\n+\n     private Subroutine topLevelSubroutine;\n \n     private CFG cfg;\n@@ -610,6 +657,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * @param methodGen\n      *            the method to build a CFG for\n      */\n+\n+\n     public BetterCFGBuilder2(@Nonnull MethodDescriptor descriptor, @Nonnull MethodGen methodGen) {\n         this.methodGen = methodGen;\n         this.cpg = methodGen.getConstantPool();\n@@ -618,19 +667,17 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         ExceptionSetFactory exceptionSetFactory;\n         try {\n             exceptionSetFactory = analysisCache.getMethodAnalysis(ExceptionSetFactory.class, descriptor);\n-            merger = new StandardTypeMerger( AnalysisContext.currentAnalysisContext()\n-                    .getLookupFailureCallback(), exceptionSetFactory);\n+            merger = new StandardTypeMerger(AnalysisContext.currentAnalysisContext().getLookupFailureCallback(), exceptionSetFactory);\n         } catch (CheckedAnalysisException e) {\n             AnalysisContext.logError(\"Unable to generate exceptionSetFactory for \" + descriptor, e);\n         }\n-\n-\n         this.exceptionHandlerMap = new ExceptionHandlerMap(methodGen, merger);\n         this.usedInstructionSet = new BitSet();\n         this.jsrSubroutineMap = new IdentityHashMap<InstructionHandle, Subroutine>();\n         this.subroutineWorkList = new LinkedList<Subroutine>();\n     }\n \n+\n     public int getIndex(FieldDescriptor f) {\n         Integer i = addedFields.get(f);\n         if (i != null) {\n@@ -639,15 +686,12 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         int index = cpg.addFieldref(f.getSlashedClassName(), f.getName(), f.getSignature());\n         addedFields.put(f, index);\n         return index;\n-\n     }\n+\n     public void optimize(InstructionList instructionList) {\n         InstructionHandle head = instructionList.getStart();\n-\n         while (head != null) {\n             Instruction i = head.getInstruction();\n-\n-\n             if (i instanceof INVOKESTATIC) {\n                 INVOKESTATIC is = (INVOKESTATIC) i;\n                 String name = is.getMethodName(cpg);\n@@ -679,9 +723,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                                     + invoked + \" in \" + methodGen.getClassName() + \".\" + methodGen.getName()\n                                     + methodGen.getSignature());\n                          */\n-\n                     }\n-\n                 }\n             }\n             if (i instanceof IfInstruction) {\n@@ -695,7 +737,6 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                     }\n                     head.swapInstruction(consumed == 1 ? new POP() : new POP2());\n                 }\n-\n             }\n             if (i instanceof IFNULL || i instanceof IFNONNULL) {\n                 IfInstruction ii = (IfInstruction) i;\n@@ -710,27 +751,22 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                         break;\n                     }\n                     InstructionHandle next3 = next2.getNext(); // ICONST\n-                    if (next3== null) {\n+                    if (next3 == null) {\n                         break;\n                     }\n                     InstructionHandle next4 = next3.getNext();\n                     if (next4 == null) {\n                         break;\n                     }\n-                    if (target.equals(next3)  && next2.getInstruction() instanceof GOTO\n-                            && next3.getInstruction() instanceof ICONST && next1.getTargeters().length == 0\n-                            && next2.getTargeters().length == 0 && next3.getTargeters().length == 1\n-                            && next4.getTargeters().length == 1) {\n+                    if (target.equals(next3) && next2.getInstruction() instanceof GOTO && next3.getInstruction() instanceof ICONST && next1.getTargeters().length == 0 && next2.getTargeters().length == 0 && next3.getTargeters().length == 1 && next4.getTargeters().length == 1) {\n                         int c1 = ((ICONST) next1.getInstruction()).getValue().intValue();\n                         GOTO g = (GOTO) next2.getInstruction();\n                         int c2 = ((ICONST) next3.getInstruction()).getValue().intValue();\n                         if (g.getTarget().equals(next4) && (c1 == 1 && c2 == 0 || c1 == 0 && c2 == 1)) {\n                             boolean nullIsTrue = i instanceof IFNULL && c2 == 1 || i instanceof IFNONNULL && c2 == 0;\n-\n                             if (nullIsTrue) {\n                                 // System.out.println(\"Found NULL2Z instruction\");\n                                 head.swapInstruction(new NULL2Z());\n-\n                             } else {\n                                 // System.out.println(\"Found NONNULL2Z instruction\");\n                                 head.swapInstruction(new NONNULL2Z());\n@@ -743,7 +779,6 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                         }\n                     }\n                 }\n-\n             }\n             if (i instanceof ACONST_NULL) {\n                 InstructionHandle next = head.getNext();\n@@ -775,6 +810,7 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         subroutineWorkList.add(topLevelSubroutine);\n \n         // Build top level subroutine and all JSR subroutines\n+\n         while (!subroutineWorkList.isEmpty()) {\n             Subroutine subroutine = subroutineWorkList.removeFirst();\n             if (DEBUG) {\n@@ -792,14 +828,11 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         BasicBlock entryBlock = cfg.getEntry();\n         InstructionList il = new InstructionList();\n         entryBlock.addInstruction(il.append(new NOP()));\n-\n         if (VERIFY_INTEGRITY) {\n             cfg.checkIntegrity();\n         }\n-\n         if (true) {\n             cfg.checkIntegrity();\n-\n         }\n     }\n \n@@ -823,14 +856,16 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * @param subroutine\n      *            the subroutine\n      */\n+\n+\n     private void build(Subroutine subroutine) throws CFGBuilderException {\n         // Prime the work list\n         subroutine.addEdgeAndExplore(subroutine.getEntry(), subroutine.getStartInstruction(), START_EDGE);\n \n         // Keep going until all basic blocks in the subroutine have been added\n+\n         while (subroutine.hasMoreWork()) {\n             WorkListItem item = subroutine.nextItem();\n-\n             InstructionHandle handle = item.getStartInstruction();\n             BasicBlock basicBlock = item.getBasicBlock();\n \n@@ -845,11 +880,9 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                 subroutine.addEdge(basicBlock, body, FALL_THROUGH_EDGE);\n                 basicBlock = body;\n             }\n-\n             if (DEBUG) {\n                 System.out.println(\"BODY block \" + basicBlock.getLabel() + \" for \" + handle);\n             }\n-\n             if (!basicBlock.isEmpty()) {\n                 throw new IllegalStateException(\"Block isn't empty!\");\n             }\n@@ -865,7 +898,6 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                 }\n                 basicBlock.addInstruction(handle);\n                 subroutine.addInstruction(handle);\n-\n                 short opcode = ins.getOpcode();\n \n                 // TODO: should check instruction to ensure that in a JSR\n@@ -873,7 +905,6 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                 // no assignments are made to the local containing the return\n                 // address.\n                 // if (ins instanceof ASTORE) ...\n-\n                 if (opcode == Constants.JSR || opcode == Constants.JSR_W) {\n                     // Find JSR subroutine, add it to subroutine work list if\n                     // we haven't built a CFG for it yet\n@@ -906,17 +937,16 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                         } else if (visitor.instructionIsExit()) {\n                             subroutine.setExitBlock(basicBlock);\n                         } else if (visitor.instructionIsReturn()) {\n-                            subroutine.setReturnBlock(basicBlock);\n-                        } else {\n-                            Iterator<Target> i = visitor.targetIterator();\n-                            while (i.hasNext()) {\n-                                Target target = i.next();\n-                                subroutine.addEdgeAndExplore(basicBlock, target.getTargetInstruction(), target.getEdgeType());\n-                            }\n-                        }\n+                                   subroutine.setReturnBlock(basicBlock);\n+                               } else {\n+                                   Iterator<Target> i = visitor.targetIterator();\n+                                   while (i.hasNext()) {\n+                                       Target target = i.next();\n+                                       subroutine.addEdgeAndExplore(basicBlock, target.getTargetInstruction(), target.getEdgeType());\n+                                   }\n+                               }\n                     }\n                 }\n-\n                 if (!endOfBasicBlock) {\n                     InstructionHandle next = handle.getNext();\n                     if (next == null) {\n@@ -932,7 +962,6 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                         handle = next;\n                     }\n                 }\n-\n             } while (!endOfBasicBlock);\n         }\n     }\n@@ -947,6 +976,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * @param etb\n      *            the exception thrower block (ETB) for the instruction\n      */\n+\n+\n     private void handleExceptions(Subroutine subroutine, InstructionHandle pei, BasicBlock etb) {\n         etb.setExceptionThrower(pei);\n \n@@ -954,13 +985,11 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         // is reachable. If so, then we know that exceptions raised\n         // at this instruction cannot propagate out of the method.\n         boolean sawUniversalExceptionHandler = false;\n-\n         List<CodeExceptionGen> exceptionHandlerList = exceptionHandlerMap.getHandlerList(pei);\n         if (exceptionHandlerList != null) {\n             for (CodeExceptionGen exceptionHandler : exceptionHandlerList) {\n                 InstructionHandle handlerStart = exceptionHandler.getHandlerPC();\n                 subroutine.addEdgeAndExplore(etb, handlerStart, HANDLED_EXCEPTION_EDGE);\n-\n                 if (Hierarchy.isUniversalExceptionHandler(exceptionHandler.getCatchType())) {\n                     sawUniversalExceptionHandler = true;\n                 }\n@@ -987,13 +1016,13 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * @return true if the instruction can throw an exception, false otherwise\n      * @throws CFGBuilderException\n      */\n+\n+\n     private boolean isPEI(InstructionHandle handle) throws CFGBuilderException {\n         Instruction ins = handle.getInstruction();\n-\n         if (!(ins instanceof ExceptionThrower)) {\n             return false;\n         }\n-\n         if (ins instanceof NEW) {\n             return false;\n         }\n@@ -1019,25 +1048,25 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         if (ins instanceof GETFIELD && !methodGen.isStatic()) {\n             // Assume that GETFIELD on this object is not PEI\n             InstructionHandle prev = handle.getPrev();\n-            while(prev != null && prev.getInstruction().getOpcode() == Constants.DUP) {\n-            \t// Some compilers generate DUP for field increment code like\n-            \t// ALOAD_0 / DUP / GETFIELD x / ICONST_1 / IADD / PUTFIELD x\n+            while (prev != null && prev.getInstruction().getOpcode() == Constants.DUP) {\n+                // Some compilers generate DUP for field increment code like\n+                // ALOAD_0 / DUP / GETFIELD x / ICONST_1 / IADD / PUTFIELD x\n                 prev = prev.getPrev();\n             }\n-            if(prev != null && prev.getInstruction().getOpcode() == Constants.ALOAD_0) {\n+            if (prev != null && prev.getInstruction().getOpcode() == Constants.ALOAD_0) {\n                 return false;\n             }\n         }\n         if (ins instanceof PUTFIELD && !methodGen.isStatic()) {\n-        \t// Assume that PUTFIELD on this object is not PEI\n+            // Assume that PUTFIELD on this object is not PEI\n             int depth = 2;\n-            for(InstructionHandle prev = handle.getPrev(); prev != null; prev = prev.getPrev()) {\n+            for (InstructionHandle prev = handle.getPrev(); prev != null; prev = prev.getPrev()) {\n                 Instruction prevInst = prev.getInstruction();\n-                if(prevInst instanceof BranchInstruction) {\n-                    if(prevInst instanceof GotoInstruction) {\n+                if (prevInst instanceof BranchInstruction) {\n+                    if (prevInst instanceof GotoInstruction) {\n                         // Currently we support only jumps to the PUTFIELD itself\n                         // This will cover simple cases like this.a = flag ? foo : bar\n-                        if(((BranchInstruction) prevInst).getTarget() == handle) {\n+                        if (((BranchInstruction) prevInst).getTarget() == handle) {\n                             depth = 2;\n                         } else {\n                             return true;\n@@ -1049,16 +1078,15 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                     }\n                 }\n                 depth = depth - prevInst.produceStack(cpg) + prevInst.consumeStack(cpg);\n-                if(depth < 0) {\n-                    throw new CFGBuilderException(\"Invalid stack at \"+prev+\" when checking \"+handle);\n+                if (depth < 0) {\n+                    throw new CFGBuilderException(\"Invalid stack at \" + prev + \" when checking \" + handle);\n                 }\n-                if(depth == 0) {\n+                if (depth == 0) {\n                     return prevInst.getOpcode() != Constants.ALOAD_0;\n                 }\n             }\n         }\n         return true;\n-\n     }\n \n     /**\n@@ -1068,6 +1096,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      *            the instruction\n      * @return true if the instruction is a control merge, false otherwise\n      */\n+\n+\n     private static boolean isMerge(InstructionHandle handle) {\n         if (handle.hasTargeters()) {\n             // Check all targeters of this handle to see if any\n@@ -1089,18 +1119,16 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      *\n      * @return the CFG for the method\n      */\n+\n+\n     private CFG inlineAll() throws CFGBuilderException {\n         CFG result = new CFG();\n-\n         Context rootContext = new Context(null, topLevelSubroutine, result);\n         rootContext.mapBlock(topLevelSubroutine.getEntry(), result.getEntry());\n         rootContext.mapBlock(topLevelSubroutine.getExit(), result.getExit());\n-\n         BasicBlock resultStartBlock = rootContext.getBlock(topLevelSubroutine.getStartBlock());\n         result.createEdge(result.getEntry(), resultStartBlock, START_EDGE);\n-\n         inline(rootContext);\n-\n         return result;\n     }\n \n@@ -1110,17 +1138,15 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n      * @param context\n      *            the Context\n      */\n-    public void inline(Context context) throws CFGBuilderException {\n \n+    public void inline(Context context) throws CFGBuilderException {\n         CFG result = context.getResult();\n \n         // Check to ensure we're not trying to inline something that is\n         // recursive\n         context.checkForRecursion();\n-\n         Subroutine subroutine = context.getSubroutine();\n         CFG subCFG = subroutine.getCFG();\n-\n         while (context.hasMoreWork()) {\n             BasicBlock subBlock = context.nextItem();\n             BasicBlock resultBlock = context.getBlock(subBlock);\n@@ -1150,7 +1176,6 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n             while (edgeIter.hasNext()) {\n                 Edge edge = edgeIter.next();\n                 int edgeType = edge.getType();\n-\n                 if (edgeType == JSR_EDGE) {\n                     // Inline a JSR subroutine...\n \n@@ -1198,10 +1223,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n                     }\n                     caller = caller.getCaller();\n                 }\n-\n                 if (caller == null) {\n-                    throw new CFGBuilderException(\"Unknown caller for escape target \" + targetInstruction + \" referenced by \"\n-                            + context.getSubroutine().getStartInstruction());\n+                    throw new CFGBuilderException(\"Unknown caller for escape target \" + targetInstruction + \" referenced by \" + context.getSubroutine().getStartInstruction());\n                 }\n \n                 // Find result block in caller\n@@ -1227,7 +1250,6 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n             if (subroutine.isUnhandledExceptionBlock(subBlock)) {\n                 result.createEdge(resultBlock, result.getExit(), UNHANDLED_EXCEPTION_EDGE);\n             }\n-\n         }\n \n         /*\n@@ -1262,35 +1284,30 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n     /**\n      * Test driver.\n      */\n+\n     public static void main(String[] argv) throws Exception {\n         if (argv.length != 1) {\n             System.err.println(\"Usage: \" + BetterCFGBuilder2.class.getName() + \" <class file>\");\n             System.exit(1);\n         }\n-\n         String methodName = SystemProperties.getProperty(\"cfgbuilder.method\");\n-\n         JavaClass jclass = new ClassParser(argv[0]).parse();\n         ClassGen classGen = new ClassGen(jclass);\n-\n         Method[] methodList = jclass.getMethods();\n         for (Method method : methodList) {\n             if (method.isAbstract() || method.isNative()) {\n+\n                 continue;\n             }\n-\n             if (methodName != null && !method.getName().equals(methodName)) {\n+\n                 continue;\n             }\n-\n             MethodDescriptor descriptor = DescriptorFactory.instance().getMethodDescriptor(jclass, method);\n             MethodGen methodGen = new MethodGen(method, jclass.getClassName(), classGen.getConstantPool());\n-\n             CFGBuilder cfgBuilder = new BetterCFGBuilder2(descriptor, methodGen);\n             cfgBuilder.build();\n-\n             CFG cfg = cfgBuilder.getCFG();\n-\n             CFGPrinter cfgPrinter = new CFGPrinter(cfg);\n             System.out.println(\"---------------------------------------------------------------------\");\n             System.out.println(\"Method: \" + SignatureConverter.convertMethodSignature(methodGen));\n@@ -1299,4 +1316,4 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 159
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1032",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/4/BetterCFGBuilder2.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/4/BetterCFGBuilder2.java\nindex c01bb2174a8..8e6a6209490 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/4/BetterCFGBuilder2.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/4/BetterCFGBuilder2.java\n@@ -1020,8 +1020,8 @@ public class BetterCFGBuilder2 implements CFGBuilder, EdgeTypes, Debug {\n             // Assume that GETFIELD on this object is not PEI\n             InstructionHandle prev = handle.getPrev();\n             while(prev != null && prev.getInstruction().getOpcode() == Constants.DUP) {\n-            \t// Some compilers generate DUP for field increment code like\n-            \t// ALOAD_0 / DUP / GETFIELD x / ICONST_1 / IADD / PUTFIELD x\n+            // Some compilers generate DUP for field increment code like\n+             // ALOAD_0 / DUP / GETFIELD x / ICONST_1 / IADD / PUTFIELD x\n                 prev = prev.getPrev();\n             }\n             if(prev != null && prev.getInstruction().getOpcode() == Constants.ALOAD_0) {\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}