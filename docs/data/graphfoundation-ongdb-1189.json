{
    "project_name": "graphfoundation-ongdb",
    "error_id": "1189",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2018 \"Neo Technology,\"\n * Network Engine for Objects in Lund AB [http://neotechnology.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "45",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "45",
                    "column": "26",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "48",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "48",
                    "column": "27",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "51",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "51",
                    "column": "28",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "54",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "54",
                    "column": "29",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "57",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "57",
                    "column": "31",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "60",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "60",
                    "column": "31",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "72",
                    "column": "12",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "72",
                    "column": "59",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "80",
                    "column": "25",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "80",
                    "column": "60",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "83",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "83",
                    "column": "47",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "91",
                    "column": "28",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "91",
                    "column": "51",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "96",
                    "column": "22",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "96",
                    "column": "82",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "110",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "110",
                    "column": "21",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "118",
                    "column": "28",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "118",
                    "column": "62",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "124",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "124",
                    "column": "40",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "126",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "126",
                    "column": "48",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "135",
                    "column": "88",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "135",
                    "column": "103",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "137",
                    "column": "45",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "138",
                    "column": "83",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "141",
                    "column": "27",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "141",
                    "column": "42",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "146",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "146",
                    "column": "40",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "148",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "148",
                    "column": "48",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "159",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "159",
                    "column": "40",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "166",
                    "column": "28",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "166",
                    "column": "46",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "242",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "242",
                    "column": "25",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "259",
                    "column": "32",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "259",
                    "column": "68",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "271",
                    "column": "32",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "271",
                    "column": "76",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1189/Reference.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1189/Reference.java\nindex d19380ab608..61e0696151d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1189/Reference.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1189/Reference.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU Affero General Public License\n  * along with this program. If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.kernel.impl.store.format.highlimit;\n \n import org.neo4j.io.pagecache.PageCursor;\n@@ -26,247 +27,249 @@ import static java.lang.String.format;\n /**\n  * {@link #encode(long, PageCursor) Encoding} and {@link #decode(PageCursor) decoding} of {@code long}\n  * references, max 58-bit, into an as compact format as possible. Format is close to how utf-8 does similar encoding.\n- *\n+ * <p>\n  * Basically one or more header bits are used to note the number of bytes required to represent a\n  * particular {@code long} value followed by the value itself. Number of bytes used for any long ranges from\n  * 3 up to the full 8 bytes. The header bits sits in the most significant bit(s) of the most significant byte,\n  * so for that the bytes that make up a value is written (and of course read) in big-endian order.\n- *\n+ * <p>\n  * Negative values are also supported, in order to handle relative references.\n  *\n  * @author Mattias Persson\n  */\n public enum Reference\n {\n-    // bit masks below contain one bit for 's' (sign) so actual address space is one bit less than advertised\n+  // bit masks below contain one bit for 's' (sign) so actual address space is one bit less than advertised\n \n-    // 3-byte, 23-bit addr space: 0sxx xxxx xxxx xxxx xxxx xxxx\n-    BYTE_3( 3, (byte) 0b0, 1 ),\n+  // 3-byte, 23-bit addr space: 0sxx xxxx xxxx xxxx xxxx xxxx\n+  BYTE_3(3, (byte) 0b0, 1),\n \n-    // 4-byte, 30-bit addr space: 10sx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n-    BYTE_4( 4, (byte) 0b10, 2 ),\n+  // 4-byte, 30-bit addr space: 10sx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n+  BYTE_4(4, (byte) 0b10, 2),\n \n-    // 5-byte, 37-bit addr space: 110s xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n-    BYTE_5( 5, (byte) 0b110, 3 ),\n+  // 5-byte, 37-bit addr space: 110s xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n+  BYTE_5(5, (byte) 0b110, 3),\n \n-    // 6-byte, 44-bit addr space: 1110 sxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n-    BYTE_6( 6, (byte) 0b1110, 4 ),\n+  // 6-byte, 44-bit addr space: 1110 sxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n+  BYTE_6(6, (byte) 0b1110, 4),\n \n-    // 7-byte, 51-bit addr space: 1111 0sxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n-    BYTE_7( 7, (byte) 0b1111_0, 5 ),\n+  // 7-byte, 51-bit addr space: 1111 0sxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n+  BYTE_7(7, (byte) 0b1111_0, 5),\n \n-    // 8-byte, 59-bit addr space: 1111 1sxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n-    BYTE_8( 8, (byte) 0b1111_1, 5 );\n+  // 8-byte, 59-bit addr space: 1111 1sxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n+  BYTE_8(8, (byte) 0b1111_1, 5);\n \n-    // Take one copy here since Enum#values() does an unnecessary defensive copy every time.\n-    private static final Reference[] ENCODINGS = Reference.values();\n+  // Take one copy here since Enum#values() does an unnecessary defensive copy every time.\n+  private static final Reference[] ENCODINGS = Reference.values();\n \n-    static final int MAX_BITS = 58;\n+  static final int MAX_BITS = 58;\n \n-    private final int numberOfBytes;\n-    private final short highHeader;\n-    private final int headerShift;\n-    private final long valueOverflowMask;\n+  private final int numberOfBytes;\n+  private final short highHeader;\n+  private final int headerShift;\n+  private final long valueOverflowMask;\n \n-    Reference( int numberOfBytes, byte header, int headerBits )\n-    {\n-        this.numberOfBytes = numberOfBytes;\n-        this.headerShift = Byte.SIZE - headerBits;\n-        this.highHeader = (short) (((byte) (header << headerShift)) & 0xFF);\n-        this.valueOverflowMask = ~valueMask( numberOfBytes, headerShift - 1 /*sign bit uses one bit*/ );\n-    }\n+  Reference(int numberOfBytes, byte header, int headerBits)\n+  {\n+    this.numberOfBytes = numberOfBytes;\n+    this.headerShift = Byte.SIZE - headerBits;\n+    this.highHeader = (short) (((byte) (header << headerShift)) & 0xFF);\n+    this.valueOverflowMask = ~valueMask(numberOfBytes, headerShift - 1 /*sign bit uses one bit*/);\n+  }\n \n-    private long valueMask( int numberOfBytes, int headerShift )\n+  private long valueMask(int numberOfBytes, int headerShift)\n+  {\n+    long mask = (1L << headerShift) - 1;\n+    for (int i = 0; i < numberOfBytes - 1; i++)\n     {\n-        long mask = ( 1L << headerShift ) - 1;\n-        for ( int i = 0; i < numberOfBytes - 1; i++ )\n-        {\n-            mask <<= 8;\n-            mask |= 0xFF;\n-        }\n-        return mask;\n+      mask <<= 8;\n+      mask |= 0xFF;\n     }\n+    return mask;\n+  }\n \n-    private boolean canEncode( long absoluteReference )\n-    {\n-        return (absoluteReference & valueOverflowMask) == 0;\n-    }\n+  private boolean canEncode(long absoluteReference)\n+  {\n+    return (absoluteReference & valueOverflowMask) == 0;\n+  }\n \n-    private void encode( long absoluteReference, boolean positive, PageCursor source )\n-    {\n-        // use big-endianness, most significant byte written first, since it contains encoding information\n-        int shift = (numberOfBytes - 1) << 3;\n-        byte signBit = (byte) ((positive ? 0 : 1) << (headerShift - 1));\n-\n-        // first (most significant) byte\n-        source.putByte( (byte) (highHeader | signBit | (byte) (absoluteReference >>> shift)) );\n-\n-        do // rest of the bytes\n-        {\n-            shift -= 8;\n-            source.putByte( (byte) (absoluteReference >>> shift) );\n-        }\n-        while ( shift > 0 );\n-    }\n+  private void encode(long absoluteReference, boolean positive, PageCursor source)\n+  {\n+    // use big-endianness, most significant byte written first, since it contains encoding information\n+    int shift = (numberOfBytes - 1) << 3;\n+    byte signBit = (byte) ((positive ? 0 : 1) << (headerShift - 1));\n \n-    private int maxBitsSupported()\n-    {\n-        return Long.SIZE - Long.numberOfLeadingZeros( ~valueOverflowMask );\n-    }\n+    // first (most significant) byte\n+    source.putByte((byte) (highHeader | signBit | (byte) (absoluteReference >>> shift)));\n \n-    public static void encode( long reference, PageCursor target )\n+    do // rest of the bytes\n     {\n-        // checking with < 0 seems to be the fastest way of telling\n-        boolean positive = reference >= 0;\n-        long absoluteReference = positive ? reference : ~reference;\n-\n-        for ( Reference encoding : ENCODINGS )\n-        {\n-            if ( encoding.canEncode( absoluteReference ) )\n-            {\n-                encoding.encode( absoluteReference, positive, target );\n-                return;\n-            }\n-        }\n-        throw unsupportedOperationDueToTooBigReference( reference );\n+      shift -= 8;\n+      source.putByte((byte) (absoluteReference >>> shift));\n     }\n+    while (shift > 0);\n+  }\n \n-    private static UnsupportedOperationException unsupportedOperationDueToTooBigReference( long reference )\n-    {\n-        return new UnsupportedOperationException( format( \"Reference %d uses too many bits to be encoded by \"\n-                + \"current compression scheme, max %d bits allowed\", reference, maxBits() ) );\n-    }\n+  private int maxBitsSupported()\n+  {\n+    return Long.SIZE - Long.numberOfLeadingZeros(~valueOverflowMask);\n+  }\n \n-    public static int length( long reference )\n-    {\n-        boolean positive = reference >= 0;\n-        long absoluteReference = positive ? reference : ~reference;\n-\n-        for ( Reference encoding : ENCODINGS )\n-        {\n-            if ( encoding.canEncode( absoluteReference ) )\n-            {\n-                return encoding.numberOfBytes;\n-            }\n-        }\n-        throw unsupportedOperationDueToTooBigReference( reference );\n-    }\n+  public static void encode(long reference, PageCursor target)\n+  {\n+    // checking with < 0 seems to be the fastest way of telling\n+    boolean positive = reference >= 0;\n+    long absoluteReference = positive ? reference : ~reference;\n \n-    private static int maxBits()\n+    for (Reference encoding : ENCODINGS)\n     {\n-        int max = 0;\n-        for ( Reference encoding : ENCODINGS )\n-        {\n-            max = Math.max( max, encoding.maxBitsSupported() );\n-        }\n-        return max;\n+      if (encoding.canEncode(absoluteReference))\n+      {\n+        encoding.encode(absoluteReference, positive, target);\n+        return;\n+      }\n     }\n+    throw unsupportedOperationDueToTooBigReference(reference);\n+  }\n+\n+  private static UnsupportedOperationException unsupportedOperationDueToTooBigReference(long reference)\n+  {\n+    return new UnsupportedOperationException(format(\"Reference %d uses too many bits to be encoded by \"\n+        + \"current compression scheme, max %d bits allowed\", reference, maxBits()));\n+  }\n+\n+  public static int length(long reference)\n+  {\n+    boolean positive = reference >= 0;\n+    long absoluteReference = positive ? reference : ~reference;\n \n-    public static long decode( PageCursor source )\n+    for (Reference encoding : ENCODINGS)\n     {\n-        // Dear future maintainers, this code is a little complicated so I'm going to take some time and explain it to\n-        // you. Make sure you have some coffee ready.\n-        //\n-        // Before we start, I have one plea: Please don't extract the constants out of this function. It is easier to\n-        // make sense of them when they are embedded within the context of the code. Also, while some of the constants\n-        // have the same value, they might change for different reasons, so let's just keep them inlined.\n-        //\n-        // The code is easier to read when it's all together, so I'll keep the code and the comment separate, and make\n-        // the comment refer to the code with <N> marks.\n-        //\n-        // <1>\n-        // The first byte of a reference is the header byte. It is an unsigned byte where all the bits matter, but Java\n-        // has no such concept as an unsigned byte, so we instead store the byte in a 32-bit int, and mask it with 0xFF\n-        // to read it as if it was unsigned. The 0xFF mask makes sure that the highest-order bit, which would otherwise\n-        // be used as a sign-bit, stays together with the other 7 bits in the lowest-order byte of the int.\n-        //\n-        // <2>\n-        // The header determines how many bytes go into the reference. These are the size marks. If the first bit of\n-        // the header is zero, then we have zero size marks and the reference takes up 3 bytes. If the header starts\n-        // with the bits 10, then we have one size mark and the reference takes up 4 bytes. We can have up to 5 size\n-        // marks, where the last two options are 11110 for a 7 byte reference, and 11111 for an 8 byte reference.\n-        // We count the size marks as follows:\n-        //  1. First extract the 5 high-bits. 0xF8 is 11111000, so xxxx_xxxx & 0xF8 => xxxx_x000.\n-        //  2. The x'es are a number of ones, possibly zero, followed by a zero. There's an instruction to count\n-        //     leading zeros, but not leading ones, so we have to invert the 1 size marks into 0s, and the possible 0\n-        //     end mark into a 1. We use the `& 0xFF` trick to prevent the leading size mark from turning into a\n-        //     sign-bit. So (~xxxx_x000) & 0xFF => XXXX_X111, e.g. 0111_1000 (no size marks) becomes 1000_0111, and\n-        //     1101_1000 (two size marks) becomes 0010_0111.\n-        //  3. Now we can count the leading zeros to find the end mark. Remember that the end-mark is the zero-bit after\n-        //     the size marks. We *always* have this end-mark at this point, because any 1 in the highest-bit of the\n-        //     reference was masked to 0 in step 1 above.\n-        //  4. When we count the number of leading zeros, we have thus far been thinking about the header as a single\n-        //     byte. However, the register we have been working on is a 32-bit integer, so we have to subtract 3 times 8\n-        //     bits to get the number of size marks in the original header *byte*.\n-        //\n-        // <3>\n-        // The sign-bit is located after the end-mark, or after the last size mark in the case of an 8 byte reference.\n-        // We have 8 bits in the header byte, so if we want to place the sign-bit at the lowest-order bit location,\n-        // then we can think of the size marks and optional end-mark as a pre-shift, pushing the sign-bit towards the\n-        // low end. We just have to figure out how many bits are left to shift over.\n-        //\n-        // <4>\n-        // If the sign-bit is 1, then we want to produce the 64-bit signed integer number -1, which consists of 64\n-        // consecutive 1-bits. If the sign-bit is 0, then we want to produce 0, which in binary is 64 consecutive\n-        // 0-bits. The reason we do this is how negative numbers work. It turns out that -X == -1 ^ (X - 1). Since\n-        // our compression scheme is all about avoiding the storage of unnecessary high-order zeros, we can more easily\n-        // store the (X - 1) part plus a sign bit, than a long string of 1-bits followed by useful data. For example,\n-        // the negative number -42 is 1111111111111111111111111111111111111111111111111111111111010110 in binary,\n-        // while 41 is just 101001. And given our equation above, -1 ^ 41 == -42.\n-        //\n-        // <5>\n-        // After the size marks, the end-mark and the sign-bit comes a few bits of payload data. The sign-bit location\n-        // marks the end of the meta-data bits, so we use that as a base for computing a mask that will remove all the\n-        // meta-data bits. Since the smallest reference takes up 3 bytes, we can immediately shift those payload bits\n-        // up 16 places to make room for the next two bytes of payload.\n-        //\n-        // <6>\n-        // Then we read the next two bytes (with unsigned mask) and save for the sign-component manipulation, we now\n-        // have a complete 3-byte reference.\n-        //\n-        // <7>\n-        // The size marks determines how many more bytes the reference takes up, so we loop through them and shift the\n-        // register up 8 places every time, and add in the next byte with an unsigned mask.\n-        //\n-        // <8>\n-        // Finally XOR the register with the sign component and we have our final value.\n-\n-        int header = source.getByte() & 0xFF; // <1>\n-        int sizeMarks = Integer.numberOfLeadingZeros( (~(header & 0xF8)) & 0xFF ) - 24; // <2>\n-        int signShift = 8 - sizeMarks - (sizeMarks == 5 ? 1 : 2); // <3>\n-        long signComponent = ~((header >>> signShift) & 1) + 1; // <4>\n-        long register = (header & ((1 << signShift) - 1)) << 16; // <5>\n-        register += ((source.getByte() & 0xFF) << 8) + (source.getByte() & 0xFF); // <6>\n-\n-        while ( sizeMarks > 0 ) // <7>\n-        {\n-            register <<= 8;\n-            register += source.getByte() & 0xFF;\n-            sizeMarks--;\n-        }\n-\n-        return signComponent ^ register; // <8>\n+      if (encoding.canEncode(absoluteReference))\n+      {\n+        return encoding.numberOfBytes;\n+      }\n     }\n+    throw unsupportedOperationDueToTooBigReference(reference);\n+  }\n \n-    /**\n-     * Convert provided reference to be relative to basisReference\n-     * @param reference reference that will be converter to relative\n-     * @param basisReference conversion basis\n-     * @return reference relative to basisReference\n-     */\n-    public static long toRelative( long reference, long basisReference )\n+  private static int maxBits()\n+  {\n+    int max = 0;\n+    for (Reference encoding : ENCODINGS)\n     {\n-        return Math.subtractExact( reference , basisReference );\n+      max = Math.max(max, encoding.maxBitsSupported());\n     }\n+    return max;\n+  }\n \n-    /**\n-     * Convert provided relative to basis reference into absolute\n-     * @param relativeReference relative reference to convert\n-     * @param basisReference basis reference\n-     * @return absolute reference\n-     */\n-    public static long toAbsolute( long relativeReference, long basisReference )\n+  public static long decode(PageCursor source)\n+  {\n+    // Dear future maintainers, this code is a little complicated so I'm going to take some time and explain it to\n+    // you. Make sure you have some coffee ready.\n+    //\n+    // Before we start, I have one plea: Please don't extract the constants out of this function. It is easier to\n+    // make sense of them when they are embedded within the context of the code. Also, while some of the constants\n+    // have the same value, they might change for different reasons, so let's just keep them inlined.\n+    //\n+    // The code is easier to read when it's all together, so I'll keep the code and the comment separate, and make\n+    // the comment refer to the code with <N> marks.\n+    //\n+    // <1>\n+    // The first byte of a reference is the header byte. It is an unsigned byte where all the bits matter, but Java\n+    // has no such concept as an unsigned byte, so we instead store the byte in a 32-bit int, and mask it with 0xFF\n+    // to read it as if it was unsigned. The 0xFF mask makes sure that the highest-order bit, which would otherwise\n+    // be used as a sign-bit, stays together with the other 7 bits in the lowest-order byte of the int.\n+    //\n+    // <2>\n+    // The header determines how many bytes go into the reference. These are the size marks. If the first bit of\n+    // the header is zero, then we have zero size marks and the reference takes up 3 bytes. If the header starts\n+    // with the bits 10, then we have one size mark and the reference takes up 4 bytes. We can have up to 5 size\n+    // marks, where the last two options are 11110 for a 7 byte reference, and 11111 for an 8 byte reference.\n+    // We count the size marks as follows:\n+    //  1. First extract the 5 high-bits. 0xF8 is 11111000, so xxxx_xxxx & 0xF8 => xxxx_x000.\n+    //  2. The x'es are a number of ones, possibly zero, followed by a zero. There's an instruction to count\n+    //     leading zeros, but not leading ones, so we have to invert the 1 size marks into 0s, and the possible 0\n+    //     end mark into a 1. We use the `& 0xFF` trick to prevent the leading size mark from turning into a\n+    //     sign-bit. So (~xxxx_x000) & 0xFF => XXXX_X111, e.g. 0111_1000 (no size marks) becomes 1000_0111, and\n+    //     1101_1000 (two size marks) becomes 0010_0111.\n+    //  3. Now we can count the leading zeros to find the end mark. Remember that the end-mark is the zero-bit after\n+    //     the size marks. We *always* have this end-mark at this point, because any 1 in the highest-bit of the\n+    //     reference was masked to 0 in step 1 above.\n+    //  4. When we count the number of leading zeros, we have thus far been thinking about the header as a single\n+    //     byte. However, the register we have been working on is a 32-bit integer, so we have to subtract 3 times 8\n+    //     bits to get the number of size marks in the original header *byte*.\n+    //\n+    // <3>\n+    // The sign-bit is located after the end-mark, or after the last size mark in the case of an 8 byte reference.\n+    // We have 8 bits in the header byte, so if we want to place the sign-bit at the lowest-order bit location,\n+    // then we can think of the size marks and optional end-mark as a pre-shift, pushing the sign-bit towards the\n+    // low end. We just have to figure out how many bits are left to shift over.\n+    //\n+    // <4>\n+    // If the sign-bit is 1, then we want to produce the 64-bit signed integer number -1, which consists of 64\n+    // consecutive 1-bits. If the sign-bit is 0, then we want to produce 0, which in binary is 64 consecutive\n+    // 0-bits. The reason we do this is how negative numbers work. It turns out that -X == -1 ^ (X - 1). Since\n+    // our compression scheme is all about avoiding the storage of unnecessary high-order zeros, we can more easily\n+    // store the (X - 1) part plus a sign bit, than a long string of 1-bits followed by useful data. For example,\n+    // the negative number -42 is 1111111111111111111111111111111111111111111111111111111111010110 in binary,\n+    // while 41 is just 101001. And given our equation above, -1 ^ 41 == -42.\n+    //\n+    // <5>\n+    // After the size marks, the end-mark and the sign-bit comes a few bits of payload data. The sign-bit location\n+    // marks the end of the meta-data bits, so we use that as a base for computing a mask that will remove all the\n+    // meta-data bits. Since the smallest reference takes up 3 bytes, we can immediately shift those payload bits\n+    // up 16 places to make room for the next two bytes of payload.\n+    //\n+    // <6>\n+    // Then we read the next two bytes (with unsigned mask) and save for the sign-component manipulation, we now\n+    // have a complete 3-byte reference.\n+    //\n+    // <7>\n+    // The size marks determines how many more bytes the reference takes up, so we loop through them and shift the\n+    // register up 8 places every time, and add in the next byte with an unsigned mask.\n+    //\n+    // <8>\n+    // Finally XOR the register with the sign component and we have our final value.\n+\n+    int header = source.getByte() & 0xFF; // <1>\n+    int sizeMarks = Integer.numberOfLeadingZeros((~(header & 0xF8)) & 0xFF) - 24; // <2>\n+    int signShift = 8 - sizeMarks - (sizeMarks == 5 ? 1 : 2); // <3>\n+    long signComponent = ~((header >>> signShift) & 1) + 1; // <4>\n+    long register = (header & ((1 << signShift) - 1)) << 16; // <5>\n+    register += ((source.getByte() & 0xFF) << 8) + (source.getByte() & 0xFF); // <6>\n+\n+    while (sizeMarks > 0) // <7>\n     {\n-        return Math.addExact( relativeReference, basisReference );\n+      register <<= 8;\n+      register += source.getByte() & 0xFF;\n+      sizeMarks--;\n     }\n+\n+    return signComponent ^ register; // <8>\n+  }\n+\n+  /**\n+   * Convert provided reference to be relative to basisReference\n+   *\n+   * @param reference      reference that will be converter to relative\n+   * @param basisReference conversion basis\n+   * @return reference relative to basisReference\n+   */\n+  public static long toRelative(long reference, long basisReference)\n+  {\n+    return Math.subtractExact(reference, basisReference);\n+  }\n+\n+  /**\n+   * Convert provided relative to basis reference into absolute\n+   *\n+   * @param relativeReference relative reference to convert\n+   * @param basisReference    basis reference\n+   * @return absolute reference\n+   */\n+  public static long toAbsolute(long relativeReference, long basisReference)\n+  {\n+    return Math.addExact(relativeReference, basisReference);\n+  }\n }\n",
            "diff_size": 324
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}