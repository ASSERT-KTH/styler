{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "113",
    "information": {
        "errors": [
            {
                "line": "34",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "public final class StringRegExPatternTerm\n{\n\tpublic enum Type\n\t{\n\t\tTYPE_SEQ, TYPE_CHOICE, TYPE_LEAF_POSITIVE, TYPE_LEAF_NEGATIVE, TYPE_LEAF_WILDCARD\n\t}",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "35",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/113/StringRegExPatternTerm.java\nindex 5966d92c3b9..90cf6a4a878 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/113/StringRegExPatternTerm.java\n@@ -31,7 +31,7 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  */\n public final class StringRegExPatternTerm\n {\n-\tpublic enum Type\n+public enum Type\n \t{\n \t\tTYPE_SEQ, TYPE_CHOICE, TYPE_LEAF_POSITIVE, TYPE_LEAF_NEGATIVE, TYPE_LEAF_WILDCARD\n \t}\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/113/StringRegExPatternTerm.java\nindex 5966d92c3b9..c7ac0e8ee03 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/113/StringRegExPatternTerm.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.regex.string;\n \n import java.util.ArrayList;\n@@ -29,562 +30,514 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  * set of characters. A leaf term is represented as a collection of ranges and a set of subterms or by a unicode\n  * category.\n  */\n-public final class StringRegExPatternTerm\n-{\n-\tpublic enum Type\n-\t{\n-\t\tTYPE_SEQ, TYPE_CHOICE, TYPE_LEAF_POSITIVE, TYPE_LEAF_NEGATIVE, TYPE_LEAF_WILDCARD\n-\t}\n-\n-\tprivate int minOccurrence = 1;\n-\tprivate int maxOccurrence = 1;\n-\tprivate Type type;\n-\n-\t// Support for range of Unicode categories as defined by the Character class\n-\tprivate int[] m_category;\n-\n-\t/**\n-\t * List of {@link StringRegExPatternTerm} (for seq or choice)\n-\t */\n-\tprivate final List<StringRegExPatternTerm> subTermList = new ArrayList<StringRegExPatternTerm>();\n-\n-\t/**\n-\t * List of {@link CharRange} (for leaf)\n-\t */\n-\tprivate final List<CharRange> rangeList = new ArrayList<CharRange>();\n-\n-\tprivate StringRegExPatternTerm notTerm;\n-\n-\tpublic StringRegExPatternTerm(final Type type)\n-\t{\n-\t\tthis.type = type;\n-\t}\n-\n-\t/**\n-\t * a single character\n-\t */\n-\tpublic StringRegExPatternTerm(char c)\n-\t{\n-\t\tthis.type = Type.TYPE_LEAF_POSITIVE;\n-\t\trangeList.add(new CharRange(c));\n-\t}\n-\n-\tpublic void addSubTerm(StringRegExPatternTerm subTerm)\n-\t{\n-\t\tsubTermList.add(subTerm);\n-\t}\n-\n-\tpublic void addChar(char c)\n-\t{\n-\t\trangeList.add(new CharRange(c));\n-\t}\n-\n-\tpublic void addChar(final int first, final int last)\n-\t{\n-\t\trangeList.add(new CharRange(first, last));\n-\t}\n-\n-\t/**\n-\t * converts the last two range items into one\n-\t */\n-\tpublic void combineRanges()\n-\t{\n-\t\tfinal CharRange a = rangeList.get(rangeList.size() - 2);\n-\t\tfinal CharRange b = rangeList.get(rangeList.size() - 1);\n-\t\ta.setLast(b.getLast());\n-\t\trangeList.remove(rangeList.size() - 1);\n-\t}\n-\n-\tpublic void addNegativeTerm(final StringRegExPatternTerm term)\n-\t{\n-\t\tnotTerm = term;\n-\t}\n-\n-\t/**\n-\t * map Unicode category abbr => array of Character constants\n-\t */\n-\tprotected static final HashMap<String, int[]> categoryMap = new HashMap<String, int[]>();\n-\n-\t/**\n-\t * Maps block name string => Character.UnicodeBlock\n-\t */\n-\tprotected static final HashMap<String, int[]> blockMap = new HashMap<String, int[]>();\n-\n-\tstatic\n-\t{\n-\t\tcategoryMap.put(\"L\", new int[] { Character.UPPERCASE_LETTER, Character.LOWERCASE_LETTER, Character.TITLECASE_LETTER, Character.MODIFIER_LETTER, Character.OTHER_LETTER }); // All\n-\t\t// Letters\n-\t\tcategoryMap.put(\"Lu\", new int[] { Character.UPPERCASE_LETTER }); // Uppercase\n-\t\tcategoryMap.put(\"Ll\", new int[] { Character.LOWERCASE_LETTER }); // Lowercase\n-\t\tcategoryMap.put(\"Lt\", new int[] { Character.TITLECASE_LETTER }); // Titlecase\n-\t\tcategoryMap.put(\"Lm\", new int[] { Character.MODIFIER_LETTER }); // Modifier\n-\t\tcategoryMap.put(\"Lo\", new int[] { Character.OTHER_LETTER }); // Other Letters\n-\n-\t\tcategoryMap.put(\"M\", new int[] { Character.NON_SPACING_MARK, Character.COMBINING_SPACING_MARK, Character.ENCLOSING_MARK }); // All\n-\t\t// Marks\n-\t\tcategoryMap.put(\"Mn\", new int[] { Character.NON_SPACING_MARK }); // Non-Spacing\n-\t\tcategoryMap.put(\"Mc\", new int[] { Character.COMBINING_SPACING_MARK }); // Spacing Combining\n-\t\tcategoryMap.put(\"Me\", new int[] { Character.ENCLOSING_MARK }); // Enclosing\n-\n-\t\tcategoryMap.put(\"N\", new int[] { Character.DECIMAL_DIGIT_NUMBER, Character.LETTER_NUMBER, Character.OTHER_NUMBER }); // All\n-\t\t// Numbers\n-\t\tcategoryMap.put(\"Nd\", new int[] { Character.DECIMAL_DIGIT_NUMBER }); // Decimal Digit\n-\t\tcategoryMap.put(\"Nl\", new int[] { Character.LETTER_NUMBER }); // Letter\n-\t\tcategoryMap.put(\"No\", new int[] { Character.OTHER_NUMBER }); // Other Numbers\n-\n-\t\tcategoryMap.put(\"P\", new int[] { Character.CONNECTOR_PUNCTUATION, Character.DASH_PUNCTUATION, Character.START_PUNCTUATION, Character.END_PUNCTUATION, Character.OTHER_PUNCTUATION }); // All\n-\t\t// Punctuation\n-\t\tcategoryMap.put(\"Pc\", new int[] { Character.CONNECTOR_PUNCTUATION }); // Connector\n-\t\tcategoryMap.put(\"Pd\", new int[] { Character.DASH_PUNCTUATION }); // Dash\n-\t\tcategoryMap.put(\"Ps\", new int[] { Character.START_PUNCTUATION }); // Open\n-\t\tcategoryMap.put(\"Pe\", new int[] { Character.END_PUNCTUATION }); // Close\n-\t\tcategoryMap.put(\"Pi\", new int[] { Character.OTHER_PUNCTUATION }); // Initial quote (Unicode 3)\n-\t\tcategoryMap.put(\"Pf\", new int[] { Character.OTHER_PUNCTUATION }); // Final quote (Unicode 3)\n-\t\tcategoryMap.put(\"Po\", new int[] { Character.OTHER_PUNCTUATION }); // Other Punctuation\n-\n-\t\tcategoryMap.put(\"Z\", new int[] { Character.SPACE_SEPARATOR, Character.LINE_SEPARATOR, Character.PARAGRAPH_SEPARATOR }); // All\n-\t\t// Separators\n-\t\tcategoryMap.put(\"Zs\", new int[] { Character.SPACE_SEPARATOR }); // Space\n-\t\tcategoryMap.put(\"Zl\", new int[] { Character.LINE_SEPARATOR }); // Line\n-\t\tcategoryMap.put(\"Zp\", new int[] { Character.PARAGRAPH_SEPARATOR }); // Paragraph\n-\n-\t\tcategoryMap.put(\"S\", new int[] { Character.MATH_SYMBOL, Character.CURRENCY_SYMBOL, Character.MODIFIER_SYMBOL, Character.OTHER_SYMBOL }); // All\n-\t\t// Symbols\n-\t\tcategoryMap.put(\"Sm\", new int[] { Character.MATH_SYMBOL }); // Math\n-\t\tcategoryMap.put(\"Sc\", new int[] { Character.CURRENCY_SYMBOL }); // Currency\n-\t\tcategoryMap.put(\"Sk\", new int[] { Character.MODIFIER_SYMBOL }); // Modifier\n-\t\tcategoryMap.put(\"So\", new int[] { Character.OTHER_SYMBOL }); // Other Symbols\n-\n-\t\tcategoryMap.put(\"C\", new int[] { Character.CONTROL, Character.FORMAT, Character.SURROGATE, Character.PRIVATE_USE, Character.UNASSIGNED }); // All\n-\t\t// Others\n-\t\tcategoryMap.put(\"Cc\", new int[] { Character.CONTROL }); // Control\n-\t\tcategoryMap.put(\"Cf\", new int[] { Character.FORMAT }); // Format\n-\t\tcategoryMap.put(\"Cs\", new int[] { Character.SURROGATE }); // Surrogate\n-\t\tcategoryMap.put(\"Co\", new int[] { Character.PRIVATE_USE }); // Private Use\n-\t\tcategoryMap.put(\"Cn\", new int[] { Character.UNASSIGNED }); // Not Assigned\n-\n-\t\t// blocks are coded as ranges to stay compatible with Java 1.1\n-\t\t// (Java 1.2 adds Character.UnicodeBlock, which would help with Unicode 2 blocks)\n-\t\tblockMap.put(\"BasicLatin\", new int[] { '\\u0000', '\\u007F' });\n-\t\tblockMap.put(\"Latin-1Supplement\", new int[] { '\\u0080', '\\u00FF' });\n-\t\tblockMap.put(\"LatinExtended-A\", new int[] { '\\u0100', '\\u017F' });\n-\t\tblockMap.put(\"LatinExtended-B\", new int[] { '\\u0180', '\\u024F' });\n-\t\tblockMap.put(\"IPAExtensions\", new int[] { '\\u0250', '\\u02AF' });\n-\t\tblockMap.put(\"SpacingModifierLetters\", new int[] { '\\u02B0', '\\u02FF' });\n-\t\tblockMap.put(\"CombiningDiacriticalMarks\", new int[] { '\\u0300', '\\u036F' });\n-\t\tblockMap.put(\"Greek\", new int[] { '\\u0370', '\\u03FF' });\n-\t\tblockMap.put(\"Cyrillic\", new int[] { '\\u0400', '\\u04FF' });\n-\t\tblockMap.put(\"Armenian\", new int[] { '\\u0530', '\\u058F' });\n-\t\tblockMap.put(\"Hebrew\", new int[] { '\\u0590', '\\u05FF' });\n-\t\tblockMap.put(\"Arabic\", new int[] { '\\u0600', '\\u06FF' });\n-\t\tblockMap.put(\"Syriac\", new int[] { '\\u0700', '\\u074F' });\n-\t\tblockMap.put(\"Thaana\", new int[] { '\\u0780', '\\u07BF' });\n-\t\tblockMap.put(\"Devanagari\", new int[] { '\\u0900', '\\u097F' });\n-\t\tblockMap.put(\"Bengali\", new int[] { '\\u0980', '\\u09FF' });\n-\t\tblockMap.put(\"Gurmukhi\", new int[] { '\\u0A00', '\\u0A7F' });\n-\t\tblockMap.put(\"Gujarati\", new int[] { '\\u0A80', '\\u0AFF' });\n-\t\tblockMap.put(\"Oriya\", new int[] { '\\u0B00', '\\u0B7F' });\n-\t\tblockMap.put(\"Tamil\", new int[] { '\\u0B80', '\\u0BFF' });\n-\t\tblockMap.put(\"Telugu\", new int[] { '\\u0C00', '\\u0C7F' });\n-\t\tblockMap.put(\"Kannada\", new int[] { '\\u0C80', '\\u0CFF' });\n-\t\tblockMap.put(\"Malayalam\", new int[] { '\\u0D00', '\\u0D7F' });\n-\t\tblockMap.put(\"Sinhala\", new int[] { '\\u0D80', '\\u0DFF' });\n-\t\tblockMap.put(\"Thai\", new int[] { '\\u0E00', '\\u0E7F' });\n-\t\tblockMap.put(\"Lao\", new int[] { '\\u0E80', '\\u0EFF' });\n-\t\tblockMap.put(\"Tibetan\", new int[] { '\\u0F00', '\\u0FFF' });\n-\t\tblockMap.put(\"Myanmar\", new int[] { '\\u1000', '\\u109F' });\n-\t\tblockMap.put(\"Georgian\", new int[] { '\\u10A0', '\\u10FF' });\n-\t\tblockMap.put(\"HangulJamo\", new int[] { '\\u1100', '\\u11FF' });\n-\t\tblockMap.put(\"Ethiopic\", new int[] { '\\u1200', '\\u137F' });\n-\t\tblockMap.put(\"Cherokee\", new int[] { '\\u13A0', '\\u13FF' });\n-\t\tblockMap.put(\"UnifiedCanadianAboriginalSyllabics\", new int[] { '\\u1400', '\\u167F' });\n-\t\tblockMap.put(\"Ogham\", new int[] { '\\u1680', '\\u169F' });\n-\t\tblockMap.put(\"Runic\", new int[] { '\\u16A0', '\\u16FF' });\n-\t\tblockMap.put(\"Khmer\", new int[] { '\\u1780', '\\u17FF' });\n-\t\tblockMap.put(\"Mongolian\", new int[] { '\\u1800', '\\u18AF' });\n-\t\tblockMap.put(\"LatinExtendedAdditional\", new int[] { '\\u1E00', '\\u1EFF' });\n-\t\tblockMap.put(\"GreekExtended\", new int[] { '\\u1F00', '\\u1FFF' });\n-\t\tblockMap.put(\"GeneralPunctuation\", new int[] { '\\u2000', '\\u206F' });\n-\t\tblockMap.put(\"SuperscriptsandSubscripts\", new int[] { '\\u2070', '\\u209F' });\n-\t\tblockMap.put(\"CurrencySymbols\", new int[] { '\\u20A0', '\\u20CF' });\n-\t\tblockMap.put(\"CombiningMarksforSymbols\", new int[] { '\\u20D0', '\\u20FF' });\n-\t\tblockMap.put(\"LetterlikeSymbols\", new int[] { '\\u2100', '\\u214F' });\n-\t\tblockMap.put(\"NumberForms\", new int[] { '\\u2150', '\\u218F' });\n-\t\tblockMap.put(\"Arrows\", new int[] { '\\u2190', '\\u21FF' });\n-\t\tblockMap.put(\"MathematicalOperators\", new int[] { '\\u2200', '\\u22FF' });\n-\t\tblockMap.put(\"MiscellaneousTechnical\", new int[] { '\\u2300', '\\u23FF' });\n-\t\tblockMap.put(\"ControlPictures\", new int[] { '\\u2400', '\\u243F' });\n-\t\tblockMap.put(\"OpticalCharacterRecognition\", new int[] { '\\u2440', '\\u245F' });\n-\t\tblockMap.put(\"EnclosedAlphanumerics\", new int[] { '\\u2460', '\\u24FF' });\n-\t\tblockMap.put(\"BoxDrawing\", new int[] { '\\u2500', '\\u257F' });\n-\t\tblockMap.put(\"BlockElements\", new int[] { '\\u2580', '\\u259F' });\n-\t\tblockMap.put(\"GeometricShapes\", new int[] { '\\u25A0', '\\u25FF' });\n-\t\tblockMap.put(\"MiscellaneousSymbols\", new int[] { '\\u2600', '\\u26FF' });\n-\t\tblockMap.put(\"Dingbats\", new int[] { '\\u2700', '\\u27BF' });\n-\t\tblockMap.put(\"BraillePatterns\", new int[] { '\\u2800', '\\u28FF' });\n-\t\tblockMap.put(\"CJKRadicalsSupplement\", new int[] { '\\u2E80', '\\u2EFF' });\n-\t\tblockMap.put(\"KangxiRadicals\", new int[] { '\\u2F00', '\\u2FDF' });\n-\t\tblockMap.put(\"IdeographicDescriptionCharacters\", new int[] { '\\u2FF0', '\\u2FFF' });\n-\t\tblockMap.put(\"CJKSymbolsandPunctuation\", new int[] { '\\u3000', '\\u303F' });\n-\t\tblockMap.put(\"Hiragana\", new int[] { '\\u3040', '\\u309F' });\n-\t\tblockMap.put(\"Katakana\", new int[] { '\\u30A0', '\\u30FF' });\n-\t\tblockMap.put(\"Bopomofo\", new int[] { '\\u3100', '\\u312F' });\n-\t\tblockMap.put(\"HangulCompatibilityJamo\", new int[] { '\\u3130', '\\u318F' });\n-\t\tblockMap.put(\"Kanbun\", new int[] { '\\u3190', '\\u319F' });\n-\t\tblockMap.put(\"BopomofoExtended\", new int[] { '\\u31A0', '\\u31BF' });\n-\t\tblockMap.put(\"EnclosedCJKLettersandMonths\", new int[] { '\\u3200', '\\u32FF' });\n-\t\tblockMap.put(\"CJKCompatibility\", new int[] { '\\u3300', '\\u33FF' });\n-\t\tblockMap.put(\"CJKUnifiedIdeographsExtensionA\", new int[] { '\\u3400', '\\u4DB5' });\n-\t\tblockMap.put(\"CJKUnifiedIdeographs\", new int[] { '\\u4E00', '\\u9FFF' });\n-\t\tblockMap.put(\"YiSyllables\", new int[] { '\\uA000', '\\uA48F' });\n-\t\tblockMap.put(\"YiRadicals\", new int[] { '\\uA490', '\\uA4CF' });\n-\t\tblockMap.put(\"HangulSyllables\", new int[] { '\\uAC00', '\\uD7A3' });\n-\t\tblockMap.put(\"HighSurrogates\", new int[] { 0xD800, 0xDB7F });\n-\t\tblockMap.put(\"HighPrivateUseSurrogates\", new int[] { 0xDB80, 0xDBFF });\n-\t\tblockMap.put(\"LowSurrogates\", new int[] { 0xDC00, 0xDFFF });\n-\t\tblockMap.put(\"PrivateUse\", new int[] { '\\uE000', '\\uF8FF' });\n-\t\tblockMap.put(\"CJKCompatibilityIdeographs\", new int[] { '\\uF900', '\\uFAFF' });\n-\t\tblockMap.put(\"AlphabeticPresentationForms\", new int[] { '\\uFB00', '\\uFB4F' });\n-\t\tblockMap.put(\"ArabicPresentationForms-A\", new int[] { '\\uFB50', '\\uFDFF' });\n-\t\tblockMap.put(\"CombiningHalfMarks\", new int[] { '\\uFE20', '\\uFE2F' });\n-\t\tblockMap.put(\"CJKCompatibilityForms\", new int[] { '\\uFE30', '\\uFE4F' });\n-\t\tblockMap.put(\"SmallFormVariants\", new int[] { '\\uFE50', '\\uFE6F' });\n-\t\tblockMap.put(\"ArabicPresentationForms-B\", new int[] { '\\uFE70', '\\uFEFE' });\n-\t\t// blockMap.put(\"Specials\", new int[]{0xFEFF, 0xFEFF}); // Formal\n-\t\tblockMap.put(\"HalfwidthandFullwidthForms\", new int[] { '\\uFF00', '\\uFFEF' });\n-\t\t// blockMap.put(\"Specials\", new int[]{0xFFF0, 0xFFFD}); // Formal\n-\t\tblockMap.put(\"Specials\", new int[] { 0xFEFF, 0xFFFD }); // Range overlaps.\n-\t\tblockMap.put(\"OldItalic\", new int[] { 0x10300, 0x1032F });\n-\t\tblockMap.put(\"Gothic\", new int[] { 0x10330, 0x1034F });\n-\t\tblockMap.put(\"Deseret\", new int[] { 0x10400, 0x1044F });\n-\t\tblockMap.put(\"ByzantineMusicalSymbols\", new int[] { 0x1D000, 0x1D0FF });\n-\t\tblockMap.put(\"MusicalSymbols\", new int[] { 0x1D100, 0x1D1FF });\n-\t\tblockMap.put(\"MathematicalAlphanumericSymbols\", new int[] { 0x1D400, 0x1D7FF });\n-\t\tblockMap.put(\"CJKUnifiedIdeographsExtensionB\", new int[] { 0x20000, 0x2A6D6 });\n-\t\tblockMap.put(\"CJKCompatibilityIdeographsSupplement\", new int[] { 0x2F800, 0x2FA1F });\n-\t\tblockMap.put(\"Tags\", new int[] { 0xE0000, 0xFFFFD });\n-\t}\n-\n-\t/**\n-\t * set Unicode category\n-\t */\n-\tpublic void setCategory(final String category) throws StringRegExException\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(category, \"abbr\");\n-\t\tm_category = categoryMap.get(category);\n-\t\tif (m_category == null)\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidUnicodeCategory, category);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * set Unicode block to match against.\n-\t * \n-\t * @param blockName\n-\t *            the XSD-style block name (spaces removed)\n-\t */\n-\tpublic void setBlock(final String blockName) throws StringRegExException\n-\t{\n-\t\tfinal int range[] = blockMap.get(blockName);\n-\t\tif (range == null)\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidUnicodeBlockName, blockName);\n-\t\t}\n-\t\taddChar(range[0], range[1]);\n-\t}\n-\n-\tpublic void setOccurrence(final int min, final int max)\n-\t{\n-\t\tminOccurrence = min;\n-\t\tmaxOccurrence = max;\n-\t}\n-\n-\t/**\n-\t * returns whether this term contains a sequence of one or more subterms\n-\t */\n-\tpublic boolean isSequence()\n-\t{\n-\t\treturn type == Type.TYPE_SEQ;\n-\t}\n-\n-\t/**\n-\t * returns whether this term contains a choice of one or more subterms\n-\t */\n-\tpublic boolean isChoice()\n-\t{\n-\t\treturn type == Type.TYPE_CHOICE;\n-\t}\n-\n-\t/**\n-\t * returns whether this term contains a set of one or more subterms\n-\t */\n-\tpublic boolean isInterleave()\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * returns an Enumeration of this term's subterms\n-\t */\n-\tpublic Iterable<StringRegExPatternTerm> getSubTerms()\n-\t{\n-\t\treturn subTermList;\n-\t}\n-\n-\t/**\n-\t * returns whether this leaf term matches the given token.\n-\t */\n-\tpublic boolean matches(final String token)\n-\t{\n-\t\tif (type == Type.TYPE_LEAF_WILDCARD)\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\t// Debug.assert(type == TYPE_LEAF_POSITIVE || type == TYPE_LEAF_NEGATIVE);\n-\t\tboolean matched = false;\n-\t\tif (m_category != null)\n-\t\t{\n-\t\t\tif ((token != null) && token.length() > 0)\n-\t\t\t{\n-\t\t\t\tfor (int i = 0; i < m_category.length && !matched; i++)\n-\t\t\t\t{\n-\t\t\t\t\tmatched = m_category[i] == Character.getType(token.charAt(0));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfor (final Iterator<CharRange> i = rangeList.iterator(); i.hasNext() && !matched;)\n-\t\t\t{\n-\t\t\t\tmatched = i.next().matches(token);\n-\t\t\t}\n-\t\t\tfor (final Iterator<StringRegExPatternTerm> i = subTermList.iterator(); i.hasNext() && !matched;)\n-\t\t\t{\n-\t\t\t\tmatched = i.next().matches(token);\n-\t\t\t}\n-\t\t}\n-\t\tif (type == Type.TYPE_LEAF_NEGATIVE)\n-\t\t{\n-\t\t\tmatched = !matched;\n-\t\t}\n-\t\tif (matched && notTerm != null && notTerm.matches(token))\n-\t\t{\n-\t\t\tmatched = false;\n-\t\t}\n-\t\treturn matched;\n-\t}\n-\n-\t/**\n-\t * Returns true if this term and the other term are both leaf terms and there exist some tokens which match both\n-\t * terms. Used to check for determinism.\n-\t */\n-\tpublic boolean intersects(StringRegExPatternTerm other)\n-\t{\n-\t\tif (isLeaf() && other.isLeaf())\n-\t\t{\n-\t\t\tif (type == Type.TYPE_LEAF_WILDCARD || other.type == Type.TYPE_LEAF_WILDCARD)\n-\t\t\t\treturn true;\n-\t\t\tif (type == Type.TYPE_LEAF_NEGATIVE)\n-\t\t\t{\n-\t\t\t\tif (other.type == Type.TYPE_LEAF_POSITIVE)\n-\t\t\t\t\treturn other.intersects(this); // prefer this being positive\n-\t\t\t\telse\n-\t\t\t\t\treturn false; // both negative => assume intersects\n-\t\t\t}\n-\t\t\tif (m_category != null)\n-\t\t\t{\n-\t\t\t\tif (other.m_category == null)\n-\t\t\t\t\treturn other.intersects(this); // prefer this being non-category\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\t// only intersect if they share same categories\n-\t\t\t\t\tfor (final int x : m_category)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfor (final int y : other.m_category)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (x == y)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// fixme should check categories\n-\t\t\t// type must be positive (though we could have negative subterms)\n-\t\t\t// see if any of our elements match 'other'\n-\t\t\tfor (final CharRange cr : rangeList)\n-\t\t\t{\n-\t\t\t\tfor (int c = cr.getFirst(); c <= cr.getLast(); c++)\n-\t\t\t\t{\n-\t\t\t\t\tif (notTerm != null && notTerm.matches(String.valueOf(c)))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (other.matches(String.valueOf(c)))\n-\t\t\t\t\t{\n-\t\t\t\t\t\treturn true; // they intersect\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfor (final StringRegExPatternTerm term : subTermList)\n-\t\t\t{\n-\t\t\t\tif (term.intersects(other))\n-\t\t\t\t{\n-\t\t\t\t\treturn true; // they intersect\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tprotected boolean isLeaf()\n-\t{\n-\t\treturn type == Type.TYPE_LEAF_WILDCARD || type == Type.TYPE_LEAF_POSITIVE || type == Type.TYPE_LEAF_NEGATIVE;\n-\t}\n-\n-\t/**\n-\t * returns the minimum number of occurrences of this term.\n-\t */\n-\tpublic int minOccurs()\n-\t{\n-\t\treturn minOccurrence;\n-\t}\n-\n-\t/**\n-\t * returns the maximum number of occurrences of this term. returns Integer.MAX_VALUE to indicate unlimited\n-\t * occurrences.\n-\t */\n-\tpublic int maxOccurs()\n-\t{\n-\t\treturn maxOccurrence;\n-\t}\n-\n-\tpublic String toString()\n-\t{\n-\t\tString s = \"\";\n-\t\tif (isChoice())\n-\t\t{\n-\t\t\ts += \"(\";\n-\t\t\tfor (int i = 0; i < subTermList.size(); i++)\n-\t\t\t{\n-\t\t\t\tif (i > 0)\n-\t\t\t\t\ts += \" | \";\n-\t\t\t\ts += subTermList.get(i).toString();\n-\t\t\t}\n-\t\t\ts += \")\";\n-\t\t}\n-\t\telse if (isSequence())\n-\t\t{\n-\t\t\ts += \"(\";\n-\t\t\tfor (int i = 0; i < subTermList.size(); i++)\n-\t\t\t{\n-\t\t\t\tif (i > 0)\n-\t\t\t\t\ts += \", \";\n-\t\t\t\ts += subTermList.get(i).toString();\n-\t\t\t}\n-\t\t\ts += \")\";\n-\t\t}\n-\t\telse if (type == Type.TYPE_LEAF_WILDCARD)\n-\t\t{\n-\t\t\ts = \"WILDCARD\";\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (type == Type.TYPE_LEAF_POSITIVE && subTermList.size() == 0 && rangeList.size() == 1 && rangeList.get(0).toString().length() == 1)\n-\t\t\t\ts = rangeList.get(0).toString();\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\ts += \"[\";\n-\t\t\t\tif (type == Type.TYPE_LEAF_NEGATIVE)\n-\t\t\t\t\ts += \"^\";\n-\t\t\t\tif (m_category != null)\n-\t\t\t\t{\n-\t\t\t\t\ts += \"UnicodeProperty(\";\n-\t\t\t\t\tfor (int i = 0; i < m_category.length; i++)\n-\t\t\t\t\t\ts += (i == 0 ? \"\" : \",\") + m_category[i];\n-\t\t\t\t\ts += \")\";\n-\t\t\t\t}\n-\t\t\t\tfor (final CharRange cr : rangeList)\n-\t\t\t\t{\n-\t\t\t\t\ts += cr.toString();\n-\t\t\t\t}\n-\t\t\t\tfor (final StringRegExPatternTerm term : subTermList)\n-\t\t\t\t{\n-\t\t\t\t\ts += term.toString();\n-\t\t\t\t}\n-\t\t\t\tif (notTerm != null)\n-\t\t\t\t\ts += \"-\" + notTerm.toString();\n-\t\t\t\ts += \"]\";\n-\t\t\t}\n-\t\t}\n-\t\tif (minOccurrence == 1 && maxOccurrence == 1)\n-\t\t{\n-\t\t\t// Do nothing\n-\t\t}\n-\t\telse if (minOccurrence == 0 && maxOccurrence == 1)\n-\t\t{\n-\t\t\ts += \"?\";\n-\t\t}\n-\t\telse if (minOccurrence == 0 && maxOccurrence == RegExBridge.UNBOUNDED)\n-\t\t{\n-\t\t\ts += \"*\";\n-\t\t}\n-\t\telse if (minOccurrence == 1 && maxOccurrence == RegExBridge.UNBOUNDED)\n-\t\t{\n-\t\t\ts += \"+\";\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\ts += \"{\" + minOccurrence + \",\";\n-\t\t\tif (maxOccurrence != RegExBridge.UNBOUNDED)\n-\t\t\t{\n-\t\t\t\ts += maxOccurrence;\n-\t\t\t}\n-\t\t\ts += \"}\";\n-\t\t}\n-\t\treturn s;\n-\t}\n-\n-\tstatic String ctoUnicodeEsc(final int i)\n-\t{\n-\t\tchar out[] = { '\\\\', 'u', Character.forDigit((i >> 12) & 0xF, 16), Character.forDigit((i >> 8) & 0xF, 16), Character.forDigit((i >> 4) & 0xF, 16), Character.forDigit(i & 0xF, 16) };\n-\t\treturn new String(out);\n-\t}\n-\n-\tpublic static String charString(int c)\n-\t{\n-\t\tif (c < ' ' || c >= 255)\n-\t\t{\n-\t\t\treturn ctoUnicodeEsc(c);\n-\t\t}\n-\t\tswitch (c)\n-\t\t{\n-\t\t\tcase StringRegExParser.NEWLINE:\n-\t\t\t\treturn \"\\\\n\";\n-\t\t\tcase StringRegExParser.RETURN:\n-\t\t\t\treturn \"\\\\r\";\n-\t\t\tcase StringRegExParser.TAB:\n-\t\t\t\treturn \"\\\\t\";\n-\t\t\tcase '\\\\':\n-\t\t\t\treturn \"\\\\\\\\\";\n-\t\t\tcase '.':\n-\t\t\tcase '-':\n-\t\t\tcase '|':\n-\t\t\tcase '^':\n-\t\t\tcase '?':\n-\t\t\tcase '*':\n-\t\t\tcase '+':\n-\t\t\tcase '[':\n-\t\t\tcase ']':\n-\t\t\tcase '(':\n-\t\t\tcase ')':\n-\t\t\tcase '{':\n-\t\t\tcase '}':\n-\t\t\t\treturn \"\\\\\" + c;\n-\t\t}\n-\t\treturn \"\" + c;\n-\t}\n+public final class StringRegExPatternTerm {\n+    public enum Type {\n+        TYPE_SEQ, TYPE_CHOICE, TYPE_LEAF_POSITIVE, TYPE_LEAF_NEGATIVE, TYPE_LEAF_WILDCARD\n+    }\n+\n+    private int minOccurrence = 1;\n+\n+    private int maxOccurrence = 1;\n+\n+    private Type type;\n+\n+    // Support for range of Unicode categories as defined by the Character class\n+    private int[] m_category;\n+\n+    /**\n+     * List of {@link StringRegExPatternTerm} (for seq or choice)\n+     */\n+    private final List<StringRegExPatternTerm> subTermList =\n+        new ArrayList<StringRegExPatternTerm>();\n+\n+    /**\n+     * List of {@link CharRange} (for leaf)\n+     */\n+    private final List<CharRange> rangeList = new ArrayList<CharRange>();\n+\n+    private StringRegExPatternTerm notTerm;\n+\n+    public StringRegExPatternTerm(final Type type) {\n+        this.type = type;\n+    }\n+\n+    /**\n+     * a single character\n+     */\n+    public StringRegExPatternTerm(char c) {\n+        this.type = Type.TYPE_LEAF_POSITIVE;\n+        rangeList.add(new CharRange(c));\n+    }\n+\n+    public void addSubTerm(StringRegExPatternTerm subTerm) {\n+        subTermList.add(subTerm);\n+    }\n+\n+    public void addChar(char c) {\n+        rangeList.add(new CharRange(c));\n+    }\n+\n+    public void addChar(final int first, final int last) {\n+        rangeList.add(new CharRange(first, last));\n+    }\n+\n+    /**\n+     * converts the last two range items into one\n+     */\n+    public void combineRanges() {\n+        final CharRange a = rangeList.get(rangeList.size() - 2);\n+        final CharRange b = rangeList.get(rangeList.size() - 1);\n+        a.setLast(b.getLast());\n+        rangeList.remove(rangeList.size() - 1);\n+    }\n+\n+    public void addNegativeTerm(final StringRegExPatternTerm term) {\n+        notTerm = term;\n+    }\n+\n+    /**\n+     * map Unicode category abbr => array of Character constants\n+     */\n+    protected static final HashMap<String, int[]> categoryMap = new HashMap<String, int[]>();\n+\n+    /**\n+     * Maps block name string => Character.UnicodeBlock\n+     */\n+    protected static final HashMap<String, int[]> blockMap = new HashMap<String, int[]>();\n+\n+    static {\n+        categoryMap.put(\"L\", new int[] {Character.UPPERCASE_LETTER, Character.LOWERCASE_LETTER,\n+            Character.TITLECASE_LETTER, Character.MODIFIER_LETTER, Character.OTHER_LETTER}); // All\n+        // Letters\n+        categoryMap.put(\"Lu\", new int[] {Character.UPPERCASE_LETTER}); // Uppercase\n+        categoryMap.put(\"Ll\", new int[] {Character.LOWERCASE_LETTER}); // Lowercase\n+        categoryMap.put(\"Lt\", new int[] {Character.TITLECASE_LETTER}); // Titlecase\n+        categoryMap.put(\"Lm\", new int[] {Character.MODIFIER_LETTER}); // Modifier\n+        categoryMap.put(\"Lo\", new int[] {Character.OTHER_LETTER}); // Other Letters\n+\n+        categoryMap.put(\"M\",\n+            new int[] {Character.NON_SPACING_MARK, Character.COMBINING_SPACING_MARK,\n+                Character.ENCLOSING_MARK}); // All\n+        // Marks\n+        categoryMap.put(\"Mn\", new int[] {Character.NON_SPACING_MARK}); // Non-Spacing\n+        categoryMap.put(\"Mc\", new int[] {Character.COMBINING_SPACING_MARK}); // Spacing Combining\n+        categoryMap.put(\"Me\", new int[] {Character.ENCLOSING_MARK}); // Enclosing\n+\n+        categoryMap.put(\"N\", new int[] {Character.DECIMAL_DIGIT_NUMBER, Character.LETTER_NUMBER,\n+            Character.OTHER_NUMBER}); // All\n+        // Numbers\n+        categoryMap.put(\"Nd\", new int[] {Character.DECIMAL_DIGIT_NUMBER}); // Decimal Digit\n+        categoryMap.put(\"Nl\", new int[] {Character.LETTER_NUMBER}); // Letter\n+        categoryMap.put(\"No\", new int[] {Character.OTHER_NUMBER}); // Other Numbers\n+\n+        categoryMap.put(\"P\", new int[] {Character.CONNECTOR_PUNCTUATION, Character.DASH_PUNCTUATION,\n+            Character.START_PUNCTUATION, Character.END_PUNCTUATION,\n+            Character.OTHER_PUNCTUATION}); // All\n+        // Punctuation\n+        categoryMap.put(\"Pc\", new int[] {Character.CONNECTOR_PUNCTUATION}); // Connector\n+        categoryMap.put(\"Pd\", new int[] {Character.DASH_PUNCTUATION}); // Dash\n+        categoryMap.put(\"Ps\", new int[] {Character.START_PUNCTUATION}); // Open\n+        categoryMap.put(\"Pe\", new int[] {Character.END_PUNCTUATION}); // Close\n+        categoryMap.put(\"Pi\", new int[] {Character.OTHER_PUNCTUATION}); // Initial quote (Unicode 3)\n+        categoryMap.put(\"Pf\", new int[] {Character.OTHER_PUNCTUATION}); // Final quote (Unicode 3)\n+        categoryMap.put(\"Po\", new int[] {Character.OTHER_PUNCTUATION}); // Other Punctuation\n+\n+        categoryMap.put(\"Z\", new int[] {Character.SPACE_SEPARATOR, Character.LINE_SEPARATOR,\n+            Character.PARAGRAPH_SEPARATOR}); // All\n+        // Separators\n+        categoryMap.put(\"Zs\", new int[] {Character.SPACE_SEPARATOR}); // Space\n+        categoryMap.put(\"Zl\", new int[] {Character.LINE_SEPARATOR}); // Line\n+        categoryMap.put(\"Zp\", new int[] {Character.PARAGRAPH_SEPARATOR}); // Paragraph\n+\n+        categoryMap.put(\"S\",\n+            new int[] {Character.MATH_SYMBOL, Character.CURRENCY_SYMBOL, Character.MODIFIER_SYMBOL,\n+                Character.OTHER_SYMBOL}); // All\n+        // Symbols\n+        categoryMap.put(\"Sm\", new int[] {Character.MATH_SYMBOL}); // Math\n+        categoryMap.put(\"Sc\", new int[] {Character.CURRENCY_SYMBOL}); // Currency\n+        categoryMap.put(\"Sk\", new int[] {Character.MODIFIER_SYMBOL}); // Modifier\n+        categoryMap.put(\"So\", new int[] {Character.OTHER_SYMBOL}); // Other Symbols\n+\n+        categoryMap.put(\"C\", new int[] {Character.CONTROL, Character.FORMAT, Character.SURROGATE,\n+            Character.PRIVATE_USE, Character.UNASSIGNED}); // All\n+        // Others\n+        categoryMap.put(\"Cc\", new int[] {Character.CONTROL}); // Control\n+        categoryMap.put(\"Cf\", new int[] {Character.FORMAT}); // Format\n+        categoryMap.put(\"Cs\", new int[] {Character.SURROGATE}); // Surrogate\n+        categoryMap.put(\"Co\", new int[] {Character.PRIVATE_USE}); // Private Use\n+        categoryMap.put(\"Cn\", new int[] {Character.UNASSIGNED}); // Not Assigned\n+\n+        // blocks are coded as ranges to stay compatible with Java 1.1\n+        // (Java 1.2 adds Character.UnicodeBlock, which would help with Unicode 2 blocks)\n+        blockMap.put(\"BasicLatin\", new int[] {'\\u0000', '\\u007F'});\n+        blockMap.put(\"Latin-1Supplement\", new int[] {'\\u0080', '\\u00FF'});\n+        blockMap.put(\"LatinExtended-A\", new int[] {'\\u0100', '\\u017F'});\n+        blockMap.put(\"LatinExtended-B\", new int[] {'\\u0180', '\\u024F'});\n+        blockMap.put(\"IPAExtensions\", new int[] {'\\u0250', '\\u02AF'});\n+        blockMap.put(\"SpacingModifierLetters\", new int[] {'\\u02B0', '\\u02FF'});\n+        blockMap.put(\"CombiningDiacriticalMarks\", new int[] {'\\u0300', '\\u036F'});\n+        blockMap.put(\"Greek\", new int[] {'\\u0370', '\\u03FF'});\n+        blockMap.put(\"Cyrillic\", new int[] {'\\u0400', '\\u04FF'});\n+        blockMap.put(\"Armenian\", new int[] {'\\u0530', '\\u058F'});\n+        blockMap.put(\"Hebrew\", new int[] {'\\u0590', '\\u05FF'});\n+        blockMap.put(\"Arabic\", new int[] {'\\u0600', '\\u06FF'});\n+        blockMap.put(\"Syriac\", new int[] {'\\u0700', '\\u074F'});\n+        blockMap.put(\"Thaana\", new int[] {'\\u0780', '\\u07BF'});\n+        blockMap.put(\"Devanagari\", new int[] {'\\u0900', '\\u097F'});\n+        blockMap.put(\"Bengali\", new int[] {'\\u0980', '\\u09FF'});\n+        blockMap.put(\"Gurmukhi\", new int[] {'\\u0A00', '\\u0A7F'});\n+        blockMap.put(\"Gujarati\", new int[] {'\\u0A80', '\\u0AFF'});\n+        blockMap.put(\"Oriya\", new int[] {'\\u0B00', '\\u0B7F'});\n+        blockMap.put(\"Tamil\", new int[] {'\\u0B80', '\\u0BFF'});\n+        blockMap.put(\"Telugu\", new int[] {'\\u0C00', '\\u0C7F'});\n+        blockMap.put(\"Kannada\", new int[] {'\\u0C80', '\\u0CFF'});\n+        blockMap.put(\"Malayalam\", new int[] {'\\u0D00', '\\u0D7F'});\n+        blockMap.put(\"Sinhala\", new int[] {'\\u0D80', '\\u0DFF'});\n+        blockMap.put(\"Thai\", new int[] {'\\u0E00', '\\u0E7F'});\n+        blockMap.put(\"Lao\", new int[] {'\\u0E80', '\\u0EFF'});\n+        blockMap.put(\"Tibetan\", new int[] {'\\u0F00', '\\u0FFF'});\n+        blockMap.put(\"Myanmar\", new int[] {'\\u1000', '\\u109F'});\n+        blockMap.put(\"Georgian\", new int[] {'\\u10A0', '\\u10FF'});\n+        blockMap.put(\"HangulJamo\", new int[] {'\\u1100', '\\u11FF'});\n+        blockMap.put(\"Ethiopic\", new int[] {'\\u1200', '\\u137F'});\n+        blockMap.put(\"Cherokee\", new int[] {'\\u13A0', '\\u13FF'});\n+        blockMap.put(\"UnifiedCanadianAboriginalSyllabics\", new int[] {'\\u1400', '\\u167F'});\n+        blockMap.put(\"Ogham\", new int[] {'\\u1680', '\\u169F'});\n+        blockMap.put(\"Runic\", new int[] {'\\u16A0', '\\u16FF'});\n+        blockMap.put(\"Khmer\", new int[] {'\\u1780', '\\u17FF'});\n+        blockMap.put(\"Mongolian\", new int[] {'\\u1800', '\\u18AF'});\n+        blockMap.put(\"LatinExtendedAdditional\", new int[] {'\\u1E00', '\\u1EFF'});\n+        blockMap.put(\"GreekExtended\", new int[] {'\\u1F00', '\\u1FFF'});\n+        blockMap.put(\"GeneralPunctuation\", new int[] {'\\u2000', '\\u206F'});\n+        blockMap.put(\"SuperscriptsandSubscripts\", new int[] {'\\u2070', '\\u209F'});\n+        blockMap.put(\"CurrencySymbols\", new int[] {'\\u20A0', '\\u20CF'});\n+        blockMap.put(\"CombiningMarksforSymbols\", new int[] {'\\u20D0', '\\u20FF'});\n+        blockMap.put(\"LetterlikeSymbols\", new int[] {'\\u2100', '\\u214F'});\n+        blockMap.put(\"NumberForms\", new int[] {'\\u2150', '\\u218F'});\n+        blockMap.put(\"Arrows\", new int[] {'\\u2190', '\\u21FF'});\n+        blockMap.put(\"MathematicalOperators\", new int[] {'\\u2200', '\\u22FF'});\n+        blockMap.put(\"MiscellaneousTechnical\", new int[] {'\\u2300', '\\u23FF'});\n+        blockMap.put(\"ControlPictures\", new int[] {'\\u2400', '\\u243F'});\n+        blockMap.put(\"OpticalCharacterRecognition\", new int[] {'\\u2440', '\\u245F'});\n+        blockMap.put(\"EnclosedAlphanumerics\", new int[] {'\\u2460', '\\u24FF'});\n+        blockMap.put(\"BoxDrawing\", new int[] {'\\u2500', '\\u257F'});\n+        blockMap.put(\"BlockElements\", new int[] {'\\u2580', '\\u259F'});\n+        blockMap.put(\"GeometricShapes\", new int[] {'\\u25A0', '\\u25FF'});\n+        blockMap.put(\"MiscellaneousSymbols\", new int[] {'\\u2600', '\\u26FF'});\n+        blockMap.put(\"Dingbats\", new int[] {'\\u2700', '\\u27BF'});\n+        blockMap.put(\"BraillePatterns\", new int[] {'\\u2800', '\\u28FF'});\n+        blockMap.put(\"CJKRadicalsSupplement\", new int[] {'\\u2E80', '\\u2EFF'});\n+        blockMap.put(\"KangxiRadicals\", new int[] {'\\u2F00', '\\u2FDF'});\n+        blockMap.put(\"IdeographicDescriptionCharacters\", new int[] {'\\u2FF0', '\\u2FFF'});\n+        blockMap.put(\"CJKSymbolsandPunctuation\", new int[] {'\\u3000', '\\u303F'});\n+        blockMap.put(\"Hiragana\", new int[] {'\\u3040', '\\u309F'});\n+        blockMap.put(\"Katakana\", new int[] {'\\u30A0', '\\u30FF'});\n+        blockMap.put(\"Bopomofo\", new int[] {'\\u3100', '\\u312F'});\n+        blockMap.put(\"HangulCompatibilityJamo\", new int[] {'\\u3130', '\\u318F'});\n+        blockMap.put(\"Kanbun\", new int[] {'\\u3190', '\\u319F'});\n+        blockMap.put(\"BopomofoExtended\", new int[] {'\\u31A0', '\\u31BF'});\n+        blockMap.put(\"EnclosedCJKLettersandMonths\", new int[] {'\\u3200', '\\u32FF'});\n+        blockMap.put(\"CJKCompatibility\", new int[] {'\\u3300', '\\u33FF'});\n+        blockMap.put(\"CJKUnifiedIdeographsExtensionA\", new int[] {'\\u3400', '\\u4DB5'});\n+        blockMap.put(\"CJKUnifiedIdeographs\", new int[] {'\\u4E00', '\\u9FFF'});\n+        blockMap.put(\"YiSyllables\", new int[] {'\\uA000', '\\uA48F'});\n+        blockMap.put(\"YiRadicals\", new int[] {'\\uA490', '\\uA4CF'});\n+        blockMap.put(\"HangulSyllables\", new int[] {'\\uAC00', '\\uD7A3'});\n+        blockMap.put(\"HighSurrogates\", new int[] {0xD800, 0xDB7F});\n+        blockMap.put(\"HighPrivateUseSurrogates\", new int[] {0xDB80, 0xDBFF});\n+        blockMap.put(\"LowSurrogates\", new int[] {0xDC00, 0xDFFF});\n+        blockMap.put(\"PrivateUse\", new int[] {'\\uE000', '\\uF8FF'});\n+        blockMap.put(\"CJKCompatibilityIdeographs\", new int[] {'\\uF900', '\\uFAFF'});\n+        blockMap.put(\"AlphabeticPresentationForms\", new int[] {'\\uFB00', '\\uFB4F'});\n+        blockMap.put(\"ArabicPresentationForms-A\", new int[] {'\\uFB50', '\\uFDFF'});\n+        blockMap.put(\"CombiningHalfMarks\", new int[] {'\\uFE20', '\\uFE2F'});\n+        blockMap.put(\"CJKCompatibilityForms\", new int[] {'\\uFE30', '\\uFE4F'});\n+        blockMap.put(\"SmallFormVariants\", new int[] {'\\uFE50', '\\uFE6F'});\n+        blockMap.put(\"ArabicPresentationForms-B\", new int[] {'\\uFE70', '\\uFEFE'});\n+        // blockMap.put(\"Specials\", new int[]{0xFEFF, 0xFEFF}); // Formal\n+        blockMap.put(\"HalfwidthandFullwidthForms\", new int[] {'\\uFF00', '\\uFFEF'});\n+        // blockMap.put(\"Specials\", new int[]{0xFFF0, 0xFFFD}); // Formal\n+        blockMap.put(\"Specials\", new int[] {0xFEFF, 0xFFFD}); // Range overlaps.\n+        blockMap.put(\"OldItalic\", new int[] {0x10300, 0x1032F});\n+        blockMap.put(\"Gothic\", new int[] {0x10330, 0x1034F});\n+        blockMap.put(\"Deseret\", new int[] {0x10400, 0x1044F});\n+        blockMap.put(\"ByzantineMusicalSymbols\", new int[] {0x1D000, 0x1D0FF});\n+        blockMap.put(\"MusicalSymbols\", new int[] {0x1D100, 0x1D1FF});\n+        blockMap.put(\"MathematicalAlphanumericSymbols\", new int[] {0x1D400, 0x1D7FF});\n+        blockMap.put(\"CJKUnifiedIdeographsExtensionB\", new int[] {0x20000, 0x2A6D6});\n+        blockMap.put(\"CJKCompatibilityIdeographsSupplement\", new int[] {0x2F800, 0x2FA1F});\n+        blockMap.put(\"Tags\", new int[] {0xE0000, 0xFFFFD});\n+    }\n+\n+    /**\n+     * set Unicode category\n+     */\n+    public void setCategory(final String category) throws StringRegExException {\n+        PreCondition.assertArgumentNotNull(category, \"abbr\");\n+        m_category = categoryMap.get(category);\n+        if (m_category == null) {\n+            throw new StringRegExException(StringRegExException.Kind.invalidUnicodeCategory,\n+                category);\n+        }\n+    }\n+\n+    /**\n+     * set Unicode block to match against.\n+     *\n+     * @param blockName\n+     *            the XSD-style block name (spaces removed)\n+     */\n+    public void setBlock(final String blockName) throws StringRegExException {\n+        final int range[] = blockMap.get(blockName);\n+        if (range == null) {\n+            throw new StringRegExException(StringRegExException.Kind.invalidUnicodeBlockName,\n+                blockName);\n+        }\n+        addChar(range[0], range[1]);\n+    }\n+\n+    public void setOccurrence(final int min, final int max) {\n+        minOccurrence = min;\n+        maxOccurrence = max;\n+    }\n+\n+    /**\n+     * returns whether this term contains a sequence of one or more subterms\n+     */\n+    public boolean isSequence() {\n+        return type == Type.TYPE_SEQ;\n+    }\n+\n+    /**\n+     * returns whether this term contains a choice of one or more subterms\n+     */\n+    public boolean isChoice() {\n+        return type == Type.TYPE_CHOICE;\n+    }\n+\n+    /**\n+     * returns whether this term contains a set of one or more subterms\n+     */\n+    public boolean isInterleave() {\n+        return false;\n+    }\n+\n+    /**\n+     * returns an Enumeration of this term's subterms\n+     */\n+    public Iterable<StringRegExPatternTerm> getSubTerms() {\n+        return subTermList;\n+    }\n+\n+    /**\n+     * returns whether this leaf term matches the given token.\n+     */\n+    public boolean matches(final String token) {\n+        if (type == Type.TYPE_LEAF_WILDCARD) {\n+            return true;\n+        }\n+        // Debug.assert(type == TYPE_LEAF_POSITIVE || type == TYPE_LEAF_NEGATIVE);\n+        boolean matched = false;\n+        if (m_category != null) {\n+            if ((token != null) && token.length() > 0) {\n+                for (int i = 0; i < m_category.length && !matched; i++) {\n+                    matched = m_category[i] == Character.getType(token.charAt(0));\n+                }\n+            }\n+        } else {\n+            for (final Iterator<CharRange> i = rangeList.iterator(); i.hasNext() && !matched; ) {\n+                matched = i.next().matches(token);\n+            }\n+            for (final Iterator<StringRegExPatternTerm> i = subTermList.iterator();\n+                 i.hasNext() && !matched; ) {\n+                matched = i.next().matches(token);\n+            }\n+        }\n+        if (type == Type.TYPE_LEAF_NEGATIVE) {\n+            matched = !matched;\n+        }\n+        if (matched && notTerm != null && notTerm.matches(token)) {\n+            matched = false;\n+        }\n+        return matched;\n+    }\n+\n+    /**\n+     * Returns true if this term and the other term are both leaf terms and there exist some tokens which match both\n+     * terms. Used to check for determinism.\n+     */\n+    public boolean intersects(StringRegExPatternTerm other) {\n+        if (isLeaf() && other.isLeaf()) {\n+            if (type == Type.TYPE_LEAF_WILDCARD || other.type == Type.TYPE_LEAF_WILDCARD) {\n+                return true;\n+            }\n+            if (type == Type.TYPE_LEAF_NEGATIVE) {\n+                if (other.type == Type.TYPE_LEAF_POSITIVE) {\n+                    return other.intersects(this); // prefer this being positive\n+                } else {\n+                    return false; // both negative => assume intersects\n+                }\n+            }\n+            if (m_category != null) {\n+                if (other.m_category == null) {\n+                    return other.intersects(this); // prefer this being non-category\n+                } else {\n+                    // only intersect if they share same categories\n+                    for (final int x : m_category) {\n+                        for (final int y : other.m_category) {\n+                            if (x == y) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                    return false;\n+                }\n+            }\n+            // fixme should check categories\n+            // type must be positive (though we could have negative subterms)\n+            // see if any of our elements match 'other'\n+            for (final CharRange cr : rangeList) {\n+                for (int c = cr.getFirst(); c <= cr.getLast(); c++) {\n+                    if (notTerm != null && notTerm.matches(String.valueOf(c))) {\n+                        continue;\n+                    }\n+                    if (other.matches(String.valueOf(c))) {\n+                        return true; // they intersect\n+                    }\n+                }\n+            }\n+            for (final StringRegExPatternTerm term : subTermList) {\n+                if (term.intersects(other)) {\n+                    return true; // they intersect\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean isLeaf() {\n+        return type == Type.TYPE_LEAF_WILDCARD || type == Type.TYPE_LEAF_POSITIVE ||\n+            type == Type.TYPE_LEAF_NEGATIVE;\n+    }\n+\n+    /**\n+     * returns the minimum number of occurrences of this term.\n+     */\n+    public int minOccurs() {\n+        return minOccurrence;\n+    }\n+\n+    /**\n+     * returns the maximum number of occurrences of this term. returns Integer.MAX_VALUE to indicate unlimited\n+     * occurrences.\n+     */\n+    public int maxOccurs() {\n+        return maxOccurrence;\n+    }\n+\n+    public String toString() {\n+        String s = \"\";\n+        if (isChoice()) {\n+            s += \"(\";\n+            for (int i = 0; i < subTermList.size(); i++) {\n+                if (i > 0) {\n+                    s += \" | \";\n+                }\n+                s += subTermList.get(i).toString();\n+            }\n+            s += \")\";\n+        } else if (isSequence()) {\n+            s += \"(\";\n+            for (int i = 0; i < subTermList.size(); i++) {\n+                if (i > 0) {\n+                    s += \", \";\n+                }\n+                s += subTermList.get(i).toString();\n+            }\n+            s += \")\";\n+        } else if (type == Type.TYPE_LEAF_WILDCARD) {\n+            s = \"WILDCARD\";\n+        } else {\n+            if (type == Type.TYPE_LEAF_POSITIVE && subTermList.size() == 0 &&\n+                rangeList.size() == 1 && rangeList.get(0).toString().length() == 1) {\n+                s = rangeList.get(0).toString();\n+            } else {\n+                s += \"[\";\n+                if (type == Type.TYPE_LEAF_NEGATIVE) {\n+                    s += \"^\";\n+                }\n+                if (m_category != null) {\n+                    s += \"UnicodeProperty(\";\n+                    for (int i = 0; i < m_category.length; i++) {\n+                        s += (i == 0 ? \"\" : \",\") + m_category[i];\n+                    }\n+                    s += \")\";\n+                }\n+                for (final CharRange cr : rangeList) {\n+                    s += cr.toString();\n+                }\n+                for (final StringRegExPatternTerm term : subTermList) {\n+                    s += term.toString();\n+                }\n+                if (notTerm != null) {\n+                    s += \"-\" + notTerm.toString();\n+                }\n+                s += \"]\";\n+            }\n+        }\n+        if (minOccurrence == 1 && maxOccurrence == 1) {\n+            // Do nothing\n+        } else if (minOccurrence == 0 && maxOccurrence == 1) {\n+            s += \"?\";\n+        } else if (minOccurrence == 0 && maxOccurrence == RegExBridge.UNBOUNDED) {\n+            s += \"*\";\n+        } else if (minOccurrence == 1 && maxOccurrence == RegExBridge.UNBOUNDED) {\n+            s += \"+\";\n+        } else {\n+            s += \"{\" + minOccurrence + \",\";\n+            if (maxOccurrence != RegExBridge.UNBOUNDED) {\n+                s += maxOccurrence;\n+            }\n+            s += \"}\";\n+        }\n+        return s;\n+    }\n+\n+    static String ctoUnicodeEsc(final int i) {\n+        char out[] = {'\\\\', 'u', Character.forDigit((i >> 12) & 0xF, 16),\n+            Character.forDigit((i >> 8) & 0xF, 16), Character.forDigit((i >> 4) & 0xF, 16),\n+            Character.forDigit(i & 0xF, 16)};\n+        return new String(out);\n+    }\n+\n+    public static String charString(int c) {\n+        if (c < ' ' || c >= 255) {\n+            return ctoUnicodeEsc(c);\n+        }\n+        switch (c) {\n+            case StringRegExParser.NEWLINE:\n+                return \"\\\\n\";\n+            case StringRegExParser.RETURN:\n+                return \"\\\\r\";\n+            case StringRegExParser.TAB:\n+                return \"\\\\t\";\n+            case '\\\\':\n+                return \"\\\\\\\\\";\n+            case '.':\n+            case '-':\n+            case '|':\n+            case '^':\n+            case '?':\n+            case '*':\n+            case '+':\n+            case '[':\n+            case ']':\n+            case '(':\n+            case ')':\n+            case '{':\n+            case '}':\n+                return \"\\\\\" + c;\n+        }\n+        return \"\" + c;\n+    }\n }\n",
            "diff_size": 563
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/113/StringRegExPatternTerm.java\nindex 5966d92c3b9..1592dacb591 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/113/StringRegExPatternTerm.java\n@@ -19,7 +19,6 @@ import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n \n@@ -29,562 +28,574 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  * set of characters. A leaf term is represented as a collection of ranges and a set of subterms or by a unicode\n  * category.\n  */\n+\n public final class StringRegExPatternTerm\n {\n-\tpublic enum Type\n-\t{\n-\t\tTYPE_SEQ, TYPE_CHOICE, TYPE_LEAF_POSITIVE, TYPE_LEAF_NEGATIVE, TYPE_LEAF_WILDCARD\n-\t}\n-\n-\tprivate int minOccurrence = 1;\n-\tprivate int maxOccurrence = 1;\n-\tprivate Type type;\n-\n-\t// Support for range of Unicode categories as defined by the Character class\n-\tprivate int[] m_category;\n-\n-\t/**\n-\t * List of {@link StringRegExPatternTerm} (for seq or choice)\n-\t */\n-\tprivate final List<StringRegExPatternTerm> subTermList = new ArrayList<StringRegExPatternTerm>();\n-\n-\t/**\n-\t * List of {@link CharRange} (for leaf)\n-\t */\n-\tprivate final List<CharRange> rangeList = new ArrayList<CharRange>();\n-\n-\tprivate StringRegExPatternTerm notTerm;\n-\n-\tpublic StringRegExPatternTerm(final Type type)\n-\t{\n-\t\tthis.type = type;\n-\t}\n-\n-\t/**\n-\t * a single character\n-\t */\n-\tpublic StringRegExPatternTerm(char c)\n-\t{\n-\t\tthis.type = Type.TYPE_LEAF_POSITIVE;\n-\t\trangeList.add(new CharRange(c));\n-\t}\n-\n-\tpublic void addSubTerm(StringRegExPatternTerm subTerm)\n-\t{\n-\t\tsubTermList.add(subTerm);\n-\t}\n-\n-\tpublic void addChar(char c)\n-\t{\n-\t\trangeList.add(new CharRange(c));\n-\t}\n-\n-\tpublic void addChar(final int first, final int last)\n-\t{\n-\t\trangeList.add(new CharRange(first, last));\n-\t}\n-\n-\t/**\n-\t * converts the last two range items into one\n-\t */\n-\tpublic void combineRanges()\n-\t{\n-\t\tfinal CharRange a = rangeList.get(rangeList.size() - 2);\n-\t\tfinal CharRange b = rangeList.get(rangeList.size() - 1);\n-\t\ta.setLast(b.getLast());\n-\t\trangeList.remove(rangeList.size() - 1);\n-\t}\n-\n-\tpublic void addNegativeTerm(final StringRegExPatternTerm term)\n-\t{\n-\t\tnotTerm = term;\n-\t}\n-\n-\t/**\n-\t * map Unicode category abbr => array of Character constants\n-\t */\n-\tprotected static final HashMap<String, int[]> categoryMap = new HashMap<String, int[]>();\n-\n-\t/**\n-\t * Maps block name string => Character.UnicodeBlock\n-\t */\n-\tprotected static final HashMap<String, int[]> blockMap = new HashMap<String, int[]>();\n-\n-\tstatic\n-\t{\n-\t\tcategoryMap.put(\"L\", new int[] { Character.UPPERCASE_LETTER, Character.LOWERCASE_LETTER, Character.TITLECASE_LETTER, Character.MODIFIER_LETTER, Character.OTHER_LETTER }); // All\n-\t\t// Letters\n-\t\tcategoryMap.put(\"Lu\", new int[] { Character.UPPERCASE_LETTER }); // Uppercase\n-\t\tcategoryMap.put(\"Ll\", new int[] { Character.LOWERCASE_LETTER }); // Lowercase\n-\t\tcategoryMap.put(\"Lt\", new int[] { Character.TITLECASE_LETTER }); // Titlecase\n-\t\tcategoryMap.put(\"Lm\", new int[] { Character.MODIFIER_LETTER }); // Modifier\n-\t\tcategoryMap.put(\"Lo\", new int[] { Character.OTHER_LETTER }); // Other Letters\n-\n-\t\tcategoryMap.put(\"M\", new int[] { Character.NON_SPACING_MARK, Character.COMBINING_SPACING_MARK, Character.ENCLOSING_MARK }); // All\n-\t\t// Marks\n-\t\tcategoryMap.put(\"Mn\", new int[] { Character.NON_SPACING_MARK }); // Non-Spacing\n-\t\tcategoryMap.put(\"Mc\", new int[] { Character.COMBINING_SPACING_MARK }); // Spacing Combining\n-\t\tcategoryMap.put(\"Me\", new int[] { Character.ENCLOSING_MARK }); // Enclosing\n-\n-\t\tcategoryMap.put(\"N\", new int[] { Character.DECIMAL_DIGIT_NUMBER, Character.LETTER_NUMBER, Character.OTHER_NUMBER }); // All\n-\t\t// Numbers\n-\t\tcategoryMap.put(\"Nd\", new int[] { Character.DECIMAL_DIGIT_NUMBER }); // Decimal Digit\n-\t\tcategoryMap.put(\"Nl\", new int[] { Character.LETTER_NUMBER }); // Letter\n-\t\tcategoryMap.put(\"No\", new int[] { Character.OTHER_NUMBER }); // Other Numbers\n-\n-\t\tcategoryMap.put(\"P\", new int[] { Character.CONNECTOR_PUNCTUATION, Character.DASH_PUNCTUATION, Character.START_PUNCTUATION, Character.END_PUNCTUATION, Character.OTHER_PUNCTUATION }); // All\n-\t\t// Punctuation\n-\t\tcategoryMap.put(\"Pc\", new int[] { Character.CONNECTOR_PUNCTUATION }); // Connector\n-\t\tcategoryMap.put(\"Pd\", new int[] { Character.DASH_PUNCTUATION }); // Dash\n-\t\tcategoryMap.put(\"Ps\", new int[] { Character.START_PUNCTUATION }); // Open\n-\t\tcategoryMap.put(\"Pe\", new int[] { Character.END_PUNCTUATION }); // Close\n-\t\tcategoryMap.put(\"Pi\", new int[] { Character.OTHER_PUNCTUATION }); // Initial quote (Unicode 3)\n-\t\tcategoryMap.put(\"Pf\", new int[] { Character.OTHER_PUNCTUATION }); // Final quote (Unicode 3)\n-\t\tcategoryMap.put(\"Po\", new int[] { Character.OTHER_PUNCTUATION }); // Other Punctuation\n-\n-\t\tcategoryMap.put(\"Z\", new int[] { Character.SPACE_SEPARATOR, Character.LINE_SEPARATOR, Character.PARAGRAPH_SEPARATOR }); // All\n-\t\t// Separators\n-\t\tcategoryMap.put(\"Zs\", new int[] { Character.SPACE_SEPARATOR }); // Space\n-\t\tcategoryMap.put(\"Zl\", new int[] { Character.LINE_SEPARATOR }); // Line\n-\t\tcategoryMap.put(\"Zp\", new int[] { Character.PARAGRAPH_SEPARATOR }); // Paragraph\n-\n-\t\tcategoryMap.put(\"S\", new int[] { Character.MATH_SYMBOL, Character.CURRENCY_SYMBOL, Character.MODIFIER_SYMBOL, Character.OTHER_SYMBOL }); // All\n-\t\t// Symbols\n-\t\tcategoryMap.put(\"Sm\", new int[] { Character.MATH_SYMBOL }); // Math\n-\t\tcategoryMap.put(\"Sc\", new int[] { Character.CURRENCY_SYMBOL }); // Currency\n-\t\tcategoryMap.put(\"Sk\", new int[] { Character.MODIFIER_SYMBOL }); // Modifier\n-\t\tcategoryMap.put(\"So\", new int[] { Character.OTHER_SYMBOL }); // Other Symbols\n-\n-\t\tcategoryMap.put(\"C\", new int[] { Character.CONTROL, Character.FORMAT, Character.SURROGATE, Character.PRIVATE_USE, Character.UNASSIGNED }); // All\n-\t\t// Others\n-\t\tcategoryMap.put(\"Cc\", new int[] { Character.CONTROL }); // Control\n-\t\tcategoryMap.put(\"Cf\", new int[] { Character.FORMAT }); // Format\n-\t\tcategoryMap.put(\"Cs\", new int[] { Character.SURROGATE }); // Surrogate\n-\t\tcategoryMap.put(\"Co\", new int[] { Character.PRIVATE_USE }); // Private Use\n-\t\tcategoryMap.put(\"Cn\", new int[] { Character.UNASSIGNED }); // Not Assigned\n-\n-\t\t// blocks are coded as ranges to stay compatible with Java 1.1\n-\t\t// (Java 1.2 adds Character.UnicodeBlock, which would help with Unicode 2 blocks)\n-\t\tblockMap.put(\"BasicLatin\", new int[] { '\\u0000', '\\u007F' });\n-\t\tblockMap.put(\"Latin-1Supplement\", new int[] { '\\u0080', '\\u00FF' });\n-\t\tblockMap.put(\"LatinExtended-A\", new int[] { '\\u0100', '\\u017F' });\n-\t\tblockMap.put(\"LatinExtended-B\", new int[] { '\\u0180', '\\u024F' });\n-\t\tblockMap.put(\"IPAExtensions\", new int[] { '\\u0250', '\\u02AF' });\n-\t\tblockMap.put(\"SpacingModifierLetters\", new int[] { '\\u02B0', '\\u02FF' });\n-\t\tblockMap.put(\"CombiningDiacriticalMarks\", new int[] { '\\u0300', '\\u036F' });\n-\t\tblockMap.put(\"Greek\", new int[] { '\\u0370', '\\u03FF' });\n-\t\tblockMap.put(\"Cyrillic\", new int[] { '\\u0400', '\\u04FF' });\n-\t\tblockMap.put(\"Armenian\", new int[] { '\\u0530', '\\u058F' });\n-\t\tblockMap.put(\"Hebrew\", new int[] { '\\u0590', '\\u05FF' });\n-\t\tblockMap.put(\"Arabic\", new int[] { '\\u0600', '\\u06FF' });\n-\t\tblockMap.put(\"Syriac\", new int[] { '\\u0700', '\\u074F' });\n-\t\tblockMap.put(\"Thaana\", new int[] { '\\u0780', '\\u07BF' });\n-\t\tblockMap.put(\"Devanagari\", new int[] { '\\u0900', '\\u097F' });\n-\t\tblockMap.put(\"Bengali\", new int[] { '\\u0980', '\\u09FF' });\n-\t\tblockMap.put(\"Gurmukhi\", new int[] { '\\u0A00', '\\u0A7F' });\n-\t\tblockMap.put(\"Gujarati\", new int[] { '\\u0A80', '\\u0AFF' });\n-\t\tblockMap.put(\"Oriya\", new int[] { '\\u0B00', '\\u0B7F' });\n-\t\tblockMap.put(\"Tamil\", new int[] { '\\u0B80', '\\u0BFF' });\n-\t\tblockMap.put(\"Telugu\", new int[] { '\\u0C00', '\\u0C7F' });\n-\t\tblockMap.put(\"Kannada\", new int[] { '\\u0C80', '\\u0CFF' });\n-\t\tblockMap.put(\"Malayalam\", new int[] { '\\u0D00', '\\u0D7F' });\n-\t\tblockMap.put(\"Sinhala\", new int[] { '\\u0D80', '\\u0DFF' });\n-\t\tblockMap.put(\"Thai\", new int[] { '\\u0E00', '\\u0E7F' });\n-\t\tblockMap.put(\"Lao\", new int[] { '\\u0E80', '\\u0EFF' });\n-\t\tblockMap.put(\"Tibetan\", new int[] { '\\u0F00', '\\u0FFF' });\n-\t\tblockMap.put(\"Myanmar\", new int[] { '\\u1000', '\\u109F' });\n-\t\tblockMap.put(\"Georgian\", new int[] { '\\u10A0', '\\u10FF' });\n-\t\tblockMap.put(\"HangulJamo\", new int[] { '\\u1100', '\\u11FF' });\n-\t\tblockMap.put(\"Ethiopic\", new int[] { '\\u1200', '\\u137F' });\n-\t\tblockMap.put(\"Cherokee\", new int[] { '\\u13A0', '\\u13FF' });\n-\t\tblockMap.put(\"UnifiedCanadianAboriginalSyllabics\", new int[] { '\\u1400', '\\u167F' });\n-\t\tblockMap.put(\"Ogham\", new int[] { '\\u1680', '\\u169F' });\n-\t\tblockMap.put(\"Runic\", new int[] { '\\u16A0', '\\u16FF' });\n-\t\tblockMap.put(\"Khmer\", new int[] { '\\u1780', '\\u17FF' });\n-\t\tblockMap.put(\"Mongolian\", new int[] { '\\u1800', '\\u18AF' });\n-\t\tblockMap.put(\"LatinExtendedAdditional\", new int[] { '\\u1E00', '\\u1EFF' });\n-\t\tblockMap.put(\"GreekExtended\", new int[] { '\\u1F00', '\\u1FFF' });\n-\t\tblockMap.put(\"GeneralPunctuation\", new int[] { '\\u2000', '\\u206F' });\n-\t\tblockMap.put(\"SuperscriptsandSubscripts\", new int[] { '\\u2070', '\\u209F' });\n-\t\tblockMap.put(\"CurrencySymbols\", new int[] { '\\u20A0', '\\u20CF' });\n-\t\tblockMap.put(\"CombiningMarksforSymbols\", new int[] { '\\u20D0', '\\u20FF' });\n-\t\tblockMap.put(\"LetterlikeSymbols\", new int[] { '\\u2100', '\\u214F' });\n-\t\tblockMap.put(\"NumberForms\", new int[] { '\\u2150', '\\u218F' });\n-\t\tblockMap.put(\"Arrows\", new int[] { '\\u2190', '\\u21FF' });\n-\t\tblockMap.put(\"MathematicalOperators\", new int[] { '\\u2200', '\\u22FF' });\n-\t\tblockMap.put(\"MiscellaneousTechnical\", new int[] { '\\u2300', '\\u23FF' });\n-\t\tblockMap.put(\"ControlPictures\", new int[] { '\\u2400', '\\u243F' });\n-\t\tblockMap.put(\"OpticalCharacterRecognition\", new int[] { '\\u2440', '\\u245F' });\n-\t\tblockMap.put(\"EnclosedAlphanumerics\", new int[] { '\\u2460', '\\u24FF' });\n-\t\tblockMap.put(\"BoxDrawing\", new int[] { '\\u2500', '\\u257F' });\n-\t\tblockMap.put(\"BlockElements\", new int[] { '\\u2580', '\\u259F' });\n-\t\tblockMap.put(\"GeometricShapes\", new int[] { '\\u25A0', '\\u25FF' });\n-\t\tblockMap.put(\"MiscellaneousSymbols\", new int[] { '\\u2600', '\\u26FF' });\n-\t\tblockMap.put(\"Dingbats\", new int[] { '\\u2700', '\\u27BF' });\n-\t\tblockMap.put(\"BraillePatterns\", new int[] { '\\u2800', '\\u28FF' });\n-\t\tblockMap.put(\"CJKRadicalsSupplement\", new int[] { '\\u2E80', '\\u2EFF' });\n-\t\tblockMap.put(\"KangxiRadicals\", new int[] { '\\u2F00', '\\u2FDF' });\n-\t\tblockMap.put(\"IdeographicDescriptionCharacters\", new int[] { '\\u2FF0', '\\u2FFF' });\n-\t\tblockMap.put(\"CJKSymbolsandPunctuation\", new int[] { '\\u3000', '\\u303F' });\n-\t\tblockMap.put(\"Hiragana\", new int[] { '\\u3040', '\\u309F' });\n-\t\tblockMap.put(\"Katakana\", new int[] { '\\u30A0', '\\u30FF' });\n-\t\tblockMap.put(\"Bopomofo\", new int[] { '\\u3100', '\\u312F' });\n-\t\tblockMap.put(\"HangulCompatibilityJamo\", new int[] { '\\u3130', '\\u318F' });\n-\t\tblockMap.put(\"Kanbun\", new int[] { '\\u3190', '\\u319F' });\n-\t\tblockMap.put(\"BopomofoExtended\", new int[] { '\\u31A0', '\\u31BF' });\n-\t\tblockMap.put(\"EnclosedCJKLettersandMonths\", new int[] { '\\u3200', '\\u32FF' });\n-\t\tblockMap.put(\"CJKCompatibility\", new int[] { '\\u3300', '\\u33FF' });\n-\t\tblockMap.put(\"CJKUnifiedIdeographsExtensionA\", new int[] { '\\u3400', '\\u4DB5' });\n-\t\tblockMap.put(\"CJKUnifiedIdeographs\", new int[] { '\\u4E00', '\\u9FFF' });\n-\t\tblockMap.put(\"YiSyllables\", new int[] { '\\uA000', '\\uA48F' });\n-\t\tblockMap.put(\"YiRadicals\", new int[] { '\\uA490', '\\uA4CF' });\n-\t\tblockMap.put(\"HangulSyllables\", new int[] { '\\uAC00', '\\uD7A3' });\n-\t\tblockMap.put(\"HighSurrogates\", new int[] { 0xD800, 0xDB7F });\n-\t\tblockMap.put(\"HighPrivateUseSurrogates\", new int[] { 0xDB80, 0xDBFF });\n-\t\tblockMap.put(\"LowSurrogates\", new int[] { 0xDC00, 0xDFFF });\n-\t\tblockMap.put(\"PrivateUse\", new int[] { '\\uE000', '\\uF8FF' });\n-\t\tblockMap.put(\"CJKCompatibilityIdeographs\", new int[] { '\\uF900', '\\uFAFF' });\n-\t\tblockMap.put(\"AlphabeticPresentationForms\", new int[] { '\\uFB00', '\\uFB4F' });\n-\t\tblockMap.put(\"ArabicPresentationForms-A\", new int[] { '\\uFB50', '\\uFDFF' });\n-\t\tblockMap.put(\"CombiningHalfMarks\", new int[] { '\\uFE20', '\\uFE2F' });\n-\t\tblockMap.put(\"CJKCompatibilityForms\", new int[] { '\\uFE30', '\\uFE4F' });\n-\t\tblockMap.put(\"SmallFormVariants\", new int[] { '\\uFE50', '\\uFE6F' });\n-\t\tblockMap.put(\"ArabicPresentationForms-B\", new int[] { '\\uFE70', '\\uFEFE' });\n-\t\t// blockMap.put(\"Specials\", new int[]{0xFEFF, 0xFEFF}); // Formal\n-\t\tblockMap.put(\"HalfwidthandFullwidthForms\", new int[] { '\\uFF00', '\\uFFEF' });\n-\t\t// blockMap.put(\"Specials\", new int[]{0xFFF0, 0xFFFD}); // Formal\n-\t\tblockMap.put(\"Specials\", new int[] { 0xFEFF, 0xFFFD }); // Range overlaps.\n-\t\tblockMap.put(\"OldItalic\", new int[] { 0x10300, 0x1032F });\n-\t\tblockMap.put(\"Gothic\", new int[] { 0x10330, 0x1034F });\n-\t\tblockMap.put(\"Deseret\", new int[] { 0x10400, 0x1044F });\n-\t\tblockMap.put(\"ByzantineMusicalSymbols\", new int[] { 0x1D000, 0x1D0FF });\n-\t\tblockMap.put(\"MusicalSymbols\", new int[] { 0x1D100, 0x1D1FF });\n-\t\tblockMap.put(\"MathematicalAlphanumericSymbols\", new int[] { 0x1D400, 0x1D7FF });\n-\t\tblockMap.put(\"CJKUnifiedIdeographsExtensionB\", new int[] { 0x20000, 0x2A6D6 });\n-\t\tblockMap.put(\"CJKCompatibilityIdeographsSupplement\", new int[] { 0x2F800, 0x2FA1F });\n-\t\tblockMap.put(\"Tags\", new int[] { 0xE0000, 0xFFFFD });\n-\t}\n-\n-\t/**\n-\t * set Unicode category\n-\t */\n-\tpublic void setCategory(final String category) throws StringRegExException\n-\t{\n-\t\tPreCondition.assertArgumentNotNull(category, \"abbr\");\n-\t\tm_category = categoryMap.get(category);\n-\t\tif (m_category == null)\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidUnicodeCategory, category);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * set Unicode block to match against.\n-\t * \n-\t * @param blockName\n-\t *            the XSD-style block name (spaces removed)\n-\t */\n-\tpublic void setBlock(final String blockName) throws StringRegExException\n-\t{\n-\t\tfinal int range[] = blockMap.get(blockName);\n-\t\tif (range == null)\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidUnicodeBlockName, blockName);\n-\t\t}\n-\t\taddChar(range[0], range[1]);\n-\t}\n-\n-\tpublic void setOccurrence(final int min, final int max)\n-\t{\n-\t\tminOccurrence = min;\n-\t\tmaxOccurrence = max;\n-\t}\n-\n-\t/**\n-\t * returns whether this term contains a sequence of one or more subterms\n-\t */\n-\tpublic boolean isSequence()\n-\t{\n-\t\treturn type == Type.TYPE_SEQ;\n-\t}\n-\n-\t/**\n-\t * returns whether this term contains a choice of one or more subterms\n-\t */\n-\tpublic boolean isChoice()\n-\t{\n-\t\treturn type == Type.TYPE_CHOICE;\n-\t}\n-\n-\t/**\n-\t * returns whether this term contains a set of one or more subterms\n-\t */\n-\tpublic boolean isInterleave()\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * returns an Enumeration of this term's subterms\n-\t */\n-\tpublic Iterable<StringRegExPatternTerm> getSubTerms()\n-\t{\n-\t\treturn subTermList;\n-\t}\n-\n-\t/**\n-\t * returns whether this leaf term matches the given token.\n-\t */\n-\tpublic boolean matches(final String token)\n-\t{\n-\t\tif (type == Type.TYPE_LEAF_WILDCARD)\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\t// Debug.assert(type == TYPE_LEAF_POSITIVE || type == TYPE_LEAF_NEGATIVE);\n-\t\tboolean matched = false;\n-\t\tif (m_category != null)\n-\t\t{\n-\t\t\tif ((token != null) && token.length() > 0)\n-\t\t\t{\n-\t\t\t\tfor (int i = 0; i < m_category.length && !matched; i++)\n-\t\t\t\t{\n-\t\t\t\t\tmatched = m_category[i] == Character.getType(token.charAt(0));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfor (final Iterator<CharRange> i = rangeList.iterator(); i.hasNext() && !matched;)\n-\t\t\t{\n-\t\t\t\tmatched = i.next().matches(token);\n-\t\t\t}\n-\t\t\tfor (final Iterator<StringRegExPatternTerm> i = subTermList.iterator(); i.hasNext() && !matched;)\n-\t\t\t{\n-\t\t\t\tmatched = i.next().matches(token);\n-\t\t\t}\n-\t\t}\n-\t\tif (type == Type.TYPE_LEAF_NEGATIVE)\n-\t\t{\n-\t\t\tmatched = !matched;\n-\t\t}\n-\t\tif (matched && notTerm != null && notTerm.matches(token))\n-\t\t{\n-\t\t\tmatched = false;\n-\t\t}\n-\t\treturn matched;\n-\t}\n-\n-\t/**\n-\t * Returns true if this term and the other term are both leaf terms and there exist some tokens which match both\n-\t * terms. Used to check for determinism.\n-\t */\n-\tpublic boolean intersects(StringRegExPatternTerm other)\n-\t{\n-\t\tif (isLeaf() && other.isLeaf())\n-\t\t{\n-\t\t\tif (type == Type.TYPE_LEAF_WILDCARD || other.type == Type.TYPE_LEAF_WILDCARD)\n-\t\t\t\treturn true;\n-\t\t\tif (type == Type.TYPE_LEAF_NEGATIVE)\n-\t\t\t{\n-\t\t\t\tif (other.type == Type.TYPE_LEAF_POSITIVE)\n-\t\t\t\t\treturn other.intersects(this); // prefer this being positive\n-\t\t\t\telse\n-\t\t\t\t\treturn false; // both negative => assume intersects\n-\t\t\t}\n-\t\t\tif (m_category != null)\n-\t\t\t{\n-\t\t\t\tif (other.m_category == null)\n-\t\t\t\t\treturn other.intersects(this); // prefer this being non-category\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\t// only intersect if they share same categories\n-\t\t\t\t\tfor (final int x : m_category)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfor (final int y : other.m_category)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (x == y)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// fixme should check categories\n-\t\t\t// type must be positive (though we could have negative subterms)\n-\t\t\t// see if any of our elements match 'other'\n-\t\t\tfor (final CharRange cr : rangeList)\n-\t\t\t{\n-\t\t\t\tfor (int c = cr.getFirst(); c <= cr.getLast(); c++)\n-\t\t\t\t{\n-\t\t\t\t\tif (notTerm != null && notTerm.matches(String.valueOf(c)))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (other.matches(String.valueOf(c)))\n-\t\t\t\t\t{\n-\t\t\t\t\t\treturn true; // they intersect\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfor (final StringRegExPatternTerm term : subTermList)\n-\t\t\t{\n-\t\t\t\tif (term.intersects(other))\n-\t\t\t\t{\n-\t\t\t\t\treturn true; // they intersect\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tprotected boolean isLeaf()\n-\t{\n-\t\treturn type == Type.TYPE_LEAF_WILDCARD || type == Type.TYPE_LEAF_POSITIVE || type == Type.TYPE_LEAF_NEGATIVE;\n-\t}\n-\n-\t/**\n-\t * returns the minimum number of occurrences of this term.\n-\t */\n-\tpublic int minOccurs()\n-\t{\n-\t\treturn minOccurrence;\n-\t}\n-\n-\t/**\n-\t * returns the maximum number of occurrences of this term. returns Integer.MAX_VALUE to indicate unlimited\n-\t * occurrences.\n-\t */\n-\tpublic int maxOccurs()\n-\t{\n-\t\treturn maxOccurrence;\n-\t}\n-\n-\tpublic String toString()\n-\t{\n-\t\tString s = \"\";\n-\t\tif (isChoice())\n-\t\t{\n-\t\t\ts += \"(\";\n-\t\t\tfor (int i = 0; i < subTermList.size(); i++)\n-\t\t\t{\n-\t\t\t\tif (i > 0)\n-\t\t\t\t\ts += \" | \";\n-\t\t\t\ts += subTermList.get(i).toString();\n-\t\t\t}\n-\t\t\ts += \")\";\n-\t\t}\n-\t\telse if (isSequence())\n-\t\t{\n-\t\t\ts += \"(\";\n-\t\t\tfor (int i = 0; i < subTermList.size(); i++)\n-\t\t\t{\n-\t\t\t\tif (i > 0)\n-\t\t\t\t\ts += \", \";\n-\t\t\t\ts += subTermList.get(i).toString();\n-\t\t\t}\n-\t\t\ts += \")\";\n-\t\t}\n-\t\telse if (type == Type.TYPE_LEAF_WILDCARD)\n-\t\t{\n-\t\t\ts = \"WILDCARD\";\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (type == Type.TYPE_LEAF_POSITIVE && subTermList.size() == 0 && rangeList.size() == 1 && rangeList.get(0).toString().length() == 1)\n-\t\t\t\ts = rangeList.get(0).toString();\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\ts += \"[\";\n-\t\t\t\tif (type == Type.TYPE_LEAF_NEGATIVE)\n-\t\t\t\t\ts += \"^\";\n-\t\t\t\tif (m_category != null)\n-\t\t\t\t{\n-\t\t\t\t\ts += \"UnicodeProperty(\";\n-\t\t\t\t\tfor (int i = 0; i < m_category.length; i++)\n-\t\t\t\t\t\ts += (i == 0 ? \"\" : \",\") + m_category[i];\n-\t\t\t\t\ts += \")\";\n-\t\t\t\t}\n-\t\t\t\tfor (final CharRange cr : rangeList)\n-\t\t\t\t{\n-\t\t\t\t\ts += cr.toString();\n-\t\t\t\t}\n-\t\t\t\tfor (final StringRegExPatternTerm term : subTermList)\n-\t\t\t\t{\n-\t\t\t\t\ts += term.toString();\n-\t\t\t\t}\n-\t\t\t\tif (notTerm != null)\n-\t\t\t\t\ts += \"-\" + notTerm.toString();\n-\t\t\t\ts += \"]\";\n-\t\t\t}\n-\t\t}\n-\t\tif (minOccurrence == 1 && maxOccurrence == 1)\n-\t\t{\n-\t\t\t// Do nothing\n-\t\t}\n-\t\telse if (minOccurrence == 0 && maxOccurrence == 1)\n-\t\t{\n-\t\t\ts += \"?\";\n-\t\t}\n-\t\telse if (minOccurrence == 0 && maxOccurrence == RegExBridge.UNBOUNDED)\n-\t\t{\n-\t\t\ts += \"*\";\n-\t\t}\n-\t\telse if (minOccurrence == 1 && maxOccurrence == RegExBridge.UNBOUNDED)\n-\t\t{\n-\t\t\ts += \"+\";\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\ts += \"{\" + minOccurrence + \",\";\n-\t\t\tif (maxOccurrence != RegExBridge.UNBOUNDED)\n-\t\t\t{\n-\t\t\t\ts += maxOccurrence;\n-\t\t\t}\n-\t\t\ts += \"}\";\n-\t\t}\n-\t\treturn s;\n-\t}\n-\n-\tstatic String ctoUnicodeEsc(final int i)\n-\t{\n-\t\tchar out[] = { '\\\\', 'u', Character.forDigit((i >> 12) & 0xF, 16), Character.forDigit((i >> 8) & 0xF, 16), Character.forDigit((i >> 4) & 0xF, 16), Character.forDigit(i & 0xF, 16) };\n-\t\treturn new String(out);\n-\t}\n-\n-\tpublic static String charString(int c)\n-\t{\n-\t\tif (c < ' ' || c >= 255)\n-\t\t{\n-\t\t\treturn ctoUnicodeEsc(c);\n-\t\t}\n-\t\tswitch (c)\n-\t\t{\n-\t\t\tcase StringRegExParser.NEWLINE:\n-\t\t\t\treturn \"\\\\n\";\n-\t\t\tcase StringRegExParser.RETURN:\n-\t\t\t\treturn \"\\\\r\";\n-\t\t\tcase StringRegExParser.TAB:\n-\t\t\t\treturn \"\\\\t\";\n-\t\t\tcase '\\\\':\n-\t\t\t\treturn \"\\\\\\\\\";\n-\t\t\tcase '.':\n-\t\t\tcase '-':\n-\t\t\tcase '|':\n-\t\t\tcase '^':\n-\t\t\tcase '?':\n-\t\t\tcase '*':\n-\t\t\tcase '+':\n-\t\t\tcase '[':\n-\t\t\tcase ']':\n-\t\t\tcase '(':\n-\t\t\tcase ')':\n-\t\t\tcase '{':\n-\t\t\tcase '}':\n-\t\t\t\treturn \"\\\\\" + c;\n-\t\t}\n-\t\treturn \"\" + c;\n-\t}\n-}\n+    public enum Type\n+    {\n+        TYPE_SEQ, TYPE_CHOICE, TYPE_LEAF_POSITIVE, TYPE_LEAF_NEGATIVE, TYPE_LEAF_WILDCARD\n+    }\n+\n+    private int minOccurrence = 1;\n+    private int maxOccurrence = 1;\n+    private Type type;\n+\n+    // Support for range of Unicode categories as defined by the Character class\n+    private int[] m_category;\n+\n+    /**\n+     * List of {@link StringRegExPatternTerm} (for seq or choice)\n+     */\n+    private final List<StringRegExPatternTerm> subTermList = new ArrayList<StringRegExPatternTerm>();\n+\n+    /**\n+     * List of {@link CharRange} (for leaf)\n+     */\n+    private final List<CharRange> rangeList = new ArrayList<CharRange>();\n+    private StringRegExPatternTerm notTerm;\n+\n+    public StringRegExPatternTerm(final Type type)\n+    {\n+        this.type = type;\n+    }\n+\n+    /**\n+     * a single character\n+     */\n+\n+    public StringRegExPatternTerm(char c)\n+    {\n+        this.type = Type.TYPE_LEAF_POSITIVE;\n+        rangeList.add(new CharRange(c));\n+    }\n+\n+    public void addSubTerm(StringRegExPatternTerm subTerm)\n+    {\n+        subTermList.add(subTerm);\n+    }\n+\n+    public void addChar(char c)\n+    {\n+        rangeList.add(new CharRange(c));\n+    }\n+\n+    public void addChar(final int first, final int last)\n+    {\n+        rangeList.add(new CharRange(first, last));\n+    }\n+\n+    /**\n+     * converts the last two range items into one\n+     */\n+\n+    public void combineRanges()\n+    {\n+        final CharRange a = rangeList.get(rangeList.size() - 2);\n+        final CharRange b = rangeList.get(rangeList.size() - 1);\n+        a.setLast(b.getLast());\n+        rangeList.remove(rangeList.size() - 1);\n+    }\n+\n+    public void addNegativeTerm(final StringRegExPatternTerm term)\n+    {\n+        notTerm = term;\n+    }\n+\n+    /**\n+     * map Unicode category abbr => array of Character constants\n+     */\n+\n+    protected static final HashMap<String, int[]> categoryMap = new HashMap<String, int[]>();\n+\n+    /**\n+     * Maps block name string => Character.UnicodeBlock\n+     */\n+    protected static final HashMap<String, int[]> blockMap = new HashMap<String, int[]>();\n+\n+    static\n+    {\n+        categoryMap.put(\"L\", new int[] { Character.UPPERCASE_LETTER, Character.LOWERCASE_LETTER, Character.TITLECASE_LETTER, Character.MODIFIER_LETTER, Character.OTHER_LETTER }); // All\n+        // Letters\n+        categoryMap.put(\"Lu\", new int[] { Character.UPPERCASE_LETTER }); // Uppercase\n+        categoryMap.put(\"Ll\", new int[] { Character.LOWERCASE_LETTER }); // Lowercase\n+        categoryMap.put(\"Lt\", new int[] { Character.TITLECASE_LETTER }); // Titlecase\n+        categoryMap.put(\"Lm\", new int[] { Character.MODIFIER_LETTER }); // Modifier\n+        categoryMap.put(\"Lo\", new int[] { Character.OTHER_LETTER }); // Other Letters\n+        categoryMap.put(\"M\", new int[] { Character.NON_SPACING_MARK, Character.COMBINING_SPACING_MARK, Character.ENCLOSING_MARK }); // All\n+        // Marks\n+        categoryMap.put(\"Mn\", new int[] { Character.NON_SPACING_MARK }); // Non-Spacing\n+        categoryMap.put(\"Mc\", new int[] { Character.COMBINING_SPACING_MARK }); // Spacing Combining\n+        categoryMap.put(\"Me\", new int[] { Character.ENCLOSING_MARK }); // Enclosing\n+        categoryMap.put(\"N\", new int[] { Character.DECIMAL_DIGIT_NUMBER, Character.LETTER_NUMBER, Character.OTHER_NUMBER }); // All\n+        // Numbers\n+        categoryMap.put(\"Nd\", new int[] { Character.DECIMAL_DIGIT_NUMBER }); // Decimal Digit\n+        categoryMap.put(\"Nl\", new int[] { Character.LETTER_NUMBER }); // Letter\n+        categoryMap.put(\"No\", new int[] { Character.OTHER_NUMBER }); // Other Numbers\n+        categoryMap.put(\"P\", new int[] { Character.CONNECTOR_PUNCTUATION, Character.DASH_PUNCTUATION, Character.START_PUNCTUATION, Character.END_PUNCTUATION, Character.OTHER_PUNCTUATION }); // All\n+        // Punctuation\n+        categoryMap.put(\"Pc\", new int[] { Character.CONNECTOR_PUNCTUATION }); // Connector\n+        categoryMap.put(\"Pd\", new int[] { Character.DASH_PUNCTUATION }); // Dash\n+        categoryMap.put(\"Ps\", new int[] { Character.START_PUNCTUATION }); // Open\n+        categoryMap.put(\"Pe\", new int[] { Character.END_PUNCTUATION }); // Close\n+        categoryMap.put(\"Pi\", new int[] { Character.OTHER_PUNCTUATION }); // Initial quote (Unicode 3)\n+        categoryMap.put(\"Pf\", new int[] { Character.OTHER_PUNCTUATION }); // Final quote (Unicode 3)\n+        categoryMap.put(\"Po\", new int[] { Character.OTHER_PUNCTUATION }); // Other Punctuation\n+        categoryMap.put(\"Z\", new int[] { Character.SPACE_SEPARATOR, Character.LINE_SEPARATOR, Character.PARAGRAPH_SEPARATOR }); // All\n+        // Separators\n+        categoryMap.put(\"Zs\", new int[] { Character.SPACE_SEPARATOR }); // Space\n+        categoryMap.put(\"Zl\", new int[] { Character.LINE_SEPARATOR }); // Line\n+        categoryMap.put(\"Zp\", new int[] { Character.PARAGRAPH_SEPARATOR }); // Paragraph\n+        categoryMap.put(\"S\", new int[] { Character.MATH_SYMBOL, Character.CURRENCY_SYMBOL, Character.MODIFIER_SYMBOL, Character.OTHER_SYMBOL }); // All\n+        // Symbols\n+        categoryMap.put(\"Sm\", new int[] { Character.MATH_SYMBOL }); // Math\n+        categoryMap.put(\"Sc\", new int[] { Character.CURRENCY_SYMBOL }); // Currency\n+        categoryMap.put(\"Sk\", new int[] { Character.MODIFIER_SYMBOL }); // Modifier\n+        categoryMap.put(\"So\", new int[] { Character.OTHER_SYMBOL }); // Other Symbols\n+        categoryMap.put(\"C\", new int[] { Character.CONTROL, Character.FORMAT, Character.SURROGATE, Character.PRIVATE_USE, Character.UNASSIGNED }); // All\n+        // Others\n+        categoryMap.put(\"Cc\", new int[] { Character.CONTROL }); // Control\n+        categoryMap.put(\"Cf\", new int[] { Character.FORMAT }); // Format\n+        categoryMap.put(\"Cs\", new int[] { Character.SURROGATE }); // Surrogate\n+        categoryMap.put(\"Co\", new int[] { Character.PRIVATE_USE }); // Private Use\n+        categoryMap.put(\"Cn\", new int[] { Character.UNASSIGNED }); // Not Assigned\n+\n+        // blocks are coded as ranges to stay compatible with Java 1.1\n+        // (Java 1.2 adds Character.UnicodeBlock, which would help with Unicode 2 blocks)\n+        blockMap.put(\"BasicLatin\", new int[] { '\\u0000', '\\u007F' });\n+        blockMap.put(\"Latin-1Supplement\", new int[] { '\\u0080', '\\u00FF' });\n+        blockMap.put(\"LatinExtended-A\", new int[] { '\\u0100', '\\u017F' });\n+        blockMap.put(\"LatinExtended-B\", new int[] { '\\u0180', '\\u024F' });\n+        blockMap.put(\"IPAExtensions\", new int[] { '\\u0250', '\\u02AF' });\n+        blockMap.put(\"SpacingModifierLetters\", new int[] { '\\u02B0', '\\u02FF' });\n+        blockMap.put(\"CombiningDiacriticalMarks\", new int[] { '\\u0300', '\\u036F' });\n+        blockMap.put(\"Greek\", new int[] { '\\u0370', '\\u03FF' });\n+        blockMap.put(\"Cyrillic\", new int[] { '\\u0400', '\\u04FF' });\n+        blockMap.put(\"Armenian\", new int[] { '\\u0530', '\\u058F' });\n+        blockMap.put(\"Hebrew\", new int[] { '\\u0590', '\\u05FF' });\n+        blockMap.put(\"Arabic\", new int[] { '\\u0600', '\\u06FF' });\n+        blockMap.put(\"Syriac\", new int[] { '\\u0700', '\\u074F' });\n+        blockMap.put(\"Thaana\", new int[] { '\\u0780', '\\u07BF' });\n+        blockMap.put(\"Devanagari\", new int[] { '\\u0900', '\\u097F' });\n+        blockMap.put(\"Bengali\", new int[] { '\\u0980', '\\u09FF' });\n+        blockMap.put(\"Gurmukhi\", new int[] { '\\u0A00', '\\u0A7F' });\n+        blockMap.put(\"Gujarati\", new int[] { '\\u0A80', '\\u0AFF' });\n+        blockMap.put(\"Oriya\", new int[] { '\\u0B00', '\\u0B7F' });\n+        blockMap.put(\"Tamil\", new int[] { '\\u0B80', '\\u0BFF' });\n+        blockMap.put(\"Telugu\", new int[] { '\\u0C00', '\\u0C7F' });\n+        blockMap.put(\"Kannada\", new int[] { '\\u0C80', '\\u0CFF' });\n+        blockMap.put(\"Malayalam\", new int[] { '\\u0D00', '\\u0D7F' });\n+        blockMap.put(\"Sinhala\", new int[] { '\\u0D80', '\\u0DFF' });\n+        blockMap.put(\"Thai\", new int[] { '\\u0E00', '\\u0E7F' });\n+        blockMap.put(\"Lao\", new int[] { '\\u0E80', '\\u0EFF' });\n+        blockMap.put(\"Tibetan\", new int[] { '\\u0F00', '\\u0FFF' });\n+        blockMap.put(\"Myanmar\", new int[] { '\\u1000', '\\u109F' });\n+        blockMap.put(\"Georgian\", new int[] { '\\u10A0', '\\u10FF' });\n+        blockMap.put(\"HangulJamo\", new int[] { '\\u1100', '\\u11FF' });\n+        blockMap.put(\"Ethiopic\", new int[] { '\\u1200', '\\u137F' });\n+        blockMap.put(\"Cherokee\", new int[] { '\\u13A0', '\\u13FF' });\n+        blockMap.put(\"UnifiedCanadianAboriginalSyllabics\", new int[] { '\\u1400', '\\u167F' });\n+        blockMap.put(\"Ogham\", new int[] { '\\u1680', '\\u169F' });\n+        blockMap.put(\"Runic\", new int[] { '\\u16A0', '\\u16FF' });\n+        blockMap.put(\"Khmer\", new int[] { '\\u1780', '\\u17FF' });\n+        blockMap.put(\"Mongolian\", new int[] { '\\u1800', '\\u18AF' });\n+        blockMap.put(\"LatinExtendedAdditional\", new int[] { '\\u1E00', '\\u1EFF' });\n+        blockMap.put(\"GreekExtended\", new int[] { '\\u1F00', '\\u1FFF' });\n+        blockMap.put(\"GeneralPunctuation\", new int[] { '\\u2000', '\\u206F' });\n+        blockMap.put(\"SuperscriptsandSubscripts\", new int[] { '\\u2070', '\\u209F' });\n+        blockMap.put(\"CurrencySymbols\", new int[] { '\\u20A0', '\\u20CF' });\n+        blockMap.put(\"CombiningMarksforSymbols\", new int[] { '\\u20D0', '\\u20FF' });\n+        blockMap.put(\"LetterlikeSymbols\", new int[] { '\\u2100', '\\u214F' });\n+        blockMap.put(\"NumberForms\", new int[] { '\\u2150', '\\u218F' });\n+        blockMap.put(\"Arrows\", new int[] { '\\u2190', '\\u21FF' });\n+        blockMap.put(\"MathematicalOperators\", new int[] { '\\u2200', '\\u22FF' });\n+        blockMap.put(\"MiscellaneousTechnical\", new int[] { '\\u2300', '\\u23FF' });\n+        blockMap.put(\"ControlPictures\", new int[] { '\\u2400', '\\u243F' });\n+        blockMap.put(\"OpticalCharacterRecognition\", new int[] { '\\u2440', '\\u245F' });\n+        blockMap.put(\"EnclosedAlphanumerics\", new int[] { '\\u2460', '\\u24FF' });\n+        blockMap.put(\"BoxDrawing\", new int[] { '\\u2500', '\\u257F' });\n+        blockMap.put(\"BlockElements\", new int[] { '\\u2580', '\\u259F' });\n+        blockMap.put(\"GeometricShapes\", new int[] { '\\u25A0', '\\u25FF' });\n+        blockMap.put(\"MiscellaneousSymbols\", new int[] { '\\u2600', '\\u26FF' });\n+        blockMap.put(\"Dingbats\", new int[] { '\\u2700', '\\u27BF' });\n+        blockMap.put(\"BraillePatterns\", new int[] { '\\u2800', '\\u28FF' });\n+        blockMap.put(\"CJKRadicalsSupplement\", new int[] { '\\u2E80', '\\u2EFF' });\n+        blockMap.put(\"KangxiRadicals\", new int[] { '\\u2F00', '\\u2FDF' });\n+        blockMap.put(\"IdeographicDescriptionCharacters\",\n+new int[] { '\\u2FF0', '\\u2FFF' });\n+        blockMap.put(\"CJKSymbolsandPunctuation\", new int[] { '\\u3000', '\\u303F' });\n+        blockMap.put(\"Hiragana\", new int[] { '\\u3040', '\\u309F' });\n+        blockMap.put(\"Katakana\", new int[] { '\\u30A0', '\\u30FF' });\n+        blockMap.put(\"Bopomofo\", new int[] { '\\u3100', '\\u312F' });\n+        blockMap.put(\"HangulCompatibilityJamo\", new int[] { '\\u3130', '\\u318F' });\n+        blockMap.put(\"Kanbun\", new int[] { '\\u3190', '\\u319F' });\n+        blockMap.put(\"BopomofoExtended\", new int[] { '\\u31A0', '\\u31BF' });\n+        blockMap.put(\"EnclosedCJKLettersandMonths\", new int[] { '\\u3200', '\\u32FF' });\n+        blockMap.put(\"CJKCompatibility\", new int[] { '\\u3300', '\\u33FF' });\n+        blockMap.put(\"CJKUnifiedIdeographsExtensionA\", new int[] { '\\u3400', '\\u4DB5' });\n+        blockMap.put(\"CJKUnifiedIdeographs\", new int[] { '\\u4E00', '\\u9FFF' });\n+        blockMap.put(\"YiSyllables\", new int[] { '\\uA000', '\\uA48F' });\n+        blockMap.put(\"YiRadicals\", new int[] { '\\uA490', '\\uA4CF' });\n+        blockMap.put(\"HangulSyllables\", new int[] { '\\uAC00', '\\uD7A3' });\n+        blockMap.put(\"HighSurrogates\", new int[] { 0xD800, 0xDB7F });\n+        blockMap.put(\"HighPrivateUseSurrogates\", new int[] { 0xDB80, 0xDBFF });\n+        blockMap.put(\"LowSurrogates\", new int[] { 0xDC00, 0xDFFF });\n+        blockMap.put(\"PrivateUse\", new int[] { '\\uE000', '\\uF8FF' });\n+        blockMap.put(\"CJKCompatibilityIdeographs\", new int[] { '\\uF900', '\\uFAFF' });\n+        blockMap.put(\"AlphabeticPresentationForms\", new int[] { '\\uFB00', '\\uFB4F' });\n+        blockMap.put(\"ArabicPresentationForms-A\", new int[] { '\\uFB50', '\\uFDFF' });\n+        blockMap.put(\"CombiningHalfMarks\", new int[] { '\\uFE20', '\\uFE2F' });\n+        blockMap.put(\"CJKCompatibilityForms\", new int[] { '\\uFE30', '\\uFE4F' });\n+        blockMap.put(\"SmallFormVariants\", new int[] { '\\uFE50', '\\uFE6F' });\n+        blockMap.put(\"ArabicPresentationForms-B\", new int[] { '\\uFE70', '\\uFEFE' });\n+        // blockMap.put(\"Specials\", new int[]{0xFEFF, 0xFEFF}); // Formal\n+        blockMap.put(\"HalfwidthandFullwidthForms\", new int[] { '\\uFF00', '\\uFFEF' });\n+        // blockMap.put(\"Specials\", new int[]{0xFFF0, 0xFFFD}); // Formal\n+        blockMap.put(\"Specials\", new int[] { 0xFEFF, 0xFFFD }); // Range overlaps.\n+        blockMap.put(\"OldItalic\", new int[] { 0x10300, 0x1032F });\n+        blockMap.put(\"Gothic\", new int[] { 0x10330, 0x1034F });\n+        blockMap.put(\"Deseret\", new int[] { 0x10400, 0x1044F });\n+        blockMap.put(\"ByzantineMusicalSymbols\", new int[] { 0x1D000, 0x1D0FF });\n+        blockMap.put(\"MusicalSymbols\", new int[] { 0x1D100, 0x1D1FF });\n+        blockMap.put(\"MathematicalAlphanumericSymbols\", new int[] { 0x1D400, 0x1D7FF });\n+        blockMap.put(\"CJKUnifiedIdeographsExtensionB\", new int[] { 0x20000, 0x2A6D6 });\n+        blockMap.put(\"CJKCompatibilityIdeographsSupplement\", new int[] { 0x2F800, 0x2FA1F });\n+        blockMap.put(\"Tags\", new int[] { 0xE0000, 0xFFFFD });\n+    }\n+\n+    /**\n+     * set Unicode category\n+     */\n+\n+    public void setCategory(final String category)\n+        throws StringRegExException\n+    {\n+        PreCondition.assertArgumentNotNull(category, \"abbr\");\n+        m_category = categoryMap.get(category);\n+        if (m_category == null)\n+        {\n+            throw new StringRegExException(StringRegExException.Kind.invalidUnicodeCategory, category);\n+        }\n+    }\n+\n+    /**\n+     * set Unicode block to match against.\n+     * \n+     * @param blockName\n+     *            the XSD-style block name (spaces removed)\n+     */\n+\n+    public void setBlock(final String blockName)\n+        throws StringRegExException\n+    {\n+        final int range[] = blockMap.get(blockName);\n+        if (range == null)\n+        {\n+            throw new StringRegExException(StringRegExException.Kind.invalidUnicodeBlockName, blockName);\n+        }\n+        addChar(range[0], range[1]);\n+    }\n+\n+    public void setOccurrence(final int min, final int max)\n+    {\n+        minOccurrence = min;\n+        maxOccurrence = max;\n+    }\n+\n+    /**\n+     * returns whether this term contains a sequence of one or more subterms\n+     */\n+\n+    public boolean isSequence()\n+    {\n+        return type == Type.TYPE_SEQ;\n+    }\n+\n+    /**\n+     * returns whether this term contains a choice of one or more subterms\n+     */\n+\n+    public boolean isChoice()\n+    {\n+        return type == Type.TYPE_CHOICE;\n+    }\n+\n+    /**\n+     * returns whether this term contains a set of one or more subterms\n+     */\n+\n+    public boolean isInterleave()\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * returns an Enumeration of this term's subterms\n+     */\n+\n+    public Iterable<StringRegExPatternTerm> getSubTerms()\n+    {\n+        return subTermList;\n+    }\n+\n+    /**\n+     * returns whether this leaf term matches the given token.\n+     */\n+\n+    public boolean matches(final String token)\n+    {\n+        if (type == Type.TYPE_LEAF_WILDCARD)\n+        {\n+            return true;\n+        }\n+        // Debug.assert(type == TYPE_LEAF_POSITIVE || type == TYPE_LEAF_NEGATIVE);\n+\n+        boolean matched = false;\n+        if (m_category != null)\n+        {\n+            if ( (token != null) && token.length() > 0)\n+            {\n+                for (int i = 0; i < m_category.length && !matched; i++)\n+                {\n+                    matched = m_category[i] == Character.getType(token.charAt(0));\n+                }\n+            }\n+        }\n+        else\n+        {\n+            for (final Iterator<CharRange> i = rangeList.iterator(); i.hasNext() && !matched;)\n+            {\n+                matched = i.next().matches(token);\n+            }\n+            for (final Iterator<StringRegExPatternTerm> i = subTermList.iterator(); i.hasNext() && !matched;)\n+            {\n+                matched = i.next().matches(token);\n+            }\n+        }\n+        if (type == Type.TYPE_LEAF_NEGATIVE)\n+        {\n+            matched = !matched;\n+        }\n+        if (matched && notTerm != null && notTerm.matches(token))\n+        {\n+            matched = false;\n+        }\n+        return matched;\n+    }\n+\n+    /**\n+     * Returns true if this term and the other term are both leaf terms and there exist some tokens which match both\n+     * terms. Used to check for determinism.\n+     */\n+\n+    public boolean intersects(StringRegExPatternTerm other)\n+    {\n+        if (isLeaf() && other.isLeaf())\n+        {\n+            if (type == Type.TYPE_LEAF_WILDCARD || other.type == Type.TYPE_LEAF_WILDCARD)\n+                return true;\n+            if (type == Type.TYPE_LEAF_NEGATIVE)\n+            {\n+                if (other.type == Type.TYPE_LEAF_POSITIVE)\n+                    return other.intersects(this); // prefer this being positive\n+                else\n+                return false; // both negative => assume intersects\n+            }\n+            if (m_category != null)\n+            {\n+                if (other.m_category == null)\n+                    return other.intersects(this); // prefer this being non-category\n+                else\n+                {\n+                    // only intersect if they share same categories\n+                    for (final int x : m_category)\n+                    {\n+                        for (final int y : other.m_category)\n+                        {\n+                            if (x == y)\n+                            {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                    return false;\n+                }\n+            }\n+            // fixme should check categories\n+            // type must be positive (though we could have negative subterms)\n+            // see if any of our elements match 'other'\n+            for (final CharRange cr : rangeList)\n+            {\n+                for (int c = cr.getFirst(); c <= cr.getLast() ; c++)\n+                {\n+                    if (notTerm != null && notTerm.matches(String.valueOf(c)))\n+                    {\n+                        continue;\n+                    }\n+                    if (other.matches(String.valueOf(c)))\n+                    {\n+                        return true; // they intersect\n+                    }\n+                }\n+            }\n+            for (final StringRegExPatternTerm term : subTermList)\n+            {\n+                if (term.intersects(other))\n+                {\n+                    return true; // they intersect\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean isLeaf()\n+    {\n+        return type == Type.TYPE_LEAF_WILDCARD || type == Type.TYPE_LEAF_POSITIVE || type == Type.TYPE_LEAF_NEGATIVE;\n+    }\n+\n+    /**\n+     * returns the minimum number of occurrences of this term.\n+     */\n+\n+    public int minOccurs()\n+    {\n+        return minOccurrence;\n+    }\n+\n+    /**\n+     * returns the maximum number of occurrences of this term. returns Integer.MAX_VALUE to indicate unlimited\n+     * occurrences.\n+     */\n+\n+    public int maxOccurs()\n+    {\n+        return maxOccurrence;\n+    }\n+\n+    public String toString()\n+    {\n+        String s = \"\";\n+        if (isChoice())\n+        {\n+            s += \"(\";\n+            for (int i = 0; i < subTermList.size() ; i++)\n+            {\n+                if (i > 0)\n+                    s += \" | \";\n+                s += subTermList.get(i).toString();\n+            }\n+            s += \")\";\n+        }\n+        else if (isSequence())\n+        {\n+            s += \"(\";\n+            for (int i = 0; i < subTermList.size() ; i++)\n+            {\n+                if (i > 0)\n+                    s += \", \";\n+                s += subTermList.get(i).toString();\n+            }\n+            s += \")\";\n+        }\n+        else if (type == Type.TYPE_LEAF_WILDCARD)\n+        {\n+            s = \"WILDCARD\";\n+        }\n+        else\n+        {\n+            if (type == Type.TYPE_LEAF_POSITIVE && subTermList.size() == 0 && rangeList.size() == 1 && rangeList.get(0).toString().length() == 1)\n+                s = rangeList.get(0).toString();\n+            else\n+            {\n+                s += \"[\";\n+                if (type == Type.TYPE_LEAF_NEGATIVE)\n+                    s += \"^\";\n+                if (m_category != null)\n+                {\n+                    s += \"UnicodeProperty(\";\n+                    for (int i = 0; i < m_category.length; i++)\n+                    s += (i == 0 ? \"\" : \",\") + m_category[i];\n+                    s += \")\";\n+                }\n+                for (final CharRange cr : rangeList)\n+                {\n+                    s += cr.toString();\n+                }\n+                for (final StringRegExPatternTerm term : subTermList)\n+                {\n+                    s += term.toString();\n+                }\n+                if (notTerm != null)\n+                    s += \"-\" + notTerm.toString();\n+                s += \"]\";\n+            }\n+        }\n+        if (minOccurrence == 1 && maxOccurrence == 1)\n+        {\n+            // Do nothing\n+\n+        }\n+        else if (minOccurrence == 0 && maxOccurrence == 1)\n+        {\n+            s += \"?\";\n+        }\n+        else if (minOccurrence == 0 && maxOccurrence == RegExBridge.UNBOUNDED)\n+        {\n+            s += \"*\";\n+        }\n+        else if (minOccurrence == 1 && maxOccurrence == RegExBridge.UNBOUNDED)\n+        {\n+            s += \"+\";\n+        }\n+        else\n+        {\n+            s += \"{\" + minOccurrence + \",\";\n+            if (maxOccurrence != RegExBridge.UNBOUNDED)\n+            {\n+                s += maxOccurrence;\n+            }\n+            s += \"}\";\n+        }\n+        return s;\n+    }\n+\n+    static String ctoUnicodeEsc(final int i)\n+    {\n+        char out[] = { '\\\\', 'u', Character.forDigit((i >> 12) & 0xF, 16), Character.forDigit((i >> 8) & 0xF, 16), Character.forDigit((i >> 4) & 0xF, 16), Character.forDigit(i & 0xF, 16) };\n+        return new String(out);\n+    }\n+\n+    public static String charString(int c)\n+    {\n+        if (c < ' ' || c >= 255)\n+        {\n+            return ctoUnicodeEsc(c);\n+        }\n+        switch (c)\n+        {\n+            case StringRegExParser.NEWLINE:\n+                return \"\\\\n\";\n+            case StringRegExParser.RETURN:\n+                return \"\\\\r\";\n+            case StringRegExParser.TAB:\n+                return \"\\\\t\";\n+            case '\\\\':\n+                return \"\\\\\\\\\";\n+            case '.':\n+            case '-':\n+            case '|':\n+            case '^':\n+            case '?':\n+            case '*':\n+            case '+':\n+            case '[':\n+            case ']':\n+            case '(':\n+            case ')':\n+            case '{':\n+            case '}':\n+                return \"\\\\\" + c;\n+        }\n+        return \"\" + c;\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 570
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "35",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/113/StringRegExPatternTerm.java\nindex 5966d92c3b9..90cf6a4a878 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/113/StringRegExPatternTerm.java\n@@ -31,7 +31,7 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  */\n public final class StringRegExPatternTerm\n {\n-\tpublic enum Type\n+public enum Type\n \t{\n \t\tTYPE_SEQ, TYPE_CHOICE, TYPE_LEAF_POSITIVE, TYPE_LEAF_NEGATIVE, TYPE_LEAF_WILDCARD\n \t}\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "35",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/113/StringRegExPatternTerm.java\nindex 5966d92c3b9..99fbb48a44c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/113/StringRegExPatternTerm.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/113/StringRegExPatternTerm.java\n@@ -31,7 +31,7 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  */\n public final class StringRegExPatternTerm\n {\n-\tpublic enum Type\n+    public enum Type\n \t{\n \t\tTYPE_SEQ, TYPE_CHOICE, TYPE_LEAF_POSITIVE, TYPE_LEAF_NEGATIVE, TYPE_LEAF_WILDCARD\n \t}\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}