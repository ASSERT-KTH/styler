{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "138",
    "information": {
        "errors": [
            {
                "line": "23",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import org.apache.accumulo.core.client.Connector;\nimport org.apache.accumulo.core.security.Authorizations;\nimport org.apache.accumulo.core.trace.thrift.TInfo;\nimport org.apache.commons.collections4.iterators.TransformIterator;\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.log4j.Logger;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "23",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "23",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/138/RunningQuery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/138/RunningQuery.java\nindex b6a8c4b238b..3a8bd1ed34d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/138/RunningQuery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/138/RunningQuery.java\n@@ -40,504 +40,530 @@ import java.util.concurrent.TimeoutException;\n \n /**\n  * Object that encapsulates a running query\n- *\n  */\n public class RunningQuery extends AbstractRunningQuery implements Runnable {\n-    \n-    private static final long serialVersionUID = 1L;\n-    \n-    private static Logger log = Logger.getLogger(RunningQuery.class);\n-    \n-    private transient Connector connection = null;\n-    private AccumuloConnectionFactory.Priority connectionPriority = null;\n-    private transient QueryLogic<?> logic = null;\n-    private Query settings = null;\n-    private long numResults = 0;\n-    private long lastPageNumber = 0;\n-    private transient TransformIterator iter = null;\n-    private Set<Authorizations> calculatedAuths = null;\n-    private boolean finished = false;\n-    private volatile boolean canceled = false;\n-    private TInfo traceInfo = null;\n-    private transient QueryMetricsBean queryMetrics = null;\n-    private RunningQueryTiming timing = null;\n-    private ExecutorService executor = null;\n-    private volatile Future<Object> future = null;\n-    private QueryPredictor predictor = null;\n-    private long maxResults = 0;\n-    \n-    public RunningQuery() {\n-        super(new QueryMetricFactoryImpl());\n-    }\n-    \n-    public RunningQuery(Connector connection, AccumuloConnectionFactory.Priority priority, QueryLogic<?> logic, Query settings, String methodAuths,\n-                    Principal principal, QueryMetricFactory metricFactory) throws Exception {\n-        this(null, connection, priority, logic, settings, methodAuths, principal, null, null, metricFactory);\n-    }\n-    \n-    public RunningQuery(Connector connection, AccumuloConnectionFactory.Priority priority, QueryLogic<?> logic, Query settings, String methodAuths,\n-                    Principal principal, RunningQueryTiming timing, ExecutorService executor, QueryMetricFactory metricFactory) throws Exception {\n-        this(null, connection, priority, logic, settings, methodAuths, principal, timing, executor, metricFactory);\n-    }\n-    \n-    public RunningQuery(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority, QueryLogic<?> logic, Query settings,\n-                    String methodAuths, Principal principal, QueryMetricFactory metricFactory) throws Exception {\n-        this(queryMetrics, connection, priority, logic, settings, methodAuths, principal, null, null, metricFactory);\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  private static Logger log = Logger.getLogger(RunningQuery.class);\n+\n+  private transient Connector connection = null;\n+  private AccumuloConnectionFactory.Priority connectionPriority = null;\n+  private transient QueryLogic<?> logic = null;\n+  private Query settings = null;\n+  private long numResults = 0;\n+  private long lastPageNumber = 0;\n+  private transient TransformIterator iter = null;\n+  private Set<Authorizations> calculatedAuths = null;\n+  private boolean finished = false;\n+  private volatile boolean canceled = false;\n+  private TInfo traceInfo = null;\n+  private transient QueryMetricsBean queryMetrics = null;\n+  private RunningQueryTiming timing = null;\n+  private ExecutorService executor = null;\n+  private volatile Future<Object> future = null;\n+  private QueryPredictor predictor = null;\n+  private long maxResults = 0;\n+\n+  public RunningQuery() {\n+    super(new QueryMetricFactoryImpl());\n+  }\n+\n+  public RunningQuery(Connector connection, AccumuloConnectionFactory.Priority priority, QueryLogic<?> logic,\n+                      Query settings, String methodAuths,\n+                      Principal principal, QueryMetricFactory metricFactory) throws Exception {\n+    this(null, connection, priority, logic, settings, methodAuths, principal, null, null, metricFactory);\n+  }\n+\n+  public RunningQuery(Connector connection, AccumuloConnectionFactory.Priority priority, QueryLogic<?> logic,\n+                      Query settings, String methodAuths,\n+                      Principal principal, RunningQueryTiming timing, ExecutorService executor,\n+                      QueryMetricFactory metricFactory) throws Exception {\n+    this(null, connection, priority, logic, settings, methodAuths, principal, timing, executor, metricFactory);\n+  }\n+\n+  public RunningQuery(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority,\n+                      QueryLogic<?> logic, Query settings,\n+                      String methodAuths, Principal principal, QueryMetricFactory metricFactory) throws Exception {\n+    this(queryMetrics, connection, priority, logic, settings, methodAuths, principal, null, null, metricFactory);\n+  }\n+\n+  public RunningQuery(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority,\n+                      QueryLogic<?> logic, Query settings,\n+                      String methodAuths, Principal principal, RunningQueryTiming timing, ExecutorService executor,\n+                      QueryMetricFactory metricFactory)\n+      throws Exception {\n+    this(queryMetrics, connection, priority, logic, settings, methodAuths, principal, timing, executor, null,\n+        metricFactory);\n+  }\n+\n+  public RunningQuery(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority,\n+                      QueryLogic<?> logic, Query settings,\n+                      String methodAuths, Principal principal, RunningQueryTiming timing, ExecutorService executor,\n+                      QueryPredictor predictor,\n+                      QueryMetricFactory metricFactory) throws Exception {\n+    super(metricFactory);\n+    if (logic != null && logic.getCollectQueryMetrics()) {\n+      this.queryMetrics = queryMetrics;\n+    }\n+    this.getMetric().setLifecycle(QueryMetric.Lifecycle.DEFINED);\n+    this.logic = logic;\n+    this.connectionPriority = priority;\n+    this.settings = settings;\n+    this.calculatedAuths = AuthorizationsUtil.getDowngradedAuthorizations(methodAuths, principal);\n+    this.timing = timing;\n+    this.executor = executor;\n+    this.predictor = predictor;\n+    // set the metric information\n+    this.settings.populateMetric(this.getMetric());\n+    this.getMetric().setQueryType(this.getClass().getSimpleName());\n+    if (this.queryMetrics != null) {\n+      try {\n+        this.queryMetrics.updateMetric(this.getMetric());\n+      } catch (Exception e) {\n+        log.error(e.getMessage(), e);\n+      }\n+    }\n+    // If connection is null, then we are likely not going to use this object for query, probably for removing or closing it.\n+    if (null != connection) {\n+      setConnection(connection);\n+    }\n+    this.maxResults = this.logic.getResultLimit(this.settings.getDnList());\n+    if (this.maxResults != this.logic.getMaxResults()) {\n+      log.info(\"Maximum results set to \" + this.maxResults + \" instead of default \" + this.logic.getMaxResults() +\n+          \", user \" + this.settings.getUserDN()\n+          + \" has a DN configured with a different limit\");\n+    }\n+  }\n+\n+  public static RunningQuery createQueryWithAuthorizations(QueryMetricsBean queryMetrics, Connector connection,\n+                                                           AccumuloConnectionFactory.Priority priority,\n+                                                           QueryLogic<?> logic, Query settings, String methodAuths,\n+                                                           RunningQueryTiming timing, ExecutorService executor,\n+                                                           QueryPredictor predictor,\n+                                                           QueryMetricFactory metricFactory) throws Exception {\n+    RunningQuery runningQuery =\n+        new RunningQuery(queryMetrics, connection, priority, logic, settings, methodAuths, null, timing, executor,\n+            predictor,\n+            metricFactory);\n+    runningQuery.calculatedAuths = Collections.singleton(new Authorizations(methodAuths));\n+    return runningQuery;\n+  }\n+\n+  private void addNDC() {\n+    String user = this.settings.getUserDN();\n+    UUID uuid = this.settings.getId();\n+    if (user != null && uuid != null) {\n+      NDC.push(\"[\" + user + \"] [\" + uuid + \"]\");\n     }\n-    \n-    public RunningQuery(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority, QueryLogic<?> logic, Query settings,\n-                    String methodAuths, Principal principal, RunningQueryTiming timing, ExecutorService executor, QueryMetricFactory metricFactory)\n-                    throws Exception {\n-        this(queryMetrics, connection, priority, logic, settings, methodAuths, principal, timing, executor, null, metricFactory);\n+  }\n+\n+  private void removeNDC() {\n+    NDC.pop();\n+  }\n+\n+  public void setConnection(Connector connection) throws Exception {\n+    // if we are setting this null, we shouldn't try to initialize\n+    // the internal logic\n+    if (connection == null) {\n+      this.connection = null;\n+      return;\n     }\n-    \n-    public RunningQuery(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority, QueryLogic<?> logic, Query settings,\n-                    String methodAuths, Principal principal, RunningQueryTiming timing, ExecutorService executor, QueryPredictor predictor,\n-                    QueryMetricFactory metricFactory) throws Exception {\n-        super(metricFactory);\n-        if (logic != null && logic.getCollectQueryMetrics()) {\n-            this.queryMetrics = queryMetrics;\n+\n+    try {\n+      addNDC();\n+      applyPrediction(null);\n+      this.connection = connection;\n+      long start = System.currentTimeMillis();\n+      GenericQueryConfiguration configuration =\n+          this.logic.initialize(this.connection, this.settings, this.calculatedAuths);\n+      this.lastPageNumber = 0;\n+      this.logic.setupQuery(configuration);\n+      this.iter = this.logic.getTransformIterator(this.settings);\n+      // the configuration query string should now hold the planned query\n+      this.getMetric().setPlan(configuration.getQueryString());\n+      this.getMetric().setSetupTime((System.currentTimeMillis() - start));\n+      this.getMetric().setLifecycle(QueryMetric.Lifecycle.INITIALIZED);\n+      testForUncaughtException(0);\n+      // TODO: applyPrediction(\"Plan\");\n+    } catch (Exception e) {\n+      log.error(e.getMessage(), e);\n+      this.getMetric().setError(e);\n+      throw e;\n+    } finally {\n+      // update AbstractRunningQuery.lastUsed in case this operation took a long time\n+      touch();\n+      removeNDC();\n+      if (this.queryMetrics != null) {\n+        try {\n+          this.queryMetrics.updateMetric(this.getMetric());\n+        } catch (Exception e) {\n+          log.error(e.getMessage(), e);\n         }\n-        this.getMetric().setLifecycle(QueryMetric.Lifecycle.DEFINED);\n-        this.logic = logic;\n-        this.connectionPriority = priority;\n-        this.settings = settings;\n-        this.calculatedAuths = AuthorizationsUtil.getDowngradedAuthorizations(methodAuths, principal);\n-        this.timing = timing;\n-        this.executor = executor;\n-        this.predictor = predictor;\n-        // set the metric information\n-        this.settings.populateMetric(this.getMetric());\n-        this.getMetric().setQueryType(this.getClass().getSimpleName());\n-        if (this.queryMetrics != null) {\n-            try {\n-                this.queryMetrics.updateMetric(this.getMetric());\n-            } catch (Exception e) {\n-                log.error(e.getMessage(), e);\n-            }\n+      }\n+    }\n+  }\n+\n+  public ResultsPage next() throws Exception {\n+    // update AbstractRunningQuery.lastUsed\n+    touch();\n+    long pageStartTime = System.currentTimeMillis();\n+    List<Object> resultList = new ArrayList<>();\n+    boolean hitPageByteTrigger = false;\n+    boolean hitPageTimeTrigger = false;\n+    try {\n+      addNDC();\n+      int currentPageCount = 0;\n+      long currentPageBytes = 0;\n+\n+      // test for any exceptions prior to loop as hasNext() would likely be false;\n+      testForUncaughtException(resultList.size());\n+\n+      while (!this.finished && ((future != null) || this.iter.hasNext())) {\n+        // if we are canceled, then break out\n+        if (this.canceled) {\n+          log.info(\"Query has been cancelled, aborting query.next call\");\n+          this.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n+          break;\n         }\n-        // If connection is null, then we are likely not going to use this object for query, probably for removing or closing it.\n-        if (null != connection) {\n-            setConnection(connection);\n+        // if the number of results has reached out page size, then break out\n+        if (currentPageCount >= this.settings.getPagesize()) {\n+          log.info(\"Query requested page size had been reached, aborting query.next call\");\n+          break;\n         }\n-        this.maxResults = this.logic.getResultLimit(this.settings.getDnList());\n-        if (this.maxResults != this.logic.getMaxResults()) {\n-            log.info(\"Maximum results set to \" + this.maxResults + \" instead of default \" + this.logic.getMaxResults() + \", user \" + this.settings.getUserDN()\n-                            + \" has a DN configured with a different limit\");\n+        // if the logic had a max page size and we have reached that, then break out\n+        if (this.logic.getMaxPageSize() > 0 && currentPageCount >= this.logic.getMaxPageSize()) {\n+          log.info(\"Query logic max page size has been reached, aborting query.next call\");\n+          break;\n         }\n-    }\n-    \n-    public static RunningQuery createQueryWithAuthorizations(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority,\n-                    QueryLogic<?> logic, Query settings, String methodAuths, RunningQueryTiming timing, ExecutorService executor, QueryPredictor predictor,\n-                    QueryMetricFactory metricFactory) throws Exception {\n-        RunningQuery runningQuery = new RunningQuery(queryMetrics, connection, priority, logic, settings, methodAuths, null, timing, executor, predictor,\n-                        metricFactory);\n-        runningQuery.calculatedAuths = Collections.singleton(new Authorizations(methodAuths));\n-        return runningQuery;\n-    }\n-    \n-    private void addNDC() {\n-        String user = this.settings.getUserDN();\n-        UUID uuid = this.settings.getId();\n-        if (user != null && uuid != null) {\n-            NDC.push(\"[\" + user + \"] [\" + uuid + \"]\");\n+        // if the logic had a page byte trigger and we have readed that, then break out\n+        if (this.logic.getPageByteTrigger() > 0 && currentPageBytes >= this.logic.getPageByteTrigger()) {\n+          log.info(\"Query logic max page byte trigger has been reached, aborting query.next call\");\n+          hitPageByteTrigger = true;\n+          break;\n         }\n-    }\n-    \n-    private void removeNDC() {\n-        NDC.pop();\n-    }\n-    \n-    public void setConnection(Connector connection) throws Exception {\n-        // if we are setting this null, we shouldn't try to initialize\n-        // the internal logic\n-        if (connection == null) {\n-            this.connection = null;\n-            return;\n+        // if the logic had a max num results (across all pages) and we have reached that (or the maxResultsOverride if set), then break out\n+        if (this.settings.isMaxResultsOverridden()) {\n+          if (this.settings.getMaxResultsOverride() >= 0 && numResults >= this.settings.getMaxResultsOverride()) {\n+            log.info(\"Max results override has been reached, aborting query.next call\");\n+            this.getMetric().setLifecycle(QueryMetric.Lifecycle.MAXRESULTS);\n+            break;\n+          }\n+        } else if (this.maxResults >= 0 && numResults >= this.maxResults) {\n+          log.info(\"Query logic max results has been reached, aborting query.next call\");\n+          this.getMetric().setLifecycle(QueryMetric.Lifecycle.MAXRESULTS);\n+          break;\n         }\n-        \n-        try {\n-            addNDC();\n-            applyPrediction(null);\n-            this.connection = connection;\n-            long start = System.currentTimeMillis();\n-            GenericQueryConfiguration configuration = this.logic.initialize(this.connection, this.settings, this.calculatedAuths);\n-            this.lastPageNumber = 0;\n-            this.logic.setupQuery(configuration);\n-            this.iter = this.logic.getTransformIterator(this.settings);\n-            // the configuration query string should now hold the planned query\n-            this.getMetric().setPlan(configuration.getQueryString());\n-            this.getMetric().setSetupTime((System.currentTimeMillis() - start));\n-            this.getMetric().setLifecycle(QueryMetric.Lifecycle.INITIALIZED);\n-            testForUncaughtException(0);\n-            // TODO: applyPrediction(\"Plan\");\n-        } catch (Exception e) {\n-            log.error(e.getMessage(), e);\n-            this.getMetric().setError(e);\n-            throw e;\n-        } finally {\n-            // update AbstractRunningQuery.lastUsed in case this operation took a long time\n-            touch();\n-            removeNDC();\n-            if (this.queryMetrics != null) {\n-                try {\n-                    this.queryMetrics.updateMetric(this.getMetric());\n-                } catch (Exception e) {\n-                    log.error(e.getMessage(), e);\n-                }\n-            }\n+        if (this.logic.getMaxWork() >= 0 &&\n+            (this.getMetric().getNextCount() + this.getMetric().getSeekCount()) >= this.logic.getMaxWork()) {\n+          log.info(\"Query logic max work has been reached, aborting query.next call\");\n+          this.getMetric().setLifecycle(QueryMetric.Lifecycle.MAXWORK);\n+          break;\n         }\n-    }\n-    \n-    public ResultsPage next() throws Exception {\n-        // update AbstractRunningQuery.lastUsed\n-        touch();\n-        long pageStartTime = System.currentTimeMillis();\n-        List<Object> resultList = new ArrayList<>();\n-        boolean hitPageByteTrigger = false;\n-        boolean hitPageTimeTrigger = false;\n-        try {\n-            addNDC();\n-            int currentPageCount = 0;\n-            long currentPageBytes = 0;\n-            \n-            // test for any exceptions prior to loop as hasNext() would likely be false;\n-            testForUncaughtException(resultList.size());\n-            \n-            while (!this.finished && ((future != null) || this.iter.hasNext())) {\n-                // if we are canceled, then break out\n-                if (this.canceled) {\n-                    log.info(\"Query has been cancelled, aborting query.next call\");\n-                    this.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n-                    break;\n-                }\n-                // if the number of results has reached out page size, then break out\n-                if (currentPageCount >= this.settings.getPagesize()) {\n-                    log.info(\"Query requested page size had been reached, aborting query.next call\");\n-                    break;\n-                }\n-                // if the logic had a max page size and we have reached that, then break out\n-                if (this.logic.getMaxPageSize() > 0 && currentPageCount >= this.logic.getMaxPageSize()) {\n-                    log.info(\"Query logic max page size has been reached, aborting query.next call\");\n-                    break;\n-                }\n-                // if the logic had a page byte trigger and we have readed that, then break out\n-                if (this.logic.getPageByteTrigger() > 0 && currentPageBytes >= this.logic.getPageByteTrigger()) {\n-                    log.info(\"Query logic max page byte trigger has been reached, aborting query.next call\");\n-                    hitPageByteTrigger = true;\n-                    break;\n-                }\n-                // if the logic had a max num results (across all pages) and we have reached that (or the maxResultsOverride if set), then break out\n-                if (this.settings.isMaxResultsOverridden()) {\n-                    if (this.settings.getMaxResultsOverride() >= 0 && numResults >= this.settings.getMaxResultsOverride()) {\n-                        log.info(\"Max results override has been reached, aborting query.next call\");\n-                        this.getMetric().setLifecycle(QueryMetric.Lifecycle.MAXRESULTS);\n-                        break;\n-                    }\n-                } else if (this.maxResults >= 0 && numResults >= this.maxResults) {\n-                    log.info(\"Query logic max results has been reached, aborting query.next call\");\n-                    this.getMetric().setLifecycle(QueryMetric.Lifecycle.MAXRESULTS);\n-                    break;\n-                }\n-                if (this.logic.getMaxWork() >= 0 && (this.getMetric().getNextCount() + this.getMetric().getSeekCount()) >= this.logic.getMaxWork()) {\n-                    log.info(\"Query logic max work has been reached, aborting query.next call\");\n-                    this.getMetric().setLifecycle(QueryMetric.Lifecycle.MAXWORK);\n-                    break;\n-                }\n-                // if we are the specified amount on the way to timing out on this call and we have results,\n-                // determine whether we are on track to having enough results\n-                // use the pagestart time for the time in call since we only care about the execution time of\n-                // this page.\n-                long pageTimeInCall = (System.currentTimeMillis() - pageStartTime);\n-                \n-                int maxPageSize = Math.min(this.settings.getPagesize(), this.logic.getMaxPageSize());\n-                if (timing != null && currentPageCount > 0 && timing.shouldReturnPartialResults(currentPageCount, maxPageSize, pageTimeInCall)) {\n-                    log.info(\"Query logic max expire before page is full, returning existing results \" + currentPageCount + \" \" + maxPageSize + \" \"\n-                                    + pageTimeInCall + \" \" + timing);\n-                    hitPageTimeTrigger = true;\n-                    break;\n-                }\n-                \n-                Object o = null;\n-                if (executor != null) {\n-                    if (future == null) {\n-                        future = executor.submit(() -> iter.next());\n-                    }\n-                    try {\n-                        o = future.get(1, TimeUnit.MINUTES);\n-                        future = null;\n-                    } catch (InterruptedException ie) {\n-                        // in this case we were most likely cancelled, no longer waiting\n-                        future = null;\n-                    } catch (ExecutionException ee) {\n-                        // in this case we need to pass up the exception\n-                        future = null;\n-                        throw ee;\n-                    } catch (TimeoutException te) {\n-                        // in this case we are still waiting on our future....simply continue\n-                    }\n-                } else {\n-                    o = iter.next();\n-                }\n-                \n-                // regardless whether the transform iterator returned a result, it may have updated the metrics (next/seek calls etc.)\n-                if (iter.getTransformer() instanceof WritesQueryMetrics) {\n-                    ((WritesQueryMetrics) iter.getTransformer()).writeQueryMetrics(this.getMetric());\n-                }\n-                \n-                // if not still waiting on a future, then process the result (or lack thereof)\n-                if (future == null) {\n-                    if (null == o) {\n-                        log.debug(\"Null result encountered, no more results\");\n-                        this.finished = true;\n-                        break;\n-                    }\n-                    resultList.add(o);\n-                    if (this.logic.getPageByteTrigger() > 0) {\n-                        currentPageBytes += ObjectSizeOf.Sizer.getObjectSize(o);\n-                    }\n-                    currentPageCount++;\n-                    numResults++;\n-                }\n-                \n-                testForUncaughtException(resultList.size());\n-            }\n-            \n-            // if the last hasNext() call failed, then we would catch the exception here\n-            testForUncaughtException(resultList.size());\n-            \n-            // Update the metric\n-            long now = System.currentTimeMillis();\n-            this.getMetric().addPageTime(currentPageCount, now - pageStartTime, pageStartTime, now);\n-            this.lastPageNumber++;\n-            if (!resultList.isEmpty()) {\n-                this.getMetric().setLifecycle(QueryMetric.Lifecycle.RESULTS);\n-            }\n-        } catch (Exception e) {\n-            log.error(e.getMessage(), e);\n-            this.getMetric().setError(e);\n-            throw e;\n-        } finally {\n-            // update AbstractRunningQuery.lastUsed in case this operation took a long time\n-            touch();\n-            removeNDC();\n-            \n-            if (this.queryMetrics != null) {\n-                try {\n-                    this.queryMetrics.updateMetric(this.getMetric());\n-                } catch (Exception e) {\n-                    log.error(e.getMessage(), e);\n-                }\n-            }\n+        // if we are the specified amount on the way to timing out on this call and we have results,\n+        // determine whether we are on track to having enough results\n+        // use the pagestart time for the time in call since we only care about the execution time of\n+        // this page.\n+        long pageTimeInCall = (System.currentTimeMillis() - pageStartTime);\n+\n+        int maxPageSize = Math.min(this.settings.getPagesize(), this.logic.getMaxPageSize());\n+        if (timing != null && currentPageCount > 0 &&\n+            timing.shouldReturnPartialResults(currentPageCount, maxPageSize, pageTimeInCall)) {\n+          log.info(\"Query logic max expire before page is full, returning existing results \" + currentPageCount + \" \" +\n+              maxPageSize + \" \"\n+              + pageTimeInCall + \" \" + timing);\n+          hitPageTimeTrigger = true;\n+          break;\n         }\n-        if (resultList.isEmpty()) {\n-            return new ResultsPage();\n+\n+        Object o = null;\n+        if (executor != null) {\n+          if (future == null) {\n+            future = executor.submit(() -> iter.next());\n+          }\n+          try {\n+            o = future.get(1, TimeUnit.MINUTES);\n+            future = null;\n+          } catch (InterruptedException ie) {\n+            // in this case we were most likely cancelled, no longer waiting\n+            future = null;\n+          } catch (ExecutionException ee) {\n+            // in this case we need to pass up the exception\n+            future = null;\n+            throw ee;\n+          } catch (TimeoutException te) {\n+            // in this case we are still waiting on our future....simply continue\n+          }\n         } else {\n-            return new ResultsPage(resultList, ((hitPageByteTrigger || hitPageTimeTrigger) ? ResultsPage.Status.PARTIAL : ResultsPage.Status.COMPLETE));\n-        }\n-    }\n-    \n-    public void cancel() {\n-        this.canceled = true;\n-        // save off the future as it could be removed at any time\n-        Future<Object> future = this.future;\n-        // cancel the future if we have one\n-        if (future != null) {\n-            future.cancel(true);\n+          o = iter.next();\n         }\n-        \n-        // change status to cancelled\n-        this.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n-    }\n-    \n-    public boolean isFinished() {\n-        return finished;\n-    }\n-    \n-    public boolean isCanceled() {\n-        return canceled;\n-    }\n-    \n-    public Connector getConnection() {\n-        return connection;\n-    }\n-    \n-    public AccumuloConnectionFactory.Priority getConnectionPriority() {\n-        return connectionPriority;\n-    }\n-    \n-    public QueryLogic<?> getLogic() {\n-        return logic;\n-    }\n-    \n-    public Query getSettings() {\n-        return settings;\n-    }\n-    \n-    public TransformIterator getTransformIterator() {\n-        return iter;\n-    }\n-    \n-    protected Set<Authorizations> getCalculatedAuths() {\n-        return calculatedAuths;\n-    }\n-    \n-    protected QueryPredictor getPredictor() {\n-        return this.predictor;\n-    }\n-    \n-    public void setPredictor(QueryPredictor predictor) {\n-        this.predictor = predictor;\n-    }\n-    \n-    protected void applyPrediction(String context) {\n-        if (getPredictor() != null) {\n-            try {\n-                Set<Prediction> predictions = getPredictor().predict(this.getMetric());\n-                if (predictions != null) {\n-                    // now we have a predictions, lets broadcast\n-                    log.info(\"Model predictions: \" + predictions);\n-                    context = (context == null ? \"\" : context + ' ');\n-                    for (Prediction prediction : predictions) {\n-                        // append the context to the predictions\n-                        this.getMetric().addPrediction(new Prediction(context + prediction.getName(), prediction.getPrediction()));\n-                    }\n-                }\n-            } catch (Exception e) {\n-                log.warn(\"Unable to apply query prediction\", e);\n-            }\n-        }\n-    }\n-    \n-    public void closeConnection(AccumuloConnectionFactory factory) throws Exception {\n-        this.getMetric().setLifecycle(BaseQueryMetric.Lifecycle.CLOSED);\n-        \n-        if (iter != null && iter.getTransformer() instanceof WritesResultCardinalities) {\n-            ((WritesResultCardinalities) iter.getTransformer()).writeResultCardinalities();\n+\n+        // regardless whether the transform iterator returned a result, it may have updated the metrics (next/seek calls etc.)\n+        if (iter.getTransformer() instanceof WritesQueryMetrics) {\n+          ((WritesQueryMetrics) iter.getTransformer()).writeQueryMetrics(this.getMetric());\n         }\n-        \n-        if (connection != null) {\n-            try {\n-                factory.returnConnection(connection);\n-                connection = null;\n-            } finally {\n-                // only push metrics if this RunningQuery was initialized\n-                if (this.queryMetrics != null) {\n-                    try {\n-                        queryMetrics.updateMetric(this.getMetric());\n-                    } catch (Exception e) {\n-                        log.error(e.getMessage());\n-                    }\n-                }\n-            }\n+\n+        // if not still waiting on a future, then process the result (or lack thereof)\n+        if (future == null) {\n+          if (null == o) {\n+            log.debug(\"Null result encountered, no more results\");\n+            this.finished = true;\n+            break;\n+          }\n+          resultList.add(o);\n+          if (this.logic.getPageByteTrigger() > 0) {\n+            currentPageBytes += ObjectSizeOf.Sizer.getObjectSize(o);\n+          }\n+          currentPageCount++;\n+          numResults++;\n         }\n-        \n-        if (logic != null) {\n-            try {\n-                addNDC();\n-                logic.close();\n-            } catch (Exception e) {\n-                log.error(\"Exception occurred while closing query logic; may be innocuous if scanners were running.\", e);\n-            } finally {\n-                removeNDC();\n-            }\n+\n+        testForUncaughtException(resultList.size());\n+      }\n+\n+      // if the last hasNext() call failed, then we would catch the exception here\n+      testForUncaughtException(resultList.size());\n+\n+      // Update the metric\n+      long now = System.currentTimeMillis();\n+      this.getMetric().addPageTime(currentPageCount, now - pageStartTime, pageStartTime, now);\n+      this.lastPageNumber++;\n+      if (!resultList.isEmpty()) {\n+        this.getMetric().setLifecycle(QueryMetric.Lifecycle.RESULTS);\n+      }\n+    } catch (Exception e) {\n+      log.error(e.getMessage(), e);\n+      this.getMetric().setError(e);\n+      throw e;\n+    } finally {\n+      // update AbstractRunningQuery.lastUsed in case this operation took a long time\n+      touch();\n+      removeNDC();\n+\n+      if (this.queryMetrics != null) {\n+        try {\n+          this.queryMetrics.updateMetric(this.getMetric());\n+        } catch (Exception e) {\n+          log.error(e.getMessage(), e);\n         }\n+      }\n     }\n-    \n-    @Override\n-    public long getLastPageNumber() {\n-        return this.lastPageNumber;\n-    }\n-    \n-    @Override\n-    public String toString() {\n-        \n-        String host = System.getProperty(\"jboss.host.name\");\n-        \n-        return new StringBuilder().append(\"host:\").append(host).append(\", id:\").append(this.getSettings().getId()).append(\", query:\")\n-                        .append(StringEscapeUtils.escapeHtml(this.getSettings().getQuery())).append(\", auths:\")\n-                        .append(this.getSettings().getQueryAuthorizations()).append(\", user:\").append(this.getSettings().getOwner()).append(\", queryLogic:\")\n-                        .append(this.getSettings().getQueryLogicName()).append(\", name:\").append(this.getSettings().getQueryName()).append(\", pagesize:\")\n-                        .append(this.getSettings().getPagesize()).append(\", begin:\").append(this.getSettings().getBeginDate()).append(\", end:\")\n-                        .append(this.getSettings().getEndDate()).append(\", expiration:\").append(this.getSettings().getExpirationDate()).append(\", params: \")\n-                        .append(this.getSettings().getParameters()).append(\", callTime: \")\n-                        .append((this.getTimeOfCurrentCall() == 0) ? 0 : System.currentTimeMillis() - this.getTimeOfCurrentCall()).toString();\n-        \n-    }\n-    \n-    /**\n-     * Sets {@link TInfo} for this query as an indication that the query is being traced. This trace info is also used to continue a trace across different\n-     * thread boundaries.\n-     */\n-    public void setTraceInfo(TInfo traceInfo) {\n-        this.traceInfo = traceInfo;\n+    if (resultList.isEmpty()) {\n+      return new ResultsPage();\n+    } else {\n+      return new ResultsPage(resultList,\n+          ((hitPageByteTrigger || hitPageTimeTrigger) ? ResultsPage.Status.PARTIAL : ResultsPage.Status.COMPLETE));\n     }\n-    \n-    /**\n-     * Gets the {@link TInfo} associated with this query, if any. If the query is not being traced, then {@code null} is returned. Callers can continue a trace\n-     * on a different thread by calling {@link org.apache.accumulo.core.trace.Trace#trace(TInfo, String)} with the info returned here, and then interacting with\n-     * the returned {@link org.apache.accumulo.core.trace.Span}.\n-     * \n-     * @return the {@link TInfo} associated with this query, if any\n-     */\n-    public TInfo getTraceInfo() {\n-        return traceInfo;\n-    }\n-    \n-    public QueryMetricsBean getQueryMetrics() {\n-        return queryMetrics;\n+  }\n+\n+  public void cancel() {\n+    this.canceled = true;\n+    // save off the future as it could be removed at any time\n+    Future<Object> future = this.future;\n+    // cancel the future if we have one\n+    if (future != null) {\n+      future.cancel(true);\n     }\n-    \n-    public void setQueryMetrics(QueryMetricsBean queryMetrics) {\n-        if (logic != null && logic.getCollectQueryMetrics() == true) {\n-            this.queryMetrics = queryMetrics;\n+\n+    // change status to cancelled\n+    this.getMetric().setLifecycle(QueryMetric.Lifecycle.CANCELLED);\n+  }\n+\n+  public boolean isFinished() {\n+    return finished;\n+  }\n+\n+  public boolean isCanceled() {\n+    return canceled;\n+  }\n+\n+  public Connector getConnection() {\n+    return connection;\n+  }\n+\n+  public AccumuloConnectionFactory.Priority getConnectionPriority() {\n+    return connectionPriority;\n+  }\n+\n+  public QueryLogic<?> getLogic() {\n+    return logic;\n+  }\n+\n+  public Query getSettings() {\n+    return settings;\n+  }\n+\n+  public TransformIterator getTransformIterator() {\n+    return iter;\n+  }\n+\n+  protected Set<Authorizations> getCalculatedAuths() {\n+    return calculatedAuths;\n+  }\n+\n+  protected QueryPredictor getPredictor() {\n+    return this.predictor;\n+  }\n+\n+  public void setPredictor(QueryPredictor predictor) {\n+    this.predictor = predictor;\n+  }\n+\n+  protected void applyPrediction(String context) {\n+    if (getPredictor() != null) {\n+      try {\n+        Set<Prediction> predictions = getPredictor().predict(this.getMetric());\n+        if (predictions != null) {\n+          // now we have a predictions, lets broadcast\n+          log.info(\"Model predictions: \" + predictions);\n+          context = (context == null ? \"\" : context + ' ');\n+          for (Prediction prediction : predictions) {\n+            // append the context to the predictions\n+            this.getMetric().addPrediction(new Prediction(context + prediction.getName(), prediction.getPrediction()));\n+          }\n         }\n+      } catch (Exception e) {\n+        log.warn(\"Unable to apply query prediction\", e);\n+      }\n     }\n-    \n-    /**\n-     * An interface used to force returning from a next call within a running query.\n-     */\n-    public interface RunningQueryTiming {\n-        boolean shouldReturnPartialResults(int pageSize, int maxPageSize, long timeInCall);\n+  }\n+\n+  public void closeConnection(AccumuloConnectionFactory factory) throws Exception {\n+    this.getMetric().setLifecycle(BaseQueryMetric.Lifecycle.CLOSED);\n+\n+    if (iter != null && iter.getTransformer() instanceof WritesResultCardinalities) {\n+      ((WritesResultCardinalities) iter.getTransformer()).writeResultCardinalities();\n     }\n-    \n-    /**\n-     * A noop implementation of the running query timing interface.\n-     */\n-    public static class RunningQueryTimingNoOp implements RunningQueryTiming {\n-        public boolean shouldReturnPartialResults(int pageSize, int maxPageSize, long timeInCall) {\n-            return false;\n+\n+    if (connection != null) {\n+      try {\n+        factory.returnConnection(connection);\n+        connection = null;\n+      } finally {\n+        // only push metrics if this RunningQuery was initialized\n+        if (this.queryMetrics != null) {\n+          try {\n+            queryMetrics.updateMetric(this.getMetric());\n+          } catch (Exception e) {\n+            log.error(e.getMessage());\n+          }\n         }\n+      }\n     }\n-    \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see java.lang.Runnable#run()\n-     */\n-    @Override\n-    public void run() {\n-        // TODO Auto-generated method stub\n-        \n+\n+    if (logic != null) {\n+      try {\n+        addNDC();\n+        logic.close();\n+      } catch (Exception e) {\n+        log.error(\"Exception occurred while closing query logic; may be innocuous if scanners were running.\", e);\n+      } finally {\n+        removeNDC();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public long getLastPageNumber() {\n+    return this.lastPageNumber;\n+  }\n+\n+  @Override\n+  public String toString() {\n+\n+    String host = System.getProperty(\"jboss.host.name\");\n+\n+    return new StringBuilder().append(\"host:\").append(host).append(\", id:\").append(this.getSettings().getId())\n+        .append(\", query:\")\n+        .append(StringEscapeUtils.escapeHtml(this.getSettings().getQuery())).append(\", auths:\")\n+        .append(this.getSettings().getQueryAuthorizations()).append(\", user:\").append(this.getSettings().getOwner())\n+        .append(\", queryLogic:\")\n+        .append(this.getSettings().getQueryLogicName()).append(\", name:\").append(this.getSettings().getQueryName())\n+        .append(\", pagesize:\")\n+        .append(this.getSettings().getPagesize()).append(\", begin:\").append(this.getSettings().getBeginDate())\n+        .append(\", end:\")\n+        .append(this.getSettings().getEndDate()).append(\", expiration:\").append(this.getSettings().getExpirationDate())\n+        .append(\", params: \")\n+        .append(this.getSettings().getParameters()).append(\", callTime: \")\n+        .append((this.getTimeOfCurrentCall() == 0) ? 0 : System.currentTimeMillis() - this.getTimeOfCurrentCall())\n+        .toString();\n+\n+  }\n+\n+  /**\n+   * Sets {@link TInfo} for this query as an indication that the query is being traced. This trace info is also used to continue a trace across different\n+   * thread boundaries.\n+   */\n+  public void setTraceInfo(TInfo traceInfo) {\n+    this.traceInfo = traceInfo;\n+  }\n+\n+  /**\n+   * Gets the {@link TInfo} associated with this query, if any. If the query is not being traced, then {@code null} is returned. Callers can continue a trace\n+   * on a different thread by calling {@link org.apache.accumulo.core.trace.Trace#trace(TInfo, String)} with the info returned here, and then interacting with\n+   * the returned {@link org.apache.accumulo.core.trace.Span}.\n+   *\n+   * @return the {@link TInfo} associated with this query, if any\n+   */\n+  public TInfo getTraceInfo() {\n+    return traceInfo;\n+  }\n+\n+  public QueryMetricsBean getQueryMetrics() {\n+    return queryMetrics;\n+  }\n+\n+  public void setQueryMetrics(QueryMetricsBean queryMetrics) {\n+    if (logic != null && logic.getCollectQueryMetrics() == true) {\n+      this.queryMetrics = queryMetrics;\n     }\n-    \n-    private void testForUncaughtException(int numResults) throws QueryException {\n-        QueryUncaughtExceptionHandler handler = settings.getUncaughtExceptionHandler();\n-        if (handler != null) {\n-            if (handler.getThrowable() != null) {\n-                if (numResults > 0) {\n-                    log.warn(\"Exception with Partial Results: resultList.getResults().size() is \" + numResults + \", and there was an UncaughtException:\"\n-                                    + handler.getThrowable() + \" in thread \" + handler.getThread());\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Throwing:\" + handler.getThrowable() + \" for query with no results\");\n-                    }\n-                }\n-                if (handler.getThrowable() instanceof QueryException) {\n-                    throw ((QueryException) handler.getThrowable());\n-                }\n-                throw new QueryException(handler.getThrowable());\n-            }\n+  }\n+\n+  /**\n+   * An interface used to force returning from a next call within a running query.\n+   */\n+  public interface RunningQueryTiming {\n+    boolean shouldReturnPartialResults(int pageSize, int maxPageSize, long timeInCall);\n+  }\n+\n+  /**\n+   * A noop implementation of the running query timing interface.\n+   */\n+  public static class RunningQueryTimingNoOp implements RunningQueryTiming {\n+    public boolean shouldReturnPartialResults(int pageSize, int maxPageSize, long timeInCall) {\n+      return false;\n+    }\n+  }\n+\n+  /*\n+   * (non-Javadoc)\n+   *\n+   * @see java.lang.Runnable#run()\n+   */\n+  @Override\n+  public void run() {\n+    // TODO Auto-generated method stub\n+\n+  }\n+\n+  private void testForUncaughtException(int numResults) throws QueryException {\n+    QueryUncaughtExceptionHandler handler = settings.getUncaughtExceptionHandler();\n+    if (handler != null) {\n+      if (handler.getThrowable() != null) {\n+        if (numResults > 0) {\n+          log.warn(\"Exception with Partial Results: resultList.getResults().size() is \" + numResults +\n+              \", and there was an UncaughtException:\"\n+              + handler.getThrowable() + \" in thread \" + handler.getThread());\n+        } else {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Throwing:\" + handler.getThrowable() + \" for query with no results\");\n+          }\n+        }\n+        if (handler.getThrowable() instanceof QueryException) {\n+          throw ((QueryException) handler.getThrowable());\n         }\n+        throw new QueryException(handler.getThrowable());\n+      }\n     }\n+  }\n }\n",
            "diff_size": 769
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "23",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/138/RunningQuery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/138/RunningQuery.java\nindex b6a8c4b238b..bf61389ecd4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/138/RunningQuery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/138/RunningQuery.java\n@@ -86,14 +86,12 @@ public class RunningQuery extends AbstractRunningQuery implements Runnable {\n     }\n     \n     public RunningQuery(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority, QueryLogic<?> logic, Query settings,\n-                    String methodAuths, Principal principal, RunningQueryTiming timing, ExecutorService executor, QueryMetricFactory metricFactory)\n-                    throws Exception {\n+                    String methodAuths, Principal principal, RunningQueryTiming timing, ExecutorService executor, QueryMetricFactory metricFactory) throws Exception {\n         this(queryMetrics, connection, priority, logic, settings, methodAuths, principal, timing, executor, null, metricFactory);\n     }\n     \n     public RunningQuery(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority, QueryLogic<?> logic, Query settings,\n-                    String methodAuths, Principal principal, RunningQueryTiming timing, ExecutorService executor, QueryPredictor predictor,\n-                    QueryMetricFactory metricFactory) throws Exception {\n+                    String methodAuths, Principal principal, RunningQueryTiming timing, ExecutorService executor, QueryPredictor predictor, QueryMetricFactory metricFactory) throws Exception {\n         super(metricFactory);\n         if (logic != null && logic.getCollectQueryMetrics()) {\n             this.queryMetrics = queryMetrics;\n@@ -128,8 +126,7 @@ public class RunningQuery extends AbstractRunningQuery implements Runnable {\n     }\n     \n     public static RunningQuery createQueryWithAuthorizations(QueryMetricsBean queryMetrics, Connector connection, AccumuloConnectionFactory.Priority priority,\n-                    QueryLogic<?> logic, Query settings, String methodAuths, RunningQueryTiming timing, ExecutorService executor, QueryPredictor predictor,\n-                    QueryMetricFactory metricFactory) throws Exception {\n+                    QueryLogic<?> logic, Query settings, String methodAuths, RunningQueryTiming timing, ExecutorService executor, QueryPredictor predictor, QueryMetricFactory metricFactory) throws Exception {\n         RunningQuery runningQuery = new RunningQuery(queryMetrics, connection, priority, logic, settings, methodAuths, null, timing, executor, predictor,\n                         metricFactory);\n         runningQuery.calculatedAuths = Collections.singleton(new Authorizations(methodAuths));\n@@ -540,4 +537,4 @@ public class RunningQuery extends AbstractRunningQuery implements Runnable {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "23",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "23",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}