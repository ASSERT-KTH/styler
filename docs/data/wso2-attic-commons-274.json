{
    "project_name": "wso2-attic-commons",
    "error_id": "274",
    "information": {
        "errors": [
            {
                "line": "246",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 133).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                if (age != null && now-age > _conn._mexTtl) {\n                    if (_instances.get(id) != null) {\n                        __log.warn(\"Discarding in-memory instance \"+id+\" because it exceeded its time-to-live: \"+_instances.get(id));\n                    }\n                    _instances.remove(id);\n                    _instancesAge.remove(id);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "246",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/274/ProcessDaoImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/274/ProcessDaoImpl.java\nindex 4132b402915..e230074024c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/274/ProcessDaoImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/274/ProcessDaoImpl.java\n@@ -16,6 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n+\n package org.apache.ode.bpel.memdao;\n \n import java.io.Serializable;\n@@ -43,212 +44,217 @@ import org.apache.ode.bpel.dao.ProcessInstanceDAO;\n  * A very simple, in-memory implementation of the {@link ProcessDAO} interface.\n  */\n class ProcessDaoImpl extends DaoBaseImpl implements ProcessDAO {\n-    private static final Log __log = LogFactory.getLog(ProcessDaoImpl.class);\n-\n-    private QName _processId;\n-    private QName _type;\n-    private long _version;\n-    final Map<String, CorrelatorDaoImpl> _correlators = new ConcurrentHashMap<String, CorrelatorDaoImpl>();\n-    protected final Map<Long, ProcessInstanceDAO> _instances = new ConcurrentHashMap<Long, ProcessInstanceDAO>();\n-    protected final Map<Long, Long> _instancesAge = new ConcurrentHashMap<Long, Long>();\n-    protected final Map<Integer, PartnerLinkDAO> _plinks = new ConcurrentHashMap<Integer, PartnerLinkDAO>();\n-    private Map<QName, ProcessDaoImpl> _store;\n-    private BpelDAOConnectionImpl _conn;\n-    private int _executionCount = 0;\n-    private Collection<Long> _instancesToRemove = new ConcurrentLinkedQueue<Long>();\n-    private volatile long _lastRemoval = 0;\n-\n-    private String _guid;\n-\n-    public ProcessDaoImpl(BpelDAOConnectionImpl conn, Map<QName, ProcessDaoImpl> store,\n-                          QName processId, QName type, String guid, long version) {\n-        if (__log.isDebugEnabled()) {\n-            __log.debug(\"Creating ProcessDao object for process \\\"\" + processId + \"\\\".\");\n-        }\n-\n-        _guid = guid;\n-        _conn = conn;\n-        _store = store;\n-        _processId = processId;\n-        _type = type;\n-        _version = version;\n+  private static final Log __log = LogFactory.getLog(ProcessDaoImpl.class);\n+\n+  private QName _processId;\n+  private QName _type;\n+  private long _version;\n+  final Map<String, CorrelatorDaoImpl> _correlators = new ConcurrentHashMap<String, CorrelatorDaoImpl>();\n+  protected final Map<Long, ProcessInstanceDAO> _instances = new ConcurrentHashMap<Long, ProcessInstanceDAO>();\n+  protected final Map<Long, Long> _instancesAge = new ConcurrentHashMap<Long, Long>();\n+  protected final Map<Integer, PartnerLinkDAO> _plinks = new ConcurrentHashMap<Integer, PartnerLinkDAO>();\n+  private Map<QName, ProcessDaoImpl> _store;\n+  private BpelDAOConnectionImpl _conn;\n+  private int _executionCount = 0;\n+  private Collection<Long> _instancesToRemove = new ConcurrentLinkedQueue<Long>();\n+  private volatile long _lastRemoval = 0;\n+\n+  private String _guid;\n+\n+  public ProcessDaoImpl(BpelDAOConnectionImpl conn, Map<QName, ProcessDaoImpl> store,\n+                        QName processId, QName type, String guid, long version) {\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(\"Creating ProcessDao object for process \\\"\" + processId + \"\\\".\");\n     }\n \n-    public Serializable getId() {\n-        return _guid;\n+    _guid = guid;\n+    _conn = conn;\n+    _store = store;\n+    _processId = processId;\n+    _type = type;\n+    _version = version;\n+  }\n+\n+  public Serializable getId() {\n+    return _guid;\n+  }\n+\n+  public QName getProcessId() {\n+    return _processId;\n+  }\n+\n+  public CorrelatorDAO getCorrelator(String cid) {\n+    CorrelatorDAO ret = _correlators.get(cid);\n+    if (ret == null) {\n+      throw new IllegalArgumentException(\"no such correlator: \" + cid);\n     }\n+    return ret;\n+  }\n \n-    public QName getProcessId() {\n-        return _processId;\n-    }\n+  public Collection<CorrelatorDAO> getCorrelators() {\n+    // Note: _correlators.values() is a Collection<CorrealatorDaoImpl>. We can't just return this object\n+    // since Collection<CorrelatorDAO> is /not/ assignment compatible with Collection<CorrelatorDaoImpl>.\n+    // However, a immutable Collection<CorrelationDAO> is assignment compatible with Collection<CorrelatorDaoImpl>,\n+    // but.... we need to introduce some ambiguity into the type hierarchy so that Java will infer the correct type.\n \n-    public CorrelatorDAO getCorrelator(String cid) {\n-        CorrelatorDAO ret = _correlators.get(cid);\n-        if (ret == null) {\n-            throw new IllegalArgumentException(\"no such correlator: \" + cid);\n-        }\n-        return ret;\n-    }\n+    // Make an ambiguous collection.\n+    Collection<? extends CorrelatorDAO> foo = _correlators.values();\n \n-    public Collection<CorrelatorDAO> getCorrelators() {\n-        // Note: _correlators.values() is a Collection<CorrealatorDaoImpl>. We can't just return this object\n-        // since Collection<CorrelatorDAO> is /not/ assignment compatible with Collection<CorrelatorDaoImpl>.\n-        // However, a immutable Collection<CorrelationDAO> is assignment compatible with Collection<CorrelatorDaoImpl>,\n-        // but.... we need to introduce some ambiguity into the type hierarchy so that Java will infer the correct type.\n+    // In order to get a collection of the super-type from a sub-type we must make the collection read-only.\n+    return Collections.unmodifiableCollection(foo);\n+  }\n \n-        // Make an ambiguous collection.\n-        Collection<? extends CorrelatorDAO> foo =  _correlators.values();\n-\n-        // In order to get a collection of the super-type from a sub-type we must make the collection read-only.\n-        return Collections.unmodifiableCollection(foo);\n+  public void removeRoutes(String routeId, ProcessInstanceDAO target) {\n+    for (CorrelatorDAO correlatorDAO : _correlators.values()) {\n+      correlatorDAO.removeRoutes(routeId, target);\n     }\n-\n-    public void removeRoutes(String routeId, ProcessInstanceDAO target) {\n-        for (CorrelatorDAO correlatorDAO : _correlators.values()) {\n-            correlatorDAO.removeRoutes(routeId, target);\n+  }\n+\n+  public ProcessInstanceDAO createInstance(CorrelatorDAO correlator) {\n+    final ProcessInstanceDaoImpl newInstance = new ProcessInstanceDaoImpl(_conn, this, correlator);\n+    _conn.defer(new Runnable() {\n+      public void run() {\n+        _instances.put(newInstance.getInstanceId(), newInstance);\n+        _instancesAge.put(newInstance.getInstanceId(), System.currentTimeMillis());\n+      }\n+    });\n+\n+    discardOldInstances();\n+\n+    // Removing right away on rollback\n+    final Long iid = newInstance.getInstanceId();\n+    _conn.onRollback(new Runnable() {\n+      public void run() {\n+        _instances.remove(iid);\n+        _instancesAge.remove(iid);\n+      }\n+    });\n+\n+    _executionCount++;\n+    return newInstance;\n+  }\n+\n+  public ProcessInstanceDAO getInstance(Long instanceId) {\n+    return _instances.get(instanceId);\n+  }\n+\n+  public Collection<ProcessInstanceDAO> findInstance(CorrelationKey key) {\n+    ArrayList<ProcessInstanceDAO> result = new ArrayList<ProcessInstanceDAO>();\n+    for (ProcessInstanceDAO instance : _instances.values()) {\n+      for (CorrelationSetDAO corrSet : instance.getCorrelationSets()) {\n+        if (corrSet.getValue().equals(key)) {\n+          result.add(instance);\n         }\n+      }\n     }\n+    return result;\n+  }\n \n-    public ProcessInstanceDAO createInstance(CorrelatorDAO correlator) {\n-        final ProcessInstanceDaoImpl newInstance = new ProcessInstanceDaoImpl(_conn, this, correlator);\n-        _conn.defer(new Runnable() {\n-            public void run() {\n-                _instances.put(newInstance.getInstanceId(), newInstance);\n-                _instancesAge.put(newInstance.getInstanceId(), System.currentTimeMillis());\n-            }\n-        });\n-\n-        discardOldInstances();\n-\n-        // Removing right away on rollback\n-        final Long iid = newInstance.getInstanceId();\n-        _conn.onRollback(new Runnable() {\n-            public void run() {\n-                _instances.remove(iid);\n-                _instancesAge.remove(iid);\n-            }\n-        });\n-\n-        _executionCount++;\n-        return newInstance;\n-    }\n-\n-    public ProcessInstanceDAO getInstance(Long instanceId) {\n-        return _instances.get(instanceId);\n-    }\n-\n-    public Collection<ProcessInstanceDAO> findInstance(CorrelationKey key) {\n-        ArrayList<ProcessInstanceDAO> result = new ArrayList<ProcessInstanceDAO>();\n-        for (ProcessInstanceDAO instance : _instances.values()) {\n-            for (CorrelationSetDAO corrSet : instance.getCorrelationSets()) {\n-                if (corrSet.getValue().equals(key)) result.add(instance);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    public void instanceCompleted(ProcessInstanceDAO instance) {\n-        // Cleaning up\n-        if (__log.isDebugEnabled())\n-          __log.debug(\"Removing completed process instance \" + instance.getInstanceId() + \" from in-memory store.\");\n-        _instancesAge.remove(instance.getInstanceId());\n-        ProcessInstanceDAO removed = _instances.remove(instance.getInstanceId());\n-        if (removed == null) {\n-            // Checking for leftover instances that should be removed\n-            ArrayList<Long> removals = new ArrayList<Long>(_instancesToRemove);\n-            for (Long iid : removals) {\n-                _instances.remove(iid);\n-            }\n-            _instancesToRemove.removeAll(removals);\n-\n-            // The instance can't be found probably because the transaction isn't committed yet and\n-            // it doesn't exist. Saving its id for later cleanup.\n-            _instancesToRemove.add(instance.getInstanceId());\n-        }\n-    }\n-\n-    public void deleteProcessAndRoutes() {\n-        _store.remove(_processId);\n-    }\n-\n-    public long getVersion() {\n-        return _version;\n-    }\n-\n-    public String getDeployer() {\n-        return \"nobody\";\n-    }\n-\n-    public QName getType() {\n-        return _type;\n+  public void instanceCompleted(ProcessInstanceDAO instance) {\n+    // Cleaning up\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(\"Removing completed process instance \" + instance.getInstanceId() + \" from in-memory store.\");\n     }\n-\n-    public CorrelatorDAO addCorrelator(String correlator) {\n-        CorrelatorDaoImpl corr = new CorrelatorDaoImpl(correlator, _conn);\n-        _correlators.put(corr.getCorrelatorId(), corr);\n-        return corr;\n-    }\n-\n-    /**\n-     * Nothing to do.\n-     */\n-    public void update() {\n-        //TODO Check requirement for persisting.\n+    _instancesAge.remove(instance.getInstanceId());\n+    ProcessInstanceDAO removed = _instances.remove(instance.getInstanceId());\n+    if (removed == null) {\n+      // Checking for leftover instances that should be removed\n+      ArrayList<Long> removals = new ArrayList<Long>(_instancesToRemove);\n+      for (Long iid : removals) {\n+        _instances.remove(iid);\n+      }\n+      _instancesToRemove.removeAll(removals);\n+\n+      // The instance can't be found probably because the transaction isn't committed yet and\n+      // it doesn't exist. Saving its id for later cleanup.\n+      _instancesToRemove.add(instance.getInstanceId());\n     }\n-\n-    public int getNumInstances() {\n-        // Instances are removed after execution, using a counter instead\n-        return _executionCount;\n-    }\n-\n-    public ProcessInstanceDAO getInstanceWithLock(Long iid) {\n-        return getInstance(iid);\n-    }\n-\n-    public int getActivityFailureCount() {\n-        return 0;\n+  }\n+\n+  public void deleteProcessAndRoutes() {\n+    _store.remove(_processId);\n+  }\n+\n+  public long getVersion() {\n+    return _version;\n+  }\n+\n+  public String getDeployer() {\n+    return \"nobody\";\n+  }\n+\n+  public QName getType() {\n+    return _type;\n+  }\n+\n+  public CorrelatorDAO addCorrelator(String correlator) {\n+    CorrelatorDaoImpl corr = new CorrelatorDaoImpl(correlator, _conn);\n+    _correlators.put(corr.getCorrelatorId(), corr);\n+    return corr;\n+  }\n+\n+  /**\n+   * Nothing to do.\n+   */\n+  public void update() {\n+    //TODO Check requirement for persisting.\n+  }\n+\n+  public int getNumInstances() {\n+    // Instances are removed after execution, using a counter instead\n+    return _executionCount;\n+  }\n+\n+  public ProcessInstanceDAO getInstanceWithLock(Long iid) {\n+    return getInstance(iid);\n+  }\n+\n+  public int getActivityFailureCount() {\n+    return 0;\n+  }\n+\n+  public Date getActivityFailureDateTime() {\n+    return null;\n+  }\n+\n+  public String getGuid() {\n+    return _guid;\n+  }\n+\n+  public void setGuid(String guid) {\n+    _guid = guid;\n+  }\n+\n+  public Collection<ProcessInstanceDAO> getActiveInstances() {\n+    ArrayList<ProcessInstanceDAO> pis = new ArrayList<ProcessInstanceDAO>();\n+    for (ProcessInstanceDAO processInstanceDAO : _instances.values()) {\n+      if (processInstanceDAO.getState() == ProcessState.STATE_ACTIVE) {\n+        pis.add(processInstanceDAO);\n+      }\n     }\n-\n-    public Date getActivityFailureDateTime() {\n-        return null;\n-    }\n-\n-    public String getGuid() {\n-        return _guid;\n-    }\n-\n-    public void setGuid(String guid) {\n-        _guid = guid;\n-    }\n-\n-    public Collection<ProcessInstanceDAO> getActiveInstances() {\n-        ArrayList<ProcessInstanceDAO> pis = new ArrayList<ProcessInstanceDAO>();\n-        for (ProcessInstanceDAO processInstanceDAO : _instances.values()) {\n-            if (processInstanceDAO.getState() == ProcessState.STATE_ACTIVE)\n-                pis.add(processInstanceDAO);\n-        }\n-        return pis;\n-    }\n-\n-    /**\n-     * Discard in-memory instances that exceeded their time-to-live to prevent memory leaks\n-     */\n-    void discardOldInstances() {\n-        long now = System.currentTimeMillis();\n-        if (now > _lastRemoval + (_conn._mexTtl/10)) {\n-            _lastRemoval = now;\n-            Object[] oldInstances = _instancesAge.keySet().toArray();\n-            for (int i=oldInstances.length-1; i>=0; i--) {\n-                Long id = (Long) oldInstances[i];\n-                Long age = _instancesAge.get(id);\n-                if (age != null && now-age > _conn._mexTtl) {\n-                    if (_instances.get(id) != null) {\n-                        __log.warn(\"Discarding in-memory instance \"+id+\" because it exceeded its time-to-live: \"+_instances.get(id));\n-                    }\n-                    _instances.remove(id);\n-                    _instancesAge.remove(id);\n-                }\n-            }\n+    return pis;\n+  }\n+\n+  /**\n+   * Discard in-memory instances that exceeded their time-to-live to prevent memory leaks\n+   */\n+  void discardOldInstances() {\n+    long now = System.currentTimeMillis();\n+    if (now > _lastRemoval + (_conn._mexTtl / 10)) {\n+      _lastRemoval = now;\n+      Object[] oldInstances = _instancesAge.keySet().toArray();\n+      for (int i = oldInstances.length - 1; i >= 0; i--) {\n+        Long id = (Long) oldInstances[i];\n+        Long age = _instancesAge.get(id);\n+        if (age != null && now - age > _conn._mexTtl) {\n+          if (_instances.get(id) != null) {\n+            __log.warn(\n+              \"Discarding in-memory instance \" + id + \" because it exceeded its time-to-live: \" + _instances.get(id));\n+          }\n+          _instances.remove(id);\n+          _instancesAge.remove(id);\n         }\n+      }\n     }\n+  }\n }\n",
            "diff_size": 303
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "63",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 145).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "245",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/274/ProcessDaoImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/274/ProcessDaoImpl.java\nindex 4132b402915..094b8a4a656 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/274/ProcessDaoImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/274/ProcessDaoImpl.java\n@@ -60,9 +60,8 @@ class ProcessDaoImpl extends DaoBaseImpl implements ProcessDAO {\n \n     private String _guid;\n \n-    public ProcessDaoImpl(BpelDAOConnectionImpl conn, Map<QName, ProcessDaoImpl> store,\n-                          QName processId, QName type, String guid, long version) {\n-        if (__log.isDebugEnabled()) {\n+    public ProcessDaoImpl(BpelDAOConnectionImpl conn, Map<QName, ProcessDaoImpl> store, QName processId, QName type, String guid, long version) {\n+    if (__log.isDebugEnabled()) {\n             __log.debug(\"Creating ProcessDao object for process \\\"\" + processId + \"\\\".\");\n         }\n \n@@ -251,4 +250,4 @@ class ProcessDaoImpl extends DaoBaseImpl implements ProcessDAO {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "246",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "246",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 133).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}