{
    "project_name": "graphfoundation-ongdb",
    "error_id": "1128",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "66",
                    "column": "20",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "66",
                    "column": "50",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "84",
                    "column": "20",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "84",
                    "column": "29",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "100",
                    "column": "36",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "126",
                    "column": "32",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "126",
                    "column": "56",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "138",
                    "column": "28",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "138",
                    "column": "49",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "140",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "140",
                    "column": "22",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "144",
                    "column": "5",
                    "severity": "error",
                    "message": "'}' at column 5 should be alone on a line.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.RightCurlyCheck"
                },
                {
                    "line": "146",
                    "column": "39",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "146",
                    "column": "60",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "166",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "166",
                    "column": "33",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "176",
                    "column": "59",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "176",
                    "column": "78",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "208",
                    "column": "24",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "208",
                    "column": "33",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "210",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "210",
                    "column": "18",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "214",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "214",
                    "column": "48",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "278",
                    "column": "36",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "278",
                    "column": "58",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "288",
                    "column": "36",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "288",
                    "column": "101",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "296",
                    "column": "15",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "301",
                    "column": "25",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "301",
                    "column": "52",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "303",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "303",
                    "column": "26",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1128/ExecutingQuery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1128/ExecutingQuery.java\nindex b662a1810a5..51d8f8df748 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1128/ExecutingQuery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1128/ExecutingQuery.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.kernel.api.query;\n \n import org.apache.commons.lang3.builder.ToStringBuilder;\n@@ -46,259 +47,264 @@ import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n  */\n public class ExecutingQuery\n {\n-    private static final AtomicLongFieldUpdater<ExecutingQuery> WAIT_TIME =\n-            newUpdater( ExecutingQuery.class, \"waitTimeNanos\" );\n-    private final long queryId;\n-    private final LockTracer lockTracer = this::waitForLock;\n-    private final PageCursorCounters pageCursorCounters;\n-    private final String username;\n-    private final ClientConnectionInfo clientConnection;\n-    private final String queryText;\n-    private final MapValue queryParameters;\n-    private final long startTimeNanos;\n-    private final long startTimestampMillis;\n-    /** Uses write barrier of {@link #status}. */\n-    private long planningDoneNanos;\n-    private final long threadExecutingTheQueryId;\n-    @SuppressWarnings( {\"unused\", \"FieldCanBeLocal\"} )\n-    private final String threadExecutingTheQueryName;\n-    private final LongSupplier activeLockCount;\n-    private final long initialActiveLocks;\n-    private final SystemNanoClock clock;\n-    private final CpuClock cpuClock;\n-    private final HeapAllocation heapAllocation;\n-    private final long cpuTimeNanosWhenQueryStarted;\n-    private final long heapAllocatedBytesWhenQueryStarted;\n-    private final Map<String,Object> transactionAnnotationData;\n-    /** Uses write barrier of {@link #status}. */\n-    private PlannerInfo plannerInfo;\n-    private volatile ExecutingQueryStatus status = SimpleState.planning();\n-    /** Updated through {@link #WAIT_TIME} */\n-    @SuppressWarnings( \"unused\" )\n-    private volatile long waitTimeNanos;\n-\n-    public ExecutingQuery(\n-            long queryId,\n-            ClientConnectionInfo clientConnection,\n-            String username,\n-            String queryText,\n-            MapValue queryParameters,\n-            Map<String,Object> transactionAnnotationData,\n-            LongSupplier activeLockCount,\n-            PageCursorCounters pageCursorCounters,\n-            long threadExecutingTheQueryId,\n-            String threadExecutingTheQueryName,\n-            SystemNanoClock clock,\n-            CpuClock cpuClock,\n-            HeapAllocation heapAllocation )\n-    {\n-        // Capture timestamps first\n-        this.cpuTimeNanosWhenQueryStarted = cpuClock.cpuTimeNanos( threadExecutingTheQueryId );\n-        this.startTimeNanos = clock.nanos();\n-        this.startTimestampMillis = clock.millis();\n-        // then continue with assigning fields\n-        this.queryId = queryId;\n-        this.clientConnection = clientConnection;\n-        this.pageCursorCounters = pageCursorCounters;\n-        this.username = username;\n-        this.queryText = queryText;\n-        this.queryParameters = queryParameters;\n-        this.transactionAnnotationData = transactionAnnotationData;\n-        this.activeLockCount = activeLockCount;\n-        this.initialActiveLocks = activeLockCount.getAsLong();\n-        this.threadExecutingTheQueryId = threadExecutingTheQueryId;\n-        this.threadExecutingTheQueryName = threadExecutingTheQueryName;\n-        this.cpuClock = cpuClock;\n-        this.heapAllocation = heapAllocation;\n-        this.clock = clock;\n-        this.heapAllocatedBytesWhenQueryStarted = heapAllocation.allocatedBytes( this.threadExecutingTheQueryId );\n-    }\n-\n-    // update state\n-\n-    public void planningCompleted( PlannerInfo plannerInfo )\n-    {\n-        this.plannerInfo = plannerInfo;\n-        this.planningDoneNanos = clock.nanos();\n-        this.status = SimpleState.running(); // write barrier - must be last\n-    }\n-\n-    public LockTracer lockTracer()\n-    {\n-        return lockTracer;\n-    }\n-\n-    public void waitsForQuery( ExecutingQuery child )\n-    {\n-        if ( child == null )\n-        {\n-            WAIT_TIME.addAndGet( this, status.waitTimeNanos( clock.nanos() ) );\n-            this.status = SimpleState.running();\n-        }\n-        else\n-        {\n-            this.status = new WaitingOnQuery( child, clock.nanos() );\n-        }\n-    }\n-\n-    // snapshot state\n-\n-    public QuerySnapshot snapshot()\n-    {\n-        // capture a consistent snapshot of the \"live\" state\n-        ExecutingQueryStatus status;\n-        long waitTimeNanos;\n-        long currentTimeNanos;\n-        long cpuTimeNanos;\n-        do\n-        {\n-            status = this.status; // read barrier, must be first\n-            waitTimeNanos = this.waitTimeNanos; // the reason for the retry loop: don't count the wait time twice\n-            cpuTimeNanos = cpuClock.cpuTimeNanos( threadExecutingTheQueryId );\n-            currentTimeNanos = clock.nanos(); // capture the time as close to the snapshot as possible\n-        }\n-        while ( this.status != status );\n-        // guarded by barrier - unused if status is planning, stable otherwise\n-        long planningDoneNanos = this.planningDoneNanos;\n-        // guarded by barrier - like planningDoneNanos\n-        PlannerInfo planner = status.isPlanning() ? null : this.plannerInfo;\n-        List<ActiveLock> waitingOnLocks = status.isWaitingOnLocks() ? status.waitingOnLocks() : Collections.emptyList();\n-        // activeLockCount is not atomic to capture, so we capture it after the most sensitive part.\n-        long totalActiveLocks = this.activeLockCount.getAsLong();\n-        // just needs to be captured at some point...\n-        long heapAllocatedBytes = heapAllocation.allocatedBytes( threadExecutingTheQueryId );\n-        PageCounterValues pageCounters = new PageCounterValues( pageCursorCounters );\n-\n-        // - at this point we are done capturing the \"live\" state, and can start computing the snapshot -\n-        long planningTimeNanos = (status.isPlanning() ? currentTimeNanos : planningDoneNanos) - startTimeNanos;\n-        long elapsedTimeNanos = currentTimeNanos - startTimeNanos;\n-        cpuTimeNanos -= cpuTimeNanosWhenQueryStarted;\n-        waitTimeNanos += status.waitTimeNanos( currentTimeNanos );\n-        // TODO: when we start allocating native memory as well during query execution,\n-        // we should have a tracer that keeps track of how much memory we have allocated for the query,\n-        // and get the value from that here.\n-        heapAllocatedBytes = heapAllocatedBytesWhenQueryStarted < 0 ? -1 : // mark that we were unable to measure\n-                heapAllocatedBytes - heapAllocatedBytesWhenQueryStarted;\n-\n-        return new QuerySnapshot(\n-                this,\n-                planner,\n-                pageCounters,\n-                NANOSECONDS.toMillis( planningTimeNanos ),\n-                NANOSECONDS.toMillis( elapsedTimeNanos ),\n-                cpuTimeNanos == 0 && cpuTimeNanosWhenQueryStarted == -1 ? -1 : NANOSECONDS.toMillis( cpuTimeNanos ),\n-                NANOSECONDS.toMillis( waitTimeNanos ),\n-                status.name(),\n-                status.toMap( currentTimeNanos ),\n-                waitingOnLocks,\n-                totalActiveLocks - initialActiveLocks,\n-                heapAllocatedBytes\n-        );\n-    }\n-\n-    // basic methods\n-\n-    @Override\n-    public boolean equals( Object o )\n-    {\n-        if ( this == o )\n-        {\n-            return true;\n-        }\n-        if ( o == null || getClass() != o.getClass() )\n-        {\n-            return false;\n-        }\n-\n-        ExecutingQuery that = (ExecutingQuery) o;\n-\n-        return queryId == that.queryId;\n-    }\n-\n-    @Override\n-    public int hashCode()\n-    {\n-        return (int) (queryId ^ (queryId >>> 32));\n-    }\n-\n-    @Override\n-    public String toString()\n-    {\n-        return ToStringBuilder.reflectionToString( this );\n-    }\n-\n-    // access stable state\n-\n-    public long internalQueryId()\n-    {\n-        return queryId;\n-    }\n-\n-    public String username()\n-    {\n-        return username;\n-    }\n-\n-    public String queryText()\n-    {\n-        return queryText;\n-    }\n-\n-    public MapValue queryParameters()\n-    {\n-        return queryParameters;\n-    }\n-\n-    public long startTimestampMillis()\n+  private static final AtomicLongFieldUpdater<ExecutingQuery> WAIT_TIME =\n+      newUpdater(ExecutingQuery.class, \"waitTimeNanos\");\n+  private final long queryId;\n+  private final LockTracer lockTracer = this::waitForLock;\n+  private final PageCursorCounters pageCursorCounters;\n+  private final String username;\n+  private final ClientConnectionInfo clientConnection;\n+  private final String queryText;\n+  private final MapValue queryParameters;\n+  private final long startTimeNanos;\n+  private final long startTimestampMillis;\n+  /**\n+   * Uses write barrier of {@link #status}.\n+   */\n+  private long planningDoneNanos;\n+  private final long threadExecutingTheQueryId;\n+  @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n+  private final String threadExecutingTheQueryName;\n+  private final LongSupplier activeLockCount;\n+  private final long initialActiveLocks;\n+  private final SystemNanoClock clock;\n+  private final CpuClock cpuClock;\n+  private final HeapAllocation heapAllocation;\n+  private final long cpuTimeNanosWhenQueryStarted;\n+  private final long heapAllocatedBytesWhenQueryStarted;\n+  private final Map<String, Object> transactionAnnotationData;\n+  /**\n+   * Uses write barrier of {@link #status}.\n+   */\n+  private PlannerInfo plannerInfo;\n+  private volatile ExecutingQueryStatus status = SimpleState.planning();\n+  /**\n+   * Updated through {@link #WAIT_TIME}\n+   */\n+  @SuppressWarnings(\"unused\")\n+  private volatile long waitTimeNanos;\n+\n+  public ExecutingQuery(\n+      long queryId,\n+      ClientConnectionInfo clientConnection,\n+      String username,\n+      String queryText,\n+      MapValue queryParameters,\n+      Map<String, Object> transactionAnnotationData,\n+      LongSupplier activeLockCount,\n+      PageCursorCounters pageCursorCounters,\n+      long threadExecutingTheQueryId,\n+      String threadExecutingTheQueryName,\n+      SystemNanoClock clock,\n+      CpuClock cpuClock,\n+      HeapAllocation heapAllocation)\n+  {\n+    // Capture timestamps first\n+    this.cpuTimeNanosWhenQueryStarted = cpuClock.cpuTimeNanos(threadExecutingTheQueryId);\n+    this.startTimeNanos = clock.nanos();\n+    this.startTimestampMillis = clock.millis();\n+    // then continue with assigning fields\n+    this.queryId = queryId;\n+    this.clientConnection = clientConnection;\n+    this.pageCursorCounters = pageCursorCounters;\n+    this.username = username;\n+    this.queryText = queryText;\n+    this.queryParameters = queryParameters;\n+    this.transactionAnnotationData = transactionAnnotationData;\n+    this.activeLockCount = activeLockCount;\n+    this.initialActiveLocks = activeLockCount.getAsLong();\n+    this.threadExecutingTheQueryId = threadExecutingTheQueryId;\n+    this.threadExecutingTheQueryName = threadExecutingTheQueryName;\n+    this.cpuClock = cpuClock;\n+    this.heapAllocation = heapAllocation;\n+    this.clock = clock;\n+    this.heapAllocatedBytesWhenQueryStarted = heapAllocation.allocatedBytes(this.threadExecutingTheQueryId);\n+  }\n+\n+  // update state\n+\n+  public void planningCompleted(PlannerInfo plannerInfo)\n+  {\n+    this.plannerInfo = plannerInfo;\n+    this.planningDoneNanos = clock.nanos();\n+    this.status = SimpleState.running(); // write barrier - must be last\n+  }\n+\n+  public LockTracer lockTracer()\n+  {\n+    return lockTracer;\n+  }\n+\n+  public void waitsForQuery(ExecutingQuery child)\n+  {\n+    if (child == null)\n     {\n-        return startTimestampMillis;\n-    }\n-\n-    public long elapsedNanos()\n+      WAIT_TIME.addAndGet(this, status.waitTimeNanos(clock.nanos()));\n+      this.status = SimpleState.running();\n+    } else\n     {\n-        return clock.nanos() - startTimeNanos;\n+      this.status = new WaitingOnQuery(child, clock.nanos());\n     }\n-\n-    public Map<String,Object> transactionAnnotationData()\n+  }\n+\n+  // snapshot state\n+\n+  public QuerySnapshot snapshot()\n+  {\n+    // capture a consistent snapshot of the \"live\" state\n+    ExecutingQueryStatus status;\n+    long waitTimeNanos;\n+    long currentTimeNanos;\n+    long cpuTimeNanos;\n+    do\n     {\n-        return transactionAnnotationData;\n+      status = this.status; // read barrier, must be first\n+      waitTimeNanos = this.waitTimeNanos; // the reason for the retry loop: don't count the wait time twice\n+      cpuTimeNanos = cpuClock.cpuTimeNanos(threadExecutingTheQueryId);\n+      currentTimeNanos = clock.nanos(); // capture the time as close to the snapshot as possible\n     }\n-\n-    public long reportedWaitingTimeNanos()\n+    while (this.status != status);\n+    // guarded by barrier - unused if status is planning, stable otherwise\n+    long planningDoneNanos = this.planningDoneNanos;\n+    // guarded by barrier - like planningDoneNanos\n+    PlannerInfo planner = status.isPlanning() ? null : this.plannerInfo;\n+    List<ActiveLock> waitingOnLocks = status.isWaitingOnLocks() ? status.waitingOnLocks() : Collections.emptyList();\n+    // activeLockCount is not atomic to capture, so we capture it after the most sensitive part.\n+    long totalActiveLocks = this.activeLockCount.getAsLong();\n+    // just needs to be captured at some point...\n+    long heapAllocatedBytes = heapAllocation.allocatedBytes(threadExecutingTheQueryId);\n+    PageCounterValues pageCounters = new PageCounterValues(pageCursorCounters);\n+\n+    // - at this point we are done capturing the \"live\" state, and can start computing the snapshot -\n+    long planningTimeNanos = (status.isPlanning() ? currentTimeNanos : planningDoneNanos) - startTimeNanos;\n+    long elapsedTimeNanos = currentTimeNanos - startTimeNanos;\n+    cpuTimeNanos -= cpuTimeNanosWhenQueryStarted;\n+    waitTimeNanos += status.waitTimeNanos(currentTimeNanos);\n+    // TODO: when we start allocating native memory as well during query execution,\n+    // we should have a tracer that keeps track of how much memory we have allocated for the query,\n+    // and get the value from that here.\n+    heapAllocatedBytes = heapAllocatedBytesWhenQueryStarted < 0 ? -1 : // mark that we were unable to measure\n+        heapAllocatedBytes - heapAllocatedBytesWhenQueryStarted;\n+\n+    return new QuerySnapshot(\n+        this,\n+        planner,\n+        pageCounters,\n+        NANOSECONDS.toMillis(planningTimeNanos),\n+        NANOSECONDS.toMillis(elapsedTimeNanos),\n+        cpuTimeNanos == 0 && cpuTimeNanosWhenQueryStarted == -1 ? -1 : NANOSECONDS.toMillis(cpuTimeNanos),\n+        NANOSECONDS.toMillis(waitTimeNanos),\n+        status.name(),\n+        status.toMap(currentTimeNanos),\n+        waitingOnLocks,\n+        totalActiveLocks - initialActiveLocks,\n+        heapAllocatedBytes\n+    );\n+  }\n+\n+  // basic methods\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o)\n     {\n-        return waitTimeNanos;\n+      return true;\n     }\n-\n-    public long totalWaitingTimeNanos( long currentTimeNanos )\n-    {\n-        return waitTimeNanos + status.waitTimeNanos( currentTimeNanos );\n-    }\n-\n-    ClientConnectionInfo clientConnection()\n-    {\n-        return clientConnection;\n-    }\n-\n-    private LockWaitEvent waitForLock( boolean exclusive, ResourceType resourceType, long[] resourceIds )\n+    if (o == null || getClass() != o.getClass())\n     {\n-        WaitingOnLockEvent event = new WaitingOnLockEvent(\n-                exclusive ? ActiveLock.EXCLUSIVE_MODE : ActiveLock.SHARED_MODE,\n-                resourceType,\n-                resourceIds,\n-                this,\n-                clock.nanos(),\n-                status );\n-        status = event;\n-        return event;\n+      return false;\n     }\n \n-    void doneWaitingOnLock( WaitingOnLockEvent waiting )\n+    ExecutingQuery that = (ExecutingQuery) o;\n+\n+    return queryId == that.queryId;\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return (int) (queryId ^ (queryId >>> 32));\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return ToStringBuilder.reflectionToString(this);\n+  }\n+\n+  // access stable state\n+\n+  public long internalQueryId()\n+  {\n+    return queryId;\n+  }\n+\n+  public String username()\n+  {\n+    return username;\n+  }\n+\n+  public String queryText()\n+  {\n+    return queryText;\n+  }\n+\n+  public MapValue queryParameters()\n+  {\n+    return queryParameters;\n+  }\n+\n+  public long startTimestampMillis()\n+  {\n+    return startTimestampMillis;\n+  }\n+\n+  public long elapsedNanos()\n+  {\n+    return clock.nanos() - startTimeNanos;\n+  }\n+\n+  public Map<String, Object> transactionAnnotationData()\n+  {\n+    return transactionAnnotationData;\n+  }\n+\n+  public long reportedWaitingTimeNanos()\n+  {\n+    return waitTimeNanos;\n+  }\n+\n+  public long totalWaitingTimeNanos(long currentTimeNanos)\n+  {\n+    return waitTimeNanos + status.waitTimeNanos(currentTimeNanos);\n+  }\n+\n+  ClientConnectionInfo clientConnection()\n+  {\n+    return clientConnection;\n+  }\n+\n+  private LockWaitEvent waitForLock(boolean exclusive, ResourceType resourceType, long[] resourceIds)\n+  {\n+    WaitingOnLockEvent event = new WaitingOnLockEvent(\n+        exclusive ? ActiveLock.EXCLUSIVE_MODE : ActiveLock.SHARED_MODE,\n+        resourceType,\n+        resourceIds,\n+        this,\n+        clock.nanos(),\n+        status);\n+    status = event;\n+    return event;\n+  }\n+\n+  void doneWaitingOnLock(WaitingOnLockEvent waiting)\n+  {\n+    if (status != waiting)\n     {\n-        if ( status != waiting )\n-        {\n-            return; // already closed\n-        }\n-        WAIT_TIME.addAndGet( this, waiting.waitTimeNanos( clock.nanos() ) );\n-        status = waiting.previousStatus();\n+      return; // already closed\n     }\n+    WAIT_TIME.addAndGet(this, waiting.waitTimeNanos(clock.nanos()));\n+    status = waiting.previousStatus();\n+  }\n }\n",
            "diff_size": 387
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "184",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 305).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "212",
                    "column": "16",
                    "severity": "error",
                    "message": "'(' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.TypecastParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1128/ExecutingQuery.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/1128/ExecutingQuery.java\nindex b662a1810a5..dbb57394ac2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1128/ExecutingQuery.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/1128/ExecutingQuery.java\n@@ -46,9 +46,8 @@ import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n  */\n public class ExecutingQuery\n {\n-    private static final AtomicLongFieldUpdater<ExecutingQuery> WAIT_TIME =\n-            newUpdater( ExecutingQuery.class, \"waitTimeNanos\" );\n-    private final long queryId;\n+    private static final AtomicLongFieldUpdater<ExecutingQuery> WAIT_TIME = newUpdater( ExecutingQuery.class, \"waitTimeNanos\" );\n+private final long queryId;\n     private final LockTracer lockTracer = this::waitForLock;\n     private final PageCursorCounters pageCursorCounters;\n     private final String username;\n@@ -57,10 +56,12 @@ public class ExecutingQuery\n     private final MapValue queryParameters;\n     private final long startTimeNanos;\n     private final long startTimestampMillis;\n-    /** Uses write barrier of {@link #status}. */\n+\n+/** Uses write barrier of {@link #status}. */\n     private long planningDoneNanos;\n     private final long threadExecutingTheQueryId;\n-    @SuppressWarnings( {\"unused\", \"FieldCanBeLocal\"} )\n+\n+@SuppressWarnings( {\"unused\", \"FieldCanBeLocal\"} )\n     private final String threadExecutingTheQueryName;\n     private final LongSupplier activeLockCount;\n     private final long initialActiveLocks;\n@@ -70,20 +71,20 @@ public class ExecutingQuery\n     private final long cpuTimeNanosWhenQueryStarted;\n     private final long heapAllocatedBytesWhenQueryStarted;\n     private final Map<String,Object> transactionAnnotationData;\n-    /** Uses write barrier of {@link #status}. */\n+\n+/** Uses write barrier of {@link #status}. */\n     private PlannerInfo plannerInfo;\n     private volatile ExecutingQueryStatus status = SimpleState.planning();\n-    /** Updated through {@link #WAIT_TIME} */\n+\n+/** Updated through {@link #WAIT_TIME} */\n     @SuppressWarnings( \"unused\" )\n     private volatile long waitTimeNanos;\n \n-    public ExecutingQuery(\n-            long queryId,\n+    public ExecutingQuery( long queryId,\n             ClientConnectionInfo clientConnection,\n             String username,\n             String queryText,\n-            MapValue queryParameters,\n-            Map<String,Object> transactionAnnotationData,\n+            MapValue queryParameters, Map<String,Object> transactionAnnotationData,\n             LongSupplier activeLockCount,\n             PageCursorCounters pageCursorCounters,\n             long threadExecutingTheQueryId,\n@@ -179,21 +180,10 @@ public class ExecutingQuery\n         // and get the value from that here.\n         heapAllocatedBytes = heapAllocatedBytesWhenQueryStarted < 0 ? -1 : // mark that we were unable to measure\n                 heapAllocatedBytes - heapAllocatedBytesWhenQueryStarted;\n-\n-        return new QuerySnapshot(\n-                this,\n-                planner,\n-                pageCounters,\n-                NANOSECONDS.toMillis( planningTimeNanos ),\n-                NANOSECONDS.toMillis( elapsedTimeNanos ),\n-                cpuTimeNanos == 0 && cpuTimeNanosWhenQueryStarted == -1 ? -1 : NANOSECONDS.toMillis( cpuTimeNanos ),\n-                NANOSECONDS.toMillis( waitTimeNanos ),\n-                status.name(),\n-                status.toMap( currentTimeNanos ),\n-                waitingOnLocks,\n+return new QuerySnapshot( this, planner, pageCounters,\n+                NANOSECONDS.toMillis( planningTimeNanos ), NANOSECONDS.toMillis( elapsedTimeNanos ), cpuTimeNanos == 0 && cpuTimeNanosWhenQueryStarted == -1 ? -1 : NANOSECONDS.toMillis( cpuTimeNanos ), NANOSECONDS.toMillis( waitTimeNanos ), status.name(), status.toMap( currentTimeNanos ), waitingOnLocks,\n                 totalActiveLocks - initialActiveLocks,\n-                heapAllocatedBytes\n-        );\n+                heapAllocatedBytes );\n     }\n \n     // basic methods\n@@ -205,7 +195,8 @@ public class ExecutingQuery\n         {\n             return true;\n         }\n-        if ( o == null || getClass() != o.getClass() )\n+\n+if ( o == null || getClass() != o.getClass() )\n         {\n             return false;\n         }\n@@ -218,7 +209,7 @@ public class ExecutingQuery\n     @Override\n     public int hashCode()\n     {\n-        return (int) (queryId ^ (queryId >>> 32));\n+        return ( int) ( queryId ^ ( queryId >>> 32 ));\n     }\n \n     @Override\n@@ -281,14 +272,9 @@ public class ExecutingQuery\n \n     private LockWaitEvent waitForLock( boolean exclusive, ResourceType resourceType, long[] resourceIds )\n     {\n-        WaitingOnLockEvent event = new WaitingOnLockEvent(\n-                exclusive ? ActiveLock.EXCLUSIVE_MODE : ActiveLock.SHARED_MODE,\n-                resourceType,\n-                resourceIds,\n-                this,\n-                clock.nanos(),\n-                status );\n-        status = event;\n+        WaitingOnLockEvent event = new WaitingOnLockEvent( exclusive ? ActiveLock.EXCLUSIVE_MODE : ActiveLock.SHARED_MODE, resourceType, resourceIds, this,\n+                clock.nanos(), status );\n+status = event;\n         return event;\n     }\n \n@@ -301,4 +287,4 @@ public class ExecutingQuery\n         WAIT_TIME.addAndGet( this, waiting.waitTimeNanos( clock.nanos() ) );\n         status = waiting.previousStatus();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 41
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}