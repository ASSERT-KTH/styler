{
    "project_name": "findbugsproject-findbugs",
    "error_id": "44",
    "information": {
        "errors": [
            {
                "line": "102",
                "column": "9",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "        if(bugAccumulator.getLastBugLocation() == null && !sawExcludedNSECall && noSideEffectMethods.useless(getMethodDescriptor())) {\n            // Do not report UC_USELESS_VOID_METHOD if something was already reported inside the current method\n        \t// it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report\n            bugAccumulator.accumulateBug(new BugInstance(this, \"UC_USELESS_VOID_METHOD\",\n                    code.getCode().length > 20 ? HIGH_PRIORITY : NORMAL_PRIORITY).addClassAndMethod(getMethodDescriptor()), this);\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/44/MethodReturnCheck.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/44/MethodReturnCheck.java\nindex c205d468a5a..7c879e40210 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/44/MethodReturnCheck.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/44/MethodReturnCheck.java\n@@ -99,7 +99,7 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n     public void visitAfter(Code code) {\n         if(bugAccumulator.getLastBugLocation() == null && !sawExcludedNSECall && noSideEffectMethods.useless(getMethodDescriptor())) {\n             // Do not report UC_USELESS_VOID_METHOD if something was already reported inside the current method\n-        \t// it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report\n+        // it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report\n             bugAccumulator.accumulateBug(new BugInstance(this, \"UC_USELESS_VOID_METHOD\",\n                     code.getCode().length > 20 ? HIGH_PRIORITY : NORMAL_PRIORITY).addClassAndMethod(getMethodDescriptor()), this);\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/44/MethodReturnCheck.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/44/MethodReturnCheck.java\nindex c205d468a5a..05fd4dc2996 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/44/MethodReturnCheck.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/44/MethodReturnCheck.java\n@@ -16,6 +16,7 @@\n  * License along with this library; if not, write to the Free Software\n  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n  */\n+\n package edu.umd.cs.findbugs.detect;\n \n import java.util.BitSet;\n@@ -61,6 +62,7 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n     private static final int SAW_INVOKE = 1;\n \n     private static final BitSet INVOKE_OPCODE_SET = new BitSet();\n+\n     static {\n         INVOKE_OPCODE_SET.set(Constants.INVOKEINTERFACE);\n         INVOKE_OPCODE_SET.set(Constants.INVOKESPECIAL);\n@@ -97,11 +99,11 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n \n     @Override\n     public void visitAfter(Code code) {\n-        if(bugAccumulator.getLastBugLocation() == null && !sawExcludedNSECall && noSideEffectMethods.useless(getMethodDescriptor())) {\n+        if (bugAccumulator.getLastBugLocation() == null && !sawExcludedNSECall && noSideEffectMethods.useless(getMethodDescriptor())) {\n             // Do not report UC_USELESS_VOID_METHOD if something was already reported inside the current method\n-        \t// it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report\n+            // it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report\n             bugAccumulator.accumulateBug(new BugInstance(this, \"UC_USELESS_VOID_METHOD\",\n-                    code.getCode().length > 20 ? HIGH_PRIORITY : NORMAL_PRIORITY).addClassAndMethod(getMethodDescriptor()), this);\n+                code.getCode().length > 20 ? HIGH_PRIORITY : NORMAL_PRIORITY).addClassAndMethod(getMethodDescriptor()), this);\n         }\n         sawExcludedNSECall = false;\n         bugAccumulator.reportAccumulatedBugs();\n@@ -145,6 +147,7 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n         return false;\n \n     }\n+\n     @Override\n     public void sawOpcode(int seen) {\n \n@@ -153,28 +156,29 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n         }\n \n         switch (seen) {\n-        case Constants.IF_ICMPEQ:\n-\n-        case Constants.IF_ICMPNE:\n-            OpcodeStack.Item left = stack.getStackItem(1);\n-            OpcodeStack.Item right = stack.getStackItem(0);\n-            if (badUseOfCompareResult(left, right)) {\n-                XMethod returnValueOf = left.getReturnValueOf();\n-                assert returnValueOf != null;\n-                bugAccumulator.accumulateBug(new BugInstance(this, \"RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE\", NORMAL_PRIORITY)\n-                .addClassAndMethod(this).addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addValueSource(right, this), this);\n-            } else if (badUseOfCompareResult(right, left)) {\n-                XMethod returnValueOf = right.getReturnValueOf();\n-                assert returnValueOf != null;\n-                bugAccumulator.accumulateBug(new BugInstance(this, \"RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE\", NORMAL_PRIORITY)\n-                .addClassAndMethod(this).addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addValueSource(left, this), this);\n-            }\n-            break;\n-        default:\n-            break;\n+            case Constants.IF_ICMPEQ:\n+\n+            case Constants.IF_ICMPNE:\n+                OpcodeStack.Item left = stack.getStackItem(1);\n+                OpcodeStack.Item right = stack.getStackItem(0);\n+                if (badUseOfCompareResult(left, right)) {\n+                    XMethod returnValueOf = left.getReturnValueOf();\n+                    assert returnValueOf != null;\n+                    bugAccumulator.accumulateBug(new BugInstance(this, \"RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE\", NORMAL_PRIORITY)\n+                        .addClassAndMethod(this).addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addValueSource(right, this), this);\n+                } else if (badUseOfCompareResult(right, left)) {\n+                    XMethod returnValueOf = right.getReturnValueOf();\n+                    assert returnValueOf != null;\n+                    bugAccumulator.accumulateBug(new BugInstance(this, \"RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE\", NORMAL_PRIORITY)\n+                        .addClassAndMethod(this).addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addValueSource(left, this), this);\n+                }\n+                break;\n+            default:\n+                break;\n         }\n \n-        checkForInitWithoutCopyOnStack: if (seen == INVOKESPECIAL && \"<init>\".equals(getNameConstantOperand())) {\n+        checkForInitWithoutCopyOnStack:\n+        if (seen == INVOKESPECIAL && \"<init>\".equals(getNameConstantOperand())) {\n             int arguments = PreorderVisitor.getNumberArguments(getSigConstantOperand());\n             OpcodeStack.Item invokedOn = stack.getStackItem(arguments);\n             if (invokedOn.isNewlyAllocated() && (!\"<init>\".equals(getMethodName()) || invokedOn.getRegisterNumber() != 0)) {\n@@ -217,11 +221,11 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n                 if (annotation != null && annotation != CheckReturnValueAnnotation.CHECK_RETURN_VALUE_IGNORE) {\n                     int priority = annotation.getPriority();\n                     if (!checkReturnAnnotationDatabase.annotationIsDirect(callSeen)\n-                            && !callSeen.getSignature().endsWith(callSeen.getClassName().replace('.', '/') + \";\")) {\n+                        && !callSeen.getSignature().endsWith(callSeen.getClassName().replace('.', '/') + \";\")) {\n                         priority++;\n                     }\n                     bugAccumulator.accumulateBug(new BugInstance(this, annotation.getPattern(), priority).addClassAndMethod(this)\n-                            .addCalledMethod(this), this);\n+                        .addCalledMethod(this), this);\n                 }\n \n             }\n@@ -244,21 +248,21 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n                     int priority = NORMAL_PRIORITY;\n                     Type callReturnType = Type.getReturnType(callSeen.getMethodDescriptor().getSignature());\n                     Type methodReturnType = Type.getReturnType(getMethodSig());\n-                    if(callReturnType.equals(methodReturnType) && callReturnType != Type.BOOLEAN && callReturnType != Type.VOID) {\n+                    if (callReturnType.equals(methodReturnType) && callReturnType != Type.BOOLEAN && callReturnType != Type.VOID) {\n                         priority = HIGH_PRIORITY;\n                     } else {\n                         String callReturnClass = callSeen.getName().equals(\"<init>\") ?\n-                                callSeen.getClassDescriptor().getClassName() :\n-                                    ClassName.fromFieldSignature(callReturnType.getSignature());\n-\n-                                String methodReturnClass = ClassName.fromFieldSignature(methodReturnType.getSignature());\n-                                if(callReturnClass != null && methodReturnClass != null &&\n-                                        Subtypes2.instanceOf(ClassName.toDottedClassName(callReturnClass), ClassName.toDottedClassName(methodReturnClass))) {\n-                                    priority = HIGH_PRIORITY;\n-                                }\n+                            callSeen.getClassDescriptor().getClassName() :\n+                            ClassName.fromFieldSignature(callReturnType.getSignature());\n+\n+                        String methodReturnClass = ClassName.fromFieldSignature(methodReturnType.getSignature());\n+                        if (callReturnClass != null && methodReturnClass != null &&\n+                            Subtypes2.instanceOf(ClassName.toDottedClassName(callReturnClass), ClassName.toDottedClassName(methodReturnClass))) {\n+                            priority = HIGH_PRIORITY;\n+                        }\n                     }\n                     BugInstance warning = new BugInstance(this, \"RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT\", priority)\n-                    .addClassAndMethod(this).addMethod(callSeen).describe(MethodAnnotation.METHOD_CALLED);\n+                        .addClassAndMethod(this).addMethod(callSeen).describe(MethodAnnotation.METHOD_CALLED);\n                     bugAccumulator.accumulateBug(warning, SourceLineAnnotation.fromVisitedInstruction(this, callPC));\n                 } else {\n                     XFactory xFactory = AnalysisContext.currentXFactory();\n@@ -282,7 +286,7 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n                     priority += 1;\n                 }\n                 if (!checkReturnAnnotationDatabase.annotationIsDirect(callSeen)\n-                        && !callSeen.getSignature().endsWith(callSeen.getClassName().replace('.', '/') + \";\")) {\n+                    && !callSeen.getSignature().endsWith(callSeen.getClassName().replace('.', '/') + \";\")) {\n                     priority++;\n                 }\n                 if (callSeen.isPrivate()) {\n@@ -293,11 +297,11 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n                 }\n                 String pattern = annotation.getPattern();\n                 if (\"<init>\".equals(callSeen.getName())\n-                        && (callSeen.getClassName().endsWith(\"Exception\") || callSeen.getClassName().endsWith(\"Error\"))) {\n+                    && (callSeen.getClassName().endsWith(\"Exception\") || callSeen.getClassName().endsWith(\"Error\"))) {\n                     pattern = \"RV_EXCEPTION_NOT_THROWN\";\n                 }\n                 BugInstance warning = new BugInstance(this, pattern, priority).addClassAndMethod(this).addMethod(callSeen)\n-                        .describe(MethodAnnotation.METHOD_CALLED);\n+                    .describe(MethodAnnotation.METHOD_CALLED);\n                 bugAccumulator.accumulateBug(warning, SourceLineAnnotation.fromVisitedInstruction(this, callPC));\n             }\n             state = SCAN;\n",
            "diff_size": 42
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/44/MethodReturnCheck.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/codebuff/44/MethodReturnCheck.java\nindex c205d468a5a..bbf6060602a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/44/MethodReturnCheck.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/codebuff/44/MethodReturnCheck.java\n@@ -19,11 +19,9 @@\n package edu.umd.cs.findbugs.detect;\n \n import java.util.BitSet;\n-\n import org.apache.bcel.Constants;\n import org.apache.bcel.classfile.Code;\n import org.apache.bcel.generic.Type;\n-\n import edu.umd.cs.findbugs.BugAccumulator;\n import edu.umd.cs.findbugs.BugInstance;\n import edu.umd.cs.findbugs.BugReporter;\n@@ -53,6 +51,7 @@ import edu.umd.cs.findbugs.visitclass.PreorderVisitor;\n  *\n  * @author David Hovemeyer\n  */\n+\n public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotationDatabase {\n     private static final boolean DEBUG = SystemProperties.getBoolean(\"mrc.debug\");\n \n@@ -61,6 +60,7 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n     private static final int SAW_INVOKE = 1;\n \n     private static final BitSet INVOKE_OPCODE_SET = new BitSet();\n+\n     static {\n         INVOKE_OPCODE_SET.set(Constants.INVOKEINTERFACE);\n         INVOKE_OPCODE_SET.set(Constants.INVOKESPECIAL);\n@@ -84,6 +84,7 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n \n     private boolean sawExcludedNSECall;\n \n+\n     public MethodReturnCheck(BugReporter bugReporter) {\n         this.bugAccumulator = new BugAccumulator(bugReporter);\n         this.noSideEffectMethods = Global.getAnalysisCache().getDatabase(NoSideEffectMethodsDatabase.class);\n@@ -97,28 +98,27 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n \n     @Override\n     public void visitAfter(Code code) {\n-        if(bugAccumulator.getLastBugLocation() == null && !sawExcludedNSECall && noSideEffectMethods.useless(getMethodDescriptor())) {\n+        if (bugAccumulator.getLastBugLocation() == null && !sawExcludedNSECall && noSideEffectMethods.useless(getMethodDescriptor())) {\n             // Do not report UC_USELESS_VOID_METHOD if something was already reported inside the current method\n-        \t// it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report\n-            bugAccumulator.accumulateBug(new BugInstance(this, \"UC_USELESS_VOID_METHOD\",\n-                    code.getCode().length > 20 ? HIGH_PRIORITY : NORMAL_PRIORITY).addClassAndMethod(getMethodDescriptor()), this);\n+            // it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report\n+            bugAccumulator.accumulateBug(\n+                new BugInstance(this, \"UC_USELESS_VOID_METHOD\", code.getCode().length > 20 ? HIGH_PRIORITY : NORMAL_PRIORITY).addClassAndMethod(getMethodDescriptor()),\n+                this);\n         }\n         sawExcludedNSECall = false;\n         bugAccumulator.reportAccumulatedBugs();\n     }\n \n+\n     private boolean badUseOfCompareResult(Item left, Item right) {\n         XMethod m = left.getReturnValueOf();\n-\n         if (m == null) {\n             return false;\n         }\n         String name = m.getName();\n-\n         if (!name.startsWith(\"compare\")) {\n             return false;\n         }\n-\n         Object value = right.getConstant();\n         if (!(value instanceof Integer) || ((Integer) value).intValue() == 0) {\n             return false;\n@@ -126,8 +126,6 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n         if (!m.isPublic() && m.isResolved()) {\n             return false;\n         }\n-\n-\n         if (m.isStatic() || !m.isResolved()) {\n             if (\"compare\".equals(name) && m.getClassName().startsWith(\"com.google.common.primitives.\")) {\n                 return true;\n@@ -141,61 +139,51 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n                 return true;\n             }\n         }\n-\n         return false;\n-\n     }\n+\n     @Override\n     public void sawOpcode(int seen) {\n-\n         if (DEBUG) {\n             System.out.printf(\"%3d %10s %3s %s%n\", getPC(), OPCODE_NAMES[seen], state, stack);\n         }\n \n         switch (seen) {\n         case Constants.IF_ICMPEQ:\n-\n         case Constants.IF_ICMPNE:\n             OpcodeStack.Item left = stack.getStackItem(1);\n             OpcodeStack.Item right = stack.getStackItem(0);\n             if (badUseOfCompareResult(left, right)) {\n                 XMethod returnValueOf = left.getReturnValueOf();\n                 assert returnValueOf != null;\n-                bugAccumulator.accumulateBug(new BugInstance(this, \"RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE\", NORMAL_PRIORITY)\n-                .addClassAndMethod(this).addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addValueSource(right, this), this);\n+                bugAccumulator.accumulateBug(new BugInstance(this, \"RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE\", NORMAL_PRIORITY).addClassAndMethod(this).addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addValueSource(right, this), this);\n             } else if (badUseOfCompareResult(right, left)) {\n                 XMethod returnValueOf = right.getReturnValueOf();\n                 assert returnValueOf != null;\n-                bugAccumulator.accumulateBug(new BugInstance(this, \"RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE\", NORMAL_PRIORITY)\n-                .addClassAndMethod(this).addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addValueSource(left, this), this);\n+                bugAccumulator.accumulateBug(new BugInstance(this, \"RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE\", NORMAL_PRIORITY).addClassAndMethod(this).addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addValueSource(left, this), this);\n             }\n             break;\n         default:\n             break;\n         }\n-\n         checkForInitWithoutCopyOnStack: if (seen == INVOKESPECIAL && \"<init>\".equals(getNameConstantOperand())) {\n             int arguments = PreorderVisitor.getNumberArguments(getSigConstantOperand());\n             OpcodeStack.Item invokedOn = stack.getStackItem(arguments);\n             if (invokedOn.isNewlyAllocated() && (!\"<init>\".equals(getMethodName()) || invokedOn.getRegisterNumber() != 0)) {\n-\n                 for (int i = arguments + 1; i < stack.getStackDepth(); i++) {\n                     OpcodeStack.Item item = stack.getStackItem(i);\n                     if (item.isNewlyAllocated() && item.getSignature().equals(invokedOn.getSignature())) {\n                         break checkForInitWithoutCopyOnStack;\n                     }\n                 }\n-\n                 callSeen = XFactory.createReferencedXMethod(this);\n                 callPC = getPC();\n                 sawMethodCallWithIgnoredReturnValue();\n                 state = SCAN;\n                 previousOpcodeWasNEW = false;\n                 return;\n-\n             }\n         }\n-\n         if (state == SAW_INVOKE && isPop(seen)) {\n             sawMethodCallWithIgnoredReturnValue();\n         } else if (INVOKE_OPCODE_SET.get(seen)) {\n@@ -208,7 +196,6 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n         } else {\n             state = SCAN;\n         }\n-\n         if (seen == NEW) {\n             previousOpcodeWasNEW = true;\n         } else {\n@@ -216,96 +203,84 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n                 CheckReturnValueAnnotation annotation = checkReturnAnnotationDatabase.getResolvedAnnotation(callSeen, false);\n                 if (annotation != null && annotation != CheckReturnValueAnnotation.CHECK_RETURN_VALUE_IGNORE) {\n                     int priority = annotation.getPriority();\n-                    if (!checkReturnAnnotationDatabase.annotationIsDirect(callSeen)\n-                            && !callSeen.getSignature().endsWith(callSeen.getClassName().replace('.', '/') + \";\")) {\n+                    if (!checkReturnAnnotationDatabase.annotationIsDirect(callSeen) && !callSeen.getSignature().endsWith(callSeen.getClassName().replace('.', '/') + \";\")) {\n                         priority++;\n                     }\n-                    bugAccumulator.accumulateBug(new BugInstance(this, annotation.getPattern(), priority).addClassAndMethod(this)\n-                            .addCalledMethod(this), this);\n+                    bugAccumulator.accumulateBug(new BugInstance(this, annotation.getPattern(), priority).addClassAndMethod(this).addCalledMethod(this), this);\n                 }\n-\n             }\n             previousOpcodeWasNEW = false;\n         }\n-\n     }\n \n     /**\n      *\n      */\n+\n+\n     private void sawMethodCallWithIgnoredReturnValue() {\n         {\n-            CheckReturnValueAnnotation annotation = checkReturnAnnotationDatabase.getResolvedAnnotation(callSeen, false);\n-            if (annotation == null) {\n-                if (noSideEffectMethods.excluded(callSeen.getMethodDescriptor())) {\n-                    sawExcludedNSECall = true;\n-                }\n-                if (noSideEffectMethods.hasNoSideEffect(callSeen.getMethodDescriptor())) {\n-                    int priority = NORMAL_PRIORITY;\n-                    Type callReturnType = Type.getReturnType(callSeen.getMethodDescriptor().getSignature());\n-                    Type methodReturnType = Type.getReturnType(getMethodSig());\n-                    if(callReturnType.equals(methodReturnType) && callReturnType != Type.BOOLEAN && callReturnType != Type.VOID) {\n-                        priority = HIGH_PRIORITY;\n-                    } else {\n-                        String callReturnClass = callSeen.getName().equals(\"<init>\") ?\n-                                callSeen.getClassDescriptor().getClassName() :\n-                                    ClassName.fromFieldSignature(callReturnType.getSignature());\n-\n-                                String methodReturnClass = ClassName.fromFieldSignature(methodReturnType.getSignature());\n-                                if(callReturnClass != null && methodReturnClass != null &&\n-                                        Subtypes2.instanceOf(ClassName.toDottedClassName(callReturnClass), ClassName.toDottedClassName(methodReturnClass))) {\n-                                    priority = HIGH_PRIORITY;\n-                                }\n-                    }\n-                    BugInstance warning = new BugInstance(this, \"RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT\", priority)\n-                    .addClassAndMethod(this).addMethod(callSeen).describe(MethodAnnotation.METHOD_CALLED);\n-                    bugAccumulator.accumulateBug(warning, SourceLineAnnotation.fromVisitedInstruction(this, callPC));\n+        CheckReturnValueAnnotation annotation = checkReturnAnnotationDatabase.getResolvedAnnotation(callSeen, false);\n+        if (annotation == null) {\n+            if (noSideEffectMethods.excluded(callSeen.getMethodDescriptor())) {\n+                sawExcludedNSECall = true;\n+            }\n+            if (noSideEffectMethods.hasNoSideEffect(callSeen.getMethodDescriptor())) {\n+                int priority = NORMAL_PRIORITY;\n+                Type callReturnType = Type.getReturnType(callSeen.getMethodDescriptor().getSignature());\n+                Type methodReturnType = Type.getReturnType(getMethodSig());\n+                if (callReturnType.equals(methodReturnType) && callReturnType != Type.BOOLEAN && callReturnType != Type.VOID) {\n+                    priority = HIGH_PRIORITY;\n                 } else {\n-                    XFactory xFactory = AnalysisContext.currentXFactory();\n-\n-                    if (xFactory.isFunctionshatMightBeMistakenForProcedures(callSeen.getMethodDescriptor())) {\n-                        annotation = CheckReturnValueAnnotation.CHECK_RETURN_VALUE_INFERRED;\n+                    String callReturnClass = callSeen.getName().equals(\"<init>\") ? callSeen.getClassDescriptor().getClassName() : ClassName.fromFieldSignature(callReturnType.getSignature());\n+                    String methodReturnClass = ClassName.fromFieldSignature(methodReturnType.getSignature());\n+                    if (callReturnClass != null && methodReturnClass != null && Subtypes2.instanceOf(ClassName.toDottedClassName(callReturnClass), ClassName.toDottedClassName(methodReturnClass))) {\n+                        priority = HIGH_PRIORITY;\n                     }\n                 }\n-            }\n-            if (annotation != null && annotation.getPriority() <= LOW_PRIORITY) {\n-                int popPC = getPC();\n-                if (DEBUG) {\n-                    System.out.println(\"Saw POP @\" + popPC);\n-                }\n-                int catchSize = getSizeOfSurroundingTryBlock(popPC);\n-\n-                int priority = annotation.getPriority();\n-                if (catchSize <= 1) {\n-                    priority += 2;\n-                } else if (catchSize <= 2) {\n-                    priority += 1;\n-                }\n-                if (!checkReturnAnnotationDatabase.annotationIsDirect(callSeen)\n-                        && !callSeen.getSignature().endsWith(callSeen.getClassName().replace('.', '/') + \";\")) {\n-                    priority++;\n-                }\n-                if (callSeen.isPrivate()) {\n-                    priority++;\n-                }\n-                if (\"clone\".equals(callSeen.getName()) || callSeen.getName().startsWith(\"get\")) {\n-                    priority++;\n-                }\n-                String pattern = annotation.getPattern();\n-                if (\"<init>\".equals(callSeen.getName())\n-                        && (callSeen.getClassName().endsWith(\"Exception\") || callSeen.getClassName().endsWith(\"Error\"))) {\n-                    pattern = \"RV_EXCEPTION_NOT_THROWN\";\n-                }\n-                BugInstance warning = new BugInstance(this, pattern, priority).addClassAndMethod(this).addMethod(callSeen)\n-                        .describe(MethodAnnotation.METHOD_CALLED);\n+                BugInstance warning = new BugInstance(this, \"RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT\", priority).addClassAndMethod(this).addMethod(callSeen).describe(MethodAnnotation.METHOD_CALLED);\n                 bugAccumulator.accumulateBug(warning, SourceLineAnnotation.fromVisitedInstruction(this, callPC));\n+            } else {\n+                XFactory xFactory = AnalysisContext.currentXFactory();\n+                if (xFactory.isFunctionshatMightBeMistakenForProcedures(callSeen.getMethodDescriptor())) {\n+                    annotation = CheckReturnValueAnnotation.CHECK_RETURN_VALUE_INFERRED;\n+                }\n             }\n-            state = SCAN;\n+        }\n+        if (annotation != null && annotation.getPriority() <= LOW_PRIORITY) {\n+            int popPC = getPC();\n+            if (DEBUG) {\n+                System.out.println(\"Saw POP @\" + popPC);\n+            }\n+            int catchSize = getSizeOfSurroundingTryBlock(popPC);\n+            int priority = annotation.getPriority();\n+            if (catchSize <= 1) {\n+                priority += 2;\n+            } else if (catchSize <= 2) {\n+                priority += 1;\n+            }\n+            if (!checkReturnAnnotationDatabase.annotationIsDirect(callSeen) && !callSeen.getSignature().endsWith(callSeen.getClassName().replace('.', '/') + \";\")) {\n+                priority++;\n+            }\n+            if (callSeen.isPrivate()) {\n+                priority++;\n+            }\n+            if (\"clone\".equals(callSeen.getName()) || callSeen.getName().startsWith(\"get\")) {\n+                priority++;\n+            }\n+            String pattern = annotation.getPattern();\n+            if (\"<init>\".equals(callSeen.getName()) && (callSeen.getClassName().endsWith(\"Exception\") || callSeen.getClassName().endsWith(\"Error\"))) {\n+                pattern = \"RV_EXCEPTION_NOT_THROWN\";\n+            }\n+            BugInstance warning = new BugInstance(this, pattern, priority).addClassAndMethod(this).addMethod(callSeen).describe(MethodAnnotation.METHOD_CALLED);\n+            bugAccumulator.accumulateBug(warning, SourceLineAnnotation.fromVisitedInstruction(this, callPC));\n+        }\n+        state = SCAN;\n         }\n     }\n \n+\n     private boolean isPop(int seen) {\n         return seen == Constants.POP || seen == Constants.POP2;\n     }\n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 137
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/44/MethodReturnCheck.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/44/MethodReturnCheck.java\nindex c205d468a5a..7c879e40210 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/44/MethodReturnCheck.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/44/MethodReturnCheck.java\n@@ -99,7 +99,7 @@ public class MethodReturnCheck extends OpcodeStackDetector implements UseAnnotat\n     public void visitAfter(Code code) {\n         if(bugAccumulator.getLastBugLocation() == null && !sawExcludedNSECall && noSideEffectMethods.useless(getMethodDescriptor())) {\n             // Do not report UC_USELESS_VOID_METHOD if something was already reported inside the current method\n-        \t// it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report\n+        // it's likely that UC_USELESS_VOID_METHOD is just the consequence of the previous report\n             bugAccumulator.accumulateBug(new BugInstance(this, \"UC_USELESS_VOID_METHOD\",\n                     code.getCode().length > 20 ? HIGH_PRIORITY : NORMAL_PRIORITY).addClassAndMethod(getMethodDescriptor()), this);\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random"
    ],
    "not_repaired_by": [
        "naturalize",
        "styler_three_grams"
    ]
}