{
    "project_name": "codefollower-H2-Research",
    "error_id": "163",
    "information": {
        "errors": [
            {
                "line": "253",
                "column": "41",
                "severity": "warning",
                "message": "';' is followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
            }
        ]
    },
    "source_code": "        int firstChild = childPageIds[splitPoint];\n        readAllRows();\n        for (; splitPoint < entryCount; ) {\n            p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], getRow(splitPoint));\n            removeChild(splitPoint);\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/163/PageBtreeNode.java\nindex 71486d3a061..480a6ed46db 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/163/PageBtreeNode.java\n@@ -250,7 +250,7 @@ public class PageBtreeNode extends PageBtree {\n         }\n         int firstChild = childPageIds[splitPoint];\n         readAllRows();\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], getRow(splitPoint));\n             removeChild(splitPoint);\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "254",
                    "column": "37",
                    "severity": "warning",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/163/PageBtreeNode.java\nindex 71486d3a061..b8b2bc335f0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/163/PageBtreeNode.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import org.h2.api.DatabaseEventListener;\n@@ -33,578 +34,578 @@ import org.h2.util.Utils;\n  */\n public class PageBtreeNode extends PageBtree {\n \n-    private static final int CHILD_OFFSET_PAIR_LENGTH = 6;\n-    private static final int MAX_KEY_LENGTH = 10;\n-\n-    private final boolean pageStoreInternalCount;\n-\n-    /**\n-     * The page ids of the children.\n-     */\n-    private int[] childPageIds;\n-\n-    private int rowCountStored = UNKNOWN_ROWCOUNT;\n-\n-    private int rowCount = UNKNOWN_ROWCOUNT;\n-\n-    private PageBtreeNode(PageBtreeIndex index, int pageId, Data data) {\n-        super(index, pageId, data);\n-        this.pageStoreInternalCount = index.getDatabase().\n-                getSettings().pageStoreInternalCount;\n-    }\n-\n-    /**\n-     * Read a b-tree node page.\n-     *\n-     * @param index the index\n-     * @param data the data\n-     * @param pageId the page id\n-     * @return the page\n-     */\n-    public static Page read(PageBtreeIndex index, Data data, int pageId) {\n-        PageBtreeNode p = new PageBtreeNode(index, pageId, data);\n-        p.read();\n-        return p;\n-    }\n-\n-    /**\n-     * Create a new b-tree node page.\n-     *\n-     * @param index the index\n-     * @param pageId the page id\n-     * @param parentPageId the parent page id\n-     * @return the page\n-     */\n-    static PageBtreeNode create(PageBtreeIndex index, int pageId,\n-            int parentPageId) {\n-        PageBtreeNode p = new PageBtreeNode(index, pageId, index.getPageStore()\n-                .createData());\n-        index.getPageStore().logUndo(p, null);\n-        p.parentPageId = parentPageId;\n-        p.writeHead();\n-        // 4 bytes for the rightmost child page id\n-        p.start = p.data.length() + 4;\n-        p.rows = SearchRow.EMPTY_ARRAY;\n-        if (p.pageStoreInternalCount) {\n-            p.rowCount = 0;\n-        }\n-        return p;\n-    }\n-\n-    private void read() {\n-        data.reset();\n-        int type = data.readByte();\n-        data.readShortInt();\n-        this.parentPageId = data.readInt();\n-        onlyPosition = (type & Page.FLAG_LAST) == 0;\n-        int indexId = data.readVarInt();\n-        if (indexId != index.getId()) {\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                    \"page:\" + getPos() + \" expected index:\" + index.getId() +\n-                    \"got:\" + indexId);\n-        }\n-        rowCount = rowCountStored = data.readInt();\n-        entryCount = data.readShortInt();\n-        childPageIds = new int[entryCount + 1];\n-        childPageIds[entryCount] = data.readInt();\n-        rows = entryCount == 0 ? SearchRow.EMPTY_ARRAY : new SearchRow[entryCount];\n-        offsets = Utils.newIntArray(entryCount);\n-        for (int i = 0; i < entryCount; i++) {\n-            childPageIds[i] = data.readInt();\n-            offsets[i] = data.readShortInt();\n-        }\n-        check();\n-        start = data.length();\n-        written = true;\n-    }\n-\n-    /**\n-     * Add a row. If it is possible this method returns -1, otherwise\n-     * the split point. It is always possible to add two rows.\n-     *\n-     * @param row the now to add\n-     * @return the split point of this page, or -1 if no split is required\n-     */\n-    private int addChildTry(SearchRow row) {\n-        if (entryCount < 4) {\n-            return -1;\n-        }\n-        int startData;\n-        if (onlyPosition) {\n-            // if we only store the position, we may at most store as many\n-            // entries as there is space for keys, because the current data area\n-            // might get larger when _removing_ a child (if the new key needs\n-            // more space) - and removing a child can't split this page\n-            startData = entryCount + 1 * MAX_KEY_LENGTH;\n-        } else {\n-            int rowLength = index.getRowSize(data, row, onlyPosition);\n-            int pageSize = index.getPageStore().getPageSize();\n-            int last = entryCount == 0 ? pageSize : offsets[entryCount - 1];\n-            startData = last - rowLength;\n-        }\n-        if (startData < start + CHILD_OFFSET_PAIR_LENGTH) {\n-            return entryCount / 2;\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * Add a child at the given position.\n-     *\n-     * @param x the position\n-     * @param childPageId the child\n-     * @param row the row smaller than the first row of the child and its\n-     *            children\n-     */\n-    private void addChild(int x, int childPageId, SearchRow row) {\n-        int rowLength = index.getRowSize(data, row, onlyPosition);\n-        int pageSize = index.getPageStore().getPageSize();\n-        int last = entryCount == 0 ? pageSize : offsets[entryCount - 1];\n-        if (last - rowLength < start + CHILD_OFFSET_PAIR_LENGTH) {\n-            readAllRows();\n-            onlyPosition = true;\n-            // change the offsets (now storing only positions)\n-            int o = pageSize;\n-            for (int i = 0; i < entryCount; i++) {\n-                o -= index.getRowSize(data, getRow(i), true);\n-                offsets[i] = o;\n-            }\n-            last = entryCount == 0 ? pageSize : offsets[entryCount - 1];\n-            rowLength = index.getRowSize(data, row, true);\n-            if (SysProperties.CHECK && last - rowLength <\n-                    start + CHILD_OFFSET_PAIR_LENGTH) {\n-                throw DbException.throwInternalError();\n-            }\n-        }\n-        int offset = last - rowLength;\n-        if (entryCount > 0) {\n-            if (x < entryCount) {\n-                offset = (x == 0 ? pageSize : offsets[x - 1]) - rowLength;\n-            }\n-        }\n-        rows = insert(rows, entryCount, x, row);\n-        offsets = insert(offsets, entryCount, x, offset);\n-        add(offsets, x + 1, entryCount + 1, -rowLength);\n-        childPageIds = insert(childPageIds, entryCount + 1, x + 1, childPageId);\n-        start += CHILD_OFFSET_PAIR_LENGTH;\n-        if (pageStoreInternalCount) {\n-            if (rowCount != UNKNOWN_ROWCOUNT) {\n-                rowCount += offset;\n-            }\n-        }\n-        entryCount++;\n-        written = false;\n-        changeCount = index.getPageStore().getChangeCount();\n+  private static final int CHILD_OFFSET_PAIR_LENGTH = 6;\n+  private static final int MAX_KEY_LENGTH = 10;\n+\n+  private final boolean pageStoreInternalCount;\n+\n+  /**\n+   * The page ids of the children.\n+   */\n+  private int[] childPageIds;\n+\n+  private int rowCountStored = UNKNOWN_ROWCOUNT;\n+\n+  private int rowCount = UNKNOWN_ROWCOUNT;\n+\n+  private PageBtreeNode(PageBtreeIndex index, int pageId, Data data) {\n+    super(index, pageId, data);\n+    this.pageStoreInternalCount = index.getDatabase().\n+        getSettings().pageStoreInternalCount;\n+  }\n+\n+  /**\n+   * Read a b-tree node page.\n+   *\n+   * @param index  the index\n+   * @param data   the data\n+   * @param pageId the page id\n+   * @return the page\n+   */\n+  public static Page read(PageBtreeIndex index, Data data, int pageId) {\n+    PageBtreeNode p = new PageBtreeNode(index, pageId, data);\n+    p.read();\n+    return p;\n+  }\n+\n+  /**\n+   * Create a new b-tree node page.\n+   *\n+   * @param index        the index\n+   * @param pageId       the page id\n+   * @param parentPageId the parent page id\n+   * @return the page\n+   */\n+  static PageBtreeNode create(PageBtreeIndex index, int pageId,\n+                              int parentPageId) {\n+    PageBtreeNode p = new PageBtreeNode(index, pageId, index.getPageStore()\n+        .createData());\n+    index.getPageStore().logUndo(p, null);\n+    p.parentPageId = parentPageId;\n+    p.writeHead();\n+    // 4 bytes for the rightmost child page id\n+    p.start = p.data.length() + 4;\n+    p.rows = SearchRow.EMPTY_ARRAY;\n+    if (p.pageStoreInternalCount) {\n+      p.rowCount = 0;\n     }\n-\n-    @Override\n-    int addRowTry(SearchRow row) {\n-        while (true) {\n-            int x = find(row, false, true, true);\n-            PageBtree page = index.getPage(childPageIds[x]);\n-            int splitPoint = page.addRowTry(row);\n-            if (splitPoint == -1) {\n-                break;\n-            }\n-            SearchRow pivot = page.getRow(splitPoint - 1);\n-            index.getPageStore().logUndo(this, data);\n-            int splitPoint2 = addChildTry(pivot);\n-            if (splitPoint2 != -1) {\n-                return splitPoint2;\n-            }\n-            PageBtree page2 = page.split(splitPoint);\n-            readAllRows();\n-            addChild(x, page2.getPos(), pivot);\n-            index.getPageStore().update(page);\n-            index.getPageStore().update(page2);\n-            index.getPageStore().update(this);\n-        }\n-        updateRowCount(1);\n-        written = false;\n-        changeCount = index.getPageStore().getChangeCount();\n-        return -1;\n+    return p;\n+  }\n+\n+  private void read() {\n+    data.reset();\n+    int type = data.readByte();\n+    data.readShortInt();\n+    this.parentPageId = data.readInt();\n+    onlyPosition = (type & Page.FLAG_LAST) == 0;\n+    int indexId = data.readVarInt();\n+    if (indexId != index.getId()) {\n+      throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n+          \"page:\" + getPos() + \" expected index:\" + index.getId() +\n+              \"got:\" + indexId);\n     }\n-\n-    private void updateRowCount(int offset) {\n-        if (rowCount != UNKNOWN_ROWCOUNT) {\n-            rowCount += offset;\n-        }\n-        if (rowCountStored != UNKNOWN_ROWCOUNT) {\n-            rowCountStored = UNKNOWN_ROWCOUNT;\n-            index.getPageStore().logUndo(this, data);\n-            if (written) {\n-                writeHead();\n-            }\n-            index.getPageStore().update(this);\n-        }\n+    rowCount = rowCountStored = data.readInt();\n+    entryCount = data.readShortInt();\n+    childPageIds = new int[entryCount + 1];\n+    childPageIds[entryCount] = data.readInt();\n+    rows = entryCount == 0 ? SearchRow.EMPTY_ARRAY : new SearchRow[entryCount];\n+    offsets = Utils.newIntArray(entryCount);\n+    for (int i = 0; i < entryCount; i++) {\n+      childPageIds[i] = data.readInt();\n+      offsets[i] = data.readShortInt();\n     }\n-\n-    @Override\n-    PageBtree split(int splitPoint) {\n-        int newPageId = index.getPageStore().allocatePage();\n-        PageBtreeNode p2 = PageBtreeNode.create(index, newPageId, parentPageId);\n-        index.getPageStore().logUndo(this, data);\n-        if (onlyPosition) {\n-            // TODO optimize: maybe not required\n-            p2.onlyPosition = true;\n-        }\n-        int firstChild = childPageIds[splitPoint];\n-        readAllRows();\n-        for (; splitPoint < entryCount; ) {\n-            p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], getRow(splitPoint));\n-            removeChild(splitPoint);\n-        }\n-        int lastChild = childPageIds[splitPoint - 1];\n-        removeChild(splitPoint - 1);\n-        childPageIds[splitPoint - 1] = lastChild;\n-        if (p2.childPageIds == null) {\n-            p2.childPageIds = new int[1];\n-        }\n-        p2.childPageIds[0] = firstChild;\n-        p2.remapChildren();\n-        return p2;\n-    }\n-\n-    @Override\n-    protected void remapChildren() {\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            int child = childPageIds[i];\n-            PageBtree p = index.getPage(child);\n-            p.setParentPageId(getPos());\n-            index.getPageStore().update(p);\n-        }\n+    check();\n+    start = data.length();\n+    written = true;\n+  }\n+\n+  /**\n+   * Add a row. If it is possible this method returns -1, otherwise\n+   * the split point. It is always possible to add two rows.\n+   *\n+   * @param row the now to add\n+   * @return the split point of this page, or -1 if no split is required\n+   */\n+  private int addChildTry(SearchRow row) {\n+    if (entryCount < 4) {\n+      return -1;\n     }\n-\n-    /**\n-     * Initialize the page.\n-     *\n-     * @param page1 the first child page\n-     * @param pivot the pivot key\n-     * @param page2 the last child page\n-     */\n-    void init(PageBtree page1, SearchRow pivot, PageBtree page2) {\n-        entryCount = 0;\n-        childPageIds = new int[] { page1.getPos() };\n-        rows = SearchRow.EMPTY_ARRAY;\n-        offsets = Utils.EMPTY_INT_ARRAY;\n-        addChild(0, page2.getPos(), pivot);\n-        if (pageStoreInternalCount) {\n-            rowCount = page1.getRowCount() + page2.getRowCount();\n-        }\n-        check();\n-    }\n-\n-    @Override\n-    void find(PageBtreeCursor cursor, SearchRow first, boolean bigger) {\n-        int i = find(first, bigger, false, false);\n-        if (i > entryCount) {\n-            if (parentPageId == PageBtree.ROOT) {\n-                return;\n-            }\n-            PageBtreeNode next = (PageBtreeNode) index.getPage(parentPageId);\n-            next.find(cursor, first, bigger);\n-            return;\n-        }\n-        PageBtree page = index.getPage(childPageIds[i]);\n-        page.find(cursor, first, bigger);\n+    int startData;\n+    if (onlyPosition) {\n+      // if we only store the position, we may at most store as many\n+      // entries as there is space for keys, because the current data area\n+      // might get larger when _removing_ a child (if the new key needs\n+      // more space) - and removing a child can't split this page\n+      startData = entryCount + 1 * MAX_KEY_LENGTH;\n+    } else {\n+      int rowLength = index.getRowSize(data, row, onlyPosition);\n+      int pageSize = index.getPageStore().getPageSize();\n+      int last = entryCount == 0 ? pageSize : offsets[entryCount - 1];\n+      startData = last - rowLength;\n     }\n-\n-    @Override\n-    void last(PageBtreeCursor cursor) {\n-        int child = childPageIds[entryCount];\n-        index.getPage(child).last(cursor);\n+    if (startData < start + CHILD_OFFSET_PAIR_LENGTH) {\n+      return entryCount / 2;\n     }\n-\n-    @Override\n-    PageBtreeLeaf getFirstLeaf() {\n-        int child = childPageIds[0];\n-        return index.getPage(child).getFirstLeaf();\n+    return -1;\n+  }\n+\n+  /**\n+   * Add a child at the given position.\n+   *\n+   * @param x           the position\n+   * @param childPageId the child\n+   * @param row         the row smaller than the first row of the child and its\n+   *                    children\n+   */\n+  private void addChild(int x, int childPageId, SearchRow row) {\n+    int rowLength = index.getRowSize(data, row, onlyPosition);\n+    int pageSize = index.getPageStore().getPageSize();\n+    int last = entryCount == 0 ? pageSize : offsets[entryCount - 1];\n+    if (last - rowLength < start + CHILD_OFFSET_PAIR_LENGTH) {\n+      readAllRows();\n+      onlyPosition = true;\n+      // change the offsets (now storing only positions)\n+      int o = pageSize;\n+      for (int i = 0; i < entryCount; i++) {\n+        o -= index.getRowSize(data, getRow(i), true);\n+        offsets[i] = o;\n+      }\n+      last = entryCount == 0 ? pageSize : offsets[entryCount - 1];\n+      rowLength = index.getRowSize(data, row, true);\n+      if (SysProperties.CHECK && last - rowLength <\n+          start + CHILD_OFFSET_PAIR_LENGTH) {\n+        throw DbException.throwInternalError();\n+      }\n     }\n-\n-    @Override\n-    PageBtreeLeaf getLastLeaf() {\n-        int child = childPageIds[entryCount];\n-        return index.getPage(child).getLastLeaf();\n+    int offset = last - rowLength;\n+    if (entryCount > 0) {\n+      if (x < entryCount) {\n+        offset = (x == 0 ? pageSize : offsets[x - 1]) - rowLength;\n+      }\n     }\n-\n-    @Override\n-    SearchRow remove(SearchRow row) {\n-        int at = find(row, false, false, true);\n-        // merge is not implemented to allow concurrent usage\n-        // TODO maybe implement merge\n-        PageBtree page = index.getPage(childPageIds[at]);\n-        SearchRow last = page.remove(row);\n-        index.getPageStore().logUndo(this, data);\n-        updateRowCount(-1);\n-        written = false;\n-        changeCount = index.getPageStore().getChangeCount();\n-        if (last == null) {\n-            // the last row didn't change - nothing to do\n-            return null;\n-        } else if (last == row) {\n-            // this child is now empty\n-            index.getPageStore().free(page.getPos());\n-            if (entryCount < 1) {\n-                // no more children - this page is empty as well\n-                return row;\n-            }\n-            if (at == entryCount) {\n-                // removing the last child\n-                last = getRow(at - 1);\n-            } else {\n-                last = null;\n-            }\n-            removeChild(at);\n-            index.getPageStore().update(this);\n-            return last;\n-        }\n-        // the last row is in the last child\n-        if (at == entryCount) {\n-            return last;\n-        }\n-        int child = childPageIds[at];\n-        removeChild(at);\n-        // TODO this can mean only the position is now stored\n-        // should split at the next possible moment\n-        addChild(at, child, last);\n-        // remove and add swapped two children, fix that\n-        int temp = childPageIds[at];\n-        childPageIds[at] = childPageIds[at + 1];\n-        childPageIds[at + 1] = temp;\n-        index.getPageStore().update(this);\n-        return null;\n-    }\n-\n-    @Override\n-    int getRowCount() {\n-        if (rowCount == UNKNOWN_ROWCOUNT) {\n-            int count = 0;\n-            for (int i = 0; i < entryCount + 1; i++) {\n-                int child = childPageIds[i];\n-                PageBtree page = index.getPage(child);\n-                count += page.getRowCount();\n-                index.getDatabase().setProgress(\n-                        DatabaseEventListener.STATE_SCAN_FILE,\n-                        index.getName(), count, Integer.MAX_VALUE);\n-            }\n-            rowCount = count;\n-        }\n-        return rowCount;\n+    rows = insert(rows, entryCount, x, row);\n+    offsets = insert(offsets, entryCount, x, offset);\n+    add(offsets, x + 1, entryCount + 1, -rowLength);\n+    childPageIds = insert(childPageIds, entryCount + 1, x + 1, childPageId);\n+    start += CHILD_OFFSET_PAIR_LENGTH;\n+    if (pageStoreInternalCount) {\n+      if (rowCount != UNKNOWN_ROWCOUNT) {\n+        rowCount += offset;\n+      }\n     }\n-\n-    @Override\n-    void setRowCountStored(int rowCount) {\n-        if (rowCount < 0 && pageStoreInternalCount) {\n-            return;\n-        }\n-        this.rowCount = rowCount;\n-        if (rowCountStored != rowCount) {\n-            rowCountStored = rowCount;\n-            index.getPageStore().logUndo(this, data);\n-            if (written) {\n-                changeCount = index.getPageStore().getChangeCount();\n-                writeHead();\n-            }\n-            index.getPageStore().update(this);\n-        }\n+    entryCount++;\n+    written = false;\n+    changeCount = index.getPageStore().getChangeCount();\n+  }\n+\n+  @Override\n+  int addRowTry(SearchRow row) {\n+    while (true) {\n+      int x = find(row, false, true, true);\n+      PageBtree page = index.getPage(childPageIds[x]);\n+      int splitPoint = page.addRowTry(row);\n+      if (splitPoint == -1) {\n+        break;\n+      }\n+      SearchRow pivot = page.getRow(splitPoint - 1);\n+      index.getPageStore().logUndo(this, data);\n+      int splitPoint2 = addChildTry(pivot);\n+      if (splitPoint2 != -1) {\n+        return splitPoint2;\n+      }\n+      PageBtree page2 = page.split(splitPoint);\n+      readAllRows();\n+      addChild(x, page2.getPos(), pivot);\n+      index.getPageStore().update(page);\n+      index.getPageStore().update(page2);\n+      index.getPageStore().update(this);\n     }\n-\n-    private void check() {\n-        if (SysProperties.CHECK) {\n-            for (int i = 0; i < entryCount + 1; i++) {\n-                int child = childPageIds[i];\n-                if (child == 0) {\n-                    DbException.throwInternalError();\n-                }\n-            }\n-        }\n+    updateRowCount(1);\n+    written = false;\n+    changeCount = index.getPageStore().getChangeCount();\n+    return -1;\n+  }\n+\n+  private void updateRowCount(int offset) {\n+    if (rowCount != UNKNOWN_ROWCOUNT) {\n+      rowCount += offset;\n     }\n-\n-    @Override\n-    public void write() {\n-        check();\n-        writeData();\n-        index.getPageStore().writePage(getPos(), data);\n+    if (rowCountStored != UNKNOWN_ROWCOUNT) {\n+      rowCountStored = UNKNOWN_ROWCOUNT;\n+      index.getPageStore().logUndo(this, data);\n+      if (written) {\n+        writeHead();\n+      }\n+      index.getPageStore().update(this);\n     }\n-\n-    private void writeHead() {\n-        data.reset();\n-        data.writeByte((byte) (Page.TYPE_BTREE_NODE |\n-                (onlyPosition ? 0 : Page.FLAG_LAST)));\n-        data.writeShortInt(0);\n-        data.writeInt(parentPageId);\n-        data.writeVarInt(index.getId());\n-        data.writeInt(rowCountStored);\n-        data.writeShortInt(entryCount);\n+  }\n+\n+  @Override\n+  PageBtree split(int splitPoint) {\n+    int newPageId = index.getPageStore().allocatePage();\n+    PageBtreeNode p2 = PageBtreeNode.create(index, newPageId, parentPageId);\n+    index.getPageStore().logUndo(this, data);\n+    if (onlyPosition) {\n+      // TODO optimize: maybe not required\n+      p2.onlyPosition = true;\n+    }\n+    int firstChild = childPageIds[splitPoint];\n+    readAllRows();\n+    for (; splitPoint < entryCount; ) {\n+      p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], getRow(splitPoint));\n+      removeChild(splitPoint);\n+    }\n+    int lastChild = childPageIds[splitPoint - 1];\n+    removeChild(splitPoint - 1);\n+    childPageIds[splitPoint - 1] = lastChild;\n+    if (p2.childPageIds == null) {\n+      p2.childPageIds = new int[1];\n+    }\n+    p2.childPageIds[0] = firstChild;\n+    p2.remapChildren();\n+    return p2;\n+  }\n+\n+  @Override\n+  protected void remapChildren() {\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      int child = childPageIds[i];\n+      PageBtree p = index.getPage(child);\n+      p.setParentPageId(getPos());\n+      index.getPageStore().update(p);\n+    }\n+  }\n+\n+  /**\n+   * Initialize the page.\n+   *\n+   * @param page1 the first child page\n+   * @param pivot the pivot key\n+   * @param page2 the last child page\n+   */\n+  void init(PageBtree page1, SearchRow pivot, PageBtree page2) {\n+    entryCount = 0;\n+    childPageIds = new int[] {page1.getPos()};\n+    rows = SearchRow.EMPTY_ARRAY;\n+    offsets = Utils.EMPTY_INT_ARRAY;\n+    addChild(0, page2.getPos(), pivot);\n+    if (pageStoreInternalCount) {\n+      rowCount = page1.getRowCount() + page2.getRowCount();\n+    }\n+    check();\n+  }\n+\n+  @Override\n+  void find(PageBtreeCursor cursor, SearchRow first, boolean bigger) {\n+    int i = find(first, bigger, false, false);\n+    if (i > entryCount) {\n+      if (parentPageId == PageBtree.ROOT) {\n+        return;\n+      }\n+      PageBtreeNode next = (PageBtreeNode) index.getPage(parentPageId);\n+      next.find(cursor, first, bigger);\n+      return;\n+    }\n+    PageBtree page = index.getPage(childPageIds[i]);\n+    page.find(cursor, first, bigger);\n+  }\n+\n+  @Override\n+  void last(PageBtreeCursor cursor) {\n+    int child = childPageIds[entryCount];\n+    index.getPage(child).last(cursor);\n+  }\n+\n+  @Override\n+  PageBtreeLeaf getFirstLeaf() {\n+    int child = childPageIds[0];\n+    return index.getPage(child).getFirstLeaf();\n+  }\n+\n+  @Override\n+  PageBtreeLeaf getLastLeaf() {\n+    int child = childPageIds[entryCount];\n+    return index.getPage(child).getLastLeaf();\n+  }\n+\n+  @Override\n+  SearchRow remove(SearchRow row) {\n+    int at = find(row, false, false, true);\n+    // merge is not implemented to allow concurrent usage\n+    // TODO maybe implement merge\n+    PageBtree page = index.getPage(childPageIds[at]);\n+    SearchRow last = page.remove(row);\n+    index.getPageStore().logUndo(this, data);\n+    updateRowCount(-1);\n+    written = false;\n+    changeCount = index.getPageStore().getChangeCount();\n+    if (last == null) {\n+      // the last row didn't change - nothing to do\n+      return null;\n+    } else if (last == row) {\n+      // this child is now empty\n+      index.getPageStore().free(page.getPos());\n+      if (entryCount < 1) {\n+        // no more children - this page is empty as well\n+        return row;\n+      }\n+      if (at == entryCount) {\n+        // removing the last child\n+        last = getRow(at - 1);\n+      } else {\n+        last = null;\n+      }\n+      removeChild(at);\n+      index.getPageStore().update(this);\n+      return last;\n+    }\n+    // the last row is in the last child\n+    if (at == entryCount) {\n+      return last;\n     }\n+    int child = childPageIds[at];\n+    removeChild(at);\n+    // TODO this can mean only the position is now stored\n+    // should split at the next possible moment\n+    addChild(at, child, last);\n+    // remove and add swapped two children, fix that\n+    int temp = childPageIds[at];\n+    childPageIds[at] = childPageIds[at + 1];\n+    childPageIds[at + 1] = temp;\n+    index.getPageStore().update(this);\n+    return null;\n+  }\n+\n+  @Override\n+  int getRowCount() {\n+    if (rowCount == UNKNOWN_ROWCOUNT) {\n+      int count = 0;\n+      for (int i = 0; i < entryCount + 1; i++) {\n+        int child = childPageIds[i];\n+        PageBtree page = index.getPage(child);\n+        count += page.getRowCount();\n+        index.getDatabase().setProgress(\n+            DatabaseEventListener.STATE_SCAN_FILE,\n+            index.getName(), count, Integer.MAX_VALUE);\n+      }\n+      rowCount = count;\n+    }\n+    return rowCount;\n+  }\n \n-    private void writeData() {\n-        if (written) {\n-            return;\n-        }\n-        readAllRows();\n+  @Override\n+  void setRowCountStored(int rowCount) {\n+    if (rowCount < 0 && pageStoreInternalCount) {\n+      return;\n+    }\n+    this.rowCount = rowCount;\n+    if (rowCountStored != rowCount) {\n+      rowCountStored = rowCount;\n+      index.getPageStore().logUndo(this, data);\n+      if (written) {\n+        changeCount = index.getPageStore().getChangeCount();\n         writeHead();\n-        data.writeInt(childPageIds[entryCount]);\n-        for (int i = 0; i < entryCount; i++) {\n-            data.writeInt(childPageIds[i]);\n-            data.writeShortInt(offsets[i]);\n-        }\n-        for (int i = 0; i < entryCount; i++) {\n-            index.writeRow(data, offsets[i], rows[i], onlyPosition);\n-        }\n-        written = true;\n+      }\n+      index.getPageStore().update(this);\n     }\n+  }\n \n-    @Override\n-    void freeRecursive() {\n-        index.getPageStore().logUndo(this, data);\n-        index.getPageStore().free(getPos());\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            int child = childPageIds[i];\n-            index.getPage(child).freeRecursive();\n+  private void check() {\n+    if (SysProperties.CHECK) {\n+      for (int i = 0; i < entryCount + 1; i++) {\n+        int child = childPageIds[i];\n+        if (child == 0) {\n+          DbException.throwInternalError();\n         }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void write() {\n+    check();\n+    writeData();\n+    index.getPageStore().writePage(getPos(), data);\n+  }\n+\n+  private void writeHead() {\n+    data.reset();\n+    data.writeByte((byte) (Page.TYPE_BTREE_NODE |\n+        (onlyPosition ? 0 : Page.FLAG_LAST)));\n+    data.writeShortInt(0);\n+    data.writeInt(parentPageId);\n+    data.writeVarInt(index.getId());\n+    data.writeInt(rowCountStored);\n+    data.writeShortInt(entryCount);\n+  }\n+\n+  private void writeData() {\n+    if (written) {\n+      return;\n+    }\n+    readAllRows();\n+    writeHead();\n+    data.writeInt(childPageIds[entryCount]);\n+    for (int i = 0; i < entryCount; i++) {\n+      data.writeInt(childPageIds[i]);\n+      data.writeShortInt(offsets[i]);\n+    }\n+    for (int i = 0; i < entryCount; i++) {\n+      index.writeRow(data, offsets[i], rows[i], onlyPosition);\n+    }\n+    written = true;\n+  }\n+\n+  @Override\n+  void freeRecursive() {\n+    index.getPageStore().logUndo(this, data);\n+    index.getPageStore().free(getPos());\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      int child = childPageIds[i];\n+      index.getPage(child).freeRecursive();\n     }\n+  }\n \n-    private void removeChild(int i) {\n-        readAllRows();\n-        entryCount--;\n-        if (pageStoreInternalCount) {\n-            updateRowCount(-index.getPage(childPageIds[i]).getRowCount());\n-        }\n+  private void removeChild(int i) {\n+    readAllRows();\n+    entryCount--;\n+    if (pageStoreInternalCount) {\n+      updateRowCount(-index.getPage(childPageIds[i]).getRowCount());\n+    }\n+    written = false;\n+    changeCount = index.getPageStore().getChangeCount();\n+    if (entryCount < 0) {\n+      DbException.throwInternalError(\"\" + entryCount);\n+    }\n+    if (entryCount > i) {\n+      int startNext = i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();\n+      int rowLength = startNext - offsets[i];\n+      add(offsets, i, entryCount + 1, rowLength);\n+    }\n+    rows = remove(rows, entryCount + 1, i);\n+    offsets = remove(offsets, entryCount + 1, i);\n+    childPageIds = remove(childPageIds, entryCount + 2, i);\n+    start -= CHILD_OFFSET_PAIR_LENGTH;\n+  }\n+\n+  /**\n+   * Set the cursor to the first row of the next page.\n+   *\n+   * @param cursor the cursor\n+   * @param pageId id of the next page\n+   */\n+  void nextPage(PageBtreeCursor cursor, int pageId) {\n+    int i;\n+    // TODO maybe keep the index in the child page (transiently)\n+    for (i = 0; i < entryCount + 1; i++) {\n+      if (childPageIds[i] == pageId) {\n+        i++;\n+        break;\n+      }\n+    }\n+    if (i > entryCount) {\n+      if (parentPageId == PageBtree.ROOT) {\n+        cursor.setCurrent(null, 0);\n+        return;\n+      }\n+      PageBtreeNode next = (PageBtreeNode) index.getPage(parentPageId);\n+      next.nextPage(cursor, getPos());\n+      return;\n+    }\n+    PageBtree page = index.getPage(childPageIds[i]);\n+    PageBtreeLeaf leaf = page.getFirstLeaf();\n+    cursor.setCurrent(leaf, 0);\n+  }\n+\n+  /**\n+   * Set the cursor to the last row of the previous page.\n+   *\n+   * @param cursor the cursor\n+   * @param pageId id of the previous page\n+   */\n+  void previousPage(PageBtreeCursor cursor, int pageId) {\n+    int i;\n+    // TODO maybe keep the index in the child page (transiently)\n+    for (i = entryCount; i >= 0; i--) {\n+      if (childPageIds[i] == pageId) {\n+        i--;\n+        break;\n+      }\n+    }\n+    if (i < 0) {\n+      if (parentPageId == PageBtree.ROOT) {\n+        cursor.setCurrent(null, 0);\n+        return;\n+      }\n+      PageBtreeNode previous = (PageBtreeNode) index.getPage(parentPageId);\n+      previous.previousPage(cursor, getPos());\n+      return;\n+    }\n+    PageBtree page = index.getPage(childPageIds[i]);\n+    PageBtreeLeaf leaf = page.getLastLeaf();\n+    cursor.setCurrent(leaf, leaf.entryCount - 1);\n+  }\n+\n+\n+  @Override\n+  public String toString() {\n+    return \"page[\" + getPos() + \"] b-tree node table:\" +\n+        index.getId() + \" entries:\" + entryCount;\n+  }\n+\n+  @Override\n+  public void moveTo(Session session, int newPos) {\n+    PageStore store = index.getPageStore();\n+    store.logUndo(this, data);\n+    PageBtreeNode p2 = PageBtreeNode.create(index, newPos, parentPageId);\n+    readAllRows();\n+    p2.rowCountStored = rowCountStored;\n+    p2.rowCount = rowCount;\n+    p2.childPageIds = childPageIds;\n+    p2.rows = rows;\n+    p2.entryCount = entryCount;\n+    p2.offsets = offsets;\n+    p2.onlyPosition = onlyPosition;\n+    p2.parentPageId = parentPageId;\n+    p2.start = start;\n+    store.update(p2);\n+    if (parentPageId == ROOT) {\n+      index.setRootPageId(session, newPos);\n+    } else {\n+      Page p = store.getPage(parentPageId);\n+      if (!(p instanceof PageBtreeNode)) {\n+        throw DbException.throwInternalError();\n+      }\n+      PageBtreeNode n = (PageBtreeNode) p;\n+      n.moveChild(getPos(), newPos);\n+    }\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      int child = childPageIds[i];\n+      PageBtree p = index.getPage(child);\n+      p.setParentPageId(newPos);\n+      store.update(p);\n+    }\n+    store.free(getPos());\n+  }\n+\n+  /**\n+   * One of the children has moved to a new page.\n+   *\n+   * @param oldPos the old position\n+   * @param newPos the new position\n+   */\n+  void moveChild(int oldPos, int newPos) {\n+    for (int i = 0; i < entryCount + 1; i++) {\n+      if (childPageIds[i] == oldPos) {\n+        index.getPageStore().logUndo(this, data);\n         written = false;\n         changeCount = index.getPageStore().getChangeCount();\n-        if (entryCount < 0) {\n-            DbException.throwInternalError(\"\" + entryCount);\n-        }\n-        if (entryCount > i) {\n-            int startNext = i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();\n-            int rowLength = startNext - offsets[i];\n-            add(offsets, i, entryCount + 1, rowLength);\n-        }\n-        rows = remove(rows, entryCount + 1, i);\n-        offsets = remove(offsets, entryCount + 1, i);\n-        childPageIds = remove(childPageIds, entryCount + 2, i);\n-        start -= CHILD_OFFSET_PAIR_LENGTH;\n-    }\n-\n-    /**\n-     * Set the cursor to the first row of the next page.\n-     *\n-     * @param cursor the cursor\n-     * @param pageId id of the next page\n-     */\n-    void nextPage(PageBtreeCursor cursor, int pageId) {\n-        int i;\n-        // TODO maybe keep the index in the child page (transiently)\n-        for (i = 0; i < entryCount + 1; i++) {\n-            if (childPageIds[i] == pageId) {\n-                i++;\n-                break;\n-            }\n-        }\n-        if (i > entryCount) {\n-            if (parentPageId == PageBtree.ROOT) {\n-                cursor.setCurrent(null, 0);\n-                return;\n-            }\n-            PageBtreeNode next = (PageBtreeNode) index.getPage(parentPageId);\n-            next.nextPage(cursor, getPos());\n-            return;\n-        }\n-        PageBtree page = index.getPage(childPageIds[i]);\n-        PageBtreeLeaf leaf = page.getFirstLeaf();\n-        cursor.setCurrent(leaf, 0);\n-    }\n-\n-    /**\n-     * Set the cursor to the last row of the previous page.\n-     *\n-     * @param cursor the cursor\n-     * @param pageId id of the previous page\n-     */\n-    void previousPage(PageBtreeCursor cursor, int pageId) {\n-        int i;\n-        // TODO maybe keep the index in the child page (transiently)\n-        for (i = entryCount; i >= 0; i--) {\n-            if (childPageIds[i] == pageId) {\n-                i--;\n-                break;\n-            }\n-        }\n-        if (i < 0) {\n-            if (parentPageId == PageBtree.ROOT) {\n-                cursor.setCurrent(null, 0);\n-                return;\n-            }\n-            PageBtreeNode previous = (PageBtreeNode) index.getPage(parentPageId);\n-            previous.previousPage(cursor, getPos());\n-            return;\n-        }\n-        PageBtree page = index.getPage(childPageIds[i]);\n-        PageBtreeLeaf leaf = page.getLastLeaf();\n-        cursor.setCurrent(leaf, leaf.entryCount - 1);\n-    }\n-\n-\n-    @Override\n-    public String toString() {\n-        return \"page[\" + getPos() + \"] b-tree node table:\" +\n-                index.getId() + \" entries:\" + entryCount;\n-    }\n-\n-    @Override\n-    public void moveTo(Session session, int newPos) {\n-        PageStore store = index.getPageStore();\n-        store.logUndo(this, data);\n-        PageBtreeNode p2 = PageBtreeNode.create(index, newPos, parentPageId);\n-        readAllRows();\n-        p2.rowCountStored = rowCountStored;\n-        p2.rowCount = rowCount;\n-        p2.childPageIds = childPageIds;\n-        p2.rows = rows;\n-        p2.entryCount = entryCount;\n-        p2.offsets = offsets;\n-        p2.onlyPosition = onlyPosition;\n-        p2.parentPageId = parentPageId;\n-        p2.start = start;\n-        store.update(p2);\n-        if (parentPageId == ROOT) {\n-            index.setRootPageId(session, newPos);\n-        } else {\n-            Page p = store.getPage(parentPageId);\n-            if (!(p instanceof PageBtreeNode)) {\n-                throw DbException.throwInternalError();\n-            }\n-            PageBtreeNode n = (PageBtreeNode) p;\n-            n.moveChild(getPos(), newPos);\n-        }\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            int child = childPageIds[i];\n-            PageBtree p = index.getPage(child);\n-            p.setParentPageId(newPos);\n-            store.update(p);\n-        }\n-        store.free(getPos());\n-    }\n-\n-    /**\n-     * One of the children has moved to a new page.\n-     *\n-     * @param oldPos the old position\n-     * @param newPos the new position\n-     */\n-    void moveChild(int oldPos, int newPos) {\n-        for (int i = 0; i < entryCount + 1; i++) {\n-            if (childPageIds[i] == oldPos) {\n-                index.getPageStore().logUndo(this, data);\n-                written = false;\n-                changeCount = index.getPageStore().getChangeCount();\n-                childPageIds[i] = newPos;\n-                index.getPageStore().update(this);\n-                return;\n-            }\n-        }\n-        throw DbException.throwInternalError(oldPos + \" \" + newPos);\n+        childPageIds[i] = newPos;\n+        index.getPageStore().update(this);\n+        return;\n+      }\n     }\n+    throw DbException.throwInternalError(oldPos + \" \" + newPos);\n+  }\n \n }\n",
            "diff_size": 912
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/163/PageBtreeNode.java\nindex 71486d3a061..a4bbfbfcc99 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/163/PageBtreeNode.java\n@@ -250,7 +250,7 @@ public class PageBtreeNode extends PageBtree {\n         }\n         int firstChild = childPageIds[splitPoint];\n         readAllRows();\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], getRow(splitPoint));\n             removeChild(splitPoint);\n         }\n@@ -607,4 +607,4 @@ public class PageBtreeNode extends PageBtree {\n         throw DbException.throwInternalError(oldPos + \" \" + newPos);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/163/PageBtreeNode.java\nindex 71486d3a061..aad8eda020f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/163/PageBtreeNode.java\n@@ -31,26 +31,24 @@ import org.h2.util.Utils;\n  * The row contains the largest key of the respective child,\n  * meaning row[0] contains the largest key of child[0].\n  */\n+\n+\n public class PageBtreeNode extends PageBtree {\n \n     private static final int CHILD_OFFSET_PAIR_LENGTH = 6;\n     private static final int MAX_KEY_LENGTH = 10;\n-\n     private final boolean pageStoreInternalCount;\n \n     /**\n      * The page ids of the children.\n      */\n     private int[] childPageIds;\n-\n     private int rowCountStored = UNKNOWN_ROWCOUNT;\n-\n     private int rowCount = UNKNOWN_ROWCOUNT;\n \n     private PageBtreeNode(PageBtreeIndex index, int pageId, Data data) {\n         super(index, pageId, data);\n-        this.pageStoreInternalCount = index.getDatabase().\n-                getSettings().pageStoreInternalCount;\n+        this.pageStoreInternalCount = index.getDatabase().getSettings().pageStoreInternalCount;\n     }\n \n     /**\n@@ -61,6 +59,8 @@ public class PageBtreeNode extends PageBtree {\n      * @param pageId the page id\n      * @return the page\n      */\n+\n+\n     public static Page read(PageBtreeIndex index, Data data, int pageId) {\n         PageBtreeNode p = new PageBtreeNode(index, pageId, data);\n         p.read();\n@@ -75,10 +75,10 @@ public class PageBtreeNode extends PageBtree {\n      * @param parentPageId the parent page id\n      * @return the page\n      */\n-    static PageBtreeNode create(PageBtreeIndex index, int pageId,\n-            int parentPageId) {\n-        PageBtreeNode p = new PageBtreeNode(index, pageId, index.getPageStore()\n-                .createData());\n+\n+\n+    static PageBtreeNode create(PageBtreeIndex index, int pageId, int parentPageId) {\n+        PageBtreeNode p = new PageBtreeNode(index, pageId, index.getPageStore().createData());\n         index.getPageStore().logUndo(p, null);\n         p.parentPageId = parentPageId;\n         p.writeHead();\n@@ -99,9 +99,8 @@ public class PageBtreeNode extends PageBtree {\n         onlyPosition = (type & Page.FLAG_LAST) == 0;\n         int indexId = data.readVarInt();\n         if (indexId != index.getId()) {\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1,\n-                    \"page:\" + getPos() + \" expected index:\" + index.getId() +\n-                    \"got:\" + indexId);\n+            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"page:\" + getPos() + \" expected index:\"\n+            + index.getId() + \"got:\" + indexId);\n         }\n         rowCount = rowCountStored = data.readInt();\n         entryCount = data.readShortInt();\n@@ -125,6 +124,7 @@ public class PageBtreeNode extends PageBtree {\n      * @param row the now to add\n      * @return the split point of this page, or -1 if no split is required\n      */\n+\n     private int addChildTry(SearchRow row) {\n         if (entryCount < 4) {\n             return -1;\n@@ -156,6 +156,7 @@ public class PageBtreeNode extends PageBtree {\n      * @param row the row smaller than the first row of the child and its\n      *            children\n      */\n+\n     private void addChild(int x, int childPageId, SearchRow row) {\n         int rowLength = index.getRowSize(data, row, onlyPosition);\n         int pageSize = index.getPageStore().getPageSize();\n@@ -171,8 +172,7 @@ public class PageBtreeNode extends PageBtree {\n             }\n             last = entryCount == 0 ? pageSize : offsets[entryCount - 1];\n             rowLength = index.getRowSize(data, row, true);\n-            if (SysProperties.CHECK && last - rowLength <\n-                    start + CHILD_OFFSET_PAIR_LENGTH) {\n+            if (SysProperties.CHECK && last - rowLength < start + CHILD_OFFSET_PAIR_LENGTH) {\n                 throw DbException.throwInternalError();\n             }\n         }\n@@ -250,7 +250,7 @@ public class PageBtreeNode extends PageBtree {\n         }\n         int firstChild = childPageIds[splitPoint];\n         readAllRows();\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], getRow(splitPoint));\n             removeChild(splitPoint);\n         }\n@@ -282,6 +282,8 @@ public class PageBtreeNode extends PageBtree {\n      * @param pivot the pivot key\n      * @param page2 the last child page\n      */\n+\n+\n     void init(PageBtree page1, SearchRow pivot, PageBtree page2) {\n         entryCount = 0;\n         childPageIds = new int[] { page1.getPos() };\n@@ -383,9 +385,7 @@ public class PageBtreeNode extends PageBtree {\n                 int child = childPageIds[i];\n                 PageBtree page = index.getPage(child);\n                 count += page.getRowCount();\n-                index.getDatabase().setProgress(\n-                        DatabaseEventListener.STATE_SCAN_FILE,\n-                        index.getName(), count, Integer.MAX_VALUE);\n+                index.getDatabase().setProgress(DatabaseEventListener.STATE_SCAN_FILE, index.getName(), count, Integer.MAX_VALUE);\n             }\n             rowCount = count;\n         }\n@@ -429,8 +429,7 @@ public class PageBtreeNode extends PageBtree {\n \n     private void writeHead() {\n         data.reset();\n-        data.writeByte((byte) (Page.TYPE_BTREE_NODE |\n-                (onlyPosition ? 0 : Page.FLAG_LAST)));\n+        data.writeByte((byte) (Page.TYPE_BTREE_NODE | (onlyPosition ? 0 : Page.FLAG_LAST)));\n         data.writeShortInt(0);\n         data.writeInt(parentPageId);\n         data.writeVarInt(index.getId());\n@@ -493,6 +492,8 @@ public class PageBtreeNode extends PageBtree {\n      * @param cursor the cursor\n      * @param pageId id of the next page\n      */\n+\n+\n     void nextPage(PageBtreeCursor cursor, int pageId) {\n         int i;\n         // TODO maybe keep the index in the child page (transiently)\n@@ -522,6 +523,8 @@ public class PageBtreeNode extends PageBtree {\n      * @param cursor the cursor\n      * @param pageId id of the previous page\n      */\n+\n+\n     void previousPage(PageBtreeCursor cursor, int pageId) {\n         int i;\n         // TODO maybe keep the index in the child page (transiently)\n@@ -545,11 +548,10 @@ public class PageBtreeNode extends PageBtree {\n         cursor.setCurrent(leaf, leaf.entryCount - 1);\n     }\n \n-\n     @Override\n     public String toString() {\n-        return \"page[\" + getPos() + \"] b-tree node table:\" +\n-                index.getId() + \" entries:\" + entryCount;\n+        return \"page[\" + getPos() + \"] b-tree node table:\"\n+        + index.getId() + \" entries:\" + entryCount;\n     }\n \n     @Override\n@@ -593,6 +595,8 @@ public class PageBtreeNode extends PageBtree {\n      * @param oldPos the old position\n      * @param newPos the new position\n      */\n+\n+\n     void moveChild(int oldPos, int newPos) {\n         for (int i = 0; i < entryCount + 1; i++) {\n             if (childPageIds[i] == oldPos) {\n@@ -607,4 +611,4 @@ public class PageBtreeNode extends PageBtree {\n         throw DbException.throwInternalError(oldPos + \" \" + newPos);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 38
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/163/PageBtreeNode.java\nindex 71486d3a061..480a6ed46db 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/163/PageBtreeNode.java\n@@ -250,7 +250,7 @@ public class PageBtreeNode extends PageBtree {\n         }\n         int firstChild = childPageIds[splitPoint];\n         readAllRows();\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], getRow(splitPoint));\n             removeChild(splitPoint);\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/163/PageBtreeNode.java\nindex 71486d3a061..480a6ed46db 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/163/PageBtreeNode.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/163/PageBtreeNode.java\n@@ -250,7 +250,7 @@ public class PageBtreeNode extends PageBtree {\n         }\n         int firstChild = childPageIds[splitPoint];\n         readAllRows();\n-        for (; splitPoint < entryCount; ) {\n+        for (; splitPoint < entryCount;) {\n             p2.addChild(p2.entryCount, childPageIds[splitPoint + 1], getRow(splitPoint));\n             removeChild(splitPoint);\n         }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij"
    ]
}