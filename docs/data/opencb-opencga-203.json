{
    "project_name": "opencb-opencga",
    "error_id": "203",
    "information": {
        "errors": [
            {
                "line": "106",
                "severity": "error",
                "message": "Line is longer than 140 characters (found 156).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "        DataStore dataStore = VariantStorageManager.getDataStore(catalogManager, studyFqn, File.Bioformat.VARIANT, sessionId);\n        VariantStorageEngine variantStorageEngine = getVariantStorageEngine(dataStore);\n        CatalogStorageMetadataSynchronizer synchronizer = new CatalogStorageMetadataSynchronizer(catalogManager, variantStorageEngine.getMetadataManager());\n\n        synchronizer.synchronizeCatalogStudyFromStorage(studyFqn, sessionId);\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "106",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 156).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "183",
                    "column": "81",
                    "severity": "error",
                    "message": "';' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.EmptyForIteratorPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/203/VariantStatsStorageOperation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/203/VariantStatsStorageOperation.java\nindex 827d11d79b0..2e9c5d13de0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/203/VariantStatsStorageOperation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/203/VariantStatsStorageOperation.java\n@@ -59,377 +59,379 @@ import static org.opencb.opencga.storage.core.variant.VariantStorageEngine.Optio\n @Analysis(id = VariantStatsAnalysis.ID, type = Analysis.AnalysisType.VARIANT)\n public class VariantStatsStorageOperation extends OpenCgaAnalysis {\n \n-    private List<String> cohorts;\n-    private String studyFqn;\n+  private List<String> cohorts;\n+  private String studyFqn;\n \n-    private boolean overwriteStats;\n-    private boolean updateStats;\n-    private boolean resume;\n-    private URI outdirUri;\n-    private List<String> cohortIds;\n+  private boolean overwriteStats;\n+  private boolean updateStats;\n+  private boolean resume;\n+  private URI outdirUri;\n+  private List<String> cohortIds;\n \n \n-    public VariantStatsStorageOperation setCohorts(List<String> cohorts) {\n-        this.cohorts = cohorts;\n-        return this;\n-    }\n+  public VariantStatsStorageOperation setCohorts(List<String> cohorts) {\n+    this.cohorts = cohorts;\n+    return this;\n+  }\n \n-    public VariantStatsStorageOperation setStudyId(String studyId) {\n-        this.studyFqn = studyId;\n-        return this;\n-    }\n+  public VariantStatsStorageOperation setStudyId(String studyId) {\n+    this.studyFqn = studyId;\n+    return this;\n+  }\n \n-    @Override\n-    protected void check() throws Exception {\n-        super.check();\n+  @Override\n+  protected void check() throws Exception {\n+    super.check();\n \n-        overwriteStats = params.getBoolean(Options.OVERWRITE_STATS.key(), false);\n-        updateStats = params.getBoolean(Options.UPDATE_STATS.key(), false);\n-        resume = params.getBoolean(Options.RESUME.key(), Options.RESUME.defaultValue());\n+    overwriteStats = params.getBoolean(Options.OVERWRITE_STATS.key(), false);\n+    updateStats = params.getBoolean(Options.UPDATE_STATS.key(), false);\n+    resume = params.getBoolean(Options.RESUME.key(), Options.RESUME.defaultValue());\n \n-        String userId = catalogManager.getUserManager().getUserId(sessionId);\n-        Study study = catalogManager.getStudyManager().resolveId(studyFqn, userId);\n-        studyFqn = study.getFqn();\n+    String userId = catalogManager.getUserManager().getUserId(sessionId);\n+    Study study = catalogManager.getStudyManager().resolveId(studyFqn, userId);\n+    studyFqn = study.getFqn();\n \n \n-        // Do not save intermediate files\n-        outdirUri = getScratchDir().toUri();\n-    }\n+    // Do not save intermediate files\n+    outdirUri = getScratchDir().toUri();\n+  }\n \n-    @Override\n-    protected void run() throws Exception {\n+  @Override\n+  protected void run() throws Exception {\n \n-        Aggregation aggregation = getAggregation(catalogManager, studyFqn, params, sessionId);\n+    Aggregation aggregation = getAggregation(catalogManager, studyFqn, params, sessionId);\n \n-        DataStore dataStore = VariantStorageManager.getDataStore(catalogManager, studyFqn, File.Bioformat.VARIANT, sessionId);\n-        VariantStorageEngine variantStorageEngine = getVariantStorageEngine(dataStore);\n-        CatalogStorageMetadataSynchronizer synchronizer = new CatalogStorageMetadataSynchronizer(catalogManager, variantStorageEngine.getMetadataManager());\n+    DataStore dataStore = VariantStorageManager.getDataStore(catalogManager, studyFqn, File.Bioformat.VARIANT, sessionId);\n+    VariantStorageEngine variantStorageEngine = getVariantStorageEngine(dataStore);\n+    CatalogStorageMetadataSynchronizer synchronizer =\n+        new CatalogStorageMetadataSynchronizer(catalogManager, variantStorageEngine.getMetadataManager());\n \n-        synchronizer.synchronizeCatalogStudyFromStorage(studyFqn, sessionId);\n+    synchronizer.synchronizeCatalogStudyFromStorage(studyFqn, sessionId);\n \n-        cohortIds = checkCohorts(studyFqn, aggregation, cohorts, sessionId);\n-        Map<String, List<String>> cohortsMap = checkCanCalculateCohorts(studyFqn, cohortIds, updateStats, resume, sessionId);\n+    cohortIds = checkCohorts(studyFqn, aggregation, cohorts, sessionId);\n+    Map<String, List<String>> cohortsMap = checkCanCalculateCohorts(studyFqn, cohortIds, updateStats, resume, sessionId);\n \n \n-        String outputFileName = buildOutputFileName(cohortIds, params.getString(VariantQueryParam.REGION.key()));\n+    String outputFileName = buildOutputFileName(cohortIds, params.getString(VariantQueryParam.REGION.key()));\n \n-        QueryOptions calculateStatsOptions = new QueryOptions(params)\n+    QueryOptions calculateStatsOptions = new QueryOptions(params)\n //                .append(VariantStorageEngine.Options.LOAD_BATCH_SIZE.key(), 100)\n //                .append(VariantStorageEngine.Options.LOAD_THREADS.key(), 6)\n-                .append(Options.AGGREGATED_TYPE.key(), aggregation)\n-                .append(Options.OVERWRITE_STATS.key(), overwriteStats)\n-                .append(Options.UPDATE_STATS.key(), updateStats)\n-                .append(Options.RESUME.key(), resume);\n-\n-        // if the study is aggregated and a mapping file is provided, pass it to storage\n-        // and create in catalog the cohorts described in the mapping file\n-        String aggregationMappingFile = params.getString(Options.AGGREGATION_MAPPING_PROPERTIES.key());\n-        if (AggregationUtils.isAggregated(aggregation) && StringUtils.isNotEmpty(aggregationMappingFile)) {\n-            Properties mappingFile = readAggregationMappingFile(aggregationMappingFile);\n-            calculateStatsOptions.append(Options.AGGREGATION_MAPPING_PROPERTIES.key(), mappingFile);\n-        }\n-\n-        // Up to this point, catalog has not been modified\n-        try {\n-            // Modify cohort status to \"CALCULATING\"\n-            updateCohorts(studyFqn, cohortIds, sessionId, Cohort.CohortStatus.CALCULATING, \"Start calculating stats\");\n-\n-            calculateStatsOptions.put(DefaultVariantStatisticsManager.OUTPUT, outdirUri.resolve(outputFileName));\n-            variantStorageEngine.getOptions().putAll(calculateStatsOptions);\n-            variantStorageEngine.calculateStats(studyFqn, cohortsMap, calculateStatsOptions);\n-\n-            // Modify cohort status to \"READY\"\n-            updateCohorts(studyFqn, cohortIds, sessionId, Cohort.CohortStatus.READY, \"\");\n-\n-            variantStorageEngine.close();\n-        } catch (Exception e) {\n-            // Error!\n-            logger.error(\"Error executing stats. Set cohorts status to \" + Cohort.CohortStatus.INVALID, e);\n-            // Modify to \"INVALID\"\n-            updateCohorts(studyFqn, cohortIds, sessionId, Cohort.CohortStatus.INVALID, \"Error calculating stats: \" + e.getMessage());\n-            throw new StorageEngineException(\"Error calculating statistics.\", e);\n-        }\n+        .append(Options.AGGREGATED_TYPE.key(), aggregation)\n+        .append(Options.OVERWRITE_STATS.key(), overwriteStats)\n+        .append(Options.UPDATE_STATS.key(), updateStats)\n+        .append(Options.RESUME.key(), resume);\n+\n+    // if the study is aggregated and a mapping file is provided, pass it to storage\n+    // and create in catalog the cohorts described in the mapping file\n+    String aggregationMappingFile = params.getString(Options.AGGREGATION_MAPPING_PROPERTIES.key());\n+    if (AggregationUtils.isAggregated(aggregation) && StringUtils.isNotEmpty(aggregationMappingFile)) {\n+      Properties mappingFile = readAggregationMappingFile(aggregationMappingFile);\n+      calculateStatsOptions.append(Options.AGGREGATION_MAPPING_PROPERTIES.key(), mappingFile);\n     }\n \n-    @Override\n-    protected void onShutdown() {\n-        try {\n-            updateCohorts(studyFqn, cohortIds, sessionId, Cohort.CohortStatus.INVALID, \"\");\n-        } catch (CatalogException e) {\n-            logger.error(\"Error updating cohorts \" + cohortIds + \" to status \" + Cohort.CohortStatus.INVALID, e);\n-        }\n+    // Up to this point, catalog has not been modified\n+    try {\n+      // Modify cohort status to \"CALCULATING\"\n+      updateCohorts(studyFqn, cohortIds, sessionId, Cohort.CohortStatus.CALCULATING, \"Start calculating stats\");\n+\n+      calculateStatsOptions.put(DefaultVariantStatisticsManager.OUTPUT, outdirUri.resolve(outputFileName));\n+      variantStorageEngine.getOptions().putAll(calculateStatsOptions);\n+      variantStorageEngine.calculateStats(studyFqn, cohortsMap, calculateStatsOptions);\n+\n+      // Modify cohort status to \"READY\"\n+      updateCohorts(studyFqn, cohortIds, sessionId, Cohort.CohortStatus.READY, \"\");\n+\n+      variantStorageEngine.close();\n+    } catch (Exception e) {\n+      // Error!\n+      logger.error(\"Error executing stats. Set cohorts status to \" + Cohort.CohortStatus.INVALID, e);\n+      // Modify to \"INVALID\"\n+      updateCohorts(studyFqn, cohortIds, sessionId, Cohort.CohortStatus.INVALID, \"Error calculating stats: \" + e.getMessage());\n+      throw new StorageEngineException(\"Error calculating statistics.\", e);\n     }\n-\n-    private VariantStorageEngine getVariantStorageEngine(DataStore dataStore) throws StorageEngineException {\n-        try {\n-            return StorageEngineFactory.get(variantStorageManager.getStorageConfiguration())\n-                    .getVariantStorageEngine(dataStore.getStorageEngine(), dataStore.getDbName());\n-        } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {\n-            throw new StorageEngineException(\"Unable to create StorageEngine\", e);\n-        }\n+  }\n+\n+  @Override\n+  protected void onShutdown() {\n+    try {\n+      updateCohorts(studyFqn, cohortIds, sessionId, Cohort.CohortStatus.INVALID, \"\");\n+    } catch (CatalogException e) {\n+      logger.error(\"Error updating cohorts \" + cohortIds + \" to status \" + Cohort.CohortStatus.INVALID, e);\n     }\n-\n-    protected String buildOutputFileName(List<String> cohortIds, String region) {\n-        final String outputFileName;\n-        if (isNotEmpty(params.getString(DefaultVariantStatisticsManager.OUTPUT_FILE_NAME))) {\n-            outputFileName = params.getString(DefaultVariantStatisticsManager.OUTPUT_FILE_NAME);\n-        } else {\n-            StringBuilder outputFileNameBuilder;\n-            outputFileNameBuilder = new StringBuilder(\"stats_\");\n-            if (isNotEmpty(region)) {\n-                outputFileNameBuilder.append(region).append('_');\n-            }\n-            for (Iterator<String> iterator = cohortIds.iterator(); iterator.hasNext();) {\n-                String cohortId = iterator.next();\n-                outputFileNameBuilder.append(cohortId);\n-                if (iterator.hasNext()) {\n-                    outputFileNameBuilder.append('_');\n-                }\n-            }\n-            outputFileName = outputFileNameBuilder.toString();\n-        }\n-        return outputFileName;\n+  }\n+\n+  private VariantStorageEngine getVariantStorageEngine(DataStore dataStore) throws StorageEngineException {\n+    try {\n+      return StorageEngineFactory.get(variantStorageManager.getStorageConfiguration())\n+          .getVariantStorageEngine(dataStore.getStorageEngine(), dataStore.getDbName());\n+    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {\n+      throw new StorageEngineException(\"Unable to create StorageEngine\", e);\n     }\n-\n-    /**\n-     * Must provide a list of cohorts or a aggregation_mapping_properties file.\n-     * @param studyId   Study\n-     * @param aggregation Aggregation type for this study. {@link #getAggregation}\n-     * @param cohorts   List of cohorts\n-     * @param sessionId User's sessionId\n-     * @return          Checked list of cohorts\n-     * @throws CatalogException if an error on Catalog\n-     * @throws IOException if an IO error reading the aggregation map file (if any)\n-     */\n-    protected List<String> checkCohorts(String studyId, Aggregation aggregation, List<String> cohorts, String sessionId)\n-            throws CatalogException, IOException {\n-        List<String> cohortIds;\n-\n-        // Check aggregation mapping properties\n-        String tagMap = params.getString(Options.AGGREGATION_MAPPING_PROPERTIES.key());\n-        List<String> cohortsByAggregationMapFile = Collections.emptyList();\n-        if (!isBlank(tagMap)) {\n-            if (!AggregationUtils.isAggregated(aggregation)) {\n-                throw nonAggregatedWithMappingFile();\n-            }\n-            cohortsByAggregationMapFile = createCohortsByAggregationMapFile(studyId, tagMap, sessionId);\n-        } else if (AggregationUtils.isAggregated(aggregation)) {\n-            if (aggregation.equals(Aggregation.BASIC)) {\n-                cohortsByAggregationMapFile = createCohortsIfNeeded(studyId, Collections.singleton(StudyEntry.DEFAULT_COHORT), sessionId);\n-            } else {\n-                throw missingAggregationMappingFile(aggregation);\n-            }\n-        }\n-\n-        if (cohorts == null || cohorts.isEmpty()) {\n-            // If no aggregation map file provided\n-            if (cohortsByAggregationMapFile.isEmpty()) {\n-                throw missingCohorts();\n-            } else {\n-                cohortIds = cohortsByAggregationMapFile;\n-            }\n-        } else {\n-            cohortIds = new ArrayList<>(cohorts.size());\n-            for (String cohort : cohorts) {\n-                String cohortId = catalogManager.getCohortManager().get(studyId, cohort,\n-                        new QueryOptions(QueryOptions.INCLUDE, CohortDBAdaptor.QueryParams.ID.key()), sessionId).first().getId();\n-                cohortIds.add(cohortId);\n-            }\n-            if (!cohortsByAggregationMapFile.isEmpty()) {\n-                if (cohortIds.size() != cohortsByAggregationMapFile.size() || !cohortIds.containsAll(cohortsByAggregationMapFile)) {\n-                    throw differentCohortsThanMappingFile();\n-                }\n-            }\n+  }\n+\n+  protected String buildOutputFileName(List<String> cohortIds, String region) {\n+    final String outputFileName;\n+    if (isNotEmpty(params.getString(DefaultVariantStatisticsManager.OUTPUT_FILE_NAME))) {\n+      outputFileName = params.getString(DefaultVariantStatisticsManager.OUTPUT_FILE_NAME);\n+    } else {\n+      StringBuilder outputFileNameBuilder;\n+      outputFileNameBuilder = new StringBuilder(\"stats_\");\n+      if (isNotEmpty(region)) {\n+        outputFileNameBuilder.append(region).append('_');\n+      }\n+      for (Iterator<String> iterator = cohortIds.iterator(); iterator.hasNext(); ) {\n+        String cohortId = iterator.next();\n+        outputFileNameBuilder.append(cohortId);\n+        if (iterator.hasNext()) {\n+          outputFileNameBuilder.append('_');\n         }\n-        return cohortIds;\n+      }\n+      outputFileName = outputFileNameBuilder.toString();\n     }\n-\n-    private List<String> createCohortsByAggregationMapFile(String studyId, String aggregationMapFile, String sessionId)\n-            throws IOException, CatalogException {\n-        Properties tagmap = readAggregationMappingFile(aggregationMapFile);\n-        Set<String> cohortNames = VariantAggregatedStatsCalculator.getCohorts(tagmap);\n-        return createCohortsIfNeeded(studyId, cohortNames, sessionId);\n+    return outputFileName;\n+  }\n+\n+  /**\n+   * Must provide a list of cohorts or a aggregation_mapping_properties file.\n+   *\n+   * @param studyId     Study\n+   * @param aggregation Aggregation type for this study. {@link #getAggregation}\n+   * @param cohorts     List of cohorts\n+   * @param sessionId   User's sessionId\n+   * @return Checked list of cohorts\n+   * @throws CatalogException if an error on Catalog\n+   * @throws IOException      if an IO error reading the aggregation map file (if any)\n+   */\n+  protected List<String> checkCohorts(String studyId, Aggregation aggregation, List<String> cohorts, String sessionId)\n+      throws CatalogException, IOException {\n+    List<String> cohortIds;\n+\n+    // Check aggregation mapping properties\n+    String tagMap = params.getString(Options.AGGREGATION_MAPPING_PROPERTIES.key());\n+    List<String> cohortsByAggregationMapFile = Collections.emptyList();\n+    if (!isBlank(tagMap)) {\n+      if (!AggregationUtils.isAggregated(aggregation)) {\n+        throw nonAggregatedWithMappingFile();\n+      }\n+      cohortsByAggregationMapFile = createCohortsByAggregationMapFile(studyId, tagMap, sessionId);\n+    } else if (AggregationUtils.isAggregated(aggregation)) {\n+      if (aggregation.equals(Aggregation.BASIC)) {\n+        cohortsByAggregationMapFile = createCohortsIfNeeded(studyId, Collections.singleton(StudyEntry.DEFAULT_COHORT), sessionId);\n+      } else {\n+        throw missingAggregationMappingFile(aggregation);\n+      }\n     }\n \n-    private Properties readAggregationMappingFile(String aggregationMapFile) throws IOException {\n-        Properties tagmap = new Properties();\n-        try (InputStream is = FileUtils.newInputStream(Paths.get(aggregationMapFile))) {\n-            tagmap.load(is);\n+    if (cohorts == null || cohorts.isEmpty()) {\n+      // If no aggregation map file provided\n+      if (cohortsByAggregationMapFile.isEmpty()) {\n+        throw missingCohorts();\n+      } else {\n+        cohortIds = cohortsByAggregationMapFile;\n+      }\n+    } else {\n+      cohortIds = new ArrayList<>(cohorts.size());\n+      for (String cohort : cohorts) {\n+        String cohortId = catalogManager.getCohortManager().get(studyId, cohort,\n+            new QueryOptions(QueryOptions.INCLUDE, CohortDBAdaptor.QueryParams.ID.key()), sessionId).first().getId();\n+        cohortIds.add(cohortId);\n+      }\n+      if (!cohortsByAggregationMapFile.isEmpty()) {\n+        if (cohortIds.size() != cohortsByAggregationMapFile.size() || !cohortIds.containsAll(cohortsByAggregationMapFile)) {\n+          throw differentCohortsThanMappingFile();\n         }\n-        return tagmap;\n+      }\n     }\n-\n-    private List<String> createCohortsIfNeeded(String studyId, Set<String> cohortNames, String sessionId) throws CatalogException {\n-        List<String> cohorts = new ArrayList<>();\n-        // Silent query, so it does not fail for missing cohorts\n-        Set<String> catalogCohorts = catalogManager.getCohortManager().get(studyId, new ArrayList<>(cohortNames),\n-                new QueryOptions(QueryOptions.INCLUDE, \"name,id\"), true, sessionId)\n-                .getResults()\n-                .stream()\n-                .filter(Objects::nonNull)\n-                .map(Cohort::getId)\n-                .collect(Collectors.toSet());\n-        for (String cohortName : cohortNames) {\n-            if (!catalogCohorts.contains(cohortName)) {\n-                DataResult<Cohort> cohort = catalogManager.getCohortManager().create(studyId, cohortName, Study.Type.COLLECTION, \"\",\n-                        Collections.emptyList(), null, null, sessionId);\n-                logger.info(\"Creating cohort {}\", cohortName);\n-                cohorts.add(cohort.first().getId());\n-            } else {\n-                logger.debug(\"cohort {} was already created\", cohortName);\n-                cohorts.add(cohortName);\n-            }\n-        }\n-        return cohorts;\n+    return cohortIds;\n+  }\n+\n+  private List<String> createCohortsByAggregationMapFile(String studyId, String aggregationMapFile, String sessionId)\n+      throws IOException, CatalogException {\n+    Properties tagmap = readAggregationMappingFile(aggregationMapFile);\n+    Set<String> cohortNames = VariantAggregatedStatsCalculator.getCohorts(tagmap);\n+    return createCohortsIfNeeded(studyId, cohortNames, sessionId);\n+  }\n+\n+  private Properties readAggregationMappingFile(String aggregationMapFile) throws IOException {\n+    Properties tagmap = new Properties();\n+    try (InputStream is = FileUtils.newInputStream(Paths.get(aggregationMapFile))) {\n+      tagmap.load(is);\n     }\n-\n-    /**\n-     * Check if a set of given cohorts are available to calculate statistics.\n-     *\n-     * @param studyFqn      Study fqn\n-     * @param cohortIds     Set of cohorts\n-     * @param updateStats   Update already existing stats\n-     * @param resume        Resume statistics calculation\n-     * @param sessionId     User's sessionId\n-     * @return Map from cohortId to Cohort\n-     * @throws CatalogException if an error on Catalog\n-     */\n-    protected Map<String, List<String>> checkCanCalculateCohorts(String studyFqn, List<String> cohortIds,\n-                                                         boolean updateStats, boolean resume, String sessionId)\n-            throws CatalogException {\n+    return tagmap;\n+  }\n+\n+  private List<String> createCohortsIfNeeded(String studyId, Set<String> cohortNames, String sessionId) throws CatalogException {\n+    List<String> cohorts = new ArrayList<>();\n+    // Silent query, so it does not fail for missing cohorts\n+    Set<String> catalogCohorts = catalogManager.getCohortManager().get(studyId, new ArrayList<>(cohortNames),\n+        new QueryOptions(QueryOptions.INCLUDE, \"name,id\"), true, sessionId)\n+        .getResults()\n+        .stream()\n+        .filter(Objects::nonNull)\n+        .map(Cohort::getId)\n+        .collect(Collectors.toSet());\n+    for (String cohortName : cohortNames) {\n+      if (!catalogCohorts.contains(cohortName)) {\n+        DataResult<Cohort> cohort = catalogManager.getCohortManager().create(studyId, cohortName, Study.Type.COLLECTION, \"\",\n+            Collections.emptyList(), null, null, sessionId);\n+        logger.info(\"Creating cohort {}\", cohortName);\n+        cohorts.add(cohort.first().getId());\n+      } else {\n+        logger.debug(\"cohort {} was already created\", cohortName);\n+        cohorts.add(cohortName);\n+      }\n+    }\n+    return cohorts;\n+  }\n+\n+  /**\n+   * Check if a set of given cohorts are available to calculate statistics.\n+   *\n+   * @param studyFqn    Study fqn\n+   * @param cohortIds   Set of cohorts\n+   * @param updateStats Update already existing stats\n+   * @param resume      Resume statistics calculation\n+   * @param sessionId   User's sessionId\n+   * @return Map from cohortId to Cohort\n+   * @throws CatalogException if an error on Catalog\n+   */\n+  protected Map<String, List<String>> checkCanCalculateCohorts(String studyFqn, List<String> cohortIds,\n+                                                               boolean updateStats, boolean resume, String sessionId)\n+      throws CatalogException {\n //        Set<Long> studyIdSet = new HashSet<>();\n-        Map<String, List<String>> cohortMap = new HashMap<>(cohortIds.size());\n-        for (String cohortId : cohortIds) {\n-            Cohort cohort = catalogManager.getCohortManager().get(studyFqn, cohortId, null, sessionId)\n-                    .first();\n+    Map<String, List<String>> cohortMap = new HashMap<>(cohortIds.size());\n+    for (String cohortId : cohortIds) {\n+      Cohort cohort = catalogManager.getCohortManager().get(studyFqn, cohortId, null, sessionId)\n+          .first();\n //            long studyIdByCohortId = catalogManager.getCohortManager().getStudyId(cohortUid);\n //            studyIdSet.add(studyIdByCohortId);\n-            switch (cohort.getStatus().getName()) {\n-                case Cohort.CohortStatus.NONE:\n-                case Cohort.CohortStatus.INVALID:\n-                    break;\n-                case Cohort.CohortStatus.READY:\n-                    if (updateStats) {\n-                        catalogManager.getCohortManager().setStatus(studyFqn, cohortId, Cohort.CohortStatus.INVALID, \"\", sessionId);\n-                        break;\n-                    } else {\n-                        // If not updating the stats or resuming, can't calculate statistics for a cohort READY\n-                        if (!resume) {\n-                            throw unableToCalculateCohortReady(cohort);\n-                        }\n-                    }\n-                    break;\n-                case Cohort.CohortStatus.CALCULATING:\n-                    if (!resume) {\n-                        throw unableToCalculateCohortCalculating(cohort);\n-                    }\n-                    break;\n-                default:\n-                    throw new IllegalStateException(\"Unknown status \" + cohort.getStatus().getName());\n+      switch (cohort.getStatus().getName()) {\n+        case Cohort.CohortStatus.NONE:\n+        case Cohort.CohortStatus.INVALID:\n+          break;\n+        case Cohort.CohortStatus.READY:\n+          if (updateStats) {\n+            catalogManager.getCohortManager().setStatus(studyFqn, cohortId, Cohort.CohortStatus.INVALID, \"\", sessionId);\n+            break;\n+          } else {\n+            // If not updating the stats or resuming, can't calculate statistics for a cohort READY\n+            if (!resume) {\n+              throw unableToCalculateCohortReady(cohort);\n             }\n-            cohortMap.put(cohort.getId(), cohort.getSamples().stream().map(Sample::getId).collect(Collectors.toList()));\n+          }\n+          break;\n+        case Cohort.CohortStatus.CALCULATING:\n+          if (!resume) {\n+            throw unableToCalculateCohortCalculating(cohort);\n+          }\n+          break;\n+        default:\n+          throw new IllegalStateException(\"Unknown status \" + cohort.getStatus().getName());\n+      }\n+      cohortMap.put(cohort.getId(), cohort.getSamples().stream().map(Sample::getId).collect(Collectors.toList()));\n //            DataResult<Sample> sampleDataResult = catalogManager.getAllSamples(studyIdByCohortId, new Query(\"id\", cohort.getSamples()),\n //                      new QueryOptions(), sessionId);\n-        }\n+    }\n \n-        // Check that all cohorts are from the same study\n-        // All cohorts are from the same study, as the study is a required parameter.\n+    // Check that all cohorts are from the same study\n+    // All cohorts are from the same study, as the study is a required parameter.\n //        if (studyIdSet.size() != 1) {\n //            throw new CatalogException(\"Error: CohortIds are from multiple studies: \" + studyIdSet.toString());\n //        }\n //        if (!new ArrayList<>(studyIdSet).get(0).equals(studyFqn)) {\n //            throw new CatalogException(\"Error: CohortIds are from a different study than provided: \" + studyIdSet.toString());\n //        }\n-        return cohortMap;\n-    }\n-\n-    protected void updateCohorts(String studyId, List<String> cohortIds, String sessionId, String status, String message)\n-            throws CatalogException {\n-        for (String cohortId : cohortIds) {\n-            catalogManager.getCohortManager().setStatus(studyId, cohortId, status, message, sessionId);\n-        }\n-    }\n-\n-    /**\n-     * If the study is aggregated and a mapping file is provided, pass it to\n-     * and create in catalog the cohorts described in the mapping file.\n-     *\n-     * If the study aggregation was not defined, updateStudy with the provided aggregation type\n-     *\n-     * @param catalogManager CatalogManager\n-     * @param studyId   StudyId where calculate stats\n-     * @param options   Options\n-     * @param sessionId Users sessionId\n-     * @return          Effective study aggregation type\n-     * @throws CatalogException if something is wrong with catalog\n-     */\n-    public static Aggregation getAggregation(CatalogManager catalogManager, String studyId, ObjectMap options, String sessionId)\n-            throws CatalogException {\n-        QueryOptions include = new QueryOptions(QueryOptions.INCLUDE, StudyDBAdaptor.QueryParams.ATTRIBUTES.key());\n-        Study study = catalogManager.getStudyManager().get(studyId, include, sessionId).first();\n-        Aggregation argsAggregation = options.get(Options.AGGREGATED_TYPE.key(), Aggregation.class, Aggregation.NONE);\n-        Object studyAggregationObj = study.getAttributes().get(Options.AGGREGATED_TYPE.key());\n-        Aggregation studyAggregation = null;\n-        if (studyAggregationObj != null) {\n-            studyAggregation = AggregationUtils.valueOf(studyAggregationObj.toString());\n-        }\n-\n-        final Aggregation aggregation;\n-        if (AggregationUtils.isAggregated(argsAggregation)) {\n-            if (studyAggregation != null && !studyAggregation.equals(argsAggregation)) {\n-                // FIXME: Throw an exception?\n-                LoggerFactory.getLogger(StorageOperation.class)\n-                        .warn(\"Calculating statistics with aggregation \" + argsAggregation + \" instead of \" + studyAggregation);\n-            }\n-            aggregation = argsAggregation;\n-            // If studyAggregation is not define, update study aggregation\n-            if (studyAggregation == null) {\n-                //update study aggregation\n-                Map<String, Aggregation> attributes = Collections.singletonMap(Options.AGGREGATED_TYPE.key(),\n-                        argsAggregation);\n-                ObjectMap parameters = new ObjectMap(\"attributes\", attributes);\n-                catalogManager.getStudyManager().update(studyId, parameters, null, sessionId);\n-            }\n-        } else {\n-            if (studyAggregation == null) {\n-                aggregation = Aggregation.NONE;\n-            } else {\n-                aggregation = studyAggregation;\n-            }\n-        }\n-        return aggregation;\n-    }\n-\n-    static CatalogException differentCohortsThanMappingFile() throws CatalogException {\n-        return new CatalogException(\"Given cohorts (if any) must match with cohorts in the aggregation mapping file.\");\n-    }\n+    return cohortMap;\n+  }\n \n-    static CatalogException missingCohorts() throws CatalogException {\n-        return new CatalogException(\"Cohort list null or empty\");\n+  protected void updateCohorts(String studyId, List<String> cohortIds, String sessionId, String status, String message)\n+      throws CatalogException {\n+    for (String cohortId : cohortIds) {\n+      catalogManager.getCohortManager().setStatus(studyId, cohortId, status, message, sessionId);\n     }\n-\n-    static IllegalArgumentException missingAggregationMappingFile(Aggregation aggregation) {\n-        return new IllegalArgumentException(\"Unable to calculate statistics for an aggregated study of type \"\n-                + \"\\\"\" + aggregation + \"\\\" without an aggregation mapping file.\");\n-    }\n-\n-    static IllegalArgumentException nonAggregatedWithMappingFile() {\n-        return new IllegalArgumentException(\"Unable to use an aggregation mapping file for non aggregated study\");\n-    }\n-\n-\n-    static CatalogException unableToCalculateCohortReady(Cohort cohort) {\n-        return new CatalogException(\"Unable to calculate stats for cohort \"\n-                + \"{ uid: \" + cohort.getUid() + \" id: \\\"\" + cohort.getId() + \"\\\" }\"\n-                + \" with status \\\"\" + cohort.getStatus().getName() + \"\\\". \"\n-                + \"Resume or update stats for continue calculation\");\n+  }\n+\n+  /**\n+   * If the study is aggregated and a mapping file is provided, pass it to\n+   * and create in catalog the cohorts described in the mapping file.\n+   * <p>\n+   * If the study aggregation was not defined, updateStudy with the provided aggregation type\n+   *\n+   * @param catalogManager CatalogManager\n+   * @param studyId        StudyId where calculate stats\n+   * @param options        Options\n+   * @param sessionId      Users sessionId\n+   * @return Effective study aggregation type\n+   * @throws CatalogException if something is wrong with catalog\n+   */\n+  public static Aggregation getAggregation(CatalogManager catalogManager, String studyId, ObjectMap options, String sessionId)\n+      throws CatalogException {\n+    QueryOptions include = new QueryOptions(QueryOptions.INCLUDE, StudyDBAdaptor.QueryParams.ATTRIBUTES.key());\n+    Study study = catalogManager.getStudyManager().get(studyId, include, sessionId).first();\n+    Aggregation argsAggregation = options.get(Options.AGGREGATED_TYPE.key(), Aggregation.class, Aggregation.NONE);\n+    Object studyAggregationObj = study.getAttributes().get(Options.AGGREGATED_TYPE.key());\n+    Aggregation studyAggregation = null;\n+    if (studyAggregationObj != null) {\n+      studyAggregation = AggregationUtils.valueOf(studyAggregationObj.toString());\n     }\n \n-    static CatalogException unableToCalculateCohortCalculating(Cohort cohort) {\n-        return new CatalogException(\"Unable to calculate stats for cohort \"\n-                + \"{ uid: \" + cohort.getUid() + \" id: \\\"\" + cohort.getId() + \"\\\" }\"\n-                + \" with status \\\"\" + cohort.getStatus().getName() + \"\\\". \"\n-                + \"Resume for continue calculation.\");\n+    final Aggregation aggregation;\n+    if (AggregationUtils.isAggregated(argsAggregation)) {\n+      if (studyAggregation != null && !studyAggregation.equals(argsAggregation)) {\n+        // FIXME: Throw an exception?\n+        LoggerFactory.getLogger(StorageOperation.class)\n+            .warn(\"Calculating statistics with aggregation \" + argsAggregation + \" instead of \" + studyAggregation);\n+      }\n+      aggregation = argsAggregation;\n+      // If studyAggregation is not define, update study aggregation\n+      if (studyAggregation == null) {\n+        //update study aggregation\n+        Map<String, Aggregation> attributes = Collections.singletonMap(Options.AGGREGATED_TYPE.key(),\n+            argsAggregation);\n+        ObjectMap parameters = new ObjectMap(\"attributes\", attributes);\n+        catalogManager.getStudyManager().update(studyId, parameters, null, sessionId);\n+      }\n+    } else {\n+      if (studyAggregation == null) {\n+        aggregation = Aggregation.NONE;\n+      } else {\n+        aggregation = studyAggregation;\n+      }\n     }\n+    return aggregation;\n+  }\n+\n+  static CatalogException differentCohortsThanMappingFile() throws CatalogException {\n+    return new CatalogException(\"Given cohorts (if any) must match with cohorts in the aggregation mapping file.\");\n+  }\n+\n+  static CatalogException missingCohorts() throws CatalogException {\n+    return new CatalogException(\"Cohort list null or empty\");\n+  }\n+\n+  static IllegalArgumentException missingAggregationMappingFile(Aggregation aggregation) {\n+    return new IllegalArgumentException(\"Unable to calculate statistics for an aggregated study of type \"\n+        + \"\\\"\" + aggregation + \"\\\" without an aggregation mapping file.\");\n+  }\n+\n+  static IllegalArgumentException nonAggregatedWithMappingFile() {\n+    return new IllegalArgumentException(\"Unable to use an aggregation mapping file for non aggregated study\");\n+  }\n+\n+\n+  static CatalogException unableToCalculateCohortReady(Cohort cohort) {\n+    return new CatalogException(\"Unable to calculate stats for cohort \"\n+        + \"{ uid: \" + cohort.getUid() + \" id: \\\"\" + cohort.getId() + \"\\\" }\"\n+        + \" with status \\\"\" + cohort.getStatus().getName() + \"\\\". \"\n+        + \"Resume or update stats for continue calculation\");\n+  }\n+\n+  static CatalogException unableToCalculateCohortCalculating(Cohort cohort) {\n+    return new CatalogException(\"Unable to calculate stats for cohort \"\n+        + \"{ uid: \" + cohort.getUid() + \" id: \\\"\" + cohort.getId() + \"\\\" }\"\n+        + \" with status \\\"\" + cohort.getStatus().getName() + \"\\\". \"\n+        + \"Resume for continue calculation.\");\n+  }\n \n }\n",
            "diff_size": 473
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "106",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 156).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/203/VariantStatsStorageOperation.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/203/VariantStatsStorageOperation.java\nindex 827d11d79b0..66d0639b6f8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/203/VariantStatsStorageOperation.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/203/VariantStatsStorageOperation.java\n@@ -179,7 +179,8 @@ public class VariantStatsStorageOperation extends OpenCgaAnalysis {\n             if (isNotEmpty(region)) {\n                 outputFileNameBuilder.append(region).append('_');\n             }\n-            for (Iterator<String> iterator = cohortIds.iterator(); iterator.hasNext();) {\n+            for (Iterator<String> iterator = cohortIds.iterator();\n+iterator.hasNext();) {\n                 String cohortId = iterator.next();\n                 outputFileNameBuilder.append(cohortId);\n                 if (iterator.hasNext()) {\n@@ -432,4 +433,4 @@ public class VariantStatsStorageOperation extends OpenCgaAnalysis {\n                 + \"Resume for continue calculation.\");\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "106",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 156).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}