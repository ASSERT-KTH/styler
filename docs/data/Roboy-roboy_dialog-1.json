{
    "project_name": "Roboy-roboy_dialog",
    "error_id": "1",
    "information": {
        "errors": [
            {
                "line": "77",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "        return new ArithmeticFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n    }\n    \n    { // ActionFormula\n      ActionFormula.Mode mode = ActionFormula.parseMode(func);\n      if (mode != null) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler/1/Formulas.java\nindex 94a22c87a6f..59fde609ff1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler/1/Formulas.java\n@@ -74,7 +74,7 @@ public abstract class Formulas {\n       if (mode != null)\n         return new ArithmeticFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n     }\n-    \n+\n     { // ActionFormula\n       ActionFormula.Mode mode = ActionFormula.parseMode(func);\n       if (mode != null) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/intellij/1/Formulas.java\nindex 94a22c87a6f..cd5f378b1ba 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/intellij/1/Formulas.java\n@@ -14,399 +14,442 @@ import java.util.Set;\n  * @author Percy Liang\n  */\n public abstract class Formulas {\n-  public static Formula fromLispTree(LispTree tree) {\n-    // Try to interpret as ValueFormula\n-    if (tree.isLeaf())  // Leaves are name values\n-      return new ValueFormula<NameValue>(new NameValue(tree.value, null));\n-    Value value = Values.fromLispTreeOrNull(tree);  // General case\n-    if (value != null)\n-      return new ValueFormula<Value>(value);\n-\n-    String func = tree.child(0).value;\n-    if (func != null) {\n-      if (func.equals(\"var\"))\n-        return new VariableFormula(tree.child(1).value);\n-      if (func.equals(\"lambda\"))\n-        return new LambdaFormula(tree.child(1).value, fromLispTree(tree.child(2)));\n-      if (func.equals(\"mark\"))\n-        return new MarkFormula(tree.child(1).value, fromLispTree(tree.child(2)));\n-      if (func.equals(\"not\"))\n-        return new NotFormula(fromLispTree(tree.child(1)));\n-      if (func.equals(\"reverse\"))\n-        return new ReverseFormula(fromLispTree(tree.child(1)));\n-      if (func.equals(\"call\")) {\n-        Formula callFunc = fromLispTree(tree.child(1));\n-        List<Formula> args = Lists.newArrayList();\n-        for (int i = 2; i < tree.children.size(); i++)\n-          args.add(fromLispTree(tree.child(i)));\n-        return new CallFormula(callFunc, args);\n-      }\n-    }\n+    public static Formula fromLispTree(LispTree tree) {\n+        // Try to interpret as ValueFormula\n+        if (tree.isLeaf())  // Leaves are name values\n+        {\n+            return new ValueFormula<NameValue>(new NameValue(tree.value, null));\n+        }\n+        Value value = Values.fromLispTreeOrNull(tree);  // General case\n+        if (value != null) {\n+            return new ValueFormula<Value>(value);\n+        }\n+\n+        String func = tree.child(0).value;\n+        if (func != null) {\n+            if (func.equals(\"var\")) {\n+                return new VariableFormula(tree.child(1).value);\n+            }\n+            if (func.equals(\"lambda\")) {\n+                return new LambdaFormula(tree.child(1).value, fromLispTree(tree.child(2)));\n+            }\n+            if (func.equals(\"mark\")) {\n+                return new MarkFormula(tree.child(1).value, fromLispTree(tree.child(2)));\n+            }\n+            if (func.equals(\"not\")) {\n+                return new NotFormula(fromLispTree(tree.child(1)));\n+            }\n+            if (func.equals(\"reverse\")) {\n+                return new ReverseFormula(fromLispTree(tree.child(1)));\n+            }\n+            if (func.equals(\"call\")) {\n+                Formula callFunc = fromLispTree(tree.child(1));\n+                List<Formula> args = Lists.newArrayList();\n+                for (int i = 2; i < tree.children.size(); i++) {\n+                    args.add(fromLispTree(tree.child(i)));\n+                }\n+                return new CallFormula(callFunc, args);\n+            }\n+        }\n+\n+        { // Merge: (and (fb:type.object.type fb:people.person) (fb:people.person.children fb:en.barack_obama))\n+            MergeFormula.Mode mode = MergeFormula.parseMode(func);\n+            if (mode != null) {\n+                return new MergeFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n+            }\n+        }\n+\n+        { // Aggregate: (count (fb:type.object.type fb:people.person))\n+            AggregateFormula.Mode mode = AggregateFormula.parseMode(func);\n+            if (mode != null) {\n+                return new AggregateFormula(mode, fromLispTree(tree.child(1)));\n+            }\n+        }\n+\n+        { // Superlative: (argmax 1 1 (fb:type.object.type fb:people.person) (lambda x (!fb:people.person.height_meters (var x))))\n+            SuperlativeFormula.Mode mode = SuperlativeFormula.parseMode(func);\n+            if (mode != null) {\n+                Formula rank = parseIntToFormula(tree.child(1));\n+                Formula count = parseIntToFormula(tree.child(2));\n+                return new SuperlativeFormula(\n+                    mode,\n+                    rank,\n+                    count,\n+                    fromLispTree(tree.child(3)),\n+                    fromLispTree(tree.child(4)));\n+            }\n+        }\n+\n+        { // Arithmetic: (- (!fb:people.person.height_meters (var x)) (!fb:people.person.height_meters (var y)))\n+            ArithmeticFormula.Mode mode = ArithmeticFormula.parseMode(func);\n+            if (mode != null) {\n+                return new ArithmeticFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n+            }\n+        }\n \n-    { // Merge: (and (fb:type.object.type fb:people.person) (fb:people.person.children fb:en.barack_obama))\n-      MergeFormula.Mode mode = MergeFormula.parseMode(func);\n-      if (mode != null)\n-        return new MergeFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n+        { // ActionFormula\n+            ActionFormula.Mode mode = ActionFormula.parseMode(func);\n+            if (mode != null) {\n+                List<Formula> args = Lists.newArrayList();\n+                for (int i = 1; i < tree.children.size(); i++) {\n+                    args.add(fromLispTree(tree.child(i)));\n+                }\n+                return new ActionFormula(mode, args);\n+            }\n+        }\n+\n+        // Default is join: (fb:type.object.type fb:people.person)\n+        if (tree.children.size() != 2) {\n+            throw new RuntimeException(\"Invalid number of arguments for join (want 2): \" + tree);\n+        }\n+        return new JoinFormula(fromLispTree(tree.child(0)), fromLispTree(tree.child(1)));\n     }\n \n-    { // Aggregate: (count (fb:type.object.type fb:people.person))\n-      AggregateFormula.Mode mode = AggregateFormula.parseMode(func);\n-      if (mode != null)\n-        return new AggregateFormula(mode, fromLispTree(tree.child(1)));\n+    // Special case to enable \"argmax 1 1\" rather than \"argmax (number 1) (number 1)\"\n+    private static Formula parseIntToFormula(LispTree tree) {\n+        try {\n+            int i = Integer.parseInt(tree.value);\n+            double d = i;\n+            NumberValue value = new NumberValue(d);\n+            return new ValueFormula(value);\n+        } catch (NumberFormatException e) {\n+            Formula formula = fromLispTree(tree);\n+            if (!(formula instanceof PrimitiveFormula)) {\n+                throw new RuntimeException(\"Rank and count of argmax must be variables or numbers\");\n+            }\n+            return formula;\n+        }\n     }\n \n-    { // Superlative: (argmax 1 1 (fb:type.object.type fb:people.person) (lambda x (!fb:people.person.height_meters (var x))))\n-      SuperlativeFormula.Mode mode = SuperlativeFormula.parseMode(func);\n-      if (mode != null) {\n-        Formula rank = parseIntToFormula(tree.child(1));\n-        Formula count = parseIntToFormula(tree.child(2));\n-        return new SuperlativeFormula(\n-            mode,\n-            rank,\n-            count,\n-            fromLispTree(tree.child(3)),\n-            fromLispTree(tree.child(4)));\n-      }\n+    // Replace occurrences of the variable reference |var| with |formula|.\n+    public static Formula substituteVar(Formula formula, final String var, final Formula replaceFormula) {\n+        return formula.map(\n+            new Function<Formula, Formula>() {\n+                public Formula apply(Formula formula) {\n+                    if (formula instanceof VariableFormula) {  // Replace variable\n+                        String name = ((VariableFormula) formula).name;\n+                        return var.equals(name) ? replaceFormula : formula;\n+                    } else if (formula instanceof LambdaFormula) {\n+                        if (((LambdaFormula) formula).var.equals(var)) // |var| is bound, so don't substitute inside\n+                        {\n+                            return formula;\n+                        }\n+                    }\n+                    return null;\n+                }\n+            });\n     }\n \n-    { // Arithmetic: (- (!fb:people.person.height_meters (var x)) (!fb:people.person.height_meters (var y)))\n-      ArithmeticFormula.Mode mode = ArithmeticFormula.parseMode(func);\n-      if (mode != null)\n-        return new ArithmeticFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n+    // Replace top-level occurrences of |searchFormula| inside |formula| with |replaceFormula|.\n+    public static Formula substituteFormula(Formula formula, final Formula searchFormula,\n+                                            final Formula replaceFormula) {\n+        return formula.map(\n+            new Function<Formula, Formula>() {\n+                public Formula apply(Formula formula) {\n+                    if (formula.equals(searchFormula)) {\n+                        return replaceFormula;\n+                    }\n+                    return null;\n+                }\n+            });\n     }\n-    \n-    { // ActionFormula\n-      ActionFormula.Mode mode = ActionFormula.parseMode(func);\n-      if (mode != null) {\n-        List<Formula> args = Lists.newArrayList();\n-        for (int i = 1; i < tree.children.size(); i++)\n-          args.add(fromLispTree(tree.child(i)));\n-        return new ActionFormula(mode, args);\n-      }\n+\n+    // Beta-reduction.\n+    public static Formula lambdaApply(LambdaFormula func, Formula arg) {\n+        return substituteVar(func.body, func.var, arg);\n     }\n \n-    // Default is join: (fb:type.object.type fb:people.person)\n-    if (tree.children.size() != 2)\n-      throw new RuntimeException(\"Invalid number of arguments for join (want 2): \" + tree);\n-    return new JoinFormula(fromLispTree(tree.child(0)), fromLispTree(tree.child(1)));\n-  }\n-\n-  // Special case to enable \"argmax 1 1\" rather than \"argmax (number 1) (number 1)\"\n-  private static Formula parseIntToFormula(LispTree tree) {\n-    try {\n-      int i = Integer.parseInt(tree.value);\n-      double d = i;\n-      NumberValue value = new NumberValue(d);\n-      return new ValueFormula(value);\n-    } catch (NumberFormatException e) {\n-      Formula formula = fromLispTree(tree);\n-      if (!(formula instanceof PrimitiveFormula))\n-        throw new RuntimeException(\"Rank and count of argmax must be variables or numbers\");\n-      return formula;\n+    // Apply all the nested LambdaFormula's.\n+    public static Formula betaReduction(Formula formula) {\n+        return formula.map(\n+            new Function<Formula, Formula>() {\n+                public Formula apply(Formula formula) {\n+                    if (formula instanceof JoinFormula) {\n+                        Formula relation = betaReduction(((JoinFormula) formula).relation);\n+                        Formula child = ((JoinFormula) formula).child;\n+                        if (relation instanceof LambdaFormula) {\n+                            return betaReduction(lambdaApply((LambdaFormula) relation, child));\n+                        }\n+                    }\n+                    return null;\n+                }\n+            });\n     }\n-  }\n-\n-  // Replace occurrences of the variable reference |var| with |formula|.\n-  public static Formula substituteVar(Formula formula, final String var, final Formula replaceFormula) {\n-    return formula.map(\n-        new Function<Formula, Formula>() {\n-          public Formula apply(Formula formula) {\n-            if (formula instanceof VariableFormula) {  // Replace variable\n-              String name = ((VariableFormula) formula).name;\n-              return var.equals(name) ? replaceFormula : formula;\n-            } else if (formula instanceof LambdaFormula) {\n-              if (((LambdaFormula) formula).var.equals(var)) // |var| is bound, so don't substitute inside\n-                return formula;\n-            }\n-            return null;\n-          }\n-        });\n-  }\n-\n-  // Replace top-level occurrences of |searchFormula| inside |formula| with |replaceFormula|.\n-  public static Formula substituteFormula(Formula formula, final Formula searchFormula, final Formula replaceFormula) {\n-    return formula.map(\n-        new Function<Formula, Formula>() {\n-          public Formula apply(Formula formula) {\n-            if (formula.equals(searchFormula)) return replaceFormula;\n-            return null;\n-          }\n-        });\n-  }\n-\n-  // Beta-reduction.\n-  public static Formula lambdaApply(LambdaFormula func, Formula arg) {\n-    return substituteVar(func.body, func.var, arg);\n-  }\n-\n-  // Apply all the nested LambdaFormula's.\n-  public static Formula betaReduction(Formula formula) {\n-    return formula.map(\n-        new Function<Formula, Formula>() {\n-          public Formula apply(Formula formula) {\n-            if (formula instanceof JoinFormula) {\n-              Formula relation = betaReduction(((JoinFormula) formula).relation);\n-              Formula child = ((JoinFormula) formula).child;\n-              if (relation instanceof LambdaFormula)\n-                return betaReduction(lambdaApply((LambdaFormula) relation, child));\n+\n+    // Return whether |formula| contains a free instance of |var|.\n+    public static boolean containsFreeVar(Formula formula, VariableFormula var) {\n+        if (formula instanceof PrimitiveFormula) {\n+            return formula.equals(var);\n+        }\n+        if (formula instanceof MergeFormula) {\n+            MergeFormula merge = (MergeFormula) formula;\n+            return containsFreeVar(merge.child1, var) || containsFreeVar(merge.child2, var);\n+        }\n+        if (formula instanceof JoinFormula) {\n+            JoinFormula join = (JoinFormula) formula;\n+            return containsFreeVar(join.relation, var) || containsFreeVar(join.child, var);\n+        }\n+        if (formula instanceof LambdaFormula) {\n+            LambdaFormula lambda = (LambdaFormula) formula;\n+            if (lambda.var.equals(var.name)) {\n+                return false;  // Blocked by bound variable\n             }\n-            return null;\n-          }\n-        });\n-  }\n-\n-  // Return whether |formula| contains a free instance of |var|.\n-  public static boolean containsFreeVar(Formula formula, VariableFormula var) {\n-    if (formula instanceof PrimitiveFormula)\n-      return formula.equals(var);\n-    if (formula instanceof MergeFormula) {\n-      MergeFormula merge = (MergeFormula) formula;\n-      return containsFreeVar(merge.child1, var) || containsFreeVar(merge.child2, var);\n-    }\n-    if (formula instanceof JoinFormula) {\n-      JoinFormula join = (JoinFormula) formula;\n-      return containsFreeVar(join.relation, var) || containsFreeVar(join.child, var);\n+            return containsFreeVar(lambda.body, var);\n+        }\n+        if (formula instanceof MarkFormula) {\n+            MarkFormula mark = (MarkFormula) formula;\n+            // Note: marks are transparent, unlike lambdas\n+            return containsFreeVar(mark.body, var);\n+        }\n+        if (formula instanceof ReverseFormula) {\n+            return containsFreeVar(((ReverseFormula) formula).child, var);\n+        }\n+        if (formula instanceof AggregateFormula) {\n+            return containsFreeVar(((AggregateFormula) formula).child, var);\n+        }\n+        if (formula instanceof ArithmeticFormula) {\n+            return containsFreeVar(((ArithmeticFormula) formula).child1, var) ||\n+                containsFreeVar(((ArithmeticFormula) formula).child2, var);\n+        }\n+        if (formula instanceof SuperlativeFormula) {\n+            SuperlativeFormula superlative = (SuperlativeFormula) formula;\n+            return containsFreeVar(superlative.rank, var) || containsFreeVar(superlative.count, var) ||\n+                containsFreeVar(superlative.head, var) || containsFreeVar(superlative.relation, var);\n+        }\n+        if (formula instanceof NotFormula) {\n+            NotFormula notForm = (NotFormula) formula;\n+            return containsFreeVar(notForm.child, var);\n+        }\n+        throw new RuntimeException(\"Unhandled: \" + formula);\n     }\n-    if (formula instanceof LambdaFormula) {\n-      LambdaFormula lambda = (LambdaFormula) formula;\n-      if (lambda.var.equals(var.name)) return false;  // Blocked by bound variable\n-      return containsFreeVar(lambda.body, var);\n-    }\n-    if (formula instanceof MarkFormula) {\n-      MarkFormula mark = (MarkFormula) formula;\n-      // Note: marks are transparent, unlike lambdas\n-      return containsFreeVar(mark.body, var);\n+\n+    // TODO(joberant): use Formula.map, and use CanonicalNames.isReverseProperty, etc.\n+    public static Set<String> extractAtomicFreebaseElements(Formula formula) {\n+        Set<String> res = new HashSet<>();\n+        LispTree formulaTree = formula.toLispTree();\n+        extractAtomicFreebaseElements(formulaTree, res);\n+        return res;\n     }\n-    if (formula instanceof ReverseFormula) {\n-      return containsFreeVar(((ReverseFormula) formula).child, var);\n+\n+    private static void extractAtomicFreebaseElements(LispTree formulaTree,\n+                                                      Set<String> res) {\n+        if (formulaTree.isLeaf()) {  // base\n+            if (formulaTree.value.startsWith(\"fb:\")) {\n+                res.add(formulaTree.value);\n+            } else if (formulaTree.value.startsWith(\"!fb:\")) {\n+                res.add(formulaTree.value.substring(1));\n+            }\n+        } else {  // recursion\n+            for (LispTree child : formulaTree.children) {\n+                extractAtomicFreebaseElements(child, res);\n+            }\n+        }\n     }\n-    if (formula instanceof AggregateFormula) {\n-      return containsFreeVar(((AggregateFormula) formula).child, var);\n+\n+    // TODO(jonathan): move to feature extractor (this function doesn't seem fundamental)\n+    public static boolean isCountFormula(Formula formula) {\n+        if (formula instanceof AggregateFormula) {\n+            return ((AggregateFormula) formula).mode == AggregateFormula.Mode.count;\n+        }\n+        if (formula instanceof JoinFormula) {\n+            Formula relation = ((JoinFormula) formula).relation;\n+            if (relation instanceof LambdaFormula) {\n+                Formula l = ((LambdaFormula) relation).body;\n+                if (l instanceof AggregateFormula) {\n+                    return ((AggregateFormula) l).mode == AggregateFormula.Mode.count;\n+                }\n+            }\n+        }\n+        return false;\n     }\n-    if (formula instanceof ArithmeticFormula) {\n-      return containsFreeVar(((ArithmeticFormula) formula).child1, var) || containsFreeVar(((ArithmeticFormula) formula).child2, var);\n+\n+    public static String getString(Formula formula) {\n+        if (formula instanceof ValueFormula) {\n+            Value value = ((ValueFormula) formula).value;\n+            if (value instanceof StringValue) {\n+                return ((StringValue) value).value;\n+            }\n+            if (value instanceof NameValue) {\n+                return ((NameValue) value).id;\n+            }\n+            if (value instanceof NumberValue) {\n+                return ((NumberValue) value).value + \"\";\n+            }\n+        } else if (formula instanceof VariableFormula) {\n+            return ((VariableFormula) formula).name;\n+        }\n+        return null;\n     }\n-    if (formula instanceof SuperlativeFormula) {\n-      SuperlativeFormula superlative = (SuperlativeFormula) formula;\n-      return containsFreeVar(superlative.rank, var) || containsFreeVar(superlative.count, var) || containsFreeVar(superlative.head, var) || containsFreeVar(superlative.relation, var);\n+\n+    public static String getNameId(Formula formula) {\n+        if (formula instanceof ValueFormula) {\n+            Value value = ((ValueFormula) formula).value;\n+            if (value instanceof NameValue) {\n+                return ((NameValue) value).id;\n+            }\n+        }\n+        return null;\n     }\n-    if (formula instanceof NotFormula) {\n-      NotFormula notForm = (NotFormula) formula;\n-      return containsFreeVar(notForm.child, var);\n+\n+    public static double getDouble(Formula formula) {\n+        if (formula instanceof ValueFormula) {\n+            Value value = ((ValueFormula) formula).value;\n+            if (value instanceof NumberValue) {\n+                return ((NumberValue) value).value;\n+            }\n+        }\n+        return Double.NaN;\n     }\n-    throw new RuntimeException(\"Unhandled: \" + formula);\n-  }\n-\n-  // TODO(joberant): use Formula.map, and use CanonicalNames.isReverseProperty, etc.\n-  public static Set<String> extractAtomicFreebaseElements(Formula formula) {\n-    Set<String> res = new HashSet<>();\n-    LispTree formulaTree = formula.toLispTree();\n-    extractAtomicFreebaseElements(formulaTree, res);\n-    return res;\n-  }\n-  private static void extractAtomicFreebaseElements(LispTree formulaTree,\n-                                                    Set<String> res) {\n-    if (formulaTree.isLeaf()) {  // base\n-      if (formulaTree.value.startsWith(\"fb:\"))\n-        res.add(formulaTree.value);\n-      else if (formulaTree.value.startsWith(\"!fb:\"))\n-        res.add(formulaTree.value.substring(1));\n-    } else {  // recursion\n-      for (LispTree child : formulaTree.children) {\n-        extractAtomicFreebaseElements(child, res);\n-      }\n+\n+    public static int getInt(Formula formula) {\n+        return (int) getDouble(formula);\n     }\n-  }\n-\n-  // TODO(jonathan): move to feature extractor (this function doesn't seem fundamental)\n-  public static boolean isCountFormula(Formula formula) {\n-    if (formula instanceof AggregateFormula)\n-      return ((AggregateFormula) formula).mode == AggregateFormula.Mode.count;\n-    if (formula instanceof JoinFormula) {\n-      Formula relation = ((JoinFormula) formula).relation;\n-      if (relation instanceof LambdaFormula) {\n-        Formula l = ((LambdaFormula) relation).body;\n-        if (l instanceof AggregateFormula)\n-          return ((AggregateFormula) l).mode == AggregateFormula.Mode.count;\n-      }\n+\n+    /**\n+     * If the formula represents a binary (e.g., fb:a.b.c or <=),\n+     * return the ID of the binary as a string.\n+     * If the formula represents a reversed binary (e.g., !fb:a.b.c or (reverse fb:a.b.c)),\n+     * return \"!\" + ID of the binary.\n+     * Otherwise, return null.\n+     */\n+    public static String getBinaryId(Formula formula) {\n+        if (formula instanceof ReverseFormula) {\n+            String childId = getBinaryId(((ReverseFormula) formula).child);\n+            if (childId == null) {\n+                return null;\n+            }\n+            return CanonicalNames.reverseProperty(childId);\n+        } else if (formula instanceof ValueFormula) {\n+            Value v = ((ValueFormula<?>) formula).value;\n+            if (v instanceof NameValue) {\n+                return ((NameValue) v).id;\n+            }\n+        }\n+        return null;\n     }\n-    return false;\n-  }\n-\n-  public static String getString(Formula formula) {\n-    if (formula instanceof ValueFormula) {\n-      Value value = ((ValueFormula) formula).value;\n-      if (value instanceof StringValue)\n-        return ((StringValue) value).value;\n-      if (value instanceof NameValue)\n-        return ((NameValue) value).id;\n-      if (value instanceof NumberValue)\n-        return ((NumberValue) value).value + \"\";\n-    } else if (formula instanceof VariableFormula) {\n-      return ((VariableFormula) formula).name;\n+\n+    public static ValueFormula<NameValue> newNameFormula(String id) {\n+        return new ValueFormula<NameValue>(new NameValue(id));\n     }\n-    return null;\n-  }\n-\n-  public static String getNameId(Formula formula) {\n-    if (formula instanceof ValueFormula) {\n-      Value value = ((ValueFormula) formula).value;\n-      if (value instanceof NameValue)\n-        return ((NameValue) value).id;\n+\n+    /*\n+     * Extract all subformulas in a string format (to also have primitive values)\n+     * TODO(joberant): replace this with Formulas.map\n+     */\n+    public static Set<String> extractSubparts(Formula f) {\n+        Set<String> res = new HashSet<String>();\n+        extractSubpartsRecursive(f, res);\n+        return res;\n     }\n-    return null;\n-  }\n-\n-  public static double getDouble(Formula formula) {\n-    if (formula instanceof ValueFormula) {\n-      Value value = ((ValueFormula) formula).value;\n-      if (value instanceof NumberValue)\n-        return ((NumberValue) value).value;\n+\n+    private static void extractSubpartsRecursive(Formula f, Set<String> res) {\n+        // base\n+        res.add(f.toString());\n+        // recurse\n+        if (f instanceof AggregateFormula) {\n+            AggregateFormula aggFormula = (AggregateFormula) f;\n+            extractSubpartsRecursive(aggFormula, res);\n+        } else if (f instanceof CallFormula) {\n+            CallFormula callFormula = (CallFormula) f;\n+            extractSubpartsRecursive(callFormula.func, res);\n+            for (Formula argFormula : callFormula.args) {\n+                extractSubpartsRecursive(argFormula, res);\n+            }\n+        } else if (f instanceof JoinFormula) {\n+            JoinFormula joinFormula = (JoinFormula) f;\n+            extractSubpartsRecursive(joinFormula.relation, res);\n+            extractSubpartsRecursive(joinFormula.child, res);\n+        } else if (f instanceof LambdaFormula) {\n+            LambdaFormula lambdaFormula = (LambdaFormula) f;\n+            extractSubpartsRecursive(lambdaFormula.body, res);\n+        } else if (f instanceof MarkFormula) {\n+            MarkFormula markFormula = (MarkFormula) f;\n+            extractSubpartsRecursive(markFormula.body, res);\n+        } else if (f instanceof MergeFormula) {\n+            MergeFormula mergeFormula = (MergeFormula) f;\n+            extractSubpartsRecursive(mergeFormula.child1, res);\n+            extractSubpartsRecursive(mergeFormula.child2, res);\n+        } else if (f instanceof NotFormula) {\n+            NotFormula notFormula = (NotFormula) f;\n+            extractSubpartsRecursive(notFormula.child, res);\n+        } else if (f instanceof ReverseFormula) {\n+            ReverseFormula revFormula = (ReverseFormula) f;\n+            extractSubpartsRecursive(revFormula.child, res);\n+        } else if (f instanceof SuperlativeFormula) {\n+            SuperlativeFormula superlativeFormula = (SuperlativeFormula) f;\n+            extractSubpartsRecursive(superlativeFormula.rank, res);\n+            extractSubpartsRecursive(superlativeFormula.count, res);\n+            extractSubpartsRecursive(superlativeFormula.head, res);\n+            extractSubpartsRecursive(superlativeFormula.relation, res);\n+        }\n     }\n-    return Double.NaN;\n-  }\n-\n-  public static int getInt(Formula formula) {\n-    return (int) getDouble(formula);\n-  }\n-\n-  /**\n-   * If the formula represents a binary (e.g., fb:a.b.c or <=),\n-   *   return the ID of the binary as a string.\n-   * If the formula represents a reversed binary (e.g., !fb:a.b.c or (reverse fb:a.b.c)),\n-   *   return \"!\" + ID of the binary.\n-   * Otherwise, return null.\n-   */\n-  public static String getBinaryId(Formula formula) {\n-    if (formula instanceof ReverseFormula) {\n-      String childId = getBinaryId(((ReverseFormula) formula).child);\n-      if (childId == null) return null;\n-      return CanonicalNames.reverseProperty(childId);\n-    } else if (formula instanceof ValueFormula) {\n-      Value v = ((ValueFormula<?>) formula).value;\n-      if (v instanceof NameValue) {\n-        return ((NameValue) v).id;\n-      }\n+\n+    // Takes in a |rawFormula| which represents a function x => y and returns a\n+    // function y => x.\n+    public static Formula reverseFormula(Formula rawFormula) {\n+        if (rawFormula instanceof ValueFormula) {\n+            if (((ValueFormula) rawFormula).value instanceof StringValue) {\n+                return null;\n+            }\n+            if (((ValueFormula) rawFormula).value instanceof ListValue) {\n+                return null;\n+            }\n+            ValueFormula<NameValue> vf = (ValueFormula<NameValue>) rawFormula;\n+            return reverseNameFormula(vf);\n+        } else if (rawFormula instanceof LambdaFormula) {\n+            // Convert (lambda x (relation1 (relation2 (var x)))) <=> (lambda x (!relation2 (!relation1 (var x))))\n+            // Note: currently only handles chains.  Make this more generic.\n+            LambdaFormula formula = (LambdaFormula) rawFormula;\n+            if (isChain(formula.body)) {\n+                return new LambdaFormula(formula.var, reverseChain(formula.body, new VariableFormula(formula.var)));\n+            } else {\n+                return new ReverseFormula(formula);\n+            }\n+        } else {\n+            return new ReverseFormula(rawFormula);\n+            // throw new RuntimeException(\"Not handled: \" + rawFormula);\n+        }\n     }\n-    return null;\n-  }\n-\n-  public static ValueFormula<NameValue> newNameFormula(String id) {\n-    return new ValueFormula<NameValue>(new NameValue(id));\n-  }\n-\n-  /*\n-   * Extract all subformulas in a string format (to also have primitive values)\n-   * TODO(joberant): replace this with Formulas.map\n-   */\n-  public static Set<String> extractSubparts(Formula f) {\n-    Set<String> res = new HashSet<String>();\n-    extractSubpartsRecursive(f, res);\n-    return res;\n-  }\n-\n-  private static void extractSubpartsRecursive(Formula f, Set<String> res) {\n-    // base\n-    res.add(f.toString());\n-    // recurse\n-    if (f instanceof AggregateFormula) {\n-      AggregateFormula aggFormula = (AggregateFormula) f;\n-      extractSubpartsRecursive(aggFormula, res);\n-    } else if (f instanceof CallFormula) {\n-      CallFormula callFormula = (CallFormula) f;\n-      extractSubpartsRecursive(callFormula.func, res);\n-      for (Formula argFormula : callFormula.args)\n-        extractSubpartsRecursive(argFormula, res);\n-    } else if (f instanceof JoinFormula) {\n-      JoinFormula joinFormula = (JoinFormula) f;\n-      extractSubpartsRecursive(joinFormula.relation, res);\n-      extractSubpartsRecursive(joinFormula.child, res);\n-    } else if (f instanceof LambdaFormula) {\n-      LambdaFormula lambdaFormula = (LambdaFormula) f;\n-      extractSubpartsRecursive(lambdaFormula.body, res);\n-    } else if (f instanceof MarkFormula) {\n-      MarkFormula markFormula = (MarkFormula) f;\n-      extractSubpartsRecursive(markFormula.body, res);\n-    } else if (f instanceof MergeFormula) {\n-      MergeFormula mergeFormula = (MergeFormula) f;\n-      extractSubpartsRecursive(mergeFormula.child1, res);\n-      extractSubpartsRecursive(mergeFormula.child2, res);\n-    } else if (f instanceof NotFormula) {\n-      NotFormula notFormula = (NotFormula) f;\n-      extractSubpartsRecursive(notFormula.child, res);\n-    } else if (f instanceof ReverseFormula) {\n-      ReverseFormula revFormula = (ReverseFormula) f;\n-      extractSubpartsRecursive(revFormula.child, res);\n-    } else if (f instanceof SuperlativeFormula) {\n-      SuperlativeFormula superlativeFormula = (SuperlativeFormula) f;\n-      extractSubpartsRecursive(superlativeFormula.rank, res);\n-      extractSubpartsRecursive(superlativeFormula.count, res);\n-      extractSubpartsRecursive(superlativeFormula.head, res);\n-      extractSubpartsRecursive(superlativeFormula.relation, res);\n+\n+    // Helper function for reverseFormula().\n+    // Check to see if formula has the form (a (b (c (var x))))\n+    private static boolean isChain(Formula source) {\n+        if (source instanceof JoinFormula) {\n+            JoinFormula join = (JoinFormula) source;\n+            return isChain(join.child);\n+        }\n+        return source instanceof VariableFormula;\n     }\n-  }\n \n-  // Takes in a |rawFormula| which represents a function x => y and returns a\n-  // function y => x.\n-  public static Formula reverseFormula(Formula rawFormula) {\n-    if (rawFormula instanceof ValueFormula) {\n-      if (((ValueFormula) rawFormula).value instanceof StringValue)\n-        return null;\n-      if (((ValueFormula) rawFormula).value instanceof ListValue)\n-        return null;\n-      ValueFormula<NameValue> vf = (ValueFormula<NameValue>) rawFormula;\n-      return reverseNameFormula(vf);\n-    } else if (rawFormula instanceof LambdaFormula) {\n-      // Convert (lambda x (relation1 (relation2 (var x)))) <=> (lambda x (!relation2 (!relation1 (var x))))\n-      // Note: currently only handles chains.  Make this more generic.\n-      LambdaFormula formula = (LambdaFormula) rawFormula;\n-      if (isChain(formula.body))\n-        return new LambdaFormula(formula.var, reverseChain(formula.body, new VariableFormula(formula.var)));\n-      else\n-        return new ReverseFormula(formula);\n-    } else {\n-      return new ReverseFormula(rawFormula);\n-      // throw new RuntimeException(\"Not handled: \" + rawFormula);\n+    // Reverse the chain\n+    private static Formula reverseChain(Formula source, Formula result) {\n+        if (source instanceof JoinFormula) {\n+            JoinFormula join = (JoinFormula) source;\n+            return reverseChain(join.child, new JoinFormula(reverseFormula(join.relation), result));\n+        } else if (source instanceof VariableFormula) {\n+            return result;\n+        } else {\n+            throw new RuntimeException(\"Not handled: \" + source);\n+        }\n     }\n-  }\n-\n-  // Helper function for reverseFormula().\n-  // Check to see if formula has the form (a (b (c (var x))))\n-  private static boolean isChain(Formula source) {\n-    if (source instanceof JoinFormula) {\n-      JoinFormula join = (JoinFormula) source;\n-      return isChain(join.child);\n+\n+    // !fb:people.person.place_of_birth <=> fb:people.person.place_of_birth\n+    private static ValueFormula<NameValue> reverseNameFormula(ValueFormula<NameValue> formula) {\n+        String id = formula.value.id;\n+        return new ValueFormula<>(new NameValue(CanonicalNames.reverseProperty(id)));\n     }\n-    return source instanceof VariableFormula;\n-  }\n-  // Reverse the chain\n-  private static Formula reverseChain(Formula source, Formula result) {\n-    if (source instanceof JoinFormula) {\n-      JoinFormula join = (JoinFormula) source;\n-      return reverseChain(join.child, new JoinFormula(reverseFormula(join.relation), result));\n-    } else if (source instanceof VariableFormula) {\n-      return result;\n-    } else {\n-      throw new RuntimeException(\"Not handled: \" + source);\n+\n+    // Try to simplify reverse subformulas within the specified formula\n+    public static Formula simplifyReverses(Formula formula) {\n+        return formula.map(new Function<Formula, Formula>() {\n+            public Formula apply(Formula formula) {\n+                if (formula instanceof ReverseFormula) {\n+                    return reverseFormula(((ReverseFormula) formula).child);\n+                }\n+                return null;\n+            }\n+        });\n     }\n-  }\n-\n-  // !fb:people.person.place_of_birth <=> fb:people.person.place_of_birth\n-  private static ValueFormula<NameValue> reverseNameFormula(ValueFormula<NameValue> formula) {\n-    String id = formula.value.id;\n-    return new ValueFormula<>(new NameValue(CanonicalNames.reverseProperty(id)));\n-  }\n-\n-  // Try to simplify reverse subformulas within the specified formula\n-  public static Formula simplifyReverses(Formula formula) {\n-    return formula.map(new Function<Formula, Formula>() {\n-      public Formula apply(Formula formula) {\n-        if (formula instanceof ReverseFormula)\n-          return reverseFormula(((ReverseFormula) formula).child);\n-        return null;\n-      }\n-    });\n-  }\n \n \n }\n",
            "diff_size": 551
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/codebuff/1/Formulas.java\nindex 94a22c87a6f..9e4da245831 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/codebuff/1/Formulas.java\n@@ -3,7 +3,6 @@ package edu.stanford.nlp.sempre;\n import com.google.common.base.Function;\n import com.google.common.collect.Lists;\n import fig.basic.LispTree;\n-\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n@@ -13,11 +12,14 @@ import java.util.Set;\n  *\n  * @author Percy Liang\n  */\n+\n+\n public abstract class Formulas {\n   public static Formula fromLispTree(LispTree tree) {\n     // Try to interpret as ValueFormula\n     if (tree.isLeaf())  // Leaves are name values\n       return new ValueFormula<NameValue>(new NameValue(tree.value, null));\n+\n     Value value = Values.fromLispTreeOrNull(tree);  // General case\n     if (value != null)\n       return new ValueFormula<Value>(value);\n@@ -42,39 +44,29 @@ public abstract class Formulas {\n         return new CallFormula(callFunc, args);\n       }\n     }\n-\n     { // Merge: (and (fb:type.object.type fb:people.person) (fb:people.person.children fb:en.barack_obama))\n       MergeFormula.Mode mode = MergeFormula.parseMode(func);\n       if (mode != null)\n         return new MergeFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n     }\n-\n     { // Aggregate: (count (fb:type.object.type fb:people.person))\n       AggregateFormula.Mode mode = AggregateFormula.parseMode(func);\n       if (mode != null)\n         return new AggregateFormula(mode, fromLispTree(tree.child(1)));\n     }\n-\n     { // Superlative: (argmax 1 1 (fb:type.object.type fb:people.person) (lambda x (!fb:people.person.height_meters (var x))))\n       SuperlativeFormula.Mode mode = SuperlativeFormula.parseMode(func);\n       if (mode != null) {\n         Formula rank = parseIntToFormula(tree.child(1));\n         Formula count = parseIntToFormula(tree.child(2));\n-        return new SuperlativeFormula(\n-            mode,\n-            rank,\n-            count,\n-            fromLispTree(tree.child(3)),\n-            fromLispTree(tree.child(4)));\n+        return new SuperlativeFormula(mode, rank, count, fromLispTree(tree.child(3)), fromLispTree(tree.child(4)));\n       }\n     }\n-\n     { // Arithmetic: (- (!fb:people.person.height_meters (var x)) (!fb:people.person.height_meters (var y)))\n       ArithmeticFormula.Mode mode = ArithmeticFormula.parseMode(func);\n       if (mode != null)\n         return new ArithmeticFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n     }\n-    \n     { // ActionFormula\n       ActionFormula.Mode mode = ActionFormula.parseMode(func);\n       if (mode != null) {\n@@ -86,12 +78,14 @@ public abstract class Formulas {\n     }\n \n     // Default is join: (fb:type.object.type fb:people.person)\n+\n     if (tree.children.size() != 2)\n       throw new RuntimeException(\"Invalid number of arguments for join (want 2): \" + tree);\n     return new JoinFormula(fromLispTree(tree.child(0)), fromLispTree(tree.child(1)));\n   }\n \n   // Special case to enable \"argmax 1 1\" rather than \"argmax (number 1) (number 1)\"\n+\n   private static Formula parseIntToFormula(LispTree tree) {\n     try {\n       int i = Integer.parseInt(tree.value);\n@@ -107,55 +101,58 @@ public abstract class Formulas {\n   }\n \n   // Replace occurrences of the variable reference |var| with |formula|.\n+\n   public static Formula substituteVar(Formula formula, final String var, final Formula replaceFormula) {\n-    return formula.map(\n-        new Function<Formula, Formula>() {\n-          public Formula apply(Formula formula) {\n-            if (formula instanceof VariableFormula) {  // Replace variable\n-              String name = ((VariableFormula) formula).name;\n-              return var.equals(name) ? replaceFormula : formula;\n-            } else if (formula instanceof LambdaFormula) {\n-              if (((LambdaFormula) formula).var.equals(var)) // |var| is bound, so don't substitute inside\n-                return formula;\n-            }\n-            return null;\n-          }\n-        });\n+    return formula.map(new Function<Formula, Formula>() {\n+                         public Formula apply(Formula formula) {\n+                           if (formula instanceof VariableFormula) {  // Replace variable\n+                             String name = ((VariableFormula) formula).name;\n+                             return var.equals(name) ? replaceFormula : formula;\n+                           } else if (formula instanceof LambdaFormula) {\n+                                    if (((LambdaFormula) formula).var.equals(var)) // |var| is bound, so don't substitute inside\n+                                      return formula;\n+                           }\n+                           return null;\n+                         }\n+                       });\n   }\n \n   // Replace top-level occurrences of |searchFormula| inside |formula| with |replaceFormula|.\n+\n   public static Formula substituteFormula(Formula formula, final Formula searchFormula, final Formula replaceFormula) {\n-    return formula.map(\n-        new Function<Formula, Formula>() {\n-          public Formula apply(Formula formula) {\n-            if (formula.equals(searchFormula)) return replaceFormula;\n-            return null;\n-          }\n-        });\n+    return formula.map(new Function<Formula, Formula>() {\n+                         public Formula apply(Formula formula) {\n+                           if (formula.equals(searchFormula))\n+                             return replaceFormula;\n+                           return null;\n+                         }\n+                       });\n   }\n \n   // Beta-reduction.\n+\n   public static Formula lambdaApply(LambdaFormula func, Formula arg) {\n     return substituteVar(func.body, func.var, arg);\n   }\n \n   // Apply all the nested LambdaFormula's.\n+\n   public static Formula betaReduction(Formula formula) {\n-    return formula.map(\n-        new Function<Formula, Formula>() {\n-          public Formula apply(Formula formula) {\n-            if (formula instanceof JoinFormula) {\n-              Formula relation = betaReduction(((JoinFormula) formula).relation);\n-              Formula child = ((JoinFormula) formula).child;\n-              if (relation instanceof LambdaFormula)\n-                return betaReduction(lambdaApply((LambdaFormula) relation, child));\n-            }\n-            return null;\n-          }\n-        });\n+    return formula.map(new Function<Formula, Formula>() {\n+                         public Formula apply(Formula formula) {\n+                           if (formula instanceof JoinFormula) {\n+                             Formula relation = betaReduction(((JoinFormula) formula).relation);\n+                             Formula child = ((JoinFormula) formula).child;\n+                             if (relation instanceof LambdaFormula)\n+                               return betaReduction(lambdaApply((LambdaFormula) relation, child));\n+                           }\n+                           return null;\n+                         }\n+                       });\n   }\n \n   // Return whether |formula| contains a free instance of |var|.\n+\n   public static boolean containsFreeVar(Formula formula, VariableFormula var) {\n     if (formula instanceof PrimitiveFormula)\n       return formula.equals(var);\n@@ -163,33 +160,42 @@ public abstract class Formulas {\n       MergeFormula merge = (MergeFormula) formula;\n       return containsFreeVar(merge.child1, var) || containsFreeVar(merge.child2, var);\n     }\n+\n     if (formula instanceof JoinFormula) {\n       JoinFormula join = (JoinFormula) formula;\n       return containsFreeVar(join.relation, var) || containsFreeVar(join.child, var);\n     }\n+\n     if (formula instanceof LambdaFormula) {\n       LambdaFormula lambda = (LambdaFormula) formula;\n-      if (lambda.var.equals(var.name)) return false;  // Blocked by bound variable\n+      if (lambda.var.equals(var.name))\n+        return false;  // Blocked by bound variable\n       return containsFreeVar(lambda.body, var);\n     }\n+\n     if (formula instanceof MarkFormula) {\n       MarkFormula mark = (MarkFormula) formula;\n       // Note: marks are transparent, unlike lambdas\n       return containsFreeVar(mark.body, var);\n     }\n+\n     if (formula instanceof ReverseFormula) {\n       return containsFreeVar(((ReverseFormula) formula).child, var);\n     }\n+\n     if (formula instanceof AggregateFormula) {\n       return containsFreeVar(((AggregateFormula) formula).child, var);\n     }\n+\n     if (formula instanceof ArithmeticFormula) {\n       return containsFreeVar(((ArithmeticFormula) formula).child1, var) || containsFreeVar(((ArithmeticFormula) formula).child2, var);\n     }\n+\n     if (formula instanceof SuperlativeFormula) {\n       SuperlativeFormula superlative = (SuperlativeFormula) formula;\n       return containsFreeVar(superlative.rank, var) || containsFreeVar(superlative.count, var) || containsFreeVar(superlative.head, var) || containsFreeVar(superlative.relation, var);\n     }\n+\n     if (formula instanceof NotFormula) {\n       NotFormula notForm = (NotFormula) formula;\n       return containsFreeVar(notForm.child, var);\n@@ -198,14 +204,15 @@ public abstract class Formulas {\n   }\n \n   // TODO(joberant): use Formula.map, and use CanonicalNames.isReverseProperty, etc.\n+\n   public static Set<String> extractAtomicFreebaseElements(Formula formula) {\n     Set<String> res = new HashSet<>();\n     LispTree formulaTree = formula.toLispTree();\n     extractAtomicFreebaseElements(formulaTree, res);\n     return res;\n   }\n-  private static void extractAtomicFreebaseElements(LispTree formulaTree,\n-                                                    Set<String> res) {\n+\n+  private static void extractAtomicFreebaseElements(LispTree formulaTree, Set<String> res) {\n     if (formulaTree.isLeaf()) {  // base\n       if (formulaTree.value.startsWith(\"fb:\"))\n         res.add(formulaTree.value);\n@@ -219,6 +226,7 @@ public abstract class Formulas {\n   }\n \n   // TODO(jonathan): move to feature extractor (this function doesn't seem fundamental)\n+\n   public static boolean isCountFormula(Formula formula) {\n     if (formula instanceof AggregateFormula)\n       return ((AggregateFormula) formula).mode == AggregateFormula.Mode.count;\n@@ -277,10 +285,12 @@ public abstract class Formulas {\n    *   return \"!\" + ID of the binary.\n    * Otherwise, return null.\n    */\n+\n   public static String getBinaryId(Formula formula) {\n     if (formula instanceof ReverseFormula) {\n       String childId = getBinaryId(((ReverseFormula) formula).child);\n-      if (childId == null) return null;\n+      if (childId == null)\n+        return null;\n       return CanonicalNames.reverseProperty(childId);\n     } else if (formula instanceof ValueFormula) {\n       Value v = ((ValueFormula<?>) formula).value;\n@@ -299,6 +309,7 @@ public abstract class Formulas {\n    * Extract all subformulas in a string format (to also have primitive values)\n    * TODO(joberant): replace this with Formulas.map\n    */\n+\n   public static Set<String> extractSubparts(Formula f) {\n     Set<String> res = new HashSet<String>();\n     extractSubpartsRecursive(f, res);\n@@ -321,39 +332,41 @@ public abstract class Formulas {\n       JoinFormula joinFormula = (JoinFormula) f;\n       extractSubpartsRecursive(joinFormula.relation, res);\n       extractSubpartsRecursive(joinFormula.child, res);\n-    } else if (f instanceof LambdaFormula) {\n-      LambdaFormula lambdaFormula = (LambdaFormula) f;\n-      extractSubpartsRecursive(lambdaFormula.body, res);\n-    } else if (f instanceof MarkFormula) {\n-      MarkFormula markFormula = (MarkFormula) f;\n-      extractSubpartsRecursive(markFormula.body, res);\n-    } else if (f instanceof MergeFormula) {\n-      MergeFormula mergeFormula = (MergeFormula) f;\n-      extractSubpartsRecursive(mergeFormula.child1, res);\n-      extractSubpartsRecursive(mergeFormula.child2, res);\n-    } else if (f instanceof NotFormula) {\n-      NotFormula notFormula = (NotFormula) f;\n-      extractSubpartsRecursive(notFormula.child, res);\n-    } else if (f instanceof ReverseFormula) {\n-      ReverseFormula revFormula = (ReverseFormula) f;\n-      extractSubpartsRecursive(revFormula.child, res);\n-    } else if (f instanceof SuperlativeFormula) {\n-      SuperlativeFormula superlativeFormula = (SuperlativeFormula) f;\n-      extractSubpartsRecursive(superlativeFormula.rank, res);\n-      extractSubpartsRecursive(superlativeFormula.count, res);\n-      extractSubpartsRecursive(superlativeFormula.head, res);\n-      extractSubpartsRecursive(superlativeFormula.relation, res);\n-    }\n+           } else if (f instanceof LambdaFormula) {\n+             LambdaFormula lambdaFormula = (LambdaFormula) f;\n+             extractSubpartsRecursive(lambdaFormula.body, res);\n+           } else if (f instanceof MarkFormula) {\n+             MarkFormula markFormula = (MarkFormula) f;\n+             extractSubpartsRecursive(markFormula.body, res);\n+                  } else if (f instanceof MergeFormula) {\n+                    MergeFormula mergeFormula = (MergeFormula) f;\n+                    extractSubpartsRecursive(mergeFormula.child1, res);\n+                    extractSubpartsRecursive(mergeFormula.child2, res);\n+                  } else if (f instanceof NotFormula) {\n+                    NotFormula notFormula = (NotFormula) f;\n+                    extractSubpartsRecursive(notFormula.child, res);\n+                         } else if (f instanceof ReverseFormula) {\n+                           ReverseFormula revFormula = (ReverseFormula) f;\n+                           extractSubpartsRecursive(revFormula.child, res);\n+                         } else if (f instanceof SuperlativeFormula) {\n+                           SuperlativeFormula superlativeFormula = (SuperlativeFormula) f;\n+                           extractSubpartsRecursive(superlativeFormula.rank, res);\n+                           extractSubpartsRecursive(superlativeFormula.count, res);\n+                           extractSubpartsRecursive(superlativeFormula.head, res);\n+                           extractSubpartsRecursive(superlativeFormula.relation, res);\n+                                }\n   }\n \n   // Takes in a |rawFormula| which represents a function x => y and returns a\n   // function y => x.\n+\n   public static Formula reverseFormula(Formula rawFormula) {\n     if (rawFormula instanceof ValueFormula) {\n       if (((ValueFormula) rawFormula).value instanceof StringValue)\n         return null;\n       if (((ValueFormula) rawFormula).value instanceof ListValue)\n         return null;\n+\n       ValueFormula<NameValue> vf = (ValueFormula<NameValue>) rawFormula;\n       return reverseNameFormula(vf);\n     } else if (rawFormula instanceof LambdaFormula) {\n@@ -372,6 +385,7 @@ public abstract class Formulas {\n \n   // Helper function for reverseFormula().\n   // Check to see if formula has the form (a (b (c (var x))))\n+\n   private static boolean isChain(Formula source) {\n     if (source instanceof JoinFormula) {\n       JoinFormula join = (JoinFormula) source;\n@@ -380,6 +394,7 @@ public abstract class Formulas {\n     return source instanceof VariableFormula;\n   }\n   // Reverse the chain\n+\n   private static Formula reverseChain(Formula source, Formula result) {\n     if (source instanceof JoinFormula) {\n       JoinFormula join = (JoinFormula) source;\n@@ -392,21 +407,21 @@ public abstract class Formulas {\n   }\n \n   // !fb:people.person.place_of_birth <=> fb:people.person.place_of_birth\n+\n   private static ValueFormula<NameValue> reverseNameFormula(ValueFormula<NameValue> formula) {\n     String id = formula.value.id;\n     return new ValueFormula<>(new NameValue(CanonicalNames.reverseProperty(id)));\n   }\n \n   // Try to simplify reverse subformulas within the specified formula\n+\n   public static Formula simplifyReverses(Formula formula) {\n     return formula.map(new Function<Formula, Formula>() {\n-      public Formula apply(Formula formula) {\n-        if (formula instanceof ReverseFormula)\n-          return reverseFormula(((ReverseFormula) formula).child);\n-        return null;\n-      }\n-    });\n+                         public Formula apply(Formula formula) {\n+                           if (formula instanceof ReverseFormula)\n+                             return reverseFormula(((ReverseFormula) formula).child);\n+                           return null;\n+                         }\n+                       });\n   }\n-\n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 110
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler_random/1/Formulas.java\nindex 94a22c87a6f..59fde609ff1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler_random/1/Formulas.java\n@@ -74,7 +74,7 @@ public abstract class Formulas {\n       if (mode != null)\n         return new ArithmeticFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n     }\n-    \n+\n     { // ActionFormula\n       ActionFormula.Mode mode = ActionFormula.parseMode(func);\n       if (mode != null) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "75",
                    "column": "101",
                    "severity": "error",
                    "message": "';' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                },
                {
                    "line": "75",
                    "column": "102",
                    "severity": "error",
                    "message": "'}' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler_three_grams/1/Formulas.java\nindex 94a22c87a6f..fabfa3ed2da 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/1/Formulas.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler_three_grams/1/Formulas.java\n@@ -72,10 +72,8 @@ public abstract class Formulas {\n     { // Arithmetic: (- (!fb:people.person.height_meters (var x)) (!fb:people.person.height_meters (var y)))\n       ArithmeticFormula.Mode mode = ArithmeticFormula.parseMode(func);\n       if (mode != null)\n-        return new ArithmeticFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));\n-    }\n-    \n-    { // ActionFormula\n+        return new ArithmeticFormula(mode, fromLispTree(tree.child(1)), fromLispTree(tree.child(2)));}\n+                { // ActionFormula\n       ActionFormula.Mode mode = ActionFormula.parseMode(func);\n       if (mode != null) {\n         List<Formula> args = Lists.newArrayList();\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random"
    ],
    "not_repaired_by": [
        "naturalize",
        "styler_three_grams"
    ]
}