{
    "project_name": "CESNET-perun",
    "error_id": "100",
    "information": {
        "errors": [
            {
                "line": "209",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "\n\t\tCoreConfig config = BeansUtils.getCoreConfig();\n\t\t\n\t\t// If we have header Shib-Identity-Provider, then the user uses identity federation to authenticate\n\t\tif (isNotEmpty(shibIdentityProvider)) {\n\t\t\textSourceName = getOriginalIdP(shibIdentityProvider, sourceIdpEntityId);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/100/Api.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/100/Api.java\nindex 8c8eeb36279..7393158c23b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/100/Api.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/100/Api.java\n@@ -206,7 +206,7 @@ public class Api extends HttpServlet {\n \t\tString remoteUser = req.getRemoteUser();\n \n \t\tCoreConfig config = BeansUtils.getCoreConfig();\n-\t\t\n+\n \t\t// If we have header Shib-Identity-Provider, then the user uses identity federation to authenticate\n \t\tif (isNotEmpty(shibIdentityProvider)) {\n \t\t\textSourceName = getOriginalIdP(shibIdentityProvider, sourceIdpEntityId);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/100/Api.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/100/Api.java\nindex 8c8eeb36279..488dfbb7f5f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/100/Api.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/100/Api.java\n@@ -67,708 +67,721 @@ import static org.apache.commons.lang3.StringUtils.isNotEmpty;\n  */\n public class Api extends HttpServlet {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(Api.class);\n-\n-\tprivate final static String APICALLER = \"apiCaller\";\n-\tprivate final static String PERUNREQUESTS = \"perunRequests\";\n-\tprivate final static String PERUNREQUESTSURL = \"getPendingRequests\";\n-\tprivate final static String PERUNSTATUS = \"getPerunStatus\";\n-\tprivate final static String PERUNSTATISTICS = \"getPerunStatistics\";\n-\tprivate final static String VOOTMANAGER = \"vootManager\";\n-\tprivate final static int timeToLiveWhenDone = 60 * 1000; // in milisec, if requests is done more than this time, remove it from list\n-\n-\tprivate static final String SHIB_IDENTITY_PROVIDER = \"Shib-Identity-Provider\";\n-\tprivate static final String SOURCE_IDP_ENTITY_ID = \"sourceIdPEntityID\";\n-\tprivate static final String SSL_CLIENT_VERIFY = \"SSL_CLIENT_VERIFY\";\n-\tprivate static final String SSL_CLIENT_ISSUER_DN = \"SSL_CLIENT_I_DN\";\n-\tprivate static final String SSL_CLIENT_SUBJECT_DN = \"SSL_CLIENT_S_DN\";\n-\tprivate static final String SSL_CLIENT_CERT = \"SSL_CLIENT_CERT\";\n-\tprivate static final String SUCCESS = \"SUCCESS\";\n-\tprivate static final String OIDC_CLAIM_SUB = \"OIDC_CLAIM_sub\";\n-\tprivate static final String OIDC_CLAIM_CLIENT_ID = \"OIDC_CLAIM_client_id\";\n-\tprivate static final String OIDC_CLAIM_SCOPE = \"OIDC_CLAIM_scope\";\n-\tprivate static final String OIDC_CLAIM_ISS = \"OIDC_CLAIM_iss\";\n-\tprivate static final String EXTSOURCE = \"EXTSOURCE\";\n-\tprivate static final String EXTSOURCETYPE = \"EXTSOURCETYPE\";\n-\tprivate static final String EXTSOURCELOA = \"EXTSOURCELOA\";\n-\tprivate static final String ENV_REMOTE_USER = \"ENV_REMOTE_USER\";\n-\tprivate static final String DELEGATED_LOGIN = \"delegatedLogin\";\n-\tprivate static final String DELEGATED_EXTSOURCE_NAME = \"delegatedExtSourceName\";\n-\tprivate static final String DELEGATED_EXTSOURCE_TYPE = \"delegatedExtSourceType\";\n-\tprivate static final String LOA = \"loa\";\n-\n-\t@Override\n-\tpublic void init() {\n-\t\t// we do not init anything\n-\t}\n-\n-\tprivate static String getStringAttribute(HttpServletRequest req, String attributeName) {\n-\t\treturn (String) req.getAttribute(attributeName);\n-\t}\n-\n-\tprivate static String getExtSourceName(HttpServletRequest req, Deserializer des) throws InternalErrorException {\n-\t\tString shibIdentityProvider = getStringAttribute(req, SHIB_IDENTITY_PROVIDER);\n-\t\tString sourceIdpEntityId = getStringAttribute(req, SOURCE_IDP_ENTITY_ID);\n-\t\tif (isNotEmpty(shibIdentityProvider)) {\n-\t\t\treturn getOriginalIdP(shibIdentityProvider, sourceIdpEntityId);\n-\t\t} else {\n-\t\t\tif (isNotEmpty(req.getHeader(OIDC_CLAIM_SUB))) {\n-\t\t\t\tString iss = req.getHeader(OIDC_CLAIM_ISS);\n-\t\t\t\tif(iss!=null) {\n-\t\t\t\t\tString extSourceName = BeansUtils.getCoreConfig().getOidcIssuersExtsourceNames().get(iss);\n-\t\t\t\t\tif(extSourceName!=null) {\n-\t\t\t\t\t\treturn extSourceName;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tthrow new InternalErrorException(\"OIDC issuer \"+iss+\" not configured\");\n-\t\t\t} else if (Objects.equals(req.getAttribute(SSL_CLIENT_VERIFY), SUCCESS)) {\n-\t\t\t\treturn getStringAttribute(req, SSL_CLIENT_ISSUER_DN);\n-\t\t\t} else {\n-\t\t\t\tString extSource = getStringAttribute(req, EXTSOURCE);\n-\t\t\t\treturn extSource != null ? extSource : des.readString(DELEGATED_EXTSOURCE_NAME);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static String getOriginalIdP(String shibIdentityProvider, String sourceIdpEntityId) {\n-\t\t// If IdP is proxy and we want to save original source IdP behind Proxy.\n-\t\tList<String> proxyIdPs = BeansUtils.getCoreConfig().getProxyIdPs();\n-\t\tif (isNotEmpty(sourceIdpEntityId)) {\n-\t\t\tif (proxyIdPs.contains(shibIdentityProvider)) {\n-\t\t\t\treturn sourceIdpEntityId;\n-\t\t\t} else {\n-\t\t\t\tlog.warn(\"sourceIdPEntityID attrribute found with value \" + sourceIdpEntityId +\n-\t\t\t\t\t\t\" in request but IdP with entityID: '\" + shibIdentityProvider +\n-\t\t\t\t\t\t\"' was not found in perun configuration property 'perun.proxyIdPs'=\" + proxyIdPs +\n-\t\t\t\t\t\t\". serving classical entityID instead of sourceIdPEntityID.\");\n-\t\t\t\treturn shibIdentityProvider;\n-\t\t\t}\n-\t\t} else {\n-\t\t\treturn shibIdentityProvider;\n-\t\t}\n-\t}\n-\n-\tprivate static String getExtLogin(HttpServletRequest req,String extSourceName,String remoteUser) {\n-\t\tif (isNotEmpty(remoteUser)) {\n-\t\t\treturn remoteUser;\n-\t\t} else {\n-\t\t\tString envRemoteUser = getStringAttribute(req, ENV_REMOTE_USER);\n-\t\t\tif (isNotEmpty(envRemoteUser)) {\n-\t\t\t\treturn envRemoteUser;\n-\t\t\t} else if (extSourceName.equals(ExtSourcesManager.EXTSOURCE_NAME_LOCAL)) {\n-\t\t\t\t// LOCAL EXTSOURCE - If ExtSource is LOCAL then generate REMOTE_USER name on the fly\n-\t\t\t\treturn Long.toString(System.currentTimeMillis());\n-\t\t\t} else {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static String getActor(HttpServletRequest req, Deserializer des) throws InternalErrorException {\n-\t\tString actor = null;\n-\t\tString remoteUser = req.getRemoteUser();\n-\t\tif (isNotEmpty(getStringAttribute(req, (SHIB_IDENTITY_PROVIDER)))) {\n-\t\t\tif (isNotEmpty(remoteUser)) {\n-\t\t\t\tactor = remoteUser;\n-\t\t\t}\n-\t\t} else if (isNotEmpty(req.getHeader(OIDC_CLAIM_SUB))) {\n-\t\t\tactor = remoteUser;\n-\t\t} else if (Objects.equals(req.getAttribute(SSL_CLIENT_VERIFY), SUCCESS)) {\n-\t\t\tactor = getStringAttribute(req, SSL_CLIENT_SUBJECT_DN);\n-\t\t} else {\n-\t\t\tString extSourceName = getStringAttribute(req, EXTSOURCE);\n-\t\t\tif (extSourceName != null) {\n-\t\t\t\tactor = getExtLogin(req, extSourceName, remoteUser);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (des != null && actor != null) {\n-\t\t\tif (BeansUtils.getCoreConfig().getRpcPowerusers().contains(actor) && des.contains(DELEGATED_LOGIN)) {\n-\t\t\t\t// Rewrite the remoteUser and extSource\n-\t\t\t\tactor = des.readString(DELEGATED_LOGIN);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn actor;\n-\n-\t}\n-\n-\tprivate static PerunPrincipal setupPerunPrincipal(HttpServletRequest req, Deserializer des) throws InternalErrorException, UserNotExistsException {\n-\t\tString extSourceLoaString = null;\n-\t\tString extLogin = null;\n-\t\tString extSourceName = null;\n-\t\tString extSourceType = null;\n-\t\tint extSourceLoa;\n-\t\tMap<String, String> additionalInformations = new HashMap<>();\n-\n-\t\tString shibIdentityProvider = getStringAttribute(req, SHIB_IDENTITY_PROVIDER);\n-\t\tString sourceIdpEntityId = getStringAttribute(req, SOURCE_IDP_ENTITY_ID);\n-\t\tString remoteUser = req.getRemoteUser();\n-\n-\t\tCoreConfig config = BeansUtils.getCoreConfig();\n-\t\t\n-\t\t// If we have header Shib-Identity-Provider, then the user uses identity federation to authenticate\n-\t\tif (isNotEmpty(shibIdentityProvider)) {\n-\t\t\textSourceName = getOriginalIdP(shibIdentityProvider, sourceIdpEntityId);\n-\t\t\textSourceType = ExtSourcesManager.EXTSOURCE_IDP;\n-\t\t\textSourceLoaString = getStringAttribute(req, LOA);\n-\t\t\tif(isEmpty(extSourceLoaString)) extSourceLoaString = \"2\";\n-\n-\t\t\t// FIXME: find better place where do the operation with attributes from federation\n-\t\t\tString eppn = getStringAttribute(req, \"eppn\");\n-\t\t\tif (isNotEmpty(eppn)) {\n-\t\t\t\t// Remove scope from the eppn attribute\n-\t\t\t\tadditionalInformations.put(\"eppnwoscope\", StringUtils.substringBefore(eppn, \"@\"));\n-\t\t\t}\n-\n-\t\t\t// Store IdP used by user to session, since for IdentityConsolidator and Registrar we need to know,\n-\t\t\t// if user logged in through proxy or not - we provide different links etc.\n-\t\t\tadditionalInformations.put(\"originIdentityProvider\", shibIdentityProvider);\n-\n-\t\t\tif (isNotEmpty(remoteUser)) {\n-\t\t\t\textLogin = remoteUser;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// If OIDC_CLAIM_sub header is present, it means user authenticated via OAuth2 with MITRE.\n-\t\telse if (isNotEmpty(req.getHeader(OIDC_CLAIM_SUB))) {\n-\t\t\textLogin = req.getHeader(OIDC_CLAIM_SUB);\n-\t\t\t//this is configurable, as the OIDC server has the source of sub claim also configurable\n-\t\t\tString iss = req.getHeader(OIDC_CLAIM_ISS);\n-\t\t\tif (iss != null) {\n-\t\t\t\textSourceName = BeansUtils.getCoreConfig().getOidcIssuersExtsourceNames().get(iss);\n-\t\t\t\textSourceType = BeansUtils.getCoreConfig().getOidcIssuersExtsourceTypes().get(iss);\n-\t\t\t\tif (extSourceName == null || extSourceType == null) {\n-\t\t\t\t\tthrow new InternalErrorException(\"OIDC issuer \" + iss + \" not configured\");\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tthrow new InternalErrorException(\"OIDC issuer not send by Authorization Server\");\n-\t\t\t}\n-\t\t\textSourceLoaString = \"-1\";\n-\t\t\tlog.debug(\"detected OIDC/OAuth2 client for sub={},iss={}\",extLogin,iss);\n-\t\t}\n-\n-\t\t// EXT_SOURCE was defined in Apache configuration (e.g. Kerberos or Local)\n-\t\telse if (req.getAttribute(EXTSOURCE) != null) {\n-\t\t\textSourceName = getStringAttribute(req, EXTSOURCE);\n-\t\t\textSourceType = getStringAttribute(req, EXTSOURCETYPE);\n-\t\t\textSourceLoaString = getStringAttribute(req, EXTSOURCELOA);\n-\t\t\textLogin = getExtLogin(req, extSourceName, remoteUser);\n-\t\t}\n-\n-\t\t// X509 cert was used\n-\t\t// Cert must be last since Apache asks for certificate everytime and fills cert properties even when Kerberos is in place.\n-\t\telse if (Objects.equals(req.getAttribute(SSL_CLIENT_VERIFY), SUCCESS)) {\n-\t\t\tString certDN = getStringAttribute(req, SSL_CLIENT_SUBJECT_DN);\n-\t\t\tString caDN = getStringAttribute(req, SSL_CLIENT_ISSUER_DN);\n-\t\t\tString wholeCert = getStringAttribute(req, SSL_CLIENT_CERT);\n-\t\t\textSourceName = caDN;\n-\t\t\textSourceType = ExtSourcesManager.EXTSOURCE_X509;\n-\t\t\textSourceLoaString = getStringAttribute(req,EXTSOURCELOA);\n-\t\t\textLogin = certDN;\n-\n-\t\t\t// Store X509 certificate in the additionalInformations structure\n-\t\t\t//FIXME: duplicit\n-\t\t\tadditionalInformations.put(\"userCertificates\",\n-\t\t\t\t\tAttributesManagerBlImpl.escapeMapAttributeValue(certDN) + AttributesManagerImpl.KEY_VALUE_DELIMITER +\n-\t\t\t\t\t\t\tAttributesManagerBlImpl.escapeMapAttributeValue(wholeCert));\n-\t\t\tadditionalInformations.put(\"userCertDNs\",\n-\t\t\t\t\tAttributesManagerBlImpl.escapeMapAttributeValue(certDN) + AttributesManagerImpl.KEY_VALUE_DELIMITER +\n-\t\t\t\t\t\t\tAttributesManagerBlImpl.escapeMapAttributeValue(caDN));\n-\t\t\tadditionalInformations.put(SSL_CLIENT_SUBJECT_DN, certDN);\n-\n-\t\t\t// Store X509\n-\t\t\tadditionalInformations.put(\"dn\", certDN);\n-\t\t\tadditionalInformations.put(\"cadn\", caDN);\n-\t\t\tadditionalInformations.put(\"certificate\", wholeCert);\n-\n-\t\t\t// Get organization from the certificate\n-\t\t\tPattern p = Pattern.compile(\"[oO]\\\\s*=\\\\s*([^/]*)\");\n-\t\t\tMatcher m = p.matcher(certDN);\n-\t\t\tif(m.find()) {\n-\t\t\t\tadditionalInformations.put(\"o\", m.group(1));\n-\t\t\t}\n-\t\t\t// Get CN from the certificate\n-\t\t\tPattern p2 = Pattern.compile(\"CN=([^/]*)\");\n-\t\t\tMatcher m2 = p2.matcher(certDN);\n-\t\t\tif(m2.find()) {\n-\t\t\t\tadditionalInformations.put(\"cn\", m2.group(1));\n-\t\t\t}\n-\n-\t\t\t// Get the X.509 certificate object\n-\t\t\tX509Certificate[] certs = (X509Certificate[]) req.getAttribute(\"javax.servlet.request.X509Certificate\");\n-\n-\t\t\t// Get the emails\n-\t\t\tif (certs != null && certs.length > 0 && certs[0] != null) {\n-\t\t\t\tString emails = \"\";\n-\n-\t\t\t\tCollection<List<?>> altNames;\n-\t\t\t\ttry {\n-\t\t\t\t\taltNames = certs[0].getSubjectAlternativeNames();\n-\t\t\t\t\tif (altNames != null) {\n-\t\t\t\t\t\tfor (List<?> entry : altNames) {\n-\t\t\t\t\t\t\tif (((Integer) entry.get(0)) == 1) {\n-\t\t\t\t\t\t\t\temails = (String) entry.get(1);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} catch (CertificateParsingException e) {\n-\t\t\t\t\tlog.error(\"Error during parsing certificate {}\", Arrays.asList(certs));\n-\t\t\t\t}\n-\n-\t\t\t\tadditionalInformations.put(\"mail\", emails);\n-\t\t\t}\n-\t\t}\n-\n-\t\t//store selected attributes for update\n-\t\tfor (AttributeDefinition attr : config.getAttributesForUpdate().getOrDefault(extSourceType,Collections.emptyList())) {\n-\t\t\tString attrValue = (String) req.getAttribute(attr.getFriendlyName());\n-\t\t\tif(attrValue!=null) {\n-\t\t\t\t//fix shibboleth encoding\n-\t\t\t\tif (ExtSourcesManager.EXTSOURCE_IDP.equals(extSourceType)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tattrValue = new String(attrValue.getBytes(\"iso-8859-1\"), \"utf-8\");\n-\t\t\t\t\t} catch (UnsupportedEncodingException e) {\n-\t\t\t\t\t\tlog.error(\"utf-8 is not known\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tlog.debug(\"storing {}={} to additionalInformations\", attr.getFriendlyName(), attrValue);\n-\t\t\t\tadditionalInformations.put(attr.getFriendlyName(), attrValue);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// If the RPC was called by the user who can do delegation and delegatedLogin is set, set the values sent in the request\n-\t\tif (des != null && extLogin != null) {\n-\t\t\tList<String> powerUsers = config.getRpcPowerusers();\n-\t\t\tif (powerUsers.contains(extLogin) && des.contains(DELEGATED_LOGIN)) {\n-\t\t\t\t// Rewrite the remoteUser and extSource\n-\t\t\t\textLogin = des.readString(DELEGATED_LOGIN);\n-\t\t\t\textSourceName = des.readString(DELEGATED_EXTSOURCE_NAME);\n-\t\t\t\textSourceType = des.readString(DELEGATED_EXTSOURCE_TYPE);\n-\t\t\t\t// Clear additionalInformations because they were valid only to the user who can do delegation\n-\t\t\t\tadditionalInformations.clear();\n-\t\t\t}\n-\t\t}\n-\n-\t\t// extSourceLoa must be number, if any specified then set to 0\n-\t\tif (isEmpty(extSourceLoaString)) {\n-\t\t\textSourceLoa = 0;\n-\t\t} else {\n-\t\t\ttry {\n-\t\t\t\textSourceLoa = Integer.parseInt(extSourceLoaString);\n-\t\t\t} catch (NumberFormatException ex) {\n-\t\t\t\textSourceLoa = 0;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Check if any of authentication system returns extLogin and extSourceName\n-\t\tif (isEmpty(extLogin) || isEmpty(extSourceName)) {\n-\t\t\tthrow new UserNotExistsException(\"extLogin or extSourceName is empty\");\n-\t\t}\n-\t\tlog.trace(\"creating PerunPrincipal(actor={},extSourceName={},extSourceType={},extSourceLoa={},additionalInformations={})\",extLogin,extSourceName, extSourceType, extSourceLoa, additionalInformations);\n-\t\treturn new PerunPrincipal(extLogin, extSourceName, extSourceType, extSourceLoa, additionalInformations);\n-\t}\n-\n-\tprivate PerunClient setupPerunClient(HttpServletRequest req) {\n-\n-\t\tif (isNotEmpty(req.getHeader(OIDC_CLAIM_SUB))) {\n-\t\t\tString clientId = req.getHeader(OIDC_CLAIM_CLIENT_ID);\n-\t\t\tList<String> scopes = Arrays.asList(req.getHeader(OIDC_CLAIM_SCOPE).split(\" \"));\n-\t\t\tlog.debug(\"detected OIDC/OAuth2 client {} with scopes {} for sub {}\", clientId, scopes, req.getHeader(OIDC_CLAIM_SUB));\n-\t\t\treturn new PerunClient(clientId, scopes);\n-\t\t}\n-\n-\t\t// If no OIDC header is present means it is not OAuth2 scenario => return trustful internal client.\n-\t\treturn new PerunClient();\n-\t}\n-\n-\n-\t@Override\n-\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n-\t\tmirrorOriginHeader(req,resp);\n-\t\tif (req.getPathInfo() == null || req.getPathInfo().equals(\"/\")) {\n-\t\t\tresp.setContentType(\"text/plain; charset=utf-8\");\n-\t\t\tWriter wrt = resp.getWriter();\n-\n-\t\t\tPerunPrincipal perunPrincipal;\n-\t\t\ttry {\n-\t\t\t\tperunPrincipal = setupPerunPrincipal(req,null);\n-\t\t\t\twrt.write(\"OK! Version: \" + PerunBl.PERUNVERSION + \", User: \" + perunPrincipal.getActor() + \", extSource: \" + perunPrincipal.getExtSourceName());\n-\t\t\t} catch (InternalErrorException | UserNotExistsException e) {\n-\t\t\t\twrt.write(\"ERROR! Exception \" + e.getMessage());\n-\t\t\t}\n-\n-\t\t\twrt.write(\"\\n\");\n-\n-\t\t\twrt.close();\n-\t\t} else {\n-\t\t\tserve(req, resp, true, false);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void doPut(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n-\t\tmirrorOriginHeader(req,resp);\n-\t\tserve(req, resp, false, true);\n-\t}\n-\n-\t@Override\n-\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n-\t\tmirrorOriginHeader(req,resp);\n-\t\tserve(req, resp, false, false);\n-\t}\n-\n-\t/**\n-\t * OPTIONS method is called by CORS pre-flight requests made by JavaScript clients running in browsers.\n-\t * The response must set CORS headers that allow the next request.\n-\t * @param req HTTP request\n-\t * @param resp HTTP response\n-\t */\n-\t@Override\n-\tprotected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n-\t\tmirrorOriginHeader(req,resp);\n-\t\tresp.setHeader(\"Access-Control-Allow-Methods\",\"GET, POST, OPTIONS\");\n-\t\tresp.setHeader(\"Access-Control-Allow-Headers\",\"Authorization, Content-Type\");\n-\t\tresp.setIntHeader(\"Access-Control-Max-Age\",86400);\n-\t\tresp.setStatus(HttpServletResponse.SC_NO_CONTENT);\n-\t}\n-\n-\tprivate void mirrorOriginHeader(HttpServletRequest req, HttpServletResponse resp) {\n-\t\tString origin = req.getHeader(\"Origin\");\n-\t\tif(origin==null) origin = \"*\";\n-\t\tresp.setHeader(\"Access-Control-Allow-Origin\",origin);\n-\t\tresp.setHeader(\"Vary\",\"Origin\");\n-\t}\n-\n-\t@SuppressWarnings(\"ConstantConditions\")\n-\tprivate void serve(HttpServletRequest req, HttpServletResponse resp, boolean isGet, boolean isPut) throws IOException {\n-\t\tSerializer ser = null;\n-\t\tString manager = \"N/A\";\n-\t\tString method = \"N/A\";\n-\t\tboolean isJsonp = false;\n-\t\tPerunRequest perunRequest = null;\n-\t\tApiCaller caller;\n-\t\tString callbackName = req.getParameter(\"callback\");\n-\n-\t\tlong timeStart = System.currentTimeMillis();\n-\t\tcaller = (ApiCaller) req.getSession(true).getAttribute(APICALLER);\n-\n-\t\tOutputStream out = resp.getOutputStream();\n-\n-\t\t// init pending request in HTTP session\n-\t\tif (req.getSession().getAttribute(PERUNREQUESTS) == null) {\n-\t\t\treq.getSession().setAttribute(PERUNREQUESTS, new ConcurrentSkipListMap<String, PerunRequest>());\n-\t\t}\n-\n-\t\t// store pending requests locally, because accessing it from session object after response is written would cause IllegalStateException\n-\t\t@SuppressWarnings(\"unchecked\")\n-\t\tConcurrentSkipListMap<String, PerunRequest> pendingRequests = ((ConcurrentSkipListMap<String, PerunRequest>) req.getSession().getAttribute(PERUNREQUESTS));\n-\n-\t\t// Check if it is request for list of pending operations.\n-\t\tif (req.getPathInfo().equals(\"/jsonp/\" + PERUNREQUESTSURL)) {\n-\t\t\t// name used to identify pending request\n-\t\t\tString callbackId = req.getParameter(\"callbackId\");\n-\t\t\tJsonSerializerJSONP serializer = new JsonSerializerJSONP(out, req, resp);\n-\t\t\tresp.setContentType(serializer.getContentType());\n-\t\t\ttry {\n-\t\t\t\t// Create a copy of the PERUNREQUESTS and then pass it to the serializer\n-\t\t\t\tif (callbackId != null) {\n-\t\t\t\t\t// return single entry\n-\t\t\t\t\tserializer.write(pendingRequests.get(callbackId));\n-\t\t\t\t} else {\n-\t\t\t\t\t// return all pending requests\n-\t\t\t\t\tserializer.write(Arrays.asList(pendingRequests.values().toArray()));\n-\t\t\t\t}\n-\t\t\t} catch (RpcException e) {\n-\t\t\t\tserializer.writePerunException(e);\n-\t\t\t}\n-\t\t\tout.close();\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t//prepare result object\n-\t\tObject result = null;\n-\n-\t\ttry {\n-\t\t\tString[] fcm; //[0] format, [1] class, [2] method\n-\t\t\ttry {\n-\t\t\t\tif (req.getPathInfo() == null) {\n-\t\t\t\t\tthrow new RpcException(RpcException.Type.NO_PATHINFO);\n-\t\t\t\t}\n-\n-\t\t\t\tfcm = req.getPathInfo().substring(1).split(\"/\", 3);\n-\t\t\t\tif (fcm.length != 3 || fcm[2].isEmpty()) {\n-\t\t\t\t\tthrow new RpcException(RpcException.Type.INVALID_URL, req.getPathInfo());\n-\t\t\t\t}\n-\t\t\t\tmanager = fcm[1];\n-\t\t\t\tmethod = fcm[2];\n-\n-\t\t\t\tser = selectSerializer(fcm[0], out, req, resp);\n-\n-\t\t\t\t// is the output JSONP?\n-\t\t\t\tif (\"jsonp\".equalsIgnoreCase(fcm[0])) {\n-\t\t\t\t\tisJsonp = true;\n-\t\t\t\t}\n-\n-\t\t\t\tresp.setContentType(ser.getContentType());\n-\t\t\t} catch (RpcException rex) {\n-\t\t\t\t//selects the default serializer (json) before throwing the exception\n-\t\t\t\tser = new JsonSerializer(out);\n-\t\t\t\tresp.setContentType(ser.getContentType());\n-\t\t\t\tthrow rex;\n-\t\t\t}\n-\n-\t\t\t// Initialize deserializer\n-\t\t\tDeserializer des;\n-\t\t\tif (isGet) {\n-\t\t\t\tdes = new UrlDeserializer(req);\n-\t\t\t} else {\n-\t\t\t\tdes = selectDeserializer(fcm[0], req);\n-\t\t\t}\n-\n-\t\t\t// We have new request, so do the whole auth/authz stuff\n-\t\t\tif (caller == null) {\n-\t\t\t\tcaller = new ApiCaller(getServletContext(), setupPerunPrincipal(req, des), setupPerunClient(req));\n-\t\t\t\t// Store the current session\n-\t\t\t\treq.getSession(true).setAttribute(APICALLER, caller);\n-\t\t\t} else if (!Objects.equals(caller.getSession().getPerunPrincipal().getExtSourceName(), getExtSourceName(req, des))) {\n-\t\t\t\t// If the user is coming from the URL protected by different authN mechanism, destroy and create session again\n-\t\t\t\tcaller = new ApiCaller(getServletContext(), setupPerunPrincipal(req, des), setupPerunClient(req));\n-\t\t\t\treq.getSession(true).setAttribute(APICALLER, caller);\n-\t\t\t} else if (!Objects.equals(caller.getSession().getPerunPrincipal().getActor(), getActor(req, des)) &&\n-\t\t\t\t\t!caller.getSession().getPerunPrincipal().getExtSourceName().equals(ExtSourcesManager.EXTSOURCE_NAME_LOCAL)) {\n-\t\t\t\t// prevent cookie stealing (if remote user changed, rebuild session)\n-\t\t\t\tcaller = new ApiCaller(getServletContext(), setupPerunPrincipal(req, des), setupPerunClient(req));\n-\t\t\t\treq.getSession(true).setAttribute(APICALLER, caller);\n-\t\t\t}\n-\n-\t\t\t// Does user want to logout from perun?\n-\t\t\tif (\"utils\".equals(manager) && \"logout\".equals(method)) {\n-\t\t\t\tif (req.getSession(false) != null) {\n-\t\t\t\t\treq.getSession().removeAttribute(APICALLER);\n-\n-\t\t\t\t\t// deletes the cookies\n-\t\t\t\t\tCookie[] cookies = req.getCookies();\n-\t\t\t\t\tif (cookies != null) {\n-\t\t\t\t\t\tfinal String SHIBBOLETH_COOKIE_FORMAT = \"^_shib.+$\";\n-\n-\t\t\t\t\t\tfor (Cookie c : cookies) {\n-\t\t\t\t\t\t\t// if shibboleth cookie\n-\t\t\t\t\t\t\tif (c.getName().matches(SHIBBOLETH_COOKIE_FORMAT)) {\n-\t\t\t\t\t\t\t\t// remove it\n-\t\t\t\t\t\t\t\tc.setValue(\"0\");\n-\t\t\t\t\t\t\t\tc.setMaxAge(0);\n-\t\t\t\t\t\t\t\t// add updated cookie to the response\n-\t\t\t\t\t\t\t\tresp.addCookie(c);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\t// Invalidate session\n-\n-\t\t\t\t\treq.getSession().invalidate();\n-\t\t\t\t}\n-\n-\t\t\t\tser.write(\"Logout\");\n-\t\t\t\t// closes the request\n-\t\t\t\tout.close();\n-\t\t\t\treturn;\n-\n-\t\t\t} else if (\"utils\".equals(manager) && \"getGuiConfiguration\".equals(method)) {\n-\n-\t\t\t\tser.write(BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-web-gui.properties\"));\n-\t\t\t\t// closes the request\n-\t\t\t\tout.close();\n-\t\t\t\treturn;\n-\n-\t\t\t} else if (\"utils\".equals(manager) && PERUNSTATUS.equals(method)) {\n-\t\t\t\tDate date = new Date();\n-\t\t\t\tTimestamp timestamp = new Timestamp(date.getTime());\n-\n-\t\t\t\tMap<String, Integer> auditerConsumers;\n-\t\t\t\t//noinspection unchecked\n-\t\t\t\tauditerConsumers = (Map<String, Integer>) caller.call(\"auditMessagesManager\", \"getAllAuditerConsumers\", des);\n-\n-\t\t\t\tList<String> perunStatus = new ArrayList<>();\n-\t\t\t\tperunStatus.add(\"Version of PerunDB: \" + caller.call(\"databaseManager\", \"getCurrentDatabaseVersion\", des));\n-\t\t\t\tperunStatus.add(\"Version of Servlet: \" + getServletContext().getServerInfo());\n-\t\t\t\tperunStatus.add(\"Version of DB-driver: \" + caller.call(\"databaseManager\", \"getDatabaseDriverInformation\", des));\n-\t\t\t\tperunStatus.add(\"Version of DB: \" + caller.call(\"databaseManager\", \"getDatabaseInformation\", des));\n-\t\t\t\tperunStatus.add(\"Version of Java platform: \" + System.getProperty(\"java.version\"));\n-\t\t\t\tfor (String consumerName : auditerConsumers.keySet()) {\n-\t\t\t\t\tInteger lastProcessedId = auditerConsumers.get(consumerName);\n-\t\t\t\t\tperunStatus.add(\"AuditerConsumer: '\" + consumerName + \"' with last processed id='\" + lastProcessedId + \"'\");\n-\t\t\t\t}\n-\t\t\t\tperunStatus.add(\"LastMessageId: \" + caller.call(\"auditMessagesManager\", \"getLastMessageId\", des));\n-\t\t\t\tperunStatus.add(\"Timestamp: \" + timestamp);\n-\t\t\t\tser.write(perunStatus);\n-\n-\t\t\t\tout.close();\n-\t\t\t\treturn;\n-\t\t\t} else if (\"utils\".equals(manager) && PERUNSTATISTICS.equals(method)) {\n-\t\t\t\tDate date = new Date();\n-\t\t\t\tTimestamp timestamp = new Timestamp(date.getTime());\n-\n-\t\t\t\tList<String> perunStatistics = new ArrayList<>();\n-\t\t\t\tperunStatistics.add(\"Timestamp: '\" + timestamp + \"'\");\n-\t\t\t\tperunStatistics.add(\"USERS: '\" + caller.call(\"usersManager\", \"getUsersCount\", des) + \"'\");\n-\t\t\t\tperunStatistics.add(\"FACILITIES: '\" + caller.call(\"facilitiesManager\", \"getFacilitiesCount\", des) + \"'\");\n-\t\t\t\tperunStatistics.add(\"DESTINATIONS: '\" + caller.call(\"servicesManager\", \"getDestinationsCount\", des) + \"'\");\n-\t\t\t\tperunStatistics.add(\"VOS: '\" + caller.call(\"vosManager\", \"getVosCount\", des) + \"'\");\n-\t\t\t\tperunStatistics.add(\"RESOURCES: '\" + caller.call(\"resourcesManager\", \"getResourcesCount\", des) + \"'\");\n-\t\t\t\tperunStatistics.add(\"GROUPS: '\" + caller.call(\"groupsManager\", \"getGroupsCount\", des) + \"'\");\n-\t\t\t\tperunStatistics.add(\"AUDITMESSAGES: '\" + caller.call(\"auditMessagesManager\", \"getAuditerMessagesCount\", des) + \"'\");\n-\t\t\t\tser.write(perunStatistics);\n-\n-\t\t\t\tout.close();\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// In case of GET requests (read ones) set changing state to false\n-\t\t\tcaller.setStateChanging(!isGet);\n-\n-\t\t\t// Store identification of the request only if supported by app (it passed unique callbackName)\n-\t\t\tif (callbackName != null) {\n-\n-\t\t\t\tperunRequest = new PerunRequest(caller.getSession().getPerunPrincipal(), callbackName,\n-\t\t\t\t\t\tmanager, method, des.readAll());\n-\n-\t\t\t\t// Add perunRequest into the queue of the requests for POST only\n-\t\t\t\tif (!isGet && !isPut) {\n-\t\t\t\t\tpendingRequests.put(callbackName, perunRequest);\n-\t\t\t\t}\n-\n-\t\t\t}\n-\n-\t\t\tPerunClient perunClient = caller.getSession().getPerunClient();\n-\t\t\tif(perunClient.getType() == PerunClient.Type.OAUTH) {\n-\t\t\t\tif(!perunClient.getScopes().contains(PerunClient.PERUN_API_SCOPE)) {\n-\t\t\t\t\t//user has not consented to scope perun_api for the client on the OAuth Authorization Server\n-\t\t\t\t\tthrow new PrivilegeException(\"Scope \"+PerunClient.PERUN_API_SCOPE+\" is missing, either the client app \"+perunClient.getId()+\" has not asked for it, or the user has not granted it.\");\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Process request and sent the response back\n-\t\t\tif (VOOTMANAGER.equals(manager)) {\n-\t\t\t\t// Process VOOT protocol\n-\t\t\t\tresult = caller.getVOOTManager().process(caller.getSession(), method, des.readAll());\n-\t\t\t\tif (perunRequest != null) perunRequest.setResult(result);\n-\t\t\t\tser.write(result);\n-\t\t\t} else {\n-\t\t\t\t//Save only exceptions from caller to result\n-\t\t\t\ttry {\n-\t\t\t\t\tresult = caller.call(manager, method, des);\n-\t\t\t\t\tif (perunRequest != null) perunRequest.setResult(result);\n-\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\tresult = ex;\n-\t\t\t\t\tthrow ex;\n-\t\t\t\t}\n-\t\t\t\tser.write(result);\n-\t\t\t}\n-\t\t} catch (PerunException pex) {\n-\t\t\t// If the output is JSONP, it cannot send the HTTP 400 code, because the web browser wouldn't accept this\n-\t\t\tif (!isJsonp) {\n-\t\t\t\tresp.setStatus(400);\n-\t\t\t}\n-\t\t\tser.writePerunException(pex);\n-\t\t} catch (PerunRuntimeException prex) {\n-\t\t\t// If the output is JSONP, it cannot send the HTTP 400 code, because the web browser wouldn't accept this\n-\t\t\tif (!isJsonp) {\n-\t\t\t\tresp.setStatus(400);\n-\t\t\t}\n-\t\t\tser.writePerunRuntimeException(prex);\n-\t\t} catch (IOException ioex) { //IOException gets logged and is rethrown\n-\t\t\t//noinspection ThrowableNotThrown\n-\t\t\tnew RpcException(RpcException.Type.UNCATCHED_EXCEPTION, ioex);\n-\t\t\tthrow ioex;\n-\t\t} catch (Exception ex) {\n-\t\t\t// If the output is JSONP, it cannot send the HTTP 400 code, because the web browser wouldn't accept this\n-\t\t\tif (!isJsonp) {\n-\t\t\t\tresp.setStatus(500);\n-\t\t\t}\n-\t\t\tser.writePerunException(new RpcException(RpcException.Type.UNCATCHED_EXCEPTION, ex));\n-\t\t} finally {\n-\t\t\tif (!isGet && !isPut && perunRequest != null) {\n-\t\t\t\t//save result of this perunRequest\n-\t\t\t\tperunRequest.setEndTime(System.currentTimeMillis());\n-\t\t\t\tif (result instanceof Exception) perunRequest.setResult(result);\n-\t\t\t\tperunRequest.setEndTime(System.currentTimeMillis());\n-\t\t\t}\n-\t\t\t//Check all resolved requests and remove them if they are old than timeToLiveWhenDone\n-\t\t\tIterator<String> iterator = pendingRequests.keySet().iterator();\n-\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\tString key = iterator.next();\n-\t\t\t\tPerunRequest value = pendingRequests.get(key);\n-\t\t\t\tif (value != null) {\n-\t\t\t\t\tif (value.getEndTime() < 0) continue;\n-\t\t\t\t\tif (System.currentTimeMillis() - value.getEndTime() > timeToLiveWhenDone) {\n-\t\t\t\t\t\titerator.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tout.close();\n-\n-\t\tlog.debug(\"Method {}.{} called by {} from {}, duration {} ms.\", manager, method, caller.getSession().getPerunPrincipal().getActor(), caller.getSession().getPerunPrincipal().getExtSourceName(), (System.currentTimeMillis() - timeStart));\n-\t}\n-\n-\tprivate Serializer selectSerializer(String format, OutputStream out, HttpServletRequest req, HttpServletResponse resp) throws IOException, RpcException {\n-\t\tswitch (Formats.match(format)) {\n-\t\t\tcase json:\n-\t\t\t\treturn new JsonSerializer(out);\n-\t\t\tcase jsonp:\n-\t\t\t\treturn new JsonSerializerJSONP(out, req, resp);\n-\t\t\tcase urlinjsonout:\n-\t\t\t\treturn new JsonSerializer(out);\n-\t\t\tcase voot:\n-\t\t\t\treturn new JsonSerializer(out);\n-\t\t\tcase jsonsimple:\n-\t\t\t\treturn new JsonSerializerJSONSIMPLE(out);\n-\t\t\tdefault:\n-\t\t\t\tthrow new RpcException(RpcException.Type.UNKNOWN_SERIALIZER_FORMAT, format);\n-\t\t}\n-\t}\n-\n-\tprivate Deserializer selectDeserializer(String format, HttpServletRequest req) throws IOException, RpcException {\n-\t\tswitch (Formats.match(format)) {\n-\t\t\tcase json:\n-\t\t\tcase jsonp:\n-\t\t\tcase jsonsimple:\n-\t\t\t\treturn new JsonDeserializer(req);\n-\t\t\tcase urlinjsonout:\n-\t\t\tcase voot:\n-\t\t\t\treturn new UrlDeserializer(req);\n-\t\t\tdefault:\n-\t\t\t\tthrow new RpcException(RpcException.Type.UNKNOWN_DESERIALIZER_FORMAT, format);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * This enum represents possible request/response content formats.\n-\t */\n-\tpublic enum Formats {\n-\n-\t\tNOMATCH,\n-\t\turlinjsonout,\n-\t\tjson,\n-\t\tjsonp,\n-\t\tvoot,\n-\t\tjsonsimple;\n-\n-\t\t/**\n-\t\t * Matches a string with the enum's values.\n-\t\t *\n-\t\t * @param str the string to match\n-\t\t * @return the matched value or {@code NOMATCH} if no matching value is found\n-\t\t * @throws NullPointerException if {@code str} is null\n-\t\t */\n-\t\tpublic static Formats match(String str) {\n-\t\t\ttry {\n-\t\t\t\treturn valueOf(str);\n-\t\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t\treturn NOMATCH;\n-\t\t\t}\n-\t\t}\n-\t}\n+    private final static Logger log = LoggerFactory.getLogger(Api.class);\n+\n+    private final static String APICALLER = \"apiCaller\";\n+    private final static String PERUNREQUESTS = \"perunRequests\";\n+    private final static String PERUNREQUESTSURL = \"getPendingRequests\";\n+    private final static String PERUNSTATUS = \"getPerunStatus\";\n+    private final static String PERUNSTATISTICS = \"getPerunStatistics\";\n+    private final static String VOOTMANAGER = \"vootManager\";\n+    private final static int timeToLiveWhenDone = 60 * 1000; // in milisec, if requests is done more than this time, remove it from list\n+\n+    private static final String SHIB_IDENTITY_PROVIDER = \"Shib-Identity-Provider\";\n+    private static final String SOURCE_IDP_ENTITY_ID = \"sourceIdPEntityID\";\n+    private static final String SSL_CLIENT_VERIFY = \"SSL_CLIENT_VERIFY\";\n+    private static final String SSL_CLIENT_ISSUER_DN = \"SSL_CLIENT_I_DN\";\n+    private static final String SSL_CLIENT_SUBJECT_DN = \"SSL_CLIENT_S_DN\";\n+    private static final String SSL_CLIENT_CERT = \"SSL_CLIENT_CERT\";\n+    private static final String SUCCESS = \"SUCCESS\";\n+    private static final String OIDC_CLAIM_SUB = \"OIDC_CLAIM_sub\";\n+    private static final String OIDC_CLAIM_CLIENT_ID = \"OIDC_CLAIM_client_id\";\n+    private static final String OIDC_CLAIM_SCOPE = \"OIDC_CLAIM_scope\";\n+    private static final String OIDC_CLAIM_ISS = \"OIDC_CLAIM_iss\";\n+    private static final String EXTSOURCE = \"EXTSOURCE\";\n+    private static final String EXTSOURCETYPE = \"EXTSOURCETYPE\";\n+    private static final String EXTSOURCELOA = \"EXTSOURCELOA\";\n+    private static final String ENV_REMOTE_USER = \"ENV_REMOTE_USER\";\n+    private static final String DELEGATED_LOGIN = \"delegatedLogin\";\n+    private static final String DELEGATED_EXTSOURCE_NAME = \"delegatedExtSourceName\";\n+    private static final String DELEGATED_EXTSOURCE_TYPE = \"delegatedExtSourceType\";\n+    private static final String LOA = \"loa\";\n+\n+    @Override\n+    public void init() {\n+        // we do not init anything\n+    }\n+\n+    private static String getStringAttribute(HttpServletRequest req, String attributeName) {\n+        return (String) req.getAttribute(attributeName);\n+    }\n+\n+    private static String getExtSourceName(HttpServletRequest req, Deserializer des) throws InternalErrorException {\n+        String shibIdentityProvider = getStringAttribute(req, SHIB_IDENTITY_PROVIDER);\n+        String sourceIdpEntityId = getStringAttribute(req, SOURCE_IDP_ENTITY_ID);\n+        if (isNotEmpty(shibIdentityProvider)) {\n+            return getOriginalIdP(shibIdentityProvider, sourceIdpEntityId);\n+        } else {\n+            if (isNotEmpty(req.getHeader(OIDC_CLAIM_SUB))) {\n+                String iss = req.getHeader(OIDC_CLAIM_ISS);\n+                if (iss != null) {\n+                    String extSourceName = BeansUtils.getCoreConfig().getOidcIssuersExtsourceNames().get(iss);\n+                    if (extSourceName != null) {\n+                        return extSourceName;\n+                    }\n+                }\n+                throw new InternalErrorException(\"OIDC issuer \" + iss + \" not configured\");\n+            } else if (Objects.equals(req.getAttribute(SSL_CLIENT_VERIFY), SUCCESS)) {\n+                return getStringAttribute(req, SSL_CLIENT_ISSUER_DN);\n+            } else {\n+                String extSource = getStringAttribute(req, EXTSOURCE);\n+                return extSource != null ? extSource : des.readString(DELEGATED_EXTSOURCE_NAME);\n+            }\n+        }\n+    }\n+\n+    private static String getOriginalIdP(String shibIdentityProvider, String sourceIdpEntityId) {\n+        // If IdP is proxy and we want to save original source IdP behind Proxy.\n+        List<String> proxyIdPs = BeansUtils.getCoreConfig().getProxyIdPs();\n+        if (isNotEmpty(sourceIdpEntityId)) {\n+            if (proxyIdPs.contains(shibIdentityProvider)) {\n+                return sourceIdpEntityId;\n+            } else {\n+                log.warn(\"sourceIdPEntityID attrribute found with value \" + sourceIdpEntityId +\n+                        \" in request but IdP with entityID: '\" + shibIdentityProvider +\n+                        \"' was not found in perun configuration property 'perun.proxyIdPs'=\" + proxyIdPs +\n+                        \". serving classical entityID instead of sourceIdPEntityID.\");\n+                return shibIdentityProvider;\n+            }\n+        } else {\n+            return shibIdentityProvider;\n+        }\n+    }\n+\n+    private static String getExtLogin(HttpServletRequest req, String extSourceName, String remoteUser) {\n+        if (isNotEmpty(remoteUser)) {\n+            return remoteUser;\n+        } else {\n+            String envRemoteUser = getStringAttribute(req, ENV_REMOTE_USER);\n+            if (isNotEmpty(envRemoteUser)) {\n+                return envRemoteUser;\n+            } else if (extSourceName.equals(ExtSourcesManager.EXTSOURCE_NAME_LOCAL)) {\n+                // LOCAL EXTSOURCE - If ExtSource is LOCAL then generate REMOTE_USER name on the fly\n+                return Long.toString(System.currentTimeMillis());\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private static String getActor(HttpServletRequest req, Deserializer des) throws InternalErrorException {\n+        String actor = null;\n+        String remoteUser = req.getRemoteUser();\n+        if (isNotEmpty(getStringAttribute(req, (SHIB_IDENTITY_PROVIDER)))) {\n+            if (isNotEmpty(remoteUser)) {\n+                actor = remoteUser;\n+            }\n+        } else if (isNotEmpty(req.getHeader(OIDC_CLAIM_SUB))) {\n+            actor = remoteUser;\n+        } else if (Objects.equals(req.getAttribute(SSL_CLIENT_VERIFY), SUCCESS)) {\n+            actor = getStringAttribute(req, SSL_CLIENT_SUBJECT_DN);\n+        } else {\n+            String extSourceName = getStringAttribute(req, EXTSOURCE);\n+            if (extSourceName != null) {\n+                actor = getExtLogin(req, extSourceName, remoteUser);\n+            }\n+        }\n+\n+        if (des != null && actor != null) {\n+            if (BeansUtils.getCoreConfig().getRpcPowerusers().contains(actor) && des.contains(DELEGATED_LOGIN)) {\n+                // Rewrite the remoteUser and extSource\n+                actor = des.readString(DELEGATED_LOGIN);\n+            }\n+        }\n+\n+        return actor;\n+\n+    }\n+\n+    private static PerunPrincipal setupPerunPrincipal(HttpServletRequest req, Deserializer des) throws InternalErrorException, UserNotExistsException {\n+        String extSourceLoaString = null;\n+        String extLogin = null;\n+        String extSourceName = null;\n+        String extSourceType = null;\n+        int extSourceLoa;\n+        Map<String, String> additionalInformations = new HashMap<>();\n+\n+        String shibIdentityProvider = getStringAttribute(req, SHIB_IDENTITY_PROVIDER);\n+        String sourceIdpEntityId = getStringAttribute(req, SOURCE_IDP_ENTITY_ID);\n+        String remoteUser = req.getRemoteUser();\n+\n+        CoreConfig config = BeansUtils.getCoreConfig();\n+\n+        // If we have header Shib-Identity-Provider, then the user uses identity federation to authenticate\n+        if (isNotEmpty(shibIdentityProvider)) {\n+            extSourceName = getOriginalIdP(shibIdentityProvider, sourceIdpEntityId);\n+            extSourceType = ExtSourcesManager.EXTSOURCE_IDP;\n+            extSourceLoaString = getStringAttribute(req, LOA);\n+            if (isEmpty(extSourceLoaString)) {\n+                extSourceLoaString = \"2\";\n+            }\n+\n+            // FIXME: find better place where do the operation with attributes from federation\n+            String eppn = getStringAttribute(req, \"eppn\");\n+            if (isNotEmpty(eppn)) {\n+                // Remove scope from the eppn attribute\n+                additionalInformations.put(\"eppnwoscope\", StringUtils.substringBefore(eppn, \"@\"));\n+            }\n+\n+            // Store IdP used by user to session, since for IdentityConsolidator and Registrar we need to know,\n+            // if user logged in through proxy or not - we provide different links etc.\n+            additionalInformations.put(\"originIdentityProvider\", shibIdentityProvider);\n+\n+            if (isNotEmpty(remoteUser)) {\n+                extLogin = remoteUser;\n+            }\n+        }\n+\n+        // If OIDC_CLAIM_sub header is present, it means user authenticated via OAuth2 with MITRE.\n+        else if (isNotEmpty(req.getHeader(OIDC_CLAIM_SUB))) {\n+            extLogin = req.getHeader(OIDC_CLAIM_SUB);\n+            //this is configurable, as the OIDC server has the source of sub claim also configurable\n+            String iss = req.getHeader(OIDC_CLAIM_ISS);\n+            if (iss != null) {\n+                extSourceName = BeansUtils.getCoreConfig().getOidcIssuersExtsourceNames().get(iss);\n+                extSourceType = BeansUtils.getCoreConfig().getOidcIssuersExtsourceTypes().get(iss);\n+                if (extSourceName == null || extSourceType == null) {\n+                    throw new InternalErrorException(\"OIDC issuer \" + iss + \" not configured\");\n+                }\n+            } else {\n+                throw new InternalErrorException(\"OIDC issuer not send by Authorization Server\");\n+            }\n+            extSourceLoaString = \"-1\";\n+            log.debug(\"detected OIDC/OAuth2 client for sub={},iss={}\", extLogin, iss);\n+        }\n+\n+        // EXT_SOURCE was defined in Apache configuration (e.g. Kerberos or Local)\n+        else if (req.getAttribute(EXTSOURCE) != null) {\n+            extSourceName = getStringAttribute(req, EXTSOURCE);\n+            extSourceType = getStringAttribute(req, EXTSOURCETYPE);\n+            extSourceLoaString = getStringAttribute(req, EXTSOURCELOA);\n+            extLogin = getExtLogin(req, extSourceName, remoteUser);\n+        }\n+\n+        // X509 cert was used\n+        // Cert must be last since Apache asks for certificate everytime and fills cert properties even when Kerberos is in place.\n+        else if (Objects.equals(req.getAttribute(SSL_CLIENT_VERIFY), SUCCESS)) {\n+            String certDN = getStringAttribute(req, SSL_CLIENT_SUBJECT_DN);\n+            String caDN = getStringAttribute(req, SSL_CLIENT_ISSUER_DN);\n+            String wholeCert = getStringAttribute(req, SSL_CLIENT_CERT);\n+            extSourceName = caDN;\n+            extSourceType = ExtSourcesManager.EXTSOURCE_X509;\n+            extSourceLoaString = getStringAttribute(req, EXTSOURCELOA);\n+            extLogin = certDN;\n+\n+            // Store X509 certificate in the additionalInformations structure\n+            //FIXME: duplicit\n+            additionalInformations.put(\"userCertificates\",\n+                    AttributesManagerBlImpl.escapeMapAttributeValue(certDN) + AttributesManagerImpl.KEY_VALUE_DELIMITER +\n+                            AttributesManagerBlImpl.escapeMapAttributeValue(wholeCert));\n+            additionalInformations.put(\"userCertDNs\",\n+                    AttributesManagerBlImpl.escapeMapAttributeValue(certDN) + AttributesManagerImpl.KEY_VALUE_DELIMITER +\n+                            AttributesManagerBlImpl.escapeMapAttributeValue(caDN));\n+            additionalInformations.put(SSL_CLIENT_SUBJECT_DN, certDN);\n+\n+            // Store X509\n+            additionalInformations.put(\"dn\", certDN);\n+            additionalInformations.put(\"cadn\", caDN);\n+            additionalInformations.put(\"certificate\", wholeCert);\n+\n+            // Get organization from the certificate\n+            Pattern p = Pattern.compile(\"[oO]\\\\s*=\\\\s*([^/]*)\");\n+            Matcher m = p.matcher(certDN);\n+            if (m.find()) {\n+                additionalInformations.put(\"o\", m.group(1));\n+            }\n+            // Get CN from the certificate\n+            Pattern p2 = Pattern.compile(\"CN=([^/]*)\");\n+            Matcher m2 = p2.matcher(certDN);\n+            if (m2.find()) {\n+                additionalInformations.put(\"cn\", m2.group(1));\n+            }\n+\n+            // Get the X.509 certificate object\n+            X509Certificate[] certs = (X509Certificate[]) req.getAttribute(\"javax.servlet.request.X509Certificate\");\n+\n+            // Get the emails\n+            if (certs != null && certs.length > 0 && certs[0] != null) {\n+                String emails = \"\";\n+\n+                Collection<List<?>> altNames;\n+                try {\n+                    altNames = certs[0].getSubjectAlternativeNames();\n+                    if (altNames != null) {\n+                        for (List<?> entry : altNames) {\n+                            if (((Integer) entry.get(0)) == 1) {\n+                                emails = (String) entry.get(1);\n+                            }\n+                        }\n+                    }\n+                } catch (CertificateParsingException e) {\n+                    log.error(\"Error during parsing certificate {}\", Arrays.asList(certs));\n+                }\n+\n+                additionalInformations.put(\"mail\", emails);\n+            }\n+        }\n+\n+        //store selected attributes for update\n+        for (AttributeDefinition attr : config.getAttributesForUpdate().getOrDefault(extSourceType, Collections.emptyList())) {\n+            String attrValue = (String) req.getAttribute(attr.getFriendlyName());\n+            if (attrValue != null) {\n+                //fix shibboleth encoding\n+                if (ExtSourcesManager.EXTSOURCE_IDP.equals(extSourceType)) {\n+                    try {\n+                        attrValue = new String(attrValue.getBytes(\"iso-8859-1\"), \"utf-8\");\n+                    } catch (UnsupportedEncodingException e) {\n+                        log.error(\"utf-8 is not known\");\n+                    }\n+                }\n+                log.debug(\"storing {}={} to additionalInformations\", attr.getFriendlyName(), attrValue);\n+                additionalInformations.put(attr.getFriendlyName(), attrValue);\n+            }\n+        }\n+\n+        // If the RPC was called by the user who can do delegation and delegatedLogin is set, set the values sent in the request\n+        if (des != null && extLogin != null) {\n+            List<String> powerUsers = config.getRpcPowerusers();\n+            if (powerUsers.contains(extLogin) && des.contains(DELEGATED_LOGIN)) {\n+                // Rewrite the remoteUser and extSource\n+                extLogin = des.readString(DELEGATED_LOGIN);\n+                extSourceName = des.readString(DELEGATED_EXTSOURCE_NAME);\n+                extSourceType = des.readString(DELEGATED_EXTSOURCE_TYPE);\n+                // Clear additionalInformations because they were valid only to the user who can do delegation\n+                additionalInformations.clear();\n+            }\n+        }\n+\n+        // extSourceLoa must be number, if any specified then set to 0\n+        if (isEmpty(extSourceLoaString)) {\n+            extSourceLoa = 0;\n+        } else {\n+            try {\n+                extSourceLoa = Integer.parseInt(extSourceLoaString);\n+            } catch (NumberFormatException ex) {\n+                extSourceLoa = 0;\n+            }\n+        }\n+\n+        // Check if any of authentication system returns extLogin and extSourceName\n+        if (isEmpty(extLogin) || isEmpty(extSourceName)) {\n+            throw new UserNotExistsException(\"extLogin or extSourceName is empty\");\n+        }\n+        log.trace(\"creating PerunPrincipal(actor={},extSourceName={},extSourceType={},extSourceLoa={},additionalInformations={})\", extLogin, extSourceName, extSourceType, extSourceLoa, additionalInformations);\n+        return new PerunPrincipal(extLogin, extSourceName, extSourceType, extSourceLoa, additionalInformations);\n+    }\n+\n+    private PerunClient setupPerunClient(HttpServletRequest req) {\n+\n+        if (isNotEmpty(req.getHeader(OIDC_CLAIM_SUB))) {\n+            String clientId = req.getHeader(OIDC_CLAIM_CLIENT_ID);\n+            List<String> scopes = Arrays.asList(req.getHeader(OIDC_CLAIM_SCOPE).split(\" \"));\n+            log.debug(\"detected OIDC/OAuth2 client {} with scopes {} for sub {}\", clientId, scopes, req.getHeader(OIDC_CLAIM_SUB));\n+            return new PerunClient(clientId, scopes);\n+        }\n+\n+        // If no OIDC header is present means it is not OAuth2 scenario => return trustful internal client.\n+        return new PerunClient();\n+    }\n+\n+\n+    @Override\n+    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n+        mirrorOriginHeader(req, resp);\n+        if (req.getPathInfo() == null || req.getPathInfo().equals(\"/\")) {\n+            resp.setContentType(\"text/plain; charset=utf-8\");\n+            Writer wrt = resp.getWriter();\n+\n+            PerunPrincipal perunPrincipal;\n+            try {\n+                perunPrincipal = setupPerunPrincipal(req, null);\n+                wrt.write(\"OK! Version: \" + PerunBl.PERUNVERSION + \", User: \" + perunPrincipal.getActor() + \", extSource: \" + perunPrincipal.getExtSourceName());\n+            } catch (InternalErrorException | UserNotExistsException e) {\n+                wrt.write(\"ERROR! Exception \" + e.getMessage());\n+            }\n+\n+            wrt.write(\"\\n\");\n+\n+            wrt.close();\n+        } else {\n+            serve(req, resp, true, false);\n+        }\n+    }\n+\n+    @Override\n+    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n+        mirrorOriginHeader(req, resp);\n+        serve(req, resp, false, true);\n+    }\n+\n+    @Override\n+    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n+        mirrorOriginHeader(req, resp);\n+        serve(req, resp, false, false);\n+    }\n+\n+    /**\n+     * OPTIONS method is called by CORS pre-flight requests made by JavaScript clients running in browsers.\n+     * The response must set CORS headers that allow the next request.\n+     *\n+     * @param req  HTTP request\n+     * @param resp HTTP response\n+     */\n+    @Override\n+    protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n+        mirrorOriginHeader(req, resp);\n+        resp.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\");\n+        resp.setHeader(\"Access-Control-Allow-Headers\", \"Authorization, Content-Type\");\n+        resp.setIntHeader(\"Access-Control-Max-Age\", 86400);\n+        resp.setStatus(HttpServletResponse.SC_NO_CONTENT);\n+    }\n+\n+    private void mirrorOriginHeader(HttpServletRequest req, HttpServletResponse resp) {\n+        String origin = req.getHeader(\"Origin\");\n+        if (origin == null) {\n+            origin = \"*\";\n+        }\n+        resp.setHeader(\"Access-Control-Allow-Origin\", origin);\n+        resp.setHeader(\"Vary\", \"Origin\");\n+    }\n+\n+    @SuppressWarnings(\"ConstantConditions\")\n+    private void serve(HttpServletRequest req, HttpServletResponse resp, boolean isGet, boolean isPut) throws IOException {\n+        Serializer ser = null;\n+        String manager = \"N/A\";\n+        String method = \"N/A\";\n+        boolean isJsonp = false;\n+        PerunRequest perunRequest = null;\n+        ApiCaller caller;\n+        String callbackName = req.getParameter(\"callback\");\n+\n+        long timeStart = System.currentTimeMillis();\n+        caller = (ApiCaller) req.getSession(true).getAttribute(APICALLER);\n+\n+        OutputStream out = resp.getOutputStream();\n+\n+        // init pending request in HTTP session\n+        if (req.getSession().getAttribute(PERUNREQUESTS) == null) {\n+            req.getSession().setAttribute(PERUNREQUESTS, new ConcurrentSkipListMap<String, PerunRequest>());\n+        }\n+\n+        // store pending requests locally, because accessing it from session object after response is written would cause IllegalStateException\n+        @SuppressWarnings(\"unchecked\")\n+        ConcurrentSkipListMap<String, PerunRequest> pendingRequests = ((ConcurrentSkipListMap<String, PerunRequest>) req.getSession().getAttribute(PERUNREQUESTS));\n+\n+        // Check if it is request for list of pending operations.\n+        if (req.getPathInfo().equals(\"/jsonp/\" + PERUNREQUESTSURL)) {\n+            // name used to identify pending request\n+            String callbackId = req.getParameter(\"callbackId\");\n+            JsonSerializerJSONP serializer = new JsonSerializerJSONP(out, req, resp);\n+            resp.setContentType(serializer.getContentType());\n+            try {\n+                // Create a copy of the PERUNREQUESTS and then pass it to the serializer\n+                if (callbackId != null) {\n+                    // return single entry\n+                    serializer.write(pendingRequests.get(callbackId));\n+                } else {\n+                    // return all pending requests\n+                    serializer.write(Arrays.asList(pendingRequests.values().toArray()));\n+                }\n+            } catch (RpcException e) {\n+                serializer.writePerunException(e);\n+            }\n+            out.close();\n+            return;\n+        }\n+\n+        //prepare result object\n+        Object result = null;\n+\n+        try {\n+            String[] fcm; //[0] format, [1] class, [2] method\n+            try {\n+                if (req.getPathInfo() == null) {\n+                    throw new RpcException(RpcException.Type.NO_PATHINFO);\n+                }\n+\n+                fcm = req.getPathInfo().substring(1).split(\"/\", 3);\n+                if (fcm.length != 3 || fcm[2].isEmpty()) {\n+                    throw new RpcException(RpcException.Type.INVALID_URL, req.getPathInfo());\n+                }\n+                manager = fcm[1];\n+                method = fcm[2];\n+\n+                ser = selectSerializer(fcm[0], out, req, resp);\n+\n+                // is the output JSONP?\n+                if (\"jsonp\".equalsIgnoreCase(fcm[0])) {\n+                    isJsonp = true;\n+                }\n+\n+                resp.setContentType(ser.getContentType());\n+            } catch (RpcException rex) {\n+                //selects the default serializer (json) before throwing the exception\n+                ser = new JsonSerializer(out);\n+                resp.setContentType(ser.getContentType());\n+                throw rex;\n+            }\n+\n+            // Initialize deserializer\n+            Deserializer des;\n+            if (isGet) {\n+                des = new UrlDeserializer(req);\n+            } else {\n+                des = selectDeserializer(fcm[0], req);\n+            }\n+\n+            // We have new request, so do the whole auth/authz stuff\n+            if (caller == null) {\n+                caller = new ApiCaller(getServletContext(), setupPerunPrincipal(req, des), setupPerunClient(req));\n+                // Store the current session\n+                req.getSession(true).setAttribute(APICALLER, caller);\n+            } else if (!Objects.equals(caller.getSession().getPerunPrincipal().getExtSourceName(), getExtSourceName(req, des))) {\n+                // If the user is coming from the URL protected by different authN mechanism, destroy and create session again\n+                caller = new ApiCaller(getServletContext(), setupPerunPrincipal(req, des), setupPerunClient(req));\n+                req.getSession(true).setAttribute(APICALLER, caller);\n+            } else if (!Objects.equals(caller.getSession().getPerunPrincipal().getActor(), getActor(req, des)) &&\n+                    !caller.getSession().getPerunPrincipal().getExtSourceName().equals(ExtSourcesManager.EXTSOURCE_NAME_LOCAL)) {\n+                // prevent cookie stealing (if remote user changed, rebuild session)\n+                caller = new ApiCaller(getServletContext(), setupPerunPrincipal(req, des), setupPerunClient(req));\n+                req.getSession(true).setAttribute(APICALLER, caller);\n+            }\n+\n+            // Does user want to logout from perun?\n+            if (\"utils\".equals(manager) && \"logout\".equals(method)) {\n+                if (req.getSession(false) != null) {\n+                    req.getSession().removeAttribute(APICALLER);\n+\n+                    // deletes the cookies\n+                    Cookie[] cookies = req.getCookies();\n+                    if (cookies != null) {\n+                        final String SHIBBOLETH_COOKIE_FORMAT = \"^_shib.+$\";\n+\n+                        for (Cookie c : cookies) {\n+                            // if shibboleth cookie\n+                            if (c.getName().matches(SHIBBOLETH_COOKIE_FORMAT)) {\n+                                // remove it\n+                                c.setValue(\"0\");\n+                                c.setMaxAge(0);\n+                                // add updated cookie to the response\n+                                resp.addCookie(c);\n+                            }\n+                        }\n+                    }\n+                    // Invalidate session\n+\n+                    req.getSession().invalidate();\n+                }\n+\n+                ser.write(\"Logout\");\n+                // closes the request\n+                out.close();\n+                return;\n+\n+            } else if (\"utils\".equals(manager) && \"getGuiConfiguration\".equals(method)) {\n+\n+                ser.write(BeansUtils.getAllPropertiesFromCustomConfiguration(\"perun-web-gui.properties\"));\n+                // closes the request\n+                out.close();\n+                return;\n+\n+            } else if (\"utils\".equals(manager) && PERUNSTATUS.equals(method)) {\n+                Date date = new Date();\n+                Timestamp timestamp = new Timestamp(date.getTime());\n+\n+                Map<String, Integer> auditerConsumers;\n+                //noinspection unchecked\n+                auditerConsumers = (Map<String, Integer>) caller.call(\"auditMessagesManager\", \"getAllAuditerConsumers\", des);\n+\n+                List<String> perunStatus = new ArrayList<>();\n+                perunStatus.add(\"Version of PerunDB: \" + caller.call(\"databaseManager\", \"getCurrentDatabaseVersion\", des));\n+                perunStatus.add(\"Version of Servlet: \" + getServletContext().getServerInfo());\n+                perunStatus.add(\"Version of DB-driver: \" + caller.call(\"databaseManager\", \"getDatabaseDriverInformation\", des));\n+                perunStatus.add(\"Version of DB: \" + caller.call(\"databaseManager\", \"getDatabaseInformation\", des));\n+                perunStatus.add(\"Version of Java platform: \" + System.getProperty(\"java.version\"));\n+                for (String consumerName : auditerConsumers.keySet()) {\n+                    Integer lastProcessedId = auditerConsumers.get(consumerName);\n+                    perunStatus.add(\"AuditerConsumer: '\" + consumerName + \"' with last processed id='\" + lastProcessedId + \"'\");\n+                }\n+                perunStatus.add(\"LastMessageId: \" + caller.call(\"auditMessagesManager\", \"getLastMessageId\", des));\n+                perunStatus.add(\"Timestamp: \" + timestamp);\n+                ser.write(perunStatus);\n+\n+                out.close();\n+                return;\n+            } else if (\"utils\".equals(manager) && PERUNSTATISTICS.equals(method)) {\n+                Date date = new Date();\n+                Timestamp timestamp = new Timestamp(date.getTime());\n+\n+                List<String> perunStatistics = new ArrayList<>();\n+                perunStatistics.add(\"Timestamp: '\" + timestamp + \"'\");\n+                perunStatistics.add(\"USERS: '\" + caller.call(\"usersManager\", \"getUsersCount\", des) + \"'\");\n+                perunStatistics.add(\"FACILITIES: '\" + caller.call(\"facilitiesManager\", \"getFacilitiesCount\", des) + \"'\");\n+                perunStatistics.add(\"DESTINATIONS: '\" + caller.call(\"servicesManager\", \"getDestinationsCount\", des) + \"'\");\n+                perunStatistics.add(\"VOS: '\" + caller.call(\"vosManager\", \"getVosCount\", des) + \"'\");\n+                perunStatistics.add(\"RESOURCES: '\" + caller.call(\"resourcesManager\", \"getResourcesCount\", des) + \"'\");\n+                perunStatistics.add(\"GROUPS: '\" + caller.call(\"groupsManager\", \"getGroupsCount\", des) + \"'\");\n+                perunStatistics.add(\"AUDITMESSAGES: '\" + caller.call(\"auditMessagesManager\", \"getAuditerMessagesCount\", des) + \"'\");\n+                ser.write(perunStatistics);\n+\n+                out.close();\n+                return;\n+            }\n+\n+            // In case of GET requests (read ones) set changing state to false\n+            caller.setStateChanging(!isGet);\n+\n+            // Store identification of the request only if supported by app (it passed unique callbackName)\n+            if (callbackName != null) {\n+\n+                perunRequest = new PerunRequest(caller.getSession().getPerunPrincipal(), callbackName,\n+                        manager, method, des.readAll());\n+\n+                // Add perunRequest into the queue of the requests for POST only\n+                if (!isGet && !isPut) {\n+                    pendingRequests.put(callbackName, perunRequest);\n+                }\n+\n+            }\n+\n+            PerunClient perunClient = caller.getSession().getPerunClient();\n+            if (perunClient.getType() == PerunClient.Type.OAUTH) {\n+                if (!perunClient.getScopes().contains(PerunClient.PERUN_API_SCOPE)) {\n+                    //user has not consented to scope perun_api for the client on the OAuth Authorization Server\n+                    throw new PrivilegeException(\"Scope \" + PerunClient.PERUN_API_SCOPE + \" is missing, either the client app \" + perunClient.getId() + \" has not asked for it, or the user has not granted it.\");\n+                }\n+            }\n+\n+            // Process request and sent the response back\n+            if (VOOTMANAGER.equals(manager)) {\n+                // Process VOOT protocol\n+                result = caller.getVOOTManager().process(caller.getSession(), method, des.readAll());\n+                if (perunRequest != null) {\n+                    perunRequest.setResult(result);\n+                }\n+                ser.write(result);\n+            } else {\n+                //Save only exceptions from caller to result\n+                try {\n+                    result = caller.call(manager, method, des);\n+                    if (perunRequest != null) {\n+                        perunRequest.setResult(result);\n+                    }\n+                } catch (Exception ex) {\n+                    result = ex;\n+                    throw ex;\n+                }\n+                ser.write(result);\n+            }\n+        } catch (PerunException pex) {\n+            // If the output is JSONP, it cannot send the HTTP 400 code, because the web browser wouldn't accept this\n+            if (!isJsonp) {\n+                resp.setStatus(400);\n+            }\n+            ser.writePerunException(pex);\n+        } catch (PerunRuntimeException prex) {\n+            // If the output is JSONP, it cannot send the HTTP 400 code, because the web browser wouldn't accept this\n+            if (!isJsonp) {\n+                resp.setStatus(400);\n+            }\n+            ser.writePerunRuntimeException(prex);\n+        } catch (IOException ioex) { //IOException gets logged and is rethrown\n+            //noinspection ThrowableNotThrown\n+            new RpcException(RpcException.Type.UNCATCHED_EXCEPTION, ioex);\n+            throw ioex;\n+        } catch (Exception ex) {\n+            // If the output is JSONP, it cannot send the HTTP 400 code, because the web browser wouldn't accept this\n+            if (!isJsonp) {\n+                resp.setStatus(500);\n+            }\n+            ser.writePerunException(new RpcException(RpcException.Type.UNCATCHED_EXCEPTION, ex));\n+        } finally {\n+            if (!isGet && !isPut && perunRequest != null) {\n+                //save result of this perunRequest\n+                perunRequest.setEndTime(System.currentTimeMillis());\n+                if (result instanceof Exception) {\n+                    perunRequest.setResult(result);\n+                }\n+                perunRequest.setEndTime(System.currentTimeMillis());\n+            }\n+            //Check all resolved requests and remove them if they are old than timeToLiveWhenDone\n+            Iterator<String> iterator = pendingRequests.keySet().iterator();\n+            while (iterator.hasNext()) {\n+                String key = iterator.next();\n+                PerunRequest value = pendingRequests.get(key);\n+                if (value != null) {\n+                    if (value.getEndTime() < 0) {\n+                        continue;\n+                    }\n+                    if (System.currentTimeMillis() - value.getEndTime() > timeToLiveWhenDone) {\n+                        iterator.remove();\n+                    }\n+                }\n+            }\n+        }\n+\n+        out.close();\n+\n+        log.debug(\"Method {}.{} called by {} from {}, duration {} ms.\", manager, method, caller.getSession().getPerunPrincipal().getActor(), caller.getSession().getPerunPrincipal().getExtSourceName(), (System.currentTimeMillis() - timeStart));\n+    }\n+\n+    private Serializer selectSerializer(String format, OutputStream out, HttpServletRequest req, HttpServletResponse resp) throws IOException, RpcException {\n+        switch (Formats.match(format)) {\n+            case json:\n+                return new JsonSerializer(out);\n+            case jsonp:\n+                return new JsonSerializerJSONP(out, req, resp);\n+            case urlinjsonout:\n+                return new JsonSerializer(out);\n+            case voot:\n+                return new JsonSerializer(out);\n+            case jsonsimple:\n+                return new JsonSerializerJSONSIMPLE(out);\n+            default:\n+                throw new RpcException(RpcException.Type.UNKNOWN_SERIALIZER_FORMAT, format);\n+        }\n+    }\n+\n+    private Deserializer selectDeserializer(String format, HttpServletRequest req) throws IOException, RpcException {\n+        switch (Formats.match(format)) {\n+            case json:\n+            case jsonp:\n+            case jsonsimple:\n+                return new JsonDeserializer(req);\n+            case urlinjsonout:\n+            case voot:\n+                return new UrlDeserializer(req);\n+            default:\n+                throw new RpcException(RpcException.Type.UNKNOWN_DESERIALIZER_FORMAT, format);\n+        }\n+    }\n+\n+    /**\n+     * This enum represents possible request/response content formats.\n+     */\n+    public enum Formats {\n+\n+        NOMATCH,\n+        urlinjsonout,\n+        json,\n+        jsonp,\n+        voot,\n+        jsonsimple;\n+\n+        /**\n+         * Matches a string with the enum's values.\n+         *\n+         * @param str the string to match\n+         * @return the matched value or {@code NOMATCH} if no matching value is found\n+         * @throws NullPointerException if {@code str} is null\n+         */\n+        public static Formats match(String str) {\n+            try {\n+                return valueOf(str);\n+            } catch (IllegalArgumentException ex) {\n+                return NOMATCH;\n+            }\n+        }\n+    }\n \n }\n",
            "diff_size": 716
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/100/Api.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/100/Api.java\nindex 8c8eeb36279..7393158c23b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/100/Api.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/100/Api.java\n@@ -206,7 +206,7 @@ public class Api extends HttpServlet {\n \t\tString remoteUser = req.getRemoteUser();\n \n \t\tCoreConfig config = BeansUtils.getCoreConfig();\n-\t\t\n+\n \t\t// If we have header Shib-Identity-Provider, then the user uses identity federation to authenticate\n \t\tif (isNotEmpty(shibIdentityProvider)) {\n \t\t\textSourceName = getOriginalIdP(shibIdentityProvider, sourceIdpEntityId);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/100/Api.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/100/Api.java\nindex 8c8eeb36279..6dff76ce7c7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/100/Api.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/100/Api.java\n@@ -205,9 +205,9 @@ public class Api extends HttpServlet {\n \t\tString sourceIdpEntityId = getStringAttribute(req, SOURCE_IDP_ENTITY_ID);\n \t\tString remoteUser = req.getRemoteUser();\n \n-\t\tCoreConfig config = BeansUtils.getCoreConfig();\n-\t\t\n-\t\t// If we have header Shib-Identity-Provider, then the user uses identity federation to authenticate\n+\t\tCoreConfig config = BeansUtils.getCoreConfig()\n+\n+\t\t; // If we have header Shib-Identity-Provider, then the user uses identity federation to authenticate\n \t\tif (isNotEmpty(shibIdentityProvider)) {\n \t\t\textSourceName = getOriginalIdP(shibIdentityProvider, sourceIdpEntityId);\n \t\t\textSourceType = ExtSourcesManager.EXTSOURCE_IDP;\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}