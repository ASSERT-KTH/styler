{
    "project_name": "graphfoundation-ongdb",
    "error_id": "237",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "110",
                    "column": "31",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "110",
                    "column": "44",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "115",
                    "column": "44",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "115",
                    "column": "83",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "120",
                    "column": "46",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "120",
                    "column": "72",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "139",
                    "column": "43",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "139",
                    "column": "56",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "152",
                    "column": "41",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "152",
                    "column": "66",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "158",
                    "column": "35",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "158",
                    "column": "48",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "163",
                    "column": "44",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "163",
                    "column": "57",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "177",
                    "column": "37",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "177",
                    "column": "50",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "188",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "188",
                    "column": "48",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "194",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "194",
                    "column": "44",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "202",
                    "column": "39",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "202",
                    "column": "74",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "204",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "204",
                    "column": "27",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "212",
                    "column": "45",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "212",
                    "column": "52",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "214",
                    "column": "43",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "214",
                    "column": "94",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "220",
                    "column": "33",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "220",
                    "column": "46",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "227",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "227",
                    "column": "30",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "233",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "233",
                    "column": "46",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "236",
                    "column": "48",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "236",
                    "column": "55",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "238",
                    "column": "43",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "238",
                    "column": "88",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "241",
                    "column": "30",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "241",
                    "column": "37",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "246",
                    "column": "52",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "246",
                    "column": "65",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "255",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "255",
                    "column": "30",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "260",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "260",
                    "column": "30",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "266",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "266",
                    "column": "46",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "280",
                    "column": "41",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "280",
                    "column": "54",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "294",
                    "column": "37",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "294",
                    "column": "50",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "306",
                    "column": "53",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "306",
                    "column": "66",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "313",
                    "column": "51",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "313",
                    "column": "64",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "316",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "316",
                    "column": "35",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "323",
                    "column": "52",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "323",
                    "column": "59",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "325",
                    "column": "43",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "325",
                    "column": "92",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "336",
                    "column": "68",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "336",
                    "column": "81",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "339",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "339",
                    "column": "35",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "341",
                    "column": "38",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "341",
                    "column": "105",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "360",
                    "column": "34",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "360",
                    "column": "47",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "363",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "363",
                    "column": "28",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "376",
                    "column": "33",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "376",
                    "column": "75",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "383",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "383",
                    "column": "37",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "389",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "389",
                    "column": "58",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "395",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "395",
                    "column": "46",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "398",
                    "column": "48",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "398",
                    "column": "55",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "400",
                    "column": "43",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "400",
                    "column": "88",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "403",
                    "column": "38",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "403",
                    "column": "45",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "414",
                    "column": "25",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "414",
                    "column": "38",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/237/OffHeapPageLock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/237/OffHeapPageLock.java\nindex d96bc34d82e..d910695663d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/237/OffHeapPageLock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/237/OffHeapPageLock.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.io.pagecache.impl.muninn;\n \n import org.neo4j.unsafe.impl.internal.dragons.UnsafeUtil;\n@@ -60,358 +61,358 @@ import org.neo4j.unsafe.impl.internal.dragons.UnsafeUtil;\n  */\n public final class OffHeapPageLock\n {\n-    /*\n-     * Bits for counting concurrent write-locks. We use 17 bits because our pages are most likely 8192 bytes, and\n-     * 2^17 = 131.072, which is far more than our page size, so makes it highly unlikely that we are going to overflow\n-     * our concurrent write lock counter. Meanwhile, it's also small enough that we have a very large (2^44) number\n-     * space for our sequence. This one value controls the layout of the lock bit-state. The rest of the layout is\n-     * derived from this.\n-     *\n-     * With 17 writer count bits, the layout looks like this:\n-     *\n-     * \u250f\u2501 [FLS] Flush lock bit\n-     * \u2503\u250f\u2501 [EXL] Exclusive lock bit\n-     * \u2503\u2503\u250f\u2501 [MOD] Modified bit\n-     * \u2503\u2503\u2503    \u250f\u2501 [CNT] Count of currently concurrently held write locks, 17 bits.\n-     * \u2503\u2503\u2503    \u2503                 \u250f\u2501 [SEQ] 44 bits for the read lock sequence, incremented on write & exclusive unlock.\n-     * \u2503\u2503\u2503\u250f\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u250f\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n-     * FEMWWWWW WWWWWWWW WWWWSSSS SSSSSSSS SSSSSSSS SSSSSSSS SSSSSSSS SSSSSSSS\n-     * 1        2        3        4        5        6        7        8        byte\n-     */\n-    private static final long CNT_BITS = 17;\n-\n-    private static final long BITS_IN_LONG = 64;\n-    private static final long EXL_LOCK_BITS = 1; // Exclusive lock bits (only 1 is supported)\n-    private static final long FLS_LOCK_BITS = 1; // Flush lock bits (only 1 is supported)\n-    private static final long MOD_BITS = 1; // Modified state bits (only 1 is supported)\n-    private static final long SEQ_BITS = BITS_IN_LONG - FLS_LOCK_BITS - EXL_LOCK_BITS - MOD_BITS - CNT_BITS;\n-\n-    // Bit map reference:              = 0bFEMWWWWW WWWWWWWW WWWWSSSS SSSSSSSS SSSSSSSS SSSSSSSS SSSSSSSS SSSSSSSS\n-    private static final long FLS_MASK = 0b10000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000L;\n-    private static final long EXL_MASK = 0b01000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000L;\n-    private static final long MOD_MASK = 0b00100000_00000000_00000000_00000000_00000000_00000000_00000000_00000000L;\n-    private static final long CNT_MASK = 0b00011111_11111111_11110000_00000000_00000000_00000000_00000000_00000000L;\n-    private static final long SEQ_MASK = 0b00000000_00000000_00001111_11111111_11111111_11111111_11111111_11111111L;\n-    private static final long CNT_UNIT = 0b00000000_00000000_00010000_00000000_00000000_00000000_00000000_00000000L;\n-    private static final long SEQ_IMSK = 0b11111111_11111111_11110000_00000000_00000000_00000000_00000000_00000000L;\n-    // Mask used to check optimistic read lock validity:\n-    private static final long CHK_MASK = 0b01011111_11111111_11111111_11111111_11111111_11111111_11111111_11111111L;\n-    // \"Flush and/or exclusive\" mask:\n-    private static final long FAE_MASK = 0b11000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000L;\n-    // Unlocked mask:\n-    private static final long UNL_MASK = 0b11011111_11111111_11110000_00000000_00000000_00000000_00000000_00000000L;\n-\n-    private OffHeapPageLock()\n+  /*\n+   * Bits for counting concurrent write-locks. We use 17 bits because our pages are most likely 8192 bytes, and\n+   * 2^17 = 131.072, which is far more than our page size, so makes it highly unlikely that we are going to overflow\n+   * our concurrent write lock counter. Meanwhile, it's also small enough that we have a very large (2^44) number\n+   * space for our sequence. This one value controls the layout of the lock bit-state. The rest of the layout is\n+   * derived from this.\n+   *\n+   * With 17 writer count bits, the layout looks like this:\n+   *\n+   * \u250f\u2501 [FLS] Flush lock bit\n+   * \u2503\u250f\u2501 [EXL] Exclusive lock bit\n+   * \u2503\u2503\u250f\u2501 [MOD] Modified bit\n+   * \u2503\u2503\u2503    \u250f\u2501 [CNT] Count of currently concurrently held write locks, 17 bits.\n+   * \u2503\u2503\u2503    \u2503                 \u250f\u2501 [SEQ] 44 bits for the read lock sequence, incremented on write & exclusive unlock.\n+   * \u2503\u2503\u2503\u250f\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u250f\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n+   * FEMWWWWW WWWWWWWW WWWWSSSS SSSSSSSS SSSSSSSS SSSSSSSS SSSSSSSS SSSSSSSS\n+   * 1        2        3        4        5        6        7        8        byte\n+   */\n+  private static final long CNT_BITS = 17;\n+\n+  private static final long BITS_IN_LONG = 64;\n+  private static final long EXL_LOCK_BITS = 1; // Exclusive lock bits (only 1 is supported)\n+  private static final long FLS_LOCK_BITS = 1; // Flush lock bits (only 1 is supported)\n+  private static final long MOD_BITS = 1; // Modified state bits (only 1 is supported)\n+  private static final long SEQ_BITS = BITS_IN_LONG - FLS_LOCK_BITS - EXL_LOCK_BITS - MOD_BITS - CNT_BITS;\n+\n+  // Bit map reference:              = 0bFEMWWWWW WWWWWWWW WWWWSSSS SSSSSSSS SSSSSSSS SSSSSSSS SSSSSSSS SSSSSSSS\n+  private static final long FLS_MASK = 0b10000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000L;\n+  private static final long EXL_MASK = 0b01000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000L;\n+  private static final long MOD_MASK = 0b00100000_00000000_00000000_00000000_00000000_00000000_00000000_00000000L;\n+  private static final long CNT_MASK = 0b00011111_11111111_11110000_00000000_00000000_00000000_00000000_00000000L;\n+  private static final long SEQ_MASK = 0b00000000_00000000_00001111_11111111_11111111_11111111_11111111_11111111L;\n+  private static final long CNT_UNIT = 0b00000000_00000000_00010000_00000000_00000000_00000000_00000000_00000000L;\n+  private static final long SEQ_IMSK = 0b11111111_11111111_11110000_00000000_00000000_00000000_00000000_00000000L;\n+  // Mask used to check optimistic read lock validity:\n+  private static final long CHK_MASK = 0b01011111_11111111_11111111_11111111_11111111_11111111_11111111_11111111L;\n+  // \"Flush and/or exclusive\" mask:\n+  private static final long FAE_MASK = 0b11000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000L;\n+  // Unlocked mask:\n+  private static final long UNL_MASK = 0b11011111_11111111_11110000_00000000_00000000_00000000_00000000_00000000L;\n+\n+  private OffHeapPageLock()\n+  {\n+    // The static version keeps all state externally.\n+  }\n+\n+  private static long getState(long address)\n+  {\n+    return UnsafeUtil.getLongVolatile(address);\n+  }\n+\n+  private static boolean compareAndSetState(long address, long expect, long update)\n+  {\n+    return UnsafeUtil.compareAndSwapLong(null, address, expect, update);\n+  }\n+\n+  private static void unconditionallySetState(long address, long update)\n+  {\n+    UnsafeUtil.putLongVolatile(address, update);\n+  }\n+\n+  /**\n+   * @return A newly initialised lock word, for a lock that is exclusively locked.\n+   */\n+  public static long initialLockWordWithExclusiveLock()\n+  {\n+    return EXL_MASK;\n+  }\n+\n+  /**\n+   * Start an optimistic critical section, and return a stamp that can be used to validate if the read lock was\n+   * consistent. That is, if no write or exclusive lock was overlapping with the optimistic read lock.\n+   *\n+   * @return A stamp that must be passed to {@link #validateReadLock(long, long)} to validate the critical section.\n+   */\n+  public static long tryOptimisticReadLock(long address)\n+  {\n+    return getState(address) & SEQ_MASK;\n+  }\n+\n+  /**\n+   * Validate a stamp from {@link #tryOptimisticReadLock(long)} or {@link #unlockExclusive(long)}, and return\n+   * {@code true} if no write or exclusive lock overlapped with the critical section of the optimistic read lock\n+   * represented by the stamp.\n+   *\n+   * @param stamp The stamp of the optimistic read lock.\n+   * @return {@code true} if the optimistic read lock was valid, {@code false} otherwise.\n+   */\n+  public static boolean validateReadLock(long address, long stamp)\n+  {\n+    UnsafeUtil.loadFence();\n+    return (getState(address) & CHK_MASK) == stamp;\n+  }\n+\n+  public static boolean isModified(long address)\n+  {\n+    return (getState(address) & MOD_MASK) == MOD_MASK;\n+  }\n+\n+  public static boolean isExclusivelyLocked(long address)\n+  {\n+    return (getState(address) & EXL_MASK) == EXL_MASK;\n+  }\n+\n+  /**\n+   * Try taking a concurrent write lock. Multiple write locks can be held at the same time. Write locks will\n+   * invalidate any optimistic read lock that overlaps with them, and write locks will make any attempt at grabbing\n+   * an exclusive lock fail. If an exclusive lock is currently held, then the attempt to take a write lock will fail.\n+   * <p>\n+   * Write locks must be paired with a corresponding {@link #unlockWrite(long)}.\n+   *\n+   * @return {@code true} if the write lock was taken, {@code false} otherwise.\n+   */\n+  public static boolean tryWriteLock(long address)\n+  {\n+    long s;\n+    long n;\n+    for (; ; )\n     {\n-        // The static version keeps all state externally.\n-    }\n-\n-    private static long getState( long address )\n-    {\n-        return UnsafeUtil.getLongVolatile( address );\n-    }\n-\n-    private static boolean compareAndSetState( long address, long expect, long update )\n-    {\n-        return UnsafeUtil.compareAndSwapLong( null, address, expect, update );\n-    }\n-\n-    private static void unconditionallySetState( long address, long update )\n-    {\n-        UnsafeUtil.putLongVolatile( address, update );\n-    }\n-\n-    /**\n-     * @return A newly initialised lock word, for a lock that is exclusively locked.\n-     */\n-    public static long initialLockWordWithExclusiveLock()\n-    {\n-        return EXL_MASK;\n-    }\n-\n-    /**\n-     * Start an optimistic critical section, and return a stamp that can be used to validate if the read lock was\n-     * consistent. That is, if no write or exclusive lock was overlapping with the optimistic read lock.\n-     *\n-     * @return A stamp that must be passed to {@link #validateReadLock(long, long)} to validate the critical section.\n-     */\n-    public static long tryOptimisticReadLock( long address )\n-    {\n-        return getState( address ) & SEQ_MASK;\n-    }\n-\n-    /**\n-     * Validate a stamp from {@link #tryOptimisticReadLock(long)} or {@link #unlockExclusive(long)}, and return\n-     * {@code true} if no write or exclusive lock overlapped with the critical section of the optimistic read lock\n-     * represented by the stamp.\n-     *\n-     * @param stamp The stamp of the optimistic read lock.\n-     * @return {@code true} if the optimistic read lock was valid, {@code false} otherwise.\n-     */\n-    public static boolean validateReadLock( long address, long stamp )\n-    {\n-        UnsafeUtil.loadFence();\n-        return (getState( address ) & CHK_MASK) == stamp;\n-    }\n-\n-    public static boolean isModified( long address )\n-    {\n-        return (getState( address ) & MOD_MASK) == MOD_MASK;\n-    }\n-\n-    public static boolean isExclusivelyLocked( long address )\n-    {\n-        return (getState( address ) & EXL_MASK) == EXL_MASK;\n-    }\n-\n-    /**\n-     * Try taking a concurrent write lock. Multiple write locks can be held at the same time. Write locks will\n-     * invalidate any optimistic read lock that overlaps with them, and write locks will make any attempt at grabbing\n-     * an exclusive lock fail. If an exclusive lock is currently held, then the attempt to take a write lock will fail.\n-     * <p>\n-     * Write locks must be paired with a corresponding {@link #unlockWrite(long)}.\n-     *\n-     * @return {@code true} if the write lock was taken, {@code false} otherwise.\n-     */\n-    public static boolean tryWriteLock( long address )\n-    {\n-        long s;\n-        long n;\n-        for ( ; ; )\n-        {\n-            s = getState( address );\n-            boolean unwritablyLocked = (s & EXL_MASK) != 0;\n-            boolean writeCountOverflow = (s & CNT_MASK) == CNT_MASK;\n-\n-            // bitwise-OR to reduce branching and allow more ILP\n-            if ( unwritablyLocked | writeCountOverflow )\n-            {\n-                return failWriteLock( s, writeCountOverflow );\n-            }\n-\n-            n = s + CNT_UNIT | MOD_MASK;\n-            if ( compareAndSetState( address, s, n ) )\n-            {\n-                UnsafeUtil.storeFence();\n-                return true;\n-            }\n-        }\n-    }\n-\n-    private static boolean failWriteLock( long s, boolean writeCountOverflow )\n-    {\n-        if ( writeCountOverflow )\n-        {\n-            throwWriteLockOverflow( s );\n-        }\n-        // Otherwise it was exclusively locked\n-        return false;\n-    }\n-\n-    private static void throwWriteLockOverflow( long s )\n-    {\n-        throw new IllegalMonitorStateException( \"Write lock counter overflow: \" + describeState( s ) );\n-    }\n-\n-    /**\n-     * Release a write lock taking with {@link #tryWriteLock(long)}.\n-     */\n-    public static void unlockWrite( long address )\n-    {\n-        long s;\n-        long n;\n-        do\n-        {\n-            s = getState( address );\n-            if ( (s & CNT_MASK) == 0 )\n-            {\n-                throwUnmatchedUnlockWrite( s );\n-            }\n-            n = nextSeq( s ) - CNT_UNIT;\n-        }\n-        while ( !compareAndSetState( address, s, n ) );\n-    }\n-\n-    private static void throwUnmatchedUnlockWrite( long s )\n-    {\n-        throw new IllegalMonitorStateException( \"Unmatched unlockWrite: \" + describeState( s ) );\n-    }\n-\n-    private static long nextSeq( long s )\n-    {\n-        return (s & SEQ_IMSK) + (s + 1 & SEQ_MASK);\n-    }\n-\n-    public static long unlockWriteAndTryTakeFlushLock( long address )\n-    {\n-        long s;\n-        long n;\n-        long r;\n-        do\n-        {\n-            r = 0;\n-            s = getState( address );\n-            if ( (s & CNT_MASK) == 0 )\n-            {\n-                throwUnmatchedUnlockWrite( s );\n-            }\n-            n = nextSeq( s ) - CNT_UNIT;\n-            if ( (n & FAE_MASK) == 0 )\n-            {\n-                n += FLS_MASK;\n-                r = n;\n-            }\n-        }\n-        while ( !compareAndSetState( address, s, n ) );\n-        UnsafeUtil.storeFence();\n-        return r;\n-    }\n-\n-    /**\n-     * Grab the exclusive lock if it is immediately available. Exclusive locks will invalidate any overlapping\n-     * optimistic read lock, and fail write and flush locks. If any write or flush locks are currently taken, or if\n-     * the exclusive lock is already taken, then the attempt to grab an exclusive lock will fail.\n-     * <p>\n-     * Successfully grabbed exclusive locks must always be paired with a corresponding {@link #unlockExclusive(long)}.\n-     *\n-     * @return {@code true} if we successfully got the exclusive lock, {@code false} otherwise.\n-     */\n-    public static boolean tryExclusiveLock( long address )\n-    {\n-        long s = getState( address );\n-        boolean res = ((s & UNL_MASK) == 0) && compareAndSetState( address, s, s + EXL_MASK );\n+      s = getState(address);\n+      boolean unwritablyLocked = (s & EXL_MASK) != 0;\n+      boolean writeCountOverflow = (s & CNT_MASK) == CNT_MASK;\n+\n+      // bitwise-OR to reduce branching and allow more ILP\n+      if (unwritablyLocked | writeCountOverflow)\n+      {\n+        return failWriteLock(s, writeCountOverflow);\n+      }\n+\n+      n = s + CNT_UNIT | MOD_MASK;\n+      if (compareAndSetState(address, s, n))\n+      {\n         UnsafeUtil.storeFence();\n-        return res;\n-    }\n-\n-    /**\n-     * Unlock the currently held exclusive lock, and atomically and implicitly take an optimistic read lock, as\n-     * represented by the returned stamp.\n-     *\n-     * @return A stamp that represents an optimistic read lock, in case you need it.\n-     */\n-    public static long unlockExclusive( long address )\n-    {\n-        long s = initiateExclusiveLockRelease( address );\n-        long n = nextSeq( s ) - EXL_MASK;\n-        // Exclusive locks prevent any state modifications from write locks\n-        unconditionallySetState( address, n );\n-        return n;\n-    }\n-\n-    /**\n-     * Atomically unlock the currently held exclusive lock, and take a write lock.\n-     */\n-    public static void unlockExclusiveAndTakeWriteLock( long address )\n-    {\n-        long s = initiateExclusiveLockRelease( address );\n-        long n = (nextSeq( s ) - EXL_MASK + CNT_UNIT) | MOD_MASK;\n-        unconditionallySetState( address, n );\n-    }\n-\n-    private static long initiateExclusiveLockRelease( long address )\n-    {\n-        long s = getState( address );\n-        if ( (s & EXL_MASK) != EXL_MASK )\n-        {\n-            throwUnmatchedUnlockExclusive( s );\n-        }\n-        return s;\n+        return true;\n+      }\n     }\n+  }\n \n-    private static void throwUnmatchedUnlockExclusive( long s )\n+  private static boolean failWriteLock(long s, boolean writeCountOverflow)\n+  {\n+    if (writeCountOverflow)\n     {\n-        throw new IllegalMonitorStateException( \"Unmatched unlockExclusive: \" + describeState( s ) );\n+      throwWriteLockOverflow(s);\n     }\n-\n-    /**\n-     * If the given lock is exclusively held, then the <em>modified</em> flag will be explicitly lowered (marked as\n-     * unmodified) if the <em>modified</em> is currently raised.\n-     * <p>\n-     * If the <em>modified</em> flag is currently not raised, then this method does nothing.\n-     *\n-     * @throws IllegalStateException if the lock at the given address is not in the exclusively locked state.\n-     */\n-    public static void explicitlyMarkPageUnmodifiedUnderExclusiveLock( long address )\n+    // Otherwise it was exclusively locked\n+    return false;\n+  }\n+\n+  private static void throwWriteLockOverflow(long s)\n+  {\n+    throw new IllegalMonitorStateException(\"Write lock counter overflow: \" + describeState(s));\n+  }\n+\n+  /**\n+   * Release a write lock taking with {@link #tryWriteLock(long)}.\n+   */\n+  public static void unlockWrite(long address)\n+  {\n+    long s;\n+    long n;\n+    do\n     {\n-        long s = getState( address );\n-        if ( (s & EXL_MASK) != EXL_MASK )\n-        {\n-            throw new IllegalStateException( \"Page must be exclusively locked to explicitly lower modified bit\" );\n-        }\n-        s = s & (~MOD_MASK);\n-        unconditionallySetState( address, s );\n+      s = getState(address);\n+      if ((s & CNT_MASK) == 0)\n+      {\n+        throwUnmatchedUnlockWrite(s);\n+      }\n+      n = nextSeq(s) - CNT_UNIT;\n     }\n-\n-    /**\n-     * Grab the flush lock if it is immediately available. Flush locks prevent overlapping exclusive locks,\n-     * but do not invalidate optimistic read locks, nor do they prevent overlapping write locks. Only one flush lock\n-     * can be held at a time. If any flush or exclusive lock is already held, the attempt to take the flush lock will\n-     * fail.\n-     * <p>\n-     * Successfully grabbed flush locks must always be paired with a corresponding\n-     * {@link #unlockFlush(long, long, boolean)}.\n-     *\n-     * @return If the lock is successfully grabbed, the method will return a stamp value that must be passed to the\n-     * {@link #unlockFlush(long, long, boolean)}, and which is used for detecting any overlapping write locks. If the\n-     * flush lock could not be taken, {@code 0} will be returned.\n-     */\n-    public static long tryFlushLock( long address )\n+    while (!compareAndSetState(address, s, n));\n+  }\n+\n+  private static void throwUnmatchedUnlockWrite(long s)\n+  {\n+    throw new IllegalMonitorStateException(\"Unmatched unlockWrite: \" + describeState(s));\n+  }\n+\n+  private static long nextSeq(long s)\n+  {\n+    return (s & SEQ_IMSK) + (s + 1 & SEQ_MASK);\n+  }\n+\n+  public static long unlockWriteAndTryTakeFlushLock(long address)\n+  {\n+    long s;\n+    long n;\n+    long r;\n+    do\n     {\n-        long s = getState( address );\n-        if ( (s & FAE_MASK) == 0 )\n-        {\n-            long n = s + FLS_MASK;\n-            boolean res = compareAndSetState( address, s, n );\n-            UnsafeUtil.storeFence();\n-            return res ? n : 0;\n-        }\n-        return 0;\n+      r = 0;\n+      s = getState(address);\n+      if ((s & CNT_MASK) == 0)\n+      {\n+        throwUnmatchedUnlockWrite(s);\n+      }\n+      n = nextSeq(s) - CNT_UNIT;\n+      if ((n & FAE_MASK) == 0)\n+      {\n+        n += FLS_MASK;\n+        r = n;\n+      }\n     }\n-\n-    /**\n-     * Unlock the currently held flush lock.\n-     */\n-    public static void unlockFlush( long address, long stamp, boolean success )\n+    while (!compareAndSetState(address, s, n));\n+    UnsafeUtil.storeFence();\n+    return r;\n+  }\n+\n+  /**\n+   * Grab the exclusive lock if it is immediately available. Exclusive locks will invalidate any overlapping\n+   * optimistic read lock, and fail write and flush locks. If any write or flush locks are currently taken, or if\n+   * the exclusive lock is already taken, then the attempt to grab an exclusive lock will fail.\n+   * <p>\n+   * Successfully grabbed exclusive locks must always be paired with a corresponding {@link #unlockExclusive(long)}.\n+   *\n+   * @return {@code true} if we successfully got the exclusive lock, {@code false} otherwise.\n+   */\n+  public static boolean tryExclusiveLock(long address)\n+  {\n+    long s = getState(address);\n+    boolean res = ((s & UNL_MASK) == 0) && compareAndSetState(address, s, s + EXL_MASK);\n+    UnsafeUtil.storeFence();\n+    return res;\n+  }\n+\n+  /**\n+   * Unlock the currently held exclusive lock, and atomically and implicitly take an optimistic read lock, as\n+   * represented by the returned stamp.\n+   *\n+   * @return A stamp that represents an optimistic read lock, in case you need it.\n+   */\n+  public static long unlockExclusive(long address)\n+  {\n+    long s = initiateExclusiveLockRelease(address);\n+    long n = nextSeq(s) - EXL_MASK;\n+    // Exclusive locks prevent any state modifications from write locks\n+    unconditionallySetState(address, n);\n+    return n;\n+  }\n+\n+  /**\n+   * Atomically unlock the currently held exclusive lock, and take a write lock.\n+   */\n+  public static void unlockExclusiveAndTakeWriteLock(long address)\n+  {\n+    long s = initiateExclusiveLockRelease(address);\n+    long n = (nextSeq(s) - EXL_MASK + CNT_UNIT) | MOD_MASK;\n+    unconditionallySetState(address, n);\n+  }\n+\n+  private static long initiateExclusiveLockRelease(long address)\n+  {\n+    long s = getState(address);\n+    if ((s & EXL_MASK) != EXL_MASK)\n     {\n-        long s;\n-        long n;\n-        do\n-        {\n-            s = getState( address );\n-            if ( (s & FLS_MASK) != FLS_MASK )\n-            {\n-                throwUnmatchedUnlockFlush( s );\n-            }\n-            // We don't increment the sequence with nextSeq here, because flush locks don't invalidate readers\n-            n = s - FLS_MASK;\n-            if ( success && (s & CHK_MASK) == (stamp & SEQ_MASK) )\n-            {\n-                // The flush was successful and we had no overlapping writers, thus we can lower the modified flag\n-                n = n & (~MOD_MASK);\n-            }\n-        }\n-        while ( !compareAndSetState( address, s, n ) );\n+      throwUnmatchedUnlockExclusive(s);\n     }\n-\n-    private static void throwUnmatchedUnlockFlush( long s )\n+    return s;\n+  }\n+\n+  private static void throwUnmatchedUnlockExclusive(long s)\n+  {\n+    throw new IllegalMonitorStateException(\"Unmatched unlockExclusive: \" + describeState(s));\n+  }\n+\n+  /**\n+   * If the given lock is exclusively held, then the <em>modified</em> flag will be explicitly lowered (marked as\n+   * unmodified) if the <em>modified</em> is currently raised.\n+   * <p>\n+   * If the <em>modified</em> flag is currently not raised, then this method does nothing.\n+   *\n+   * @throws IllegalStateException if the lock at the given address is not in the exclusively locked state.\n+   */\n+  public static void explicitlyMarkPageUnmodifiedUnderExclusiveLock(long address)\n+  {\n+    long s = getState(address);\n+    if ((s & EXL_MASK) != EXL_MASK)\n     {\n-        throw new IllegalMonitorStateException( \"Unmatched unlockFlush: \" + describeState( s ) );\n+      throw new IllegalStateException(\"Page must be exclusively locked to explicitly lower modified bit\");\n     }\n-\n-    private static String describeState( long s )\n+    s = s & (~MOD_MASK);\n+    unconditionallySetState(address, s);\n+  }\n+\n+  /**\n+   * Grab the flush lock if it is immediately available. Flush locks prevent overlapping exclusive locks,\n+   * but do not invalidate optimistic read locks, nor do they prevent overlapping write locks. Only one flush lock\n+   * can be held at a time. If any flush or exclusive lock is already held, the attempt to take the flush lock will\n+   * fail.\n+   * <p>\n+   * Successfully grabbed flush locks must always be paired with a corresponding\n+   * {@link #unlockFlush(long, long, boolean)}.\n+   *\n+   * @return If the lock is successfully grabbed, the method will return a stamp value that must be passed to the\n+   * {@link #unlockFlush(long, long, boolean)}, and which is used for detecting any overlapping write locks. If the\n+   * flush lock could not be taken, {@code 0} will be returned.\n+   */\n+  public static long tryFlushLock(long address)\n+  {\n+    long s = getState(address);\n+    if ((s & FAE_MASK) == 0)\n     {\n-        long flush = s >>> EXL_LOCK_BITS + MOD_BITS + CNT_BITS + SEQ_BITS;\n-        long excl = (s & EXL_MASK) >>> MOD_BITS + CNT_BITS + SEQ_BITS;\n-        long mod = (s & MOD_MASK) >>> CNT_BITS + SEQ_BITS;\n-        long cnt = (s & CNT_MASK) >> SEQ_BITS;\n-        long seq = s & SEQ_MASK;\n-        return \"OffHeapPageLock[\" +\n-               \"Flush: \" + flush + \", Excl: \" + excl + \", Mod: \" + mod + \", Ws: \" + cnt + \", S: \" + seq + \"]\";\n+      long n = s + FLS_MASK;\n+      boolean res = compareAndSetState(address, s, n);\n+      UnsafeUtil.storeFence();\n+      return res ? n : 0;\n     }\n-\n-    static String toString( long address )\n+    return 0;\n+  }\n+\n+  /**\n+   * Unlock the currently held flush lock.\n+   */\n+  public static void unlockFlush(long address, long stamp, boolean success)\n+  {\n+    long s;\n+    long n;\n+    do\n     {\n-        return describeState( getState( address ) );\n+      s = getState(address);\n+      if ((s & FLS_MASK) != FLS_MASK)\n+      {\n+        throwUnmatchedUnlockFlush(s);\n+      }\n+      // We don't increment the sequence with nextSeq here, because flush locks don't invalidate readers\n+      n = s - FLS_MASK;\n+      if (success && (s & CHK_MASK) == (stamp & SEQ_MASK))\n+      {\n+        // The flush was successful and we had no overlapping writers, thus we can lower the modified flag\n+        n = n & (~MOD_MASK);\n+      }\n     }\n+    while (!compareAndSetState(address, s, n));\n+  }\n+\n+  private static void throwUnmatchedUnlockFlush(long s)\n+  {\n+    throw new IllegalMonitorStateException(\"Unmatched unlockFlush: \" + describeState(s));\n+  }\n+\n+  private static String describeState(long s)\n+  {\n+    long flush = s >>> EXL_LOCK_BITS + MOD_BITS + CNT_BITS + SEQ_BITS;\n+    long excl = (s & EXL_MASK) >>> MOD_BITS + CNT_BITS + SEQ_BITS;\n+    long mod = (s & MOD_MASK) >>> CNT_BITS + SEQ_BITS;\n+    long cnt = (s & CNT_MASK) >> SEQ_BITS;\n+    long seq = s & SEQ_MASK;\n+    return \"OffHeapPageLock[\" +\n+        \"Flush: \" + flush + \", Excl: \" + excl + \", Mod: \" + mod + \", Ws: \" + cnt + \", S: \" + seq + \"]\";\n+  }\n+\n+  static String toString(long address)\n+  {\n+    return describeState(getState(address));\n+  }\n }\n",
            "diff_size": 556
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/237/OffHeapPageLock.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/237/OffHeapPageLock.java\nindex d96bc34d82e..3c5aaf88d3b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/237/OffHeapPageLock.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/237/OffHeapPageLock.java\n@@ -223,11 +223,12 @@ public final class OffHeapPageLock\n         do\n         {\n             s = getState( address );\n-            if ( (s & CNT_MASK) == 0 )\n+            if ( ( s & CNT_MASK) == 0 )\n             {\n                 throwUnmatchedUnlockWrite( s );\n             }\n-            n = nextSeq( s ) - CNT_UNIT;\n+\n+n = nextSeq( s ) - CNT_UNIT;\n         }\n         while ( !compareAndSetState( address, s, n ) );\n     }\n@@ -239,7 +240,7 @@ public final class OffHeapPageLock\n \n     private static long nextSeq( long s )\n     {\n-        return (s & SEQ_IMSK) + (s + 1 & SEQ_MASK);\n+        return ( s & SEQ_IMSK) + (s + 1 & SEQ_MASK);\n     }\n \n     public static long unlockWriteAndTryTakeFlushLock( long address )\n@@ -251,12 +252,13 @@ public final class OffHeapPageLock\n         {\n             r = 0;\n             s = getState( address );\n-            if ( (s & CNT_MASK) == 0 )\n+            if ( ( s & CNT_MASK) == 0 )\n             {\n                 throwUnmatchedUnlockWrite( s );\n             }\n-            n = nextSeq( s ) - CNT_UNIT;\n-            if ( (n & FAE_MASK) == 0 )\n+\n+n = nextSeq( s ) - CNT_UNIT;\n+            if ( ( n & FAE_MASK) == 0 )\n             {\n                 n += FLS_MASK;\n                 r = n;\n@@ -306,17 +308,19 @@ public final class OffHeapPageLock\n     {\n         long s = initiateExclusiveLockRelease( address );\n         long n = (nextSeq( s ) - EXL_MASK + CNT_UNIT) | MOD_MASK;\n-        unconditionallySetState( address, n );\n+\n+unconditionallySetState( address, n );\n     }\n \n     private static long initiateExclusiveLockRelease( long address )\n     {\n         long s = getState( address );\n-        if ( (s & EXL_MASK) != EXL_MASK )\n+        if ( ( s & EXL_MASK) != EXL_MASK )\n         {\n             throwUnmatchedUnlockExclusive( s );\n         }\n-        return s;\n+\n+return s;\n     }\n \n     private static void throwUnmatchedUnlockExclusive( long s )\n@@ -335,11 +339,12 @@ public final class OffHeapPageLock\n     public static void explicitlyMarkPageUnmodifiedUnderExclusiveLock( long address )\n     {\n         long s = getState( address );\n-        if ( (s & EXL_MASK) != EXL_MASK )\n+        if ( ( s & EXL_MASK) != EXL_MASK )\n         {\n             throw new IllegalStateException( \"Page must be exclusively locked to explicitly lower modified bit\" );\n         }\n-        s = s & (~MOD_MASK);\n+\n+s = s & (~MOD_MASK);\n         unconditionallySetState( address, s );\n     }\n \n@@ -359,7 +364,7 @@ public final class OffHeapPageLock\n     public static long tryFlushLock( long address )\n     {\n         long s = getState( address );\n-        if ( (s & FAE_MASK) == 0 )\n+        if ( ( s & FAE_MASK) == 0 )\n         {\n             long n = s + FLS_MASK;\n             boolean res = compareAndSetState( address, s, n );\n@@ -379,13 +384,13 @@ public final class OffHeapPageLock\n         do\n         {\n             s = getState( address );\n-            if ( (s & FLS_MASK) != FLS_MASK )\n+            if ( ( s & FLS_MASK) != FLS_MASK )\n             {\n                 throwUnmatchedUnlockFlush( s );\n             }\n             // We don't increment the sequence with nextSeq here, because flush locks don't invalidate readers\n             n = s - FLS_MASK;\n-            if ( success && (s & CHK_MASK) == (stamp & SEQ_MASK) )\n+            if ( success && ( s & CHK_MASK) == ( stamp & SEQ_MASK) )\n             {\n                 // The flush was successful and we had no overlapping writers, thus we can lower the modified flag\n                 n = n & (~MOD_MASK);\n@@ -406,12 +411,11 @@ public final class OffHeapPageLock\n         long mod = (s & MOD_MASK) >>> CNT_BITS + SEQ_BITS;\n         long cnt = (s & CNT_MASK) >> SEQ_BITS;\n         long seq = s & SEQ_MASK;\n-        return \"OffHeapPageLock[\" +\n-               \"Flush: \" + flush + \", Excl: \" + excl + \", Mod: \" + mod + \", Ws: \" + cnt + \", S: \" + seq + \"]\";\n+        return \"OffHeapPageLock[\" + \"Flush: \" + flush + \", Excl: \" + excl + \", Mod: \" + mod + \", Ws: \" + cnt + \", S: \" + seq + \"]\";\n     }\n \n     static String toString( long address )\n     {\n         return describeState( getState( address ) );\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 22
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}