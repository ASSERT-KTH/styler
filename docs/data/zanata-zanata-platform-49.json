{
    "project_name": "zanata-zanata-platform",
    "error_id": "49",
    "information": {
        "errors": [
            {
                "line": "127",
                "column": "61",
                "severity": "error",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "            });\n        } else if (!allowAnonymousAccessProvider.get() ||\n                !HttpUtil.isReadMethod(context.getMethod())){\n            // special cases for path such as '/test/' or '/oauth/' are now\n            // handled by having annotation @NoSecurityCheck on those API\n            // methods/classes. ZanataRestSecurityBinder will ensure that this",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/49/ZanataRestSecurityInterceptor.java\nindex f1b1c62cb0a..c0a3f838408 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/49/ZanataRestSecurityInterceptor.java\n@@ -124,7 +124,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n                 zanataIdentity.tryLogin();\n             });\n         } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+                !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/49/ZanataRestSecurityInterceptor.java\nindex f1b1c62cb0a..9942fb34abf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/49/ZanataRestSecurityInterceptor.java\n@@ -60,199 +60,199 @@ import cyclops.control.Either;\n // TODO rename this class to Filter since it's no longer a seam JAX-RS interceptor\n @ApplicationScoped\n public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n-    private static final Logger log =\n-            LoggerFactory.getLogger(ZanataRestSecurityInterceptor.class);\n-    private HttpServletRequest request;\n+  private static final Logger log =\n+    LoggerFactory.getLogger(ZanataRestSecurityInterceptor.class);\n+  private HttpServletRequest request;\n \n-    private SecurityTokens securityTokens;\n+  private SecurityTokens securityTokens;\n \n-    private ZanataIdentity zanataIdentity;\n+  private ZanataIdentity zanataIdentity;\n \n-    private boolean isOAuthEnabled;\n-    private IServiceLocator serviceLocator = ServiceLocator.instance();\n+  private boolean isOAuthEnabled;\n+  private IServiceLocator serviceLocator = ServiceLocator.instance();\n \n-    private Provider<Boolean> allowAnonymousAccessProvider;\n+  private Provider<Boolean> allowAnonymousAccessProvider;\n \n \n-    public ZanataRestSecurityInterceptor() {\n-    }\n+  public ZanataRestSecurityInterceptor() {\n+  }\n \n-    @Inject\n-    protected ZanataRestSecurityInterceptor(@DeltaSpike HttpServletRequest request,\n-            SecurityTokens securityTokens, ZanataIdentity zanataIdentity,\n-            @SupportOAuth boolean isOAuthEnabled, IServiceLocator serviceLocator,\n-            @AllowAnonymousAccess Provider<Boolean> allowAnonymousAccessProvider) {\n-        this.request = request;\n-        this.securityTokens = securityTokens;\n-        this.zanataIdentity = zanataIdentity;\n-        this.isOAuthEnabled = isOAuthEnabled;\n-        this.serviceLocator = serviceLocator;\n-        this.allowAnonymousAccessProvider = allowAnonymousAccessProvider;\n-    }\n+  @Inject\n+  protected ZanataRestSecurityInterceptor(@DeltaSpike HttpServletRequest request,\n+                                          SecurityTokens securityTokens, ZanataIdentity zanataIdentity,\n+                                          @SupportOAuth boolean isOAuthEnabled, IServiceLocator serviceLocator,\n+                                          @AllowAnonymousAccess Provider<Boolean> allowAnonymousAccessProvider) {\n+    this.request = request;\n+    this.securityTokens = securityTokens;\n+    this.zanataIdentity = zanataIdentity;\n+    this.isOAuthEnabled = isOAuthEnabled;\n+    this.serviceLocator = serviceLocator;\n+    this.allowAnonymousAccessProvider = allowAnonymousAccessProvider;\n+  }\n \n-    @Override\n-    public void filter(ContainerRequestContext context)\n-            throws IOException {\n-        if (hasAuthenticatedAccount()) {\n-            // request come from the same browser and the user has logged in\n-            return;\n-        }\n+  @Override\n+  public void filter(ContainerRequestContext context)\n+    throws IOException {\n+    if (hasAuthenticatedAccount()) {\n+      // request come from the same browser and the user has logged in\n+      return;\n+    }\n \n-        RestCredentials restCredentials = new RestCredentials(context, request, isOAuthEnabled);\n+    RestCredentials restCredentials = new RestCredentials(context, request, isOAuthEnabled);\n \n-        if (restCredentials.hasApiKey()) {\n-            // if apiKey presents, we use apiKey for security check\n-            zanataIdentity.getCredentials().setUsername(restCredentials.username.get());\n-            zanataIdentity.setApiKey(restCredentials.apiKey.get());\n-            zanataIdentity.tryLogin();\n-            if (!SecurityFunctions.canAccessRestPath(zanataIdentity,\n-                    context.getUriInfo().getPath())) {\n-                String message = InvalidApiKeyUtil\n-                        .getMessage(restCredentials.username.get(),\n-                                restCredentials.apiKey.get());\n-                log.info(\"can not authenticate REST request: {}\", message);\n-                context.abortWith(Response.status(Status.UNAUTHORIZED)\n-                        .entity(message)\n-                        .build());\n-            }\n-        } else if (restCredentials.hasOAuthToken()) {\n-            getAuthenticatedUsernameOrError().bipeek(context::abortWith, username -> {\n-                zanataIdentity.getCredentials().setUsername(username);\n-                zanataIdentity.setRequestUsingOAuth(true);\n-                // login will always success since the check was done above\n-                // here the tryLogin() will just set up the correct system state\n-                zanataIdentity.tryLogin();\n-            });\n-        } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n-            // special cases for path such as '/test/' or '/oauth/' are now\n-            // handled by having annotation @NoSecurityCheck on those API\n-            // methods/classes. ZanataRestSecurityBinder will ensure that this\n-            // ContainerRequestFilter will not be called for those annotated\n-            // services.\n+    if (restCredentials.hasApiKey()) {\n+      // if apiKey presents, we use apiKey for security check\n+      zanataIdentity.getCredentials().setUsername(restCredentials.username.get());\n+      zanataIdentity.setApiKey(restCredentials.apiKey.get());\n+      zanataIdentity.tryLogin();\n+      if (!SecurityFunctions.canAccessRestPath(zanataIdentity,\n+        context.getUriInfo().getPath())) {\n+        String message = InvalidApiKeyUtil\n+          .getMessage(restCredentials.username.get(),\n+            restCredentials.apiKey.get());\n+        log.info(\"can not authenticate REST request: {}\", message);\n+        context.abortWith(Response.status(Status.UNAUTHORIZED)\n+          .entity(message)\n+          .build());\n+      }\n+    } else if (restCredentials.hasOAuthToken()) {\n+      getAuthenticatedUsernameOrError().bipeek(context::abortWith, username -> {\n+        zanataIdentity.getCredentials().setUsername(username);\n+        zanataIdentity.setRequestUsingOAuth(true);\n+        // login will always success since the check was done above\n+        // here the tryLogin() will just set up the correct system state\n+        zanataIdentity.tryLogin();\n+      });\n+    } else if (!allowAnonymousAccessProvider.get() ||\n+      !HttpUtil.isReadMethod(context.getMethod())) {\n+      // special cases for path such as '/test/' or '/oauth/' are now\n+      // handled by having annotation @NoSecurityCheck on those API\n+      // methods/classes. ZanataRestSecurityBinder will ensure that this\n+      // ContainerRequestFilter will not be called for those annotated\n+      // services.\n \n-            // if we don't have any information to authenticate and the\n-            // requesting API does NOT allow anonymous access\n-            log.info(\"can not authenticate REST request: {}\", restCredentials);\n-            context.abortWith(Response.status(Status.UNAUTHORIZED)\n-                    .header(\"Content-Type\", MediaType.TEXT_PLAIN)\n-                    .entity(\"User authentication required for REST request\")\n-                    .build());\n-        }\n+      // if we don't have any information to authenticate and the\n+      // requesting API does NOT allow anonymous access\n+      log.info(\"can not authenticate REST request: {}\", restCredentials);\n+      context.abortWith(Response.status(Status.UNAUTHORIZED)\n+        .header(\"Content-Type\", MediaType.TEXT_PLAIN)\n+        .entity(\"User authentication required for REST request\")\n+        .build());\n     }\n+  }\n \n-    private Either<Response, String> getAuthenticatedUsernameOrError() {\n+  private Either<Response, String> getAuthenticatedUsernameOrError() {\n \n-        Optional<String> usernameOpt;\n-        Optional<String> accessTokenOpt =\n-                OAuthUtil.getAccessTokenFromHeader(request);\n-        usernameOpt = accessTokenOpt.flatMap(\n-                token -> securityTokens.findUsernameByAccessToken(token));\n+    Optional<String> usernameOpt;\n+    Optional<String> accessTokenOpt =\n+      OAuthUtil.getAccessTokenFromHeader(request);\n+    usernameOpt = accessTokenOpt.flatMap(\n+      token -> securityTokens.findUsernameByAccessToken(token));\n \n-        if (!usernameOpt.isPresent()) {\n-            log.info(\n-                    \"Bad OAuth request, invalid or expired tokens: access token: {}\",\n-                    accessTokenOpt);\n-            return Either.left(buildUnauthorizedResponse(\n-                    \"Bad OAuth request, invalid or expired tokens: access token [\" +\n-                            accessTokenOpt + \"]\"));\n-        }\n-        String username = usernameOpt.get();\n-        return Either.right(username);\n+    if (!usernameOpt.isPresent()) {\n+      log.info(\n+        \"Bad OAuth request, invalid or expired tokens: access token: {}\",\n+        accessTokenOpt);\n+      return Either.left(buildUnauthorizedResponse(\n+        \"Bad OAuth request, invalid or expired tokens: access token [\" +\n+          accessTokenOpt + \"]\"));\n     }\n+    String username = usernameOpt.get();\n+    return Either.right(username);\n+  }\n \n-    private Response buildUnauthorizedResponse(String message) {\n-        OAuthResponse oauthResponse = null;\n-        try {\n-            oauthResponse = OAuthRSResponse\n-                    .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)\n-                    .buildHeaderMessage();\n-        } catch (OAuthSystemException e1) {\n-            return buildServerErrorResponse(message);\n-        }\n-\n-        return Response\n-                .status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE, oauthResponse.getHeader(\n-                        OAuth.HeaderType.WWW_AUTHENTICATE)).build();\n+  private Response buildUnauthorizedResponse(String message) {\n+    OAuthResponse oauthResponse = null;\n+    try {\n+      oauthResponse = OAuthRSResponse\n+        .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)\n+        .buildHeaderMessage();\n+    } catch (OAuthSystemException e1) {\n+      return buildServerErrorResponse(message);\n     }\n \n-    private Response buildServerErrorResponse(String message) {\n-        return Response.serverError().entity(message).build();\n-    }\n+    return Response\n+      .status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE, oauthResponse.getHeader(\n+        OAuth.HeaderType.WWW_AUTHENTICATE)).build();\n+  }\n \n-    private boolean hasAuthenticatedAccount() {\n-        return serviceLocator\n-                .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n-                null;\n-    }\n+  private Response buildServerErrorResponse(String message) {\n+    return Response.serverError().entity(message).build();\n+  }\n \n-    /**\n-     * Encapsulate all possible authentication values from a REST request.\n-     */\n-    private static class RestCredentials {\n+  private boolean hasAuthenticatedAccount() {\n+    return serviceLocator\n+      .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n+      null;\n+  }\n \n-        private final Optional<String> username;\n-        private final Optional<String> apiKey;\n-        private final Optional<String> accessToken;\n+  /**\n+   * Encapsulate all possible authentication values from a REST request.\n+   */\n+  private static class RestCredentials {\n \n-        RestCredentials(ContainerRequestContext context, HttpServletRequest request,\n-                boolean isOAuthSupported) {\n-            String username = HttpUtil.getUsername(context.getHeaders());\n-            String apiKey = HttpUtil.getApiKey(context.getHeaders());\n-            this.username = optionalNotEmptyString(username);\n-            this.apiKey = optionalNotEmptyString(apiKey);\n-            if (isOAuthSupported) {\n-                accessToken = OAuthUtil.getAccessTokenFromHeader(request);\n-            } else {\n-                accessToken = Optional.empty();\n-            }\n-        }\n+    private final Optional<String> username;\n+    private final Optional<String> apiKey;\n+    private final Optional<String> accessToken;\n \n-        private static Optional<String> optionalNotEmptyString(String value) {\n-            return value == null || value.isEmpty() ?\n-                    Optional.empty() :\n-                    Optional.of(value);\n-        }\n+    RestCredentials(ContainerRequestContext context, HttpServletRequest request,\n+                    boolean isOAuthSupported) {\n+      String username = HttpUtil.getUsername(context.getHeaders());\n+      String apiKey = HttpUtil.getApiKey(context.getHeaders());\n+      this.username = optionalNotEmptyString(username);\n+      this.apiKey = optionalNotEmptyString(apiKey);\n+      if (isOAuthSupported) {\n+        accessToken = OAuthUtil.getAccessTokenFromHeader(request);\n+      } else {\n+        accessToken = Optional.empty();\n+      }\n+    }\n+\n+    private static Optional<String> optionalNotEmptyString(String value) {\n+      return value == null || value.isEmpty() ?\n+        Optional.empty() :\n+        Optional.of(value);\n+    }\n \n-        boolean hasApiKey() {\n-            return username.isPresent() && apiKey.isPresent();\n-        }\n+    boolean hasApiKey() {\n+      return username.isPresent() && apiKey.isPresent();\n+    }\n \n-        boolean hasOAuthToken() {\n-            return accessToken.isPresent();\n-        }\n+    boolean hasOAuthToken() {\n+      return accessToken.isPresent();\n+    }\n \n-        @Override\n-        public String toString() {\n-            return MoreObjects.toStringHelper(this)\n-                    .add(\"username\", username)\n-                    .add(\"apiKey\", apiKey)\n-                    .add(\"accessToken\", accessToken)\n-                    .toString();\n-        }\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+        .add(\"username\", username)\n+        .add(\"apiKey\", apiKey)\n+        .add(\"accessToken\", accessToken)\n+        .toString();\n     }\n+  }\n \n-    /**\n-     * This will use the {@code NoSecurityCheck} annotation and only apply\n-     * security request filter to endpoints that don't have that annotation.\n-     *\n-     * @author Patrick Huang <a href=\"mailto:pahuang@redhat.com\">pahuang@redhat.com</a>\n-     */\n-    @javax.ws.rs.ext.Provider\n-    @PreMatching\n-    public static class ZanataRestSecurityBinder implements DynamicFeature {\n-        @Inject\n-        private ZanataRestSecurityInterceptor securityInterceptor;\n+  /**\n+   * This will use the {@code NoSecurityCheck} annotation and only apply\n+   * security request filter to endpoints that don't have that annotation.\n+   *\n+   * @author Patrick Huang <a href=\"mailto:pahuang@redhat.com\">pahuang@redhat.com</a>\n+   */\n+  @javax.ws.rs.ext.Provider\n+  @PreMatching\n+  public static class ZanataRestSecurityBinder implements DynamicFeature {\n+    @Inject\n+    private ZanataRestSecurityInterceptor securityInterceptor;\n \n-        @Override\n-        public void configure(ResourceInfo resourceInfo,\n-                FeatureContext featureContext) {\n-            Class<?> clazz = resourceInfo.getResourceClass();\n-            Method method = resourceInfo.getResourceMethod();\n-            if (!method.isAnnotationPresent(NoSecurityCheck.class)\n-                    && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n-                featureContext.register(securityInterceptor);\n-            }\n-        }\n+    @Override\n+    public void configure(ResourceInfo resourceInfo,\n+                          FeatureContext featureContext) {\n+      Class<?> clazz = resourceInfo.getResourceClass();\n+      Method method = resourceInfo.getResourceMethod();\n+      if (!method.isAnnotationPresent(NoSecurityCheck.class)\n+        && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n+        featureContext.register(securityInterceptor);\n+      }\n     }\n+  }\n }\n",
            "diff_size": 186
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/49/ZanataRestSecurityInterceptor.java\nindex f1b1c62cb0a..c8b4db30f13 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/49/ZanataRestSecurityInterceptor.java\n@@ -124,7 +124,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n                 zanataIdentity.tryLogin();\n             });\n         } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+                !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n@@ -182,8 +182,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n     private boolean hasAuthenticatedAccount() {\n         return serviceLocator\n-                .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n-                null;\n+                .getInstance(HAccount.class, new AuthenticatedLiteral()) != null;\n     }\n \n     /**\n@@ -255,4 +254,4 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 4
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/49/ZanataRestSecurityInterceptor.java\nindex f1b1c62cb0a..e1629190667 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/49/ZanataRestSecurityInterceptor.java\n@@ -17,7 +17,6 @@ import javax.ws.rs.core.FeatureContext;\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n import javax.ws.rs.core.Response.Status;\n-\n import org.apache.deltaspike.core.api.common.DeltaSpike;\n import org.apache.oltu.oauth2.common.OAuth;\n import org.apache.oltu.oauth2.common.exception.OAuthSystemException;\n@@ -58,30 +57,28 @@ import cyclops.control.Either;\n  * @see org.zanata.security.annotations.CheckLoggedIn\n  */\n // TODO rename this class to Filter since it's no longer a seam JAX-RS interceptor\n+\n+\n @ApplicationScoped\n public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n-    private static final Logger log =\n-            LoggerFactory.getLogger(ZanataRestSecurityInterceptor.class);\n+    private static final Logger log = LoggerFactory.getLogger(ZanataRestSecurityInterceptor.class);\n     private HttpServletRequest request;\n-\n     private SecurityTokens securityTokens;\n-\n     private ZanataIdentity zanataIdentity;\n-\n     private boolean isOAuthEnabled;\n     private IServiceLocator serviceLocator = ServiceLocator.instance();\n-\n     private Provider<Boolean> allowAnonymousAccessProvider;\n \n-\n     public ZanataRestSecurityInterceptor() {\n     }\n \n     @Inject\n     protected ZanataRestSecurityInterceptor(@DeltaSpike HttpServletRequest request,\n-            SecurityTokens securityTokens, ZanataIdentity zanataIdentity,\n-            @SupportOAuth boolean isOAuthEnabled, IServiceLocator serviceLocator,\n-            @AllowAnonymousAccess Provider<Boolean> allowAnonymousAccessProvider) {\n+SecurityTokens securityTokens,\n+ZanataIdentity zanataIdentity,\n+   @SupportOAuth boolean isOAuthEnabled,\n+IServiceLocator serviceLocator,\n+@AllowAnonymousAccess Provider<Boolean> allowAnonymousAccessProvider) {\n         this.request = request;\n         this.securityTokens = securityTokens;\n         this.zanataIdentity = zanataIdentity;\n@@ -91,29 +88,21 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n     }\n \n     @Override\n-    public void filter(ContainerRequestContext context)\n-            throws IOException {\n+    public void filter(ContainerRequestContext context) throws IOException {\n         if (hasAuthenticatedAccount()) {\n             // request come from the same browser and the user has logged in\n             return;\n         }\n-\n         RestCredentials restCredentials = new RestCredentials(context, request, isOAuthEnabled);\n-\n         if (restCredentials.hasApiKey()) {\n             // if apiKey presents, we use apiKey for security check\n             zanataIdentity.getCredentials().setUsername(restCredentials.username.get());\n             zanataIdentity.setApiKey(restCredentials.apiKey.get());\n             zanataIdentity.tryLogin();\n-            if (!SecurityFunctions.canAccessRestPath(zanataIdentity,\n-                    context.getUriInfo().getPath())) {\n-                String message = InvalidApiKeyUtil\n-                        .getMessage(restCredentials.username.get(),\n-                                restCredentials.apiKey.get());\n+            if (!SecurityFunctions.canAccessRestPath(zanataIdentity, context.getUriInfo().getPath())) {\n+                String message = InvalidApiKeyUtil.getMessage(restCredentials.username.get(), restCredentials.apiKey.get());\n                 log.info(\"can not authenticate REST request: {}\", message);\n-                context.abortWith(Response.status(Status.UNAUTHORIZED)\n-                        .entity(message)\n-                        .build());\n+                context.abortWith(Response.status(Status.UNAUTHORIZED).entity(message).build());\n             }\n         } else if (restCredentials.hasOAuthToken()) {\n             getAuthenticatedUsernameOrError().bipeek(context::abortWith, username -> {\n@@ -123,8 +112,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n                 // here the tryLogin() will just set up the correct system state\n                 zanataIdentity.tryLogin();\n             });\n-        } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+        } else if (!allowAnonymousAccessProvider.get() || !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n@@ -133,29 +121,18 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n             // if we don't have any information to authenticate and the\n             // requesting API does NOT allow anonymous access\n-            log.info(\"can not authenticate REST request: {}\", restCredentials);\n-            context.abortWith(Response.status(Status.UNAUTHORIZED)\n-                    .header(\"Content-Type\", MediaType.TEXT_PLAIN)\n-                    .entity(\"User authentication required for REST request\")\n-                    .build());\n-        }\n+                   log.info(\"can not authenticate REST request: {}\", restCredentials);\n+                   context.abortWith(Response.status(Status.UNAUTHORIZED).header(\"Content-Type\", MediaType.TEXT_PLAIN).entity(\"User authentication required for REST request\").build());\n+               }\n     }\n \n     private Either<Response, String> getAuthenticatedUsernameOrError() {\n-\n         Optional<String> usernameOpt;\n-        Optional<String> accessTokenOpt =\n-                OAuthUtil.getAccessTokenFromHeader(request);\n-        usernameOpt = accessTokenOpt.flatMap(\n-                token -> securityTokens.findUsernameByAccessToken(token));\n-\n+        Optional<String> accessTokenOpt = OAuthUtil.getAccessTokenFromHeader(request);\n+        usernameOpt = accessTokenOpt.flatMap(token -> securityTokens.findUsernameByAccessToken(token));\n         if (!usernameOpt.isPresent()) {\n-            log.info(\n-                    \"Bad OAuth request, invalid or expired tokens: access token: {}\",\n-                    accessTokenOpt);\n-            return Either.left(buildUnauthorizedResponse(\n-                    \"Bad OAuth request, invalid or expired tokens: access token [\" +\n-                            accessTokenOpt + \"]\"));\n+            log.info(\"Bad OAuth request, invalid or expired tokens: access token: {}\", accessTokenOpt);\n+            return Either.left(buildUnauthorizedResponse(\"Bad OAuth request, invalid or expired tokens: access token [\" + accessTokenOpt + \"]\"));\n         }\n         String username = usernameOpt.get();\n         return Either.right(username);\n@@ -164,16 +141,11 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n     private Response buildUnauthorizedResponse(String message) {\n         OAuthResponse oauthResponse = null;\n         try {\n-            oauthResponse = OAuthRSResponse\n-                    .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)\n-                    .buildHeaderMessage();\n+            oauthResponse = OAuthRSResponse.errorResponse(HttpServletResponse.SC_UNAUTHORIZED).buildHeaderMessage();\n         } catch (OAuthSystemException e1) {\n             return buildServerErrorResponse(message);\n         }\n-\n-        return Response\n-                .status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE, oauthResponse.getHeader(\n-                        OAuth.HeaderType.WWW_AUTHENTICATE)).build();\n+        return Response.status(oauthResponse.getResponseStatus()).header(OAuth.HeaderType.WWW_AUTHENTICATE, oauthResponse.getHeader(OAuth.HeaderType.WWW_AUTHENTICATE)).build();\n     }\n \n     private Response buildServerErrorResponse(String message) {\n@@ -181,22 +153,19 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n     }\n \n     private boolean hasAuthenticatedAccount() {\n-        return serviceLocator\n-                .getInstance(HAccount.class, new AuthenticatedLiteral()) !=\n-                null;\n+        return serviceLocator.getInstance(HAccount.class, new AuthenticatedLiteral()) != null;\n     }\n \n     /**\n      * Encapsulate all possible authentication values from a REST request.\n      */\n-    private static class RestCredentials {\n \n+    private static class RestCredentials {\n         private final Optional<String> username;\n         private final Optional<String> apiKey;\n         private final Optional<String> accessToken;\n \n-        RestCredentials(ContainerRequestContext context, HttpServletRequest request,\n-                boolean isOAuthSupported) {\n+        RestCredentials(ContainerRequestContext context, HttpServletRequest request, boolean isOAuthSupported) {\n             String username = HttpUtil.getUsername(context.getHeaders());\n             String apiKey = HttpUtil.getApiKey(context.getHeaders());\n             this.username = optionalNotEmptyString(username);\n@@ -209,9 +178,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n         }\n \n         private static Optional<String> optionalNotEmptyString(String value) {\n-            return value == null || value.isEmpty() ?\n-                    Optional.empty() :\n-                    Optional.of(value);\n+            return value == null || value.isEmpty() ? Optional.empty() : Optional.of(value);\n         }\n \n         boolean hasApiKey() {\n@@ -224,11 +191,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n \n         @Override\n         public String toString() {\n-            return MoreObjects.toStringHelper(this)\n-                    .add(\"username\", username)\n-                    .add(\"apiKey\", apiKey)\n-                    .add(\"accessToken\", accessToken)\n-                    .toString();\n+            return MoreObjects.toStringHelper(this).add(\"username\", username).add(\"apiKey\", apiKey).add(\"accessToken\", accessToken).toString();\n         }\n     }\n \n@@ -238,21 +201,19 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n      *\n      * @author Patrick Huang <a href=\"mailto:pahuang@redhat.com\">pahuang@redhat.com</a>\n      */\n+\n     @javax.ws.rs.ext.Provider\n     @PreMatching\n     public static class ZanataRestSecurityBinder implements DynamicFeature {\n         @Inject\n         private ZanataRestSecurityInterceptor securityInterceptor;\n-\n         @Override\n-        public void configure(ResourceInfo resourceInfo,\n-                FeatureContext featureContext) {\n+        public void configure(ResourceInfo resourceInfo, FeatureContext featureContext) {\n             Class<?> clazz = resourceInfo.getResourceClass();\n             Method method = resourceInfo.getResourceMethod();\n-            if (!method.isAnnotationPresent(NoSecurityCheck.class)\n-                    && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n+            if (!method.isAnnotationPresent(NoSecurityCheck.class) && !clazz.isAnnotationPresent(NoSecurityCheck.class)) {\n                 featureContext.register(securityInterceptor);\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 76
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/49/ZanataRestSecurityInterceptor.java\nindex f1b1c62cb0a..c0a3f838408 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_random/49/ZanataRestSecurityInterceptor.java\n@@ -124,7 +124,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n                 zanataIdentity.tryLogin();\n             });\n         } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+                !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/49/ZanataRestSecurityInterceptor.java\nindex f1b1c62cb0a..c0a3f838408 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/49/ZanataRestSecurityInterceptor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/49/ZanataRestSecurityInterceptor.java\n@@ -124,7 +124,7 @@ public class ZanataRestSecurityInterceptor implements ContainerRequestFilter {\n                 zanataIdentity.tryLogin();\n             });\n         } else if (!allowAnonymousAccessProvider.get() ||\n-                !HttpUtil.isReadMethod(context.getMethod())){\n+                !HttpUtil.isReadMethod(context.getMethod())) {\n             // special cases for path such as '/test/' or '/oauth/' are now\n             // handled by having annotation @NoSecurityCheck on those API\n             // methods/classes. ZanataRestSecurityBinder will ensure that this\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}