{
    "project_name": "codefollower-H2-Research",
    "error_id": "314",
    "information": {
        "errors": [
            {
                "line": "47",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "/*\n         \u6709\u4e09\u79cd\u4ea7\u751fTableView\u7684\u65b9\u5f0f:\n\t1. CREATE VIEW\u8bed\u53e5\n\n\t\u5982: CREATE OR REPLACE FORCE VIEW IF NOT EXISTS my_view COMMENT IS 'my view'(f1,f2) \n\t\t\tAS SELECT id,name FROM CreateViewTest",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "47",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "49",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/314/TableView.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/314/TableView.java\nindex 8a97b2d1351..3c0a70ec6b2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/314/TableView.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/314/TableView.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (https://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.table;\n \n import java.util.ArrayList;\n@@ -39,6 +40,7 @@ import org.h2.value.Value;\n \n /**\n  * A view is a virtual table that is defined by a query.\n+ *\n  * @author Thomas Mueller\n  * @author Nicolas Fortin, Atelier SIG, IRSTV FR CNRS 24888\n  */\n@@ -68,46 +70,46 @@ import org.h2.value.Value;\n  */\n public class TableView extends Table {\n \n-    private static final long ROW_COUNT_APPROXIMATION = 100;\n-\n-    private String querySQL;\n-    private ArrayList<Table> tables;\n-    private Column[] columnTemplates;\n-    private Query viewQuery;\n-    private ViewIndex index;\n-    private boolean allowRecursive;\n-    private DbException createException;\n-    private long lastModificationCheck;\n-    private long maxDataModificationId;\n-    private User owner;\n-    private Query topQuery;\n-    private ResultInterface recursiveResult;\n-    private boolean isRecursiveQueryDetected;\n-    private boolean isTableExpression;\n-\n-    public TableView(Schema schema, int id, String name, String querySQL,\n-            ArrayList<Parameter> params, Column[] columnTemplates, Session session,\n-            boolean allowRecursive, boolean literalsChecked, boolean isTableExpression, boolean isTemporary) {\n-        super(schema, id, name, false, true);\n-        setTemporary(isTemporary);\n-        init(querySQL, params, columnTemplates, session, allowRecursive, literalsChecked, isTableExpression);\n-    }\n-\n-    /**\n-     * Try to replace the SQL statement of the view and re-compile this and all\n-     * dependent views.\n-     *\n-     * @param querySQL the SQL statement\n-     * @param newColumnTemplates the columns\n-     * @param session the session\n-     * @param recursive whether this is a recursive view\n-     * @param force if errors should be ignored\n-     * @param literalsChecked if literals have been checked\n-     */\n-    public void replace(String querySQL,  Column[] newColumnTemplates, Session session,\n-            boolean recursive, boolean force, boolean literalsChecked) {\n-        String oldQuerySQL = this.querySQL;\n-        Column[] oldColumnTemplates = this.columnTemplates;\n+  private static final long ROW_COUNT_APPROXIMATION = 100;\n+\n+  private String querySQL;\n+  private ArrayList<Table> tables;\n+  private Column[] columnTemplates;\n+  private Query viewQuery;\n+  private ViewIndex index;\n+  private boolean allowRecursive;\n+  private DbException createException;\n+  private long lastModificationCheck;\n+  private long maxDataModificationId;\n+  private User owner;\n+  private Query topQuery;\n+  private ResultInterface recursiveResult;\n+  private boolean isRecursiveQueryDetected;\n+  private boolean isTableExpression;\n+\n+  public TableView(Schema schema, int id, String name, String querySQL,\n+                   ArrayList<Parameter> params, Column[] columnTemplates, Session session,\n+                   boolean allowRecursive, boolean literalsChecked, boolean isTableExpression, boolean isTemporary) {\n+    super(schema, id, name, false, true);\n+    setTemporary(isTemporary);\n+    init(querySQL, params, columnTemplates, session, allowRecursive, literalsChecked, isTableExpression);\n+  }\n+\n+  /**\n+   * Try to replace the SQL statement of the view and re-compile this and all\n+   * dependent views.\n+   *\n+   * @param querySQL           the SQL statement\n+   * @param newColumnTemplates the columns\n+   * @param session            the session\n+   * @param recursive          whether this is a recursive view\n+   * @param force              if errors should be ignored\n+   * @param literalsChecked    if literals have been checked\n+   */\n+  public void replace(String querySQL, Column[] newColumnTemplates, Session session,\n+                      boolean recursive, boolean force, boolean literalsChecked) {\n+    String oldQuerySQL = this.querySQL;\n+    Column[] oldColumnTemplates = this.columnTemplates;\n //<<<<<<< HEAD\n //        boolean oldRecursive = this.recursive;\n //        // init\u91cc\u6267\u884c\u4e86\u4e00\u6b21initColumnsAndTables\uff0c\u867d\u7136\u6267\u884c\u4e86\u4e24\u6b21initColumnsAndTables\uff0c\u4f46\u662finit\u4e2d\u8fd8\u5efa\u7acb\u4e86ViewIndex\n@@ -119,66 +121,67 @@ public class TableView extends Table {\n //            // \u5982\u679c\u5931\u8d25\u4e86\uff0c\u6309\u539f\u6765\u7684\u91cd\u65b0\u6765\u8fc7\n //            init(oldQuerySQL, null, oldColumnTemplates, session, oldRecursive);\n //=======\n-        boolean oldRecursive = this.allowRecursive;\n-        init(querySQL, null, newColumnTemplates, session, recursive, literalsChecked, isTableExpression);\n-        DbException e = recompile(session, force, true);\n-        if (e != null) {\n-            init(oldQuerySQL, null, oldColumnTemplates, session, oldRecursive,\n-                    literalsChecked, isTableExpression);\n-            recompile(session, true, false);\n-            throw e;\n-        }\n+    boolean oldRecursive = this.allowRecursive;\n+    init(querySQL, null, newColumnTemplates, session, recursive, literalsChecked, isTableExpression);\n+    DbException e = recompile(session, force, true);\n+    if (e != null) {\n+      init(oldQuerySQL, null, oldColumnTemplates, session, oldRecursive,\n+          literalsChecked, isTableExpression);\n+      recompile(session, true, false);\n+      throw e;\n+    }\n+  }\n+\n+  private synchronized void init(String querySQL, ArrayList<Parameter> params,\n+                                 Column[] columnTemplates, Session session, boolean allowRecursive,\n+                                 boolean literalsChecked,\n+                                 boolean isTableExpression) {\n+    this.querySQL = querySQL;\n+    this.columnTemplates = columnTemplates;\n+    this.allowRecursive = allowRecursive;\n+    this.isRecursiveQueryDetected = false;\n+    this.isTableExpression = isTableExpression;\n+    index = new ViewIndex(this, querySQL, params, allowRecursive);\n+    initColumnsAndTables(session, literalsChecked);\n+  }\n+\n+  private Query compileViewQuery(Session session, String sql, boolean literalsChecked, String viewName) {\n+    Prepared p;\n+    session.setParsingCreateView(true, viewName);\n+    try {\n+      p = session.prepare(sql, false, literalsChecked);\n+    } finally {\n+      session.setParsingCreateView(false, viewName);\n+    }\n+    if (!(p instanceof Query)) {\n+      throw DbException.getSyntaxError(sql, 0);\n+    }\n+    Query q = (Query) p;\n+    // only potentially recursive cte queries need to be non-lazy\n+    if (isTableExpression && allowRecursive) {\n+      q.setNeverLazy(true);\n+    }\n+    return q;\n+  }\n+\n+  /**\n+   * Re-compile the view query and all views that depend on this object.\n+   *\n+   * @param session         the session\n+   * @param force           if exceptions should be ignored\n+   * @param clearIndexCache if we need to clear view index cache\n+   * @return the exception if re-compiling this or any dependent view failed\n+   * (only when force is disabled)\n+   */\n+  public synchronized DbException recompile(Session session, boolean force,\n+                                            boolean clearIndexCache) {\n+    try {\n+      compileViewQuery(session, querySQL, false, getName());\n+    } catch (DbException e) {\n+      if (!force) {\n+        return e;\n+      }\n     }\n-\n-    private synchronized void init(String querySQL, ArrayList<Parameter> params,\n-            Column[] columnTemplates, Session session, boolean allowRecursive, boolean literalsChecked,\n-            boolean isTableExpression) {\n-        this.querySQL = querySQL;\n-        this.columnTemplates = columnTemplates;\n-        this.allowRecursive = allowRecursive;\n-        this.isRecursiveQueryDetected = false;\n-        this.isTableExpression = isTableExpression;\n-        index = new ViewIndex(this, querySQL, params, allowRecursive);\n-        initColumnsAndTables(session, literalsChecked);\n-    }\n-\n-    private Query compileViewQuery(Session session, String sql, boolean literalsChecked, String viewName) {\n-        Prepared p;\n-        session.setParsingCreateView(true, viewName);\n-        try {\n-            p = session.prepare(sql, false, literalsChecked);\n-        } finally {\n-            session.setParsingCreateView(false, viewName);\n-        }\n-        if (!(p instanceof Query)) {\n-            throw DbException.getSyntaxError(sql, 0);\n-        }\n-        Query q = (Query) p;\n-        // only potentially recursive cte queries need to be non-lazy\n-        if (isTableExpression && allowRecursive) {\n-            q.setNeverLazy(true);\n-        }\n-        return q;\n-    }\n-\n-    /**\n-     * Re-compile the view query and all views that depend on this object.\n-     *\n-     * @param session the session\n-     * @param force if exceptions should be ignored\n-     * @param clearIndexCache if we need to clear view index cache\n-     * @return the exception if re-compiling this or any dependent view failed\n-     *         (only when force is disabled)\n-     */\n-    public synchronized DbException recompile(Session session, boolean force,\n-            boolean clearIndexCache) {\n-        try {\n-            compileViewQuery(session, querySQL, false, getName());\n-        } catch (DbException e) {\n-            if (!force) {\n-                return e;\n-            }\n-        }\n //<<<<<<< HEAD\n //        \n //        //\u5982\u4e0b:\n@@ -199,25 +202,25 @@ public class TableView extends Table {\n //                    return e;\n //                }\n //=======\n-        ArrayList<TableView> dependentViews = new ArrayList<>(getDependentViews());\n-        initColumnsAndTables(session, false);\n-        for (TableView v : dependentViews) {\n-            DbException e = v.recompile(session, force, false);\n-            if (e != null && !force) {\n-                return e;\n-            }\n-        }\n-        if (clearIndexCache) {\n-            clearIndexCaches(database);\n-        }\n-        return force ? null : createException;\n-    }\n-\n-    private void initColumnsAndTables(Session session, boolean literalsChecked) {\n-        Column[] cols;\n-        removeCurrentViewFromOtherTables();\n-        setTableExpression(isTableExpression);\n-        try {\n+    ArrayList<TableView> dependentViews = new ArrayList<>(getDependentViews());\n+    initColumnsAndTables(session, false);\n+    for (TableView v : dependentViews) {\n+      DbException e = v.recompile(session, force, false);\n+      if (e != null && !force) {\n+        return e;\n+      }\n+    }\n+    if (clearIndexCache) {\n+      clearIndexCaches(database);\n+    }\n+    return force ? null : createException;\n+  }\n+\n+  private void initColumnsAndTables(Session session, boolean literalsChecked) {\n+    Column[] cols;\n+    removeCurrentViewFromOtherTables();\n+    setTableExpression(isTableExpression);\n+    try {\n //<<<<<<< HEAD\n //            Query query = compileViewQuery(session, querySQL); //\u91cd\u65b0\u5bf9select\u8bed\u53e5\u8fdb\u884c\u89e3\u6790\u548cprepare\n //            this.querySQL = query.getPlanSQL();\n@@ -242,682 +245,685 @@ public class TableView extends Table {\n //            //expressions.size\u6709\u53ef\u80fd\u5927\u4e8equery.getColumnCount()\uff0c\u56e0\u4e3aquery.getColumnCount()\u4e0d\u5305\u542bgroup by\u7b49\u989d\u5916\u52a0\u8fdb\u6765\u7684\u8868\u8fbe\u5f0f\n //            for (int i = 0, count = query.getColumnCount(); i < count; i++) {\n //=======\n-            Query compiledQuery = compileViewQuery(session, querySQL, literalsChecked, getName());\n-            this.querySQL = compiledQuery.getPlanSQL(true);\n-            tables = new ArrayList<>(compiledQuery.getTables());\n-            ArrayList<Expression> expressions = compiledQuery.getExpressions();\n-            ColumnNamer columnNamer = new ColumnNamer(session);\n-            final int count = compiledQuery.getColumnCount();\n-            ArrayList<Column> list = new ArrayList<>(count);\n-            for (int i = 0; i < count; i++) {\n-                Expression expr = expressions.get(i);\n-                String name = null;\n-                //\u5982CREATE OR REPLACE FORCE VIEW IF NOT EXISTS my_view AS SELECT id,name FROM CreateViewTest\n-                //\u6ca1\u6709\u4e3a\u89c6\u56fe\u6307\u5b9a\u5b57\u6bb5\u7684\u65f6\u5019\uff0c\u7528select\u5b57\u6bb5\u5217\u8868\u4e2d\u7684\u540d\u5b57\uff0c\u6b64\u65f6columnTemplates==null\n-                TypeInfo type = TypeInfo.TYPE_UNKNOWN;\n-                if (columnTemplates != null && columnTemplates.length > i) {\n-                    name = columnTemplates[i].getName();\n-                    type = columnTemplates[i].getType();\n-                }\n-                if (name == null) {\n-                    name = expr.getAlias();\n-                }\n-                name = columnNamer.getColumnName(expr, i, name);\n-                if (type.getValueType() == Value.UNKNOWN) {\n-                    type = expr.getType();\n-                }\n-                Column col = new Column(name, type);\n-                col.setTable(this, i);\n-                list.add(col);\n-            }\n-            cols = list.toArray(new Column[0]);\n-            createException = null;\n-            viewQuery = compiledQuery;\n-        } catch (DbException e) {\n-            e.addSQL(getCreateSQL());\n-            createException = e;\n-            // If it can't be compiled, then it's a 'zero column table'\n-            // this avoids problems when creating the view when opening the\n-            // database.\n-            // If it can not be compiled - it could also be a recursive common\n-            // table expression query.\n-            if (isRecursiveQueryExceptionDetected(createException)) {\n-                this.isRecursiveQueryDetected = true;\n-            }\n-            tables = Utils.newSmallArrayList();\n-            cols = new Column[0];\n-            if (allowRecursive && columnTemplates != null) {\n-                cols = new Column[columnTemplates.length];\n-                for (int i = 0; i < columnTemplates.length; i++) {\n-                    cols[i] = columnTemplates[i].getClone();\n-                }\n-                index.setRecursive(true);\n-                createException = null;\n-            }\n-        }\n-        setColumns(cols);\n-        if (getId() != 0) {\n-            addDependentViewToTables();\n-        }\n-    }\n-\n-    @Override\n-    public boolean isView() {\n-        return true;\n-    }\n-\n-    /**\n-     * Check if this view is currently invalid.\n-     *\n-     * @return true if it is\n-     */\n-    public boolean isInvalid() {\n-        return createException != null;\n+      Query compiledQuery = compileViewQuery(session, querySQL, literalsChecked, getName());\n+      this.querySQL = compiledQuery.getPlanSQL(true);\n+      tables = new ArrayList<>(compiledQuery.getTables());\n+      ArrayList<Expression> expressions = compiledQuery.getExpressions();\n+      ColumnNamer columnNamer = new ColumnNamer(session);\n+      final int count = compiledQuery.getColumnCount();\n+      ArrayList<Column> list = new ArrayList<>(count);\n+      for (int i = 0; i < count; i++) {\n+        Expression expr = expressions.get(i);\n+        String name = null;\n+        //\u5982CREATE OR REPLACE FORCE VIEW IF NOT EXISTS my_view AS SELECT id,name FROM CreateViewTest\n+        //\u6ca1\u6709\u4e3a\u89c6\u56fe\u6307\u5b9a\u5b57\u6bb5\u7684\u65f6\u5019\uff0c\u7528select\u5b57\u6bb5\u5217\u8868\u4e2d\u7684\u540d\u5b57\uff0c\u6b64\u65f6columnTemplates==null\n+        TypeInfo type = TypeInfo.TYPE_UNKNOWN;\n+        if (columnTemplates != null && columnTemplates.length > i) {\n+          name = columnTemplates[i].getName();\n+          type = columnTemplates[i].getType();\n+        }\n+        if (name == null) {\n+          name = expr.getAlias();\n+        }\n+        name = columnNamer.getColumnName(expr, i, name);\n+        if (type.getValueType() == Value.UNKNOWN) {\n+          type = expr.getType();\n+        }\n+        Column col = new Column(name, type);\n+        col.setTable(this, i);\n+        list.add(col);\n+      }\n+      cols = list.toArray(new Column[0]);\n+      createException = null;\n+      viewQuery = compiledQuery;\n+    } catch (DbException e) {\n+      e.addSQL(getCreateSQL());\n+      createException = e;\n+      // If it can't be compiled, then it's a 'zero column table'\n+      // this avoids problems when creating the view when opening the\n+      // database.\n+      // If it can not be compiled - it could also be a recursive common\n+      // table expression query.\n+      if (isRecursiveQueryExceptionDetected(createException)) {\n+        this.isRecursiveQueryDetected = true;\n+      }\n+      tables = Utils.newSmallArrayList();\n+      cols = new Column[0];\n+      if (allowRecursive && columnTemplates != null) {\n+        cols = new Column[columnTemplates.length];\n+        for (int i = 0; i < columnTemplates.length; i++) {\n+          cols[i] = columnTemplates[i].getClone();\n+        }\n+        index.setRecursive(true);\n+        createException = null;\n+      }\n+    }\n+    setColumns(cols);\n+    if (getId() != 0) {\n+      addDependentViewToTables();\n+    }\n+  }\n+\n+  @Override\n+  public boolean isView() {\n+    return true;\n+  }\n+\n+  /**\n+   * Check if this view is currently invalid.\n+   *\n+   * @return true if it is\n+   */\n+  public boolean isInvalid() {\n+    return createException != null;\n+  }\n+\n+  @Override\n+  public PlanItem getBestPlanItem(Session session, int[] masks,\n+                                  TableFilter[] filters, int filter, SortOrder sortOrder,\n+                                  AllColumnsForPlan allColumnsSet) {\n+    final CacheKey cacheKey = new CacheKey(masks, this);\n+    Map<Object, ViewIndex> indexCache = session.getViewIndexCache(topQuery != null);\n+    ViewIndex i = indexCache.get(cacheKey);\n+    if (i == null || i.isExpired()) {\n+      i = new ViewIndex(this, index, session, masks, filters, filter, sortOrder);\n+      indexCache.put(cacheKey, i);\n+    }\n+    PlanItem item = new PlanItem();\n+    item.cost = i.getCost(session, masks, filters, filter, sortOrder, allColumnsSet);\n+    item.setIndex(i);\n+    return item;\n+  }\n+\n+  @Override\n+  public boolean isQueryComparable() {\n+    if (!super.isQueryComparable()) {\n+      return false;\n+    }\n+    for (Table t : tables) {\n+      if (!t.isQueryComparable()) {\n+        return false;\n+      }\n+    }\n+    if (topQuery != null &&\n+        !topQuery.isEverything(ExpressionVisitor.QUERY_COMPARABLE_VISITOR)) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  public Query getTopQuery() {\n+    return topQuery;\n+  }\n+\n+  @Override\n+  public String getDropSQL() {\n+    return \"DROP VIEW IF EXISTS \" + getSQL(true) + \" CASCADE\";\n+  }\n+\n+  @Override\n+  public String getCreateSQLForCopy(Table table, String quotedName) {\n+    return getCreateSQL(false, true, quotedName);\n+  }\n+\n+\n+  @Override\n+  public String getCreateSQL() {\n+    return getCreateSQL(false, true);\n+  }\n+\n+  /**\n+   * Generate \"CREATE\" SQL statement for the view.\n+   *\n+   * @param orReplace if true, then include the OR REPLACE clause\n+   * @param force     if true, then include the FORCE clause\n+   * @return the SQL statement\n+   */\n+  public String getCreateSQL(boolean orReplace, boolean force) {\n+    return getCreateSQL(orReplace, force, getSQL(true));\n+  }\n+\n+  private String getCreateSQL(boolean orReplace, boolean force, String quotedName) {\n+    StringBuilder builder = new StringBuilder(\"CREATE \");\n+    if (orReplace) {\n+      builder.append(\"OR REPLACE \");\n+    }\n+    if (force) {\n+      builder.append(\"FORCE \");\n+    }\n+    builder.append(\"VIEW \");\n+    if (isTableExpression) {\n+      builder.append(\"TABLE_EXPRESSION \");\n+    }\n+    builder.append(quotedName);\n+    if (comment != null) {\n+      builder.append(\" COMMENT \");\n+      StringUtils.quoteStringSQL(builder, comment);\n+    }\n+    if (columns != null && columns.length > 0) {\n+      builder.append('(');\n+      Column.writeColumns(builder, columns, true);\n+      builder.append(')');\n+    } else if (columnTemplates != null) {\n+      builder.append('(');\n+      Column.writeColumns(builder, columnTemplates, true);\n+      builder.append(')');\n+    }\n+    return builder.append(\" AS\\n\").append(querySQL).toString();\n+  }\n+\n+  @Override\n+  public boolean lock(Session session, boolean exclusive, boolean forceLockEvenInMvcc) {\n+    // exclusive lock means: the view will be dropped\n+    return false;\n+  }\n+\n+  @Override\n+  public void close(Session session) {\n+    // nothing to do\n+  }\n+\n+  @Override\n+  public void unlock(Session s) {\n+    // nothing to do\n+  }\n+\n+  @Override\n+  public boolean isLockedExclusively() {\n+    return false;\n+  }\n+\n+  @Override\n+  public Index addIndex(Session session, String indexName, int indexId,\n+                        IndexColumn[] cols, IndexType indexType, boolean create,\n+                        String indexComment) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void removeRow(Session session, Row row) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void addRow(Session session, Row row) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void checkSupportAlter() {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public void truncate(Session session) {\n+    throw DbException.getUnsupportedException(\"VIEW\");\n+  }\n+\n+  @Override\n+  public long getRowCount(Session session) {\n+    throw DbException.throwInternalError(toString());\n+  }\n+\n+  @Override\n+  public boolean canGetRowCount() {\n+    // TODO view: could get the row count, but not that easy\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean canDrop() {\n+    return true;\n+  }\n+\n+  @Override\n+  public TableType getTableType() {\n+    return TableType.VIEW;\n+  }\n+\n+  @Override\n+  public void removeChildrenAndResources(Session session) {\n+    removeCurrentViewFromOtherTables();\n+    super.removeChildrenAndResources(session);\n+    database.removeMeta(session, getId());\n+    querySQL = null;\n+    index = null;\n+    clearIndexCaches(database);\n+    invalidate();\n+  }\n+\n+  /**\n+   * Clear the cached indexes for all sessions.\n+   *\n+   * @param database the database\n+   */\n+  public static void clearIndexCaches(Database database) {\n+    for (Session s : database.getSessions(true)) {\n+      s.clearViewIndexCache();\n+    }\n+  }\n+\n+  @Override\n+  public StringBuilder getSQL(StringBuilder builder, boolean alwaysQuote) {\n+    if (isTemporary() && querySQL != null) {\n+      builder.append(\"(\\n\");\n+      return StringUtils.indent(builder, querySQL, 4, true).append(')');\n+    }\n+    return super.getSQL(builder, alwaysQuote);\n+  }\n+\n+  public String getQuery() {\n+    return querySQL;\n+  }\n+\n+  @Override\n+  public Index getScanIndex(Session session) {\n+    return getBestPlanItem(session, null, null, -1, null, null).getIndex();\n+  }\n+\n+  @Override\n+  public Index getScanIndex(Session session, int[] masks,\n+                            TableFilter[] filters, int filter, SortOrder sortOrder,\n+                            AllColumnsForPlan allColumnsSet) {\n+    if (createException != null) {\n+      String msg = createException.getMessage();\n+      throw DbException.get(ErrorCode.VIEW_IS_INVALID_2,\n+          createException, getSQL(false), msg);\n+    }\n+    PlanItem item = getBestPlanItem(session, masks, filters, filter, sortOrder, allColumnsSet);\n+    return item.getIndex();\n+  }\n+\n+  @Override\n+  public boolean canReference() {\n+    return false;\n+  }\n+\n+  @Override\n+  public ArrayList<Index> getIndexes() {\n+    return null;\n+  }\n+\n+  @Override\n+  public long getMaxDataModificationId() {\n+    if (createException != null) {\n+      return Long.MAX_VALUE;\n+    }\n+    if (viewQuery == null) {\n+      return Long.MAX_VALUE;\n+    }\n+    // if nothing was modified in the database since the last check, and the\n+    // last is known, then we don't need to check again\n+    // this speeds up nested views\n+    long dbMod = database.getModificationDataId();\n+    if (dbMod > lastModificationCheck && maxDataModificationId <= dbMod) {\n+      maxDataModificationId = viewQuery.getMaxDataModificationId();\n+      lastModificationCheck = dbMod;\n+    }\n+    return maxDataModificationId;\n+  }\n+\n+  @Override\n+  public Index getUniqueIndex() {\n+    return null;\n+  }\n+\n+  private void removeCurrentViewFromOtherTables() {\n+    if (tables != null) {\n+      for (Table t : tables) {\n+        t.removeDependentView(this);\n+      }\n+      tables.clear();\n+    }\n+  }\n+\n+  private void addDependentViewToTables() {\n+    for (Table t : tables) {\n+      t.addDependentView(this);\n+    }\n+  }\n+\n+  private void setOwner(User owner) {\n+    this.owner = owner;\n+  }\n+\n+  public User getOwner() {\n+    return owner;\n+  }\n+\n+  /**\n+   * Create a temporary view out of the given query.\n+   *\n+   * @param session  the session\n+   * @param owner    the owner of the query\n+   * @param name     the view name\n+   * @param query    the query\n+   * @param topQuery the top level query\n+   * @return the view table\n+   */\n+  public static TableView createTempView(Session session, User owner,\n+                                         String name, Query query, Query topQuery) {\n+    Schema mainSchema = session.getDatabase().getMainSchema();\n+    String querySQL = query.getPlanSQL(true);\n+    TableView v = new TableView(mainSchema, 0, name,\n+        querySQL, query.getParameters(), null /* column templates */, session,\n+        false/* allow recursive */, true /* literals have already been checked when parsing original query */,\n+        false /* is table expression */, true/*temporary*/);\n+    if (v.createException != null) {\n+      throw v.createException;\n+    }\n+    v.setTopQuery(topQuery);\n+    v.setOwner(owner);\n+    v.setTemporary(true);\n+    return v;\n+  }\n+\n+  private void setTopQuery(Query topQuery) {\n+    this.topQuery = topQuery;\n+  }\n+\n+  @Override\n+  public long getRowCountApproximation() {\n+    return ROW_COUNT_APPROXIMATION;\n+  }\n+\n+  @Override\n+  public long getDiskSpaceUsed() {\n+    return 0;\n+  }\n+\n+  /**\n+   * Get the index of the first parameter.\n+   *\n+   * @param additionalParameters additional parameters\n+   * @return the index of the first parameter\n+   */\n+  public int getParameterOffset(ArrayList<Parameter> additionalParameters) {\n+    int result = topQuery == null ? -1 : getMaxParameterIndex(topQuery.getParameters());\n+    if (additionalParameters != null) {\n+      result = Math.max(result, getMaxParameterIndex(additionalParameters));\n+    }\n+    return result + 1;\n+  }\n+\n+  private static int getMaxParameterIndex(ArrayList<Parameter> parameters) {\n+    int result = -1;\n+    for (Parameter p : parameters) {\n+      result = Math.max(result, p.getIndex());\n+    }\n+    return result;\n+  }\n+\n+  public boolean isRecursive() {\n+    return allowRecursive;\n+  }\n+\n+  @Override\n+  public boolean isDeterministic() {\n+    if (allowRecursive || viewQuery == null) {\n+      return false;\n+    }\n+    return viewQuery.isEverything(ExpressionVisitor.DETERMINISTIC_VISITOR);\n+  }\n+\n+  public void setRecursiveResult(ResultInterface value) {\n+    if (recursiveResult != null) {\n+      recursiveResult.close();\n+    }\n+    this.recursiveResult = value;\n+  }\n+\n+  public ResultInterface getRecursiveResult() {\n+    return recursiveResult;\n+  }\n+\n+  @Override\n+  public void addDependencies(HashSet<DbObject> dependencies) {\n+    super.addDependencies(dependencies);\n+    if (tables != null) {\n+      for (Table t : tables) {\n+        if (TableType.VIEW != t.getTableType()) {\n+          t.addDependencies(dependencies);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * The key of the index cache for views.\n+   */\n+  private static final class CacheKey {\n+\n+    private final int[] masks;\n+    private final TableView view;\n+\n+    CacheKey(int[] masks, TableView view) {\n+      this.masks = masks;\n+      this.view = view;\n     }\n \n     @Override\n-    public PlanItem getBestPlanItem(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n-        final CacheKey cacheKey = new CacheKey(masks, this);\n-        Map<Object, ViewIndex> indexCache = session.getViewIndexCache(topQuery != null);\n-        ViewIndex i = indexCache.get(cacheKey);\n-        if (i == null || i.isExpired()) {\n-            i = new ViewIndex(this, index, session, masks, filters, filter, sortOrder);\n-            indexCache.put(cacheKey, i);\n-        }\n-        PlanItem item = new PlanItem();\n-        item.cost = i.getCost(session, masks, filters, filter, sortOrder, allColumnsSet);\n-        item.setIndex(i);\n-        return item;\n+    public int hashCode() {\n+      final int prime = 31;\n+      int result = 1;\n+      result = prime * result + Arrays.hashCode(masks);\n+      result = prime * result + view.hashCode();\n+      return result;\n     }\n \n     @Override\n-    public boolean isQueryComparable() {\n-        if (!super.isQueryComparable()) {\n-            return false;\n-        }\n-        for (Table t : tables) {\n-            if (!t.isQueryComparable()) {\n-                return false;\n-            }\n-        }\n-        if (topQuery != null &&\n-                !topQuery.isEverything(ExpressionVisitor.QUERY_COMPARABLE_VISITOR)) {\n-            return false;\n-        }\n+    public boolean equals(Object obj) {\n+      if (this == obj) {\n         return true;\n-    }\n-\n-    public Query getTopQuery() {\n-        return topQuery;\n-    }\n-\n-    @Override\n-    public String getDropSQL() {\n-        return \"DROP VIEW IF EXISTS \" + getSQL(true) + \" CASCADE\";\n-    }\n-\n-    @Override\n-    public String getCreateSQLForCopy(Table table, String quotedName) {\n-        return getCreateSQL(false, true, quotedName);\n-    }\n-\n-\n-    @Override\n-    public String getCreateSQL() {\n-        return getCreateSQL(false, true);\n-    }\n-\n-    /**\n-     * Generate \"CREATE\" SQL statement for the view.\n-     *\n-     * @param orReplace if true, then include the OR REPLACE clause\n-     * @param force if true, then include the FORCE clause\n-     * @return the SQL statement\n-     */\n-    public String getCreateSQL(boolean orReplace, boolean force) {\n-        return getCreateSQL(orReplace, force, getSQL(true));\n-    }\n-\n-    private String getCreateSQL(boolean orReplace, boolean force, String quotedName) {\n-        StringBuilder builder = new StringBuilder(\"CREATE \");\n-        if (orReplace) {\n-            builder.append(\"OR REPLACE \");\n-        }\n-        if (force) {\n-            builder.append(\"FORCE \");\n-        }\n-        builder.append(\"VIEW \");\n-        if (isTableExpression) {\n-            builder.append(\"TABLE_EXPRESSION \");\n-        }\n-        builder.append(quotedName);\n-        if (comment != null) {\n-            builder.append(\" COMMENT \");\n-            StringUtils.quoteStringSQL(builder, comment);\n-        }\n-        if (columns != null && columns.length > 0) {\n-            builder.append('(');\n-            Column.writeColumns(builder, columns, true);\n-            builder.append(')');\n-        } else if (columnTemplates != null) {\n-            builder.append('(');\n-            Column.writeColumns(builder, columnTemplates, true);\n-            builder.append(')');\n-        }\n-        return builder.append(\" AS\\n\").append(querySQL).toString();\n-    }\n-\n-    @Override\n-    public boolean lock(Session session, boolean exclusive, boolean forceLockEvenInMvcc) {\n-        // exclusive lock means: the view will be dropped\n+      }\n+      if (obj == null) {\n         return false;\n-    }\n-\n-    @Override\n-    public void close(Session session) {\n-        // nothing to do\n-    }\n-\n-    @Override\n-    public void unlock(Session s) {\n-        // nothing to do\n-    }\n-\n-    @Override\n-    public boolean isLockedExclusively() {\n+      }\n+      if (getClass() != obj.getClass()) {\n         return false;\n-    }\n-\n-    @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public void removeRow(Session session, Row row) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public void addRow(Session session, Row row) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public void checkSupportAlter() {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public void truncate(Session session) {\n-        throw DbException.getUnsupportedException(\"VIEW\");\n-    }\n-\n-    @Override\n-    public long getRowCount(Session session) {\n-        throw DbException.throwInternalError(toString());\n-    }\n-\n-    @Override\n-    public boolean canGetRowCount() {\n-        // TODO view: could get the row count, but not that easy\n+      }\n+      CacheKey other = (CacheKey) obj;\n+      if (view != other.view) {\n         return false;\n-    }\n-\n-    @Override\n-    public boolean canDrop() {\n-        return true;\n-    }\n-\n-    @Override\n-    public TableType getTableType() {\n-        return TableType.VIEW;\n-    }\n-\n-    @Override\n-    public void removeChildrenAndResources(Session session) {\n-        removeCurrentViewFromOtherTables();\n-        super.removeChildrenAndResources(session);\n-        database.removeMeta(session, getId());\n-        querySQL = null;\n-        index = null;\n-        clearIndexCaches(database);\n-        invalidate();\n-    }\n-\n-    /**\n-     * Clear the cached indexes for all sessions.\n-     *\n-     * @param database the database\n-     */\n-    public static void clearIndexCaches(Database database) {\n-        for (Session s : database.getSessions(true)) {\n-            s.clearViewIndexCache();\n-        }\n-    }\n-\n-    @Override\n-    public StringBuilder getSQL(StringBuilder builder, boolean alwaysQuote) {\n-        if (isTemporary() && querySQL != null) {\n-            builder.append(\"(\\n\");\n-            return StringUtils.indent(builder, querySQL, 4, true).append(')');\n-        }\n-        return super.getSQL(builder, alwaysQuote);\n-    }\n-\n-    public String getQuery() {\n-        return querySQL;\n-    }\n-\n-    @Override\n-    public Index getScanIndex(Session session) {\n-        return getBestPlanItem(session, null, null, -1, null, null).getIndex();\n-    }\n-\n-    @Override\n-    public Index getScanIndex(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n-        if (createException != null) {\n-            String msg = createException.getMessage();\n-            throw DbException.get(ErrorCode.VIEW_IS_INVALID_2,\n-                    createException, getSQL(false), msg);\n-        }\n-        PlanItem item = getBestPlanItem(session, masks, filters, filter, sortOrder, allColumnsSet);\n-        return item.getIndex();\n-    }\n-\n-    @Override\n-    public boolean canReference() {\n-        return false;\n-    }\n-\n-    @Override\n-    public ArrayList<Index> getIndexes() {\n-        return null;\n-    }\n-\n-    @Override\n-    public long getMaxDataModificationId() {\n-        if (createException != null) {\n-            return Long.MAX_VALUE;\n-        }\n-        if (viewQuery == null) {\n-            return Long.MAX_VALUE;\n-        }\n-        // if nothing was modified in the database since the last check, and the\n-        // last is known, then we don't need to check again\n-        // this speeds up nested views\n-        long dbMod = database.getModificationDataId();\n-        if (dbMod > lastModificationCheck && maxDataModificationId <= dbMod) {\n-            maxDataModificationId = viewQuery.getMaxDataModificationId();\n-            lastModificationCheck = dbMod;\n-        }\n-        return maxDataModificationId;\n-    }\n-\n-    @Override\n-    public Index getUniqueIndex() {\n-        return null;\n-    }\n-\n-    private void removeCurrentViewFromOtherTables() {\n-        if (tables != null) {\n-            for (Table t : tables) {\n-                t.removeDependentView(this);\n-            }\n-            tables.clear();\n-        }\n-    }\n-\n-    private void addDependentViewToTables() {\n-        for (Table t : tables) {\n-            t.addDependentView(this);\n-        }\n-    }\n-\n-    private void setOwner(User owner) {\n-        this.owner = owner;\n-    }\n-\n-    public User getOwner() {\n-        return owner;\n-    }\n-\n-    /**\n-     * Create a temporary view out of the given query.\n-     *\n-     * @param session the session\n-     * @param owner the owner of the query\n-     * @param name the view name\n-     * @param query the query\n-     * @param topQuery the top level query\n-     * @return the view table\n-     */\n-    public static TableView createTempView(Session session, User owner,\n-            String name, Query query, Query topQuery) {\n-        Schema mainSchema = session.getDatabase().getMainSchema();\n-        String querySQL = query.getPlanSQL(true);\n-        TableView v = new TableView(mainSchema, 0, name,\n-                querySQL, query.getParameters(), null /* column templates */, session,\n-                false/* allow recursive */, true /* literals have already been checked when parsing original query */,\n-                false /* is table expression */, true/*temporary*/);\n-        if (v.createException != null) {\n-            throw v.createException;\n-        }\n-        v.setTopQuery(topQuery);\n-        v.setOwner(owner);\n-        v.setTemporary(true);\n-        return v;\n-    }\n-\n-    private void setTopQuery(Query topQuery) {\n-        this.topQuery = topQuery;\n-    }\n-\n-    @Override\n-    public long getRowCountApproximation() {\n-        return ROW_COUNT_APPROXIMATION;\n-    }\n-\n-    @Override\n-    public long getDiskSpaceUsed() {\n-        return 0;\n-    }\n-\n-    /**\n-     * Get the index of the first parameter.\n-     *\n-     * @param additionalParameters additional parameters\n-     * @return the index of the first parameter\n-     */\n-    public int getParameterOffset(ArrayList<Parameter> additionalParameters) {\n-        int result = topQuery == null ? -1 : getMaxParameterIndex(topQuery.getParameters());\n-        if (additionalParameters != null) {\n-            result = Math.max(result, getMaxParameterIndex(additionalParameters));\n-        }\n-        return result + 1;\n-    }\n-\n-    private static int getMaxParameterIndex(ArrayList<Parameter> parameters) {\n-        int result = -1;\n-        for (Parameter p : parameters) {\n-            result = Math.max(result, p.getIndex());\n-        }\n-        return result;\n-    }\n-\n-    public boolean isRecursive() {\n-        return allowRecursive;\n-    }\n-\n-    @Override\n-    public boolean isDeterministic() {\n-        if (allowRecursive || viewQuery == null) {\n-            return false;\n-        }\n-        return viewQuery.isEverything(ExpressionVisitor.DETERMINISTIC_VISITOR);\n-    }\n-\n-    public void setRecursiveResult(ResultInterface value) {\n-        if (recursiveResult != null) {\n-            recursiveResult.close();\n-        }\n-        this.recursiveResult = value;\n-    }\n-\n-    public ResultInterface getRecursiveResult() {\n-        return recursiveResult;\n-    }\n-\n-    @Override\n-    public void addDependencies(HashSet<DbObject> dependencies) {\n-        super.addDependencies(dependencies);\n-        if (tables != null) {\n-            for (Table t : tables) {\n-                if (TableType.VIEW != t.getTableType()) {\n-                    t.addDependencies(dependencies);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * The key of the index cache for views.\n-     */\n-    private static final class CacheKey {\n-\n-        private final int[] masks;\n-        private final TableView view;\n-\n-        CacheKey(int[] masks, TableView view) {\n-            this.masks = masks;\n-            this.view = view;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            final int prime = 31;\n-            int result = 1;\n-            result = prime * result + Arrays.hashCode(masks);\n-            result = prime * result + view.hashCode();\n-            return result;\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n-            }\n-            if (obj == null) {\n-                return false;\n-            }\n-            if (getClass() != obj.getClass()) {\n-                return false;\n-            }\n-            CacheKey other = (CacheKey) obj;\n-            if (view != other.view) {\n-                return false;\n-            }\n-            return Arrays.equals(masks, other.masks);\n-        }\n-    }\n-\n-    /**\n-     * Was query recursion detected during compiling.\n-     *\n-     * @return true if yes\n-     */\n-    public boolean isRecursiveQueryDetected() {\n-        return isRecursiveQueryDetected;\n-    }\n-\n-    /**\n-     * Does exception indicate query recursion?\n-     */\n-    private boolean isRecursiveQueryExceptionDetected(DbException exception) {\n-        if (exception == null) {\n-            return false;\n-        }\n-        if (exception.getErrorCode() != ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1) {\n-            return false;\n-        }\n-        return exception.getMessage().contains(\"\\\"\" + this.getName() + \"\\\"\");\n-    }\n-\n-    public List<Table> getTables() {\n-        return tables;\n-    }\n-\n-    /**\n-     * Create a view.\n-     *\n-     * @param schema the schema\n-     * @param id the view id\n-     * @param name the view name\n-     * @param querySQL the query\n-     * @param parameters the parameters\n-     * @param columnTemplates the columns\n-     * @param session the session\n-     * @param literalsChecked whether literals in the query are checked\n-     * @param isTableExpression if this is a table expression\n-     * @param isTemporary whether the view is persisted\n-     * @param db the database\n-     * @return the view\n-     */\n-    public static TableView createTableViewMaybeRecursive(Schema schema, int id, String name, String querySQL,\n-            ArrayList<Parameter> parameters, Column[] columnTemplates, Session session,\n-            boolean literalsChecked, boolean isTableExpression, boolean isTemporary, Database db) {\n-\n-\n-        Table recursiveTable = createShadowTableForRecursiveTableExpression(isTemporary, session, name,\n-                schema, Arrays.asList(columnTemplates), db);\n-\n-        List<Column> columnTemplateList;\n-        String[] querySQLOutput = {null};\n-        ArrayList<String> columnNames = new ArrayList<>();\n-        for (Column columnTemplate: columnTemplates) {\n-            columnNames.add(columnTemplate.getName());\n-        }\n-\n-        try {\n-            Prepared withQuery = session.prepare(querySQL, false, false);\n-            if (!isTemporary) {\n-                withQuery.setSession(session);\n-            }\n-            columnTemplateList = TableView.createQueryColumnTemplateList(columnNames.toArray(new String[1]),\n-                    (Query) withQuery, querySQLOutput);\n-\n-        } finally {\n-            destroyShadowTableForRecursiveExpression(isTemporary, session, recursiveTable);\n-        }\n-\n-        // build with recursion turned on\n-        TableView view = new TableView(schema, id, name, querySQL,\n-                parameters, columnTemplateList.toArray(columnTemplates), session,\n-                true/* try recursive */, literalsChecked, isTableExpression, isTemporary);\n-\n-        // is recursion really detected ? if not - recreate it without recursion flag\n-        // and no recursive index\n-        if (!view.isRecursiveQueryDetected()) {\n-            if (!isTemporary) {\n-                db.addSchemaObject(session, view);\n-                view.lock(session, true, true);\n-                session.getDatabase().removeSchemaObject(session, view);\n-\n-                // during database startup - this method does not normally get called - and it\n-                // needs to be to correctly un-register the table which the table expression\n-                // uses...\n-                view.removeChildrenAndResources(session);\n-            } else {\n-                session.removeLocalTempTable(view);\n-            }\n-            view = new TableView(schema, id, name, querySQL, parameters,\n-                    columnTemplates, session,\n-                    false/* detected not recursive */, literalsChecked, isTableExpression, isTemporary);\n-        }\n-\n-        return view;\n-    }\n-\n-\n-    /**\n-     * Creates a list of column templates from a query (usually from WITH query,\n-     * but could be any query)\n-     *\n-     * @param cols - an optional list of column names (can be specified by WITH\n-     *            clause overriding usual select names)\n-     * @param theQuery - the query object we want the column list for\n-     * @param querySQLOutput - array of length 1 to receive extra 'output' field\n-     *            in addition to return value - containing the SQL query of the\n-     *            Query object\n-     * @return a list of column object returned by withQuery\n-     */\n-    public static List<Column> createQueryColumnTemplateList(String[] cols,\n-            Query theQuery, String[] querySQLOutput) {\n-        List<Column> columnTemplateList = new ArrayList<>();\n-        theQuery.prepare();\n-        // String array of length 1 is to receive extra 'output' field in addition to\n-        // return value\n-        querySQLOutput[0] = StringUtils.cache(theQuery.getPlanSQL(true));\n-        ColumnNamer columnNamer = new ColumnNamer(theQuery.getSession());\n-        ArrayList<Expression> withExpressions = theQuery.getExpressions();\n-        for (int i = 0; i < withExpressions.size(); ++i) {\n-            Expression columnExp = withExpressions.get(i);\n-            // use the passed in column name if supplied, otherwise use alias\n-            // (if found) otherwise use column name derived from column\n-            // expression\n-            String columnName = columnNamer.getColumnName(columnExp, i, cols);\n-            columnTemplateList.add(new Column(columnName, columnExp.getType()));\n-\n-        }\n-        return columnTemplateList;\n-    }\n-\n-    /**\n-     * Create a table for a recursive query.\n-     *\n-     * @param isTemporary whether the table is persisted\n-     * @param targetSession the session\n-     * @param cteViewName the name\n-     * @param schema the schema\n-     * @param columns the columns\n-     * @param db the database\n-     * @return the table\n-     */\n-    public static Table createShadowTableForRecursiveTableExpression(boolean isTemporary, Session targetSession,\n-            String cteViewName, Schema schema, List<Column> columns, Database db) {\n-\n-        // create table data object\n-        CreateTableData recursiveTableData = new CreateTableData();\n-        recursiveTableData.id = db.allocateObjectId();\n-        recursiveTableData.columns = new ArrayList<>(columns);\n-        recursiveTableData.tableName = cteViewName;\n-        recursiveTableData.temporary = isTemporary;\n-        recursiveTableData.persistData = true;\n-        recursiveTableData.persistIndexes = !isTemporary;\n-        recursiveTableData.create = true;\n-        recursiveTableData.session = targetSession;\n-\n-        // this gets a meta table lock that is not released\n-        Table recursiveTable = schema.createTable(recursiveTableData);\n-\n-        if (!isTemporary) {\n-            // this unlock is to prevent lock leak from schema.createTable()\n-            db.unlockMeta(targetSession);\n-            synchronized (targetSession) {\n-                db.addSchemaObject(targetSession, recursiveTable);\n-            }\n-        } else {\n-            targetSession.addLocalTempTable(recursiveTable);\n-        }\n-        return recursiveTable;\n-    }\n-\n-    /**\n-     * Remove a table for a recursive query.\n-     *\n-     * @param isTemporary whether the table is persisted\n-     * @param targetSession the session\n-     * @param recursiveTable the table\n-     */\n-    public static void destroyShadowTableForRecursiveExpression(boolean isTemporary, Session targetSession,\n-            Table recursiveTable) {\n-        if (recursiveTable != null) {\n-            if (!isTemporary) {\n-                recursiveTable.lock(targetSession, true, true);\n-                targetSession.getDatabase().removeSchemaObject(targetSession, recursiveTable);\n-\n-            } else {\n-                targetSession.removeLocalTempTable(recursiveTable);\n-            }\n-\n-            // both removeSchemaObject and removeLocalTempTable hold meta locks - release them here\n-            targetSession.getDatabase().unlockMeta(targetSession);\n-        }\n-    }\n+      }\n+      return Arrays.equals(masks, other.masks);\n+    }\n+  }\n+\n+  /**\n+   * Was query recursion detected during compiling.\n+   *\n+   * @return true if yes\n+   */\n+  public boolean isRecursiveQueryDetected() {\n+    return isRecursiveQueryDetected;\n+  }\n+\n+  /**\n+   * Does exception indicate query recursion?\n+   */\n+  private boolean isRecursiveQueryExceptionDetected(DbException exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    if (exception.getErrorCode() != ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1) {\n+      return false;\n+    }\n+    return exception.getMessage().contains(\"\\\"\" + this.getName() + \"\\\"\");\n+  }\n+\n+  public List<Table> getTables() {\n+    return tables;\n+  }\n+\n+  /**\n+   * Create a view.\n+   *\n+   * @param schema            the schema\n+   * @param id                the view id\n+   * @param name              the view name\n+   * @param querySQL          the query\n+   * @param parameters        the parameters\n+   * @param columnTemplates   the columns\n+   * @param session           the session\n+   * @param literalsChecked   whether literals in the query are checked\n+   * @param isTableExpression if this is a table expression\n+   * @param isTemporary       whether the view is persisted\n+   * @param db                the database\n+   * @return the view\n+   */\n+  public static TableView createTableViewMaybeRecursive(Schema schema, int id, String name, String querySQL,\n+                                                        ArrayList<Parameter> parameters, Column[] columnTemplates,\n+                                                        Session session,\n+                                                        boolean literalsChecked, boolean isTableExpression,\n+                                                        boolean isTemporary, Database db) {\n+\n+\n+    Table recursiveTable = createShadowTableForRecursiveTableExpression(isTemporary, session, name,\n+        schema, Arrays.asList(columnTemplates), db);\n+\n+    List<Column> columnTemplateList;\n+    String[] querySQLOutput = {null};\n+    ArrayList<String> columnNames = new ArrayList<>();\n+    for (Column columnTemplate : columnTemplates) {\n+      columnNames.add(columnTemplate.getName());\n+    }\n+\n+    try {\n+      Prepared withQuery = session.prepare(querySQL, false, false);\n+      if (!isTemporary) {\n+        withQuery.setSession(session);\n+      }\n+      columnTemplateList = TableView.createQueryColumnTemplateList(columnNames.toArray(new String[1]),\n+          (Query) withQuery, querySQLOutput);\n+\n+    } finally {\n+      destroyShadowTableForRecursiveExpression(isTemporary, session, recursiveTable);\n+    }\n+\n+    // build with recursion turned on\n+    TableView view = new TableView(schema, id, name, querySQL,\n+        parameters, columnTemplateList.toArray(columnTemplates), session,\n+        true/* try recursive */, literalsChecked, isTableExpression, isTemporary);\n+\n+    // is recursion really detected ? if not - recreate it without recursion flag\n+    // and no recursive index\n+    if (!view.isRecursiveQueryDetected()) {\n+      if (!isTemporary) {\n+        db.addSchemaObject(session, view);\n+        view.lock(session, true, true);\n+        session.getDatabase().removeSchemaObject(session, view);\n+\n+        // during database startup - this method does not normally get called - and it\n+        // needs to be to correctly un-register the table which the table expression\n+        // uses...\n+        view.removeChildrenAndResources(session);\n+      } else {\n+        session.removeLocalTempTable(view);\n+      }\n+      view = new TableView(schema, id, name, querySQL, parameters,\n+          columnTemplates, session,\n+          false/* detected not recursive */, literalsChecked, isTableExpression, isTemporary);\n+    }\n+\n+    return view;\n+  }\n+\n+\n+  /**\n+   * Creates a list of column templates from a query (usually from WITH query,\n+   * but could be any query)\n+   *\n+   * @param cols           - an optional list of column names (can be specified by WITH\n+   *                       clause overriding usual select names)\n+   * @param theQuery       - the query object we want the column list for\n+   * @param querySQLOutput - array of length 1 to receive extra 'output' field\n+   *                       in addition to return value - containing the SQL query of the\n+   *                       Query object\n+   * @return a list of column object returned by withQuery\n+   */\n+  public static List<Column> createQueryColumnTemplateList(String[] cols,\n+                                                           Query theQuery, String[] querySQLOutput) {\n+    List<Column> columnTemplateList = new ArrayList<>();\n+    theQuery.prepare();\n+    // String array of length 1 is to receive extra 'output' field in addition to\n+    // return value\n+    querySQLOutput[0] = StringUtils.cache(theQuery.getPlanSQL(true));\n+    ColumnNamer columnNamer = new ColumnNamer(theQuery.getSession());\n+    ArrayList<Expression> withExpressions = theQuery.getExpressions();\n+    for (int i = 0; i < withExpressions.size(); ++i) {\n+      Expression columnExp = withExpressions.get(i);\n+      // use the passed in column name if supplied, otherwise use alias\n+      // (if found) otherwise use column name derived from column\n+      // expression\n+      String columnName = columnNamer.getColumnName(columnExp, i, cols);\n+      columnTemplateList.add(new Column(columnName, columnExp.getType()));\n+\n+    }\n+    return columnTemplateList;\n+  }\n+\n+  /**\n+   * Create a table for a recursive query.\n+   *\n+   * @param isTemporary   whether the table is persisted\n+   * @param targetSession the session\n+   * @param cteViewName   the name\n+   * @param schema        the schema\n+   * @param columns       the columns\n+   * @param db            the database\n+   * @return the table\n+   */\n+  public static Table createShadowTableForRecursiveTableExpression(boolean isTemporary, Session targetSession,\n+                                                                   String cteViewName, Schema schema,\n+                                                                   List<Column> columns, Database db) {\n+\n+    // create table data object\n+    CreateTableData recursiveTableData = new CreateTableData();\n+    recursiveTableData.id = db.allocateObjectId();\n+    recursiveTableData.columns = new ArrayList<>(columns);\n+    recursiveTableData.tableName = cteViewName;\n+    recursiveTableData.temporary = isTemporary;\n+    recursiveTableData.persistData = true;\n+    recursiveTableData.persistIndexes = !isTemporary;\n+    recursiveTableData.create = true;\n+    recursiveTableData.session = targetSession;\n+\n+    // this gets a meta table lock that is not released\n+    Table recursiveTable = schema.createTable(recursiveTableData);\n+\n+    if (!isTemporary) {\n+      // this unlock is to prevent lock leak from schema.createTable()\n+      db.unlockMeta(targetSession);\n+      synchronized (targetSession) {\n+        db.addSchemaObject(targetSession, recursiveTable);\n+      }\n+    } else {\n+      targetSession.addLocalTempTable(recursiveTable);\n+    }\n+    return recursiveTable;\n+  }\n+\n+  /**\n+   * Remove a table for a recursive query.\n+   *\n+   * @param isTemporary    whether the table is persisted\n+   * @param targetSession  the session\n+   * @param recursiveTable the table\n+   */\n+  public static void destroyShadowTableForRecursiveExpression(boolean isTemporary, Session targetSession,\n+                                                              Table recursiveTable) {\n+    if (recursiveTable != null) {\n+      if (!isTemporary) {\n+        recursiveTable.lock(targetSession, true, true);\n+        targetSession.getDatabase().removeSchemaObject(targetSession, recursiveTable);\n+\n+      } else {\n+        targetSession.removeLocalTempTable(recursiveTable);\n+      }\n+\n+      // both removeSchemaObject and removeLocalTempTable hold meta locks - release them here\n+      targetSession.getDatabase().unlockMeta(targetSession);\n+    }\n+  }\n }\n",
            "diff_size": 1223
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "47",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/314/TableView.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/314/TableView.java\nindex 8a97b2d1351..c3546baa475 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/314/TableView.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/314/TableView.java\n@@ -104,22 +104,13 @@ public class TableView extends Table {\n      * @param force if errors should be ignored\n      * @param literalsChecked if literals have been checked\n      */\n-    public void replace(String querySQL,  Column[] newColumnTemplates, Session session,\n+    public void replace(String querySQL, Column[] newColumnTemplates, Session session,\n             boolean recursive, boolean force, boolean literalsChecked) {\n         String oldQuerySQL = this.querySQL;\n         Column[] oldColumnTemplates = this.columnTemplates;\n //<<<<<<< HEAD\n-//        boolean oldRecursive = this.recursive;\n-//        // init\u91cc\u6267\u884c\u4e86\u4e00\u6b21initColumnsAndTables\uff0c\u867d\u7136\u6267\u884c\u4e86\u4e24\u6b21initColumnsAndTables\uff0c\u4f46\u662finit\u4e2d\u8fd8\u5efa\u7acb\u4e86ViewIndex\n-//        // \u6240\u4ee5\u8fd9\u91cc\u662f\u5fc5\u987b\u8c03\u7528init\u7684\n-//        init(querySQL, null, columnTemplates, session, recursive);\n-//        // recompile\u91cc\u53c8\u6267\u884c\u4e86\u4e00\u6b21initColumnsAndTables\n-//        DbException e = recompile(session, force, true);\n-//        if (e != null) {\n-//            // \u5982\u679c\u5931\u8d25\u4e86\uff0c\u6309\u539f\u6765\u7684\u91cd\u65b0\u6765\u8fc7\n-//            init(oldQuerySQL, null, oldColumnTemplates, session, oldRecursive);\n-//=======\n-        boolean oldRecursive = this.allowRecursive;\n+//    \n+boolean oldRecursive = this.allowRecursive;\n         init(querySQL, null, newColumnTemplates, session, recursive, literalsChecked, isTableExpression);\n         DbException e = recompile(session, force, true);\n         if (e != null) {\n@@ -218,31 +209,9 @@ public class TableView extends Table {\n         removeCurrentViewFromOtherTables();\n         setTableExpression(isTableExpression);\n         try {\n-//<<<<<<< HEAD\n-//            Query query = compileViewQuery(session, querySQL); //\u91cd\u65b0\u5bf9select\u8bed\u53e5\u8fdb\u884c\u89e3\u6790\u548cprepare\n-//            this.querySQL = query.getPlanSQL();\n-//            tables = New.arrayList(query.getTables());\n-//            ArrayList<Expression> expressions = query.getExpressions();\n-//            ArrayList<Column> list = New.arrayList();\n-//            \n-//    \t\t//select\u5b57\u6bb5\u4e2a\u6570\u6bd4view\u5b57\u6bb5\u591a\u7684\u60c5\u51b5\uff0c\u591a\u51fa\u6765\u7684\u6309select\u5b57\u6bb5\u539f\u6765\u7684\u7b97\n-//    \t\t//\u8fd9\u91cc\u5b9e\u9645\u662ff1\u3001name\n-//    \t\t//sql = \"CREATE OR REPLACE FORCE VIEW my_view COMMENT IS 'my view'(f1) \" //\n-//    \t\t//\t\t+ \"AS SELECT id,name FROM CreateViewTest\";\n-//\n-//    \t\t//select\u5b57\u6bb5\u4e2a\u6570\u6bd4view\u5b57\u6bb5\u5c11\u7684\u60c5\u51b5\uff0cview\u4e2d\u5c11\u7684\u5b57\u6bb5\u88ab\u5ffd\u7565\n-//    \t\t//\u8fd9\u91cc\u5b9e\u9645\u662ff1\uff0c\u800cf2\u88ab\u5ffd\u7565\u4e86\uff0c\u4e5f\u4e0d\u63d0\u793a\u9519\u8bef\n-//    \t\t//sql = \"CREATE OR REPLACE FORCE VIEW my_view COMMENT IS 'my view'(f1, f2) \" //\n-//    \t\t//\t\t+ \"AS SELECT id FROM CreateViewTest\";\n-//\n-//    \t\t//\u4e0d\u7ba1\u52a0\u4e0d\u52a0FORCE\uff0c\u8ddf\u4e0a\u9762\u4e5f\u4e00\u6837\n-//    \t\t//sql = \"CREATE OR REPLACE VIEW my_view COMMENT IS 'my view'(f1, f2) \" //\n-//    \t\t//\t\t+ \"AS SELECT id FROM CreateViewTest\";\n-//            \n-//            //expressions.size\u6709\u53ef\u80fd\u5927\u4e8equery.getColumnCount()\uff0c\u56e0\u4e3aquery.getColumnCount()\u4e0d\u5305\u542bgroup by\u7b49\u989d\u5916\u52a0\u8fdb\u6765\u7684\u8868\u8fbe\u5f0f\n-//            for (int i = 0, count = query.getColumnCount(); i < count; i++) {\n-//=======\n-            Query compiledQuery = compileViewQuery(session, querySQL, literalsChecked, getName());\n+    //<<<<<<< HEAD\n+//            Query query = comp\n+Query compiledQuery = compileViewQuery(session, querySQL, literalsChecked, getName());\n             this.querySQL = compiledQuery.getPlanSQL(true);\n             tables = new ArrayList<>(compiledQuery.getTables());\n             ArrayList<Expression> expressions = compiledQuery.getExpressions();\n@@ -604,8 +573,7 @@ public class TableView extends Table {\n         String querySQL = query.getPlanSQL(true);\n         TableView v = new TableView(mainSchema, 0, name,\n                 querySQL, query.getParameters(), null /* column templates */, session,\n-                false/* allow recursive */, true /* literals have already been checked when parsing original query */,\n-                false /* is table expression */, true/*temporary*/);\n+        false/* allow recursive */, true/* literals have already been checked when parsing original query */, false/* is table expression */, true/*temporary*/);\n         if (v.createException != null) {\n             throw v.createException;\n         }\n@@ -772,15 +740,13 @@ public class TableView extends Table {\n     public static TableView createTableViewMaybeRecursive(Schema schema, int id, String name, String querySQL,\n             ArrayList<Parameter> parameters, Column[] columnTemplates, Session session,\n             boolean literalsChecked, boolean isTableExpression, boolean isTemporary, Database db) {\n-\n-\n-        Table recursiveTable = createShadowTableForRecursiveTableExpression(isTemporary, session, name,\n+    Table recursiveTable = createShadowTableForRecursiveTableExpression(isTemporary, session, name,\n                 schema, Arrays.asList(columnTemplates), db);\n \n         List<Column> columnTemplateList;\n         String[] querySQLOutput = {null};\n         ArrayList<String> columnNames = new ArrayList<>();\n-        for (Column columnTemplate: columnTemplates) {\n+        for (Column columnTemplate : columnTemplates) {\n             columnNames.add(columnTemplate.getName());\n         }\n \n@@ -791,15 +757,14 @@ public class TableView extends Table {\n             }\n             columnTemplateList = TableView.createQueryColumnTemplateList(columnNames.toArray(new String[1]),\n                     (Query) withQuery, querySQLOutput);\n-\n-        } finally {\n+    } finally {\n             destroyShadowTableForRecursiveExpression(isTemporary, session, recursiveTable);\n         }\n \n         // build with recursion turned on\n         TableView view = new TableView(schema, id, name, querySQL,\n                 parameters, columnTemplateList.toArray(columnTemplates), session,\n-                true/* try recursive */, literalsChecked, isTableExpression, isTemporary);\n+        true/* try recursive */, literalsChecked, isTableExpression, isTemporary);\n \n         // is recursion really detected ? if not - recreate it without recursion flag\n         // and no recursive index\n@@ -818,10 +783,9 @@ public class TableView extends Table {\n             }\n             view = new TableView(schema, id, name, querySQL, parameters,\n                     columnTemplates, session,\n-                    false/* detected not recursive */, literalsChecked, isTableExpression, isTemporary);\n+        false/* detected not recursive */, literalsChecked, isTableExpression, isTemporary);\n         }\n-\n-        return view;\n+return view;\n     }\n \n \n@@ -853,8 +817,7 @@ public class TableView extends Table {\n             // expression\n             String columnName = columnNamer.getColumnName(columnExp, i, cols);\n             columnTemplateList.add(new Column(columnName, columnExp.getType()));\n-\n-        }\n+    }\n         return columnTemplateList;\n     }\n \n@@ -911,8 +874,7 @@ public class TableView extends Table {\n             if (!isTemporary) {\n                 recursiveTable.lock(targetSession, true, true);\n                 targetSession.getDatabase().removeSchemaObject(targetSession, recursiveTable);\n-\n-            } else {\n+    } else {\n                 targetSession.removeLocalTempTable(recursiveTable);\n             }\n \n@@ -920,4 +882,4 @@ public class TableView extends Table {\n             targetSession.getDatabase().unlockMeta(targetSession);\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 54
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/314/TableView.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/314/TableView.java\nindex 8a97b2d1351..cacc1b8c705 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/314/TableView.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/314/TableView.java\n@@ -10,7 +10,6 @@ import java.util.Arrays;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-\n import org.h2.api.ErrorCode;\n import org.h2.command.Prepared;\n import org.h2.command.ddl.CreateTableData;\n@@ -44,32 +43,33 @@ import org.h2.value.Value;\n  */\n /*\n          \u6709\u4e09\u79cd\u4ea7\u751fTableView\u7684\u65b9\u5f0f:\n-\t1. CREATE VIEW\u8bed\u53e5\n+    1. CREATE VIEW\u8bed\u53e5\n \n-\t\u5982: CREATE OR REPLACE FORCE VIEW IF NOT EXISTS my_view COMMENT IS 'my view'(f1,f2) \n-\t\t\tAS SELECT id,name FROM CreateViewTest\n+    \u5982: CREATE OR REPLACE FORCE VIEW IF NOT EXISTS my_view COMMENT IS 'my view'(f1,f2) \n+            AS SELECT id,name FROM CreateViewTest\n \n \n-\t2. \u5d4c\u5165\u5728FROM\u4e2d\u7684\u4e34\u65f6\u89c6\u56fe\n+    2. \u5d4c\u5165\u5728FROM\u4e2d\u7684\u4e34\u65f6\u89c6\u56fe\n \n-\t\u5982: select id,name from (select id,name from CreateViewTest)\n+    \u5982: select id,name from (select id,name from CreateViewTest)\n \n \n-\t3. WITH RECURSIVE\u8bed\u53e5\n+    3. WITH RECURSIVE\u8bed\u53e5\n \n-\t\u5982: WITH RECURSIVE my_tmp_table(f1,f2) \n-\t\t\tAS (select id,name from CreateViewTest UNION ALL select 1, 2) \n-\t\t\t\tselect f1, f2 from my_tmp_table\n-\tRECURSIVE\u8fd9\u4e2a\u5173\u952e\u5b57\u662f\u53ef\u9009\u7684\n+    \u5982: WITH RECURSIVE my_tmp_table(f1,f2) \n+            AS (select id,name from CreateViewTest UNION ALL select 1, 2) \n+                select f1, f2 from my_tmp_table\n+    RECURSIVE\u8fd9\u4e2a\u5173\u952e\u5b57\u662f\u53ef\u9009\u7684\n \n \n-\t\u53ea\u67092\u53ef\u4ee5\u5e26Parameters\uff0c\u5b83\u662f\u901a\u8fc7\u8fd9\u4e2a\u65b9\u6cd5\u8c03\u7528: org.h2.table.TableView.createTempView(Session, User, String, Query, Query)\n-\t\u53ea\u67093\u7684recursive\u662ftrue \n+    \u53ea\u67092\u53ef\u4ee5\u5e26Parameters\uff0c\u5b83\u662f\u901a\u8fc7\u8fd9\u4e2a\u65b9\u6cd5\u8c03\u7528: org.h2.table.TableView.createTempView(Session, User, String, Query, Query)\n+    \u53ea\u67093\u7684recursive\u662ftrue \n  */\n+\n+\n public class TableView extends Table {\n \n     private static final long ROW_COUNT_APPROXIMATION = 100;\n-\n     private String querySQL;\n     private ArrayList<Table> tables;\n     private Column[] columnTemplates;\n@@ -85,9 +85,7 @@ public class TableView extends Table {\n     private boolean isRecursiveQueryDetected;\n     private boolean isTableExpression;\n \n-    public TableView(Schema schema, int id, String name, String querySQL,\n-            ArrayList<Parameter> params, Column[] columnTemplates, Session session,\n-            boolean allowRecursive, boolean literalsChecked, boolean isTableExpression, boolean isTemporary) {\n+    public TableView(Schema schema, int id, String name, String querySQL, ArrayList<Parameter> params, Column[] columnTemplates, Session session, boolean allowRecursive, boolean literalsChecked, boolean isTableExpression, boolean isTemporary) {\n         super(schema, id, name, false, true);\n         setTemporary(isTemporary);\n         init(querySQL, params, columnTemplates, session, allowRecursive, literalsChecked, isTableExpression);\n@@ -104,8 +102,9 @@ public class TableView extends Table {\n      * @param force if errors should be ignored\n      * @param literalsChecked if literals have been checked\n      */\n-    public void replace(String querySQL,  Column[] newColumnTemplates, Session session,\n-            boolean recursive, boolean force, boolean literalsChecked) {\n+\n+\n+    public void replace(String querySQL, Column[] newColumnTemplates, Session session, boolean recursive, boolean force, boolean literalsChecked) {\n         String oldQuerySQL = this.querySQL;\n         Column[] oldColumnTemplates = this.columnTemplates;\n //<<<<<<< HEAD\n@@ -123,16 +122,13 @@ public class TableView extends Table {\n         init(querySQL, null, newColumnTemplates, session, recursive, literalsChecked, isTableExpression);\n         DbException e = recompile(session, force, true);\n         if (e != null) {\n-            init(oldQuerySQL, null, oldColumnTemplates, session, oldRecursive,\n-                    literalsChecked, isTableExpression);\n+            init(oldQuerySQL, null, oldColumnTemplates, session, oldRecursive, literalsChecked, isTableExpression);\n             recompile(session, true, false);\n             throw e;\n         }\n     }\n \n-    private synchronized void init(String querySQL, ArrayList<Parameter> params,\n-            Column[] columnTemplates, Session session, boolean allowRecursive, boolean literalsChecked,\n-            boolean isTableExpression) {\n+    private synchronized void init(String querySQL, ArrayList<Parameter> params, Column[] columnTemplates, Session session, boolean allowRecursive, boolean literalsChecked, boolean isTableExpression) {\n         this.querySQL = querySQL;\n         this.columnTemplates = columnTemplates;\n         this.allowRecursive = allowRecursive;\n@@ -170,8 +166,9 @@ public class TableView extends Table {\n      * @return the exception if re-compiling this or any dependent view failed\n      *         (only when force is disabled)\n      */\n-    public synchronized DbException recompile(Session session, boolean force,\n-            boolean clearIndexCache) {\n+\n+\n+    public synchronized DbException recompile(Session session, boolean force, boolean clearIndexCache) {\n         try {\n             compileViewQuery(session, querySQL, false, getName());\n         } catch (DbException e) {\n@@ -183,8 +180,8 @@ public class TableView extends Table {\n //        \n //        //\u5982\u4e0b:\n //        //CREATE OR REPLACE FORCE VIEW my_view(f1,f2) AS SELECT id,name FROM CreateViewTest\n-//\t\t//CREATE OR REPLACE FORCE VIEW view1 AS SELECT f1 FROM my_view\n-//\t\t//CREATE OR REPLACE FORCE VIEW view2 AS SELECT f2 FROM my_view\n+//      //CREATE OR REPLACE FORCE VIEW view1 AS SELECT f1 FROM my_view\n+//      //CREATE OR REPLACE FORCE VIEW view2 AS SELECT f2 FROM my_view\n //        //view1\u548cview2\u662f\u5efa\u7acb\u5728my_view\u8fd9\u4e2a\u89c6\u56fe\u4e4b\u4e0a\uff0c\u5f53\u8981recompile my_view\u65f6\uff0c\u56e0\u4e3aview1\u548cview2\u4f9d\u8d56\u4e86my_view\n //        //\u6240\u4ee5\u8981\u5bf9\u4ed6\u4eec\u91cd\u65b0recompile\uff0c\u8fd9\u91ccgetViews()\u8fd4\u56deview1\u548cview2\n //        ArrayList<TableView> views = getViews();\n@@ -199,7 +196,7 @@ public class TableView extends Table {\n //                    return e;\n //                }\n //=======\n-        ArrayList<TableView> dependentViews = new ArrayList<>(getDependentViews());\n+        ArrayList<TableView> dependentViews = new ArrayList< >(getDependentViews());\n         initColumnsAndTables(session, false);\n         for (TableView v : dependentViews) {\n             DbException e = v.recompile(session, force, false);\n@@ -225,30 +222,30 @@ public class TableView extends Table {\n //            ArrayList<Expression> expressions = query.getExpressions();\n //            ArrayList<Column> list = New.arrayList();\n //            \n-//    \t\t//select\u5b57\u6bb5\u4e2a\u6570\u6bd4view\u5b57\u6bb5\u591a\u7684\u60c5\u51b5\uff0c\u591a\u51fa\u6765\u7684\u6309select\u5b57\u6bb5\u539f\u6765\u7684\u7b97\n-//    \t\t//\u8fd9\u91cc\u5b9e\u9645\u662ff1\u3001name\n-//    \t\t//sql = \"CREATE OR REPLACE FORCE VIEW my_view COMMENT IS 'my view'(f1) \" //\n-//    \t\t//\t\t+ \"AS SELECT id,name FROM CreateViewTest\";\n+//          //select\u5b57\u6bb5\u4e2a\u6570\u6bd4view\u5b57\u6bb5\u591a\u7684\u60c5\u51b5\uff0c\u591a\u51fa\u6765\u7684\u6309select\u5b57\u6bb5\u539f\u6765\u7684\u7b97\n+//          //\u8fd9\u91cc\u5b9e\u9645\u662ff1\u3001name\n+//          //sql = \"CREATE OR REPLACE FORCE VIEW my_view COMMENT IS 'my view'(f1) \" //\n+//          //      + \"AS SELECT id,name FROM CreateViewTest\";\n //\n-//    \t\t//select\u5b57\u6bb5\u4e2a\u6570\u6bd4view\u5b57\u6bb5\u5c11\u7684\u60c5\u51b5\uff0cview\u4e2d\u5c11\u7684\u5b57\u6bb5\u88ab\u5ffd\u7565\n-//    \t\t//\u8fd9\u91cc\u5b9e\u9645\u662ff1\uff0c\u800cf2\u88ab\u5ffd\u7565\u4e86\uff0c\u4e5f\u4e0d\u63d0\u793a\u9519\u8bef\n-//    \t\t//sql = \"CREATE OR REPLACE FORCE VIEW my_view COMMENT IS 'my view'(f1, f2) \" //\n-//    \t\t//\t\t+ \"AS SELECT id FROM CreateViewTest\";\n+//          //select\u5b57\u6bb5\u4e2a\u6570\u6bd4view\u5b57\u6bb5\u5c11\u7684\u60c5\u51b5\uff0cview\u4e2d\u5c11\u7684\u5b57\u6bb5\u88ab\u5ffd\u7565\n+//          //\u8fd9\u91cc\u5b9e\u9645\u662ff1\uff0c\u800cf2\u88ab\u5ffd\u7565\u4e86\uff0c\u4e5f\u4e0d\u63d0\u793a\u9519\u8bef\n+//          //sql = \"CREATE OR REPLACE FORCE VIEW my_view COMMENT IS 'my view'(f1, f2) \" //\n+//          //      + \"AS SELECT id FROM CreateViewTest\";\n //\n-//    \t\t//\u4e0d\u7ba1\u52a0\u4e0d\u52a0FORCE\uff0c\u8ddf\u4e0a\u9762\u4e5f\u4e00\u6837\n-//    \t\t//sql = \"CREATE OR REPLACE VIEW my_view COMMENT IS 'my view'(f1, f2) \" //\n-//    \t\t//\t\t+ \"AS SELECT id FROM CreateViewTest\";\n+//          //\u4e0d\u7ba1\u52a0\u4e0d\u52a0FORCE\uff0c\u8ddf\u4e0a\u9762\u4e5f\u4e00\u6837\n+//          //sql = \"CREATE OR REPLACE VIEW my_view COMMENT IS 'my view'(f1, f2) \" //\n+//          //      + \"AS SELECT id FROM CreateViewTest\";\n //            \n //            //expressions.size\u6709\u53ef\u80fd\u5927\u4e8equery.getColumnCount()\uff0c\u56e0\u4e3aquery.getColumnCount()\u4e0d\u5305\u542bgroup by\u7b49\u989d\u5916\u52a0\u8fdb\u6765\u7684\u8868\u8fbe\u5f0f\n //            for (int i = 0, count = query.getColumnCount(); i < count; i++) {\n //=======\n             Query compiledQuery = compileViewQuery(session, querySQL, literalsChecked, getName());\n             this.querySQL = compiledQuery.getPlanSQL(true);\n-            tables = new ArrayList<>(compiledQuery.getTables());\n+            tables = new ArrayList< >(compiledQuery.getTables());\n             ArrayList<Expression> expressions = compiledQuery.getExpressions();\n             ColumnNamer columnNamer = new ColumnNamer(session);\n             final int count = compiledQuery.getColumnCount();\n-            ArrayList<Column> list = new ArrayList<>(count);\n+            ArrayList<Column> list = new ArrayList< >(count);\n             for (int i = 0; i < count; i++) {\n                 Expression expr = expressions.get(i);\n                 String name = null;\n@@ -311,14 +308,14 @@ public class TableView extends Table {\n      *\n      * @return true if it is\n      */\n+\n+\n     public boolean isInvalid() {\n         return createException != null;\n     }\n \n     @Override\n-    public PlanItem getBestPlanItem(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n+    public PlanItem getBestPlanItem(Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder, AllColumnsForPlan allColumnsSet) {\n         final CacheKey cacheKey = new CacheKey(masks, this);\n         Map<Object, ViewIndex> indexCache = session.getViewIndexCache(topQuery != null);\n         ViewIndex i = indexCache.get(cacheKey);\n@@ -342,13 +339,13 @@ public class TableView extends Table {\n                 return false;\n             }\n         }\n-        if (topQuery != null &&\n-                !topQuery.isEverything(ExpressionVisitor.QUERY_COMPARABLE_VISITOR)) {\n+        if (topQuery != null && !topQuery.isEverything(ExpressionVisitor.QUERY_COMPARABLE_VISITOR)) {\n             return false;\n         }\n         return true;\n     }\n \n+\n     public Query getTopQuery() {\n         return topQuery;\n     }\n@@ -363,7 +360,6 @@ public class TableView extends Table {\n         return getCreateSQL(false, true, quotedName);\n     }\n \n-\n     @Override\n     public String getCreateSQL() {\n         return getCreateSQL(false, true);\n@@ -376,6 +372,8 @@ public class TableView extends Table {\n      * @param force if true, then include the FORCE clause\n      * @return the SQL statement\n      */\n+\n+\n     public String getCreateSQL(boolean orReplace, boolean force) {\n         return getCreateSQL(orReplace, force, getSQL(true));\n     }\n@@ -418,11 +416,13 @@ public class TableView extends Table {\n     @Override\n     public void close(Session session) {\n         // nothing to do\n+\n     }\n \n     @Override\n     public void unlock(Session s) {\n         // nothing to do\n+\n     }\n \n     @Override\n@@ -431,9 +431,7 @@ public class TableView extends Table {\n     }\n \n     @Override\n-    public Index addIndex(Session session, String indexName, int indexId,\n-            IndexColumn[] cols, IndexType indexType, boolean create,\n-            String indexComment) {\n+    public Index addIndex(Session session, String indexName, int indexId, IndexColumn[] cols, IndexType indexType, boolean create, String indexComment) {\n         throw DbException.getUnsupportedException(\"VIEW\");\n     }\n \n@@ -494,6 +492,8 @@ public class TableView extends Table {\n      *\n      * @param database the database\n      */\n+\n+\n     public static void clearIndexCaches(Database database) {\n         for (Session s : database.getSessions(true)) {\n             s.clearViewIndexCache();\n@@ -509,6 +509,7 @@ public class TableView extends Table {\n         return super.getSQL(builder, alwaysQuote);\n     }\n \n+\n     public String getQuery() {\n         return querySQL;\n     }\n@@ -519,13 +520,10 @@ public class TableView extends Table {\n     }\n \n     @Override\n-    public Index getScanIndex(Session session, int[] masks,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            AllColumnsForPlan allColumnsSet) {\n+    public Index getScanIndex(Session session, int[] masks, TableFilter[] filters, int filter, SortOrder sortOrder, AllColumnsForPlan allColumnsSet) {\n         if (createException != null) {\n             String msg = createException.getMessage();\n-            throw DbException.get(ErrorCode.VIEW_IS_INVALID_2,\n-                    createException, getSQL(false), msg);\n+            throw DbException.get(ErrorCode.VIEW_IS_INVALID_2, createException, getSQL(false), msg);\n         }\n         PlanItem item = getBestPlanItem(session, masks, filters, filter, sortOrder, allColumnsSet);\n         return item.getIndex();\n@@ -584,6 +582,7 @@ public class TableView extends Table {\n         this.owner = owner;\n     }\n \n+\n     public User getOwner() {\n         return owner;\n     }\n@@ -598,14 +597,13 @@ public class TableView extends Table {\n      * @param topQuery the top level query\n      * @return the view table\n      */\n-    public static TableView createTempView(Session session, User owner,\n-            String name, Query query, Query topQuery) {\n+\n+\n+    public static TableView createTempView(Session session, User owner, String name, Query query, Query topQuery) {\n         Schema mainSchema = session.getDatabase().getMainSchema();\n         String querySQL = query.getPlanSQL(true);\n-        TableView v = new TableView(mainSchema, 0, name,\n-                querySQL, query.getParameters(), null /* column templates */, session,\n-                false/* allow recursive */, true /* literals have already been checked when parsing original query */,\n-                false /* is table expression */, true/*temporary*/);\n+        TableView v = new TableView(mainSchema, 0, name, querySQL, query.getParameters(),\n+null /* column templates */, session, false/* allow recursive */, true /* literals have already been checked when parsing original query */, false /* is table expression */, true/*temporary*/);\n         if (v.createException != null) {\n             throw v.createException;\n         }\n@@ -635,6 +633,8 @@ public class TableView extends Table {\n      * @param additionalParameters additional parameters\n      * @return the index of the first parameter\n      */\n+\n+\n     public int getParameterOffset(ArrayList<Parameter> additionalParameters) {\n         int result = topQuery == null ? -1 : getMaxParameterIndex(topQuery.getParameters());\n         if (additionalParameters != null) {\n@@ -651,6 +651,7 @@ public class TableView extends Table {\n         return result;\n     }\n \n+\n     public boolean isRecursive() {\n         return allowRecursive;\n     }\n@@ -663,6 +664,7 @@ public class TableView extends Table {\n         return viewQuery.isEverything(ExpressionVisitor.DETERMINISTIC_VISITOR);\n     }\n \n+\n     public void setRecursiveResult(ResultInterface value) {\n         if (recursiveResult != null) {\n             recursiveResult.close();\n@@ -670,6 +672,7 @@ public class TableView extends Table {\n         this.recursiveResult = value;\n     }\n \n+\n     public ResultInterface getRecursiveResult() {\n         return recursiveResult;\n     }\n@@ -689,6 +692,7 @@ public class TableView extends Table {\n     /**\n      * The key of the index cache for views.\n      */\n+\n     private static final class CacheKey {\n \n         private final int[] masks;\n@@ -725,6 +729,7 @@ public class TableView extends Table {\n             }\n             return Arrays.equals(masks, other.masks);\n         }\n+\n     }\n \n     /**\n@@ -732,6 +737,8 @@ public class TableView extends Table {\n      *\n      * @return true if yes\n      */\n+\n+\n     public boolean isRecursiveQueryDetected() {\n         return isRecursiveQueryDetected;\n     }\n@@ -739,6 +746,7 @@ public class TableView extends Table {\n     /**\n      * Does exception indicate query recursion?\n      */\n+\n     private boolean isRecursiveQueryExceptionDetected(DbException exception) {\n         if (exception == null) {\n             return false;\n@@ -746,9 +754,11 @@ public class TableView extends Table {\n         if (exception.getErrorCode() != ErrorCode.TABLE_OR_VIEW_NOT_FOUND_1) {\n             return false;\n         }\n-        return exception.getMessage().contains(\"\\\"\" + this.getName() + \"\\\"\");\n+        return exception.getMessage().contains(\"\\\"\" +\n+this.getName() + \"\\\"\");\n     }\n \n+\n     public List<Table> getTables() {\n         return tables;\n     }\n@@ -769,37 +779,29 @@ public class TableView extends Table {\n      * @param db the database\n      * @return the view\n      */\n-    public static TableView createTableViewMaybeRecursive(Schema schema, int id, String name, String querySQL,\n-            ArrayList<Parameter> parameters, Column[] columnTemplates, Session session,\n-            boolean literalsChecked, boolean isTableExpression, boolean isTemporary, Database db) {\n \n \n-        Table recursiveTable = createShadowTableForRecursiveTableExpression(isTemporary, session, name,\n-                schema, Arrays.asList(columnTemplates), db);\n-\n+    public static TableView createTableViewMaybeRecursive(Schema schema, int id, String name, String querySQL, ArrayList<Parameter> parameters, Column[] columnTemplates, Session session, boolean literalsChecked, boolean isTableExpression, boolean isTemporary, Database db) {\n+        Table recursiveTable = createShadowTableForRecursiveTableExpression(\n+                               isTemporary, session, name, schema, Arrays.asList(columnTemplates), db);\n         List<Column> columnTemplateList;\n-        String[] querySQLOutput = {null};\n-        ArrayList<String> columnNames = new ArrayList<>();\n-        for (Column columnTemplate: columnTemplates) {\n+        String[] querySQLOutput = { null };\n+        ArrayList<String> columnNames = new ArrayList< >();\n+        for (Column columnTemplate : columnTemplates) {\n             columnNames.add(columnTemplate.getName());\n         }\n-\n         try {\n             Prepared withQuery = session.prepare(querySQL, false, false);\n             if (!isTemporary) {\n                 withQuery.setSession(session);\n             }\n-            columnTemplateList = TableView.createQueryColumnTemplateList(columnNames.toArray(new String[1]),\n-                    (Query) withQuery, querySQLOutput);\n-\n+            columnTemplateList = TableView.createQueryColumnTemplateList(columnNames.toArray(new String[1]), (Query) withQuery, querySQLOutput);\n         } finally {\n             destroyShadowTableForRecursiveExpression(isTemporary, session, recursiveTable);\n         }\n \n         // build with recursion turned on\n-        TableView view = new TableView(schema, id, name, querySQL,\n-                parameters, columnTemplateList.toArray(columnTemplates), session,\n-                true/* try recursive */, literalsChecked, isTableExpression, isTemporary);\n+        TableView view = new TableView(schema, id, name, querySQL, parameters, columnTemplateList.toArray(columnTemplates), session, true/* try recursive */, literalsChecked, isTableExpression, isTemporary);\n \n         // is recursion really detected ? if not - recreate it without recursion flag\n         // and no recursive index\n@@ -816,11 +818,8 @@ public class TableView extends Table {\n             } else {\n                 session.removeLocalTempTable(view);\n             }\n-            view = new TableView(schema, id, name, querySQL, parameters,\n-                    columnTemplates, session,\n-                    false/* detected not recursive */, literalsChecked, isTableExpression, isTemporary);\n+            view = new TableView(schema, id, name, querySQL, parameters, columnTemplates, session, false/* detected not recursive */, literalsChecked, isTableExpression, isTemporary);\n         }\n-\n         return view;\n     }\n \n@@ -837,9 +836,10 @@ public class TableView extends Table {\n      *            Query object\n      * @return a list of column object returned by withQuery\n      */\n-    public static List<Column> createQueryColumnTemplateList(String[] cols,\n-            Query theQuery, String[] querySQLOutput) {\n-        List<Column> columnTemplateList = new ArrayList<>();\n+\n+\n+    public static List<Column> createQueryColumnTemplateList(String[] cols, Query theQuery, String[] querySQLOutput) {\n+        List<Column> columnTemplateList = new ArrayList< >();\n         theQuery.prepare();\n         // String array of length 1 is to receive extra 'output' field in addition to\n         // return value\n@@ -853,7 +853,6 @@ public class TableView extends Table {\n             // expression\n             String columnName = columnNamer.getColumnName(columnExp, i, cols);\n             columnTemplateList.add(new Column(columnName, columnExp.getType()));\n-\n         }\n         return columnTemplateList;\n     }\n@@ -869,13 +868,14 @@ public class TableView extends Table {\n      * @param db the database\n      * @return the table\n      */\n-    public static Table createShadowTableForRecursiveTableExpression(boolean isTemporary, Session targetSession,\n-            String cteViewName, Schema schema, List<Column> columns, Database db) {\n+\n+\n+    public static Table createShadowTableForRecursiveTableExpression(boolean isTemporary, Session targetSession, String cteViewName, Schema schema, List<Column> columns, Database db) {\n \n         // create table data object\n         CreateTableData recursiveTableData = new CreateTableData();\n         recursiveTableData.id = db.allocateObjectId();\n-        recursiveTableData.columns = new ArrayList<>(columns);\n+        recursiveTableData.columns = new ArrayList< >(columns);\n         recursiveTableData.tableName = cteViewName;\n         recursiveTableData.temporary = isTemporary;\n         recursiveTableData.persistData = true;\n@@ -885,7 +885,6 @@ public class TableView extends Table {\n \n         // this gets a meta table lock that is not released\n         Table recursiveTable = schema.createTable(recursiveTableData);\n-\n         if (!isTemporary) {\n             // this unlock is to prevent lock leak from schema.createTable()\n             db.unlockMeta(targetSession);\n@@ -905,13 +904,14 @@ public class TableView extends Table {\n      * @param targetSession the session\n      * @param recursiveTable the table\n      */\n-    public static void destroyShadowTableForRecursiveExpression(boolean isTemporary, Session targetSession,\n-            Table recursiveTable) {\n+\n+\n+    public static void destroyShadowTableForRecursiveExpression(boolean isTemporary,\n+        Session targetSession, Table recursiveTable) {\n         if (recursiveTable != null) {\n             if (!isTemporary) {\n                 recursiveTable.lock(targetSession, true, true);\n                 targetSession.getDatabase().removeSchemaObject(targetSession, recursiveTable);\n-\n             } else {\n                 targetSession.removeLocalTempTable(recursiveTable);\n             }\n@@ -920,4 +920,5 @@ public class TableView extends Table {\n             targetSession.getDatabase().unlockMeta(targetSession);\n         }\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 128
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "47",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "47",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}