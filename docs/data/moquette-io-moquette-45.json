{
    "project_name": "moquette-io-moquette",
    "error_id": "45",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "warning",
                "message": "missing copyright header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "package io.moquette.broker;\n\nimport io.moquette.spi.impl.subscriptions.ISubscriptionsDirectory;\nimport io.moquette.spi.impl.subscriptions.Subscription;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/45/PostOffice.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/45/PostOffice.java\nindex 5d511e33e8d..b4471877667 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/45/PostOffice.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/45/PostOffice.java\n@@ -20,255 +20,253 @@ import static io.netty.handler.codec.mqtt.MqttQoS.*;\n \n class PostOffice {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(PostOffice.class);\n-\n-    private final Authorizator authorizator;\n-    private final ISubscriptionsDirectory subscriptions;\n-    private final IRetainedRepository retainedRepository;\n-    private SessionRegistry sessionRegistry;\n-\n-    PostOffice(ISubscriptionsDirectory subscriptions, IAuthorizatorPolicy authorizatorPolicy,\n-               IRetainedRepository retainedRepository, SessionRegistry sessionRegistry) {\n-        this.authorizator = new Authorizator(authorizatorPolicy);\n-        this.subscriptions = subscriptions;\n-        this.retainedRepository = retainedRepository;\n-        this.sessionRegistry = sessionRegistry;\n+  private static final Logger LOG = LoggerFactory.getLogger(PostOffice.class);\n+\n+  private final Authorizator authorizator;\n+  private final ISubscriptionsDirectory subscriptions;\n+  private final IRetainedRepository retainedRepository;\n+  private SessionRegistry sessionRegistry;\n+\n+  PostOffice(ISubscriptionsDirectory subscriptions, IAuthorizatorPolicy authorizatorPolicy,\n+             IRetainedRepository retainedRepository, SessionRegistry sessionRegistry) {\n+    this.authorizator = new Authorizator(authorizatorPolicy);\n+    this.subscriptions = subscriptions;\n+    this.retainedRepository = retainedRepository;\n+    this.sessionRegistry = sessionRegistry;\n+  }\n+\n+  public void init(SessionRegistry sessionRegistry) {\n+    this.sessionRegistry = sessionRegistry;\n+  }\n+\n+  public void fireWill(Session.Will will) {\n+    // MQTT 3.1.2.8-17\n+    publish2Subscribers(will.payload, new Topic(will.topic), will.qos);\n+  }\n+\n+  public void subscribeClientToTopics(MqttSubscribeMessage msg, String clientID, String username,\n+                                      MQTTConnection mqttConnection) {\n+    // verify which topics of the subscribe ongoing has read access permission\n+    int messageID = messageId(msg);\n+    List<MqttTopicSubscription> ackTopics = authorizator.verifyTopicsReadAccess(clientID, username, msg);\n+    MqttSubAckMessage ackMessage = doAckMessageFromValidateFilters(ackTopics, messageID);\n+\n+    // store topics subscriptions in session\n+    List<Subscription> newSubscriptions = ackTopics.stream()\n+        .filter(req -> req.qualityOfService() != FAILURE)\n+        .map(req -> {\n+          final Topic topic = new Topic(req.topicName());\n+          return new Subscription(clientID, topic, req.qualityOfService());\n+        }).collect(Collectors.toList());\n+\n+    for (Subscription subscription : newSubscriptions) {\n+      subscriptions.add(subscription);\n     }\n \n-    public void init(SessionRegistry sessionRegistry) {\n-        this.sessionRegistry = sessionRegistry;\n-    }\n-\n-    public void fireWill(Session.Will will) {\n-        // MQTT 3.1.2.8-17\n-        publish2Subscribers(will.payload, new Topic(will.topic), will.qos);\n-    }\n-\n-    public void subscribeClientToTopics(MqttSubscribeMessage msg, String clientID, String username,\n-                                        MQTTConnection mqttConnection) {\n-        // verify which topics of the subscribe ongoing has read access permission\n-        int messageID = messageId(msg);\n-        List<MqttTopicSubscription> ackTopics = authorizator.verifyTopicsReadAccess(clientID, username, msg);\n-        MqttSubAckMessage ackMessage = doAckMessageFromValidateFilters(ackTopics, messageID);\n-\n-        // store topics subscriptions in session\n-        List<Subscription> newSubscriptions = ackTopics.stream()\n-            .filter(req -> req.qualityOfService() != FAILURE)\n-            .map(req -> {\n-                final Topic topic = new Topic(req.topicName());\n-                return new Subscription(clientID, topic, req.qualityOfService());\n-            }).collect(Collectors.toList());\n-\n-        for (Subscription subscription : newSubscriptions) {\n-            subscriptions.add(subscription);\n-        }\n+    // add the subscriptions to Session\n+    Session session = sessionRegistry.retrieve(clientID);\n+    session.addSubscriptions(newSubscriptions);\n \n-        // add the subscriptions to Session\n-        Session session = sessionRegistry.retrieve(clientID);\n-        session.addSubscriptions(newSubscriptions);\n+    // send ack message\n+    mqttConnection.sendSubAckMessage(messageID, ackMessage);\n \n-        // send ack message\n-        mqttConnection.sendSubAckMessage(messageID, ackMessage);\n+    publishRetainedMessagesForSubscriptions(clientID, newSubscriptions);\n \n-        publishRetainedMessagesForSubscriptions(clientID, newSubscriptions);\n-\n-        // TODO notify the Observables\n+    // TODO notify the Observables\n //        for (Subscription subscription : newSubscriptions) {\n //            m_interceptor.notifyTopicSubscribed(newSubscription, username);\n //        }\n-    }\n+  }\n \n-    private void publishRetainedMessagesForSubscriptions(String clientID, List<Subscription> newSubscriptions) {\n-        Session targetSession = this.sessionRegistry.retrieve(clientID);\n-        for (Subscription subscription : newSubscriptions) {\n-            final String topicFilter = subscription.getTopicFilter().toString();\n-            final MqttPublishMessage retainedMsg = retainedRepository.retainedOnTopic(topicFilter);\n+  private void publishRetainedMessagesForSubscriptions(String clientID, List<Subscription> newSubscriptions) {\n+    Session targetSession = this.sessionRegistry.retrieve(clientID);\n+    for (Subscription subscription : newSubscriptions) {\n+      final String topicFilter = subscription.getTopicFilter().toString();\n+      final MqttPublishMessage retainedMsg = retainedRepository.retainedOnTopic(topicFilter);\n \n-            if (retainedMsg == null) {\n-                // not found\n-                continue;\n-            }\n+      if (retainedMsg == null) {\n+        // not found\n+        continue;\n+      }\n \n-            final MqttQoS retainedQos = retainedMsg.fixedHeader().qosLevel();\n-            MqttQoS qos = lowerQosToTheSubscriptionDesired(subscription, retainedQos);\n+      final MqttQoS retainedQos = retainedMsg.fixedHeader().qosLevel();\n+      MqttQoS qos = lowerQosToTheSubscriptionDesired(subscription, retainedQos);\n \n-            final ByteBuf origPayload = retainedMsg.payload();\n-            ByteBuf payload = origPayload.retainedDuplicate();\n-            targetSession.sendRetainedPublishOnSessionAtQos(subscription.getTopicFilter(), qos, payload);\n-        }\n+      final ByteBuf origPayload = retainedMsg.payload();\n+      ByteBuf payload = origPayload.retainedDuplicate();\n+      targetSession.sendRetainedPublishOnSessionAtQos(subscription.getTopicFilter(), qos, payload);\n     }\n-\n-    /**\n-     * Create the SUBACK response from a list of topicFilters\n-     */\n-    private MqttSubAckMessage doAckMessageFromValidateFilters(List<MqttTopicSubscription> topicFilters, int messageId) {\n-        List<Integer> grantedQoSLevels = new ArrayList<>();\n-        for (MqttTopicSubscription req : topicFilters) {\n-            grantedQoSLevels.add(req.qualityOfService().value());\n-        }\n-\n-        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, AT_MOST_ONCE,\n-            false, 0);\n-        MqttSubAckPayload payload = new MqttSubAckPayload(grantedQoSLevels);\n-        return new MqttSubAckMessage(fixedHeader, from(messageId), payload);\n+  }\n+\n+  /**\n+   * Create the SUBACK response from a list of topicFilters\n+   */\n+  private MqttSubAckMessage doAckMessageFromValidateFilters(List<MqttTopicSubscription> topicFilters, int messageId) {\n+    List<Integer> grantedQoSLevels = new ArrayList<>();\n+    for (MqttTopicSubscription req : topicFilters) {\n+      grantedQoSLevels.add(req.qualityOfService().value());\n     }\n \n-    public void unsubscribe(List<String> topics, MQTTConnection mqttConnection, int messageId) {\n-        final String clientID = mqttConnection.getClientId();\n-        for (String t : topics) {\n-            Topic topic = new Topic(t);\n-            boolean validTopic = topic.isValid();\n-            if (!validTopic) {\n-                // close the connection, not valid topicFilter is a protocol violation\n-                mqttConnection.dropConnection();\n-                LOG.warn(\"Topic filter is not valid. CId={}, topics: {}, offending topic filter: {}\", clientID,\n-                         topics, topic);\n-                return;\n-            }\n-\n-            LOG.trace(\"Removing subscription. CId={}, topic={}\", clientID, topic);\n-            subscriptions.removeSubscription(topic, clientID);\n-\n-            // TODO remove the subscriptions to Session\n+    MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, AT_MOST_ONCE,\n+        false, 0);\n+    MqttSubAckPayload payload = new MqttSubAckPayload(grantedQoSLevels);\n+    return new MqttSubAckMessage(fixedHeader, from(messageId), payload);\n+  }\n+\n+  public void unsubscribe(List<String> topics, MQTTConnection mqttConnection, int messageId) {\n+    final String clientID = mqttConnection.getClientId();\n+    for (String t : topics) {\n+      Topic topic = new Topic(t);\n+      boolean validTopic = topic.isValid();\n+      if (!validTopic) {\n+        // close the connection, not valid topicFilter is a protocol violation\n+        mqttConnection.dropConnection();\n+        LOG.warn(\"Topic filter is not valid. CId={}, topics: {}, offending topic filter: {}\", clientID,\n+            topics, topic);\n+        return;\n+      }\n+\n+      LOG.trace(\"Removing subscription. CId={}, topic={}\", clientID, topic);\n+      subscriptions.removeSubscription(topic, clientID);\n+\n+      // TODO remove the subscriptions to Session\n //            clientSession.unsubscribeFrom(topic);\n \n-            //TODO notify interceptors\n+      //TODO notify interceptors\n //            String username = NettyUtils.userName(channel);\n //            m_interceptor.notifyTopicUnsubscribed(topic.toString(), clientID, username);\n-        }\n+    }\n+\n+    // ack the client\n+    mqttConnection.sendUnsubAckMessage(topics, clientID, messageId);\n+  }\n \n-        // ack the client\n-        mqttConnection.sendUnsubAckMessage(topics, clientID, messageId);\n+  void receivedPublishQos0(Topic topic, String username, String clientID, ByteBuf payload, boolean retain) {\n+    if (!authorizator.canWrite(topic, username, clientID)) {\n+      LOG.error(\"MQTT client is not authorized to publish on topic. CId={}, topic: {}\", clientID, topic);\n+      return;\n     }\n+    publish2Subscribers(payload, topic, AT_MOST_ONCE);\n \n-    void receivedPublishQos0(Topic topic, String username, String clientID, ByteBuf payload, boolean retain) {\n-        if (!authorizator.canWrite(topic, username, clientID)) {\n-            LOG.error(\"MQTT client is not authorized to publish on topic. CId={}, topic: {}\", clientID, topic);\n-            return;\n-        }\n-        publish2Subscribers(payload, topic, AT_MOST_ONCE);\n-\n-        if (retain) {\n-            // QoS == 0 && retain => clean old retained\n-            retainedRepository.cleanRetained(topic);\n-        }\n+    if (retain) {\n+      // QoS == 0 && retain => clean old retained\n+      retainedRepository.cleanRetained(topic);\n+    }\n // TODO\n //        m_interceptor.notifyTopicPublished(msg, clientID, username);\n+  }\n+\n+  void receivedPublishQos1(MQTTConnection connection, Topic topic, String username, ByteBuf payload, int messageID,\n+                           boolean retain, MqttPublishMessage msg) {\n+    // verify if topic can be write\n+    topic.getTokens();\n+    if (!topic.isValid()) {\n+      LOG.warn(\"Invalid topic format, force close the connection\");\n+      connection.dropConnection();\n+      return;\n+    }\n+    final String clientId = connection.getClientId();\n+    if (!authorizator.canWrite(topic, username, clientId)) {\n+      LOG.error(\"MQTT client is not authorized to publish on topic. CId={}, topic: {}\", clientId, topic);\n+      return;\n     }\n \n-    void receivedPublishQos1(MQTTConnection connection, Topic topic, String username, ByteBuf payload, int messageID,\n-                             boolean retain, MqttPublishMessage msg) {\n-        // verify if topic can be write\n-        topic.getTokens();\n-        if (!topic.isValid()) {\n-            LOG.warn(\"Invalid topic format, force close the connection\");\n-            connection.dropConnection();\n-            return;\n-        }\n-        final String clientId = connection.getClientId();\n-        if (!authorizator.canWrite(topic, username, clientId)) {\n-            LOG.error(\"MQTT client is not authorized to publish on topic. CId={}, topic: {}\", clientId, topic);\n-            return;\n-        }\n-\n-        publish2Subscribers(payload, topic, AT_LEAST_ONCE);\n-\n-        connection.sendPubAck(messageID);\n-\n-        if (retain) {\n-            if (!payload.isReadable()) {\n-                retainedRepository.cleanRetained(topic);\n-            } else {\n-                // before wasn't stored\n-                retainedRepository.retain(topic, msg);\n-            }\n-        }\n+    publish2Subscribers(payload, topic, AT_LEAST_ONCE);\n+\n+    connection.sendPubAck(messageID);\n+\n+    if (retain) {\n+      if (!payload.isReadable()) {\n+        retainedRepository.cleanRetained(topic);\n+      } else {\n+        // before wasn't stored\n+        retainedRepository.retain(topic, msg);\n+      }\n+    }\n //TODO\n //        m_interceptor.notifyTopicPublished(msg, clientID, username);\n+  }\n+\n+  private void publish2Subscribers(ByteBuf origPayload, Topic topic, MqttQoS publishingQos) {\n+    Set<Subscription> topicMatchingSubscriptions = subscriptions.matchQosSharpening(topic);\n+\n+    for (final Subscription sub : topicMatchingSubscriptions) {\n+      MqttQoS qos = lowerQosToTheSubscriptionDesired(sub, publishingQos);\n+      Session targetSession = this.sessionRegistry.retrieve(sub.getClientId());\n+\n+      boolean isSessionPresent = targetSession != null;\n+      if (isSessionPresent) {\n+        LOG.debug(\"Sending PUBLISH message to active subscriber CId: {}, topicFilter: {}, qos: {}\",\n+            sub.getClientId(), sub.getTopicFilter(), qos);\n+        // we need to retain because duplicate only copy r/w indexes and don't retain() causing refCnt = 0\n+        ByteBuf payload = origPayload.retainedDuplicate();\n+        targetSession.sendPublishOnSessionAtQos(topic, qos, payload);\n+      } else {\n+        // If we are, the subscriber disconnected after the subscriptions tree selected that session as a\n+        // destination.\n+        LOG.debug(\"PUBLISH to not yet present session. CId: {}, topicFilter: {}, qos: {}\", sub.getClientId(),\n+            sub.getTopicFilter(), qos);\n+      }\n     }\n-\n-    private void publish2Subscribers(ByteBuf origPayload, Topic topic, MqttQoS publishingQos) {\n-        Set<Subscription> topicMatchingSubscriptions = subscriptions.matchQosSharpening(topic);\n-\n-        for (final Subscription sub : topicMatchingSubscriptions) {\n-            MqttQoS qos = lowerQosToTheSubscriptionDesired(sub, publishingQos);\n-            Session targetSession = this.sessionRegistry.retrieve(sub.getClientId());\n-\n-            boolean isSessionPresent = targetSession != null;\n-            if (isSessionPresent) {\n-                LOG.debug(\"Sending PUBLISH message to active subscriber CId: {}, topicFilter: {}, qos: {}\",\n-                          sub.getClientId(), sub.getTopicFilter(), qos);\n-                // we need to retain because duplicate only copy r/w indexes and don't retain() causing refCnt = 0\n-                ByteBuf payload = origPayload.retainedDuplicate();\n-                targetSession.sendPublishOnSessionAtQos(topic, qos, payload);\n-            } else {\n-                // If we are, the subscriber disconnected after the subscriptions tree selected that session as a\n-                // destination.\n-                LOG.debug(\"PUBLISH to not yet present session. CId: {}, topicFilter: {}, qos: {}\", sub.getClientId(),\n-                          sub.getTopicFilter(), qos);\n-            }\n-        }\n+  }\n+\n+  /**\n+   * First phase of a publish QoS2 protocol, sent by publisher to the broker. Publish to all interested\n+   * subscribers.\n+   */\n+  void receivedPublishQos2(MQTTConnection connection, MqttPublishMessage mqttPublishMessage) {\n+    LOG.trace(\"Processing PUBREL message on connection: {}\", connection);\n+    final Topic topic = new Topic(mqttPublishMessage.variableHeader().topicName());\n+    final ByteBuf payload = mqttPublishMessage.payload();\n+    publish2Subscribers(payload, topic, EXACTLY_ONCE);\n+\n+    final boolean retained = mqttPublishMessage.fixedHeader().isRetain();\n+    if (retained) {\n+      if (!payload.isReadable()) {\n+        retainedRepository.cleanRetained(topic);\n+      } else {\n+        // before wasn't stored\n+        retainedRepository.retain(topic, mqttPublishMessage);\n+      }\n     }\n \n-    /**\n-     * First phase of a publish QoS2 protocol, sent by publisher to the broker. Publish to all interested\n-     * subscribers.\n-     */\n-    void receivedPublishQos2(MQTTConnection connection, MqttPublishMessage mqttPublishMessage) {\n-        LOG.trace(\"Processing PUBREL message on connection: {}\", connection);\n-        final Topic topic = new Topic(mqttPublishMessage.variableHeader().topicName());\n-        final ByteBuf payload = mqttPublishMessage.payload();\n-        publish2Subscribers(payload, topic, EXACTLY_ONCE);\n-\n-        final boolean retained = mqttPublishMessage.fixedHeader().isRetain();\n-        if (retained) {\n-            if (!payload.isReadable()) {\n-                retainedRepository.cleanRetained(topic);\n-            } else {\n-                // before wasn't stored\n-                retainedRepository.retain(topic, mqttPublishMessage);\n-            }\n-        }\n-\n-        //TODO here we should notify to the listeners\n-        //m_interceptor.notifyTopicPublished(msg, clientID, username);\n-    }\n+    //TODO here we should notify to the listeners\n+    //m_interceptor.notifyTopicPublished(msg, clientID, username);\n+  }\n \n-    static MqttQoS lowerQosToTheSubscriptionDesired(Subscription sub, MqttQoS qos) {\n-        if (qos.value() > sub.getRequestedQos().value()) {\n-            qos = sub.getRequestedQos();\n-        }\n-        return qos;\n+  static MqttQoS lowerQosToTheSubscriptionDesired(Subscription sub, MqttQoS qos) {\n+    if (qos.value() > sub.getRequestedQos().value()) {\n+      qos = sub.getRequestedQos();\n     }\n-\n-    /**\n-     * Intended usage is only for embedded versions of the broker, where the hosting application\n-     * want to use the broker to send a publish message. Like normal external publish message but\n-     * with some changes to avoid security check, and the handshake phases for Qos1 and Qos2. It\n-     * also doesn't notifyTopicPublished because using internally the owner should already know\n-     * where it's publishing.\n-     *\n-     * @param msg\n-     *            the message to publish.\n-     * @param clientId\n-     *            the clientID\n-     */\n-    public void internalPublish(MqttPublishMessage msg, final String clientId) {\n-        final MqttQoS qos = msg.fixedHeader().qosLevel();\n-        final Topic topic = new Topic(msg.variableHeader().topicName());\n-        final ByteBuf payload = msg.payload();\n-        LOG.info(\"Sending internal PUBLISH message Topic={}, qos={}\", topic, qos);\n-\n-        publish2Subscribers(payload, topic, qos);\n-\n-        if (!msg.fixedHeader().isRetain()) {\n-            return;\n-        }\n-        if (qos == AT_MOST_ONCE || msg.payload().readableBytes() == 0) {\n-            // QoS == 0 && retain => clean old retained\n-            retainedRepository.cleanRetained(topic);\n-            return;\n-        }\n-        retainedRepository.retain(topic, msg);\n+    return qos;\n+  }\n+\n+  /**\n+   * Intended usage is only for embedded versions of the broker, where the hosting application\n+   * want to use the broker to send a publish message. Like normal external publish message but\n+   * with some changes to avoid security check, and the handshake phases for Qos1 and Qos2. It\n+   * also doesn't notifyTopicPublished because using internally the owner should already know\n+   * where it's publishing.\n+   *\n+   * @param msg      the message to publish.\n+   * @param clientId the clientID\n+   */\n+  public void internalPublish(MqttPublishMessage msg, final String clientId) {\n+    final MqttQoS qos = msg.fixedHeader().qosLevel();\n+    final Topic topic = new Topic(msg.variableHeader().topicName());\n+    final ByteBuf payload = msg.payload();\n+    LOG.info(\"Sending internal PUBLISH message Topic={}, qos={}\", topic, qos);\n+\n+    publish2Subscribers(payload, topic, qos);\n+\n+    if (!msg.fixedHeader().isRetain()) {\n+      return;\n+    }\n+    if (qos == AT_MOST_ONCE || msg.payload().readableBytes() == 0) {\n+      // QoS == 0 && retain => clean old retained\n+      retainedRepository.cleanRetained(topic);\n+      return;\n     }\n+    retainedRepository.retain(topic, msg);\n+  }\n }\n",
            "diff_size": 297
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "28",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 168).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "44",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 132).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "117",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 127).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "149",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 159).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/45/PostOffice.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/45/PostOffice.java\nindex 5d511e33e8d..9fd62d111b1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/45/PostOffice.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/45/PostOffice.java\n@@ -8,7 +8,6 @@ import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.mqtt.*;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Set;\n@@ -21,14 +20,12 @@ import static io.netty.handler.codec.mqtt.MqttQoS.*;\n class PostOffice {\n \n     private static final Logger LOG = LoggerFactory.getLogger(PostOffice.class);\n-\n     private final Authorizator authorizator;\n     private final ISubscriptionsDirectory subscriptions;\n     private final IRetainedRepository retainedRepository;\n     private SessionRegistry sessionRegistry;\n \n-    PostOffice(ISubscriptionsDirectory subscriptions, IAuthorizatorPolicy authorizatorPolicy,\n-               IRetainedRepository retainedRepository, SessionRegistry sessionRegistry) {\n+    PostOffice(ISubscriptionsDirectory subscriptions, IAuthorizatorPolicy authorizatorPolicy, IRetainedRepository retainedRepository, SessionRegistry sessionRegistry) {\n         this.authorizator = new Authorizator(authorizatorPolicy);\n         this.subscriptions = subscriptions;\n         this.retainedRepository = retainedRepository;\n@@ -44,32 +41,30 @@ class PostOffice {\n         publish2Subscribers(will.payload, new Topic(will.topic), will.qos);\n     }\n \n-    public void subscribeClientToTopics(MqttSubscribeMessage msg, String clientID, String username,\n-                                        MQTTConnection mqttConnection) {\n+    public void subscribeClientToTopics(MqttSubscribeMessage msg, String clientID, String username, MQTTConnection mqttConnection) {\n         // verify which topics of the subscribe ongoing has read access permission\n         int messageID = messageId(msg);\n         List<MqttTopicSubscription> ackTopics = authorizator.verifyTopicsReadAccess(clientID, username, msg);\n         MqttSubAckMessage ackMessage = doAckMessageFromValidateFilters(ackTopics, messageID);\n \n         // store topics subscriptions in session\n-        List<Subscription> newSubscriptions = ackTopics.stream()\n-            .filter(req -> req.qualityOfService() != FAILURE)\n-            .map(req -> {\n-                final Topic topic = new Topic(req.topicName());\n-                return new Subscription(clientID, topic, req.qualityOfService());\n-            }).collect(Collectors.toList());\n-\n+        List<Subscription> newSubscriptions = ackTopics.stream().filter(req -> req.qualityOfService() != FAILURE)\n+.map(req -> {\n+   final Topic topic = new Topic(req.topicName());\n+   return new Subscription(clientID, topic, req.qualityOfService());\n+})\n+.collect(Collectors.toList());\n         for (Subscription subscription : newSubscriptions) {\n             subscriptions.add(subscription);\n         }\n \n         // add the subscriptions to Session\n+\n         Session session = sessionRegistry.retrieve(clientID);\n         session.addSubscriptions(newSubscriptions);\n \n         // send ack message\n         mqttConnection.sendSubAckMessage(messageID, ackMessage);\n-\n         publishRetainedMessagesForSubscriptions(clientID, newSubscriptions);\n \n         // TODO notify the Observables\n@@ -83,15 +78,13 @@ class PostOffice {\n         for (Subscription subscription : newSubscriptions) {\n             final String topicFilter = subscription.getTopicFilter().toString();\n             final MqttPublishMessage retainedMsg = retainedRepository.retainedOnTopic(topicFilter);\n-\n             if (retainedMsg == null) {\n                 // not found\n+\n                 continue;\n             }\n-\n             final MqttQoS retainedQos = retainedMsg.fixedHeader().qosLevel();\n             MqttQoS qos = lowerQosToTheSubscriptionDesired(subscription, retainedQos);\n-\n             final ByteBuf origPayload = retainedMsg.payload();\n             ByteBuf payload = origPayload.retainedDuplicate();\n             targetSession.sendRetainedPublishOnSessionAtQos(subscription.getTopicFilter(), qos, payload);\n@@ -101,14 +94,14 @@ class PostOffice {\n     /**\n      * Create the SUBACK response from a list of topicFilters\n      */\n+\n     private MqttSubAckMessage doAckMessageFromValidateFilters(List<MqttTopicSubscription> topicFilters, int messageId) {\n         List<Integer> grantedQoSLevels = new ArrayList<>();\n         for (MqttTopicSubscription req : topicFilters) {\n             grantedQoSLevels.add(req.qualityOfService().value());\n         }\n \n-        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, AT_MOST_ONCE,\n-            false, 0);\n+        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBACK, false, AT_MOST_ONCE, false, 0);\n         MqttSubAckPayload payload = new MqttSubAckPayload(grantedQoSLevels);\n         return new MqttSubAckMessage(fixedHeader, from(messageId), payload);\n     }\n@@ -121,11 +114,9 @@ class PostOffice {\n             if (!validTopic) {\n                 // close the connection, not valid topicFilter is a protocol violation\n                 mqttConnection.dropConnection();\n-                LOG.warn(\"Topic filter is not valid. CId={}, topics: {}, offending topic filter: {}\", clientID,\n-                         topics, topic);\n+                LOG.warn(\"Topic filter is not valid. CId={}, topics: {}, offending topic filter: {}\", clientID, topics, topic);\n                 return;\n             }\n-\n             LOG.trace(\"Removing subscription. CId={}, topic={}\", clientID, topic);\n             subscriptions.removeSubscription(topic, clientID);\n \n@@ -147,7 +138,6 @@ class PostOffice {\n             return;\n         }\n         publish2Subscribers(payload, topic, AT_MOST_ONCE);\n-\n         if (retain) {\n             // QoS == 0 && retain => clean old retained\n             retainedRepository.cleanRetained(topic);\n@@ -156,8 +146,7 @@ class PostOffice {\n //        m_interceptor.notifyTopicPublished(msg, clientID, username);\n     }\n \n-    void receivedPublishQos1(MQTTConnection connection, Topic topic, String username, ByteBuf payload, int messageID,\n-                             boolean retain, MqttPublishMessage msg) {\n+    void receivedPublishQos1(MQTTConnection connection, Topic topic, String username, ByteBuf payload, int messageID, boolean retain, MqttPublishMessage msg) {\n         // verify if topic can be write\n         topic.getTokens();\n         if (!topic.isValid()) {\n@@ -170,11 +159,8 @@ class PostOffice {\n             LOG.error(\"MQTT client is not authorized to publish on topic. CId={}, topic: {}\", clientId, topic);\n             return;\n         }\n-\n         publish2Subscribers(payload, topic, AT_LEAST_ONCE);\n-\n         connection.sendPubAck(messageID);\n-\n         if (retain) {\n             if (!payload.isReadable()) {\n                 retainedRepository.cleanRetained(topic);\n@@ -189,23 +175,25 @@ class PostOffice {\n \n     private void publish2Subscribers(ByteBuf origPayload, Topic topic, MqttQoS publishingQos) {\n         Set<Subscription> topicMatchingSubscriptions = subscriptions.matchQosSharpening(topic);\n-\n         for (final Subscription sub : topicMatchingSubscriptions) {\n             MqttQoS qos = lowerQosToTheSubscriptionDesired(sub, publishingQos);\n             Session targetSession = this.sessionRegistry.retrieve(sub.getClientId());\n-\n             boolean isSessionPresent = targetSession != null;\n             if (isSessionPresent) {\n                 LOG.debug(\"Sending PUBLISH message to active subscriber CId: {}, topicFilter: {}, qos: {}\",\n-                          sub.getClientId(), sub.getTopicFilter(), qos);\n+                    sub.getClientId(),\n+                    sub.getTopicFilter(),\n+                    qos);\n                 // we need to retain because duplicate only copy r/w indexes and don't retain() causing refCnt = 0\n                 ByteBuf payload = origPayload.retainedDuplicate();\n                 targetSession.sendPublishOnSessionAtQos(topic, qos, payload);\n             } else {\n                 // If we are, the subscriber disconnected after the subscriptions tree selected that session as a\n                 // destination.\n-                LOG.debug(\"PUBLISH to not yet present session. CId: {}, topicFilter: {}, qos: {}\", sub.getClientId(),\n-                          sub.getTopicFilter(), qos);\n+                LOG.debug(\"PUBLISH to not yet present session. CId: {}, topicFilter: {}, qos: {}\",\n+                    sub.getClientId(),\n+                    sub.getTopicFilter(),\n+                    qos);\n             }\n         }\n     }\n@@ -214,12 +202,12 @@ class PostOffice {\n      * First phase of a publish QoS2 protocol, sent by publisher to the broker. Publish to all interested\n      * subscribers.\n      */\n+\n     void receivedPublishQos2(MQTTConnection connection, MqttPublishMessage mqttPublishMessage) {\n         LOG.trace(\"Processing PUBREL message on connection: {}\", connection);\n         final Topic topic = new Topic(mqttPublishMessage.variableHeader().topicName());\n         final ByteBuf payload = mqttPublishMessage.payload();\n         publish2Subscribers(payload, topic, EXACTLY_ONCE);\n-\n         final boolean retained = mqttPublishMessage.fixedHeader().isRetain();\n         if (retained) {\n             if (!payload.isReadable()) {\n@@ -253,17 +241,17 @@ class PostOffice {\n      * @param clientId\n      *            the clientID\n      */\n+\n     public void internalPublish(MqttPublishMessage msg, final String clientId) {\n         final MqttQoS qos = msg.fixedHeader().qosLevel();\n         final Topic topic = new Topic(msg.variableHeader().topicName());\n         final ByteBuf payload = msg.payload();\n         LOG.info(\"Sending internal PUBLISH message Topic={}, qos={}\", topic, qos);\n-\n         publish2Subscribers(payload, topic, qos);\n-\n         if (!msg.fixedHeader().isRetain()) {\n             return;\n         }\n+\n         if (qos == AT_MOST_ONCE || msg.payload().readableBytes() == 0) {\n             // QoS == 0 && retain => clean old retained\n             retainedRepository.cleanRetained(topic);\n@@ -271,4 +259,4 @@ class PostOffice {\n         }\n         retainedRepository.retain(topic, msg);\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 47
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "warning",
                    "message": "missing copyright header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}