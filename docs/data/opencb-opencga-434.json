{
    "project_name": "opencb-opencga",
    "error_id": "434",
    "information": {
        "errors": [
            {
                "line": "340",
                "severity": "error",
                "message": "Line is longer than 140 characters (found 141).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                        }\n                    }\n                    list.add(new QueryBuilder().and(key).regex(Pattern.compile(\"^\" + clinicalSignificance, Pattern.CASE_INSENSITIVE)).get());\n                }\n                if (QueryOperation.OR.equals(pair.getKey())) {\n                    builder.or(list.toArray(new DBObject[0]));",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/434/VariantMongoDBQueryParser.java\nindex 7db5eca5f18..e5a3e03b8bf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/434/VariantMongoDBQueryParser.java\n@@ -337,9 +337,12 @@ public class VariantMongoDBQueryParser {\n                             }\n                         }\n                     }\n-                    list.add(new QueryBuilder().and(key).regex(Pattern.compile(\"^\" + clinicalSignificance, Pattern.CASE_INSENSITIVE)).get());\n-                }\n-                if (QueryOperation.OR.equals(pair.getKey())) {\n+                    list.add(new\n+                    QueryBuilder()\n+                    .\n+                    and(key).regex(Pattern.compile(\"^\" + clinicalSignificance, Pattern.CASE_INSENSITIVE)).get());\n+                 }\n+                 if (QueryOperation.OR.equals(pair.getKey())) {\n                     builder.or(list.toArray(new DBObject[0]));\n                 } else {\n                     builder.and(list.toArray(new DBObject[0]));\n",
            "diff_size": 6
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/434/VariantMongoDBQueryParser.java\nindex 7db5eca5f18..2e97486f3e1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/434/VariantMongoDBQueryParser.java\n@@ -65,297 +65,297 @@ import static org.opencb.opencga.storage.mongodb.variant.converters.DocumentToVa\n  */\n public class VariantMongoDBQueryParser {\n \n-    public static final String OVERLAPPED_FILES_ONLY = \"overlappedFilesOnly\";\n-    public static final VariantStringIdConverter STRING_ID_CONVERTER = new VariantStringIdConverter();\n-    protected static Logger logger = LoggerFactory.getLogger(VariantMongoDBQueryParser.class);\n-    private final VariantStorageMetadataManager metadataManager;\n-    //    private final CellBaseUtils cellBaseUtils;\n-\n-    public VariantMongoDBQueryParser(VariantStorageMetadataManager variantStorageMetadataManager) {\n-        this.metadataManager = variantStorageMetadataManager;\n-\n-    }\n-\n-    protected Document parseQuery(final Query originalQuery) {\n-        QueryBuilder builder = new QueryBuilder();\n-        if (originalQuery != null) {\n-            // Copy given query. It may be modified\n-            Query query = new Query(originalQuery);\n-            boolean nonGeneRegionFilter = false;\n-            /* VARIANT PARAMS */\n-\n-            if (isValidParam(query, REGION)) {\n-                nonGeneRegionFilter = true;\n-                List<Region> regions = Region.parseRegions(query.getString(REGION.key()), true);\n-                if (!regions.isEmpty()) {\n-                    getRegionFilter(regions, builder);\n-                }\n-            }\n-\n-            // Object with all VariantIds, ids, genes and xrefs from ID, XREF, GENES, ... filters\n-            VariantQueryParser.VariantQueryXref variantQueryXref = VariantQueryParser.parseXrefs(query);\n-\n-            if (!variantQueryXref.getIds().isEmpty()) {\n-                addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD,\n-                        variantQueryXref.getIds(), builder, QueryOperation.OR);\n-                addQueryStringFilter(DocumentToVariantConverter.IDS_FIELD, variantQueryXref.getIds(), builder, QueryOperation.OR);\n-            }\n-\n-            if (!variantQueryXref.getOtherXrefs().isEmpty()) {\n-                nonGeneRegionFilter = true;\n-                addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                                + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n-                                + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD,\n-                        variantQueryXref.getOtherXrefs(), builder, QueryOperation.OR);\n-            }\n-\n-            if (!variantQueryXref.getVariants().isEmpty()) {\n-                nonGeneRegionFilter = true;\n-                List<String> mongoIds = new ArrayList<>(variantQueryXref.getVariants().size());\n-                for (Variant variant : variantQueryXref.getVariants()) {\n-                    mongoIds.add(STRING_ID_CONVERTER.buildId(variant));\n-                }\n-                if (mongoIds.size() == 1) {\n-                    builder.or(new QueryBuilder().and(\"_id\").is(mongoIds.get(0)).get());\n-                } else {\n-                    builder.or(new QueryBuilder().and(\"_id\").in(mongoIds).get());\n-                }\n-            }\n-\n-            if (!variantQueryXref.getGenes().isEmpty()) {\n-                if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE)) {\n-                    List<String> soList = query.getAsStringList(ANNOT_CONSEQUENCE_TYPE.key());\n-                    Set<String> gnSo = new HashSet<>(variantQueryXref.getGenes().size() * soList.size());\n-                    for (String gene : variantQueryXref.getGenes()) {\n-                        for (String so : soList) {\n-                            int soNumber = parseConsequenceType(so);\n-                            gnSo.add(DocumentToVariantAnnotationConverter.buildGeneSO(gene, soNumber));\n-                        }\n-                    }\n-                    builder.or(new BasicDBObject(DocumentToVariantConverter.ANNOTATION_FIELD\n-                            + '.' + DocumentToVariantAnnotationConverter.GENE_SO_FIELD, new BasicDBObject(\"$in\", gnSo)));\n-                    if (!nonGeneRegionFilter) {\n-                        // Filter already present in the GENE_SO_FIELD\n-                        query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n-                    }\n-                } else {\n-                    addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                                    + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n-                                    + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD,\n-                            variantQueryXref.getGenes(), builder, QueryOperation.OR);\n-                }\n-            }\n+  public static final String OVERLAPPED_FILES_ONLY = \"overlappedFilesOnly\";\n+  public static final VariantStringIdConverter STRING_ID_CONVERTER = new VariantStringIdConverter();\n+  protected static Logger logger = LoggerFactory.getLogger(VariantMongoDBQueryParser.class);\n+  private final VariantStorageMetadataManager metadataManager;\n+  //    private final CellBaseUtils cellBaseUtils;\n+\n+  public VariantMongoDBQueryParser(VariantStorageMetadataManager variantStorageMetadataManager) {\n+    this.metadataManager = variantStorageMetadataManager;\n+\n+  }\n+\n+  protected Document parseQuery(final Query originalQuery) {\n+    QueryBuilder builder = new QueryBuilder();\n+    if (originalQuery != null) {\n+      // Copy given query. It may be modified\n+      Query query = new Query(originalQuery);\n+      boolean nonGeneRegionFilter = false;\n+      /* VARIANT PARAMS */\n+\n+      if (isValidParam(query, REGION)) {\n+        nonGeneRegionFilter = true;\n+        List<Region> regions = Region.parseRegions(query.getString(REGION.key()), true);\n+        if (!regions.isEmpty()) {\n+          getRegionFilter(regions, builder);\n+        }\n+      }\n+\n+      // Object with all VariantIds, ids, genes and xrefs from ID, XREF, GENES, ... filters\n+      VariantQueryParser.VariantQueryXref variantQueryXref = VariantQueryParser.parseXrefs(query);\n+\n+      if (!variantQueryXref.getIds().isEmpty()) {\n+        addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+                + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n+                + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD,\n+            variantQueryXref.getIds(), builder, QueryOperation.OR);\n+        addQueryStringFilter(DocumentToVariantConverter.IDS_FIELD, variantQueryXref.getIds(), builder, QueryOperation.OR);\n+      }\n+\n+      if (!variantQueryXref.getOtherXrefs().isEmpty()) {\n+        nonGeneRegionFilter = true;\n+        addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+                + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n+                + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD,\n+            variantQueryXref.getOtherXrefs(), builder, QueryOperation.OR);\n+      }\n+\n+      if (!variantQueryXref.getVariants().isEmpty()) {\n+        nonGeneRegionFilter = true;\n+        List<String> mongoIds = new ArrayList<>(variantQueryXref.getVariants().size());\n+        for (Variant variant : variantQueryXref.getVariants()) {\n+          mongoIds.add(STRING_ID_CONVERTER.buildId(variant));\n+        }\n+        if (mongoIds.size() == 1) {\n+          builder.or(new QueryBuilder().and(\"_id\").is(mongoIds.get(0)).get());\n+        } else {\n+          builder.or(new QueryBuilder().and(\"_id\").in(mongoIds).get());\n+        }\n+      }\n+\n+      if (!variantQueryXref.getGenes().isEmpty()) {\n+        if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE)) {\n+          List<String> soList = query.getAsStringList(ANNOT_CONSEQUENCE_TYPE.key());\n+          Set<String> gnSo = new HashSet<>(variantQueryXref.getGenes().size() * soList.size());\n+          for (String gene : variantQueryXref.getGenes()) {\n+            for (String so : soList) {\n+              int soNumber = parseConsequenceType(so);\n+              gnSo.add(DocumentToVariantAnnotationConverter.buildGeneSO(gene, soNumber));\n+            }\n+          }\n+          builder.or(new BasicDBObject(DocumentToVariantConverter.ANNOTATION_FIELD\n+              + '.' + DocumentToVariantAnnotationConverter.GENE_SO_FIELD, new BasicDBObject(\"$in\", gnSo)));\n+          if (!nonGeneRegionFilter) {\n+            // Filter already present in the GENE_SO_FIELD\n+            query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n+          }\n+        } else {\n+          addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+                  + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n+                  + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD,\n+              variantQueryXref.getGenes(), builder, QueryOperation.OR);\n+        }\n+      }\n \n-            if (isValidParam(query, REFERENCE)) {\n-                addQueryStringFilter(DocumentToVariantConverter.REFERENCE_FIELD, query.getString(REFERENCE.key()),\n-                        builder, QueryOperation.AND);\n-            }\n+      if (isValidParam(query, REFERENCE)) {\n+        addQueryStringFilter(DocumentToVariantConverter.REFERENCE_FIELD, query.getString(REFERENCE.key()),\n+            builder, QueryOperation.AND);\n+      }\n \n-            if (isValidParam(query, ALTERNATE)) {\n-                addQueryStringFilter(DocumentToVariantConverter.ALTERNATE_FIELD, query.getString(ALTERNATE.key()),\n-                        builder, QueryOperation.AND);\n-            }\n+      if (isValidParam(query, ALTERNATE)) {\n+        addQueryStringFilter(DocumentToVariantConverter.ALTERNATE_FIELD, query.getString(ALTERNATE.key()),\n+            builder, QueryOperation.AND);\n+      }\n \n-            if (isValidParam(query, TYPE)) {\n-                addQueryFilter(DocumentToVariantConverter.TYPE_FIELD, query.getAsStringList(TYPE.key()), builder,\n-                        QueryOperation.AND); //addQueryStringFilter(DBObjectToVariantConverter.TYPE_FIELD,\n+      if (isValidParam(query, TYPE)) {\n+        addQueryFilter(DocumentToVariantConverter.TYPE_FIELD, query.getAsStringList(TYPE.key()), builder,\n+            QueryOperation.AND); //addQueryStringFilter(DBObjectToVariantConverter.TYPE_FIELD,\n //                query.getString(VariantQueryParams.TYPE.key()), builder, QueryOperation.AND);\n-            }\n-\n-            if (isValidParam(query, RELEASE)) {\n-                int release = query.getInt(RELEASE.key(), -1);\n-                if (release <= 0) {\n-                    throw VariantQueryException.malformedParam(RELEASE, query.getString(RELEASE.key()));\n-                }\n-\n-                builder.and(DocumentToVariantConverter.RELEASE_FIELD).lessThanEquals(release);\n-            }\n-\n-            /* ANNOTATION PARAMS */\n-            QueryBuilder annotationQueryBuilder = new QueryBuilder();\n-            parseAnnotationQueryParams(query, annotationQueryBuilder);\n-            DBObject annotationQuery = annotationQueryBuilder.get();\n-            if (!annotationQuery.keySet().isEmpty()) {\n-                builder.and(annotationQuery);\n-            }\n-\n-            /* STUDIES */\n-            QueryBuilder studyQueryBuilder = new QueryBuilder();\n-            final StudyMetadata defaultStudy = parseStudyQueryParams(query, studyQueryBuilder);\n-\n-            /* STATS PARAMS */\n-            parseStatsQueryParams(query, studyQueryBuilder, defaultStudy);\n-            if (builder.get().keySet().isEmpty()) {\n-                builder = studyQueryBuilder;\n-            } else {\n-                builder.and(studyQueryBuilder.get());\n-            }\n+      }\n \n+      if (isValidParam(query, RELEASE)) {\n+        int release = query.getInt(RELEASE.key(), -1);\n+        if (release <= 0) {\n+          throw VariantQueryException.malformedParam(RELEASE, query.getString(RELEASE.key()));\n         }\n \n-        logger.debug(\"----------------------\");\n-        logger.debug(\"Query         = {}\", VariantQueryUtils.printQuery(originalQuery));\n-        Document mongoQuery = new Document(builder.get().toMap());\n-        logger.debug(\"MongoDB Query = {}\", mongoQuery.toJson(new JsonWriterSettings(JsonMode.SHELL, false)));\n-        return mongoQuery;\n-    }\n-\n-    private void parseAnnotationQueryParams(Query query, QueryBuilder builder) {\n-        if (query != null) {\n-            if (isValidParam(query, ANNOTATION_EXISTS)) {\n-                boolean exists = query.getBoolean(ANNOTATION_EXISTS.key());\n-                builder.and(DocumentToVariantConverter.ANNOTATION_FIELD + \".\" + DocumentToVariantAnnotationConverter.ANNOT_ID_FIELD);\n-                builder.exists(exists);\n-                if (!exists) {\n-                    builder.and(DocumentToVariantConverter.ANNOTATION_FIELD\n-                            + '.' + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n-                            + '.' + DocumentToVariantAnnotationConverter.CT_SO_ACCESSION_FIELD)\n-                            .exists(false);\n-                }\n-                // else , should be combined with an or, and it would not speed up the filtering. This scenario is not so common\n-            }\n-\n-            if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE)) {\n-                String value = query.getString(ANNOT_CONSEQUENCE_TYPE.key());\n-                addQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                                + '.' + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n-                                + '.' + DocumentToVariantAnnotationConverter.CT_SO_ACCESSION_FIELD, value, builder, QueryOperation.AND,\n-                        VariantQueryUtils::parseConsequenceType);\n-            }\n+        builder.and(DocumentToVariantConverter.RELEASE_FIELD).lessThanEquals(release);\n+      }\n+\n+      /* ANNOTATION PARAMS */\n+      QueryBuilder annotationQueryBuilder = new QueryBuilder();\n+      parseAnnotationQueryParams(query, annotationQueryBuilder);\n+      DBObject annotationQuery = annotationQueryBuilder.get();\n+      if (!annotationQuery.keySet().isEmpty()) {\n+        builder.and(annotationQuery);\n+      }\n+\n+      /* STUDIES */\n+      QueryBuilder studyQueryBuilder = new QueryBuilder();\n+      final StudyMetadata defaultStudy = parseStudyQueryParams(query, studyQueryBuilder);\n+\n+      /* STATS PARAMS */\n+      parseStatsQueryParams(query, studyQueryBuilder, defaultStudy);\n+      if (builder.get().keySet().isEmpty()) {\n+        builder = studyQueryBuilder;\n+      } else {\n+        builder.and(studyQueryBuilder.get());\n+      }\n \n-            if (isValidParam(query, ANNOT_BIOTYPE)) {\n-                String biotypes = query.getString(ANNOT_BIOTYPE.key());\n-                addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                        + \".\" + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n-                        + \".\" + DocumentToVariantAnnotationConverter.CT_BIOTYPE_FIELD, biotypes, builder, QueryOperation.AND);\n-            }\n+    }\n \n-            if (isValidParam(query, ANNOT_POLYPHEN)) {\n-                String value = query.getString(ANNOT_POLYPHEN.key());\n+    logger.debug(\"----------------------\");\n+    logger.debug(\"Query         = {}\", VariantQueryUtils.printQuery(originalQuery));\n+    Document mongoQuery = new Document(builder.get().toMap());\n+    logger.debug(\"MongoDB Query = {}\", mongoQuery.toJson(new JsonWriterSettings(JsonMode.SHELL, false)));\n+    return mongoQuery;\n+  }\n+\n+  private void parseAnnotationQueryParams(Query query, QueryBuilder builder) {\n+    if (query != null) {\n+      if (isValidParam(query, ANNOTATION_EXISTS)) {\n+        boolean exists = query.getBoolean(ANNOTATION_EXISTS.key());\n+        builder.and(DocumentToVariantConverter.ANNOTATION_FIELD + \".\" + DocumentToVariantAnnotationConverter.ANNOT_ID_FIELD);\n+        builder.exists(exists);\n+        if (!exists) {\n+          builder.and(DocumentToVariantConverter.ANNOTATION_FIELD\n+              + '.' + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n+              + '.' + DocumentToVariantAnnotationConverter.CT_SO_ACCESSION_FIELD)\n+              .exists(false);\n+        }\n+        // else , should be combined with an or, and it would not speed up the filtering. This scenario is not so common\n+      }\n+\n+      if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE)) {\n+        String value = query.getString(ANNOT_CONSEQUENCE_TYPE.key());\n+        addQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+                + '.' + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n+                + '.' + DocumentToVariantAnnotationConverter.CT_SO_ACCESSION_FIELD, value, builder, QueryOperation.AND,\n+            VariantQueryUtils::parseConsequenceType);\n+      }\n+\n+      if (isValidParam(query, ANNOT_BIOTYPE)) {\n+        String biotypes = query.getString(ANNOT_BIOTYPE.key());\n+        addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+            + \".\" + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n+            + \".\" + DocumentToVariantAnnotationConverter.CT_BIOTYPE_FIELD, biotypes, builder, QueryOperation.AND);\n+      }\n+\n+      if (isValidParam(query, ANNOT_POLYPHEN)) {\n+        String value = query.getString(ANNOT_POLYPHEN.key());\n //                addCompListQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n //                                + \".\" + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n //                                + \".\" + DocumentToVariantAnnotationConverter.CT_PROTEIN_POLYPHEN_FIELD\n //                                + \".\" + DocumentToVariantAnnotationConverter.SCORE_SCORE_FIELD,\n //                        value, builder);\n-                addScoreFilter(value, builder, ANNOT_POLYPHEN, DocumentToVariantAnnotationConverter.POLYPHEN, true);\n-            }\n+        addScoreFilter(value, builder, ANNOT_POLYPHEN, DocumentToVariantAnnotationConverter.POLYPHEN, true);\n+      }\n \n-            if (isValidParam(query, ANNOT_SIFT)) {\n-                String value = query.getString(ANNOT_SIFT.key());\n+      if (isValidParam(query, ANNOT_SIFT)) {\n+        String value = query.getString(ANNOT_SIFT.key());\n //                addCompListQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n //                        + \".\" + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n //                        + \".\" + DocumentToVariantAnnotationConverter.CT_PROTEIN_SIFT_FIELD + \".\"\n //                        + DocumentToVariantAnnotationConverter.SCORE_SCORE_FIELD, value, builder);\n-                addScoreFilter(value, builder, ANNOT_SIFT, DocumentToVariantAnnotationConverter.SIFT, true);\n-            }\n-\n-            if (isValidParam(query, ANNOT_PROTEIN_SUBSTITUTION)) {\n-                String value = query.getString(ANNOT_PROTEIN_SUBSTITUTION.key());\n-                addScoreFilter(value, builder, ANNOT_PROTEIN_SUBSTITUTION, true);\n-            }\n-\n-            if (isValidParam(query, ANNOT_CONSERVATION)) {\n-                String value = query.getString(ANNOT_CONSERVATION.key());\n-                addScoreFilter(value, builder, ANNOT_CONSERVATION, false);\n-            }\n-\n-            if (isValidParam(query, ANNOT_TRANSCRIPT_FLAG)) {\n-                String value = query.getString(ANNOT_TRANSCRIPT_FLAG.key());\n-                addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                        + \".\" + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n-                        + \".\" + DocumentToVariantAnnotationConverter.CT_TRANSCRIPT_ANNOT_FLAGS, value, builder, QueryOperation.AND);\n-            }\n-\n-            if (isValidParam(query, ANNOT_GENE_TRAIT_ID)) {\n-                String value = query.getString(ANNOT_GENE_TRAIT_ID.key());\n-                QueryOperation internalOp = checkOperator(value);\n-                List<String> values = splitValue(value, internalOp);\n-                QueryBuilder geneTraitBuilder;\n-                if (internalOp == QueryOperation.OR) {\n-                    geneTraitBuilder = QueryBuilder.start();\n-                } else {\n-                    geneTraitBuilder = builder;\n-                }\n+        addScoreFilter(value, builder, ANNOT_SIFT, DocumentToVariantAnnotationConverter.SIFT, true);\n+      }\n+\n+      if (isValidParam(query, ANNOT_PROTEIN_SUBSTITUTION)) {\n+        String value = query.getString(ANNOT_PROTEIN_SUBSTITUTION.key());\n+        addScoreFilter(value, builder, ANNOT_PROTEIN_SUBSTITUTION, true);\n+      }\n+\n+      if (isValidParam(query, ANNOT_CONSERVATION)) {\n+        String value = query.getString(ANNOT_CONSERVATION.key());\n+        addScoreFilter(value, builder, ANNOT_CONSERVATION, false);\n+      }\n+\n+      if (isValidParam(query, ANNOT_TRANSCRIPT_FLAG)) {\n+        String value = query.getString(ANNOT_TRANSCRIPT_FLAG.key());\n+        addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+            + \".\" + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n+            + \".\" + DocumentToVariantAnnotationConverter.CT_TRANSCRIPT_ANNOT_FLAGS, value, builder, QueryOperation.AND);\n+      }\n+\n+      if (isValidParam(query, ANNOT_GENE_TRAIT_ID)) {\n+        String value = query.getString(ANNOT_GENE_TRAIT_ID.key());\n+        QueryOperation internalOp = checkOperator(value);\n+        List<String> values = splitValue(value, internalOp);\n+        QueryBuilder geneTraitBuilder;\n+        if (internalOp == QueryOperation.OR) {\n+          geneTraitBuilder = QueryBuilder.start();\n+        } else {\n+          geneTraitBuilder = builder;\n+        }\n \n \n-                List<String> geneTraitId = new LinkedList<>();\n-                List<String> hpo = new LinkedList<>();\n-                for (String v : values) {\n-                    if (isHpo(v)) {\n-                        hpo.add(v);\n-                    } else {\n-                        geneTraitId.add(v);\n-                    }\n-                }\n+        List<String> geneTraitId = new LinkedList<>();\n+        List<String> hpo = new LinkedList<>();\n+        for (String v : values) {\n+          if (isHpo(v)) {\n+            hpo.add(v);\n+          } else {\n+            geneTraitId.add(v);\n+          }\n+        }\n \n-                if (!geneTraitId.isEmpty()) {\n-                    addQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                                    + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_FIELD\n-                                    + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_ID_FIELD, geneTraitId, geneTraitBuilder,\n-                            internalOp, internalOp, Object::toString);\n-                }\n+        if (!geneTraitId.isEmpty()) {\n+          addQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+                  + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_FIELD\n+                  + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_ID_FIELD, geneTraitId, geneTraitBuilder,\n+              internalOp, internalOp, Object::toString);\n+        }\n \n-                if (!hpo.isEmpty()) {\n-                    addQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                                    + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n-                                    + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD, hpo, geneTraitBuilder,\n-                            internalOp, internalOp, Object::toString);\n-                }\n+        if (!hpo.isEmpty()) {\n+          addQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+                  + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n+                  + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD, hpo, geneTraitBuilder,\n+              internalOp, internalOp, Object::toString);\n+        }\n \n-                if (internalOp == QueryOperation.OR) {\n-                    builder.and(geneTraitBuilder.get());\n-                }\n-            }\n+        if (internalOp == QueryOperation.OR) {\n+          builder.and(geneTraitBuilder.get());\n+        }\n+      }\n \n-            if (isValidParam(query, ANNOT_GENE_TRAIT_NAME)) {\n-                String value = query.getString(ANNOT_GENE_TRAIT_NAME.key());\n+      if (isValidParam(query, ANNOT_GENE_TRAIT_NAME)) {\n+        String value = query.getString(ANNOT_GENE_TRAIT_NAME.key());\n //                addCompQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n //                        + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_FIELD\n //                        + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_NAME_FIELD, value, builder, false);\n-                addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_NAME_FIELD, value, builder, QueryOperation.AND);\n+        addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+            + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_FIELD\n+            + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_NAME_FIELD, value, builder, QueryOperation.AND);\n+      }\n+\n+      if (isValidParam(query, ANNOT_CLINICAL_SIGNIFICANCE)) {\n+        String value = query.getString(ANNOT_CLINICAL_SIGNIFICANCE.key());\n+        String key = DocumentToVariantConverter.ANNOTATION_FIELD\n+            + '.' + DocumentToVariantAnnotationConverter.CLINICAL_DATA_FIELD\n+            + '.' + DocumentToVariantAnnotationConverter.CLINICAL_CLINVAR_FIELD\n+            + '.' + \"clinicalSignificance\";\n+        Pair<QueryOperation, List<String>> pair = splitValue(value);\n+        List<DBObject> list = new ArrayList<>(pair.getValue().size());\n+        for (String clinicalSignificance : pair.getValue()) {\n+          ClinicalSignificance enumValue = EnumUtils.getEnum(ClinicalSignificance.class, clinicalSignificance);\n+          if (enumValue != null) {\n+            for (Map.Entry<String, ClinicalSignificance> entry : VariantAnnotationUtils.CLINVAR_CLINSIG_TO_ACMG.entrySet()) {\n+              if (entry.getValue() == enumValue) {\n+                clinicalSignificance = entry.getKey();\n+                break;\n+              }\n             }\n+          }\n+          list.add(new QueryBuilder().and(key).regex(Pattern.compile(\"^\" + clinicalSignificance, Pattern.CASE_INSENSITIVE)).get());\n+        }\n+        if (QueryOperation.OR.equals(pair.getKey())) {\n+          builder.or(list.toArray(new DBObject[0]));\n+        } else {\n+          builder.and(list.toArray(new DBObject[0]));\n+        }\n \n-            if (isValidParam(query, ANNOT_CLINICAL_SIGNIFICANCE)) {\n-                String value = query.getString(ANNOT_CLINICAL_SIGNIFICANCE.key());\n-                String key = DocumentToVariantConverter.ANNOTATION_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.CLINICAL_DATA_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.CLINICAL_CLINVAR_FIELD\n-                        + '.' + \"clinicalSignificance\";\n-                Pair<QueryOperation, List<String>> pair = splitValue(value);\n-                List<DBObject> list = new ArrayList<>(pair.getValue().size());\n-                for (String clinicalSignificance : pair.getValue()) {\n-                    ClinicalSignificance enumValue = EnumUtils.getEnum(ClinicalSignificance.class, clinicalSignificance);\n-                    if (enumValue != null) {\n-                        for (Map.Entry<String, ClinicalSignificance> entry : VariantAnnotationUtils.CLINVAR_CLINSIG_TO_ACMG.entrySet()) {\n-                            if (entry.getValue() == enumValue) {\n-                                clinicalSignificance = entry.getKey();\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    list.add(new QueryBuilder().and(key).regex(Pattern.compile(\"^\" + clinicalSignificance, Pattern.CASE_INSENSITIVE)).get());\n-                }\n-                if (QueryOperation.OR.equals(pair.getKey())) {\n-                    builder.or(list.toArray(new DBObject[0]));\n-                } else {\n-                    builder.and(list.toArray(new DBObject[0]));\n-                }\n-\n-            }\n+      }\n \n-            if (isValidParam(query, ANNOT_HPO)) {\n-                String value = query.getString(ANNOT_HPO.key());\n+      if (isValidParam(query, ANNOT_HPO)) {\n+        String value = query.getString(ANNOT_HPO.key());\n //                addQueryStringFilter(DocumentToVariantAnnotationConverter.GENE_TRAIT_HPO_FIELD, value, geneTraitBuilder,\n //                        QueryOperation.AND);\n-                addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                                + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n-                                + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD, value, builder,\n-                        QueryOperation.AND);\n-            }\n+        addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+                + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n+                + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD, value, builder,\n+            QueryOperation.AND);\n+      }\n \n //            DBObject geneTraitQuery = geneTraitBuilder.get();\n //            if (geneTraitQuery.keySet().size() != 0) {\n@@ -363,1332 +363,1332 @@ public class VariantMongoDBQueryParser {\n //                        + \".\" + DocumentToVariantAnnotationConverter.GENE_TRAIT_FIELD).elemMatch(geneTraitQuery);\n //            }\n \n-            if (isValidParam(query, ANNOT_GO_GENES)) {\n-                String value = query.getString(ANNOT_GO_GENES.key());\n-\n-                // Check if comma separated of semi colon separated (AND or OR)\n-                QueryOperation queryOperation = checkOperator(value);\n-                // Split by comma or semi colon\n-                List<String> goGenes = splitValue(value, queryOperation);\n-\n-                builder.and(DocumentToVariantConverter.ANNOTATION_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD).in(goGenes);\n-\n-            }\n-\n-            if (isValidParam(query, ANNOT_EXPRESSION_GENES)) {\n-                String value = query.getString(ANNOT_EXPRESSION_GENES.key());\n-\n-                // Check if comma separated of semi colon separated (AND or OR)\n-                QueryOperation queryOperation = checkOperator(value);\n-                // Split by comma or semi colon\n-                List<String> expressionGenes = splitValue(value, queryOperation);\n-\n-                builder.and(DocumentToVariantConverter.ANNOTATION_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n-                        + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD).in(expressionGenes);\n-\n-            }\n-\n-\n-            if (isValidParam(query, ANNOT_PROTEIN_KEYWORD)) {\n-                String value = query.getString(ANNOT_PROTEIN_KEYWORD.key());\n-                addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                        + \".\" + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n-                        + \".\" + DocumentToVariantAnnotationConverter.CT_PROTEIN_KEYWORDS, value, builder, QueryOperation.AND);\n-            }\n-\n-            if (isValidParam(query, ANNOT_DRUG)) {\n-                String value = query.getString(ANNOT_DRUG.key());\n-                addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                        + \".\" + DocumentToVariantAnnotationConverter.DRUG_FIELD\n-                        + \".\" + DocumentToVariantAnnotationConverter.DRUG_NAME_FIELD, value, builder, QueryOperation.AND);\n-            }\n-\n-            if (isValidParam(query, ANNOT_FUNCTIONAL_SCORE)) {\n-                String value = query.getString(ANNOT_FUNCTIONAL_SCORE.key());\n-                addScoreFilter(value, builder, ANNOT_FUNCTIONAL_SCORE, false);\n-            }\n-\n-            if (isValidParam(query, CUSTOM_ANNOTATION)) {\n-                String value = query.getString(CUSTOM_ANNOTATION.key());\n-                addCompListQueryFilter(DocumentToVariantConverter.CUSTOM_ANNOTATION_FIELD, value, builder, true);\n-            }\n-\n-            if (isValidParam(query, ANNOT_POPULATION_ALTERNATE_FREQUENCY)) {\n-                String value = query.getString(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key());\n-                addFrequencyFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                                + \".\" + DocumentToVariantAnnotationConverter.POPULATION_FREQUENCIES_FIELD,\n-                        DocumentToVariantAnnotationConverter.POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD, value, builder,\n-                        ANNOT_POPULATION_ALTERNATE_FREQUENCY, true); // Same\n-                // method addFrequencyFilter is used for reference and allele frequencies. Need to provide the field\n-                // (reference/alternate) where to check the frequency\n-            }\n-\n-            if (isValidParam(query, ANNOT_POPULATION_REFERENCE_FREQUENCY)) {\n-                String value = query.getString(ANNOT_POPULATION_REFERENCE_FREQUENCY.key());\n-                addFrequencyFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n-                                + \".\" + DocumentToVariantAnnotationConverter.POPULATION_FREQUENCIES_FIELD,\n-                        DocumentToVariantAnnotationConverter.POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD, value, builder,\n-                        ANNOT_POPULATION_REFERENCE_FREQUENCY, false); // Same\n-                // method addFrequencyFilter is used for reference and allele frequencies. Need to provide the field\n-                // (reference/alternate) where to check the frequency\n-            }\n-\n-            if (isValidParam(query, ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY)) {\n-                String value = query.getString(ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY.key());\n-                addFrequencyFilter(DocumentToVariantConverter.ANNOTATION_FIELD + \".\"\n-                                + DocumentToVariantAnnotationConverter.POPULATION_FREQUENCIES_FIELD,\n-                        value, builder, ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY, true,\n-                        (v, queryBuilder) -> {\n-                            String[] split = splitOperator(v);\n-                            String op = split[1];\n-                            String obj = split[2];\n-\n-                            double aDouble = Double.parseDouble(obj);\n-                            switch (op) {\n-                                case \"<\":\n-                                    queryBuilder.or(QueryBuilder.start(DocumentToVariantAnnotationConverter.\n-                                                    POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).lessThan(aDouble).get(),\n-                                            QueryBuilder.start(DocumentToVariantAnnotationConverter.\n-                                                    POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).lessThan(aDouble).get()\n-                                    );\n-                                    break;\n-                                case \"<=\":\n-                                    queryBuilder.or(QueryBuilder.start(DocumentToVariantAnnotationConverter.\n-                                                    POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).lessThanEquals(aDouble).get(),\n-                                            QueryBuilder.start(DocumentToVariantAnnotationConverter.\n-                                                    POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).lessThanEquals(aDouble).get()\n-                                    );\n-                                    break;\n-                                case \">\":\n-                                    queryBuilder.and(DocumentToVariantAnnotationConverter.\n-                                            POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).greaterThan(aDouble)\n-                                            .and(DocumentToVariantAnnotationConverter.\n-                                                    POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).greaterThan(aDouble);\n-                                    break;\n-                                case \">=\":\n-                                    queryBuilder.and(DocumentToVariantAnnotationConverter.\n-                                            POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).greaterThanEquals(aDouble)\n-                                            .and(DocumentToVariantAnnotationConverter.\n-                                                    POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).greaterThanEquals(aDouble);\n-                                    break;\n-                                default:\n-                                    throw new IllegalArgumentException(\"Unsupported operator '\" + op + \"'\");\n-                            }\n-                        });\n-            }\n-\n-            if (isValidParam(query, VARIANTS_TO_INDEX)) {\n-                long ts = metadataManager.getProjectMetadata().getAttributes()\n-                        .getLong(SEARCH_INDEX_LAST_TIMESTAMP.key());\n-                if (ts > 0) {\n-                    String key = INDEX_FIELD + '.' + DocumentToVariantConverter.INDEX_TIMESTAMP_FIELD;\n-                    builder.or(\n-                            QueryBuilder.start(key).greaterThan(ts).get(),\n-                            QueryBuilder.start(key).exists(false).get()); // It may not exist from versions <1.4.x\n-                } // Otherwise, get all variants\n-            }\n-        }\n+      if (isValidParam(query, ANNOT_GO_GENES)) {\n+        String value = query.getString(ANNOT_GO_GENES.key());\n+\n+        // Check if comma separated of semi colon separated (AND or OR)\n+        QueryOperation queryOperation = checkOperator(value);\n+        // Split by comma or semi colon\n+        List<String> goGenes = splitValue(value, queryOperation);\n+\n+        builder.and(DocumentToVariantConverter.ANNOTATION_FIELD\n+            + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n+            + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD).in(goGenes);\n+\n+      }\n+\n+      if (isValidParam(query, ANNOT_EXPRESSION_GENES)) {\n+        String value = query.getString(ANNOT_EXPRESSION_GENES.key());\n+\n+        // Check if comma separated of semi colon separated (AND or OR)\n+        QueryOperation queryOperation = checkOperator(value);\n+        // Split by comma or semi colon\n+        List<String> expressionGenes = splitValue(value, queryOperation);\n+\n+        builder.and(DocumentToVariantConverter.ANNOTATION_FIELD\n+            + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n+            + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD).in(expressionGenes);\n+\n+      }\n+\n+\n+      if (isValidParam(query, ANNOT_PROTEIN_KEYWORD)) {\n+        String value = query.getString(ANNOT_PROTEIN_KEYWORD.key());\n+        addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+            + \".\" + DocumentToVariantAnnotationConverter.CONSEQUENCE_TYPE_FIELD\n+            + \".\" + DocumentToVariantAnnotationConverter.CT_PROTEIN_KEYWORDS, value, builder, QueryOperation.AND);\n+      }\n+\n+      if (isValidParam(query, ANNOT_DRUG)) {\n+        String value = query.getString(ANNOT_DRUG.key());\n+        addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+            + \".\" + DocumentToVariantAnnotationConverter.DRUG_FIELD\n+            + \".\" + DocumentToVariantAnnotationConverter.DRUG_NAME_FIELD, value, builder, QueryOperation.AND);\n+      }\n+\n+      if (isValidParam(query, ANNOT_FUNCTIONAL_SCORE)) {\n+        String value = query.getString(ANNOT_FUNCTIONAL_SCORE.key());\n+        addScoreFilter(value, builder, ANNOT_FUNCTIONAL_SCORE, false);\n+      }\n+\n+      if (isValidParam(query, CUSTOM_ANNOTATION)) {\n+        String value = query.getString(CUSTOM_ANNOTATION.key());\n+        addCompListQueryFilter(DocumentToVariantConverter.CUSTOM_ANNOTATION_FIELD, value, builder, true);\n+      }\n+\n+      if (isValidParam(query, ANNOT_POPULATION_ALTERNATE_FREQUENCY)) {\n+        String value = query.getString(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key());\n+        addFrequencyFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+                + \".\" + DocumentToVariantAnnotationConverter.POPULATION_FREQUENCIES_FIELD,\n+            DocumentToVariantAnnotationConverter.POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD, value, builder,\n+            ANNOT_POPULATION_ALTERNATE_FREQUENCY, true); // Same\n+        // method addFrequencyFilter is used for reference and allele frequencies. Need to provide the field\n+        // (reference/alternate) where to check the frequency\n+      }\n+\n+      if (isValidParam(query, ANNOT_POPULATION_REFERENCE_FREQUENCY)) {\n+        String value = query.getString(ANNOT_POPULATION_REFERENCE_FREQUENCY.key());\n+        addFrequencyFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n+                + \".\" + DocumentToVariantAnnotationConverter.POPULATION_FREQUENCIES_FIELD,\n+            DocumentToVariantAnnotationConverter.POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD, value, builder,\n+            ANNOT_POPULATION_REFERENCE_FREQUENCY, false); // Same\n+        // method addFrequencyFilter is used for reference and allele frequencies. Need to provide the field\n+        // (reference/alternate) where to check the frequency\n+      }\n+\n+      if (isValidParam(query, ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY)) {\n+        String value = query.getString(ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY.key());\n+        addFrequencyFilter(DocumentToVariantConverter.ANNOTATION_FIELD + \".\"\n+                + DocumentToVariantAnnotationConverter.POPULATION_FREQUENCIES_FIELD,\n+            value, builder, ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY, true,\n+            (v, queryBuilder) -> {\n+              String[] split = splitOperator(v);\n+              String op = split[1];\n+              String obj = split[2];\n+\n+              double aDouble = Double.parseDouble(obj);\n+              switch (op) {\n+                case \"<\":\n+                  queryBuilder.or(QueryBuilder.start(DocumentToVariantAnnotationConverter.\n+                          POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).lessThan(aDouble).get(),\n+                      QueryBuilder.start(DocumentToVariantAnnotationConverter.\n+                          POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).lessThan(aDouble).get()\n+                  );\n+                  break;\n+                case \"<=\":\n+                  queryBuilder.or(QueryBuilder.start(DocumentToVariantAnnotationConverter.\n+                          POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).lessThanEquals(aDouble).get(),\n+                      QueryBuilder.start(DocumentToVariantAnnotationConverter.\n+                          POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).lessThanEquals(aDouble).get()\n+                  );\n+                  break;\n+                case \">\":\n+                  queryBuilder.and(DocumentToVariantAnnotationConverter.\n+                      POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).greaterThan(aDouble)\n+                      .and(DocumentToVariantAnnotationConverter.\n+                          POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).greaterThan(aDouble);\n+                  break;\n+                case \">=\":\n+                  queryBuilder.and(DocumentToVariantAnnotationConverter.\n+                      POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).greaterThanEquals(aDouble)\n+                      .and(DocumentToVariantAnnotationConverter.\n+                          POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).greaterThanEquals(aDouble);\n+                  break;\n+                default:\n+                  throw new IllegalArgumentException(\"Unsupported operator '\" + op + \"'\");\n+              }\n+            });\n+      }\n+\n+      if (isValidParam(query, VARIANTS_TO_INDEX)) {\n+        long ts = metadataManager.getProjectMetadata().getAttributes()\n+            .getLong(SEARCH_INDEX_LAST_TIMESTAMP.key());\n+        if (ts > 0) {\n+          String key = INDEX_FIELD + '.' + DocumentToVariantConverter.INDEX_TIMESTAMP_FIELD;\n+          builder.or(\n+              QueryBuilder.start(key).greaterThan(ts).get(),\n+              QueryBuilder.start(key).exists(false).get()); // It may not exist from versions <1.4.x\n+        } // Otherwise, get all variants\n+      }\n     }\n+  }\n+\n+  private StudyMetadata parseStudyQueryParams(Query query, QueryBuilder builder) {\n+\n+    if (query != null) {\n+      Map<String, Integer> studies = metadataManager.getStudies(null);\n+\n+      String studyQueryPrefix = DocumentToVariantConverter.STUDIES_FIELD + '.';\n+      final StudyMetadata defaultStudy = getDefaultStudy(query, null, metadataManager);\n+\n+      if (isValidParam(query, STUDY)) {\n+        String value = query.getString(STUDY.key());\n+\n+        addQueryFilter(studyQueryPrefix + DocumentToStudyVariantEntryConverter.STUDYID_FIELD, value,\n+            builder, QueryOperation.AND, study -> metadataManager.getStudyId(study, false, studies));\n+      }\n+\n+      boolean overlappedFilesFiles = query.getBoolean(OVERLAPPED_FILES_ONLY);\n+      List<Integer> fileIds = Collections.emptyList();\n+      List<String> fileNames = Collections.emptyList();\n+      QueryOperation filesOperation = QueryOperation.OR;\n+      if (isValidParam(query, FILE)) {\n+        String filesValue = query.getString(FILE.key());\n+        filesOperation = checkOperator(filesValue);\n+        fileNames = splitValue(filesValue, filesOperation);\n+\n+        fileIds = fileNames\n+            .stream()\n+            .filter(value -> !isNegated(value))\n+            .map(value -> {\n+              Integer fileId = metadataManager.getFileIdPair(value, false, defaultStudy).getValue();\n+              if (fileId == null) {\n+                throw VariantQueryException.fileNotFound(value, defaultStudy.getName());\n+              }\n+              if (overlappedFilesFiles) {\n+                fileId = -fileId;\n+              }\n+              return fileId;\n+            })\n+            .collect(Collectors.toList());\n+      } else if (isValidParam(query, INCLUDE_FILE)) {\n+        List<String> files = getIncludeFilesList(query);\n+        if (files != null) {\n+          fileIds = new ArrayList<>(files.size());\n+          for (String file : files) {\n+            fileIds.add(metadataManager.getFileIdPair(file, false, defaultStudy).getValue());\n+          }\n+        }\n+      }\n \n-    private StudyMetadata parseStudyQueryParams(Query query, QueryBuilder builder) {\n-\n-        if (query != null) {\n-            Map<String, Integer> studies = metadataManager.getStudies(null);\n-\n-            String studyQueryPrefix = DocumentToVariantConverter.STUDIES_FIELD + '.';\n-            final StudyMetadata defaultStudy = getDefaultStudy(query, null, metadataManager);\n-\n-            if (isValidParam(query, STUDY)) {\n-                String value = query.getString(STUDY.key());\n-\n-                addQueryFilter(studyQueryPrefix + DocumentToStudyVariantEntryConverter.STUDYID_FIELD, value,\n-                        builder, QueryOperation.AND, study -> metadataManager.getStudyId(study, false, studies));\n-            }\n-\n-            boolean overlappedFilesFiles = query.getBoolean(OVERLAPPED_FILES_ONLY);\n-            List<Integer> fileIds = Collections.emptyList();\n-            List<String> fileNames = Collections.emptyList();\n-            QueryOperation filesOperation = QueryOperation.OR;\n-            if (isValidParam(query, FILE)) {\n-                String filesValue = query.getString(FILE.key());\n-                filesOperation = checkOperator(filesValue);\n-                fileNames = splitValue(filesValue, filesOperation);\n-\n-                fileIds = fileNames\n-                        .stream()\n-                        .filter(value -> !isNegated(value))\n-                        .map(value -> {\n-                            Integer fileId = metadataManager.getFileIdPair(value, false, defaultStudy).getValue();\n-                            if (fileId == null) {\n-                                throw VariantQueryException.fileNotFound(value, defaultStudy.getName());\n-                            }\n-                            if (overlappedFilesFiles) {\n-                                fileId = -fileId;\n-                            }\n-                            return fileId;\n-                        })\n-                        .collect(Collectors.toList());\n-            } else if (isValidParam(query, INCLUDE_FILE)) {\n-                List<String> files = getIncludeFilesList(query);\n-                if (files != null) {\n-                    fileIds = new ArrayList<>(files.size());\n-                    for (String file : files) {\n-                        fileIds.add(metadataManager.getFileIdPair(file, false, defaultStudy).getValue());\n-                    }\n-                }\n-            }\n-\n-            if (isValidParam(query, FILTER) || isValidParam(query, QUAL) || isValidParam(query, INFO)) {\n-                String filterValue = query.getString(FILTER.key());\n-                QueryOperation filterOperation = checkOperator(filterValue);\n-                List<String> filterValues = splitValue(filterValue, filterOperation);\n-                Pair<QueryOperation, Map<String, String>> infoParamPair = parseInfo(query);\n-                QueryOperation infoOperator = infoParamPair.getKey();\n-                Map<String, String> infoMap = infoParamPair.getValue();\n+      if (isValidParam(query, FILTER) || isValidParam(query, QUAL) || isValidParam(query, INFO)) {\n+        String filterValue = query.getString(FILTER.key());\n+        QueryOperation filterOperation = checkOperator(filterValue);\n+        List<String> filterValues = splitValue(filterValue, filterOperation);\n+        Pair<QueryOperation, Map<String, String>> infoParamPair = parseInfo(query);\n+        QueryOperation infoOperator = infoParamPair.getKey();\n+        Map<String, String> infoMap = infoParamPair.getValue();\n \n \n-                boolean useFileElemMatch = !fileIds.isEmpty();\n-                boolean infoInFileElemMatch = useFileElemMatch && (infoOperator == null || filesOperation == infoOperator);\n+        boolean useFileElemMatch = !fileIds.isEmpty();\n+        boolean infoInFileElemMatch = useFileElemMatch && (infoOperator == null || filesOperation == infoOperator);\n \n //                values = query.getString(QUAL.key());\n //                QueryOperation qualOperation = checkOperator(values);\n //                List<String> qualValues = splitValue(values, qualOperation);\n-                if (!useFileElemMatch) {\n-                    String key = studyQueryPrefix\n-                            + DocumentToStudyVariantEntryConverter.FILES_FIELD + '.'\n-                            + DocumentToStudyVariantEntryConverter.ATTRIBUTES_FIELD + '.';\n-\n-                    if (isValidParam(query, FILTER)) {\n-                        DBObject[] regexList = getFileFilterDBObjects(key + StudyEntry.FILTER, filterValues);\n-                        if (filterOperation == QueryOperation.OR) {\n-                            builder.or(regexList);\n-                        } else {\n-                            builder.and(regexList);\n-                        }\n-                    }\n-                    if (isValidParam(query, QUAL)) {\n-                        addCompListQueryFilter(key + StudyEntry.QUAL, query.getString(QUAL.key()), builder, false);\n-                    }\n-                } else {\n-                    DBObject[] fileElemMatch = new DBObject[fileIds.size()];\n-                    String key = DocumentToStudyVariantEntryConverter.ATTRIBUTES_FIELD + '.';\n-                    DBObject[] regexList = getFileFilterDBObjects(key + StudyEntry.FILTER, filterValues);\n-\n-                    int i = 0;\n-                    for (Integer fileId : fileIds) {\n-                        QueryBuilder fileBuilder = QueryBuilder.start();\n-\n-                        fileBuilder.and(DocumentToStudyVariantEntryConverter.FILEID_FIELD).is(fileId);\n-                        if (isValidParam(query, FILTER)) {\n-                            if (filterOperation == QueryOperation.OR) {\n-                                fileBuilder.or(regexList);\n-                            } else {\n-                                fileBuilder.and(regexList);\n-                            }\n-                        }\n-                        if (isValidParam(query, QUAL)) {\n-                            addCompListQueryFilter(key + StudyEntry.QUAL, query.getString(QUAL.key()), fileBuilder, false);\n-                        }\n-\n-                        if (infoInFileElemMatch && !infoMap.isEmpty()) {\n-                            if (defaultStudy == null) {\n-                                throw VariantQueryException.missingStudyForFile(fileId.toString(),\n-                                        metadataManager.getStudyNames());\n-                            }\n-                            String fileName = metadataManager.getFileName(defaultStudy.getId(), fileId);\n-                            String infoValue = infoMap.get(fileName);\n-                            if (infoValue != null) {\n-                                addCompListQueryFilter(DocumentToStudyVariantEntryConverter.ATTRIBUTES_FIELD, infoValue, fileBuilder, true);\n-                            }\n-                        }\n-\n-                        fileElemMatch[i++] = new BasicDBObject(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD,\n-                                new BasicDBObject(\"$elemMatch\", fileBuilder.get()));\n-                    }\n-                    if (filesOperation == QueryOperation.OR) {\n-                        builder.or(fileElemMatch);\n-                    } else {\n-                        builder.and(fileElemMatch);\n-                    }\n-\n-                }\n-\n-                if (!infoInFileElemMatch && !infoMap.isEmpty()) {\n-                    DBObject[] infoElemMatch = new DBObject[infoMap.size()];\n-                    int i = 0;\n-                    for (Map.Entry<String, String> entry : infoMap.entrySet()) {\n-                        if (defaultStudy == null) {\n-                            throw VariantQueryException.missingStudyForFile(entry.getKey(), metadataManager.getStudyNames());\n-                        }\n-                        QueryBuilder infoBuilder = new QueryBuilder();\n-                        Integer fileId = metadataManager.getFileId(defaultStudy.getId(), entry.getKey(), true);\n-                        infoBuilder.and(DocumentToStudyVariantEntryConverter.FILEID_FIELD).is(fileId);\n-                        String infoValue = entry.getValue();\n-                        if (infoValue != null) {\n-                            addCompListQueryFilter(DocumentToStudyVariantEntryConverter.ATTRIBUTES_FIELD, infoValue, infoBuilder, true);\n-                        }\n-                        infoElemMatch[i++] = new BasicDBObject(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD,\n-                                new BasicDBObject(\"$elemMatch\", infoBuilder.get()));\n-                    }\n-                    if (infoOperator == QueryOperation.OR) {\n-                        builder.or(infoElemMatch);\n-                    } else {\n-                        builder.and(infoElemMatch);\n-                    }\n-                }\n-            }\n-\n-            if (isValidParam(query, FORMAT)) {\n-                throw VariantQueryException.unsupportedVariantQueryFilter(FORMAT, MongoDBVariantStorageEngine.STORAGE_ENGINE_ID);\n-            }\n-\n-            Map<Object, List<String>> genotypesFilter = new HashMap<>();\n-            QueryOperation gtQueryOperation = null;\n-            if (isValidParam(query, GENOTYPE)) {\n-                String sampleGenotypes = query.getString(GENOTYPE.key());\n-                gtQueryOperation = parseGenotypeFilter(sampleGenotypes, genotypesFilter);\n-            } else if (isValidParam(query, SAMPLE)) {\n-                String samples = query.getString(SAMPLE.key());\n-\n-                List<String> genotypes;\n-                if (defaultStudy != null) {\n-                    genotypes = defaultStudy.getAttributes().getAsStringList(LOADED_GENOTYPES.key()).stream()\n-                            .filter(gt -> DocumentToSamplesConverter.genotypeToDataModelType(gt).contains(\"1\"))\n-                            .collect(Collectors.toList());\n-                } else {\n-                    genotypes = Arrays.asList(\n-                            \"1\",\n-                            \"0/1\", \"0|1\", \"1|0\",\n-                            \"1/1\", \"1|1\",\n-                            \"1/2\", \"1|2\", \"2|1\"\n-                    );\n-                }\n-                QueryOperation sampleQueryOperation = VariantQueryUtils.checkOperator(samples);\n-                if (gtQueryOperation != null && sampleQueryOperation != null && !gtQueryOperation.equals(sampleQueryOperation)) {\n-                    throw VariantQueryException.incompatibleSampleAndGenotypeOperators();\n-                }\n-                if (gtQueryOperation == null) {\n-                    gtQueryOperation = sampleQueryOperation;\n-                }\n-\n-                for (String sample : VariantQueryUtils.splitValue(samples, gtQueryOperation)) {\n-                    if (isNegated(sample)) {\n-                        throw VariantQueryException.malformedParam(SAMPLE, samples, \"Unsupported negated samples\");\n-                    }\n-                    int sampleId = metadataManager.getSampleId(defaultStudy.getId(), sample, true);\n-                    genotypesFilter.put(sampleId, genotypes);\n-                }\n-            }\n-\n-            // Only will contain values if the genotypesOperator is AND\n-            Set<List<Integer>> fileIdGroupsFromSamples = Collections.emptySet();\n-            Set<Integer> fileIdsFromSamples = Collections.emptySet();\n-            if (!genotypesFilter.isEmpty()) {\n-                fileIdGroupsFromSamples = new HashSet<>();\n-                fileIdsFromSamples = new HashSet<>();\n-\n-                List<String> defaultGenotypes;\n-                List<String> loadedGenotypes;\n-                if (defaultStudy != null) {\n-                    defaultGenotypes = defaultStudy.getAttributes().getAsStringList(DEFAULT_GENOTYPE.key());\n-                    loadedGenotypes = defaultStudy.getAttributes().getAsStringList(LOADED_GENOTYPES.key());\n-                    loadedGenotypes.replaceAll(DocumentToSamplesConverter::genotypeToDataModelType);\n-                } else {\n-                    defaultGenotypes = DEFAULT_GENOTYPE.defaultValue();\n-                    loadedGenotypes = Arrays.asList(\n-                            \"0/0\", \"0|0\",\n-                            \"0/1\", \"1/0\", \"1/1\", \"./.\",\n-                            \"0|1\", \"1|0\", \"1|1\", \".|.\",\n-                            \"0|2\", \"2|0\", \"2|1\", \"1|2\", \"2|2\",\n-                            \"0/2\", \"2/0\", \"2/1\", \"1/2\", \"2/2\",\n-                            GenotypeClass.UNKNOWN_GENOTYPE);\n-                }\n-\n-                List<DBObject> genotypeQueries = new ArrayList<>(genotypesFilter.size());\n-\n-                for (Map.Entry<Object, List<String>> entry : genotypesFilter.entrySet()) {\n-                    Object sample = entry.getKey();\n-                    List<String> genotypes = GenotypeClass.filter(entry.getValue(), loadedGenotypes, defaultGenotypes);\n-\n-                    // If empty, should find none. Add non-existing genotype\n-                    // TODO: Fast empty result\n-                    if (!entry.getValue().isEmpty() && genotypes.isEmpty()) {\n-                        genotypes.add(GenotypeClass.NONE_GT_VALUE);\n-                    }\n-\n-                    int sampleId = metadataManager.getSampleId(defaultStudy.getId(), sample, true);\n-\n-                    // We can not filter sample by file if one of the requested genotypes is the unknown genotype\n-                    boolean canFilterSampleByFile = !genotypes.contains(GenotypeClass.UNKNOWN_GENOTYPE);\n-                    boolean defaultGenotypeNegated = false;\n-                    if (canFilterSampleByFile) {\n-                        for (String genotype : genotypes) {\n-                            // Do not filter sample by file if the genotypes are negated, unless is a defaultGenotype\n-                            if (isNegated(genotype)) {\n-                                if (defaultGenotypes.contains(removeNegation(genotype))) {\n-                                    canFilterSampleByFile = true;\n-                                    defaultGenotypeNegated = true;\n-                                    break;\n-                                } else {\n-                                    canFilterSampleByFile = false;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    QueryBuilder genotypesBuilder = QueryBuilder.start();\n-                    if (canFilterSampleByFile) {\n-                        List<Integer> fileIdsFromSample = new ArrayList<>();\n-                        for (Integer file : metadataManager.getIndexedFiles(defaultStudy.getId())) {\n-                            FileMetadata fileMetadata = metadataManager.getFileMetadata(defaultStudy.getId(), file);\n-                            if (fileMetadata.getSamples().contains(sampleId)) {\n-                                fileIdsFromSample.add(file);\n-                            }\n-                        }\n-\n-                        if (defaultGenotypeNegated) {\n-                            QueryBuilder negatedFileBuilder = new QueryBuilder()\n-                                    .and(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD\n-                                            + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD);\n-                            if (fileIdsFromSample.size() == 1) {\n-                                negatedFileBuilder.notEquals(fileIdsFromSample.get(0));\n-                            } else {\n-                                negatedFileBuilder.notIn(fileIdsFromSample);\n-                            }\n-                            genotypesBuilder.or(negatedFileBuilder.get());\n-                        } else if (gtQueryOperation == QueryOperation.OR) {\n-                            genotypesBuilder.and(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD\n-                                    + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD);\n-                            if (fileIdsFromSample.size() == 1) {\n-                                genotypesBuilder.is(fileIdsFromSample.get(0));\n-                            } else {\n-                                genotypesBuilder.in(fileIdsFromSample);\n-                            }\n-                        } else {\n-                            // FILE ID filter can be added at the end, together with the main FILE filter\n-                            fileIdGroupsFromSamples.add(fileIdsFromSample);\n-                            fileIdsFromSamples.addAll(fileIdsFromSample);\n-                        }\n-                    }\n-\n-                    for (String genotype : genotypes) {\n-                        if (genotype.equals(GenotypeClass.NA_GT_VALUE)) {\n-                            continue;\n-                        }\n-\n-                        boolean negated = isNegated(genotype);\n-                        if (negated) {\n-                            genotype = removeNegation(genotype);\n-                        }\n-                        if (defaultGenotypes.contains(genotype)) {\n-\n-                            if (negated) {\n-                                for (String otherGenotype : loadedGenotypes) {\n-                                    if (defaultGenotypes.contains(otherGenotype)) {\n-                                        continue;\n-                                    }\n-                                    String key = studyQueryPrefix\n-                                            + DocumentToStudyVariantEntryConverter.GENOTYPES_FIELD\n-                                            + '.' + DocumentToSamplesConverter.genotypeToStorageType(otherGenotype);\n-                                    genotypesBuilder.or(new BasicDBObject(key, sampleId));\n-                                }\n-                            } else {\n-                                QueryBuilder andBuilder = QueryBuilder.start();\n-                                for (String otherGenotype : loadedGenotypes) {\n-                                    if (defaultGenotypes.contains(otherGenotype)) {\n-                                        continue;\n-                                    }\n-                                    String key = studyQueryPrefix\n-                                            + DocumentToStudyVariantEntryConverter.GENOTYPES_FIELD\n-                                            + '.' + DocumentToSamplesConverter.genotypeToStorageType(otherGenotype);\n-                                    andBuilder.and(new BasicDBObject(key,\n-                                            new Document(\"$ne\", sampleId)));\n-                                }\n-                                genotypesBuilder.or(andBuilder.get());\n-                            }\n-                        } else {\n-                            String s = studyQueryPrefix\n-                                    + DocumentToStudyVariantEntryConverter.GENOTYPES_FIELD\n-                                    + '.' + DocumentToSamplesConverter.genotypeToStorageType(genotype);\n-                            if (negated) {\n-                                //and [ {\"gt.0|1\" : { $ne : <sampleId> } } ]\n-                                genotypesBuilder.and(new BasicDBObject(s, new BasicDBObject(\"$ne\", sampleId)));\n-\n-                            } else {\n-                                //or [ {\"gt.0|1\" : <sampleId> } ]\n-                                genotypesBuilder.or(new BasicDBObject(s, sampleId));\n-                            }\n-                        }\n-                    }\n-                    genotypeQueries.add(genotypesBuilder.get());\n-                }\n-\n-                if (gtQueryOperation == QueryOperation.OR) {\n-                    builder.or(genotypeQueries.toArray(new DBObject[genotypeQueries.size()])).get();\n-                } else {\n-                    builder.and(genotypeQueries.toArray(new DBObject[genotypeQueries.size()]));\n-                }\n-\n-            }\n-\n-            if (fileNames.isEmpty()) {\n-                // If there is no valid files filter, add files filter to speed up this query\n-                if (!fileIdGroupsFromSamples.isEmpty()) {\n-                    if ((gtQueryOperation != QueryOperation.AND || fileIdGroupsFromSamples.size() == 1)\n-                            && fileIdsFromSamples.containsAll(metadataManager.getIndexedFiles(defaultStudy.getId()))) {\n-                        // Do not add files filter if operator is OR and must select all the files.\n-                        // i.e. ANY file among ALL indexed files\n-                        logger.debug(\"Skip filter by all files\");\n-                    } else {\n-                        addFileGroupsFilter(builder, studyQueryPrefix, gtQueryOperation, fileIdGroupsFromSamples, null);\n-                    }\n-                }\n+        if (!useFileElemMatch) {\n+          String key = studyQueryPrefix\n+              + DocumentToStudyVariantEntryConverter.FILES_FIELD + '.'\n+              + DocumentToStudyVariantEntryConverter.ATTRIBUTES_FIELD + '.';\n+\n+          if (isValidParam(query, FILTER)) {\n+            DBObject[] regexList = getFileFilterDBObjects(key + StudyEntry.FILTER, filterValues);\n+            if (filterOperation == QueryOperation.OR) {\n+              builder.or(regexList);\n             } else {\n-                if (fileIdGroupsFromSamples.isEmpty()) {\n-                    addQueryFilter(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD\n-                                    + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD,\n-                            fileNames, builder, QueryOperation.AND, filesOperation,\n-                            value -> {\n-                                Integer fileId = metadataManager.getFileIdPair(value, false, defaultStudy).getValue();\n-                                if (fileId == null) {\n-                                    throw VariantQueryException.fileNotFound(value, defaultStudy.getName());\n-                                }\n-                                if (overlappedFilesFiles) {\n-                                    fileId = -fileId;\n-                                }\n-                                return fileId;\n-                            });\n-                } else {\n-                    // fileIdGroupsFromSamples is not empty. gtQueryOperation is always AND at this point\n-                    // assert gtQueryOperation == Operation.AND || gtQueryOperation == null\n-                    if (filesOperation == QueryOperation.AND || filesOperation == null) {\n-                        // sample = AND, files = AND\n-                        // Simple mix\n-\n-                        // Some files may be negated. Get them, and put them appart\n-                        List<Integer> negatedFiles = null;\n-                        if (fileNames.stream().anyMatch(VariantQueryUtils::isNegated)) {\n-                            negatedFiles = fileNames\n-                                    .stream()\n-                                    .filter(VariantQueryUtils::isNegated)\n-                                    .map(value -> {\n-                                        Integer fileId = metadataManager.getFileIdPair(value, false, defaultStudy)\n-                                                .getValue();\n-                                        if (fileId == null) {\n-                                            throw VariantQueryException.fileNotFound(value, defaultStudy.getName());\n-                                        }\n-                                        if (overlappedFilesFiles) {\n-                                            fileId = -fileId;\n-                                        }\n-                                        return fileId;\n-                                    })\n-                                    .collect(Collectors.toList());\n-                        }\n-                        for (Integer fileId : fileIds) {\n-                            fileIdGroupsFromSamples.add(Collections.singletonList(fileId));\n-                        }\n-                        addFileGroupsFilter(builder, studyQueryPrefix, QueryOperation.AND, fileIdGroupsFromSamples, negatedFiles);\n-\n-                    } else if (filesOperation == QueryOperation.OR) {\n-                        // samples = AND, files = OR\n-\n-                        // Put all files in a group\n-                        // the filesOperation==OR will will be expressed with an \"$in\" of the new group\n-                        fileIdGroupsFromSamples.add(fileIds);\n-                        addFileGroupsFilter(builder, studyQueryPrefix, QueryOperation.AND, fileIdGroupsFromSamples, null);\n-                    }\n-                }\n+              builder.and(regexList);\n             }\n-\n-            return defaultStudy;\n+          }\n+          if (isValidParam(query, QUAL)) {\n+            addCompListQueryFilter(key + StudyEntry.QUAL, query.getString(QUAL.key()), builder, false);\n+          }\n         } else {\n-            return null;\n-        }\n-    }\n+          DBObject[] fileElemMatch = new DBObject[fileIds.size()];\n+          String key = DocumentToStudyVariantEntryConverter.ATTRIBUTES_FIELD + '.';\n+          DBObject[] regexList = getFileFilterDBObjects(key + StudyEntry.FILTER, filterValues);\n+\n+          int i = 0;\n+          for (Integer fileId : fileIds) {\n+            QueryBuilder fileBuilder = QueryBuilder.start();\n+\n+            fileBuilder.and(DocumentToStudyVariantEntryConverter.FILEID_FIELD).is(fileId);\n+            if (isValidParam(query, FILTER)) {\n+              if (filterOperation == QueryOperation.OR) {\n+                fileBuilder.or(regexList);\n+              } else {\n+                fileBuilder.and(regexList);\n+              }\n+            }\n+            if (isValidParam(query, QUAL)) {\n+              addCompListQueryFilter(key + StudyEntry.QUAL, query.getString(QUAL.key()), fileBuilder, false);\n+            }\n+\n+            if (infoInFileElemMatch && !infoMap.isEmpty()) {\n+              if (defaultStudy == null) {\n+                throw VariantQueryException.missingStudyForFile(fileId.toString(),\n+                    metadataManager.getStudyNames());\n+              }\n+              String fileName = metadataManager.getFileName(defaultStudy.getId(), fileId);\n+              String infoValue = infoMap.get(fileName);\n+              if (infoValue != null) {\n+                addCompListQueryFilter(DocumentToStudyVariantEntryConverter.ATTRIBUTES_FIELD, infoValue, fileBuilder, true);\n+              }\n+            }\n+\n+            fileElemMatch[i++] = new BasicDBObject(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD,\n+                new BasicDBObject(\"$elemMatch\", fileBuilder.get()));\n+          }\n+          if (filesOperation == QueryOperation.OR) {\n+            builder.or(fileElemMatch);\n+          } else {\n+            builder.and(fileElemMatch);\n+          }\n \n-    private void addFileGroupsFilter(QueryBuilder builder, String studyQueryPrefix, QueryOperation operation,\n-                                     Set<List<Integer>> fileIdGroups, List<Integer> negatedFiles) {\n-        if (operation == QueryOperation.OR) {\n-            // Merge into one single group\n-            HashSet<Integer> fileIds = new HashSet<>();\n-            for (List<Integer> files : fileIdGroups) {\n-                fileIds.addAll(files);\n-            }\n-            fileIdGroups = Collections.singleton(new ArrayList<>(fileIds));\n         }\n \n-        String fileIdField = studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD\n-                + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD;\n-        List<DBObject> fileQueries = new ArrayList<>(fileIdGroups.size());\n-        List<Integer> singleElementGroups = new ArrayList<>();\n-        for (List<Integer> group : fileIdGroups) {\n-            if (group.size() == 1) {\n-                singleElementGroups.add(group.get(0));\n-            } else {\n-                fileQueries.add(new BasicDBObject(fileIdField, new BasicDBObject(\"$in\", group)));\n-            }\n+        if (!infoInFileElemMatch && !infoMap.isEmpty()) {\n+          DBObject[] infoElemMatch = new DBObject[infoMap.size()];\n+          int i = 0;\n+          for (Map.Entry<String, String> entry : infoMap.entrySet()) {\n+            if (defaultStudy == null) {\n+              throw VariantQueryException.missingStudyForFile(entry.getKey(), metadataManager.getStudyNames());\n+            }\n+            QueryBuilder infoBuilder = new QueryBuilder();\n+            Integer fileId = metadataManager.getFileId(defaultStudy.getId(), entry.getKey(), true);\n+            infoBuilder.and(DocumentToStudyVariantEntryConverter.FILEID_FIELD).is(fileId);\n+            String infoValue = entry.getValue();\n+            if (infoValue != null) {\n+              addCompListQueryFilter(DocumentToStudyVariantEntryConverter.ATTRIBUTES_FIELD, infoValue, infoBuilder, true);\n+            }\n+            infoElemMatch[i++] = new BasicDBObject(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD,\n+                new BasicDBObject(\"$elemMatch\", infoBuilder.get()));\n+          }\n+          if (infoOperator == QueryOperation.OR) {\n+            builder.or(infoElemMatch);\n+          } else {\n+            builder.and(infoElemMatch);\n+          }\n         }\n-        if (!singleElementGroups.isEmpty()) {\n-            if (singleElementGroups.size() == 1) {\n-                fileQueries.add(new BasicDBObject(fileIdField, singleElementGroups.get(0)));\n-            } else if (operation == QueryOperation.AND) {\n-                fileQueries.add(new BasicDBObject(fileIdField, new BasicDBObject(\"$all\", singleElementGroups)));\n-            } else {\n-                fileQueries.add(new BasicDBObject(fileIdField, new BasicDBObject(\"$in\", singleElementGroups)));\n-            }\n+      }\n+\n+      if (isValidParam(query, FORMAT)) {\n+        throw VariantQueryException.unsupportedVariantQueryFilter(FORMAT, MongoDBVariantStorageEngine.STORAGE_ENGINE_ID);\n+      }\n+\n+      Map<Object, List<String>> genotypesFilter = new HashMap<>();\n+      QueryOperation gtQueryOperation = null;\n+      if (isValidParam(query, GENOTYPE)) {\n+        String sampleGenotypes = query.getString(GENOTYPE.key());\n+        gtQueryOperation = parseGenotypeFilter(sampleGenotypes, genotypesFilter);\n+      } else if (isValidParam(query, SAMPLE)) {\n+        String samples = query.getString(SAMPLE.key());\n+\n+        List<String> genotypes;\n+        if (defaultStudy != null) {\n+          genotypes = defaultStudy.getAttributes().getAsStringList(LOADED_GENOTYPES.key()).stream()\n+              .filter(gt -> DocumentToSamplesConverter.genotypeToDataModelType(gt).contains(\"1\"))\n+              .collect(Collectors.toList());\n+        } else {\n+          genotypes = Arrays.asList(\n+              \"1\",\n+              \"0/1\", \"0|1\", \"1|0\",\n+              \"1/1\", \"1|1\",\n+              \"1/2\", \"1|2\", \"2|1\"\n+          );\n         }\n-\n-        if (CollectionUtils.isNotEmpty(negatedFiles)) {\n-            DBObject negatedFilter;\n-            if (negatedFiles.size() == 1) {\n-                negatedFilter = new BasicDBObject(fileIdField, new BasicDBObject(\"$ne\", negatedFiles.get(0)));\n-            } else {\n-                negatedFilter = new BasicDBObject(fileIdField, new BasicDBObject(\"$nin\", negatedFiles));\n-            }\n-            if (operation != QueryOperation.OR) {\n-                fileQueries.add(negatedFilter);\n-            } else {\n-                // This should never happen\n-                throw VariantQueryException.internalException(new IllegalStateException(\"Unsupported negated files with operator OR\"));\n-            }\n+        QueryOperation sampleQueryOperation = VariantQueryUtils.checkOperator(samples);\n+        if (gtQueryOperation != null && sampleQueryOperation != null && !gtQueryOperation.equals(sampleQueryOperation)) {\n+          throw VariantQueryException.incompatibleSampleAndGenotypeOperators();\n+        }\n+        if (gtQueryOperation == null) {\n+          gtQueryOperation = sampleQueryOperation;\n         }\n \n-        if (fileQueries.size() == 1) {\n-            builder.get().putAll(fileQueries.get(0));\n-        } else if (operation == QueryOperation.OR) {\n-//            builder.and(new BasicDBObject(\"$or\", fileQueries));\n-            Object or = builder.get().removeField(\"$or\");\n-            if (or == null) {\n-                builder.or(fileQueries.toArray(new DBObject[0]));\n-            } else {\n-                builder.and(new BasicDBObject(\"$or\", or), new BasicDBObject(\"$or\", fileQueries));\n-            }\n+        for (String sample : VariantQueryUtils.splitValue(samples, gtQueryOperation)) {\n+          if (isNegated(sample)) {\n+            throw VariantQueryException.malformedParam(SAMPLE, samples, \"Unsupported negated samples\");\n+          }\n+          int sampleId = metadataManager.getSampleId(defaultStudy.getId(), sample, true);\n+          genotypesFilter.put(sampleId, genotypes);\n+        }\n+      }\n+\n+      // Only will contain values if the genotypesOperator is AND\n+      Set<List<Integer>> fileIdGroupsFromSamples = Collections.emptySet();\n+      Set<Integer> fileIdsFromSamples = Collections.emptySet();\n+      if (!genotypesFilter.isEmpty()) {\n+        fileIdGroupsFromSamples = new HashSet<>();\n+        fileIdsFromSamples = new HashSet<>();\n+\n+        List<String> defaultGenotypes;\n+        List<String> loadedGenotypes;\n+        if (defaultStudy != null) {\n+          defaultGenotypes = defaultStudy.getAttributes().getAsStringList(DEFAULT_GENOTYPE.key());\n+          loadedGenotypes = defaultStudy.getAttributes().getAsStringList(LOADED_GENOTYPES.key());\n+          loadedGenotypes.replaceAll(DocumentToSamplesConverter::genotypeToDataModelType);\n         } else {\n-            builder.and(fileQueries.toArray(new DBObject[0]));\n+          defaultGenotypes = DEFAULT_GENOTYPE.defaultValue();\n+          loadedGenotypes = Arrays.asList(\n+              \"0/0\", \"0|0\",\n+              \"0/1\", \"1/0\", \"1/1\", \"./.\",\n+              \"0|1\", \"1|0\", \"1|1\", \".|.\",\n+              \"0|2\", \"2|0\", \"2|1\", \"1|2\", \"2|2\",\n+              \"0/2\", \"2/0\", \"2/1\", \"1/2\", \"2/2\",\n+              GenotypeClass.UNKNOWN_GENOTYPE);\n         }\n-    }\n \n-    private DBObject[] getFileFilterDBObjects(String key, List<String> filterValues) {\n-        DBObject[] regexList = new DBObject[filterValues.size()];\n-        for (int i = 0; i < filterValues.size(); i++) {\n-            String filter = filterValues.get(i);\n-            boolean negated = isNegated(filter);\n-            if (negated) {\n-                filter = removeNegation(filter);\n-            }\n-            if (filter.contains(VCFConstants.FILTER_CODE_SEPARATOR) || filter.equals(VCFConstants.PASSES_FILTERS_v4)) {\n-                if (!negated) {\n-                    regexList[i] = new BasicDBObject(key, filter);\n+        List<DBObject> genotypeQueries = new ArrayList<>(genotypesFilter.size());\n+\n+        for (Map.Entry<Object, List<String>> entry : genotypesFilter.entrySet()) {\n+          Object sample = entry.getKey();\n+          List<String> genotypes = GenotypeClass.filter(entry.getValue(), loadedGenotypes, defaultGenotypes);\n+\n+          // If empty, should find none. Add non-existing genotype\n+          // TODO: Fast empty result\n+          if (!entry.getValue().isEmpty() && genotypes.isEmpty()) {\n+            genotypes.add(GenotypeClass.NONE_GT_VALUE);\n+          }\n+\n+          int sampleId = metadataManager.getSampleId(defaultStudy.getId(), sample, true);\n+\n+          // We can not filter sample by file if one of the requested genotypes is the unknown genotype\n+          boolean canFilterSampleByFile = !genotypes.contains(GenotypeClass.UNKNOWN_GENOTYPE);\n+          boolean defaultGenotypeNegated = false;\n+          if (canFilterSampleByFile) {\n+            for (String genotype : genotypes) {\n+              // Do not filter sample by file if the genotypes are negated, unless is a defaultGenotype\n+              if (isNegated(genotype)) {\n+                if (defaultGenotypes.contains(removeNegation(genotype))) {\n+                  canFilterSampleByFile = true;\n+                  defaultGenotypeNegated = true;\n+                  break;\n                 } else {\n-                    regexList[i] = new BasicDBObject(key, new BasicDBObject(\"$ne\", filter));\n+                  canFilterSampleByFile = false;\n                 }\n+              }\n+            }\n+          }\n+          QueryBuilder genotypesBuilder = QueryBuilder.start();\n+          if (canFilterSampleByFile) {\n+            List<Integer> fileIdsFromSample = new ArrayList<>();\n+            for (Integer file : metadataManager.getIndexedFiles(defaultStudy.getId())) {\n+              FileMetadata fileMetadata = metadataManager.getFileMetadata(defaultStudy.getId(), file);\n+              if (fileMetadata.getSamples().contains(sampleId)) {\n+                fileIdsFromSample.add(file);\n+              }\n+            }\n+\n+            if (defaultGenotypeNegated) {\n+              QueryBuilder negatedFileBuilder = new QueryBuilder()\n+                  .and(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD\n+                      + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD);\n+              if (fileIdsFromSample.size() == 1) {\n+                negatedFileBuilder.notEquals(fileIdsFromSample.get(0));\n+              } else {\n+                negatedFileBuilder.notIn(fileIdsFromSample);\n+              }\n+              genotypesBuilder.or(negatedFileBuilder.get());\n+            } else if (gtQueryOperation == QueryOperation.OR) {\n+              genotypesBuilder.and(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD\n+                  + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD);\n+              if (fileIdsFromSample.size() == 1) {\n+                genotypesBuilder.is(fileIdsFromSample.get(0));\n+              } else {\n+                genotypesBuilder.in(fileIdsFromSample);\n+              }\n             } else {\n-                if (!negated) {\n-                    regexList[i] = new BasicDBObject(key, new BasicDBObject(\"$regex\", filter));\n-                } else {\n-                    regexList[i] = new BasicDBObject(key, new BasicDBObject(\"$not\", Pattern.compile(filter)));\n-                }\n-            }\n-        }\n-        return regexList;\n-    }\n-\n-    private void parseStatsQueryParams(Query query, QueryBuilder builder, StudyMetadata defaultStudy) {\n-        if (query != null) {\n-            if (query.get(COHORT.key()) != null && !query.getString(COHORT.key()).isEmpty()) {\n-                addQueryFilter(DocumentToVariantConverter.STATS_FIELD\n-                                + '.' + DocumentToVariantStatsConverter.COHORT_ID,\n-                        query.getString(COHORT.key()), builder, QueryOperation.AND,\n-                        s -> {\n-                            try {\n-                                return Integer.parseInt(s);\n-                            } catch (NumberFormatException ignore) {\n-                                String[] split = VariantQueryUtils.splitStudyResource(s);\n-                                if (defaultStudy == null && split.length == 1) {\n-                                    throw VariantQueryException.malformedParam(COHORT, s, \"Expected {study}:{cohort}\");\n-                                } else {\n-                                    String study;\n-                                    String cohort;\n-                                    Integer cohortId;\n-                                    if (defaultStudy != null && split.length == 1) {\n-                                        cohort = s;\n-                                        cohortId = metadataManager.getCohortId(defaultStudy.getId(), cohort);\n-                                        if (cohortId == null) {\n-                                            List<String> availableCohorts = new LinkedList<>();\n-                                            metadataManager.cohortIterator(defaultStudy.getId())\n-                                                    .forEachRemaining(c -> availableCohorts.add(c.getName()));\n-                                            throw VariantQueryException.cohortNotFound(cohort, defaultStudy.getId(), availableCohorts);\n-                                        }\n-                                    } else {\n-                                        study = split[0];\n-                                        cohort = split[1];\n-                                        int studyId = metadataManager.getStudyId(study);\n-                                        cohortId = metadataManager.getCohortId(studyId, cohort);\n-                                    }\n-                                    return cohortId;\n-                                }\n-                            }\n-                        });\n-            }\n-\n-            if (query.get(STATS_REF.key()) != null && !query.getString(STATS_REF.key()).isEmpty()) {\n-                addStatsFilterList(DocumentToVariantStatsConverter.REF_FREQ_FIELD, query.getString(STATS_REF.key()),\n-                        builder, defaultStudy);\n-            }\n-\n-            if (query.get(STATS_ALT.key()) != null && !query.getString(STATS_ALT.key()).isEmpty()) {\n-                addStatsFilterList(DocumentToVariantStatsConverter.ALT_FREQ_FIELD, query.getString(STATS_ALT.key()),\n-                        builder, defaultStudy);\n+              // FILE ID filter can be added at the end, together with the main FILE filter\n+              fileIdGroupsFromSamples.add(fileIdsFromSample);\n+              fileIdsFromSamples.addAll(fileIdsFromSample);\n             }\n+          }\n \n-            if (query.get(STATS_MAF.key()) != null && !query.getString(STATS_MAF.key()).isEmpty()) {\n-                addStatsFilterList(DocumentToVariantStatsConverter.MAF_FIELD, query.getString(STATS_MAF.key()),\n-                        builder, defaultStudy);\n+          for (String genotype : genotypes) {\n+            if (genotype.equals(GenotypeClass.NA_GT_VALUE)) {\n+              continue;\n             }\n \n-            if (query.get(STATS_MGF.key()) != null && !query.getString(STATS_MGF.key()).isEmpty()) {\n-                addStatsFilterList(DocumentToVariantStatsConverter.MGF_FIELD, query.getString(STATS_MGF.key()),\n-                        builder, defaultStudy);\n-            }\n-\n-            if (query.get(MISSING_ALLELES.key()) != null && !query.getString(MISSING_ALLELES.key())\n-                    .isEmpty()) {\n-                addStatsFilterList(DocumentToVariantStatsConverter.MISSALLELE_FIELD, query.getString(MISSING_ALLELES\n-                        .key()), builder, defaultStudy);\n-            }\n-\n-            if (query.get(MISSING_GENOTYPES.key()) != null && !query.getString(MISSING_GENOTYPES\n-                    .key()).isEmpty()) {\n-                addStatsFilterList(DocumentToVariantStatsConverter.MISSGENOTYPE_FIELD, query.getString(\n-                        MISSING_GENOTYPES.key()), builder, defaultStudy);\n-            }\n-\n-            if (query.get(\"numgt\") != null && !query.getString(\"numgt\").isEmpty()) {\n-                for (String numgt : query.getAsStringList(\"numgt\")) {\n-                    String[] split = numgt.split(\":\");\n-                    addCompQueryFilter(\n-                            DocumentToVariantConverter.STATS_FIELD + '.' + DocumentToVariantStatsConverter.NUMGT_FIELD + '.' + split[0],\n-                            split[1], builder, false);\n+            boolean negated = isNegated(genotype);\n+            if (negated) {\n+              genotype = removeNegation(genotype);\n+            }\n+            if (defaultGenotypes.contains(genotype)) {\n+\n+              if (negated) {\n+                for (String otherGenotype : loadedGenotypes) {\n+                  if (defaultGenotypes.contains(otherGenotype)) {\n+                    continue;\n+                  }\n+                  String key = studyQueryPrefix\n+                      + DocumentToStudyVariantEntryConverter.GENOTYPES_FIELD\n+                      + '.' + DocumentToSamplesConverter.genotypeToStorageType(otherGenotype);\n+                  genotypesBuilder.or(new BasicDBObject(key, sampleId));\n                 }\n-            }\n-        }\n-    }\n-\n-    protected Document createProjection(Query query, QueryOptions options) {\n-        return createProjection(query, options, VariantQueryUtils.parseVariantQueryFields(query, options, metadataManager));\n-    }\n-\n-    protected Document createProjection(Query query, QueryOptions options, VariantQueryFields selectVariantElements) {\n-        if (options == null) {\n-            options = new QueryOptions();\n-        }\n-\n-        Document projection = new Document();\n-\n-        if (options.containsKey(QueryOptions.SORT) && !(\"_id\").equals(options.getString(QueryOptions.SORT))) {\n-            if (options.getBoolean(QueryOptions.SORT)) {\n-                options.put(QueryOptions.SORT, \"_id\");\n-                options.putIfAbsent(QueryOptions.ORDER, QueryOptions.ASCENDING);\n+              } else {\n+                QueryBuilder andBuilder = QueryBuilder.start();\n+                for (String otherGenotype : loadedGenotypes) {\n+                  if (defaultGenotypes.contains(otherGenotype)) {\n+                    continue;\n+                  }\n+                  String key = studyQueryPrefix\n+                      + DocumentToStudyVariantEntryConverter.GENOTYPES_FIELD\n+                      + '.' + DocumentToSamplesConverter.genotypeToStorageType(otherGenotype);\n+                  andBuilder.and(new BasicDBObject(key,\n+                      new Document(\"$ne\", sampleId)));\n+                }\n+                genotypesBuilder.or(andBuilder.get());\n+              }\n             } else {\n-                options.remove(QueryOptions.SORT);\n-            }\n+              String s = studyQueryPrefix\n+                  + DocumentToStudyVariantEntryConverter.GENOTYPES_FIELD\n+                  + '.' + DocumentToSamplesConverter.genotypeToStorageType(genotype);\n+              if (negated) {\n+                //and [ {\"gt.0|1\" : { $ne : <sampleId> } } ]\n+                genotypesBuilder.and(new BasicDBObject(s, new BasicDBObject(\"$ne\", sampleId)));\n+\n+              } else {\n+                //or [ {\"gt.0|1\" : <sampleId> } ]\n+                genotypesBuilder.or(new BasicDBObject(s, sampleId));\n+              }\n+            }\n+          }\n+          genotypeQueries.add(genotypesBuilder.get());\n         }\n \n-        Set<VariantField> returnedFields = new HashSet<>(selectVariantElements.getFields());\n-        // Add all required fields\n-        returnedFields.addAll(DocumentToVariantConverter.REQUIRED_FIELDS_SET);\n-        // StudyID is mandatory if returning any STUDY element\n-        if (returnedFields.contains(VariantField.STUDIES)) {\n-            returnedFields.add(VariantField.STUDIES_STUDY_ID);\n+        if (gtQueryOperation == QueryOperation.OR) {\n+          builder.or(genotypeQueries.toArray(new DBObject[genotypeQueries.size()])).get();\n+        } else {\n+          builder.and(genotypeQueries.toArray(new DBObject[genotypeQueries.size()]));\n         }\n \n-\n-        // Top level $elemMatch MUST be at the very beginning in the projection document, so all the fields apply correctly.\n-        //\n-        // This two queries return different values:\n-        //\n-        // > db.variants.find({}, {studies:{$elemMatch:{sid:1}}, \"studies.files\":1})\n-        // {  studies : [ { sid : 1, files : [ ... ] } ]  }\n-        //\n-        // > db.variants.find({}, {\"studies.files\":1, studies:{$elemMatch:{sid:1}}})\n-        // {  studies : [ { sid : 1, files : [ ... ] , gt : { ... } } ]  }\n-        List<Integer> studiesIds = selectVariantElements.getStudies();\n-        // Use elemMatch only if there is one study to return.\n-        if (studiesIds.size() == 1) {\n-            projection.put(\n-                    DocumentToVariantConverter.STUDIES_FIELD,\n-                    new Document(\n-                            \"$elemMatch\",\n-                            new Document(\n-                                    DocumentToStudyVariantEntryConverter.STUDYID_FIELD,\n-                                    new Document(\n-                                            \"$in\",\n-                                            studiesIds\n-                                    )\n-                            )\n-                    )\n-            );\n+      }\n+\n+      if (fileNames.isEmpty()) {\n+        // If there is no valid files filter, add files filter to speed up this query\n+        if (!fileIdGroupsFromSamples.isEmpty()) {\n+          if ((gtQueryOperation != QueryOperation.AND || fileIdGroupsFromSamples.size() == 1)\n+              && fileIdsFromSamples.containsAll(metadataManager.getIndexedFiles(defaultStudy.getId()))) {\n+            // Do not add files filter if operator is OR and must select all the files.\n+            // i.e. ANY file among ALL indexed files\n+            logger.debug(\"Skip filter by all files\");\n+          } else {\n+            addFileGroupsFilter(builder, studyQueryPrefix, gtQueryOperation, fileIdGroupsFromSamples, null);\n+          }\n         }\n-\n-        if (returnedFields.contains(VariantField.STUDIES_SAMPLES_DATA)) {\n-            List<String> formats = VariantQueryUtils.getIncludeFormats(query);\n-            if (formats != null) { // If null, undefined. Return all\n-                // Special conversion\n-                returnedFields.remove(VariantField.STUDIES_SAMPLES_DATA);\n-\n-                for (String format : formats) {\n-                    if (format.equals(GT)) {\n-                        projection.put(DocumentToVariantConverter.STUDIES_FIELD + '.'\n-                                + DocumentToStudyVariantEntryConverter.GENOTYPES_FIELD, 1);\n-                    } else {\n-                        projection.put(DocumentToVariantConverter.STUDIES_FIELD + '.'\n-                                + DocumentToStudyVariantEntryConverter.FILES_FIELD + '.'\n-                                + DocumentToStudyVariantEntryConverter.SAMPLE_DATA_FIELD + '.' + format.toLowerCase(), 1);\n-                    }\n-                    projection.put(DocumentToVariantConverter.STUDIES_FIELD + '.'\n-                            + DocumentToStudyVariantEntryConverter.FILES_FIELD + '.'\n-                            + DocumentToStudyVariantEntryConverter.FILEID_FIELD, 1);\n+      } else {\n+        if (fileIdGroupsFromSamples.isEmpty()) {\n+          addQueryFilter(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD\n+                  + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD,\n+              fileNames, builder, QueryOperation.AND, filesOperation,\n+              value -> {\n+                Integer fileId = metadataManager.getFileIdPair(value, false, defaultStudy).getValue();\n+                if (fileId == null) {\n+                  throw VariantQueryException.fileNotFound(value, defaultStudy.getName());\n                 }\n-            }\n-        }\n-\n-        returnedFields = VariantField.prune(returnedFields);\n-\n-        if (!returnedFields.isEmpty()) { //Include some\n-            for (VariantField s : returnedFields) {\n-                List<String> keys = DocumentToVariantConverter.toShortFieldName(s);\n-                if (keys != null) {\n-                    for (String key : keys) {\n-                        // Put if absent. Do not overwrite $elemMatch, if any\n-                        projection.putIfAbsent(key, 1);\n-                    }\n-                } else {\n-                    logger.warn(\"Unknown include field: {}\", s);\n+                if (overlappedFilesFiles) {\n+                  fileId = -fileId;\n                 }\n+                return fileId;\n+              });\n+        } else {\n+          // fileIdGroupsFromSamples is not empty. gtQueryOperation is always AND at this point\n+          // assert gtQueryOperation == Operation.AND || gtQueryOperation == null\n+          if (filesOperation == QueryOperation.AND || filesOperation == null) {\n+            // sample = AND, files = AND\n+            // Simple mix\n+\n+            // Some files may be negated. Get them, and put them appart\n+            List<Integer> negatedFiles = null;\n+            if (fileNames.stream().anyMatch(VariantQueryUtils::isNegated)) {\n+              negatedFiles = fileNames\n+                  .stream()\n+                  .filter(VariantQueryUtils::isNegated)\n+                  .map(value -> {\n+                    Integer fileId = metadataManager.getFileIdPair(value, false, defaultStudy)\n+                        .getValue();\n+                    if (fileId == null) {\n+                      throw VariantQueryException.fileNotFound(value, defaultStudy.getName());\n+                    }\n+                    if (overlappedFilesFiles) {\n+                      fileId = -fileId;\n+                    }\n+                    return fileId;\n+                  })\n+                  .collect(Collectors.toList());\n             }\n-        }\n-\n-        if (query.getBoolean(VARIANTS_TO_INDEX.key(), false)) {\n-            projection.putIfAbsent(INDEX_FIELD, 1);\n-        }\n+            for (Integer fileId : fileIds) {\n+              fileIdGroupsFromSamples.add(Collections.singletonList(fileId));\n+            }\n+            addFileGroupsFilter(builder, studyQueryPrefix, QueryOperation.AND, fileIdGroupsFromSamples, negatedFiles);\n \n-        logger.debug(\"QueryOptions: = {}\", options.toJson());\n-        logger.debug(\"Projection:   = {}\", projection.toJson(new JsonWriterSettings(JsonMode.SHELL, false)));\n-        return projection;\n-    }\n+          } else if (filesOperation == QueryOperation.OR) {\n+            // samples = AND, files = OR\n \n-    private QueryBuilder addQueryStringFilter(String key, String value, final QueryBuilder builder, VariantQueryUtils.QueryOperation op) {\n-        return this.addQueryFilter(key, value, builder, op, Function.identity());\n-    }\n+            // Put all files in a group\n+            // the filesOperation==OR will will be expressed with an \"$in\" of the new group\n+            fileIdGroupsFromSamples.add(fileIds);\n+            addFileGroupsFilter(builder, studyQueryPrefix, QueryOperation.AND, fileIdGroupsFromSamples, null);\n+          }\n+        }\n+      }\n \n-    private QueryBuilder addQueryStringFilter(String key, List<String> value, final QueryBuilder builder,\n-                                              VariantQueryUtils.QueryOperation op) {\n-        return this.addQueryFilter(key, value, builder, op, Function.identity());\n+      return defaultStudy;\n+    } else {\n+      return null;\n     }\n-\n-    private QueryBuilder addQueryIntegerFilter(String key, String value, final QueryBuilder builder, VariantQueryUtils.QueryOperation op) {\n-        return this.addQueryFilter(key, value, builder, op, elem -> {\n-            try {\n-                return Integer.parseInt(elem);\n-            } catch (NumberFormatException e) {\n-                throw new VariantQueryException(\"Unable to parse int \" + elem, e);\n-            }\n-        });\n+  }\n+\n+  private void addFileGroupsFilter(QueryBuilder builder, String studyQueryPrefix, QueryOperation operation,\n+                                   Set<List<Integer>> fileIdGroups, List<Integer> negatedFiles) {\n+    if (operation == QueryOperation.OR) {\n+      // Merge into one single group\n+      HashSet<Integer> fileIds = new HashSet<>();\n+      for (List<Integer> files : fileIdGroups) {\n+        fileIds.addAll(files);\n+      }\n+      fileIdGroups = Collections.singleton(new ArrayList<>(fileIds));\n     }\n \n-    private QueryBuilder addQueryIntegerFilter(String key, Collection<Integer> value, final QueryBuilder builder,\n-                                               VariantQueryUtils.QueryOperation op) {\n-        return this.addQueryFilter(key, value, builder, op);\n+    String fileIdField = studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD\n+        + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD;\n+    List<DBObject> fileQueries = new ArrayList<>(fileIdGroups.size());\n+    List<Integer> singleElementGroups = new ArrayList<>();\n+    for (List<Integer> group : fileIdGroups) {\n+      if (group.size() == 1) {\n+        singleElementGroups.add(group.get(0));\n+      } else {\n+        fileQueries.add(new BasicDBObject(fileIdField, new BasicDBObject(\"$in\", group)));\n+      }\n     }\n-\n-    private <T> QueryBuilder addQueryFilter(String key, String value, final QueryBuilder builder, QueryOperation op,\n-                                            Function<String, T> map) {\n-        VariantQueryUtils.QueryOperation intraOp = checkOperator(value);\n-        return addQueryFilter(key, splitValue(value, intraOp), builder, op, intraOp, map);\n+    if (!singleElementGroups.isEmpty()) {\n+      if (singleElementGroups.size() == 1) {\n+        fileQueries.add(new BasicDBObject(fileIdField, singleElementGroups.get(0)));\n+      } else if (operation == QueryOperation.AND) {\n+        fileQueries.add(new BasicDBObject(fileIdField, new BasicDBObject(\"$all\", singleElementGroups)));\n+      } else {\n+        fileQueries.add(new BasicDBObject(fileIdField, new BasicDBObject(\"$in\", singleElementGroups)));\n+      }\n     }\n \n-    private <T> QueryBuilder addQueryFilter(String key, Collection<T> value, final QueryBuilder builder, QueryOperation op) {\n-        return addQueryFilter(key, value, builder, op, t -> t);\n+    if (CollectionUtils.isNotEmpty(negatedFiles)) {\n+      DBObject negatedFilter;\n+      if (negatedFiles.size() == 1) {\n+        negatedFilter = new BasicDBObject(fileIdField, new BasicDBObject(\"$ne\", negatedFiles.get(0)));\n+      } else {\n+        negatedFilter = new BasicDBObject(fileIdField, new BasicDBObject(\"$nin\", negatedFiles));\n+      }\n+      if (operation != QueryOperation.OR) {\n+        fileQueries.add(negatedFilter);\n+      } else {\n+        // This should never happen\n+        throw VariantQueryException.internalException(new IllegalStateException(\"Unsupported negated files with operator OR\"));\n+      }\n     }\n \n-    private <S, T> QueryBuilder addQueryFilter(String key, Collection<S> value, final QueryBuilder builder, QueryOperation op,\n-                                               Function<S, T> map) {\n-        return addQueryFilter(key, value, builder, op, QueryOperation.OR, map);\n+    if (fileQueries.size() == 1) {\n+      builder.get().putAll(fileQueries.get(0));\n+    } else if (operation == QueryOperation.OR) {\n+//            builder.and(new BasicDBObject(\"$or\", fileQueries));\n+      Object or = builder.get().removeField(\"$or\");\n+      if (or == null) {\n+        builder.or(fileQueries.toArray(new DBObject[0]));\n+      } else {\n+        builder.and(new BasicDBObject(\"$or\", or), new BasicDBObject(\"$or\", fileQueries));\n+      }\n+    } else {\n+      builder.and(fileQueries.toArray(new DBObject[0]));\n     }\n-\n-    private <S, T> QueryBuilder addQueryFilter(String key, Collection<S> values, QueryBuilder builder, QueryOperation op,\n-                                               QueryOperation intraOp, Function<S, T> map) {\n-        QueryBuilder auxBuilder;\n-        if (op == VariantQueryUtils.QueryOperation.OR) {\n-            auxBuilder = QueryBuilder.start();\n+  }\n+\n+  private DBObject[] getFileFilterDBObjects(String key, List<String> filterValues) {\n+    DBObject[] regexList = new DBObject[filterValues.size()];\n+    for (int i = 0; i < filterValues.size(); i++) {\n+      String filter = filterValues.get(i);\n+      boolean negated = isNegated(filter);\n+      if (negated) {\n+        filter = removeNegation(filter);\n+      }\n+      if (filter.contains(VCFConstants.FILTER_CODE_SEPARATOR) || filter.equals(VCFConstants.PASSES_FILTERS_v4)) {\n+        if (!negated) {\n+          regexList[i] = new BasicDBObject(key, filter);\n         } else {\n-            auxBuilder = builder;\n+          regexList[i] = new BasicDBObject(key, new BasicDBObject(\"$ne\", filter));\n         }\n-\n-        if (values.size() == 1) {\n-            S elem = values.iterator().next();\n-            if (elem instanceof String && isNegated((String) elem)) {\n-                T mapped = map.apply((S) removeNegation((String) elem));\n-                if (mapped instanceof Collection) {\n-                    auxBuilder.and(key).notIn(mapped);\n-                } else {\n-                    auxBuilder.and(key).notEquals(mapped);\n-                }\n-            } else {\n-                T mapped = map.apply(elem);\n-                if (mapped instanceof Collection) {\n-                    auxBuilder.and(key).in(mapped);\n-                } else {\n-                    auxBuilder.and(key).is(mapped);\n-                }\n-            }\n-        } else if (intraOp == QueryOperation.OR) {\n-            List<Object> list = new ArrayList<>(values.size());\n-            for (S elem : values) {\n-                if (elem instanceof String && isNegated((String) elem)) {\n-                    throw new VariantQueryException(\"Unable to use negate (!) operator in OR sequences (<it_1>(,<it_n>)*)\");\n-                } else {\n-                    T mapped = map.apply(elem);\n-                    if (mapped instanceof Collection) {\n-                        list.addAll(((Collection) mapped));\n-                    } else {\n-                        list.add(mapped);\n-                    }\n-                }\n-            }\n-            if (list.size() == 1) {\n-                auxBuilder.and(key).is(list);\n-            } else {\n-                auxBuilder.and(key).in(list);\n-            }\n+      } else {\n+        if (!negated) {\n+          regexList[i] = new BasicDBObject(key, new BasicDBObject(\"$regex\", filter));\n         } else {\n-            //Split in two lists: positive and negative\n-            List<Object> listIs = new ArrayList<>(values.size());\n-            List<Object> listNotIs = new ArrayList<>(values.size());\n-\n-            for (S elem : values) {\n-                if (elem instanceof String && isNegated((String) elem)) {\n-                    T mapped = map.apply((S) removeNegation((String) elem));\n-                    if (mapped instanceof Collection) {\n-                        listNotIs.addAll(((Collection) mapped));\n-                    } else {\n-                        listNotIs.add(mapped);\n-                    }\n+          regexList[i] = new BasicDBObject(key, new BasicDBObject(\"$not\", Pattern.compile(filter)));\n+        }\n+      }\n+    }\n+    return regexList;\n+  }\n+\n+  private void parseStatsQueryParams(Query query, QueryBuilder builder, StudyMetadata defaultStudy) {\n+    if (query != null) {\n+      if (query.get(COHORT.key()) != null && !query.getString(COHORT.key()).isEmpty()) {\n+        addQueryFilter(DocumentToVariantConverter.STATS_FIELD\n+                + '.' + DocumentToVariantStatsConverter.COHORT_ID,\n+            query.getString(COHORT.key()), builder, QueryOperation.AND,\n+            s -> {\n+              try {\n+                return Integer.parseInt(s);\n+              } catch (NumberFormatException ignore) {\n+                String[] split = VariantQueryUtils.splitStudyResource(s);\n+                if (defaultStudy == null && split.length == 1) {\n+                  throw VariantQueryException.malformedParam(COHORT, s, \"Expected {study}:{cohort}\");\n                 } else {\n-                    T mapped = map.apply(elem);\n-                    if (mapped instanceof Collection) {\n-                        listIs.addAll(((Collection) mapped));\n-                    } else {\n-                        listIs.add(mapped);\n+                  String study;\n+                  String cohort;\n+                  Integer cohortId;\n+                  if (defaultStudy != null && split.length == 1) {\n+                    cohort = s;\n+                    cohortId = metadataManager.getCohortId(defaultStudy.getId(), cohort);\n+                    if (cohortId == null) {\n+                      List<String> availableCohorts = new LinkedList<>();\n+                      metadataManager.cohortIterator(defaultStudy.getId())\n+                          .forEachRemaining(c -> availableCohorts.add(c.getName()));\n+                      throw VariantQueryException.cohortNotFound(cohort, defaultStudy.getId(), availableCohorts);\n                     }\n+                  } else {\n+                    study = split[0];\n+                    cohort = split[1];\n+                    int studyId = metadataManager.getStudyId(study);\n+                    cohortId = metadataManager.getCohortId(studyId, cohort);\n+                  }\n+                  return cohortId;\n                 }\n-            }\n-\n-            if (!listIs.isEmpty()) {    //Can not use method \"is\" because it will be overwritten with the \"notEquals\" or \"notIn\" method\n-                auxBuilder.and(key).all(listIs);\n-            }\n-            if (listNotIs.size() == 1) {\n-                auxBuilder.and(key).notEquals(listNotIs.get(0));\n-            } else if (listNotIs.size() > 1) {\n-                auxBuilder.and(key).notIn(listNotIs);\n-            }\n-\n-        }\n-\n-        if (op == VariantQueryUtils.QueryOperation.OR) {\n-            builder.or(auxBuilder.get());\n+              }\n+            });\n+      }\n+\n+      if (query.get(STATS_REF.key()) != null && !query.getString(STATS_REF.key()).isEmpty()) {\n+        addStatsFilterList(DocumentToVariantStatsConverter.REF_FREQ_FIELD, query.getString(STATS_REF.key()),\n+            builder, defaultStudy);\n+      }\n+\n+      if (query.get(STATS_ALT.key()) != null && !query.getString(STATS_ALT.key()).isEmpty()) {\n+        addStatsFilterList(DocumentToVariantStatsConverter.ALT_FREQ_FIELD, query.getString(STATS_ALT.key()),\n+            builder, defaultStudy);\n+      }\n+\n+      if (query.get(STATS_MAF.key()) != null && !query.getString(STATS_MAF.key()).isEmpty()) {\n+        addStatsFilterList(DocumentToVariantStatsConverter.MAF_FIELD, query.getString(STATS_MAF.key()),\n+            builder, defaultStudy);\n+      }\n+\n+      if (query.get(STATS_MGF.key()) != null && !query.getString(STATS_MGF.key()).isEmpty()) {\n+        addStatsFilterList(DocumentToVariantStatsConverter.MGF_FIELD, query.getString(STATS_MGF.key()),\n+            builder, defaultStudy);\n+      }\n+\n+      if (query.get(MISSING_ALLELES.key()) != null && !query.getString(MISSING_ALLELES.key())\n+          .isEmpty()) {\n+        addStatsFilterList(DocumentToVariantStatsConverter.MISSALLELE_FIELD, query.getString(MISSING_ALLELES\n+            .key()), builder, defaultStudy);\n+      }\n+\n+      if (query.get(MISSING_GENOTYPES.key()) != null && !query.getString(MISSING_GENOTYPES\n+          .key()).isEmpty()) {\n+        addStatsFilterList(DocumentToVariantStatsConverter.MISSGENOTYPE_FIELD, query.getString(\n+            MISSING_GENOTYPES.key()), builder, defaultStudy);\n+      }\n+\n+      if (query.get(\"numgt\") != null && !query.getString(\"numgt\").isEmpty()) {\n+        for (String numgt : query.getAsStringList(\"numgt\")) {\n+          String[] split = numgt.split(\":\");\n+          addCompQueryFilter(\n+              DocumentToVariantConverter.STATS_FIELD + '.' + DocumentToVariantStatsConverter.NUMGT_FIELD + '.' + split[0],\n+              split[1], builder, false);\n         }\n-        return builder;\n+      }\n     }\n+  }\n \n-    /**\n-     * Accept a list of comparative filters separated with \",\" or \";\" with the expression:\n-     * {OPERATION}{VALUE}, where the accepted operations are: <, <=, >, >=, =, ==, !=, ~=.\n-     *\n-     * @param key\n-     * @param value\n-     * @param builder\n-     * @param extendKey\n-     * @return\n-     */\n-    private QueryBuilder addCompListQueryFilter(String key, String value, QueryBuilder builder, boolean extendKey) {\n-        VariantQueryUtils.QueryOperation op = checkOperator(value);\n-        List<String> values = splitValue(value, op);\n-\n-        QueryBuilder compBuilder;\n-        if (op == QueryOperation.OR) {\n-            compBuilder = QueryBuilder.start();\n-        } else {\n-            compBuilder = builder;\n-        }\n+  protected Document createProjection(Query query, QueryOptions options) {\n+    return createProjection(query, options, VariantQueryUtils.parseVariantQueryFields(query, options, metadataManager));\n+  }\n \n-        for (String elem : values) {\n-            addCompQueryFilter(key, elem, compBuilder, extendKey);\n-        }\n+  protected Document createProjection(Query query, QueryOptions options, VariantQueryFields selectVariantElements) {\n+    if (options == null) {\n+      options = new QueryOptions();\n+    }\n \n-        if (op == QueryOperation.OR) {\n-            builder.or(compBuilder.get());\n-        }\n-        return builder;\n+    Document projection = new Document();\n+\n+    if (options.containsKey(QueryOptions.SORT) && !(\"_id\").equals(options.getString(QueryOptions.SORT))) {\n+      if (options.getBoolean(QueryOptions.SORT)) {\n+        options.put(QueryOptions.SORT, \"_id\");\n+        options.putIfAbsent(QueryOptions.ORDER, QueryOptions.ASCENDING);\n+      } else {\n+        options.remove(QueryOptions.SORT);\n+      }\n     }\n \n-    private QueryBuilder addCompQueryFilter(String key, String value, QueryBuilder builder, boolean extendKey) {\n-        String[] strings = splitOperator(value);\n-        String op = \"\";\n-        if (strings.length == 3) {\n-            if (extendKey && !strings[0].isEmpty()) {\n-                key = key + \".\" + strings[0];\n-            }\n-            value = strings[2];\n-            op = strings[1];\n-        }\n-        return addCompQueryFilter(key, value, builder, op);\n+    Set<VariantField> returnedFields = new HashSet<>(selectVariantElements.getFields());\n+    // Add all required fields\n+    returnedFields.addAll(DocumentToVariantConverter.REQUIRED_FIELDS_SET);\n+    // StudyID is mandatory if returning any STUDY element\n+    if (returnedFields.contains(VariantField.STUDIES)) {\n+      returnedFields.add(VariantField.STUDIES_STUDY_ID);\n     }\n \n-    private QueryBuilder addCompQueryFilter(String key, String obj, QueryBuilder builder, String op) {\n \n-        switch (op) {\n-            case \"<\":\n-                builder.and(key).lessThan(Double.parseDouble(obj));\n-                break;\n-            case \"<<\":\n-                builder.and(new BasicDBObject(\"$or\", Arrays.asList(\n-                        QueryBuilder.start(key).lessThan(Double.parseDouble(obj)).get(),\n-                        QueryBuilder.start(key).exists(false).get()\n-                )));\n-                break;\n-            case \"<=\":\n-                builder.and(key).lessThanEquals(Double.parseDouble(obj));\n-                break;\n-            case \"<<=\":\n-                builder.and(new BasicDBObject(\"$or\", Arrays.asList(\n-                        QueryBuilder.start(key).lessThanEquals(Double.parseDouble(obj)).get(),\n-                        QueryBuilder.start(key).exists(false).get()\n-                )));\n-                break;\n-            case \">\":\n-                builder.and(key).greaterThan(Double.parseDouble(obj));\n-                break;\n-            case \">>\":\n-                builder.and(new BasicDBObject(\"$or\", Arrays.asList(\n-                        QueryBuilder.start(key).greaterThan(Double.parseDouble(obj)).get(),\n-                        QueryBuilder.start(key).exists(false).get()\n-                )));\n-                break;\n-            case \">=\":\n-                builder.and(key).greaterThanEquals(Double.parseDouble(obj));\n-                break;\n-            case \">>=\":\n-                builder.and(new BasicDBObject(\"$or\", Arrays.asList(\n-                        QueryBuilder.start(key).greaterThanEquals(Double.parseDouble(obj)).get(),\n-                        QueryBuilder.start(key).exists(false).get()\n-                )));\n-                break;\n-            case \"=\":\n-            case \"==\":\n-                try {\n-                    builder.and(key).is(Double.parseDouble(obj));\n-                } catch (NumberFormatException e) {\n-                    builder.and(key).is(obj);\n-                }\n-                break;\n-            case \"!=\":\n-                try {\n-                    builder.and(key).notEquals(Double.parseDouble(obj));\n-                } catch (NumberFormatException e) {\n-                    builder.and(key).notEquals(obj);\n-                }\n-                break;\n-            case \"~=\":\n-            case \"~\":\n-                builder.and(key).regex(Pattern.compile(obj));\n-                break;\n-            default:\n-                break;\n+    // Top level $elemMatch MUST be at the very beginning in the projection document, so all the fields apply correctly.\n+    //\n+    // This two queries return different values:\n+    //\n+    // > db.variants.find({}, {studies:{$elemMatch:{sid:1}}, \"studies.files\":1})\n+    // {  studies : [ { sid : 1, files : [ ... ] } ]  }\n+    //\n+    // > db.variants.find({}, {\"studies.files\":1, studies:{$elemMatch:{sid:1}}})\n+    // {  studies : [ { sid : 1, files : [ ... ] , gt : { ... } } ]  }\n+    List<Integer> studiesIds = selectVariantElements.getStudies();\n+    // Use elemMatch only if there is one study to return.\n+    if (studiesIds.size() == 1) {\n+      projection.put(\n+          DocumentToVariantConverter.STUDIES_FIELD,\n+          new Document(\n+              \"$elemMatch\",\n+              new Document(\n+                  DocumentToStudyVariantEntryConverter.STUDYID_FIELD,\n+                  new Document(\n+                      \"$in\",\n+                      studiesIds\n+                  )\n+              )\n+          )\n+      );\n+    }\n+\n+    if (returnedFields.contains(VariantField.STUDIES_SAMPLES_DATA)) {\n+      List<String> formats = VariantQueryUtils.getIncludeFormats(query);\n+      if (formats != null) { // If null, undefined. Return all\n+        // Special conversion\n+        returnedFields.remove(VariantField.STUDIES_SAMPLES_DATA);\n+\n+        for (String format : formats) {\n+          if (format.equals(GT)) {\n+            projection.put(DocumentToVariantConverter.STUDIES_FIELD + '.'\n+                + DocumentToStudyVariantEntryConverter.GENOTYPES_FIELD, 1);\n+          } else {\n+            projection.put(DocumentToVariantConverter.STUDIES_FIELD + '.'\n+                + DocumentToStudyVariantEntryConverter.FILES_FIELD + '.'\n+                + DocumentToStudyVariantEntryConverter.SAMPLE_DATA_FIELD + '.' + format.toLowerCase(), 1);\n+          }\n+          projection.put(DocumentToVariantConverter.STUDIES_FIELD + '.'\n+              + DocumentToStudyVariantEntryConverter.FILES_FIELD + '.'\n+              + DocumentToStudyVariantEntryConverter.FILEID_FIELD, 1);\n         }\n-        return builder;\n+      }\n     }\n \n-    private QueryBuilder addStringCompQueryFilter(VariantQueryParam param, String key, String value, QueryBuilder builder) {\n-        String[] split = splitOperator(value);\n-        String op = split[1];\n-        String obj = split[2];\n+    returnedFields = VariantField.prune(returnedFields);\n \n-        switch (op) {\n-            case \"!=\":\n-            case \"!\":\n-                builder.and(key).notEquals(obj);\n-                break;\n-            case \"~=\":\n-            case \"~\":\n-                builder.and(key).regex(Pattern.compile(obj));\n-                break;\n-            case \"\":\n-            case \"=\":\n-            case \"==\":\n-                builder.and(key).is(obj);\n-                break;\n-            default:\n-                throw VariantQueryException.malformedParam(param, value, \"Unsupported operator \" + op);\n+    if (!returnedFields.isEmpty()) { //Include some\n+      for (VariantField s : returnedFields) {\n+        List<String> keys = DocumentToVariantConverter.toShortFieldName(s);\n+        if (keys != null) {\n+          for (String key : keys) {\n+            // Put if absent. Do not overwrite $elemMatch, if any\n+            projection.putIfAbsent(key, 1);\n+          }\n+        } else {\n+          logger.warn(\"Unknown include field: {}\", s);\n         }\n-        return builder;\n+      }\n     }\n \n-    /**\n-     * Accepts a list of filters separated with \",\" or \";\" with the expression: {SCORE}{OPERATION}{VALUE}.\n-     *\n-     * @param value        Value to parse\n-     * @param builder      QueryBuilder\n-     * @param scoreParam Score query param\n-     * @param allowDescriptionFilter Use string values as filters for the score description\n-     * @return QueryBuilder\n-     */\n-    private QueryBuilder addScoreFilter(String value, QueryBuilder builder, VariantQueryParam scoreParam,\n-                                        boolean allowDescriptionFilter) {\n-        return addScoreFilter(value, builder, scoreParam, null, allowDescriptionFilter);\n+    if (query.getBoolean(VARIANTS_TO_INDEX.key(), false)) {\n+      projection.putIfAbsent(INDEX_FIELD, 1);\n     }\n \n-    /**\n-     * Accepts a list of filters separated with \",\" or \";\" with the expression: {SOURCE}{OPERATION}{VALUE}.\n-     *\n-     * @param value         Value to parse\n-     * @param builder       QueryBuilder\n-     * @param scoreParam    Score VariantQueryParam\n-     * @param defaultSource Default source value. If null, must be present in the filter. If not, must not be present.\n-     * @param allowDescriptionFilter Use string values as filters for the score description\n-     * @return QueryBuilder\n-     */\n-    private QueryBuilder addScoreFilter(String value, QueryBuilder builder, VariantQueryParam scoreParam, final String defaultSource,\n-                                        boolean allowDescriptionFilter) {\n-        final List<String> list;\n-        QueryOperation operation = checkOperator(value);\n-        list = splitValue(value, operation);\n-        List<DBObject> dbObjects = new ArrayList<>();\n-        for (String elem : list) {\n-            String[] score = VariantQueryUtils.splitOperator(elem);\n-            String source;\n-            String op;\n-            String scoreValue;\n-            // No given score\n-            if (StringUtils.isEmpty(score[0])) {\n-                if (defaultSource == null) {\n-                    logger.error(\"Bad score filter: \" + elem);\n-                    throw VariantQueryException.malformedParam(scoreParam, value);\n-                }\n-                source = defaultSource;\n-                op = score[1];\n-                scoreValue = score[2];\n-            } else {\n-                if (defaultSource != null) {\n-                    logger.error(\"Bad score filter: \" + elem);\n-                    throw VariantQueryException.malformedParam(scoreParam, value);\n-                }\n-                source = score[0];\n-                op = score[1];\n-                scoreValue = score[2];\n-            }\n-\n-            String key = DocumentToVariantAnnotationConverter.SCORE_FIELD_MAP.get(source);\n-            if (key == null) {\n-                // Unknown score\n-                throw VariantQueryException.malformedParam(scoreParam, value);\n-            }\n+    logger.debug(\"QueryOptions: = {}\", options.toJson());\n+    logger.debug(\"Projection:   = {}\", projection.toJson(new JsonWriterSettings(JsonMode.SHELL, false)));\n+    return projection;\n+  }\n+\n+  private QueryBuilder addQueryStringFilter(String key, String value, final QueryBuilder builder, VariantQueryUtils.QueryOperation op) {\n+    return this.addQueryFilter(key, value, builder, op, Function.identity());\n+  }\n+\n+  private QueryBuilder addQueryStringFilter(String key, List<String> value, final QueryBuilder builder,\n+                                            VariantQueryUtils.QueryOperation op) {\n+    return this.addQueryFilter(key, value, builder, op, Function.identity());\n+  }\n+\n+  private QueryBuilder addQueryIntegerFilter(String key, String value, final QueryBuilder builder, VariantQueryUtils.QueryOperation op) {\n+    return this.addQueryFilter(key, value, builder, op, elem -> {\n+      try {\n+        return Integer.parseInt(elem);\n+      } catch (NumberFormatException e) {\n+        throw new VariantQueryException(\"Unable to parse int \" + elem, e);\n+      }\n+    });\n+  }\n+\n+  private QueryBuilder addQueryIntegerFilter(String key, Collection<Integer> value, final QueryBuilder builder,\n+                                             VariantQueryUtils.QueryOperation op) {\n+    return this.addQueryFilter(key, value, builder, op);\n+  }\n+\n+  private <T> QueryBuilder addQueryFilter(String key, String value, final QueryBuilder builder, QueryOperation op,\n+                                          Function<String, T> map) {\n+    VariantQueryUtils.QueryOperation intraOp = checkOperator(value);\n+    return addQueryFilter(key, splitValue(value, intraOp), builder, op, intraOp, map);\n+  }\n+\n+  private <T> QueryBuilder addQueryFilter(String key, Collection<T> value, final QueryBuilder builder, QueryOperation op) {\n+    return addQueryFilter(key, value, builder, op, t -> t);\n+  }\n+\n+  private <S, T> QueryBuilder addQueryFilter(String key, Collection<S> value, final QueryBuilder builder, QueryOperation op,\n+                                             Function<S, T> map) {\n+    return addQueryFilter(key, value, builder, op, QueryOperation.OR, map);\n+  }\n+\n+  private <S, T> QueryBuilder addQueryFilter(String key, Collection<S> values, QueryBuilder builder, QueryOperation op,\n+                                             QueryOperation intraOp, Function<S, T> map) {\n+    QueryBuilder auxBuilder;\n+    if (op == VariantQueryUtils.QueryOperation.OR) {\n+      auxBuilder = QueryBuilder.start();\n+    } else {\n+      auxBuilder = builder;\n+    }\n \n-            QueryBuilder scoreBuilder = new QueryBuilder();\n-            if (NumberUtils.isParsable(scoreValue)) {\n-                // Query by score\n-                key += '.' + DocumentToVariantAnnotationConverter.SCORE_SCORE_FIELD;\n-                addCompQueryFilter(key, scoreValue, scoreBuilder, op);\n-            } else if (allowDescriptionFilter) {\n-                // Query by description\n-                key += '.' + DocumentToVariantAnnotationConverter.SCORE_DESCRIPTION_FIELD;\n-                addStringCompQueryFilter(scoreParam, key, scoreValue, scoreBuilder);\n-            } else {\n-                throw VariantQueryException.malformedParam(scoreParam, value);\n-            }\n-            dbObjects.add(scoreBuilder.get());\n+    if (values.size() == 1) {\n+      S elem = values.iterator().next();\n+      if (elem instanceof String && isNegated((String) elem)) {\n+        T mapped = map.apply((S) removeNegation((String) elem));\n+        if (mapped instanceof Collection) {\n+          auxBuilder.and(key).notIn(mapped);\n+        } else {\n+          auxBuilder.and(key).notEquals(mapped);\n         }\n-\n-        if (!dbObjects.isEmpty()) {\n-            if (operation == null || operation == QueryOperation.AND) {\n-                builder.and(dbObjects.toArray(new DBObject[dbObjects.size()]));\n-            } else {\n-                builder.and(new BasicDBObject(\"$or\", dbObjects));\n-            }\n+      } else {\n+        T mapped = map.apply(elem);\n+        if (mapped instanceof Collection) {\n+          auxBuilder.and(key).in(mapped);\n+        } else {\n+          auxBuilder.and(key).is(mapped);\n+        }\n+      }\n+    } else if (intraOp == QueryOperation.OR) {\n+      List<Object> list = new ArrayList<>(values.size());\n+      for (S elem : values) {\n+        if (elem instanceof String && isNegated((String) elem)) {\n+          throw new VariantQueryException(\"Unable to use negate (!) operator in OR sequences (<it_1>(,<it_n>)*)\");\n+        } else {\n+          T mapped = map.apply(elem);\n+          if (mapped instanceof Collection) {\n+            list.addAll(((Collection) mapped));\n+          } else {\n+            list.add(mapped);\n+          }\n         }\n-        return builder;\n+      }\n+      if (list.size() == 1) {\n+        auxBuilder.and(key).is(list);\n+      } else {\n+        auxBuilder.and(key).in(list);\n+      }\n+    } else {\n+      //Split in two lists: positive and negative\n+      List<Object> listIs = new ArrayList<>(values.size());\n+      List<Object> listNotIs = new ArrayList<>(values.size());\n+\n+      for (S elem : values) {\n+        if (elem instanceof String && isNegated((String) elem)) {\n+          T mapped = map.apply((S) removeNegation((String) elem));\n+          if (mapped instanceof Collection) {\n+            listNotIs.addAll(((Collection) mapped));\n+          } else {\n+            listNotIs.add(mapped);\n+          }\n+        } else {\n+          T mapped = map.apply(elem);\n+          if (mapped instanceof Collection) {\n+            listIs.addAll(((Collection) mapped));\n+          } else {\n+            listIs.add(mapped);\n+          }\n+        }\n+      }\n+\n+      if (!listIs.isEmpty()) {    //Can not use method \"is\" because it will be overwritten with the \"notEquals\" or \"notIn\" method\n+        auxBuilder.and(key).all(listIs);\n+      }\n+      if (listNotIs.size() == 1) {\n+        auxBuilder.and(key).notEquals(listNotIs.get(0));\n+      } else if (listNotIs.size() > 1) {\n+        auxBuilder.and(key).notIn(listNotIs);\n+      }\n+\n     }\n \n-    /**\n-     * Accepts a list of filters separated with \",\" or \";\" with the expression:\n-     * {STUDY}:{POPULATION}{OPERATION}{VALUE}.\n-     *\n-     * @param key                  PopulationFrequency schema field\n-     * @param alleleFrequencyField Allele frequency schema field\n-     * @param value                Value to parse\n-     * @param builder              QueryBuilder\n-     * @param queryParam           QueryParam filter\n-     * @return QueryBuilder\n-     */\n-    private QueryBuilder addFrequencyFilter(String key, String alleleFrequencyField, String value, QueryBuilder builder,\n-                                            VariantQueryParam queryParam, boolean alternate) {\n-        return addFrequencyFilter(key, value, builder, queryParam, alternate,\n-                (v, qb) -> addCompQueryFilter(alleleFrequencyField, v, qb, false));\n+    if (op == VariantQueryUtils.QueryOperation.OR) {\n+      builder.or(auxBuilder.get());\n+    }\n+    return builder;\n+  }\n+\n+  /**\n+   * Accept a list of comparative filters separated with \",\" or \";\" with the expression:\n+   * {OPERATION}{VALUE}, where the accepted operations are: <, <=, >, >=, =, ==, !=, ~=.\n+   *\n+   * @param key\n+   * @param value\n+   * @param builder\n+   * @param extendKey\n+   * @return\n+   */\n+  private QueryBuilder addCompListQueryFilter(String key, String value, QueryBuilder builder, boolean extendKey) {\n+    VariantQueryUtils.QueryOperation op = checkOperator(value);\n+    List<String> values = splitValue(value, op);\n+\n+    QueryBuilder compBuilder;\n+    if (op == QueryOperation.OR) {\n+      compBuilder = QueryBuilder.start();\n+    } else {\n+      compBuilder = builder;\n     }\n \n-    /**\n-     * Accepts a list of filters separated with \",\" or \";\" with the expression:\n-     * {STUDY}:{POPULATION}{OPERATION}{VALUE}.\n-     *\n-     * @param key       PopulationFrequency schema field\n-     * @param value     Value to parse\n-     * @param builder   QueryBuilder\n-     * @param addFilter For complex filter\n-     * @return QueryBuilder\n-     */\n-    private QueryBuilder addFrequencyFilter(String key, String value, QueryBuilder builder, VariantQueryParam queryParam,\n-                                            boolean alternate, BiConsumer<String, QueryBuilder> addFilter) {\n-        final List<String> list;\n-        QueryOperation operation = checkOperator(value);\n-        list = splitValue(value, operation);\n-\n-        List<BasicDBObject> dbObjects = new ArrayList<>();\n-        for (String elem : list) {\n-            String[] split = elem.split(IS);\n-            if (split.length != 2) {\n-                logger.error(\"Bad population frequency filter: \" + elem);\n-                throw VariantQueryException.malformedParam(queryParam, value);\n-                //new IllegalArgumentException(\"Bad population frequency filter: \" + elem);\n-            }\n-            String study = split[0];\n-            String populationFrequency = split[1];\n-            String[] populationFrequencySplit = splitOperator(populationFrequency);\n-            String population = populationFrequencySplit[0];\n-            String operator = populationFrequencySplit[1];\n-            String numValue = populationFrequencySplit[2];\n-            if (operator.startsWith(\">>\") || operator.startsWith(\"<<\")) {\n-                // Remove first char\n-                operator = operator.substring(1);\n-            }\n+    for (String elem : values) {\n+      addCompQueryFilter(key, elem, compBuilder, extendKey);\n+    }\n \n-            logger.debug(\"populationFrequency = \" + Arrays.toString(populationFrequencySplit));\n-\n-            QueryBuilder frequencyBuilder = new QueryBuilder();\n-            frequencyBuilder.and(DocumentToVariantAnnotationConverter.POPULATION_FREQUENCY_STUDY_FIELD).is(study);\n-            frequencyBuilder.and(DocumentToVariantAnnotationConverter.POPULATION_FREQUENCY_POP_FIELD).is(population);\n-            Document studyPopFilter = new Document(frequencyBuilder.get().toMap());\n-            addFilter.accept(operator + numValue, frequencyBuilder);\n-            BasicDBObject elemMatch = new BasicDBObject(key, new BasicDBObject(\"$elemMatch\", frequencyBuilder.get()));\n-            if (alternate && operator.startsWith(\"<\") || !alternate && operator.startsWith(\">\")) {\n-                BasicDBObject orNotExistsAnyPopulation = new BasicDBObject(key, new BasicDBObject(\"$exists\", false));\n-                BasicDBObject orNotExistsPopulation =\n-                        new BasicDBObject(key, new BasicDBObject(\"$not\", new BasicDBObject(\"$elemMatch\", studyPopFilter)));\n-                dbObjects.add(new BasicDBObject(\"$or\", Arrays.asList(orNotExistsAnyPopulation, orNotExistsPopulation, elemMatch)));\n-            } else {\n-                dbObjects.add(elemMatch);\n-            }\n+    if (op == QueryOperation.OR) {\n+      builder.or(compBuilder.get());\n+    }\n+    return builder;\n+  }\n+\n+  private QueryBuilder addCompQueryFilter(String key, String value, QueryBuilder builder, boolean extendKey) {\n+    String[] strings = splitOperator(value);\n+    String op = \"\";\n+    if (strings.length == 3) {\n+      if (extendKey && !strings[0].isEmpty()) {\n+        key = key + \".\" + strings[0];\n+      }\n+      value = strings[2];\n+      op = strings[1];\n+    }\n+    return addCompQueryFilter(key, value, builder, op);\n+  }\n+\n+  private QueryBuilder addCompQueryFilter(String key, String obj, QueryBuilder builder, String op) {\n+\n+    switch (op) {\n+      case \"<\":\n+        builder.and(key).lessThan(Double.parseDouble(obj));\n+        break;\n+      case \"<<\":\n+        builder.and(new BasicDBObject(\"$or\", Arrays.asList(\n+            QueryBuilder.start(key).lessThan(Double.parseDouble(obj)).get(),\n+            QueryBuilder.start(key).exists(false).get()\n+        )));\n+        break;\n+      case \"<=\":\n+        builder.and(key).lessThanEquals(Double.parseDouble(obj));\n+        break;\n+      case \"<<=\":\n+        builder.and(new BasicDBObject(\"$or\", Arrays.asList(\n+            QueryBuilder.start(key).lessThanEquals(Double.parseDouble(obj)).get(),\n+            QueryBuilder.start(key).exists(false).get()\n+        )));\n+        break;\n+      case \">\":\n+        builder.and(key).greaterThan(Double.parseDouble(obj));\n+        break;\n+      case \">>\":\n+        builder.and(new BasicDBObject(\"$or\", Arrays.asList(\n+            QueryBuilder.start(key).greaterThan(Double.parseDouble(obj)).get(),\n+            QueryBuilder.start(key).exists(false).get()\n+        )));\n+        break;\n+      case \">=\":\n+        builder.and(key).greaterThanEquals(Double.parseDouble(obj));\n+        break;\n+      case \">>=\":\n+        builder.and(new BasicDBObject(\"$or\", Arrays.asList(\n+            QueryBuilder.start(key).greaterThanEquals(Double.parseDouble(obj)).get(),\n+            QueryBuilder.start(key).exists(false).get()\n+        )));\n+        break;\n+      case \"=\":\n+      case \"==\":\n+        try {\n+          builder.and(key).is(Double.parseDouble(obj));\n+        } catch (NumberFormatException e) {\n+          builder.and(key).is(obj);\n         }\n-        if (!dbObjects.isEmpty()) {\n-            if (operation == null || operation == QueryOperation.AND) {\n-                builder.and(dbObjects.toArray(new BasicDBObject[dbObjects.size()]));\n-            } else {\n-                builder.and(new BasicDBObject(\"$or\", dbObjects));\n-            }\n+        break;\n+      case \"!=\":\n+        try {\n+          builder.and(key).notEquals(Double.parseDouble(obj));\n+        } catch (NumberFormatException e) {\n+          builder.and(key).notEquals(obj);\n         }\n-        return builder;\n+        break;\n+      case \"~=\":\n+      case \"~\":\n+        builder.and(key).regex(Pattern.compile(obj));\n+        break;\n+      default:\n+        break;\n     }\n-\n-    /**\n-     * Accept filters separated with \",\" or \";\" with the expression:\n-     * [{STUDY}:]{COHORT}{OPERATION}{VALUE}.\n-     * Where STUDY is optional if defaultStudyMetadata is provided\n-     *\n-     * @param key                       Stats field to filter\n-     * @param values                    Values to parse\n-     * @param builder                   QueryBuilder\n-     * @param defaultStudyMetadata\n-     */\n-    private void addStatsFilterList(String key, String values, QueryBuilder builder, StudyMetadata defaultStudyMetadata) {\n-        QueryOperation op = checkOperator(values);\n-        List<String> valuesList = splitValue(values, op);\n-        List<DBObject> statsQueries = new LinkedList<>();\n-        for (String value : valuesList) {\n-            statsQueries.add(addStatsFilter(key, value, new QueryBuilder(), defaultStudyMetadata).get());\n+    return builder;\n+  }\n+\n+  private QueryBuilder addStringCompQueryFilter(VariantQueryParam param, String key, String value, QueryBuilder builder) {\n+    String[] split = splitOperator(value);\n+    String op = split[1];\n+    String obj = split[2];\n+\n+    switch (op) {\n+      case \"!=\":\n+      case \"!\":\n+        builder.and(key).notEquals(obj);\n+        break;\n+      case \"~=\":\n+      case \"~\":\n+        builder.and(key).regex(Pattern.compile(obj));\n+        break;\n+      case \"\":\n+      case \"=\":\n+      case \"==\":\n+        builder.and(key).is(obj);\n+        break;\n+      default:\n+        throw VariantQueryException.malformedParam(param, value, \"Unsupported operator \" + op);\n+    }\n+    return builder;\n+  }\n+\n+  /**\n+   * Accepts a list of filters separated with \",\" or \";\" with the expression: {SCORE}{OPERATION}{VALUE}.\n+   *\n+   * @param value                  Value to parse\n+   * @param builder                QueryBuilder\n+   * @param scoreParam             Score query param\n+   * @param allowDescriptionFilter Use string values as filters for the score description\n+   * @return QueryBuilder\n+   */\n+  private QueryBuilder addScoreFilter(String value, QueryBuilder builder, VariantQueryParam scoreParam,\n+                                      boolean allowDescriptionFilter) {\n+    return addScoreFilter(value, builder, scoreParam, null, allowDescriptionFilter);\n+  }\n+\n+  /**\n+   * Accepts a list of filters separated with \",\" or \";\" with the expression: {SOURCE}{OPERATION}{VALUE}.\n+   *\n+   * @param value                  Value to parse\n+   * @param builder                QueryBuilder\n+   * @param scoreParam             Score VariantQueryParam\n+   * @param defaultSource          Default source value. If null, must be present in the filter. If not, must not be present.\n+   * @param allowDescriptionFilter Use string values as filters for the score description\n+   * @return QueryBuilder\n+   */\n+  private QueryBuilder addScoreFilter(String value, QueryBuilder builder, VariantQueryParam scoreParam, final String defaultSource,\n+                                      boolean allowDescriptionFilter) {\n+    final List<String> list;\n+    QueryOperation operation = checkOperator(value);\n+    list = splitValue(value, operation);\n+    List<DBObject> dbObjects = new ArrayList<>();\n+    for (String elem : list) {\n+      String[] score = VariantQueryUtils.splitOperator(elem);\n+      String source;\n+      String op;\n+      String scoreValue;\n+      // No given score\n+      if (StringUtils.isEmpty(score[0])) {\n+        if (defaultSource == null) {\n+          logger.error(\"Bad score filter: \" + elem);\n+          throw VariantQueryException.malformedParam(scoreParam, value);\n         }\n-\n-        if (!statsQueries.isEmpty()) {\n-            if (op == QueryOperation.OR) {\n-                builder.or(statsQueries.toArray(new DBObject[statsQueries.size()]));\n-            } else {\n-                builder.and(statsQueries.toArray(new DBObject[statsQueries.size()]));\n-            }\n+        source = defaultSource;\n+        op = score[1];\n+        scoreValue = score[2];\n+      } else {\n+        if (defaultSource != null) {\n+          logger.error(\"Bad score filter: \" + elem);\n+          throw VariantQueryException.malformedParam(scoreParam, value);\n         }\n+        source = score[0];\n+        op = score[1];\n+        scoreValue = score[2];\n+      }\n+\n+      String key = DocumentToVariantAnnotationConverter.SCORE_FIELD_MAP.get(source);\n+      if (key == null) {\n+        // Unknown score\n+        throw VariantQueryException.malformedParam(scoreParam, value);\n+      }\n+\n+      QueryBuilder scoreBuilder = new QueryBuilder();\n+      if (NumberUtils.isParsable(scoreValue)) {\n+        // Query by score\n+        key += '.' + DocumentToVariantAnnotationConverter.SCORE_SCORE_FIELD;\n+        addCompQueryFilter(key, scoreValue, scoreBuilder, op);\n+      } else if (allowDescriptionFilter) {\n+        // Query by description\n+        key += '.' + DocumentToVariantAnnotationConverter.SCORE_DESCRIPTION_FIELD;\n+        addStringCompQueryFilter(scoreParam, key, scoreValue, scoreBuilder);\n+      } else {\n+        throw VariantQueryException.malformedParam(scoreParam, value);\n+      }\n+      dbObjects.add(scoreBuilder.get());\n     }\n \n-    /**\n-     * Accepts filters with the expresion: [{STUDY}:]{COHORT}{OPERATION}{VALUE}.\n-     * Where STUDY is optional if defaultStudyMetadata is provided\n-     *\n-     * @param key                       Stats field to filter\n-     * @param filter                    Filter to parse\n-     * @param builder                   QueryBuilder\n-     * @param defaultStudyMetadata\n-     */\n-    private QueryBuilder addStatsFilter(String key, String filter, QueryBuilder builder, StudyMetadata defaultStudyMetadata) {\n-        String[] studyValue = VariantQueryUtils.splitStudyResource(filter);\n-        if (studyValue.length == 2 || defaultStudyMetadata != null) {\n-            int studyId;\n-            Integer cohortId;\n-            String operator;\n-            String valueStr;\n-            if (studyValue.length == 2) {\n-                String[] cohortOpValue = VariantQueryUtils.splitOperator(studyValue[1]);\n-                String study = studyValue[0];\n-                String cohort = cohortOpValue[0];\n-                operator = cohortOpValue[1];\n-                valueStr = cohortOpValue[2];\n-\n-                studyId = metadataManager.getStudyId(study);\n-                cohortId = metadataManager.getCohortId(studyId, cohort);\n-            } else {\n-//                String study = defaultStudyMetadata.getStudyName();\n-                studyId = defaultStudyMetadata.getId();\n-                String[] cohortOpValue = VariantQueryUtils.splitOperator(filter);\n-                String cohort = cohortOpValue[0];\n-                cohortId = metadataManager.getCohortId(studyId, cohort);\n-                operator = cohortOpValue[1];\n-                valueStr = cohortOpValue[2];\n-            }\n-\n-            QueryBuilder statsBuilder = new QueryBuilder();\n-            statsBuilder.and(DocumentToVariantStatsConverter.STUDY_ID).is(studyId);\n-            if (cohortId != null) {\n-                statsBuilder.and(DocumentToVariantStatsConverter.COHORT_ID).is(cohortId);\n-            }\n-            addCompQueryFilter(key, valueStr, statsBuilder, operator);\n-            builder.and(DocumentToVariantConverter.STATS_FIELD).elemMatch(statsBuilder.get());\n-        } else {\n-            addCompQueryFilter(DocumentToVariantConverter.STATS_FIELD + \".\" + key, filter, builder, false);\n-        }\n-        return builder;\n+    if (!dbObjects.isEmpty()) {\n+      if (operation == null || operation == QueryOperation.AND) {\n+        builder.and(dbObjects.toArray(new DBObject[dbObjects.size()]));\n+      } else {\n+        builder.and(new BasicDBObject(\"$or\", dbObjects));\n+      }\n     }\n-\n-    private QueryBuilder getRegionFilter(Region region, QueryBuilder builder) {\n-        List<String> chunkIds = getChunkIds(region);\n-        builder.and(DocumentToVariantConverter.AT_FIELD + '.' + DocumentToVariantConverter.CHUNK_IDS_FIELD).in(chunkIds);\n-        builder.and(DocumentToVariantConverter.END_FIELD).greaterThanEquals(region.getStart());\n-        builder.and(DocumentToVariantConverter.START_FIELD).lessThanEquals(region.getEnd());\n-        return builder;\n+    return builder;\n+  }\n+\n+  /**\n+   * Accepts a list of filters separated with \",\" or \";\" with the expression:\n+   * {STUDY}:{POPULATION}{OPERATION}{VALUE}.\n+   *\n+   * @param key                  PopulationFrequency schema field\n+   * @param alleleFrequencyField Allele frequency schema field\n+   * @param value                Value to parse\n+   * @param builder              QueryBuilder\n+   * @param queryParam           QueryParam filter\n+   * @return QueryBuilder\n+   */\n+  private QueryBuilder addFrequencyFilter(String key, String alleleFrequencyField, String value, QueryBuilder builder,\n+                                          VariantQueryParam queryParam, boolean alternate) {\n+    return addFrequencyFilter(key, value, builder, queryParam, alternate,\n+        (v, qb) -> addCompQueryFilter(alleleFrequencyField, v, qb, false));\n+  }\n+\n+  /**\n+   * Accepts a list of filters separated with \",\" or \";\" with the expression:\n+   * {STUDY}:{POPULATION}{OPERATION}{VALUE}.\n+   *\n+   * @param key       PopulationFrequency schema field\n+   * @param value     Value to parse\n+   * @param builder   QueryBuilder\n+   * @param addFilter For complex filter\n+   * @return QueryBuilder\n+   */\n+  private QueryBuilder addFrequencyFilter(String key, String value, QueryBuilder builder, VariantQueryParam queryParam,\n+                                          boolean alternate, BiConsumer<String, QueryBuilder> addFilter) {\n+    final List<String> list;\n+    QueryOperation operation = checkOperator(value);\n+    list = splitValue(value, operation);\n+\n+    List<BasicDBObject> dbObjects = new ArrayList<>();\n+    for (String elem : list) {\n+      String[] split = elem.split(IS);\n+      if (split.length != 2) {\n+        logger.error(\"Bad population frequency filter: \" + elem);\n+        throw VariantQueryException.malformedParam(queryParam, value);\n+        //new IllegalArgumentException(\"Bad population frequency filter: \" + elem);\n+      }\n+      String study = split[0];\n+      String populationFrequency = split[1];\n+      String[] populationFrequencySplit = splitOperator(populationFrequency);\n+      String population = populationFrequencySplit[0];\n+      String operator = populationFrequencySplit[1];\n+      String numValue = populationFrequencySplit[2];\n+      if (operator.startsWith(\">>\") || operator.startsWith(\"<<\")) {\n+        // Remove first char\n+        operator = operator.substring(1);\n+      }\n+\n+      logger.debug(\"populationFrequency = \" + Arrays.toString(populationFrequencySplit));\n+\n+      QueryBuilder frequencyBuilder = new QueryBuilder();\n+      frequencyBuilder.and(DocumentToVariantAnnotationConverter.POPULATION_FREQUENCY_STUDY_FIELD).is(study);\n+      frequencyBuilder.and(DocumentToVariantAnnotationConverter.POPULATION_FREQUENCY_POP_FIELD).is(population);\n+      Document studyPopFilter = new Document(frequencyBuilder.get().toMap());\n+      addFilter.accept(operator + numValue, frequencyBuilder);\n+      BasicDBObject elemMatch = new BasicDBObject(key, new BasicDBObject(\"$elemMatch\", frequencyBuilder.get()));\n+      if (alternate && operator.startsWith(\"<\") || !alternate && operator.startsWith(\">\")) {\n+        BasicDBObject orNotExistsAnyPopulation = new BasicDBObject(key, new BasicDBObject(\"$exists\", false));\n+        BasicDBObject orNotExistsPopulation =\n+            new BasicDBObject(key, new BasicDBObject(\"$not\", new BasicDBObject(\"$elemMatch\", studyPopFilter)));\n+        dbObjects.add(new BasicDBObject(\"$or\", Arrays.asList(orNotExistsAnyPopulation, orNotExistsPopulation, elemMatch)));\n+      } else {\n+        dbObjects.add(elemMatch);\n+      }\n+    }\n+    if (!dbObjects.isEmpty()) {\n+      if (operation == null || operation == QueryOperation.AND) {\n+        builder.and(dbObjects.toArray(new BasicDBObject[dbObjects.size()]));\n+      } else {\n+        builder.and(new BasicDBObject(\"$or\", dbObjects));\n+      }\n+    }\n+    return builder;\n+  }\n+\n+  /**\n+   * Accept filters separated with \",\" or \";\" with the expression:\n+   * [{STUDY}:]{COHORT}{OPERATION}{VALUE}.\n+   * Where STUDY is optional if defaultStudyMetadata is provided\n+   *\n+   * @param key                  Stats field to filter\n+   * @param values               Values to parse\n+   * @param builder              QueryBuilder\n+   * @param defaultStudyMetadata\n+   */\n+  private void addStatsFilterList(String key, String values, QueryBuilder builder, StudyMetadata defaultStudyMetadata) {\n+    QueryOperation op = checkOperator(values);\n+    List<String> valuesList = splitValue(values, op);\n+    List<DBObject> statsQueries = new LinkedList<>();\n+    for (String value : valuesList) {\n+      statsQueries.add(addStatsFilter(key, value, new QueryBuilder(), defaultStudyMetadata).get());\n     }\n \n-    private QueryBuilder getRegionFilter(List<Region> regions, QueryBuilder builder) {\n-        if (regions != null && !regions.isEmpty()) {\n-            DBObject[] objects = new DBObject[regions.size()];\n-            int i = 0;\n-            for (Region region : regions) {\n-                DBObject regionObject = new BasicDBObject();\n+    if (!statsQueries.isEmpty()) {\n+      if (op == QueryOperation.OR) {\n+        builder.or(statsQueries.toArray(new DBObject[statsQueries.size()]));\n+      } else {\n+        builder.and(statsQueries.toArray(new DBObject[statsQueries.size()]));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Accepts filters with the expresion: [{STUDY}:]{COHORT}{OPERATION}{VALUE}.\n+   * Where STUDY is optional if defaultStudyMetadata is provided\n+   *\n+   * @param key                  Stats field to filter\n+   * @param filter               Filter to parse\n+   * @param builder              QueryBuilder\n+   * @param defaultStudyMetadata\n+   */\n+  private QueryBuilder addStatsFilter(String key, String filter, QueryBuilder builder, StudyMetadata defaultStudyMetadata) {\n+    String[] studyValue = VariantQueryUtils.splitStudyResource(filter);\n+    if (studyValue.length == 2 || defaultStudyMetadata != null) {\n+      int studyId;\n+      Integer cohortId;\n+      String operator;\n+      String valueStr;\n+      if (studyValue.length == 2) {\n+        String[] cohortOpValue = VariantQueryUtils.splitOperator(studyValue[1]);\n+        String study = studyValue[0];\n+        String cohort = cohortOpValue[0];\n+        operator = cohortOpValue[1];\n+        valueStr = cohortOpValue[2];\n+\n+        studyId = metadataManager.getStudyId(study);\n+        cohortId = metadataManager.getCohortId(studyId, cohort);\n+      } else {\n+//                String study = defaultStudyMetadata.getStudyName();\n+        studyId = defaultStudyMetadata.getId();\n+        String[] cohortOpValue = VariantQueryUtils.splitOperator(filter);\n+        String cohort = cohortOpValue[0];\n+        cohortId = metadataManager.getCohortId(studyId, cohort);\n+        operator = cohortOpValue[1];\n+        valueStr = cohortOpValue[2];\n+      }\n+\n+      QueryBuilder statsBuilder = new QueryBuilder();\n+      statsBuilder.and(DocumentToVariantStatsConverter.STUDY_ID).is(studyId);\n+      if (cohortId != null) {\n+        statsBuilder.and(DocumentToVariantStatsConverter.COHORT_ID).is(cohortId);\n+      }\n+      addCompQueryFilter(key, valueStr, statsBuilder, operator);\n+      builder.and(DocumentToVariantConverter.STATS_FIELD).elemMatch(statsBuilder.get());\n+    } else {\n+      addCompQueryFilter(DocumentToVariantConverter.STATS_FIELD + \".\" + key, filter, builder, false);\n+    }\n+    return builder;\n+  }\n+\n+  private QueryBuilder getRegionFilter(Region region, QueryBuilder builder) {\n+    List<String> chunkIds = getChunkIds(region);\n+    builder.and(DocumentToVariantConverter.AT_FIELD + '.' + DocumentToVariantConverter.CHUNK_IDS_FIELD).in(chunkIds);\n+    builder.and(DocumentToVariantConverter.END_FIELD).greaterThanEquals(region.getStart());\n+    builder.and(DocumentToVariantConverter.START_FIELD).lessThanEquals(region.getEnd());\n+    return builder;\n+  }\n+\n+  private QueryBuilder getRegionFilter(List<Region> regions, QueryBuilder builder) {\n+    if (regions != null && !regions.isEmpty()) {\n+      DBObject[] objects = new DBObject[regions.size()];\n+      int i = 0;\n+      for (Region region : regions) {\n+        DBObject regionObject = new BasicDBObject();\n //                if (region.getEnd() - region.getStart() < 1000000) {\n //                    List<String> chunkIds = getChunkIds(region);\n //                    regionObject.put(DocumentToVariantConverter.AT_FIELD + '.' + DocumentToVariantConverter\n@@ -1698,52 +1698,52 @@ public class VariantMongoDBQueryParser {\n //                    regionObject.put(DocumentToVariantConverter.CHROMOSOME_FIELD, region.getChromosome());\n //                }\n \n-                int end = region.getEnd();\n-                if (end < Integer.MAX_VALUE) { // Avoid overflow\n-                    end++;\n-                }\n-                regionObject.put(\"_id\", new Document()\n-                        .append(\"$gte\", VariantStringIdConverter.buildId(region.getChromosome(), region.getStart()))\n-                        .append(\"$lt\", VariantStringIdConverter.buildId(region.getChromosome(), end)));\n-\n-                objects[i] = regionObject;\n-                i++;\n-            }\n-            builder.or(objects);\n+        int end = region.getEnd();\n+        if (end < Integer.MAX_VALUE) { // Avoid overflow\n+          end++;\n         }\n-        return builder;\n+        regionObject.put(\"_id\", new Document()\n+            .append(\"$gte\", VariantStringIdConverter.buildId(region.getChromosome(), region.getStart()))\n+            .append(\"$lt\", VariantStringIdConverter.buildId(region.getChromosome(), end)));\n+\n+        objects[i] = regionObject;\n+        i++;\n+      }\n+      builder.or(objects);\n     }\n-\n-    /* *******************\n-     * Auxiliary methods *\n-     * *******************/\n-    private List<String> getChunkIds(Region region) {\n-        List<String> chunkIds = new LinkedList<>();\n-\n-        int chunkSize = (region.getEnd() - region.getStart() > VariantMongoDBAdaptor.CHUNK_SIZE_BIG)\n-                ? VariantMongoDBAdaptor.CHUNK_SIZE_BIG\n-                : VariantMongoDBAdaptor.CHUNK_SIZE_SMALL;\n-        int ks = chunkSize / 1000;\n-        int chunkStart = region.getStart() / chunkSize;\n-        int chunkEnd = region.getEnd() / chunkSize;\n-\n-        for (int i = chunkStart; i <= chunkEnd; i++) {\n-            String chunkId = region.getChromosome() + \"_\" + i + \"_\" + ks + \"k\";\n-            chunkIds.add(chunkId);\n-        }\n-        return chunkIds;\n+    return builder;\n+  }\n+\n+  /* *******************\n+   * Auxiliary methods *\n+   * *******************/\n+  private List<String> getChunkIds(Region region) {\n+    List<String> chunkIds = new LinkedList<>();\n+\n+    int chunkSize = (region.getEnd() - region.getStart() > VariantMongoDBAdaptor.CHUNK_SIZE_BIG)\n+        ? VariantMongoDBAdaptor.CHUNK_SIZE_BIG\n+        : VariantMongoDBAdaptor.CHUNK_SIZE_SMALL;\n+    int ks = chunkSize / 1000;\n+    int chunkStart = region.getStart() / chunkSize;\n+    int chunkEnd = region.getEnd() / chunkSize;\n+\n+    for (int i = chunkStart; i <= chunkEnd; i++) {\n+      String chunkId = region.getChromosome() + \"_\" + i + \"_\" + ks + \"k\";\n+      chunkIds.add(chunkId);\n     }\n+    return chunkIds;\n+  }\n \n-    protected int getChunkId(int position, int chunksize) {\n-        return position / chunksize;\n-    }\n+  protected int getChunkId(int position, int chunksize) {\n+    return position / chunksize;\n+  }\n \n-    protected int getChunkStart(int id, int chunksize) {\n-        return (id == 0) ? 1 : id * chunksize;\n-    }\n+  protected int getChunkStart(int id, int chunksize) {\n+    return (id == 0) ? 1 : id * chunksize;\n+  }\n \n-    protected int getChunkEnd(int id, int chunksize) {\n-        return (id * chunksize) + chunksize - 1;\n-    }\n+  protected int getChunkEnd(int id, int chunksize) {\n+    return (id * chunksize) + chunksize - 1;\n+  }\n \n }\n",
            "diff_size": 2280
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "296",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 175).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "302",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 161).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "338",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "439",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 163).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "845",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 150).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1051",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 148).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1177",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 144).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "1191",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 152).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/434/VariantMongoDBQueryParser.java\nindex 7db5eca5f18..57cffa54451 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/434/VariantMongoDBQueryParser.java\n@@ -293,15 +293,13 @@ public class VariantMongoDBQueryParser {\n                 if (!geneTraitId.isEmpty()) {\n                     addQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n                                     + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_FIELD\n-                                    + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_ID_FIELD, geneTraitId, geneTraitBuilder,\n-                            internalOp, internalOp, Object::toString);\n+                                    + '.' + DocumentToVariantAnnotationConverter.GENE_TRAIT_ID_FIELD, geneTraitId, geneTraitBuilder, internalOp, internalOp, Object::toString);\n                 }\n \n                 if (!hpo.isEmpty()) {\n                     addQueryFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n                                     + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n-                                    + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD, hpo, geneTraitBuilder,\n-                            internalOp, internalOp, Object::toString);\n+                                    + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD, hpo, geneTraitBuilder, internalOp, internalOp, Object::toString);\n                 }\n \n                 if (internalOp == QueryOperation.OR) {\n@@ -353,8 +351,7 @@ public class VariantMongoDBQueryParser {\n //                        QueryOperation.AND);\n                 addQueryStringFilter(DocumentToVariantConverter.ANNOTATION_FIELD\n                                 + '.' + DocumentToVariantAnnotationConverter.XREFS_FIELD\n-                                + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD, value, builder,\n-                        QueryOperation.AND);\n+                                + '.' + DocumentToVariantAnnotationConverter.XREF_ID_FIELD, value, builder, QueryOperation.AND);\n             }\n \n //            DBObject geneTraitQuery = geneTraitBuilder.get();\n@@ -439,8 +436,7 @@ public class VariantMongoDBQueryParser {\n             if (isValidParam(query, ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY)) {\n                 String value = query.getString(ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY.key());\n                 addFrequencyFilter(DocumentToVariantConverter.ANNOTATION_FIELD + \".\"\n-                                + DocumentToVariantAnnotationConverter.POPULATION_FREQUENCIES_FIELD,\n-                        value, builder, ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY, true,\n+                                + DocumentToVariantAnnotationConverter.POPULATION_FREQUENCIES_FIELD, value, builder, ANNOT_POPULATION_MINOR_ALLELE_FREQUENCY, true,\n                         (v, queryBuilder) -> {\n                             String[] split = splitOperator(v);\n                             String op = split[1];\n@@ -452,15 +448,13 @@ public class VariantMongoDBQueryParser {\n                                     queryBuilder.or(QueryBuilder.start(DocumentToVariantAnnotationConverter.\n                                                     POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).lessThan(aDouble).get(),\n                                             QueryBuilder.start(DocumentToVariantAnnotationConverter.\n-                                                    POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).lessThan(aDouble).get()\n-                                    );\n+                                                    POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).lessThan(aDouble).get());\n                                     break;\n                                 case \"<=\":\n                                     queryBuilder.or(QueryBuilder.start(DocumentToVariantAnnotationConverter.\n                                                     POPULATION_FREQUENCY_REFERENCE_FREQUENCY_FIELD).lessThanEquals(aDouble).get(),\n                                             QueryBuilder.start(DocumentToVariantAnnotationConverter.\n-                                                    POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).lessThanEquals(aDouble).get()\n-                                    );\n+                                                    POPULATION_FREQUENCY_ALTERNATE_FREQUENCY_FIELD).lessThanEquals(aDouble).get());\n                                     break;\n                                 case \">\":\n                                     queryBuilder.and(DocumentToVariantAnnotationConverter.\n@@ -848,8 +842,7 @@ public class VariantMongoDBQueryParser {\n             } else {\n                 if (fileIdGroupsFromSamples.isEmpty()) {\n                     addQueryFilter(studyQueryPrefix + DocumentToStudyVariantEntryConverter.FILES_FIELD\n-                                    + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD,\n-                            fileNames, builder, QueryOperation.AND, filesOperation,\n+                                    + '.' + DocumentToStudyVariantEntryConverter.FILEID_FIELD, fileNames, builder, QueryOperation.AND, filesOperation,\n                             value -> {\n                                 Integer fileId = metadataManager.getFileIdPair(value, false, defaultStudy).getValue();\n                                 if (fileId == null) {\n@@ -910,7 +903,7 @@ public class VariantMongoDBQueryParser {\n \n     private void addFileGroupsFilter(QueryBuilder builder, String studyQueryPrefix, QueryOperation operation,\n                                      Set<List<Integer>> fileIdGroups, List<Integer> negatedFiles) {\n-        if (operation == QueryOperation.OR) {\n+    if (operation == QueryOperation.OR) {\n             // Merge into one single group\n             HashSet<Integer> fileIds = new HashSet<>();\n             for (List<Integer> files : fileIdGroups) {\n@@ -1055,12 +1048,10 @@ public class VariantMongoDBQueryParser {\n \n             if (query.get(MISSING_ALLELES.key()) != null && !query.getString(MISSING_ALLELES.key())\n                     .isEmpty()) {\n-                addStatsFilterList(DocumentToVariantStatsConverter.MISSALLELE_FIELD, query.getString(MISSING_ALLELES\n-                        .key()), builder, defaultStudy);\n+                addStatsFilterList(DocumentToVariantStatsConverter.MISSALLELE_FIELD, query.getString(MISSING_ALLELES.key()), builder, defaultStudy);\n             }\n \n-            if (query.get(MISSING_GENOTYPES.key()) != null && !query.getString(MISSING_GENOTYPES\n-                    .key()).isEmpty()) {\n+            if (query.get(MISSING_GENOTYPES.key()) != null && !query.getString(MISSING_GENOTYPES.key()).isEmpty()) {\n                 addStatsFilterList(DocumentToVariantStatsConverter.MISSGENOTYPE_FIELD, query.getString(\n                         MISSING_GENOTYPES.key()), builder, defaultStudy);\n             }\n@@ -1183,8 +1174,7 @@ public class VariantMongoDBQueryParser {\n         return this.addQueryFilter(key, value, builder, op, Function.identity());\n     }\n \n-    private QueryBuilder addQueryStringFilter(String key, List<String> value, final QueryBuilder builder,\n-                                              VariantQueryUtils.QueryOperation op) {\n+    private QueryBuilder addQueryStringFilter(String key, List<String> value, final QueryBuilder builder, VariantQueryUtils.QueryOperation op) {\n         return this.addQueryFilter(key, value, builder, op, Function.identity());\n     }\n \n@@ -1198,14 +1188,13 @@ public class VariantMongoDBQueryParser {\n         });\n     }\n \n-    private QueryBuilder addQueryIntegerFilter(String key, Collection<Integer> value, final QueryBuilder builder,\n-                                               VariantQueryUtils.QueryOperation op) {\n+    private QueryBuilder addQueryIntegerFilter(String key, Collection<Integer> value, final QueryBuilder builder, VariantQueryUtils.QueryOperation op) {\n         return this.addQueryFilter(key, value, builder, op);\n     }\n \n     private <T> QueryBuilder addQueryFilter(String key, String value, final QueryBuilder builder, QueryOperation op,\n                                             Function<String, T> map) {\n-        VariantQueryUtils.QueryOperation intraOp = checkOperator(value);\n+    VariantQueryUtils.QueryOperation intraOp = checkOperator(value);\n         return addQueryFilter(key, splitValue(value, intraOp), builder, op, intraOp, map);\n     }\n \n@@ -1215,7 +1204,7 @@ public class VariantMongoDBQueryParser {\n \n     private <S, T> QueryBuilder addQueryFilter(String key, Collection<S> value, final QueryBuilder builder, QueryOperation op,\n                                                Function<S, T> map) {\n-        return addQueryFilter(key, value, builder, op, QueryOperation.OR, map);\n+    return addQueryFilter(key, value, builder, op, QueryOperation.OR, map);\n     }\n \n     private <S, T> QueryBuilder addQueryFilter(String key, Collection<S> values, QueryBuilder builder, QueryOperation op,\n@@ -1447,7 +1436,7 @@ public class VariantMongoDBQueryParser {\n      */\n     private QueryBuilder addScoreFilter(String value, QueryBuilder builder, VariantQueryParam scoreParam,\n                                         boolean allowDescriptionFilter) {\n-        return addScoreFilter(value, builder, scoreParam, null, allowDescriptionFilter);\n+    return addScoreFilter(value, builder, scoreParam, null, allowDescriptionFilter);\n     }\n \n     /**\n@@ -1534,7 +1523,7 @@ public class VariantMongoDBQueryParser {\n      */\n     private QueryBuilder addFrequencyFilter(String key, String alleleFrequencyField, String value, QueryBuilder builder,\n                                             VariantQueryParam queryParam, boolean alternate) {\n-        return addFrequencyFilter(key, value, builder, queryParam, alternate,\n+    return addFrequencyFilter(key, value, builder, queryParam, alternate,\n                 (v, qb) -> addCompQueryFilter(alleleFrequencyField, v, qb, false));\n     }\n \n@@ -1746,4 +1735,4 @@ public class VariantMongoDBQueryParser {\n         return (id * chunksize) + chunksize - 1;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 28
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "341",
                    "column": "16",
                    "severity": "error",
                    "message": "';' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/434/VariantMongoDBQueryParser.java\nindex 7db5eca5f18..9af402a97fd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/434/VariantMongoDBQueryParser.java\n@@ -337,8 +337,9 @@ public class VariantMongoDBQueryParser {\n                             }\n                         }\n                     }\n-                    list.add(new QueryBuilder().and(key).regex(Pattern.compile(\"^\" + clinicalSignificance, Pattern.CASE_INSENSITIVE)).get());\n-                }\n+                    list.add(new QueryBuilder().and(key).regex(Pattern.compile(\"^\" + clinicalSignificance, Pattern.CASE_INSENSITIVE)).get())\n+                ;\n+                    }\n                 if (QueryOperation.OR.equals(pair.getKey())) {\n                     builder.or(list.toArray(new DBObject[0]));\n                 } else {\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/434/VariantMongoDBQueryParser.java\nindex 7db5eca5f18..e5a3e03b8bf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/434/VariantMongoDBQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/434/VariantMongoDBQueryParser.java\n@@ -337,9 +337,12 @@ public class VariantMongoDBQueryParser {\n                             }\n                         }\n                     }\n-                    list.add(new QueryBuilder().and(key).regex(Pattern.compile(\"^\" + clinicalSignificance, Pattern.CASE_INSENSITIVE)).get());\n-                }\n-                if (QueryOperation.OR.equals(pair.getKey())) {\n+                    list.add(new\n+                    QueryBuilder()\n+                    .\n+                    and(key).regex(Pattern.compile(\"^\" + clinicalSignificance, Pattern.CASE_INSENSITIVE)).get());\n+                 }\n+                 if (QueryOperation.OR.equals(pair.getKey())) {\n                     builder.or(list.toArray(new DBObject[0]));\n                 } else {\n                     builder.and(list.toArray(new DBObject[0]));\n",
            "diff_size": 6
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}