{
    "project_name": "CESNET-perun",
    "error_id": "341",
    "information": {
        "errors": [
            {
                "line": "2348",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "\t\tif (resultGroup.getId() == operandGroup.getId()) {\n\t\t\tthrow new GroupRelationNotAllowed(\"Result group \" + resultGroup + \" cannot be the same as operand group \" + operandGroup);\n\t\t} \n\n\t\t// check if there is already a record of these two groups\n\t\tif (this.groupsManagerImpl.isRelationBetweenGroups(resultGroup, operandGroup)) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/341/GroupsManagerBlImpl.java\nindex 80d1b77abcd..2e81bfaeccd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler/341/GroupsManagerBlImpl.java\n@@ -2345,7 +2345,7 @@ public class GroupsManagerBlImpl implements GroupsManagerBl {\n \t\t// check if result group is the same as operand group\n \t\tif (resultGroup.getId() == operandGroup.getId()) {\n \t\t\tthrow new GroupRelationNotAllowed(\"Result group \" + resultGroup + \" cannot be the same as operand group \" + operandGroup);\n-\t\t} \n+\t\t}\n \n \t\t// check if there is already a record of these two groups\n \t\tif (this.groupsManagerImpl.isRelationBetweenGroups(resultGroup, operandGroup)) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/341/GroupsManagerBlImpl.java\nindex 80d1b77abcd..2d9fd705a28 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/intellij/341/GroupsManagerBlImpl.java\n@@ -1,6 +1,7 @@\n package cz.metacentrum.perun.core.blImpl;\n \n import cz.metacentrum.perun.core.api.PerunPrincipal;\n+\n import java.text.ParseException;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -37,2383 +38,2418 @@ import java.util.concurrent.ConcurrentLinkedQueue;\n  */\n public class GroupsManagerBlImpl implements GroupsManagerBl {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(GroupsManagerBlImpl.class);\n-\n-\tprivate final GroupsManagerImplApi groupsManagerImpl;\n-\tprivate PerunBl perunBl;\n-\n-\tprivate Map<Integer, GroupSynchronizerThread> groupSynchronizerThreads;\n-\tprivate static final String A_G_D_AUTHORITATIVE_GROUP = AttributesManager.NS_GROUP_ATTR_DEF + \":authoritativeGroup\";\n-\n-\t/**\n-\t * Create new instance of this class.\n-\t *\n-\t */\n-\tpublic GroupsManagerBlImpl(GroupsManagerImplApi groupsManagerImpl) {\n-\t\tthis.groupsManagerImpl = groupsManagerImpl;\n-\t\tthis.groupSynchronizerThreads = new HashMap<Integer, GroupSynchronizerThread>();\n-\t}\n-\n-\tpublic Group createGroup(PerunSession sess, Vo vo, Group group) throws GroupExistsException, InternalErrorException {\n-\t\tgroup = getGroupsManagerImpl().createGroup(sess, vo, group);\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} created in {}.\", group, vo);\n-\t\tgroup.setVoId(vo.getId());\n-\n-\n-\t\t//set creator as group admin unless he already have authz right on the group (he is VO admin)\n-\t\tUser user = sess.getPerunPrincipal().getUser();\n-\t\tif(user != null) {   //user can be null in tests\n-\t\t\tif(!AuthzResolverBlImpl.isAuthorized(sess, Role.VOADMIN, vo)) {\n-\t\t\t\ttry {\n-\t\t\t\t\tAuthzResolverBlImpl.setRole(sess, user, group, Role.GROUPADMIN);\n-\t\t\t\t} catch (AlreadyAdminException e) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(\"Newly created group already have an admin.\", e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn group;\n-\t}\n-\n-\tpublic Group createGroup(PerunSession sess, Group parentGroup, Group group) throws GroupExistsException, InternalErrorException, GroupOperationsException, GroupRelationNotAllowed, GroupRelationAlreadyExists {\n-\t\tVo vo = this.getVo(sess, parentGroup);\n-\n-\t\tgroup = getGroupsManagerImpl().createGroup(sess, vo, parentGroup, group);\n-\t\tparentGroup = createGroupUnion(sess, parentGroup, group, true);\n-\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} created in {} as subgroup of {}\", group, vo, parentGroup);\n-\n-\t\treturn group;\n-\t}\n-\n-\tpublic void deleteGroup(PerunSession sess, Group group, boolean forceDelete) throws InternalErrorException, RelationExistsException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthrow new java.lang.IllegalArgumentException(\"Built-in \" + group.getName() + \" group cannot be deleted separately.\");\n-\t\t}\n-\n-\t\tthis.deleteAnyGroup(sess, group, forceDelete);\n-\t}\n-\n-\tpublic void deleteGroups(PerunSession perunSession, List<Group> groups, boolean forceDelete) throws InternalErrorException, GroupAlreadyRemovedException, RelationExistsException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\t//Use sorting by group names reverse order (first name A:B:c then A:B etc.)\n-\t\tCollections.sort(groups, Collections.reverseOrder(\n-\t\t\t\tnew Comparator<Group>() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic int compare(Group groupToCompare,Group groupToCompareWith) {\n-\t\t\t\t\t\treturn groupToCompare.getName().compareTo(groupToCompareWith.getName());\n-\t\t\t\t\t}\n-\t\t\t\t}));\n-\n-\t\tfor(Group group: groups) {\n-\t\t\tthis.deleteGroup(perunSession, group, forceDelete);\n-\t\t}\n-\t}\n-\n-\tpublic void deleteMembersGroup(PerunSession sess, Vo vo) throws InternalErrorException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tGroup group;\n-\t\ttry {\n-\t\t\tgroup = getGroupByName(sess, vo, VosManager.MEMBERS_GROUP);\n-\t\t} catch (GroupNotExistsException e) {\n-\t\t\tthrow new ConsistencyErrorException(\"Built-in members group must exists.\",e);\n-\t\t}\n-\t\ttry {\n-\t\t\tthis.deleteAnyGroup(sess, group, true);\n-\t\t} catch (RelationExistsException e) {\n-\t\t\tthrow new ConsistencyErrorException(\"Built-in members group cannot have any relation in this stage.\",e);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * If forceDelete is false, delete only group which has no subgroup and no member.\n-\t * If forceDelete is true, delete group with all subgroups and members.\n-\t *\n-\t * @param sess\n-\t * @param group\n-\t * @param forceDelete if false, delete only empty group without subgroups. If true, delete group including subgroups and members.\n-\t * @throws InternalErrorException\n-\t * @throws RelationExistsException Raise only if forceDelete is false and the group has any subgroup or member.\n-\t * @throws GroupAlreadyRemovedException if there are 0 rows affected by deleting from DB\n-\t */\n-\tprotected void deleteAnyGroup(PerunSession sess, Group group, boolean forceDelete) throws InternalErrorException, RelationExistsException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tVo vo = this.getVo(sess, group);\n-\n-\t\tif (getGroupsManagerImpl().getSubGroupsCount(sess, group) > 0) {\n-\t\t\tif (!forceDelete) throw new RelationExistsException(\"Group group=\"+group+\" contains subgroups\");\n-\n-\t\t\t// make sure we delete all subgroups !!\n-\t\t\tList<Group> subGroups = getAllSubGroups(sess, group);\n-\n-\t\t\t// Use sorting by group names reverse order (first A:B:c then A:B etc.)\n-\t\t\t// to make sure we delete from the bottom in a hierarchy\n-\t\t\tCollections.sort(subGroups, Collections.reverseOrder(\n-\t\t\t\t\tnew Comparator<Group>() {\n-\t\t\t\t\t\t@Override\n-\t\t\t\t\t\tpublic int compare(Group groupToCompare,Group groupToCompareWith) {\n-\t\t\t\t\t\t\treturn groupToCompare.getName().compareTo(groupToCompareWith.getName());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}));\n-\n-\t\t\tfor (Group g : subGroups) {\n-\t\t\t\t//For auditer\n-\t\t\t\tList<Resource> subGroupResources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, g);\n-\t\t\t\tfor(Resource resource : subGroupResources) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, g, resource);\n-\t\t\t\t\t} catch(GroupNotDefinedOnResourceException ex) {\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t//remove subgroups' attributes\n-\t\t\t\ttry {\n-\t\t\t\t\tgetPerunBl().getAttributesManagerBl().removeAllAttributes(sess, g);\n-\t\t\t\t} catch(AttributeValueException ex) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(\"All resources was removed from this group. So all attributes values can be removed.\", ex);\n-\t\t\t\t}\n-\n-\t\t\t\t// delete all sub-groups reserved logins from KDC\n-\t\t\t\tList<Integer> list = getGroupsManagerImpl().getGroupApplicationIds(sess, group);\n-\t\t\t\tfor (Integer appId : list) {\n-\t\t\t\t\t// for each application\n-\t\t\t\t\tfor (Pair<String, String> login : getGroupsManagerImpl().getApplicationReservedLogins(appId)) {\n-\t\t\t\t\t\t// for all reserved logins - delete them in ext. system (e.g. KDC)\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// left = namespace / right = login\n-\t\t\t\t\t\t\tgetPerunBl().getUsersManagerBl().deletePassword(sess, login.getRight(), login.getLeft());\n-\t\t\t\t\t\t} catch (LoginNotExistsException ex) {\n-\t\t\t\t\t\t\tlog.error(\"Login: {} not exists in namespace: {} while deleting passwords.\", login.getRight(), login.getLeft());\n-\t\t\t\t\t\t} catch (PasswordDeletionFailedException | PasswordOperationTimeoutException ex) {\n-\t\t\t\t\t\t\tthrow new InternalErrorException(\"Failed to delete reserved login \"+login.getRight()+\" from KDC.\", ex);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// delete all Groups reserved logins from DB\n-\t\t\t\tgetGroupsManagerImpl().deleteGroupReservedLogins(sess, group);\n-\n-\t\t\t\t//Remove all information about group on facilities (facilities contacts)\n-\t\t\t\tList<ContactGroup> groupContactGroups = getPerunBl().getFacilitiesManagerBl().getFacilityContactGroups(sess, group);\n-\t\t\t\tif(!groupContactGroups.isEmpty()) {\n-\t\t\t\t\tgetPerunBl().getFacilitiesManagerBl().removeAllGroupContacts(sess, group);\n-\t\t\t\t}\n-\n-\t\t\t\t//remove all assigned ExtSources to this group\n-\t\t\t\tList<ExtSource> assignedSources = getPerunBl().getExtSourcesManagerBl().getGroupExtSources(sess, group);\n-\t\t\t\tfor(ExtSource source: assignedSources) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getExtSourcesManagerBl().removeExtSource(sess, group, source);\n-\t\t\t\t\t} catch (ExtSourceNotAssignedException | ExtSourceAlreadyRemovedException ex) {\n-\t\t\t\t\t\t//Just log this, because if method can't remove it, it is probably not assigned now\n-\t\t\t\t\t\tlog.error(\"Try to remove not existing extSource {} from group {} when deleting group.\", source, group);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// 1. remove all relations with group g as an operand group.\n-\t\t\t\t// this removes all relations that depend on this group\n-\t\t\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, g.getId());\n-\t\t\t\tfor (Integer groupId : relations) {\n-\t\t\t\t\tremoveGroupUnion(sess, groupsManagerImpl.getGroupById(sess, groupId), g, true);\n-\t\t\t\t}\n-\n-\t\t\t\t// 2. remove all relations with group as a result group\n-\t\t\t\t// We can remove relations without recalculation (@see processRelationMembers)\n-\t\t\t\t// because all dependencies of group were deleted in step 1.\n-\t\t\t\tgroupsManagerImpl.removeResultGroupRelations(sess, g);\n-\n-\t\t\t\t// Group applications, submitted data and app_form are deleted on cascade with \"deleteGroup()\"\n-\n-\t\t\t\tList<Member> membersFromDeletedGroup = getGroupMembers(sess, g);\n-\t\t\t\t// Deletes also all direct and indirect members of the group\n-\t\t\t\tgetGroupsManagerImpl().deleteGroup(sess, vo, g);\n-\n-\t\t\t\tlogTotallyRemovedMembers(sess, g.getParentGroupId(), membersFromDeletedGroup);\n-\n-\t\t\t\tgetPerunBl().getAuditer().log(sess, \"{} deleted.\", g);\n-\n-\t\t\t}\n-\t\t}\n-\t\tif ((this.getGroupMembersCount(sess, group) > 0) && !forceDelete) {\n-\t\t\tthrow new RelationExistsException(\"Group group=\"+group+\" contains members\");\n-\t\t}\n-\n-\t\tList<Resource> assignedResources  = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\ttry {\n-\t\t\tfor(Resource resource : assignedResources) {\n-\t\t\t\tgetPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, group, resource);\n-\t\t\t}\n-\t\t\t//remove group's attributes\n-\t\t\tgetPerunBl().getAttributesManagerBl().removeAllAttributes(sess, group);\n-\t\t} catch(GroupNotDefinedOnResourceException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(AttributeValueException ex) {\n-\t\t\tthrow new ConsistencyErrorException(\"All resources was removed from this group, so no attributes should remain assigned.\", ex);\n-\t\t}\n-\n-\t\t// delete all Groups reserved logins from KDC\n-\t\tList<Integer> list = getGroupsManagerImpl().getGroupApplicationIds(sess, group);\n-\t\tfor (Integer appId : list) {\n-\t\t\t// for each application\n-\t\t\tfor (Pair<String, String> login : getGroupsManagerImpl().getApplicationReservedLogins(appId)) {\n-\t\t\t\t// for all reserved logins - delete them in ext. system (e.g. KDC)\n-\t\t\t\ttry {\n-\t\t\t\t\t// left = namespace / right = login\n-\t\t\t\t\tgetPerunBl().getUsersManagerBl().deletePassword(sess, login.getRight(), login.getLeft());\n-\t\t\t\t} catch (LoginNotExistsException ex) {\n-\t\t\t\t\tlog.error(\"Login: {} not exists in namespace: {} while deleting passwords.\", login.getRight(), login.getLeft());\n-\t\t\t\t} catch (PasswordDeletionFailedException | PasswordOperationTimeoutException ex) {\n-\t\t\t\t\tthrow new InternalErrorException(\"Failed to delete reserved login \"+login.getRight()+\" from KDC.\", ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t// delete all Groups reserved logins from DB\n-\t\tgetGroupsManagerImpl().deleteGroupReservedLogins(sess, group);\n-\n-\t\t//Remove all information about group on facilities (facilities contacts)\n-\t\tList<ContactGroup> groupContactGroups = getPerunBl().getFacilitiesManagerBl().getFacilityContactGroups(sess, group);\n-\t\tif(!groupContactGroups.isEmpty()) {\n-\t\t\tif(forceDelete) {\n-\t\t\t\tgetPerunBl().getFacilitiesManagerBl().removeAllGroupContacts(sess, group);\n-\t\t\t} else {\n-\t\t\t\tthrow new RelationExistsException(\"Group has still some facilities contacts: \" + groupContactGroups);\n-\t\t\t}\n-\t\t}\n-\n-\t\t//remove all assigned ExtSources to this group\n-\t\tList<ExtSource> assignedSources = getPerunBl().getExtSourcesManagerBl().getGroupExtSources(sess, group);\n-\t\tfor(ExtSource source: assignedSources) {\n-\t\t\ttry {\n-\t\t\t\tgetPerunBl().getExtSourcesManagerBl().removeExtSource(sess, group, source);\n-\t\t\t} catch (ExtSourceNotAssignedException | ExtSourceAlreadyRemovedException ex) {\n-\t\t\t\t//Just log this, because if method can't remove it, it is probably not assigned now\n-\t\t\t\tlog.error(\"Try to remove not existing extSource {} from group {} when deleting group.\", source, group);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// 1. remove all relations with group g as an operand group.\n-\t\t// this removes all relations that depend on this group\n-\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n-\t\tfor (Integer groupId : relations) {\n-\t\t\tremoveGroupUnion(sess, groupsManagerImpl.getGroupById(sess, groupId), group, true);\n-\t\t}\n-\n-\t\t// 2. remove all relations with group as a result group\n-\t\t// We can remove relations without recalculation (@see processRelationMembers)\n-\t\t// because all dependencies of group were deleted in step 1.\n-\t\tgroupsManagerImpl.removeResultGroupRelations(sess, group);\n-\n-\t\t// Group applications, submitted data and app_form are deleted on cascade with \"deleteGroup()\"\n-\t\tList<Member> membersFromDeletedGroup = getGroupMembers(sess, group);\n-\t\t// Deletes also all direct and indirect members of the group\n-\t\tgetGroupsManagerImpl().deleteGroup(sess, vo, group);\n-\n-\t\tlogTotallyRemovedMembers(sess, group.getParentGroupId(), membersFromDeletedGroup);\n-\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} deleted.\", group);\n-\t}\n-\n-\t/**\n-\t * Log members that were deleted from parent group totally to auditer.\n-\t *\n-\t * @param sess perun session\n-\t * @param parentGroupId group id\n-\t * @param membersFromDeletedGroup deleted members from child group\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate void logTotallyRemovedMembers(PerunSession sess, Integer parentGroupId, List<Member> membersFromDeletedGroup) throws InternalErrorException {\n-\t\twhile(parentGroupId != null) {\n-\t\t\tGroup parentGroup;\n-\t\t\ttry {\n-\t\t\t\tparentGroup = getGroupById(sess, parentGroupId);\n-\t\t\t} catch (GroupNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t\t// getting members from parent group AFTER the indirect members from subgroup were removed from this group.\n-\t\t\tList<Member> membersFromParentGroup = getGroupMembers(sess, parentGroup);\n-\t\t\t// removeAll will remove all members which remains in parent group even after they removal of INDIRECT records.\n-\t\t\tmembersFromDeletedGroup.removeAll(membersFromParentGroup);\n-\t\t\t// now all members which left in membersFromDeletedGroup list are totally removed members from this group,\n-\t\t\t// so we need to log them to auditer\n-\t\t\tfor(Member m: membersFromDeletedGroup) {\n-\t\t\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", m, parentGroup);\n-\t\t\t}\n-\t\t\tparentGroupId=parentGroup.getParentGroupId();\n-\t\t}\n-\t}\n-\n-\tpublic void deleteAllGroups(PerunSession sess, Vo vo) throws InternalErrorException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tfor(Group group: getGroupsManagerImpl().getGroups(sess, vo)) {\n-\n-\t\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\t\t// Do not delete built-in groups, they must be deleted using separate functions deleteMembersGroup\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tList<Resource> assignedResources  = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\t\ttry {\n-\t\t\t\tfor(Resource resource : assignedResources) {\n-\t\t\t\t\tgetPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, group, resource);\n-\t\t\t\t\tgetPerunBl().getAttributesManagerBl().removeAllAttributes(sess, resource, group);\n-\t\t\t\t}\n-\t\t\t\t//remove group's attributes\n-\t\t\t\tgetPerunBl().getAttributesManagerBl().removeAllAttributes(sess, group);\n-\t\t\t} catch(GroupNotDefinedOnResourceException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t} catch(AttributeValueException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(\"All resources was removed from this group. So all attributes values can be removed.\", ex);\n-\t\t\t} catch (WrongAttributeAssignmentException ex) {\n-\t\t\t\tthrow new InternalErrorException(ex);\n-\t\t\t}\n-\n-\t\t\ttry {\n-\t\t\t\tthis.deleteGroup(sess, group, true);\n-\t\t\t} catch (RelationExistsException | GroupNotExistsException e) {\n-\t\t\t\tthrow new ConsistencyErrorException(e);\n-\t\t\t}\n-\t\t}\n-\t\tgetPerunBl().getAuditer().log(sess, \"All group in {} deleted.\", vo);\n-\t}\n-\n-\tpublic Group updateGroup(PerunSession sess, Group group) throws InternalErrorException {\n-\n-\t\t// return group with correct updated name and shortName\n-\t\tgroup = getGroupsManagerImpl().updateGroup(sess, group);\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} updated.\", group);\n-\n-\t\tList<Group> allSubgroups = this.getAllSubGroups(sess, group);\n-\t\tString[] groupNames = group.getName().split(\":\");\n-\n-\t\tfor(Group g: allSubgroups) {\n-\t\t\tString[] subGroupNames = g.getName().split(\":\");\n-\t\t\tfor (int i=0; i<groupNames.length; i++) {\n-\t\t\t\tif (!subGroupNames[i].equals(groupNames[i])) {\n-\t\t\t\t\t// this part of name changed\n-\t\t\t\t\tsubGroupNames[i] = groupNames[i];\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// create new name\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tfor (String sgName : subGroupNames) {\n-\t\t\t\tsb.append(sgName).append(\":\");\n-\t\t\t}\n-\t\t\t// set name without last \":\"\n-\t\t\tg.setName(sb.toString().substring(0, sb.length()-1));\n-\t\t\t// for subgroups we must update whole name\n-\t\t\tgetGroupsManagerImpl().updateGroupName(sess, g);\n-\t\t\t// create auditer message for every updated group\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} updated.\", g);\n-\t\t}\n-\n-\t\treturn group;\n-\t}\n-\n-\tpublic Group getGroupById(PerunSession sess, int id) throws InternalErrorException, GroupNotExistsException {\n-\t\treturn getGroupsManagerImpl().getGroupById(sess, id);\n-\t}\n-\n-\tpublic List<Group> getGroupsToSynchronize(PerunSession sess) throws InternalErrorException{\n-\t\treturn getGroupsManagerImpl().getGroupsToSynchronize(sess);\n-\t}\n-\n-\tpublic Group getGroupByName(PerunSession sess, Vo vo, String name) throws InternalErrorException, GroupNotExistsException {\n-\t\treturn getGroupsManagerImpl().getGroupByName(sess, vo, name);\n-\t}\n-\n-\tpublic void addMemberToMembersGroup(PerunSession sess, Group group,  Member member) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, NotMemberOfParentGroupException, GroupNotExistsException, GroupOperationsException {\n-\t\t// Check if the group IS memebers or administrators group\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthis.addDirectMember(sess, group, member);\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"This method must be called only from methods VosManager.addAdmin and MembersManager.createMember.\");\n-\t\t}\n-\t}\n-\n-\tpublic void addMember(PerunSession sess, Group group, Member member) throws InternalErrorException, WrongReferenceAttributeValueException, GroupOperationsException, AlreadyMemberException, WrongAttributeValueException, GroupNotExistsException {\n-\t\t// Check if the group is NOT members or administrators group\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthrow new InternalErrorException(\"Cannot add member directly to the members group.\");\n-\t\t} else {\n-\t\t\tthis.addDirectMember(sess, group, member);\n-\t\t}\n-\t}\n-\n-\tprivate List<Group> getParentGroups(PerunSession sess, Group group)throws InternalErrorException {\n-\t\tif(group == null) return new ArrayList<Group>();\n-\t\ttry {\n-\t\t\tif (group.getParentGroupId() == null) return new ArrayList<Group>();\n-\t\t\tList<Group> groups = getParentGroups(sess,getGroupById(sess,group.getParentGroupId()));\n-\t\t\tgroups.add(getGroupById(sess, group.getParentGroupId()));\n-\t\t\treturn groups;\n-\t\t} catch(GroupNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add a record of the member with a DIRECT membership type to the group.\n-\t *\n-\t * @param sess perun session\n-\t * @param group group to add member to\n-\t * @param member member to be added as DIRECT\n-\t * @throws InternalErrorException\n-\t * @throws AlreadyMemberException\n-\t * @throws WrongAttributeValueException\n-\t * @throws WrongReferenceAttributeValueException\n-\t * @throws GroupNotExistsException\n-\t * @throws GroupOperationsException\n-\t */\n-\tprotected void addDirectMember(PerunSession sess, Group group, Member member) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, GroupNotExistsException, GroupOperationsException {\n-\n-\t\tif(this.groupsManagerImpl.isDirectGroupMember(sess, group, member)) throw new AlreadyMemberException(member);\n-\n-\t\tboolean memberWasIndirectInGroup = this.isGroupMember(sess, group, member);\n-\n-\t\tmember = getGroupsManagerImpl().addMember(sess, group, member, MembershipType.DIRECT, group.getId());\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} added to {}.\", member, group);\n-\n-\t\t//If member was indirect in group before, we don't need to change anything in other groups\n-\t\tif(memberWasIndirectInGroup) return;\n-\t\t// check all relations with this group and call processRelationMembers to reflect changes of adding member to group\n-\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n-\t\tfor (Integer groupId : relations) {\n-\t\t\tprocessRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), Collections.singletonList(member), group.getId(), true);\n-\t\t}\n-\n-\t\tsetRequiredAttributes(sess, member, group);\n-\t}\n-\n-\t/**\n-\t * Add records of the members with an INDIRECT membership type to the group.\n-\t *\n-\t * @param sess perun session\n-\t * @param group group to add members to\n-\t * @param members list of members to add as INDIRECT\n-\t * @param sourceGroupId id of a group from which members originate\n-\t * @return list of members that were not members already\n-\t * @throws InternalErrorException\n-\t * @throws AlreadyMemberException\n-\t * @throws WrongAttributeValueException\n-\t * @throws WrongReferenceAttributeValueException\n-\t */\n-\tprotected List<Member> addIndirectMembers(PerunSession sess, Group group, List<Member> members, int sourceGroupId) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n-\t\t// save list of old group members\n-\t\tList<Member> oldMembers = this.getGroupMembers(sess, group);\n-\n-\t\tfor (Member member : members) {\n-\t\t\tgroupsManagerImpl.addMember(sess, group, member, MembershipType.INDIRECT, sourceGroupId);\n-\t\t}\n-\n-\t\t// get list of new members\n-\t\tList<Member> newMembers = this.getGroupMembers(sess, group);\n-\t\t// select only newly added members\n-\t\tnewMembers.removeAll(oldMembers);\n-\n-\t\tfor (Member member : newMembers) {\n-\t\t\tsetRequiredAttributes(sess, member, group);\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} added to {}.\", member, group);\n-\t\t}\n-\n-\t\treturn newMembers;\n-\t}\n-\n-\t/**\n-\t * Set required attributes when adding new direct or indirect members.\n-\t * @param sess perun session\n-\t * @param member member\n-\t * @param group group\n-\t * @throws InternalErrorException\n-\t * @throws WrongAttributeValueException\n-\t * @throws WrongReferenceAttributeValueException\n-\t */\n-\tprivate void setRequiredAttributes(PerunSession sess, Member member, Group group) throws InternalErrorException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n-\t\t// setting required attributes\n-\t\tUser user = getPerunBl().getUsersManagerBl().getUserByMember(sess, member);\n-\t\tList<Resource> resources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\tfor (Resource resource : resources) {\n-\t\t\tFacility facility = getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\t\t// check members attributes\n-\t\t\ttry {\n-\t\t\t\tgetPerunBl().getAttributesManagerBl().setRequiredAttributes(sess, facility, resource, user, member);\n-\t\t\t} catch(WrongAttributeAssignmentException | AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Remove records of the members with an INDIRECT membership type from the group.\n-\t *\n-\t * @param sess perun session\n-\t * @param group group to remove records of INDIRECT members from\n-\t * @param members list of members to remove\n-\t * @param sourceGroupId id of a group from which members originate\n-\t * @return list of members that were removed (their only record in the group was deleted)\n-\t * @throws InternalErrorException\n-\t * @throws AlreadyMemberException\n-\t * @throws WrongAttributeValueException\n-\t * @throws WrongReferenceAttributeValueException\n-\t * @throws NotGroupMemberException\n-\t */\n-\tprotected List<Member> removeIndirectMembers(PerunSession sess, Group group, List<Member> members, int sourceGroupId) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, NotGroupMemberException {\n-\t\t// save list of old group members\n-\t\tList<Member> oldMembers = this.getGroupMembers(sess, group);\n-\n-\t\tfor (Member member: members) {\n-\t\t\tmember.setSourceGroupId(sourceGroupId);\n-\t\t\tgroupsManagerImpl.removeMember(sess, group, member);\n-\t\t}\n-\n-\t\t// get list of new members\n-\t\tList<Member> newMembers = this.getGroupMembers(sess, group);\n-\t\t// get only removed members\n-\t\toldMembers.removeAll(newMembers);\n-\n-\t\tfor(Member removedIndirectMember: oldMembers) {\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", removedIndirectMember, group);\n-\t\t}\n-\n-\t\treturn oldMembers;\n-\t}\n-\n-\tpublic void removeMember(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n-\t\t// Check if the group is NOT members or administrators group\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthrow new InternalErrorException(\"Cannot remove member directly from the members group.\");\n-\t\t} else {\n-\t\t\tthis.removeDirectMember(sess, group, member);\n-\t\t}\n-\t}\n-\n-\tpublic void removeMemberFromMembersOrAdministratorsGroup(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n-\t\t// Check if the group IS memebers or administrators group\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthis.removeDirectMember(sess, group, member);\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"This method must be called only from methods VosManager.removeAdmin and MembersManager.deleteMember.\");\n-\t\t}\n-\t}\n-\n-\tprotected void removeDirectMember(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n-\t\tmember.setSourceGroupId(group.getId());\n-\t\tgetGroupsManagerImpl().removeMember(sess, group, member);\n-\t\tif (this.getGroupsManagerImpl().isGroupMember(sess, group, member)) {\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from {}.\", member, group);\n-\t\t\t//If member was indirect in group before, we don't need to change anything in other groups\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", member, group);\n-\t\t}\n-\n-\t\t// check all relations with this group and call processRelationMembers to reflect changes of removing member from group\n-\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n-\t\tfor (Integer groupId : relations) {\n-\t\t\tprocessRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), Collections.singletonList(member), group.getId(), false);\n-\t\t}\n-\n-\t}\n-\n-\tpublic List<Member> getGroupMembers(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn this.filterMembersByMembershipTypeInGroup(getGroupsManagerImpl().getGroupMembers(sess, group));\n-\t}\n-\n-\tpublic List<Member> getGroupMembers(PerunSession sess, Group group, Status status) throws InternalErrorException {\n-\t\tif (status == null) {\n-\t\t\treturn this.getGroupMembers(sess, group);\n-\t\t}\n-\t\treturn this.filterMembersByMembershipTypeInGroup(getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(status), false));\n-\t}\n-\n-\t@Override\n-\tpublic List<User> getGroupUsers(PerunSession perunSession, Group group) throws InternalErrorException {\n-\t\treturn new ArrayList<User>(new HashSet<User>(getGroupsManagerImpl().getGroupUsers(perunSession, group)));\n-\t}\n-\n-\tpublic List<Member> getGroupMembersExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(Status.INVALID), true);\n-\t}\n-\n-\tpublic List<Member> getGroupMembersExceptInvalidAndDisabled(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(Status.INVALID, Status.DISABLED), true);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembers(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn this.getGroupRichMembers(sess, group, null);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembersExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<Member> members = this.getGroupMembersExceptInvalid(sess, group);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembers(PerunSession sess, Group group, Status status) throws InternalErrorException {\n-\t\tList<Member> members = this.getGroupMembers(sess, group, status);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembersWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn this.getGroupRichMembersWithAttributes(sess, group, null);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembersWithAttributesExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<RichMember> richMembers = this.getGroupRichMembersExceptInvalid(sess, group);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembersWithAttributes(PerunSession sess, Group group, Status status) throws InternalErrorException {\n-\t\tList<RichMember> richMembers = this.getGroupRichMembers(sess, group, status);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n-\t}\n-\n-\tpublic int getGroupMembersCount(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<Member> members = this.getGroupMembers(sess, group);\n-\t\treturn members.size();\n-\t}\n-\n-\tpublic void addAdmin(PerunSession sess, Group group, User user) throws InternalErrorException, AlreadyAdminException {\n-\t\tAuthzResolverBlImpl.setRole(sess, user, group, Role.GROUPADMIN);\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} was added as admin of {}.\", user, group);\n-\t}\n-\n-\t@Override\n-\tpublic void addAdmin(PerunSession sess, Group group, Group authorizedGroup) throws InternalErrorException, AlreadyAdminException {\n-\t\tList<Group> listOfAdmins = getAdminGroups(sess, group);\n-\t\tif (listOfAdmins.contains(authorizedGroup)) throw new AlreadyAdminException(authorizedGroup);\n-\n-\t\tAuthzResolverBlImpl.setRole(sess, authorizedGroup, group, Role.GROUPADMIN);\n-\t\tgetPerunBl().getAuditer().log(sess, \"Group {} was added as admin of {}.\", authorizedGroup, group);\n-\t}\n-\n-\tpublic void removeAdmin(PerunSession sess, Group group, User user) throws InternalErrorException, UserNotAdminException {\n-\t\tAuthzResolverBlImpl.unsetRole(sess, user, group, Role.GROUPADMIN);\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from admins of {}.\", user, group);\n-\t}\n-\n-\t@Override\n-\tpublic void removeAdmin(PerunSession sess, Group group, Group authorizedGroup) throws InternalErrorException, GroupNotAdminException {\n-\t\tList<Group> listOfAdmins = getAdminGroups(sess, group);\n-\t\tif (!listOfAdmins.contains(authorizedGroup)) throw new GroupNotAdminException(authorizedGroup);\n-\n-\t\tAuthzResolverBlImpl.unsetRole(sess, authorizedGroup, group, Role.GROUPADMIN);\n-\t\tgetPerunBl().getAuditer().log(sess, \"Group {} was removed from admins of {}.\", authorizedGroup, group);\n-\t}\n-\n-\tpublic List<User> getAdmins(PerunSession perunSession, Group group, boolean onlyDirectAdmins) throws InternalErrorException {\n-\t\tif(onlyDirectAdmins) {\n-\t\t\treturn getGroupsManagerImpl().getDirectAdmins(perunSession, group);\n-\t\t} else {\n-\t\t\treturn getGroupsManagerImpl().getAdmins(perunSession, group);\n-\t\t}\n-\t}\n-\n-\tpublic List<RichUser> getRichAdmins(PerunSession perunSession, Group group, List<String> specificAttributes, boolean allUserAttributes, boolean onlyDirectAdmins) throws InternalErrorException, UserNotExistsException {\n-\t\tList<User> users = this.getAdmins(perunSession, group, onlyDirectAdmins);\n-\t\tList<RichUser> richUsers;\n-\n-\t\tif(allUserAttributes) {\n-\t\t\trichUsers = perunBl.getUsersManagerBl().getRichUsersWithAttributesFromListOfUsers(perunSession, users);\n-\t\t} else {\n-\t\t\ttry {\n-\t\t\t\trichUsers = getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new InternalErrorException(\"One of Attribute not exist.\", ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn richUsers;\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<User> getAdmins(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getAdmins(sess, group);\n-\t}\n-\n-\t@Deprecated\n-\t@Override\n-\tpublic List<User> getDirectAdmins(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getDirectAdmins(sess, group);\n-\t}\n-\n-\t@Override\n-\tpublic List<Group> getAdminGroups(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupAdmins(sess, group);\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getRichAdmins(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n-\t\tList<User> users = this.getAdmins(perunSession, group);\n-\t\tList<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users);\n-\t\treturn richUsers;\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getDirectRichAdmins(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n-\t\tList<User> users = this.getDirectAdmins(perunSession, group);\n-\t\tList<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users);\n-\t\treturn richUsers;\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getRichAdminsWithAttributes(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n-\t\tList<User> users = this.getAdmins(perunSession, group);\n-\t\tList<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersWithAttributesFromListOfUsers(perunSession, users);\n-\t\treturn richUsers;\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getRichAdminsWithSpecificAttributes(PerunSession perunSession, Group group, List<String> specificAttributes) throws InternalErrorException, UserNotExistsException {\n-\t\ttry {\n-\t\t\treturn getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, this.getRichAdmins(perunSession, group), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new InternalErrorException(\"One of Attribute not exist.\", ex);\n-\t\t}\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getDirectRichAdminsWithSpecificAttributes(PerunSession perunSession, Group group, List<String> specificAttributes) throws InternalErrorException, UserNotExistsException {\n-\t\ttry {\n-\t\t\treturn getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, this.getDirectRichAdmins(perunSession, group), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new InternalErrorException(\"One of Attribute not exist.\", ex);\n-\t\t}\n-\t}\n-\n-\tpublic List<Group> getAssignedGroupsToResource(PerunSession sess, Resource resource) throws InternalErrorException {\n-\t\treturn getAssignedGroupsToResource(sess, resource, false);\n-\t}\n-\n-\tpublic List<Group> getAssignedGroupsToResource(PerunSession sess, Resource resource, boolean withSubGroups) throws InternalErrorException {\n-\t\tList<Group> assignedGroups = getGroupsManagerImpl().getAssignedGroupsToResource(sess, resource);\n-\t\tif(!withSubGroups) return assignedGroups;\n-\n-\t\tboolean done = assignedGroups.isEmpty();\n-\t\tList<Group> groupsToProcess = new ArrayList<Group>(assignedGroups);\n-\t\twhile(!done) {\n-\t\t\tList<Group> groupsToAdd = new ArrayList<Group>();\n-\t\t\tfor(Group group : groupsToProcess) {\n-\t\t\t\t//FIXME Do not get subgroups of the members group\n-\t\t\t\tif (!group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\t\t\tgroupsToAdd.addAll(this.getSubGroups(sess, group));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tgroupsToAdd.removeAll(assignedGroups);\n-\t\t\tassignedGroups.addAll(groupsToAdd);\n-\t\t\tgroupsToProcess = groupsToAdd;\n-\t\t\tdone = groupsToProcess.isEmpty();\n-\t\t}\n-\t\treturn assignedGroups;\n-\t}\n-\n-\tpublic List<Group> getAllGroups(PerunSession sess, Vo vo) throws InternalErrorException {\n-\t\tList<Group> groups = getGroupsManagerImpl().getAllGroups(sess, vo);\n-\n-\t\t// Sort\n-\t\tCollections.sort(groups);\n-\n-\t\treturn groups;\n-\t}\n-\n-\tpublic Map<Group, Object> getAllGroupsWithHierarchy(PerunSession sess, Vo vo) throws InternalErrorException {\n-\t\tMap<Group,Object> groupHierarchy = new TreeMap<Group, Object>();\n-\n-\t\t// Get the top level group = members\n-\t\ttry {\n-\t\t\tgroupHierarchy.put(this.getGroupByName(sess, vo, VosManager.MEMBERS_GROUP), null);\n-\t\t} catch (GroupNotExistsException e) {\n-\t\t\tthrow new ConsistencyErrorException(\"Built-in members group must exists.\",e);\n-\t\t}\n-\n-\t\t// Call recursively getGroupsForHierarchy, which finds all subgroups\n-\t\treturn getGroupsForHierarchy(sess, groupHierarchy);\n-\t}\n-\n-\t/**\n-\t *\n-\t * @param sess\n-\t * @param groups initialized HashMap containing pair <topLevelGropu, null>\n-\t * @return HashMap containing all VO groups hierarchically organized\n-\t */\n-\tprivate Map<Group, Object> getGroupsForHierarchy(PerunSession sess, Map<Group, Object> groups) throws InternalErrorException {\n-\t\tfor (Group group: groups.keySet()) {\n-\t\t\tList<Group> subGroups = this.getSubGroups(sess, group);\n-\n-\t\t\tMap<Group,Object> subGroupHierarchy = new TreeMap<Group, Object>();\n-\t\t\tfor (Group subGroup: subGroups) {\n-\t\t\t\tsubGroupHierarchy.put(subGroup, null);\n-\t\t\t}\n-\n-\t\t\tgroups.put(group, this.getGroupsForHierarchy(sess, subGroupHierarchy));\n-\t\t}\n-\n-\t\treturn groups;\n-\t}\n-\n-\tpublic List<Group> getSubGroups(PerunSession sess, Group parentGroup) throws InternalErrorException {\n-\t\tList<Group> subGroups = getGroupsManagerImpl().getSubGroups(sess, parentGroup);\n-\n-\t\t// Sort\n-\t\tCollections.sort(subGroups);\n-\n-\t\treturn subGroups;\n-\t}\n-\n-\tpublic List<Group> getAllSubGroups(PerunSession sess, Group parentGroup) throws InternalErrorException {\n-\t\tQueue<Group> groupsInQueue = new ConcurrentLinkedQueue<Group>();\n-\t\tgroupsInQueue.addAll(getGroupsManagerImpl().getSubGroups(sess, parentGroup));\n-\t\tList<Group> allSubGroups = new ArrayList<Group>();\n-\t\twhile(groupsInQueue.peek() != null) {\n-\t\t\tgroupsInQueue.addAll(getGroupsManagerImpl().getSubGroups(sess, groupsInQueue.peek()));\n-\t\t\tallSubGroups.add(groupsInQueue.poll());\n-\t\t}\n-\t\treturn allSubGroups;\n-\t}\n-\n-\tpublic Group getParentGroup(PerunSession sess, Group group) throws InternalErrorException, ParentGroupNotExistsException {\n-\t\tif(group.getParentGroupId() == null) {\n-\t\t\tVo vo = this.getVo(sess, group);\n-\t\t\ttry {\n-\t\t\t\treturn this.getGroupByName(sess, vo, VosManager.MEMBERS_GROUP);\n-\t\t\t} catch (GroupNotExistsException ex) {\n-\t\t\t\tthrow new ParentGroupNotExistsException(\"Members group not exist for vo\" + vo);\n-\t\t\t}\n-\t\t} else {\n-\t\t\treturn getGroupsManagerImpl().getParentGroup(sess, group);\n-\t\t}\n-\t}\n-\n-\tpublic List<Group> getGroups(PerunSession sess, Vo vo) throws InternalErrorException {\n-\t\tList<Group> groups = getGroupsManagerImpl().getGroups(sess, vo);\n-\n-\t\tCollections.sort(groups);\n-\n-\t\treturn groups;\n-\t}\n-\n-\tpublic List<Group> getGroupsByIds(PerunSession sess, List<Integer> groupsIds) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupsByIds(sess, groupsIds);\n-\t}\n-\n-\tpublic int getGroupsCount(PerunSession sess, Vo vo) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupsCount(sess, vo);\n-\t}\n-\n-\tpublic int getGroupsCount(PerunSession sess) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupsCount(sess);\n-\t}\n-\n-\tpublic int getSubGroupsCount(PerunSession sess, Group parentGroup) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getSubGroupsCount(sess, parentGroup);\n-\t}\n-\n-\tpublic Vo getVo(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tint voId = getGroupsManagerImpl().getVoId(sess, group);\n-\t\ttry {\n-\t\t\treturn getPerunBl().getVosManagerBl().getVoById(sess, voId);\n-\t\t} catch (VoNotExistsException e) {\n-\t\t\tthrow new ConsistencyErrorException(\"Group belongs to the non-existent VO\", e);\n-\t\t}\n-\t}\n-\n-\tpublic List<Group> getMemberGroups(PerunSession sess, Member member) throws InternalErrorException {\n-\t\tList<Group> groups = this.getAllMemberGroups(sess, member);\n-\t\t//Remove members group\n-\t\tif(!groups.isEmpty()) {\n-\t\t\tIterator<Group> iterator = groups.iterator();\n-\t\t\twhile(iterator.hasNext()) {\n-\t\t\t\tGroup g = iterator.next();\n-\t\t\t\tif(g.getName().equals(VosManager.MEMBERS_GROUP)) iterator.remove();\n-\t\t\t}\n-\t\t}\n-\t\t// Sort\n-\t\tCollections.sort(groups);\n-\t\treturn groups;\n-\t}\n-\n-\tpublic List<Group> getMemberDirectGroups(PerunSession sess, Member member) throws InternalErrorException {\n-\t\tList<Group> memberGroups = this.getMemberGroups(sess, member);\n-\n-\t\tIterator<Group> groupIterator = memberGroups.iterator();\n-\t\twhile(groupIterator.hasNext()) {\n-\t\t\tif(!getGroupsManagerImpl().isDirectGroupMember(sess, groupIterator.next(), member)) {\n-\t\t\t\tgroupIterator.remove();\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn memberGroups;\n-\t}\n-\n-\tpublic List<Group> getMemberGroupsByAttribute(PerunSession sess, Member member, Attribute attribute) throws WrongAttributeAssignmentException,InternalErrorException {\n-\t\tList<Group> memberGroups = this.getAllMemberGroups(sess, member);\n-\t\tmemberGroups.retainAll(this.getGroupsByAttribute(sess, attribute));\n-\t\treturn memberGroups;\n-\t}\n-\n-\tpublic List<Group> getAllMemberGroups(PerunSession sess, Member member) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getAllMemberGroups(sess, member);\n-\t}\n-\n-\tpublic List<Member> getParentGroupMembers(PerunSession sess, Group group) throws InternalErrorException {\n-\t\ttry {\n-\t\t\tGroup parentGroup = getParentGroup(sess, group);\n-\t\t\treturn getGroupMembers(sess, parentGroup);\n-\t\t} catch(ParentGroupNotExistsException ex) {\n-\t\t\t//group (from param) is top level group. Return VO members instead.\n-\t\t\tVo vo = getVo(sess, group);\n-\t\t\treturn getPerunBl().getMembersManagerBl().getMembers(sess, vo);\n-\t\t}\n-\t}\n-\n-\tpublic List<RichMember> getParentGroupRichMembers(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<Member> members = this.getParentGroupMembers(sess, group);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n-\t}\n-\n-\tpublic List<RichMember> getParentGroupRichMembersWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<RichMember> richMembers = this.getParentGroupRichMembers(sess, group);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n-\t}\n-\n-\tpublic boolean isUserMemberOfGroup(PerunSession sess, User user, Group group) throws InternalErrorException {\n-\t\treturn groupsManagerImpl.isUserMemberOfGroup(sess, user, group);\n-\t}\n-\n-\t/**\n-\t * Compare richMember userExtSources with Candidate's userExtSources, if some of the useExtSource fits.\n-\t *\n-\t * @param richMember\n-\t * @param candidate\n-\t * @return true if richMember.userExtSources contains some of the candidate.useExtSource\n-\t */\n-\tprotected boolean hasCandidateExistingMember(Candidate candidate, RichMember richMember) {\n-\t\tfor (UserExtSource ues: richMember.getUserExtSources()) {\n-\t\t\tif (candidate.getUserExtSources().contains(ues)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * This method run in separate transaction.\n-\t */\n-\tpublic List<String> synchronizeGroup(PerunSession sess, Group group) throws InternalErrorException, MemberAlreadyRemovedException, AttributeNotExistsException, WrongAttributeAssignmentException, ExtSourceNotExistsException, WrongAttributeValueException, WrongReferenceAttributeValueException, GroupOperationsException, NotMemberOfParentGroupException, GroupNotExistsException {\n-\t\t//needed variables for whole method\n-\t\tList<String> skippedMembers = new ArrayList<>();\n-\t\tExtSource source = null;\n-\t\tExtSource membersSource = null;\n-\n-\t\ttry {\n-\t\t\tlog.info(\"Group synchronization {}: started.\", group);\n-\n-\t\t\t//Initialization of group extSource\n-\t\t\tsource = getGroupExtSourceForSynchronization(sess, group);\n-\n-\t\t\t//Initialization of groupMembers extSource (if it is set), in other case set membersSource = source\n-\t\t\tmembersSource = getGroupMembersExtSourceForSynchronization(sess, group, source);\n-\n-\t\t\t//Prepare info about userAttributes which need to be overwrite (not just updated)\n-\t\t\tList<String> overwriteUserAttributesList = getOverwriteUserAttributesListFromExtSource(membersSource);\n-\n-\t\t\t//Get info about type of synchronization (with or without update)\n-\t\t\tboolean lightweightSynchronization = isThisLightweightSynchronization(sess, group);\n-\n-\t\t\tlog.info(\"Group synchronization {}: using configuration extSource for membership {}, extSource for members {}\", new Object[] {group, membersSource, membersSource.getName()});\n-\n-\t\t\t//Prepare containers for work with group members\n-\t\t\tList<Candidate> candidatesToAdd = new ArrayList<>();\n-\t\t\tMap<Candidate, RichMember> membersToUpdate = new HashMap<>();\n-\t\t\tList<RichMember> membersToRemove = new ArrayList<>();\n-\n-\t\t\t//get all actual members of group\n-\t\t\tList<RichMember> actualGroupMembers = getPerunBl().getGroupsManagerBl().getGroupRichMembers(sess, group);\n-\n-\t\t\tif(lightweightSynchronization) {\n-\t\t\t\tcategorizeMembersForLightweightSynchronization(sess, group, source, membersSource, actualGroupMembers, candidatesToAdd, membersToRemove, skippedMembers);\n-\t\t\t} else {\n-\t\t\t\t//Get subjects from extSource\n-\t\t\t\tList<Map<String, String>> subjects = getSubjectsFromExtSource(sess, source, group);\n-\t\t\t\t//Convert subjects to candidates\n-\t\t\t\tList<Candidate> candidates = convertSubjectsToCandidates(sess, subjects, membersSource, source, skippedMembers);\n-\n-\t\t\t\tcategorizeMembersForSynchronization(sess, actualGroupMembers, candidates, candidatesToAdd, membersToUpdate, membersToRemove);\n-\t\t\t}\n-\n-\t\t\t//Update members already presented in group\n-\t\t\tupdateExistingMembersWhileSynchronization(sess, group, membersToUpdate, overwriteUserAttributesList);\n-\n-\t\t\t//Add not presented candidates to group\n-\t\t\taddMissingMembersWhileSynchronization(sess, group, candidatesToAdd, overwriteUserAttributesList, skippedMembers);\n-\n-\t\t\t//Remove presented members in group who are not presented in synchronized ExtSource\n-\t\t\tremoveFormerMembersWhileSynchronization(sess, group, membersToRemove);\n-\n-\t\t\tlog.info(\"Group synchronization {}: ended.\", group);\n-\t\t} finally {\n-\t\t\tcloseExtSourcesAfterSynchronization(membersSource, source);\n-\t\t}\n-\n-\t\treturn skippedMembers;\n-\t}\n-\n-\t/**\n-\t * Force group synchronization.\n-\t *\n-\t * Adds the group synchronization process in the groupSynchronizerThreads.\n-\t *\n-\t * @param group\n-\t */\n-\tpublic void forceGroupSynchronization(PerunSession sess, Group group) throws GroupSynchronizationAlreadyRunningException {\n-\t\t// First check if the group is not currently in synchronization process\n-\t\tif (groupSynchronizerThreads.containsKey(group.getId()) && groupSynchronizerThreads.get(group.getId()).getState() != Thread.State.TERMINATED) {\n-\t\t\tthrow new GroupSynchronizationAlreadyRunningException(group);\n-\t\t} else {\n-\t\t\t// Remove from groupSynchronizerThreads if the thread was terminated\n-\t\t\tif (groupSynchronizerThreads.containsKey(group.getId())) {\n-\t\t\t\tgroupSynchronizerThreads.remove(group.getId());\n-\t\t\t}\n-\t\t\t// Start and run the new thread\n-\t\t\tGroupSynchronizerThread thread = new GroupSynchronizerThread(sess, group);\n-\t\t\tthread.start();\n-\t\t\tlog.info(\"Group synchronization thread started for group {}.\", group);\n-\n-\t\t\tgroupSynchronizerThreads.put(group.getId(), thread);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Synchronize all groups which have enabled synchronization. This method is run by the scheduler every 5 minutes.\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tpublic void synchronizeGroups(PerunSession sess) throws InternalErrorException {\n-\t\tRandom rand = new Random();\n-\n-\t\t// Firstly remove all terminated threads\n-\t\tList<Integer> threadsToRemove = new ArrayList<Integer>();\n-\t\tfor (Integer groupId: groupSynchronizerThreads.keySet()) {\n-\t\t\tif (groupSynchronizerThreads.get(groupId).getState() == Thread.State.TERMINATED) {\n-\t\t\t\tthreadsToRemove.add(groupId);\n-\t\t\t}\n-\t\t}\n-\t\tfor (Integer groupId: threadsToRemove) {\n-\t\t\tgroupSynchronizerThreads.remove(groupId);\n-\t\t\tlog.debug(\"Removing terminated group synchronization thread for group id={}\", groupId);\n-\t\t}\n-\n-\t\t// Get the default synchronization interval and synchronization timeout from the configuration file\n-\t\tint intervalMultiplier = Integer.parseInt(BeansUtils.getPropertyFromConfiguration(\"perun.group.synchronization.interval\"));\n-\t\tint timeout = Integer.parseInt(BeansUtils.getPropertyFromConfiguration(\"perun.group.synchronization.timeout\"));\n-\n-\t\t// Get the number of seconds from the epoch, so we can divide it by the synchronization interval value\n-\t\tlong minutesFromEpoch = System.currentTimeMillis()/1000/60;\n-\n-\t\t// Get the groups with synchronization enabled\n-\t\tList<Group> groups = groupsManagerImpl.getGroupsToSynchronize(sess);\n-\n-\t\tint numberOfNewSynchronizations = 0;\n-\t\tint numberOfActiveSynchronizations = 0;\n-\t\tint numberOfTerminatedSynchronizations = 0;\n-\t\tfor (Group group: groups) {\n-\t\t\t// Get the synchronization interval\n-\t\t\ttry {\n-\t\t\t\tAttribute intervalAttribute = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPSYNCHROINTERVAL_ATTRNAME);\n-\t\t\t\tif (intervalAttribute.getValue() != null) {\n-\t\t\t\t\tintervalMultiplier = Integer.parseInt((String) intervalAttribute.getValue());\n-\t\t\t\t} else {\n-\t\t\t\t\tlog.warn(\"Group {} hasn't set synchronization interval, using default {} seconds\", group, intervalMultiplier);\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException e) {\n-\t\t\t\tthrow new ConsistencyErrorException(\"Required attribute \" + GroupsManager.GROUPSYNCHROINTERVAL_ATTRNAME + \" isn't defined in Perun!\",e);\n-\t\t\t} catch (WrongAttributeAssignmentException e) {\n-\t\t\t\tlog.error(\"Cannot synchronize group \" + group +\" due to exception:\", e);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t// Multiply with 5 to get real minutes\n-\t\t\tintervalMultiplier = intervalMultiplier*5;\n-\n-\t\t\t// If the minutesFromEpoch can be divided by the intervalMultiplier, then synchronize\n-\t\t\tif ((minutesFromEpoch % intervalMultiplier) == 0) {\n-\t\t\t\t// It's time to synchronize\n-\t\t\t\tlog.info(\"Scheduling synchronization for the group {}. Interval {} minutes.\", group, intervalMultiplier);\n-\n-\t\t\t\t// Run each synchronization in separate thread, but do not start new one, if previous hasn't finished yet\n-\t\t\t\tif (groupSynchronizerThreads.containsKey(group.getId())) {\n-\t\t\t\t\t// Check the running time of the thread\n-\t\t\t\t\tlong timeDiff = System.currentTimeMillis() - groupSynchronizerThreads.get(group.getId()).getStartTime();\n-\n-\t\t\t\t\t// If the time is greater than timeout set in the configuration file (in minutes)\n-\t\t\t\t\tif (timeDiff/1000/60 > timeout) {\n-\t\t\t\t\t\t// Timeout reach, stop the thread\n-\t\t\t\t\t\tlog.warn(\"Timeout {} minutes of the synchronization thread for the group {} reached.\", timeout, group);\n-\t\t\t\t\t\tgroupSynchronizerThreads.get(group.getId()).interrupt();\n-\t\t\t\t\t\tgroupSynchronizerThreads.remove(group.getId());\n-\t\t\t\t\t\tnumberOfTerminatedSynchronizations++;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tnumberOfActiveSynchronizations++;\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// Start and run the new thread\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\t// Do not overload externalSource, run each synchronization in 0-30s steps\n-\t\t\t\t\t\tThread.sleep(rand.nextInt(30000));\n-\t\t\t\t\t} catch (InterruptedException e) {\n-\t\t\t\t\t\t// Do nothing\n-\t\t\t\t\t}\n-\t\t\t\t\tGroupSynchronizerThread thread = new GroupSynchronizerThread(sess, group);\n-\t\t\t\t\tthread.start();\n-\t\t\t\t\tlog.info(\"Group synchronization thread started for group {}.\", group);\n-\n-\t\t\t\t\tgroupSynchronizerThreads.put(group.getId(), thread);\n-\t\t\t\t\tnumberOfNewSynchronizations++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (groups.size() > 0) {\n-\t\t\tlog.info(\"Synchronizing {} groups, active {}, new {}, terminated {}.\",\n-\t\t\t\t\tnew Object[] {groups.size(), numberOfActiveSynchronizations, numberOfNewSynchronizations, numberOfTerminatedSynchronizations});\n-\t\t}\n-\t}\n-\n-\tprivate static class GroupSynchronizerThread extends Thread {\n-\n-\t\t// all synchronization runs under synchronizer identity.\n-\t\tfinal PerunPrincipal pp = new PerunPrincipal(\"perunSynchronizer\", ExtSourcesManager.EXTSOURCE_NAME_INTERNAL, ExtSourcesManager.EXTSOURCE_INTERNAL);\n-\t\tprivate PerunBl perunBl;\n-\t\tprivate PerunSession sess;\n-\t\tprivate Group group;\n-\t\tprivate long startTime;\n-\n-\t\tpublic GroupSynchronizerThread(PerunSession sess, Group group) {\n-\t\t\t// take only reference to perun\n-\t\t\tthis.perunBl = (PerunBl) sess.getPerun();\n-\t\t\tthis.group = group;\n-\t\t\ttry {\n-\t\t\t\t// create own session\n-\t\t\t\tthis.sess = perunBl.getPerunSession(pp, new PerunClient());\n-\t\t\t} catch (InternalErrorException ex) {\n-\t\t\t\tlog.error(\"Unable to create internal session for Synchronizer with credentials {} because of exception {}\", pp, ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\tpublic void run() {\n-\t\t\t//text of exception if was thrown, null in exceptionMessage means \"no exception, it's ok\"\n-\t\t\tString exceptionMessage = null;\n-\t\t\t//text with all skipped members and reasons of this skipping\n-\t\t\tString skippedMembersMessage = null;\n-\t\t\t//if exception which produce fail of whole synchronization was thrown\n-\t\t\tboolean failedDueToException = false;\n-\n-\t\t\ttry {\n-\t\t\t\tlog.debug(\"Synchronization thread for group {} has started.\", group);\n-\t\t\t\t// Set the start time, so we can check the timeout of the thread\n-\t\t\t\tstartTime = System.currentTimeMillis();\n-\n-\t\t\t\t//synchronize Group and get information about skipped Members\n-\t\t\t\tList<String> skippedMembers = perunBl.getGroupsManagerBl().synchronizeGroup(sess, group);\n-\n-\t\t\t\tif(!skippedMembers.isEmpty()) {\n-\t\t\t\t\tskippedMembersMessage = \"These members from extSource were skipped: { \";\n-\n-\t\t\t\t\tfor(String skippedMember: skippedMembers) {\n-\t\t\t\t\t\tif(skippedMember == null) continue;\n-\n-\t\t\t\t\t\tskippedMembersMessage+= skippedMember + \", \";\n-\t\t\t\t\t}\n-\t\t\t\t\tskippedMembersMessage+= \" }\";\n-\t\t\t\t\texceptionMessage = skippedMembersMessage;\n-\t\t\t\t}\n-\n-\t\t\t\tlog.debug(\"Synchronization thread for group {} has finished in {} ms.\", group, System.currentTimeMillis()-startTime);\n-\t\t\t} catch (WrongAttributeValueException | WrongReferenceAttributeValueException | InternalErrorException |\n-\t\t\t\t\tWrongAttributeAssignmentException | MemberAlreadyRemovedException | GroupNotExistsException |\n-\t\t\t\t\tGroupOperationsException | NotMemberOfParentGroupException | AttributeNotExistsException | ExtSourceNotExistsException e) {\n-\t\t\t\tfailedDueToException = true;\n-\t\t\t\texceptionMessage = \"Cannot synchronize group \";\n-\t\t\t\tlog.error(exceptionMessage + group, e);\n-\t\t\t\texceptionMessage+= \"due to exception: \" + e.getName() + \" => \" + e.getMessage();\n-\t\t\t} catch (Exception e) {\n-\t\t\t\t//If some other exception has been thrown, log it and throw again\n-\t\t\t\tfailedDueToException = true;\n-\t\t\t\texceptionMessage = \"Cannot synchronize group \";\n-\t\t\t\tlog.error(exceptionMessage + group, e);\n-\t\t\t\texceptionMessage+= \"due to unexpected exception: \" + e.getClass().getName() + \" => \" + e.getMessage();\n-\t\t\t\tthrow e;\n-\t\t\t} finally {\n-\t\t\t\t//Save information about group synchronization, this method run in new transaction\n-\t\t\t\ttry {\n-\t\t\t\t\tperunBl.getGroupsManagerBl().saveInformationAboutGroupSynchronization(sess, group, failedDueToException, exceptionMessage);\n-\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\tlog.error(\"When synchronization group \" + group + \", exception was thrown.\", ex);\n-\t\t\t\t\tlog.info(\"Info about exception from synchronization: \" + skippedMembersMessage);\n-\t\t\t\t}\n-\t\t\t\tlog.debug(\"GroupSynchronizerThread finished for group: {}\", group);\n-\t\t\t}\n-\t\t}\n-\n-\t\tpublic long getStartTime() {\n-\t\t\treturn startTime;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get all groups of member (except members group) where authoritativeGroup attribute is set to 1 (true)\n-\t *\n-\t * @param sess\n-\t * @param member\n-\t * @return list of groups with authoritativeAttribute set to 1\n-\t *\n-\t * @throws AttributeNotExistsException if authoritativeGroup attribute not exists\n-\t * @throws InternalErrorException\n-\t */\n-\tList<Group> getAllAuthoritativeGroupsOfMember(PerunSession sess, Member member) throws AttributeNotExistsException, InternalErrorException {\n-\t\t//Get all member groups except membersGroup\n-\t\tList<Group> memberGroups = this.getMemberGroups(sess, member);\n-\t\tIterator<Group> groupsIter = memberGroups.iterator();\n-\t\t//Iterate through all groups and remove those which have not authoritativeGroup attribute set to 1\n-\t\twhile(groupsIter.hasNext()) {\n-\t\t\tGroup group = groupsIter.next();\n-\t\t\ttry {\n-\t\t\t\tboolean isThisGroupAuthoritative = false;\n-\t\t\t\tAttribute authoritativeGroup = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_D_AUTHORITATIVE_GROUP);\n-\t\t\t\tif(authoritativeGroup.getValue() != null) {\n-\t\t\t\t\tInteger attrValue = (Integer) authoritativeGroup.getValue();\n-\t\t\t\t\tif(attrValue == 1) isThisGroupAuthoritative = true;\n-\t\t\t\t}\n-\t\t\t\t//If group is not authoritative group, remove it from list of memberAuthoritativeGroups\n-\t\t\t\tif(!isThisGroupAuthoritative) groupsIter.remove();\n-\t\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\t\tthrow new InternalErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn memberGroups;\n-\t}\n-\n-\t/**\n-\t * Gets the groupsManagerImpl for this instance.\n-\t *\n-\t * @return The groupsManagerImpl.\n-\t */\n-\tpublic GroupsManagerImplApi getGroupsManagerImpl() {\n-\t\treturn this.groupsManagerImpl;\n-\t}\n-\n-\t/**\n-\t * Gets the perunBl.\n-\t *\n-\t * @return The perunBl.\n-\t */\n-\tpublic PerunBl getPerunBl() {\n-\t\treturn this.perunBl;\n-\t}\n-\n-\tpublic List<Group> getGroupsByAttribute(PerunSession sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tgetPerunBl().getAttributesManagerBl().checkNamespace(sess, attribute, AttributesManager.NS_GROUP_ATTR);\n-\t\tif(!(getPerunBl().getAttributesManagerBl().isDefAttribute(sess, attribute) || getPerunBl().getAttributesManagerBl().isOptAttribute(sess, attribute))) throw new WrongAttributeAssignmentException(\"This method can process only def and opt attributes\");\n-\t\treturn getGroupsManagerImpl().getGroupsByAttribute(sess, attribute);\n-\t}\n-\n-\tpublic List<Pair<Group, Resource>> getGroupResourcePairsByAttribute(PerunSession sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tgetPerunBl().getAttributesManagerBl().checkNamespace(sess, attribute, AttributesManager.NS_GROUP_RESOURCE_ATTR);\n-\t\tif(!(getPerunBl().getAttributesManagerBl().isDefAttribute(sess, attribute) || getPerunBl().getAttributesManagerBl().isOptAttribute(sess, attribute))) throw new WrongAttributeAssignmentException(\"This method can process only def and opt attributes\");\n-\t\treturn getGroupsManagerImpl().getGroupResourcePairsByAttribute(sess, attribute);\n-\t}\n-\n-\tpublic boolean isGroupMember(PerunSession sess, Group group, Member member) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().isGroupMember(sess, group, member);\n-\t}\n-\n-\tpublic void checkGroupExists(PerunSession sess, Group group) throws InternalErrorException, GroupNotExistsException {\n-\t\tgetGroupsManagerImpl().checkGroupExists(sess, group);\n-\t}\n-\n-\tpublic List<Group> getGroupsByPerunBean(PerunSession sess, PerunBean perunBean) throws InternalErrorException {\n-\t\tList<Group> groups = new ArrayList<Group>();\n-\n-\t\t//All possible useful objects\n-\t\tVo vo = null;\n-\t\tFacility facility = null;\n-\t\tGroup group = null;\n-\t\tMember member = null;\n-\t\tUser user = null;\n-\t\tHost host = null;\n-\t\tResource resource = null;\n-\n-\t\tif(perunBean != null) {\n-\t\t\tif(perunBean instanceof Vo) vo = (Vo) perunBean;\n-\t\t\telse if(perunBean instanceof Facility) facility = (Facility) perunBean;\n-\t\t\telse if(perunBean instanceof Group) group = (Group) perunBean;\n-\t\t\telse if(perunBean instanceof Member) member = (Member) perunBean;\n-\t\t\telse if(perunBean instanceof User) user = (User) perunBean;\n-\t\t\telse if(perunBean instanceof Host) host = (Host) perunBean;\n-\t\t\telse if(perunBean instanceof Resource) resource = (Resource) perunBean;\n-\t\t\telse {\n-\t\t\t\tthrow new InternalErrorException(\"There is unrecognized object in primaryHolder of aidingAttr.\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"Aiding attribute must have primaryHolder which is not null.\");\n-\t\t}\n-\n-\t\t//Important For Groups not work with Subgroups! Invalid members are executed too.\n-\n-\t\tif(group != null) {\n-\t\t\tgroups.add(group);\n-\t\t} else if(member != null) {\n-\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAllMemberGroups(sess, member));\n-\t\t} else if(resource != null) {\n-\t\t\tgroups.addAll(getPerunBl().getResourcesManagerBl().getAssignedGroups(sess, resource));\n-\t\t} else if(user != null) {\n-\t\t\tList<Member> members = getPerunBl().getMembersManagerBl().getMembersByUser(sess, user);\n-\t\t\tfor(Member memberElement: members) {\n-\t\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAllMemberGroups(sess, memberElement));\n-\t\t\t}\n-\t\t} else if(host != null) {\n-\t\t\tfacility = getPerunBl().getFacilitiesManagerBl().getFacilityForHost(sess, host);\n-\t\t\tList<Resource> resourcesFromFacility = getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n-\t\t\tfor(Resource resourceElement: resourcesFromFacility) {\n-\t\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAssignedGroupsToResource(sess, resourceElement));\n-\t\t\t}\n-\t\t} else if(facility != null) {\n-\t\t\tList<Resource> resourcesFromFacility = getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n-\t\t\tfor(Resource resourceElement: resourcesFromFacility) {\n-\t\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAssignedGroupsToResource(sess, resourceElement));\n-\t\t\t}\n-\t\t} else if(vo != null) {\n-\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAllGroups(sess, vo));\n-\t\t}\n-\n-\t\tgroups = new ArrayList<Group>(new HashSet<Group>(groups));\n-\t\treturn groups;\n-\t}\n-\n-\tpublic List<Member> filterMembersByMembershipTypeInGroup(List<Member> members) throws InternalErrorException {\n-\t\tList<Member> filteredMembers = new ArrayList<Member>();\n-\t\tIterator<Member> membersIterator = members.iterator();\n-\n-\t\t//Add members with direct membership type\n-\t\twhile(membersIterator.hasNext()) {\n-\t\t\tMember m = membersIterator.next();\n-\t\t\tif(m.getMembershipType().equals(MembershipType.DIRECT)) {\n-\t\t\t\tfilteredMembers.add(m);\n-\t\t\t\tmembersIterator.remove();\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Add not containing members with indirect membership type\n-\t\tfor(Member m: members) {\n-\t\t\tif(!filteredMembers.contains(m)) filteredMembers.add(m);\n-\t\t}\n-\n-\t\treturn filteredMembers;\n-\t}\n-\n-\tpublic RichGroup filterOnlyAllowedAttributes(PerunSession sess, RichGroup richGroup) throws InternalErrorException {\n-\t\tif(richGroup == null) throw new InternalErrorException(\"RichGroup can't be null.\");\n-\n-\t\t//Filtering richGroup attributes\n-\t\tif(richGroup.getAttributes() != null) {\n-\t\t\tList<Attribute> groupAttributes = richGroup.getAttributes();\n-\t\t\tList<Attribute> allowedGroupAttributes = new ArrayList<Attribute>();\n-\t\t\tfor(Attribute groupAttr : groupAttributes) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.READ, groupAttr, richGroup, null)) {\n-\t\t\t\t\tgroupAttr.setWritable(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttr, richGroup, null));\n-\t\t\t\t\tallowedGroupAttributes.add(groupAttr);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\trichGroup.setAttributes(allowedGroupAttributes);\n-\t\t}\n-\t\treturn richGroup;\n-\t}\n-\n-\tpublic List<RichGroup> filterOnlyAllowedAttributes(PerunSession sess, List<RichGroup> richGroups) throws InternalErrorException {\n-\t\tList<RichGroup> filteredRichGroups = new ArrayList<RichGroup>();\n-\t\tif(richGroups == null || richGroups.isEmpty()) return filteredRichGroups;\n-\n-\t\tfor(RichGroup rg : richGroups) {\n-\t\t\tfilteredRichGroups.add(this.filterOnlyAllowedAttributes(sess, rg));\n-\t\t}\n-\n-\t\treturn filteredRichGroups;\n-\t}\n-\n-\tpublic void setPerunBl(PerunBl perunBl) {\n-\t\tthis.perunBl = perunBl;\n-\t}\n-\n-\tpublic RichGroup convertGroupToRichGroupWithAttributes(PerunSession sess, Group group) throws InternalErrorException{\n-\t\treturn new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group));\n-\t}\n-\n-\tpublic RichGroup convertGroupToRichGroupWithAttributesByName(PerunSession sess, Group group, List<String> attrNames) throws InternalErrorException{\n-\t\tif (attrNames == null) return convertGroupToRichGroupWithAttributes(sess, group);\n-\t\treturn new RichGroup(group,this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group, attrNames));\n-\t}\n-\n-\tpublic List<RichGroup> convertGroupsToRichGroupsWithAttributes(PerunSession sess, List<Group> groups) throws InternalErrorException {\n-\t\tList<RichGroup> richGroups = new ArrayList<>();\n-\t\tfor(Group group: groups) {\n-\t\t\trichGroups.add(new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group)));\n-\t\t}\n-\t\treturn richGroups;\n-\t}\n-\n-\tpublic List<RichGroup> convertGroupsToRichGroupsWithAttributes(PerunSession sess, List<Group> groups, List<String> attrNames) throws InternalErrorException {\n-\t\tif (attrNames == null) return convertGroupsToRichGroupsWithAttributes(sess, groups);\n-\t\tList<RichGroup> richGroups = new ArrayList<>();\n-\t\tfor(Group group: groups) {\n-\t\t\trichGroups.add(new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group, attrNames)));\n-\t\t}\n-\t\treturn richGroups;\n-\t}\n-\n-\tpublic List<RichGroup> getAllRichGroupsWithAttributesByNames(PerunSession sess, Vo vo, List<String> attrNames)throws InternalErrorException{\n-\t\treturn convertGroupsToRichGroupsWithAttributes(sess, this.getAllGroups(sess, vo), attrNames);\n-\t}\n-\n-\tpublic List<RichGroup> getRichSubGroupsWithAttributesByNames(PerunSession sess, Group parentGroup, List<String> attrNames)throws InternalErrorException{\n-\t\treturn convertGroupsToRichGroupsWithAttributes(sess, this.getSubGroups(sess, parentGroup), attrNames);\n-\t}\n-\n-\tpublic List<RichGroup> getAllRichSubGroupsWithAttributesByNames(PerunSession sess, Group parentGroup, List<String> attrNames)throws InternalErrorException{\n-\t\treturn convertGroupsToRichGroupsWithAttributes(sess, this.getAllSubGroups(sess, parentGroup), attrNames);\n-\t}\n-\n-\tpublic RichGroup getRichGroupByIdWithAttributesByNames(PerunSession sess, int groupId, List<String> attrNames)throws InternalErrorException, GroupNotExistsException{\n-\t\treturn convertGroupToRichGroupWithAttributesByName(sess, this.getGroupById(sess, groupId), attrNames);\n-\t}\n-\n-\tpublic void saveInformationAboutGroupSynchronization(PerunSession sess, Group group, boolean failedDueToException, String exceptionMessage) throws AttributeNotExistsException, InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, WrongAttributeValueException {\n-\t\t//get current timestamp of this synchronization\n-\t\tDate currentTimestamp = new Date();\n-\t\tString originalExceptionMessage = exceptionMessage;\n-\t\t//If session is null, throw an exception\n-\t\tif (sess == null) {\n-\t\t\tthrow new InternalErrorException(\"Session is null when trying to save information about synchronization. Group: \" + group + \", timestamp: \" + currentTimestamp + \",message: \" + exceptionMessage);\n-\t\t}\n-\n-\t\t//If group is null, throw an exception\n-\t\tif (group == null) {\n-\t\t\tthrow new InternalErrorException(\"Object group is null when trying to save information about synchronization. Timestamp: \" + currentTimestamp + \", message: \" + exceptionMessage);\n-\t\t}\n-\n-\t\t//if exceptionMessage is empty, use \"Empty message\" instead\n-\t\tif (exceptionMessage != null && exceptionMessage.isEmpty()) {\n-\t\t\texceptionMessage = \"Empty message.\";\n-\t\t//else trim the message on 1000 characters if not null\n-\t\t} else if (exceptionMessage != null && exceptionMessage.length() > 1000) {\n-\t\t\texceptionMessage = exceptionMessage.substring(0, 1000) + \" ... message is too long, other info is in perun log file. If needed, please ask perun administrators.\";\n-\t\t}\n-\n-\t\t//Set correct format of currentTimestamp\n-\t\tString correctTimestampString = BeansUtils.getDateFormatter().format(currentTimestamp);\n-\n-\t\t//Get both attribute definition lastSynchroTimestamp and lastSynchroState\n-\t\t//Get definitions and values, set values\n-\t\tAttribute lastSynchronizationTimestamp = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, AttributesManager.NS_GROUP_ATTR_DEF + \":lastSynchronizationTimestamp\"));\n-\t\tAttribute lastSynchronizationState = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, AttributesManager.NS_GROUP_ATTR_DEF + \":lastSynchronizationState\"));\n-\t\tlastSynchronizationTimestamp.setValue(correctTimestampString);\n-\t\t//if exception is null, set null to value => remove attribute instead of setting in method setAttributes\n-\t\tlastSynchronizationState.setValue(exceptionMessage);\n-\n-\t\t//attributes to set\n-\t\tList<Attribute> attrsToSet = new ArrayList<>();\n-\n-\t\t//null in exceptionMessage means no exception, success\n-\t\t//Set lastSuccessSynchronizationTimestamp if this one is success\n-\t\tif(exceptionMessage == null) {\n-\t\t\tString attrName = AttributesManager.NS_GROUP_ATTR_DEF + \":lastSuccessSynchronizationTimestamp\";\n-\t\t\ttry {\n-\t\t\t\tAttribute lastSuccessSynchronizationTimestamp = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, attrName));\n-\t\t\t\tlastSuccessSynchronizationTimestamp.setValue(correctTimestampString);\n-\t\t\t\tattrsToSet.add(lastSuccessSynchronizationTimestamp);\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tlog.error(\"Can't save lastSuccessSynchronizationTimestamp, because there is missing attribute with name {}\",attrName);\n-\t\t\t}\n-\t\t} else {\n-\t\t\t//Log to auditer_log that synchronization failed or finished with some errors\n-\t\t\tif(failedDueToException) {\n-\t\t\t\tgetPerunBl().getAuditer().log(sess, \"{} synchronization failed because of {}.\", group, originalExceptionMessage);\n-\t\t\t} else {\n-\t\t\t\tgetPerunBl().getAuditer().log(sess, \"{} synchronization finished with errors: {}.\", group, originalExceptionMessage);\n-\t\t\t}\n-\t\t}\n-\n-\t\t//set lastSynchronizationState and lastSynchronizationTimestamp\n-\t\tattrsToSet.add(lastSynchronizationState);\n-\t\tattrsToSet.add(lastSynchronizationTimestamp);\n-\t\t((PerunBl) sess.getPerun()).getAttributesManagerBl().setAttributes(sess, group, attrsToSet);\n-\t}\n-\n-\t@Override\n-\tpublic List<Group> getGroupsWithAssignedExtSourceInVo(PerunSession sess, ExtSource source, Vo vo) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupsWithAssignedExtSourceInVo(sess, source, vo);\n-\t}\n-\n-\t//----------- PRIVATE METHODS FOR  GROUP SYNCHRONIZATION -----------\n-\n-\t/**\n-\t * For lightweight synchronization prepare candidate to add and members to remove.\n-\t *\n-\t * Get all subjects from loginSource and try to find users in Perun by their login and this ExtSource.\n-\t * If found, look if this user is already in synchronized Group. If yes skip him, if not add him to candidateToAdd\n-\t * If not found, add him to candidatesToAdd (from source itself or from memberSource if they are different)\n-\t *\n-\t * Rest of former members need to be add to membersToRemove to remove them from group.\n-\t *\n-\t * This method fill 2 member structures which get as parameters:\n-\t * 1. candidateToAdd - New members of the group\n-\t * 2. membersToRemove - Former members who are not in synchronized ExtSource now\n-\t *\n-\t * @param sess\n-\t * @param group\n-\t * @param loginSource\n-\t * @param memberSource\n-\t * @param groupMembers\n-\t * @param candidatesToAdd\n-\t * @param membersToRemove\n-\t * @param skippedMembers\n-\t * @throws InternalErrorException\n-\t * @throws ExtSourceNotExistsException\n-\t */\n-\tprivate void categorizeMembersForLightweightSynchronization(PerunSession sess, Group group, ExtSource loginSource, ExtSource memberSource, List<RichMember> groupMembers, List<Candidate> candidatesToAdd, List<RichMember> membersToRemove, List<String> skippedMembers) throws InternalErrorException, ExtSourceNotExistsException {\n-\t\t//Get subjects from loginSource\n-\t\tList<Map<String, String>> subjects = getSubjectsFromExtSource(sess, loginSource, group);\n-\n-\t\t//Prepare structure of userIds with richMembers to better work with actual members\n-\t\tMap<Integer, RichMember> idsOfUsersInGroup = new HashMap<>();\n-\t\tfor(RichMember richMember: groupMembers) {\n-\t\t\tidsOfUsersInGroup.put(richMember.getUserId(), richMember);\n-\t\t}\n-\n-\t\t//try to find users by login and loginSource\n-\t\tfor(Map<String, String> subjectFromLoginSource : subjects) {\n-\t\t\tString login = subjectFromLoginSource.get(\"login\");\n-\t\t\t// Skip subjects, which doesn't have login\n-\t\t\tif (login == null || login.isEmpty()) {\n-\t\t\t\tlog.debug(\"Subject {} doesn't contain attribute login, skipping.\", subjectFromLoginSource);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subjectFromLoginSource + \"] was skipped because login is missing\");\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t//try to find user from perun by login and member extSource (need to use memberSource because loginSource is not saved by synchronization)\n-\t\t\tUser user = null;\n-\t\t\tCandidate candidate = null;\n-\t\t\ttry {\n-\t\t\t\tUserExtSource userExtSource = getPerunBl().getUsersManagerBl().getUserExtSourceByExtLogin(sess, memberSource, login);\n-\t\t\t\tuser = getPerunBl().getUsersManagerBl().getUserByUserExtSource(sess, userExtSource);\n-\t\t\t\tif(!idsOfUsersInGroup.containsKey(user.getId())) {\n-\t\t\t\t\tcandidate = new Candidate(user, userExtSource);\n-\t\t\t\t}\n-\t\t\t} catch (UserExtSourceNotExistsException | UserNotExistsException ex) {\n-\t\t\t\t//If not find, get more information about him from member extSource\n-\t\t\t\tList<Map<String, String>> subjectToConvert = Arrays.asList(subjectFromLoginSource);\n-\t\t\t\tList<Candidate> converetedCandidatesList = convertSubjectsToCandidates(sess, subjectToConvert, memberSource, loginSource, skippedMembers);\n-\t\t\t\t//Empty means not found (skipped)\n-\t\t\t\tif(!converetedCandidatesList.isEmpty()) {\n-\t\t\t\t\t//We add one subject so we take the one converted candidate\n-\t\t\t\t\tcandidate = converetedCandidatesList.get(0);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//If user is not null now, we found it so we can use it from perun, in other case he is not in perun at all\n-\t\t\tif(user != null && candidate == null) {\n-\t\t\t\t//we can skip this one, because he is already in group, and remove him from the map\n-\t\t\t\tidsOfUsersInGroup.remove(user.getId());\n-\t\t\t} else if (candidate != null) {\n-\t\t\t\tcandidatesToAdd.add(candidate);\n-\t\t\t} else {\n-\t\t\t\t//Both null means that we can't find subject by login in extSource at all (will be in skipped members)\n-\t\t\t\tlog.debug(\"Subject with login {} was skipped because can't be found in extSource {}.\", login, memberSource);\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Rest of them need to be removed\n-\t\tmembersToRemove.addAll(idsOfUsersInGroup.values());\n-\t}\n-\n-\t/**\n-\t * This method fill 3 member structures which get as parameters:\n-\t * 1. membersToUpdate - Candidates with equivalent Members from Perun for purpose of updating attributes and statuses\n-\t * 2. candidateToAdd - New members of the group\n-\t * 3. membersToRemove - Former members who are not in synchronized ExtSource now\n-\t *\n-\t * @param sess\n-\t * @param groupMembers current group members\n-\t * @param candidates to be synchronized from extSource\n-\t * @param membersToUpdate 1. container (more above)\n-\t * @param candidatesToAdd 2. container (more above)\n-\t * @param membersToRemove 3. container (more above)\n-\t *\n-\t * @throws InternalErrorException if getting RichMembers without attributes for the group fail\n-\t */\n-\tprivate void categorizeMembersForSynchronization(PerunSession sess, List<RichMember> groupMembers, List<Candidate> candidates, List<Candidate> candidatesToAdd, Map<Candidate, RichMember> membersToUpdate, List<RichMember> membersToRemove) throws InternalErrorException {\n-\t\tcandidatesToAdd.addAll(candidates);\n-\t\tmembersToRemove.addAll(groupMembers);\n-\t\t//mapping structure for more efficient searching\n-\t\tMap<UserExtSource, RichMember> mappingStructure = new HashMap<>();\n-\t\tfor(RichMember rm: groupMembers) {\n-\t\t\tfor(UserExtSource ues: rm.getUserExtSources()) {\n-\t\t\t\tmappingStructure.put(ues, rm);\n-\t\t\t}\n-\t\t}\n-\n-\t\t//try to find already existing candidates between members in group\n-\t\tfor(Candidate candidate: candidates) {\n-\t\t\tList<UserExtSource> candidateExtSources = candidate.getUserExtSources();\n-\t\t\tfor(UserExtSource key: candidateExtSources) {\n-\t\t\t\t//candidate exists, will be updated\n-\t\t\t\tif(mappingStructure.containsKey(key)) {\n-\t\t\t\t\tmembersToUpdate.put(candidate, mappingStructure.get(key));\n-\t\t\t\t\tcandidatesToAdd.remove(candidate);\n-\t\t\t\t\tmembersToRemove.remove(mappingStructure.get(key));\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get ExtSource by name from attribute group:groupMembersExtSource.\n-\t * Attribute can be null so if is not set, use default source.\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t * @param defaultSource we need to have already default group source (for synchronization)\n-\t *\n-\t * @return if exists, return membersExtSource, if not, return default group extSource\n-\t *\n-\t * @throws InternalErrorException if some internal error happens\n-\t * @throws WrongAttributeAssignmentException if bad assignment of groupMembersExtSource attribute\n-\t * @throws AttributeNotExistsException if groupMembersExtSource attribute not exists in perun Database\n-\t * @throws ExtSourceNotExistsException if extSource set in Group attribute not exists\n-\t */\n-\tprivate ExtSource getGroupMembersExtSourceForSynchronization(PerunSession sess, Group group, ExtSource defaultSource) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, ExtSourceNotExistsException {\n-\t\t//Prepare the groupMembersExtSource if it is set\n-\t\tAttribute membersExtSourceNameAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPMEMBERSEXTSOURCE_ATTRNAME);\n-\t\tExtSource membersSource = null;\n-\t\t// If the different extSource name for the members was set use it\n-\t\tif (membersExtSourceNameAttr != null && membersExtSourceNameAttr.getValue() != null) {\n-\t\t\tString membersExtSourceName = (String) membersExtSourceNameAttr.getValue();\n-\t\t\tmembersSource = getPerunBl().getExtSourcesManagerBl().getExtSourceByName(sess, membersExtSourceName);\n-\t\t\treturn membersSource;\n-\t\t//Otherwise use use the group one\n-\t\t} else {\n-\t\t\treturn defaultSource;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get ExtSource by name from attribute group:groupExtSource\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t *\n-\t * @return default group extSource for synchronization\n-\t *\n-\t * @throws InternalErrorException if some internal error happens or attribute with extSource name is null\n-\t * @throws WrongAttributeAssignmentException if bad assignment of groupExtSource attribute\n-\t * @throws AttributeNotExistsException if groupExtSource attribute not exists in perun Database\n-\t * @throws ExtSourceNotExistsException if extSource set in Group attribute not exists\n-\t */\n-\tprivate ExtSource getGroupExtSourceForSynchronization(PerunSession sess, Group group) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, ExtSourceNotExistsException {\n-\t\t//Get extSource name from group attribute\n-\t\tAttribute extSourceNameAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPEXTSOURCE_ATTRNAME);\n-\t\tif (extSourceNameAttr == null || extSourceNameAttr.getValue() == null) {\n-\t\t\tthrow new InternalErrorException(\"ExtSource is not set for group: \" + group);\n-\t\t}\n-\t\t//return extSource by name\n-\t\treturn getPerunBl().getExtSourcesManagerBl().getExtSourceByName(sess, ((String) extSourceNameAttr.getValue()));\n-\t}\n-\n-\t/**\n-\t * From membersSource extSource get attribute overwriteUserAttributes and prepare\n-\t * list of attributes names to be overwrite for synchronized users.\n-\t *\n-\t * Attribute has value (if set) in format \"name,name2,name3...\"\n-\t * Method parse these names to list of names.\n-\t * Return empty array if attribute is not set for extSource or if it is empty.\n-\t *\n-\t * @param membersSource to get attributes from\n-\t *\n-\t * @return list of attribute names to be overwrite\n-\t *\n-\t * @throws InternalErrorException if something happens in getting attributes from membersSource\n-\t */\n-\tprivate List<String> getOverwriteUserAttributesListFromExtSource(ExtSource membersSource) throws InternalErrorException {\n-\t\tMap<String, String> membersSourceAttributes = getPerunBl().getExtSourcesManagerBl().getAttributes(membersSource);\n-\t\tList<String> overwriteUserAttributesList = new ArrayList<>();\n-\t\tString overwriteUserAttributes = membersSourceAttributes.get(\"overwriteUserAttributes\");\n-\t\tif(overwriteUserAttributes != null && !overwriteUserAttributes.isEmpty()) {\n-\t\t\t//remove all white spaces and invisible characters\n-\t\t\toverwriteUserAttributes = overwriteUserAttributes.replaceAll(\"\\\\s\", \"\");\n-\t\t\toverwriteUserAttributesList = Arrays.asList(overwriteUserAttributes.split(\",\"));\n-\t\t}\n-\t\treturn overwriteUserAttributesList;\n-\t}\n-\n-\t/**\n-\t * Return true if attribute group:lightweightSynchronization is set to true.\n-\t * False if not.\n-\t *\n-\t * True means: we don't want to update existing members (attributes, statuses etc.), just\n-\t * add new members and remove former members\n-\t * False means: we want to do whole synchronization process including updating operations\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t *\n-\t * @return true if this is lightweightSynchronization, false if not\n-\t *\n-\t * @throws InternalErrorException if something happens while getting lightweightSynchronization attribute\n-\t * @throws WrongAttributeAssignmentException if bad assignment of lightweightSynchronization attribute\n-\t * @throws AttributeNotExistsException if lightweightSynchronization attribute not exists in perun Database\n-\t */\n-\tprivate boolean isThisLightweightSynchronization(PerunSession sess, Group group) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tAttribute lightweightSynchronzationAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPLIGHTWEIGHTSYNCHRONIZATION_ATTRNAME);\n-\t\tboolean lightweightSynchronization = false;\n-\t\tif(lightweightSynchronzationAttr != null && lightweightSynchronzationAttr.getValue() != null) {\n-\t\t\tlightweightSynchronization = (Boolean) lightweightSynchronzationAttr.getValue();\n-\t\t}\n-\t\treturn lightweightSynchronization;\n-\t}\n-\n-\t/**\n-\t * Return List of subjects, where subject is map of attribute names and attribute values.\n-\t * Every subject is structure for creating Candidate from ExtSource.\n-\t *\n-\t * @param sess\n-\t * @param source to get subjects from\n-\t * @param group to be synchronized\n-\t *\n-\t * @return list of subjects\n-\t *\n-\t * @throws InternalErrorException if internal error occurs\n-\t */\n-\tprivate List<Map<String, String>> getSubjectsFromExtSource(PerunSession sess, ExtSource source, Group group) throws InternalErrorException {\n-\t\t//Get all group attributes and store tham to map (info like query, time interval etc.)\n-\t\tList<Attribute> groupAttributes = getPerunBl().getAttributesManagerBl().getAttributes(sess, group);\n-\t\tMap<String, String> groupAttributesMap = new HashMap<String, String>();\n-\t\tfor (Attribute attr: groupAttributes) {\n-\t\t\tString value = BeansUtils.attributeValueToString(attr);\n-\t\t\tString name = attr.getName();\n-\t\t\tgroupAttributesMap.put(name, value);\n-\t\t}\n-\t\t//-- Get Subjects in form of map where left string is name of attribute and right string is value of attribute, every subject is one map\n-\t\tList<Map<String, String>> subjects;\n-\t\ttry {\n-\t\t\tsubjects = ((ExtSourceSimpleApi) source).getGroupSubjects(groupAttributesMap);\n-\t\t\tlog.debug(\"Group synchronization {}: external group contains {} members.\", group, subjects.size());\n-\t\t} catch (ExtSourceUnsupportedOperationException e2) {\n-\t\t\tthrow new InternalErrorException(\"ExtSource \" + source.getName() + \" doesn't support getGroupSubjects\", e2);\n-\t\t}\n-\t\treturn subjects;\n-\t}\n-\n-\t/**\n-\t * Convert List of subjects to list of Candidates.\n-\t *\n-\t * To getting Candidate can use 1 of 3 possible options:\n-\t * 1] membersSource and source are not equals => we have just login, other attributes neet to get from membersSource\n-\t * 2] membersSource==source and membersSource is instance of ExtSourceApi => we already have all attributes in subject\n-\t * 3] membersSource==source and membersSource is instance of SimplExtSourceApi => we have just login, need to read other attributes again\n-\t *\n-\t * If candidate cannot be get for some reason, add this reason to skippedMembers list and skip him.\n-\t *\n-\t * @param sess\n-\t * @param subjects list of subjects from ExtSource (at least login should be here)\n-\t * @param membersSource optional member ExtSource (if members attributes are from other source then their logins)\n-\t * @param source default group ExtSource\n-\t * @param skippedMembers not successfully synchronized members are skipped and information about it should be added here\n-\t *\n-\t * @return list of successfully created candidates from subjects\n-\t *\n-\t * @throws InternalErrorException if some internal error occurs\n-\t * @throws ExtSourceNotExistsException if membersSource not exists in Perun\n-\t */\n-\tprivate List<Candidate> convertSubjectsToCandidates(PerunSession sess, List<Map<String, String>> subjects, ExtSource membersSource, ExtSource source, List<String> skippedMembers) throws InternalErrorException, ExtSourceNotExistsException {\n-\t\tList<Candidate> candidates = new ArrayList<>();\n-\t\tfor (Map<String, String> subject: subjects) {\n-\t\t\tString login = subject.get(\"login\");\n-\t\t\t// Skip subjects, which doesn't have login\n-\t\t\tif (login == null || login.isEmpty()) {\n-\t\t\t\tlog.debug(\"Subject {} doesn't contain attribute login, skipping.\", subject);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because login is missing\");\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\t// One of three possible ways should happen to get Candidate\n-\t\t\t\t// 1] sources of login and other attributes are not same\n-\t\t\t\tif(!membersSource.equals(source)) {\n-\t\t\t\t\t//need to read attributes from the new memberSource, we can't use locally data there (there are from other extSource)\n-\t\t\t\t\tcandidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, membersSource, login)));\n-\t\t\t\t// 2] sources are same and we work with source which is instance of ExtSourceApi\n-\t\t\t\t} else if (membersSource instanceof ExtSourceApi) {\n-\t\t\t\t\t// we can use the data from this source without reading them again (all exists in the map of subject attributes)\n-\t\t\t\t\tcandidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, subject, membersSource, login)));\n-\t\t\t\t// 3] sources are same and we work with source which is instace of ExtSourceSimpleApi\n-\t\t\t\t} else if (membersSource instanceof ExtSourceSimpleApi) {\n-\t\t\t\t\t// we can't use the data from this source, we need to read them again (they are not in the map of subject attributes)\n-\t\t\t\t\tcandidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, membersSource, login)));\n-\t\t\t\t} else {\n-\t\t\t\t\t// this could not happen without change in extSource API code\n-\t\t\t\t\tthrow new InternalErrorException(\"ExtSource is other instance than SimpleApi or Api and this is not supported!\");\n-\t\t\t\t}\n-\t\t\t} catch (CandidateNotExistsException e) {\n-\t\t\t\tlog.warn(\"getGroupSubjects subjects returned login {}, but it cannot be obtained using getCandidate()\", login);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because candidate can't be found by login:'\" + login + \"' in extSource \" + membersSource);\n-\t\t\t\tcontinue;\n-\t\t\t} catch (ExtSourceUnsupportedOperationException e) {\n-\t\t\t\tlog.warn(\"ExtSource {} doesn't support getCandidate operation.\", membersSource);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because extSource \" + membersSource + \" not support method getCandidate\");\n-\t\t\t\tcontinue;\n-\t\t\t} catch (ParserException e) {\n-\t\t\t\tlog.warn(\"Can't parse value {} from candidate with login {}\", e.getParsedValue(), login);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because of problem with parsing value '\" + e.getParsedValue() + \"'\");\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn candidates;\n-\t}\n-\n-\t/**\n-\t * Get Map membersToUpdate and update their attributes, extSources, expirations and statuses.\n-\t *\n-\t * For Member - updateAttributes\n-\t * For User - updateAttributes if exists in list of overwriteUserAttributesList,\n-\t *            in other case just mergeAttributes.\n-\t *\n-\t * updateAttributes = store new values\n-\t * mergeAttributes = for List and Map add new values, do not remove old one,\n-\t *                   for other cases store new values (like String, Integer etc.)\n-\t *\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t * @param membersToUpdate list of members for updating in Perun by information from extSource\n-\t * @param overwriteUserAttributesList list of user attributes to be updated instead of merged\n-\t *\n-\t * @throws InternalErrorException if some internal error occurs\n-\t * @throws AttributeNotExistsException if some attributes not exists and for this reason can't be updated\n-\t * @throws WrongAttributeAssignmentException if some attribute is updated in bad way (bad assignment)\n-\t */\n-\tprivate void updateExistingMembersWhileSynchronization(PerunSession sess, Group group, Map<Candidate, RichMember> membersToUpdate, List<String> overwriteUserAttributesList) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tList<AttributeDefinition> attrDefs = new ArrayList<>();\n-\t\t//Iterate through all subject attributes\n-\t\tfor(Candidate candidate: membersToUpdate.keySet()) {\n-\t\t\tRichMember richMember = membersToUpdate.get(candidate);\n-\n-\t\t\t//If member not exists in this moment (somebody remove him before start of updating), skip him and log it\n-\t\t\ttry {\n-\t\t\t\tgetPerunBl().getMembersManagerBl().checkMemberExists(sess, richMember);\n-\t\t\t} catch (MemberNotExistsException ex) {\n-\t\t\t\t//log it and skip this member\n-\t\t\t\tlog.debug(\"Someone removed member {} from group {} before updating process. Skip him.\", richMember, group);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t//load attrDefinitions just once for first candidate\n-\t\t\tif(attrDefs.isEmpty()) {\n-\t\t\t\tfor(String attrName : candidate.getAttributes().keySet()) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tAttributeDefinition attrDef = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attrName);\n-\t\t\t\t\t\tattrDefs.add(attrDef);\n-\t\t\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\t\t\tlog.error(\"Can't synchronize attribute \" + attrName + \" for candidate \" + candidate + \" and for group \" + group);\n-\t\t\t\t\t\t//skip this attribute at all\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//get RichMember with attributes\n-\t\t\trichMember = getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, Arrays.asList(richMember), attrDefs).get(0);\n-\t\t\tfor (String attributeName : candidate.getAttributes().keySet()) {\n-\t\t\t\t//update member attribute\n-\t\t\t\tif(attributeName.startsWith(AttributesManager.NS_MEMBER_ATTR)) {\n-\t\t\t\t\tboolean attributeFound = false;\n-\t\t\t\t\tfor (Attribute memberAttribute: richMember.getMemberAttributes()) {\n-\t\t\t\t\t\tif(memberAttribute.getName().equals(attributeName)) {\n-\t\t\t\t\t\t\tattributeFound = true;\n-\t\t\t\t\t\t\tObject subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), memberAttribute.getType());\n-\t\t\t\t\t\t\tif (subjectAttributeValue != null && !memberAttribute.getValue().equals(subjectAttributeValue)) {\n-\t\t\t\t\t\t\t\tlog.trace(\"Group synchronization {}: value of the attribute {} for memberId {} changed. Original value {}, new value {}.\",\n-\t\t\t\t\t\t\t\t\t\tnew Object[] {group, memberAttribute, richMember.getId(), memberAttribute.getValue(), subjectAttributeValue});\n-\t\t\t\t\t\t\t\tmemberAttribute.setValue(subjectAttributeValue);\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember, memberAttribute);\n-\t\t\t\t\t\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t\t\t\t\t\t// There is a problem with attribute value, so set INVALID status for the member\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n-\t\t\t\t\t\t\t\t} catch\t(WrongAttributeAssignmentException e) {\n-\t\t\t\t\t\t\t\t\tthrow new ConsistencyErrorException(e);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t//we found it, but there is no change;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\t//member has not set this attribute so set it now if possible\n-\t\t\t\t\tif(!attributeFound) {\n-\t\t\t\t\t\tAttribute newAttribute = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attributeName));\n-\t\t\t\t\t\tObject subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), newAttribute.getType());\n-\t\t\t\t\t\tnewAttribute.setValue(subjectAttributeValue);\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// Try to set member's attributes\n-\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember, newAttribute);\n-\t\t\t\t\t\t\tlog.trace(\"Setting the {} value {}\", newAttribute, candidate.getAttributes().get(attributeName));\n-\t\t\t\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t\t\t\t// There is a problem with attribute value, so set INVALID status for the member\n-\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t//update user attribute\n-\t\t\t\t} else if(attributeName.startsWith(AttributesManager.NS_USER_ATTR)) {\n-\t\t\t\t\tboolean attributeFound = false;\n-\t\t\t\t\tfor (Attribute userAttribute: richMember.getUserAttributes()) {\n-\t\t\t\t\t\tif(userAttribute.getName().equals(attributeName)) {\n-\t\t\t\t\t\t\tattributeFound = true;\n-\t\t\t\t\t\t\tObject subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), userAttribute.getType());\n-\t\t\t\t\t\t\tif (!userAttribute.getValue().equals(subjectAttributeValue)) {\n-\t\t\t\t\t\t\t\tlog.trace(\"Group synchronization {}: value of the attribute {} for memberId {} changed. Original value {}, new value {}.\",\n-\t\t\t\t\t\t\t\t\t\tnew Object[] {group, userAttribute, richMember.getId(), userAttribute.getValue(), subjectAttributeValue});\n-\t\t\t\t\t\t\t\tuserAttribute.setValue(subjectAttributeValue);\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t//Choose set or merge by extSource attribute overwriteUserAttributes (if contains this one)\n-\t\t\t\t\t\t\t\t\tif(overwriteUserAttributesList.contains(userAttribute.getName())) {\n-\t\t\t\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember.getUser(), userAttribute);\n-\t\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().mergeAttributeValueInNestedTransaction(sess, richMember.getUser(), userAttribute);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t\t\t\t\t\t// There is a problem with attribute value, so set INVALID status for the member\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n-\t\t\t\t\t\t\t\t} catch (WrongAttributeAssignmentException e) {\n-\t\t\t\t\t\t\t\t\tthrow new ConsistencyErrorException(e);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t//we found it, but there is no change\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\t//user has not set this attribute so set it now if\n-\t\t\t\t\tif(!attributeFound) {\n-\t\t\t\t\t\tAttribute newAttribute = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attributeName));\n-\t\t\t\t\t\tObject subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), newAttribute.getType());\n-\t\t\t\t\t\tnewAttribute.setValue(subjectAttributeValue);\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// Try to set user's attributes\n-\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember.getUser(), newAttribute);\n-\t\t\t\t\t\t\tlog.trace(\"Setting the {} value {}\", newAttribute, candidate.getAttributes().get(attributeName));\n-\t\t\t\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t\t\t\t// There is a problem with attribute value, so set INVALID status for the member\n-\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t//we are not supporting other attributes then member or user so skip it without error, but log it\n-\t\t\t\t\tlog.error(\"Attribute {} can't be set, because it is not member or user attribute.\", attributeName);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//Synchronize userExtSources (add not existing)\n-\t\t\tfor (UserExtSource ues : candidate.getUserExtSources()) {\n-\t\t\t\tif (!getPerunBl().getUsersManagerBl().userExtSourceExists(sess, ues)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getUsersManagerBl().addUserExtSource(sess, richMember.getUser(), ues);\n-\t\t\t\t\t} catch (UserExtSourceExistsException e) {\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"Adding already existing userExtSource \" + ues, e);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//Set correct member Status\n-\t\t\t// If the member has expired or disabled status, try to expire/validate him (depending on expiration date)\n-\t\t\tif (richMember.getStatus().equals(Status.DISABLED) || richMember.getStatus().equals(Status.EXPIRED)) {\n-\t\t\t\tDate now = new Date();\n-\t\t\t\tAttribute membershipExpiration = getPerunBl().getAttributesManagerBl().getAttribute(sess, richMember, AttributesManager.NS_MEMBER_ATTR_DEF + \":membershipExpiration\");\n-\t\t\t\tif(membershipExpiration.getValue() != null) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tDate currentMembershipExpirationDate = BeansUtils.getDateFormatterWithoutTime().parse((String) membershipExpiration.getValue());\n-\t\t\t\t\t\tif (currentMembershipExpirationDate.before(now)) {\n-\t\t\t\t\t\t\t//disabled members which are after expiration date will be expired\n-\t\t\t\t\t\t\tif (richMember.getStatus().equals(Status.DISABLED)) {\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tperunBl.getMembersManagerBl().expireMember(sess, richMember);\n-\t\t\t\t\t\t\t\t\tlog.info(\"Switching member id {} to EXPIRE state, due to expiration {}.\", richMember.getId(), (String) membershipExpiration.getValue());\n-\t\t\t\t\t\t\t\t\tlog.debug(\"Switching member to EXPIRE state, additional info: membership expiration date='{}', system now date='{}'\", currentMembershipExpirationDate, now);\n-\t\t\t\t\t\t\t\t} catch (MemberNotValidYetException e) {\n-\t\t\t\t\t\t\t\t\tlog.error(\"Consistency error while trying to expire member id {}, exception {}\", richMember.getId(), e);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t//disabled and expired members which are before expiration date will be validated\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tperunBl.getMembersManagerBl().validateMember(sess, richMember);\n-\t\t\t\t\t\t\t\tlog.info(\"Switching member id {} to VALID state, due to expiration {}.\", richMember.getId(), (String) membershipExpiration.getValue());\n-\t\t\t\t\t\t\t\tlog.debug(\"Switching member to VALID state, additional info: membership expiration date='{}', system now date='{}'\", currentMembershipExpirationDate, now);\n-\t\t\t\t\t\t\t} catch (WrongAttributeValueException e) {\n-\t\t\t\t\t\t\t\tlog.error(\"Error during validating member id {}, exception {}\", richMember.getId(), e);\n-\t\t\t\t\t\t\t} catch (WrongReferenceAttributeValueException e) {\n-\t\t\t\t\t\t\t\tlog.error(\"Error during validating member id {}, exception {}\", richMember.getId(), e);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (ParseException ex) {\n-\t\t\t\t\t\tlog.error(\"Group synchronization: memberId {} expiration String cannot be parsed, exception {}.\",richMember.getId(), ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// If the member has INVALID status, try to validate the member\n-\t\t\ttry {\n-\t\t\t\tif (richMember.getStatus().equals(Status.INVALID)) {\n-\t\t\t\t\tgetPerunBl().getMembersManagerBl().validateMember(sess, richMember);\n-\t\t\t\t}\n-\t\t\t} catch (WrongAttributeValueException e) {\n-\t\t\t\tlog.info(\"Member id {} will stay in INVALID state, because there was problem with attributes {}.\", richMember.getId(), e);\n-\t\t\t} catch (WrongReferenceAttributeValueException e) {\n-\t\t\t\tlog.info(\"Member id {} will stay in INVALID state, because there was problem with attributes {}.\", richMember.getId(), e);\n-\t\t\t}\n-\n-\t\t\t// If the member has still DISABLED status, try to validate the member\n-\t\t\ttry {\n-\t\t\t\tif (richMember.getStatus().equals(Status.DISABLED)) {\n-\t\t\t\t\tgetPerunBl().getMembersManagerBl().validateMember(sess, richMember);\n-\t\t\t\t}\n-\t\t\t} catch (WrongAttributeValueException e) {\n-\t\t\t\tlog.info(\"Switching member id {} into INVALID state from DISABLED, because there was problem with attributes {}.\", richMember.getId(), e);\n-\t\t\t} catch (WrongReferenceAttributeValueException e) {\n-\t\t\t\tlog.info(\"Switching member id {} into INVALID state from DISABLED, because there was problem with attributes {}.\", richMember.getId(), e);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get list of new candidates and add them to the Group.\n-\t *\n-\t * If Candidate can't be added to Group, skip him and add this information to skippedMembers list.\n-\t *\n-\t * When creating new member from Candidate, if user already exists, merge his attributes,\n-\t * if attribute exists in list of overwriteUserAttributesList, update it instead of merging.\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t * @param candidatesToAdd list of new members (candidates)\n-\t * @param overwriteUserAttributesList list of attributes to be updated for user if found\n-\t * @param skippedMembers list of not successfully synchronized members\n-\t *\n-\t * @throws InternalErrorException if some internal error occurs\n-\t */\n-\tprivate void addMissingMembersWhileSynchronization(PerunSession sess, Group group, List<Candidate> candidatesToAdd, List<String> overwriteUserAttributesList, List<String> skippedMembers) throws InternalErrorException, GroupOperationsException {\n-\t\t// Now add missing members\n-\t\tfor (Candidate candidate: candidatesToAdd) {\n-\t\t\tMember member = null;\n-\t\t\ttry {\n-\t\t\t\t// Check if the member is already in the VO (just not in the group)\n-\t\t\t\tmember = getPerunBl().getMembersManagerBl().getMemberByUserExtSources(sess, getPerunBl().getGroupsManagerBl().getVo(sess, group), candidate.getUserExtSources());\n-\n-\t\t\t\t// member exists - update attributes\n-\t\t\t\tMap<Candidate,RichMember> memberMap = new HashMap<>();\n-\t\t\t\tmemberMap.put(candidate, getPerunBl().getMembersManagerBl().getRichMember(sess, member));\n-\t\t\t\ttry {\n-\t\t\t\t\tupdateExistingMembersWhileSynchronization(sess, group, memberMap, overwriteUserAttributesList);\n-\t\t\t\t} catch (WrongAttributeAssignmentException | AttributeNotExistsException e) {\n-\t\t\t\t\t// if update fails, skip him\n-\t\t\t\t\tlog.warn(\"Can't update member from candidate {} due to attribute value exception {}.\", candidate, e);\n-\t\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because there was problem when updating member from candidate: Exception: \" + e.getName() + \" => '\" + e.getMessage() + \"'\");\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t} catch (MemberNotExistsException e) {\n-\t\t\t\ttry {\n-\t\t\t\t\t// We have new member (candidate), so create him using synchronous createMember (and overwrite chosed user attributes)\n-\t\t\t\t\tmember = getPerunBl().getMembersManagerBl().createMemberSync(sess, getPerunBl().getGroupsManagerBl().getVo(sess, group), candidate, null, overwriteUserAttributesList);\n-\t\t\t\t\tlog.info(\"Group synchronization {}: New member id {} created during synchronization.\", group, member.getId());\n-\t\t\t\t} catch (AlreadyMemberException e1) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(\"Trying to add existing member\");\n-\t\t\t\t} catch (AttributeValueException e1) {\n-\t\t\t\t\tlog.warn(\"Can't create member from candidate {} due to attribute value exception {}.\", candidate, e1);\n-\t\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because there was problem when createing member from candidate: Exception: \" + e1.getName() + \" => '\" + e1.getMessage() + \"'\");\n-\t\t\t\t\tcontinue;\n-\t\t\t\t} catch (ExtendMembershipException ex) {\n-\t\t\t\t\tlog.warn(\"Can't create member from candidate {} due to membership expiration exception {}.\", candidate, ex);\n-\t\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because membership expiration: Exception: \" + ex.getName() + \" => \" + ex.getMessage() + \"]\");\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\ttry {\n-\t\t\t\t// Add the member to the group\n-\t\t\t\tif (!group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\t\t\t// Do not add members to the generic members group\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().addMember(sess, group, member);\n-\t\t\t\t\t} catch(NotMemberOfParentGroupException | GroupNotExistsException ex) {\n-\t\t\t\t\t\t// Shouldn't happen, because every group has at least Members group as a parent\n-\t\t\t\t\t\t// Shouldn't happen, group should always exist\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tlog.info(\"Group synchronization {}: New member id {} added.\", group, member.getId());\n-\t\t\t} catch (AlreadyMemberException e) {\n-\t\t\t\t//This part is ok, it means someone add member before synchronization ends, log it and skip this member\n-\t\t\t\tlog.debug(\"Member {} was added to group {} before adding process. Skip this member.\", member, group);\n-\t\t\t\tcontinue;\n-\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t// There is a problem with attribute value, so set INVALID status of the member\n-\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, member);\n-\t\t\t}\n-\n-\t\t\t// Try to validate member\n-\t\t\ttry {\n-\t\t\t\tgetPerunBl().getMembersManagerBl().validateMember(sess, member);\n-\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\tlog.warn(\"Member id {} will be in INVALID status due to wrong attributes {}.\", member.getId(), e);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Remove former members from group (if they are not listed in ExtSource yet).\n-\t *\n-\t * If this is membersGroup (of some Vo) try to disableMember, if not possible then delete him.\n-\t * If this is regular group (of some Vo) remove him and if this group is also\n-\t * his last authoritative group, disable or delete him also in the Vo.\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t * @param membersToRemove list of members to be removed from Group\n-\t *\n-\t * @throws InternalErrorException if some internal error occurs\n-\t * @throws WrongAttributeAssignmentException if there is some problem with assignment of attribute\n-\t * @throws MemberAlreadyRemovedException if member is already out of group when we trying to do this by synchronization\n-\t */\n-\tprivate void removeFormerMembersWhileSynchronization(PerunSession sess, Group group, List<RichMember> membersToRemove) throws InternalErrorException, WrongAttributeAssignmentException, MemberAlreadyRemovedException, GroupOperationsException, GroupNotExistsException {\n-\t\t//First get information if this group is authoritative group\n-\t\tboolean thisGroupIsAuthoritativeGroup = false;\n-\t\ttry {\n-\t\t\tAttribute authoritativeGroupAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_D_AUTHORITATIVE_GROUP);\n-\t\t\tif(authoritativeGroupAttr.getValue() != null) {\n-\t\t\t\tInteger authoritativeGroupValue = (Integer) authoritativeGroupAttr.getValue();\n-\t\t\t\tif(authoritativeGroupValue == 1) thisGroupIsAuthoritativeGroup = true;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t//Means that this group is not authoritative\n-\t\t\tlog.error(\"Attribute {} doesn't exists.\", A_G_D_AUTHORITATIVE_GROUP);\n-\t\t}\n-\n-\t\t//Second remove members (use authoritative group where is needed)\n-\t\tfor (RichMember member: membersToRemove) {\n-\t\t\t// Member is missing in the external group, so remove him from the perun group\n-\t\t\ttry {\n-\t\t\t\t//members group\n-\t\t\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\t\t\t// If the group is members group, the member must be disabled as a member of VO\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().disableMember(sess, member);\n-\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} disabled.\", group, member.getId());\n-\t\t\t\t\t} catch(MemberNotValidYetException ex) {\n-\t\t\t\t\t\t//Member is still invalid in perun. We can delete him.\n-\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().deleteMember(sess, member);\n-\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} would have been disabled but he has been deleted instead because he was invalid.\", group, member.getId());\n-\t\t\t\t\t}\n-\t\t\t\t\t//not members group\n-\t\t\t\t} else {\n-\t\t\t\t\t//If this group is authoritative group, check if this is last authoritative group of this member\n-\t\t\t\t\t//If Yes = deleteMember (from Vo), if No = only removeMember\n-\t\t\t\t\tif(thisGroupIsAuthoritativeGroup) {\n-\t\t\t\t\t\tList<Group> memberAuthoritativeGroups = null;\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tmemberAuthoritativeGroups = getAllAuthoritativeGroupsOfMember(sess, member);\n-\t\t\t\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\t\t\t\t//This means that no authoritative group can exists without this attribute\n-\t\t\t\t\t\t\tlog.error(\"Attribute {} doesn't exists.\", A_G_D_AUTHORITATIVE_GROUP);\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t//If list of member authoritativeGroups is not null, attribute exists\n-\t\t\t\t\t\tif(memberAuthoritativeGroups != null) {\n-\t\t\t\t\t\t\tmemberAuthoritativeGroups.remove(group);\n-\t\t\t\t\t\t\tif(memberAuthoritativeGroups.isEmpty()) {\n-\t\t\t\t\t\t\t\t//First try to disable member, if is invalid, delete him from Vo\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().disableMember(sess, member);\n-\t\t\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} disabled because synchronizer wants to remove him from last authoritativeGroup in Vo.\", group, member.getId());\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n-\t\t\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n-\t\t\t\t\t\t\t\t} catch(MemberNotValidYetException ex) {\n-\t\t\t\t\t\t\t\t\t//Member is still invalid in perun. We can delete him.\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().deleteMember(sess, member);\n-\t\t\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} would have been disabled but he has been deleted instead because he was invalid and synchronizer wants to remove him from last authoritativeGroup in Vo.\", group, member.getId());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t//If there is still some other authoritative group for this member, only remove him from group\n-\t\t\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n-\t\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t//If list of member authoritativeGroups is null, attribute not exists, only remove member from Group\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n-\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n-\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (NotGroupMemberException e) {\n-\t\t\t\tthrow new ConsistencyErrorException(\"Trying to remove non-existing user\");\n-\t\t\t} catch (MemberAlreadyRemovedException ex) {\n-\t\t\t\t//Member was probably removed before starting of synchronization removing process, log it and skip this member\n-\t\t\t\tlog.debug(\"Member {} was removed from group {} before removing process. Skip this member.\", member, group);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Try to close both extSources (membersSource and group source)\n-\t *\n-\t * @param membersSource optional membersSource\n-\t * @param source default groupSource\n-\t */\n-\tprivate void closeExtSourcesAfterSynchronization(ExtSource membersSource, ExtSource source) {\n-\t\t//Close open extSources (not empty ones) if they support this operation\n-\t\tif(membersSource != null) {\n-\t\t\ttry {\n-\t\t\t\t((ExtSourceSimpleApi) membersSource).close();\n-\t\t\t} catch (ExtSourceUnsupportedOperationException e) {\n-\t\t\t\t// ExtSource doesn't support that functionality, so silently skip it.\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.info(\"Can't close membersSource connection. Cause: {}\", e);\n-\t\t\t}\n-\t\t}\n-\t\tif(source != null) {\n-\t\t\ttry {\n-\t\t\t\t((ExtSourceSimpleApi) source).close();\n-\t\t\t} catch (ExtSourceUnsupportedOperationException e) {\n-\t\t\t\t// ExtSource doesn't support that functionality, so silently skip it.\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.info(\"Can't close extSource connection. Cause: {}\", e);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void processRelationMembers(PerunSession sess, Group resultGroup, List<Member> changedMembers, int sourceGroupId, boolean addition) throws GroupOperationsException {\n-\n-\t\tList<Member> newMembers;\n-\n-\t\ttry {\n-\t\t\tif (addition) {\n-\t\t\t\tnewMembers = addIndirectMembers(sess, resultGroup, changedMembers, sourceGroupId);\n-\t\t\t} else {\n-\t\t\t\tnewMembers = removeIndirectMembers(sess, resultGroup, changedMembers, sourceGroupId);\n-\t\t\t}\n-\n-\t\t\tif (newMembers.isEmpty()) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, resultGroup.getId());\n-\t\t\tfor (Integer groupId : relations) {\n-\t\t\t\tprocessRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), newMembers, resultGroup.getId(), addition);\n-\t\t\t}\n-\t\t} catch (WrongReferenceAttributeValueException | WrongAttributeValueException | AlreadyMemberException |\n-\t\t\t\tInternalErrorException | NotGroupMemberException | GroupNotExistsException ex) {\n-\t\t\tthrow new GroupOperationsException(ex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Group createGroupUnion(PerunSession sess, Group resultGroup, Group operandGroup, boolean parentFlag) throws GroupOperationsException, InternalErrorException, GroupRelationAlreadyExists, GroupRelationNotAllowed {\n-\n-\t\t// block inclusion to members group, since it doesn't make sense\n-\t\t// allow inclusion of members group, since we want to delegate privileges on assigning all vo members to some service for group manager.\n-\t\tif(resultGroup.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthrow new GroupRelationNotAllowed(\"Union cannot be created when result group \" + resultGroup + \" is members group.\");\n-\t\t}\n-\n-\t\t// check if both groups are from same VO\n-\t\tif (resultGroup.getVoId() != operandGroup.getVoId()) {\n-\t\t\tthrow new GroupRelationNotAllowed(\"Union cannot be created on groups: \" + resultGroup + \", \" + operandGroup + \". They are not from the same VO.\");\n-\t\t}\n-\n-\t\t// check if result group is the same as operand group\n-\t\tif (resultGroup.getId() == operandGroup.getId()) {\n-\t\t\tthrow new GroupRelationNotAllowed(\"Result group \" + resultGroup + \" cannot be the same as operand group \" + operandGroup);\n-\t\t} \n-\n-\t\t// check if there is already a record of these two groups\n-\t\tif (this.groupsManagerImpl.isRelationBetweenGroups(resultGroup, operandGroup)) {\n-\t\t\tthrow new GroupRelationAlreadyExists(\"There is already a relation defined between result group \" + resultGroup +\n-\t\t\t\t\t\" and operand group \" + operandGroup + \" or they are in hierarchical structure.\");\n-\t\t}\n-\n-\t\t// check cycle between groups\n-\t\tif (checkGroupsCycle(sess, resultGroup.getId(), operandGroup.getId())) {\n-\t\t\tthrow new GroupRelationNotAllowed(\"Union between result group \" + resultGroup + \" and operand group \" + operandGroup + \" would create group cycle.\");\n-\t\t}\n-\n-\t\t// save group relation\n-\t\tgroupsManagerImpl.saveGroupRelation(sess, resultGroup, operandGroup, parentFlag);\n-\n-\t\t// do the operation logic\n-\t\tprocessRelationMembers(sess, resultGroup, getGroupMembers(sess, operandGroup), operandGroup.getId(), true);\n-\n-\t\treturn resultGroup;\n-\t}\n-\n-\t@Override\n-\tpublic void removeGroupUnion(PerunSession sess, Group resultGroup, Group operandGroup, boolean parentFlag) throws GroupOperationsException, InternalErrorException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tif (!groupsManagerImpl.isOneWayRelationBetweenGroups(resultGroup, operandGroup)) {\n-\t\t\tthrow new GroupRelationDoesNotExist(\"Union does not exist between result group \" + resultGroup + \" and operand group\" + operandGroup + \".\");\n-\t\t}\n-\n-\t\tif (parentFlag || groupsManagerImpl.isRelationRemovable(sess, resultGroup, operandGroup)) {\n-\t\t\tprocessRelationMembers(sess, resultGroup, getGroupMembers(sess, operandGroup), operandGroup.getId(), false);\n-\t\t} else {\n-\t\t\tthrow new GroupRelationCannotBeRemoved(\"Union between result group \" + resultGroup + \" and operand group\" + operandGroup +\n-\t\t\t\t\t\" cannot be removed, because it's part of the hierarchical structure of the groups.\");\n-\t\t}\n-\n-\t\tgroupsManagerImpl.removeGroupUnion(sess, resultGroup, operandGroup);\n-\t}\n-\n-\t@Override\n-\tpublic List<Group> getGroupUnions(PerunSession session, Group group, boolean reverseDirection) throws InternalErrorException {\n-\t\tif (reverseDirection) {\n-\t\t\treturn groupsManagerImpl.getResultGroups(session, group.getId());\n-\t\t} else {\n-\t\t\treturn groupsManagerImpl.getOperandGroups(session, group.getId());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Check if cycle would be created by adding union between these groups.\n-\t *\n-\t * @param sess perun session\n-\t * @param resultGroupId result group id\n-\t * @param operandGroupId operand group id\n-\t * @return true if cycle would be created; false otherwise\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate boolean checkGroupsCycle(PerunSession sess, int resultGroupId, int operandGroupId) throws InternalErrorException {\n-\t\tList<Integer> groupsIds = groupsManagerImpl.getResultGroupsIds(sess, resultGroupId);\n-\n-\t\tif (groupsIds.contains(operandGroupId)) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tfor (Integer id: groupsIds) {\n-\t\t\tif(checkGroupsCycle(sess, id, operandGroupId)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n+    private final static Logger log = LoggerFactory.getLogger(GroupsManagerBlImpl.class);\n+\n+    private final GroupsManagerImplApi groupsManagerImpl;\n+    private PerunBl perunBl;\n+\n+    private Map<Integer, GroupSynchronizerThread> groupSynchronizerThreads;\n+    private static final String A_G_D_AUTHORITATIVE_GROUP = AttributesManager.NS_GROUP_ATTR_DEF + \":authoritativeGroup\";\n+\n+    /**\n+     * Create new instance of this class.\n+     */\n+    public GroupsManagerBlImpl(GroupsManagerImplApi groupsManagerImpl) {\n+        this.groupsManagerImpl = groupsManagerImpl;\n+        this.groupSynchronizerThreads = new HashMap<Integer, GroupSynchronizerThread>();\n+    }\n+\n+    public Group createGroup(PerunSession sess, Vo vo, Group group) throws GroupExistsException, InternalErrorException {\n+        group = getGroupsManagerImpl().createGroup(sess, vo, group);\n+        getPerunBl().getAuditer().log(sess, \"{} created in {}.\", group, vo);\n+        group.setVoId(vo.getId());\n+\n+\n+        //set creator as group admin unless he already have authz right on the group (he is VO admin)\n+        User user = sess.getPerunPrincipal().getUser();\n+        if (user != null) {   //user can be null in tests\n+            if (!AuthzResolverBlImpl.isAuthorized(sess, Role.VOADMIN, vo)) {\n+                try {\n+                    AuthzResolverBlImpl.setRole(sess, user, group, Role.GROUPADMIN);\n+                } catch (AlreadyAdminException e) {\n+                    throw new ConsistencyErrorException(\"Newly created group already have an admin.\", e);\n+                }\n+            }\n+        }\n+\n+        return group;\n+    }\n+\n+    public Group createGroup(PerunSession sess, Group parentGroup, Group group) throws GroupExistsException, InternalErrorException, GroupOperationsException, GroupRelationNotAllowed, GroupRelationAlreadyExists {\n+        Vo vo = this.getVo(sess, parentGroup);\n+\n+        group = getGroupsManagerImpl().createGroup(sess, vo, parentGroup, group);\n+        parentGroup = createGroupUnion(sess, parentGroup, group, true);\n+\n+        getPerunBl().getAuditer().log(sess, \"{} created in {} as subgroup of {}\", group, vo, parentGroup);\n+\n+        return group;\n+    }\n+\n+    public void deleteGroup(PerunSession sess, Group group, boolean forceDelete)\n+            throws InternalErrorException, RelationExistsException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+        if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+            throw new java.lang.IllegalArgumentException(\"Built-in \" + group.getName() + \" group cannot be deleted separately.\");\n+        }\n+\n+        this.deleteAnyGroup(sess, group, forceDelete);\n+    }\n+\n+    public void deleteGroups(PerunSession perunSession, List<Group> groups, boolean forceDelete)\n+            throws InternalErrorException, GroupAlreadyRemovedException, RelationExistsException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+        //Use sorting by group names reverse order (first name A:B:c then A:B etc.)\n+        Collections.sort(groups, Collections.reverseOrder(\n+                new Comparator<Group>() {\n+                    @Override\n+                    public int compare(Group groupToCompare, Group groupToCompareWith) {\n+                        return groupToCompare.getName().compareTo(groupToCompareWith.getName());\n+                    }\n+                }));\n+\n+        for (Group group : groups) {\n+            this.deleteGroup(perunSession, group, forceDelete);\n+        }\n+    }\n+\n+    public void deleteMembersGroup(PerunSession sess, Vo vo) throws InternalErrorException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+        Group group;\n+        try {\n+            group = getGroupByName(sess, vo, VosManager.MEMBERS_GROUP);\n+        } catch (GroupNotExistsException e) {\n+            throw new ConsistencyErrorException(\"Built-in members group must exists.\", e);\n+        }\n+        try {\n+            this.deleteAnyGroup(sess, group, true);\n+        } catch (RelationExistsException e) {\n+            throw new ConsistencyErrorException(\"Built-in members group cannot have any relation in this stage.\", e);\n+        }\n+    }\n+\n+    /**\n+     * If forceDelete is false, delete only group which has no subgroup and no member.\n+     * If forceDelete is true, delete group with all subgroups and members.\n+     *\n+     * @param sess\n+     * @param group\n+     * @param forceDelete if false, delete only empty group without subgroups. If true, delete group including subgroups and members.\n+     * @throws InternalErrorException\n+     * @throws RelationExistsException      Raise only if forceDelete is false and the group has any subgroup or member.\n+     * @throws GroupAlreadyRemovedException if there are 0 rows affected by deleting from DB\n+     */\n+    protected void deleteAnyGroup(PerunSession sess, Group group, boolean forceDelete)\n+            throws InternalErrorException, RelationExistsException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+        Vo vo = this.getVo(sess, group);\n+\n+        if (getGroupsManagerImpl().getSubGroupsCount(sess, group) > 0) {\n+            if (!forceDelete) {\n+                throw new RelationExistsException(\"Group group=\" + group + \" contains subgroups\");\n+            }\n+\n+            // make sure we delete all subgroups !!\n+            List<Group> subGroups = getAllSubGroups(sess, group);\n+\n+            // Use sorting by group names reverse order (first A:B:c then A:B etc.)\n+            // to make sure we delete from the bottom in a hierarchy\n+            Collections.sort(subGroups, Collections.reverseOrder(\n+                    new Comparator<Group>() {\n+                        @Override\n+                        public int compare(Group groupToCompare, Group groupToCompareWith) {\n+                            return groupToCompare.getName().compareTo(groupToCompareWith.getName());\n+                        }\n+                    }));\n+\n+            for (Group g : subGroups) {\n+                //For auditer\n+                List<Resource> subGroupResources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, g);\n+                for (Resource resource : subGroupResources) {\n+                    try {\n+                        getPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, g, resource);\n+                    } catch (GroupNotDefinedOnResourceException ex) {\n+                        throw new ConsistencyErrorException(ex);\n+                    }\n+                }\n+\n+                //remove subgroups' attributes\n+                try {\n+                    getPerunBl().getAttributesManagerBl().removeAllAttributes(sess, g);\n+                } catch (AttributeValueException ex) {\n+                    throw new ConsistencyErrorException(\"All resources was removed from this group. So all attributes values can be removed.\", ex);\n+                }\n+\n+                // delete all sub-groups reserved logins from KDC\n+                List<Integer> list = getGroupsManagerImpl().getGroupApplicationIds(sess, group);\n+                for (Integer appId : list) {\n+                    // for each application\n+                    for (Pair<String, String> login : getGroupsManagerImpl().getApplicationReservedLogins(appId)) {\n+                        // for all reserved logins - delete them in ext. system (e.g. KDC)\n+                        try {\n+                            // left = namespace / right = login\n+                            getPerunBl().getUsersManagerBl().deletePassword(sess, login.getRight(), login.getLeft());\n+                        } catch (LoginNotExistsException ex) {\n+                            log.error(\"Login: {} not exists in namespace: {} while deleting passwords.\", login.getRight(), login.getLeft());\n+                        } catch (PasswordDeletionFailedException | PasswordOperationTimeoutException ex) {\n+                            throw new InternalErrorException(\"Failed to delete reserved login \" + login.getRight() + \" from KDC.\", ex);\n+                        }\n+                    }\n+                }\n+                // delete all Groups reserved logins from DB\n+                getGroupsManagerImpl().deleteGroupReservedLogins(sess, group);\n+\n+                //Remove all information about group on facilities (facilities contacts)\n+                List<ContactGroup> groupContactGroups = getPerunBl().getFacilitiesManagerBl().getFacilityContactGroups(sess, group);\n+                if (!groupContactGroups.isEmpty()) {\n+                    getPerunBl().getFacilitiesManagerBl().removeAllGroupContacts(sess, group);\n+                }\n+\n+                //remove all assigned ExtSources to this group\n+                List<ExtSource> assignedSources = getPerunBl().getExtSourcesManagerBl().getGroupExtSources(sess, group);\n+                for (ExtSource source : assignedSources) {\n+                    try {\n+                        getPerunBl().getExtSourcesManagerBl().removeExtSource(sess, group, source);\n+                    } catch (ExtSourceNotAssignedException | ExtSourceAlreadyRemovedException ex) {\n+                        //Just log this, because if method can't remove it, it is probably not assigned now\n+                        log.error(\"Try to remove not existing extSource {} from group {} when deleting group.\", source, group);\n+                    }\n+                }\n+\n+                // 1. remove all relations with group g as an operand group.\n+                // this removes all relations that depend on this group\n+                List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, g.getId());\n+                for (Integer groupId : relations) {\n+                    removeGroupUnion(sess, groupsManagerImpl.getGroupById(sess, groupId), g, true);\n+                }\n+\n+                // 2. remove all relations with group as a result group\n+                // We can remove relations without recalculation (@see processRelationMembers)\n+                // because all dependencies of group were deleted in step 1.\n+                groupsManagerImpl.removeResultGroupRelations(sess, g);\n+\n+                // Group applications, submitted data and app_form are deleted on cascade with \"deleteGroup()\"\n+\n+                List<Member> membersFromDeletedGroup = getGroupMembers(sess, g);\n+                // Deletes also all direct and indirect members of the group\n+                getGroupsManagerImpl().deleteGroup(sess, vo, g);\n+\n+                logTotallyRemovedMembers(sess, g.getParentGroupId(), membersFromDeletedGroup);\n+\n+                getPerunBl().getAuditer().log(sess, \"{} deleted.\", g);\n+\n+            }\n+        }\n+        if ((this.getGroupMembersCount(sess, group) > 0) && !forceDelete) {\n+            throw new RelationExistsException(\"Group group=\" + group + \" contains members\");\n+        }\n+\n+        List<Resource> assignedResources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+        try {\n+            for (Resource resource : assignedResources) {\n+                getPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, group, resource);\n+            }\n+            //remove group's attributes\n+            getPerunBl().getAttributesManagerBl().removeAllAttributes(sess, group);\n+        } catch (GroupNotDefinedOnResourceException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        } catch (AttributeValueException ex) {\n+            throw new ConsistencyErrorException(\"All resources was removed from this group, so no attributes should remain assigned.\", ex);\n+        }\n+\n+        // delete all Groups reserved logins from KDC\n+        List<Integer> list = getGroupsManagerImpl().getGroupApplicationIds(sess, group);\n+        for (Integer appId : list) {\n+            // for each application\n+            for (Pair<String, String> login : getGroupsManagerImpl().getApplicationReservedLogins(appId)) {\n+                // for all reserved logins - delete them in ext. system (e.g. KDC)\n+                try {\n+                    // left = namespace / right = login\n+                    getPerunBl().getUsersManagerBl().deletePassword(sess, login.getRight(), login.getLeft());\n+                } catch (LoginNotExistsException ex) {\n+                    log.error(\"Login: {} not exists in namespace: {} while deleting passwords.\", login.getRight(), login.getLeft());\n+                } catch (PasswordDeletionFailedException | PasswordOperationTimeoutException ex) {\n+                    throw new InternalErrorException(\"Failed to delete reserved login \" + login.getRight() + \" from KDC.\", ex);\n+                }\n+            }\n+        }\n+        // delete all Groups reserved logins from DB\n+        getGroupsManagerImpl().deleteGroupReservedLogins(sess, group);\n+\n+        //Remove all information about group on facilities (facilities contacts)\n+        List<ContactGroup> groupContactGroups = getPerunBl().getFacilitiesManagerBl().getFacilityContactGroups(sess, group);\n+        if (!groupContactGroups.isEmpty()) {\n+            if (forceDelete) {\n+                getPerunBl().getFacilitiesManagerBl().removeAllGroupContacts(sess, group);\n+            } else {\n+                throw new RelationExistsException(\"Group has still some facilities contacts: \" + groupContactGroups);\n+            }\n+        }\n+\n+        //remove all assigned ExtSources to this group\n+        List<ExtSource> assignedSources = getPerunBl().getExtSourcesManagerBl().getGroupExtSources(sess, group);\n+        for (ExtSource source : assignedSources) {\n+            try {\n+                getPerunBl().getExtSourcesManagerBl().removeExtSource(sess, group, source);\n+            } catch (ExtSourceNotAssignedException | ExtSourceAlreadyRemovedException ex) {\n+                //Just log this, because if method can't remove it, it is probably not assigned now\n+                log.error(\"Try to remove not existing extSource {} from group {} when deleting group.\", source, group);\n+            }\n+        }\n+\n+        // 1. remove all relations with group g as an operand group.\n+        // this removes all relations that depend on this group\n+        List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n+        for (Integer groupId : relations) {\n+            removeGroupUnion(sess, groupsManagerImpl.getGroupById(sess, groupId), group, true);\n+        }\n+\n+        // 2. remove all relations with group as a result group\n+        // We can remove relations without recalculation (@see processRelationMembers)\n+        // because all dependencies of group were deleted in step 1.\n+        groupsManagerImpl.removeResultGroupRelations(sess, group);\n+\n+        // Group applications, submitted data and app_form are deleted on cascade with \"deleteGroup()\"\n+        List<Member> membersFromDeletedGroup = getGroupMembers(sess, group);\n+        // Deletes also all direct and indirect members of the group\n+        getGroupsManagerImpl().deleteGroup(sess, vo, group);\n+\n+        logTotallyRemovedMembers(sess, group.getParentGroupId(), membersFromDeletedGroup);\n+\n+        getPerunBl().getAuditer().log(sess, \"{} deleted.\", group);\n+    }\n+\n+    /**\n+     * Log members that were deleted from parent group totally to auditer.\n+     *\n+     * @param sess                    perun session\n+     * @param parentGroupId           group id\n+     * @param membersFromDeletedGroup deleted members from child group\n+     * @throws InternalErrorException\n+     */\n+    private void logTotallyRemovedMembers(PerunSession sess, Integer parentGroupId, List<Member> membersFromDeletedGroup) throws InternalErrorException {\n+        while (parentGroupId != null) {\n+            Group parentGroup;\n+            try {\n+                parentGroup = getGroupById(sess, parentGroupId);\n+            } catch (GroupNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+            // getting members from parent group AFTER the indirect members from subgroup were removed from this group.\n+            List<Member> membersFromParentGroup = getGroupMembers(sess, parentGroup);\n+            // removeAll will remove all members which remains in parent group even after they removal of INDIRECT records.\n+            membersFromDeletedGroup.removeAll(membersFromParentGroup);\n+            // now all members which left in membersFromDeletedGroup list are totally removed members from this group,\n+            // so we need to log them to auditer\n+            for (Member m : membersFromDeletedGroup) {\n+                getPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", m, parentGroup);\n+            }\n+            parentGroupId = parentGroup.getParentGroupId();\n+        }\n+    }\n+\n+    public void deleteAllGroups(PerunSession sess, Vo vo) throws InternalErrorException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+        for (Group group : getGroupsManagerImpl().getGroups(sess, vo)) {\n+\n+            if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+                // Do not delete built-in groups, they must be deleted using separate functions deleteMembersGroup\n+                continue;\n+            }\n+            List<Resource> assignedResources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+            try {\n+                for (Resource resource : assignedResources) {\n+                    getPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, group, resource);\n+                    getPerunBl().getAttributesManagerBl().removeAllAttributes(sess, resource, group);\n+                }\n+                //remove group's attributes\n+                getPerunBl().getAttributesManagerBl().removeAllAttributes(sess, group);\n+            } catch (GroupNotDefinedOnResourceException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            } catch (AttributeValueException ex) {\n+                throw new ConsistencyErrorException(\"All resources was removed from this group. So all attributes values can be removed.\", ex);\n+            } catch (WrongAttributeAssignmentException ex) {\n+                throw new InternalErrorException(ex);\n+            }\n+\n+            try {\n+                this.deleteGroup(sess, group, true);\n+            } catch (RelationExistsException | GroupNotExistsException e) {\n+                throw new ConsistencyErrorException(e);\n+            }\n+        }\n+        getPerunBl().getAuditer().log(sess, \"All group in {} deleted.\", vo);\n+    }\n+\n+    public Group updateGroup(PerunSession sess, Group group) throws InternalErrorException {\n+\n+        // return group with correct updated name and shortName\n+        group = getGroupsManagerImpl().updateGroup(sess, group);\n+        getPerunBl().getAuditer().log(sess, \"{} updated.\", group);\n+\n+        List<Group> allSubgroups = this.getAllSubGroups(sess, group);\n+        String[] groupNames = group.getName().split(\":\");\n+\n+        for (Group g : allSubgroups) {\n+            String[] subGroupNames = g.getName().split(\":\");\n+            for (int i = 0; i < groupNames.length; i++) {\n+                if (!subGroupNames[i].equals(groupNames[i])) {\n+                    // this part of name changed\n+                    subGroupNames[i] = groupNames[i];\n+                }\n+            }\n+            // create new name\n+            StringBuilder sb = new StringBuilder();\n+            for (String sgName : subGroupNames) {\n+                sb.append(sgName).append(\":\");\n+            }\n+            // set name without last \":\"\n+            g.setName(sb.toString().substring(0, sb.length() - 1));\n+            // for subgroups we must update whole name\n+            getGroupsManagerImpl().updateGroupName(sess, g);\n+            // create auditer message for every updated group\n+            getPerunBl().getAuditer().log(sess, \"{} updated.\", g);\n+        }\n+\n+        return group;\n+    }\n+\n+    public Group getGroupById(PerunSession sess, int id) throws InternalErrorException, GroupNotExistsException {\n+        return getGroupsManagerImpl().getGroupById(sess, id);\n+    }\n+\n+    public List<Group> getGroupsToSynchronize(PerunSession sess) throws InternalErrorException {\n+        return getGroupsManagerImpl().getGroupsToSynchronize(sess);\n+    }\n+\n+    public Group getGroupByName(PerunSession sess, Vo vo, String name) throws InternalErrorException, GroupNotExistsException {\n+        return getGroupsManagerImpl().getGroupByName(sess, vo, name);\n+    }\n+\n+    public void addMemberToMembersGroup(PerunSession sess, Group group, Member member) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, NotMemberOfParentGroupException, GroupNotExistsException, GroupOperationsException {\n+        // Check if the group IS memebers or administrators group\n+        if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+            this.addDirectMember(sess, group, member);\n+        } else {\n+            throw new InternalErrorException(\"This method must be called only from methods VosManager.addAdmin and MembersManager.createMember.\");\n+        }\n+    }\n+\n+    public void addMember(PerunSession sess, Group group, Member member) throws InternalErrorException, WrongReferenceAttributeValueException, GroupOperationsException, AlreadyMemberException, WrongAttributeValueException, GroupNotExistsException {\n+        // Check if the group is NOT members or administrators group\n+        if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+            throw new InternalErrorException(\"Cannot add member directly to the members group.\");\n+        } else {\n+            this.addDirectMember(sess, group, member);\n+        }\n+    }\n+\n+    private List<Group> getParentGroups(PerunSession sess, Group group) throws InternalErrorException {\n+        if (group == null) {\n+            return new ArrayList<Group>();\n+        }\n+        try {\n+            if (group.getParentGroupId() == null) {\n+                return new ArrayList<Group>();\n+            }\n+            List<Group> groups = getParentGroups(sess, getGroupById(sess, group.getParentGroupId()));\n+            groups.add(getGroupById(sess, group.getParentGroupId()));\n+            return groups;\n+        } catch (GroupNotExistsException ex) {\n+            throw new ConsistencyErrorException(ex);\n+        }\n+    }\n+\n+    /**\n+     * Add a record of the member with a DIRECT membership type to the group.\n+     *\n+     * @param sess   perun session\n+     * @param group  group to add member to\n+     * @param member member to be added as DIRECT\n+     * @throws InternalErrorException\n+     * @throws AlreadyMemberException\n+     * @throws WrongAttributeValueException\n+     * @throws WrongReferenceAttributeValueException\n+     * @throws GroupNotExistsException\n+     * @throws GroupOperationsException\n+     */\n+    protected void addDirectMember(PerunSession sess, Group group, Member member) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, GroupNotExistsException, GroupOperationsException {\n+\n+        if (this.groupsManagerImpl.isDirectGroupMember(sess, group, member)) {\n+            throw new AlreadyMemberException(member);\n+        }\n+\n+        boolean memberWasIndirectInGroup = this.isGroupMember(sess, group, member);\n+\n+        member = getGroupsManagerImpl().addMember(sess, group, member, MembershipType.DIRECT, group.getId());\n+        getPerunBl().getAuditer().log(sess, \"{} added to {}.\", member, group);\n+\n+        //If member was indirect in group before, we don't need to change anything in other groups\n+        if (memberWasIndirectInGroup) {\n+            return;\n+        }\n+        // check all relations with this group and call processRelationMembers to reflect changes of adding member to group\n+        List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n+        for (Integer groupId : relations) {\n+            processRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), Collections.singletonList(member), group.getId(), true);\n+        }\n+\n+        setRequiredAttributes(sess, member, group);\n+    }\n+\n+    /**\n+     * Add records of the members with an INDIRECT membership type to the group.\n+     *\n+     * @param sess          perun session\n+     * @param group         group to add members to\n+     * @param members       list of members to add as INDIRECT\n+     * @param sourceGroupId id of a group from which members originate\n+     * @return list of members that were not members already\n+     * @throws InternalErrorException\n+     * @throws AlreadyMemberException\n+     * @throws WrongAttributeValueException\n+     * @throws WrongReferenceAttributeValueException\n+     */\n+    protected List<Member> addIndirectMembers(PerunSession sess, Group group, List<Member> members, int sourceGroupId) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n+        // save list of old group members\n+        List<Member> oldMembers = this.getGroupMembers(sess, group);\n+\n+        for (Member member : members) {\n+            groupsManagerImpl.addMember(sess, group, member, MembershipType.INDIRECT, sourceGroupId);\n+        }\n+\n+        // get list of new members\n+        List<Member> newMembers = this.getGroupMembers(sess, group);\n+        // select only newly added members\n+        newMembers.removeAll(oldMembers);\n+\n+        for (Member member : newMembers) {\n+            setRequiredAttributes(sess, member, group);\n+            getPerunBl().getAuditer().log(sess, \"{} added to {}.\", member, group);\n+        }\n+\n+        return newMembers;\n+    }\n+\n+    /**\n+     * Set required attributes when adding new direct or indirect members.\n+     *\n+     * @param sess   perun session\n+     * @param member member\n+     * @param group  group\n+     * @throws InternalErrorException\n+     * @throws WrongAttributeValueException\n+     * @throws WrongReferenceAttributeValueException\n+     */\n+    private void setRequiredAttributes(PerunSession sess, Member member, Group group) throws InternalErrorException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n+        // setting required attributes\n+        User user = getPerunBl().getUsersManagerBl().getUserByMember(sess, member);\n+        List<Resource> resources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+        for (Resource resource : resources) {\n+            Facility facility = getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+            // check members attributes\n+            try {\n+                getPerunBl().getAttributesManagerBl().setRequiredAttributes(sess, facility, resource, user, member);\n+            } catch (WrongAttributeAssignmentException | AttributeNotExistsException ex) {\n+                throw new ConsistencyErrorException(ex);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Remove records of the members with an INDIRECT membership type from the group.\n+     *\n+     * @param sess          perun session\n+     * @param group         group to remove records of INDIRECT members from\n+     * @param members       list of members to remove\n+     * @param sourceGroupId id of a group from which members originate\n+     * @return list of members that were removed (their only record in the group was deleted)\n+     * @throws InternalErrorException\n+     * @throws AlreadyMemberException\n+     * @throws WrongAttributeValueException\n+     * @throws WrongReferenceAttributeValueException\n+     * @throws NotGroupMemberException\n+     */\n+    protected List<Member> removeIndirectMembers(PerunSession sess, Group group, List<Member> members, int sourceGroupId) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, NotGroupMemberException {\n+        // save list of old group members\n+        List<Member> oldMembers = this.getGroupMembers(sess, group);\n+\n+        for (Member member : members) {\n+            member.setSourceGroupId(sourceGroupId);\n+            groupsManagerImpl.removeMember(sess, group, member);\n+        }\n+\n+        // get list of new members\n+        List<Member> newMembers = this.getGroupMembers(sess, group);\n+        // get only removed members\n+        oldMembers.removeAll(newMembers);\n+\n+        for (Member removedIndirectMember : oldMembers) {\n+            getPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", removedIndirectMember, group);\n+        }\n+\n+        return oldMembers;\n+    }\n+\n+    public void removeMember(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n+        // Check if the group is NOT members or administrators group\n+        if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+            throw new InternalErrorException(\"Cannot remove member directly from the members group.\");\n+        } else {\n+            this.removeDirectMember(sess, group, member);\n+        }\n+    }\n+\n+    public void removeMemberFromMembersOrAdministratorsGroup(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n+        // Check if the group IS memebers or administrators group\n+        if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+            this.removeDirectMember(sess, group, member);\n+        } else {\n+            throw new InternalErrorException(\"This method must be called only from methods VosManager.removeAdmin and MembersManager.deleteMember.\");\n+        }\n+    }\n+\n+    protected void removeDirectMember(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n+        member.setSourceGroupId(group.getId());\n+        getGroupsManagerImpl().removeMember(sess, group, member);\n+        if (this.getGroupsManagerImpl().isGroupMember(sess, group, member)) {\n+            getPerunBl().getAuditer().log(sess, \"{} was removed from {}.\", member, group);\n+            //If member was indirect in group before, we don't need to change anything in other groups\n+            return;\n+        } else {\n+            getPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", member, group);\n+        }\n+\n+        // check all relations with this group and call processRelationMembers to reflect changes of removing member from group\n+        List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n+        for (Integer groupId : relations) {\n+            processRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), Collections.singletonList(member), group.getId(), false);\n+        }\n+\n+    }\n+\n+    public List<Member> getGroupMembers(PerunSession sess, Group group) throws InternalErrorException {\n+        return this.filterMembersByMembershipTypeInGroup(getGroupsManagerImpl().getGroupMembers(sess, group));\n+    }\n+\n+    public List<Member> getGroupMembers(PerunSession sess, Group group, Status status) throws InternalErrorException {\n+        if (status == null) {\n+            return this.getGroupMembers(sess, group);\n+        }\n+        return this.filterMembersByMembershipTypeInGroup(getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(status), false));\n+    }\n+\n+    @Override\n+    public List<User> getGroupUsers(PerunSession perunSession, Group group) throws InternalErrorException {\n+        return new ArrayList<User>(new HashSet<User>(getGroupsManagerImpl().getGroupUsers(perunSession, group)));\n+    }\n+\n+    public List<Member> getGroupMembersExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n+        return getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(Status.INVALID), true);\n+    }\n+\n+    public List<Member> getGroupMembersExceptInvalidAndDisabled(PerunSession sess, Group group) throws InternalErrorException {\n+        return getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(Status.INVALID, Status.DISABLED), true);\n+    }\n+\n+    public List<RichMember> getGroupRichMembers(PerunSession sess, Group group) throws InternalErrorException {\n+        return this.getGroupRichMembers(sess, group, null);\n+    }\n+\n+    public List<RichMember> getGroupRichMembersExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n+        List<Member> members = this.getGroupMembersExceptInvalid(sess, group);\n+\n+        return getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n+    }\n+\n+    public List<RichMember> getGroupRichMembers(PerunSession sess, Group group, Status status) throws InternalErrorException {\n+        List<Member> members = this.getGroupMembers(sess, group, status);\n+\n+        return getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n+    }\n+\n+    public List<RichMember> getGroupRichMembersWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n+        return this.getGroupRichMembersWithAttributes(sess, group, null);\n+    }\n+\n+    public List<RichMember> getGroupRichMembersWithAttributesExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n+        List<RichMember> richMembers = this.getGroupRichMembersExceptInvalid(sess, group);\n+\n+        return getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n+    }\n+\n+    public List<RichMember> getGroupRichMembersWithAttributes(PerunSession sess, Group group, Status status) throws InternalErrorException {\n+        List<RichMember> richMembers = this.getGroupRichMembers(sess, group, status);\n+\n+        return getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n+    }\n+\n+    public int getGroupMembersCount(PerunSession sess, Group group) throws InternalErrorException {\n+        List<Member> members = this.getGroupMembers(sess, group);\n+        return members.size();\n+    }\n+\n+    public void addAdmin(PerunSession sess, Group group, User user) throws InternalErrorException, AlreadyAdminException {\n+        AuthzResolverBlImpl.setRole(sess, user, group, Role.GROUPADMIN);\n+        getPerunBl().getAuditer().log(sess, \"{} was added as admin of {}.\", user, group);\n+    }\n+\n+    @Override\n+    public void addAdmin(PerunSession sess, Group group, Group authorizedGroup) throws InternalErrorException, AlreadyAdminException {\n+        List<Group> listOfAdmins = getAdminGroups(sess, group);\n+        if (listOfAdmins.contains(authorizedGroup)) {\n+            throw new AlreadyAdminException(authorizedGroup);\n+        }\n+\n+        AuthzResolverBlImpl.setRole(sess, authorizedGroup, group, Role.GROUPADMIN);\n+        getPerunBl().getAuditer().log(sess, \"Group {} was added as admin of {}.\", authorizedGroup, group);\n+    }\n+\n+    public void removeAdmin(PerunSession sess, Group group, User user) throws InternalErrorException, UserNotAdminException {\n+        AuthzResolverBlImpl.unsetRole(sess, user, group, Role.GROUPADMIN);\n+        getPerunBl().getAuditer().log(sess, \"{} was removed from admins of {}.\", user, group);\n+    }\n+\n+    @Override\n+    public void removeAdmin(PerunSession sess, Group group, Group authorizedGroup) throws InternalErrorException, GroupNotAdminException {\n+        List<Group> listOfAdmins = getAdminGroups(sess, group);\n+        if (!listOfAdmins.contains(authorizedGroup)) {\n+            throw new GroupNotAdminException(authorizedGroup);\n+        }\n+\n+        AuthzResolverBlImpl.unsetRole(sess, authorizedGroup, group, Role.GROUPADMIN);\n+        getPerunBl().getAuditer().log(sess, \"Group {} was removed from admins of {}.\", authorizedGroup, group);\n+    }\n+\n+    public List<User> getAdmins(PerunSession perunSession, Group group, boolean onlyDirectAdmins) throws InternalErrorException {\n+        if (onlyDirectAdmins) {\n+            return getGroupsManagerImpl().getDirectAdmins(perunSession, group);\n+        } else {\n+            return getGroupsManagerImpl().getAdmins(perunSession, group);\n+        }\n+    }\n+\n+    public List<RichUser> getRichAdmins(PerunSession perunSession, Group group, List<String> specificAttributes, boolean allUserAttributes, boolean onlyDirectAdmins) throws InternalErrorException, UserNotExistsException {\n+        List<User> users = this.getAdmins(perunSession, group, onlyDirectAdmins);\n+        List<RichUser> richUsers;\n+\n+        if (allUserAttributes) {\n+            richUsers = perunBl.getUsersManagerBl().getRichUsersWithAttributesFromListOfUsers(perunSession, users);\n+        } else {\n+            try {\n+                richUsers = getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n+            } catch (AttributeNotExistsException ex) {\n+                throw new InternalErrorException(\"One of Attribute not exist.\", ex);\n+            }\n+        }\n+\n+        return richUsers;\n+    }\n+\n+    @Deprecated\n+    public List<User> getAdmins(PerunSession sess, Group group) throws InternalErrorException {\n+        return getGroupsManagerImpl().getAdmins(sess, group);\n+    }\n+\n+    @Deprecated\n+    @Override\n+    public List<User> getDirectAdmins(PerunSession sess, Group group) throws InternalErrorException {\n+        return getGroupsManagerImpl().getDirectAdmins(sess, group);\n+    }\n+\n+    @Override\n+    public List<Group> getAdminGroups(PerunSession sess, Group group) throws InternalErrorException {\n+        return getGroupsManagerImpl().getGroupAdmins(sess, group);\n+    }\n+\n+    @Deprecated\n+    public List<RichUser> getRichAdmins(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n+        List<User> users = this.getAdmins(perunSession, group);\n+        List<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users);\n+        return richUsers;\n+    }\n+\n+    @Deprecated\n+    public List<RichUser> getDirectRichAdmins(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n+        List<User> users = this.getDirectAdmins(perunSession, group);\n+        List<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users);\n+        return richUsers;\n+    }\n+\n+    @Deprecated\n+    public List<RichUser> getRichAdminsWithAttributes(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n+        List<User> users = this.getAdmins(perunSession, group);\n+        List<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersWithAttributesFromListOfUsers(perunSession, users);\n+        return richUsers;\n+    }\n+\n+    @Deprecated\n+    public List<RichUser> getRichAdminsWithSpecificAttributes(PerunSession perunSession, Group group, List<String> specificAttributes) throws InternalErrorException, UserNotExistsException {\n+        try {\n+            return getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, this.getRichAdmins(perunSession, group), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n+        } catch (AttributeNotExistsException ex) {\n+            throw new InternalErrorException(\"One of Attribute not exist.\", ex);\n+        }\n+    }\n+\n+    @Deprecated\n+    public List<RichUser> getDirectRichAdminsWithSpecificAttributes(PerunSession perunSession, Group group, List<String> specificAttributes) throws InternalErrorException, UserNotExistsException {\n+        try {\n+            return getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, this.getDirectRichAdmins(perunSession, group), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n+        } catch (AttributeNotExistsException ex) {\n+            throw new InternalErrorException(\"One of Attribute not exist.\", ex);\n+        }\n+    }\n+\n+    public List<Group> getAssignedGroupsToResource(PerunSession sess, Resource resource) throws InternalErrorException {\n+        return getAssignedGroupsToResource(sess, resource, false);\n+    }\n+\n+    public List<Group> getAssignedGroupsToResource(PerunSession sess, Resource resource, boolean withSubGroups) throws InternalErrorException {\n+        List<Group> assignedGroups = getGroupsManagerImpl().getAssignedGroupsToResource(sess, resource);\n+        if (!withSubGroups) {\n+            return assignedGroups;\n+        }\n+\n+        boolean done = assignedGroups.isEmpty();\n+        List<Group> groupsToProcess = new ArrayList<Group>(assignedGroups);\n+        while (!done) {\n+            List<Group> groupsToAdd = new ArrayList<Group>();\n+            for (Group group : groupsToProcess) {\n+                //FIXME Do not get subgroups of the members group\n+                if (!group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+                    groupsToAdd.addAll(this.getSubGroups(sess, group));\n+                }\n+            }\n+            groupsToAdd.removeAll(assignedGroups);\n+            assignedGroups.addAll(groupsToAdd);\n+            groupsToProcess = groupsToAdd;\n+            done = groupsToProcess.isEmpty();\n+        }\n+        return assignedGroups;\n+    }\n+\n+    public List<Group> getAllGroups(PerunSession sess, Vo vo) throws InternalErrorException {\n+        List<Group> groups = getGroupsManagerImpl().getAllGroups(sess, vo);\n+\n+        // Sort\n+        Collections.sort(groups);\n+\n+        return groups;\n+    }\n+\n+    public Map<Group, Object> getAllGroupsWithHierarchy(PerunSession sess, Vo vo) throws InternalErrorException {\n+        Map<Group, Object> groupHierarchy = new TreeMap<Group, Object>();\n+\n+        // Get the top level group = members\n+        try {\n+            groupHierarchy.put(this.getGroupByName(sess, vo, VosManager.MEMBERS_GROUP), null);\n+        } catch (GroupNotExistsException e) {\n+            throw new ConsistencyErrorException(\"Built-in members group must exists.\", e);\n+        }\n+\n+        // Call recursively getGroupsForHierarchy, which finds all subgroups\n+        return getGroupsForHierarchy(sess, groupHierarchy);\n+    }\n+\n+    /**\n+     * @param sess\n+     * @param groups initialized HashMap containing pair <topLevelGropu, null>\n+     * @return HashMap containing all VO groups hierarchically organized\n+     */\n+    private Map<Group, Object> getGroupsForHierarchy(PerunSession sess, Map<Group, Object> groups) throws InternalErrorException {\n+        for (Group group : groups.keySet()) {\n+            List<Group> subGroups = this.getSubGroups(sess, group);\n+\n+            Map<Group, Object> subGroupHierarchy = new TreeMap<Group, Object>();\n+            for (Group subGroup : subGroups) {\n+                subGroupHierarchy.put(subGroup, null);\n+            }\n+\n+            groups.put(group, this.getGroupsForHierarchy(sess, subGroupHierarchy));\n+        }\n+\n+        return groups;\n+    }\n+\n+    public List<Group> getSubGroups(PerunSession sess, Group parentGroup) throws InternalErrorException {\n+        List<Group> subGroups = getGroupsManagerImpl().getSubGroups(sess, parentGroup);\n+\n+        // Sort\n+        Collections.sort(subGroups);\n+\n+        return subGroups;\n+    }\n+\n+    public List<Group> getAllSubGroups(PerunSession sess, Group parentGroup) throws InternalErrorException {\n+        Queue<Group> groupsInQueue = new ConcurrentLinkedQueue<Group>();\n+        groupsInQueue.addAll(getGroupsManagerImpl().getSubGroups(sess, parentGroup));\n+        List<Group> allSubGroups = new ArrayList<Group>();\n+        while (groupsInQueue.peek() != null) {\n+            groupsInQueue.addAll(getGroupsManagerImpl().getSubGroups(sess, groupsInQueue.peek()));\n+            allSubGroups.add(groupsInQueue.poll());\n+        }\n+        return allSubGroups;\n+    }\n+\n+    public Group getParentGroup(PerunSession sess, Group group) throws InternalErrorException, ParentGroupNotExistsException {\n+        if (group.getParentGroupId() == null) {\n+            Vo vo = this.getVo(sess, group);\n+            try {\n+                return this.getGroupByName(sess, vo, VosManager.MEMBERS_GROUP);\n+            } catch (GroupNotExistsException ex) {\n+                throw new ParentGroupNotExistsException(\"Members group not exist for vo\" + vo);\n+            }\n+        } else {\n+            return getGroupsManagerImpl().getParentGroup(sess, group);\n+        }\n+    }\n+\n+    public List<Group> getGroups(PerunSession sess, Vo vo) throws InternalErrorException {\n+        List<Group> groups = getGroupsManagerImpl().getGroups(sess, vo);\n+\n+        Collections.sort(groups);\n+\n+        return groups;\n+    }\n+\n+    public List<Group> getGroupsByIds(PerunSession sess, List<Integer> groupsIds) throws InternalErrorException {\n+        return getGroupsManagerImpl().getGroupsByIds(sess, groupsIds);\n+    }\n+\n+    public int getGroupsCount(PerunSession sess, Vo vo) throws InternalErrorException {\n+        return getGroupsManagerImpl().getGroupsCount(sess, vo);\n+    }\n+\n+    public int getGroupsCount(PerunSession sess) throws InternalErrorException {\n+        return getGroupsManagerImpl().getGroupsCount(sess);\n+    }\n+\n+    public int getSubGroupsCount(PerunSession sess, Group parentGroup) throws InternalErrorException {\n+        return getGroupsManagerImpl().getSubGroupsCount(sess, parentGroup);\n+    }\n+\n+    public Vo getVo(PerunSession sess, Group group) throws InternalErrorException {\n+        int voId = getGroupsManagerImpl().getVoId(sess, group);\n+        try {\n+            return getPerunBl().getVosManagerBl().getVoById(sess, voId);\n+        } catch (VoNotExistsException e) {\n+            throw new ConsistencyErrorException(\"Group belongs to the non-existent VO\", e);\n+        }\n+    }\n+\n+    public List<Group> getMemberGroups(PerunSession sess, Member member) throws InternalErrorException {\n+        List<Group> groups = this.getAllMemberGroups(sess, member);\n+        //Remove members group\n+        if (!groups.isEmpty()) {\n+            Iterator<Group> iterator = groups.iterator();\n+            while (iterator.hasNext()) {\n+                Group g = iterator.next();\n+                if (g.getName().equals(VosManager.MEMBERS_GROUP)) {\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+        // Sort\n+        Collections.sort(groups);\n+        return groups;\n+    }\n+\n+    public List<Group> getMemberDirectGroups(PerunSession sess, Member member) throws InternalErrorException {\n+        List<Group> memberGroups = this.getMemberGroups(sess, member);\n+\n+        Iterator<Group> groupIterator = memberGroups.iterator();\n+        while (groupIterator.hasNext()) {\n+            if (!getGroupsManagerImpl().isDirectGroupMember(sess, groupIterator.next(), member)) {\n+                groupIterator.remove();\n+            }\n+        }\n+\n+        return memberGroups;\n+    }\n+\n+    public List<Group> getMemberGroupsByAttribute(PerunSession sess, Member member, Attribute attribute) throws WrongAttributeAssignmentException, InternalErrorException {\n+        List<Group> memberGroups = this.getAllMemberGroups(sess, member);\n+        memberGroups.retainAll(this.getGroupsByAttribute(sess, attribute));\n+        return memberGroups;\n+    }\n+\n+    public List<Group> getAllMemberGroups(PerunSession sess, Member member) throws InternalErrorException {\n+        return getGroupsManagerImpl().getAllMemberGroups(sess, member);\n+    }\n+\n+    public List<Member> getParentGroupMembers(PerunSession sess, Group group) throws InternalErrorException {\n+        try {\n+            Group parentGroup = getParentGroup(sess, group);\n+            return getGroupMembers(sess, parentGroup);\n+        } catch (ParentGroupNotExistsException ex) {\n+            //group (from param) is top level group. Return VO members instead.\n+            Vo vo = getVo(sess, group);\n+            return getPerunBl().getMembersManagerBl().getMembers(sess, vo);\n+        }\n+    }\n+\n+    public List<RichMember> getParentGroupRichMembers(PerunSession sess, Group group) throws InternalErrorException {\n+        List<Member> members = this.getParentGroupMembers(sess, group);\n+\n+        return getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n+    }\n+\n+    public List<RichMember> getParentGroupRichMembersWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n+        List<RichMember> richMembers = this.getParentGroupRichMembers(sess, group);\n+\n+        return getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n+    }\n+\n+    public boolean isUserMemberOfGroup(PerunSession sess, User user, Group group) throws InternalErrorException {\n+        return groupsManagerImpl.isUserMemberOfGroup(sess, user, group);\n+    }\n+\n+    /**\n+     * Compare richMember userExtSources with Candidate's userExtSources, if some of the useExtSource fits.\n+     *\n+     * @param richMember\n+     * @param candidate\n+     * @return true if richMember.userExtSources contains some of the candidate.useExtSource\n+     */\n+    protected boolean hasCandidateExistingMember(Candidate candidate, RichMember richMember) {\n+        for (UserExtSource ues : richMember.getUserExtSources()) {\n+            if (candidate.getUserExtSources().contains(ues)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method run in separate transaction.\n+     */\n+    public List<String> synchronizeGroup(PerunSession sess, Group group)\n+            throws InternalErrorException, MemberAlreadyRemovedException, AttributeNotExistsException, WrongAttributeAssignmentException, ExtSourceNotExistsException, WrongAttributeValueException, WrongReferenceAttributeValueException, GroupOperationsException, NotMemberOfParentGroupException,\n+            GroupNotExistsException {\n+        //needed variables for whole method\n+        List<String> skippedMembers = new ArrayList<>();\n+        ExtSource source = null;\n+        ExtSource membersSource = null;\n+\n+        try {\n+            log.info(\"Group synchronization {}: started.\", group);\n+\n+            //Initialization of group extSource\n+            source = getGroupExtSourceForSynchronization(sess, group);\n+\n+            //Initialization of groupMembers extSource (if it is set), in other case set membersSource = source\n+            membersSource = getGroupMembersExtSourceForSynchronization(sess, group, source);\n+\n+            //Prepare info about userAttributes which need to be overwrite (not just updated)\n+            List<String> overwriteUserAttributesList = getOverwriteUserAttributesListFromExtSource(membersSource);\n+\n+            //Get info about type of synchronization (with or without update)\n+            boolean lightweightSynchronization = isThisLightweightSynchronization(sess, group);\n+\n+            log.info(\"Group synchronization {}: using configuration extSource for membership {}, extSource for members {}\", new Object[] {group, membersSource, membersSource.getName()});\n+\n+            //Prepare containers for work with group members\n+            List<Candidate> candidatesToAdd = new ArrayList<>();\n+            Map<Candidate, RichMember> membersToUpdate = new HashMap<>();\n+            List<RichMember> membersToRemove = new ArrayList<>();\n+\n+            //get all actual members of group\n+            List<RichMember> actualGroupMembers = getPerunBl().getGroupsManagerBl().getGroupRichMembers(sess, group);\n+\n+            if (lightweightSynchronization) {\n+                categorizeMembersForLightweightSynchronization(sess, group, source, membersSource, actualGroupMembers, candidatesToAdd, membersToRemove, skippedMembers);\n+            } else {\n+                //Get subjects from extSource\n+                List<Map<String, String>> subjects = getSubjectsFromExtSource(sess, source, group);\n+                //Convert subjects to candidates\n+                List<Candidate> candidates = convertSubjectsToCandidates(sess, subjects, membersSource, source, skippedMembers);\n+\n+                categorizeMembersForSynchronization(sess, actualGroupMembers, candidates, candidatesToAdd, membersToUpdate, membersToRemove);\n+            }\n+\n+            //Update members already presented in group\n+            updateExistingMembersWhileSynchronization(sess, group, membersToUpdate, overwriteUserAttributesList);\n+\n+            //Add not presented candidates to group\n+            addMissingMembersWhileSynchronization(sess, group, candidatesToAdd, overwriteUserAttributesList, skippedMembers);\n+\n+            //Remove presented members in group who are not presented in synchronized ExtSource\n+            removeFormerMembersWhileSynchronization(sess, group, membersToRemove);\n+\n+            log.info(\"Group synchronization {}: ended.\", group);\n+        } finally {\n+            closeExtSourcesAfterSynchronization(membersSource, source);\n+        }\n+\n+        return skippedMembers;\n+    }\n+\n+    /**\n+     * Force group synchronization.\n+     * <p>\n+     * Adds the group synchronization process in the groupSynchronizerThreads.\n+     *\n+     * @param group\n+     */\n+    public void forceGroupSynchronization(PerunSession sess, Group group) throws GroupSynchronizationAlreadyRunningException {\n+        // First check if the group is not currently in synchronization process\n+        if (groupSynchronizerThreads.containsKey(group.getId()) && groupSynchronizerThreads.get(group.getId()).getState() != Thread.State.TERMINATED) {\n+            throw new GroupSynchronizationAlreadyRunningException(group);\n+        } else {\n+            // Remove from groupSynchronizerThreads if the thread was terminated\n+            if (groupSynchronizerThreads.containsKey(group.getId())) {\n+                groupSynchronizerThreads.remove(group.getId());\n+            }\n+            // Start and run the new thread\n+            GroupSynchronizerThread thread = new GroupSynchronizerThread(sess, group);\n+            thread.start();\n+            log.info(\"Group synchronization thread started for group {}.\", group);\n+\n+            groupSynchronizerThreads.put(group.getId(), thread);\n+        }\n+    }\n+\n+    /**\n+     * Synchronize all groups which have enabled synchronization. This method is run by the scheduler every 5 minutes.\n+     *\n+     * @throws InternalErrorException\n+     */\n+    public void synchronizeGroups(PerunSession sess) throws InternalErrorException {\n+        Random rand = new Random();\n+\n+        // Firstly remove all terminated threads\n+        List<Integer> threadsToRemove = new ArrayList<Integer>();\n+        for (Integer groupId : groupSynchronizerThreads.keySet()) {\n+            if (groupSynchronizerThreads.get(groupId).getState() == Thread.State.TERMINATED) {\n+                threadsToRemove.add(groupId);\n+            }\n+        }\n+        for (Integer groupId : threadsToRemove) {\n+            groupSynchronizerThreads.remove(groupId);\n+            log.debug(\"Removing terminated group synchronization thread for group id={}\", groupId);\n+        }\n+\n+        // Get the default synchronization interval and synchronization timeout from the configuration file\n+        int intervalMultiplier = Integer.parseInt(BeansUtils.getPropertyFromConfiguration(\"perun.group.synchronization.interval\"));\n+        int timeout = Integer.parseInt(BeansUtils.getPropertyFromConfiguration(\"perun.group.synchronization.timeout\"));\n+\n+        // Get the number of seconds from the epoch, so we can divide it by the synchronization interval value\n+        long minutesFromEpoch = System.currentTimeMillis() / 1000 / 60;\n+\n+        // Get the groups with synchronization enabled\n+        List<Group> groups = groupsManagerImpl.getGroupsToSynchronize(sess);\n+\n+        int numberOfNewSynchronizations = 0;\n+        int numberOfActiveSynchronizations = 0;\n+        int numberOfTerminatedSynchronizations = 0;\n+        for (Group group : groups) {\n+            // Get the synchronization interval\n+            try {\n+                Attribute intervalAttribute = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPSYNCHROINTERVAL_ATTRNAME);\n+                if (intervalAttribute.getValue() != null) {\n+                    intervalMultiplier = Integer.parseInt((String) intervalAttribute.getValue());\n+                } else {\n+                    log.warn(\"Group {} hasn't set synchronization interval, using default {} seconds\", group, intervalMultiplier);\n+                }\n+            } catch (AttributeNotExistsException e) {\n+                throw new ConsistencyErrorException(\"Required attribute \" + GroupsManager.GROUPSYNCHROINTERVAL_ATTRNAME + \" isn't defined in Perun!\", e);\n+            } catch (WrongAttributeAssignmentException e) {\n+                log.error(\"Cannot synchronize group \" + group + \" due to exception:\", e);\n+                continue;\n+            }\n+\n+            // Multiply with 5 to get real minutes\n+            intervalMultiplier = intervalMultiplier * 5;\n+\n+            // If the minutesFromEpoch can be divided by the intervalMultiplier, then synchronize\n+            if ((minutesFromEpoch % intervalMultiplier) == 0) {\n+                // It's time to synchronize\n+                log.info(\"Scheduling synchronization for the group {}. Interval {} minutes.\", group, intervalMultiplier);\n+\n+                // Run each synchronization in separate thread, but do not start new one, if previous hasn't finished yet\n+                if (groupSynchronizerThreads.containsKey(group.getId())) {\n+                    // Check the running time of the thread\n+                    long timeDiff = System.currentTimeMillis() - groupSynchronizerThreads.get(group.getId()).getStartTime();\n+\n+                    // If the time is greater than timeout set in the configuration file (in minutes)\n+                    if (timeDiff / 1000 / 60 > timeout) {\n+                        // Timeout reach, stop the thread\n+                        log.warn(\"Timeout {} minutes of the synchronization thread for the group {} reached.\", timeout, group);\n+                        groupSynchronizerThreads.get(group.getId()).interrupt();\n+                        groupSynchronizerThreads.remove(group.getId());\n+                        numberOfTerminatedSynchronizations++;\n+                    } else {\n+                        numberOfActiveSynchronizations++;\n+                    }\n+                } else {\n+                    // Start and run the new thread\n+                    try {\n+                        // Do not overload externalSource, run each synchronization in 0-30s steps\n+                        Thread.sleep(rand.nextInt(30000));\n+                    } catch (InterruptedException e) {\n+                        // Do nothing\n+                    }\n+                    GroupSynchronizerThread thread = new GroupSynchronizerThread(sess, group);\n+                    thread.start();\n+                    log.info(\"Group synchronization thread started for group {}.\", group);\n+\n+                    groupSynchronizerThreads.put(group.getId(), thread);\n+                    numberOfNewSynchronizations++;\n+                }\n+            }\n+        }\n+\n+        if (groups.size() > 0) {\n+            log.info(\"Synchronizing {} groups, active {}, new {}, terminated {}.\",\n+                    new Object[] {groups.size(), numberOfActiveSynchronizations, numberOfNewSynchronizations, numberOfTerminatedSynchronizations});\n+        }\n+    }\n+\n+    private static class GroupSynchronizerThread extends Thread {\n+\n+        // all synchronization runs under synchronizer identity.\n+        final PerunPrincipal pp = new PerunPrincipal(\"perunSynchronizer\", ExtSourcesManager.EXTSOURCE_NAME_INTERNAL, ExtSourcesManager.EXTSOURCE_INTERNAL);\n+        private PerunBl perunBl;\n+        private PerunSession sess;\n+        private Group group;\n+        private long startTime;\n+\n+        public GroupSynchronizerThread(PerunSession sess, Group group) {\n+            // take only reference to perun\n+            this.perunBl = (PerunBl) sess.getPerun();\n+            this.group = group;\n+            try {\n+                // create own session\n+                this.sess = perunBl.getPerunSession(pp, new PerunClient());\n+            } catch (InternalErrorException ex) {\n+                log.error(\"Unable to create internal session for Synchronizer with credentials {} because of exception {}\", pp, ex);\n+            }\n+        }\n+\n+        public void run() {\n+            //text of exception if was thrown, null in exceptionMessage means \"no exception, it's ok\"\n+            String exceptionMessage = null;\n+            //text with all skipped members and reasons of this skipping\n+            String skippedMembersMessage = null;\n+            //if exception which produce fail of whole synchronization was thrown\n+            boolean failedDueToException = false;\n+\n+            try {\n+                log.debug(\"Synchronization thread for group {} has started.\", group);\n+                // Set the start time, so we can check the timeout of the thread\n+                startTime = System.currentTimeMillis();\n+\n+                //synchronize Group and get information about skipped Members\n+                List<String> skippedMembers = perunBl.getGroupsManagerBl().synchronizeGroup(sess, group);\n+\n+                if (!skippedMembers.isEmpty()) {\n+                    skippedMembersMessage = \"These members from extSource were skipped: { \";\n+\n+                    for (String skippedMember : skippedMembers) {\n+                        if (skippedMember == null) {\n+                            continue;\n+                        }\n+\n+                        skippedMembersMessage += skippedMember + \", \";\n+                    }\n+                    skippedMembersMessage += \" }\";\n+                    exceptionMessage = skippedMembersMessage;\n+                }\n+\n+                log.debug(\"Synchronization thread for group {} has finished in {} ms.\", group, System.currentTimeMillis() - startTime);\n+            } catch (WrongAttributeValueException | WrongReferenceAttributeValueException | InternalErrorException |\n+                    WrongAttributeAssignmentException | MemberAlreadyRemovedException | GroupNotExistsException |\n+                    GroupOperationsException | NotMemberOfParentGroupException | AttributeNotExistsException | ExtSourceNotExistsException e) {\n+                failedDueToException = true;\n+                exceptionMessage = \"Cannot synchronize group \";\n+                log.error(exceptionMessage + group, e);\n+                exceptionMessage += \"due to exception: \" + e.getName() + \" => \" + e.getMessage();\n+            } catch (Exception e) {\n+                //If some other exception has been thrown, log it and throw again\n+                failedDueToException = true;\n+                exceptionMessage = \"Cannot synchronize group \";\n+                log.error(exceptionMessage + group, e);\n+                exceptionMessage += \"due to unexpected exception: \" + e.getClass().getName() + \" => \" + e.getMessage();\n+                throw e;\n+            } finally {\n+                //Save information about group synchronization, this method run in new transaction\n+                try {\n+                    perunBl.getGroupsManagerBl().saveInformationAboutGroupSynchronization(sess, group, failedDueToException, exceptionMessage);\n+                } catch (Exception ex) {\n+                    log.error(\"When synchronization group \" + group + \", exception was thrown.\", ex);\n+                    log.info(\"Info about exception from synchronization: \" + skippedMembersMessage);\n+                }\n+                log.debug(\"GroupSynchronizerThread finished for group: {}\", group);\n+            }\n+        }\n+\n+        public long getStartTime() {\n+            return startTime;\n+        }\n+    }\n+\n+    /**\n+     * Get all groups of member (except members group) where authoritativeGroup attribute is set to 1 (true)\n+     *\n+     * @param sess\n+     * @param member\n+     * @return list of groups with authoritativeAttribute set to 1\n+     * @throws AttributeNotExistsException if authoritativeGroup attribute not exists\n+     * @throws InternalErrorException\n+     */\n+    List<Group> getAllAuthoritativeGroupsOfMember(PerunSession sess, Member member) throws AttributeNotExistsException, InternalErrorException {\n+        //Get all member groups except membersGroup\n+        List<Group> memberGroups = this.getMemberGroups(sess, member);\n+        Iterator<Group> groupsIter = memberGroups.iterator();\n+        //Iterate through all groups and remove those which have not authoritativeGroup attribute set to 1\n+        while (groupsIter.hasNext()) {\n+            Group group = groupsIter.next();\n+            try {\n+                boolean isThisGroupAuthoritative = false;\n+                Attribute authoritativeGroup = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_D_AUTHORITATIVE_GROUP);\n+                if (authoritativeGroup.getValue() != null) {\n+                    Integer attrValue = (Integer) authoritativeGroup.getValue();\n+                    if (attrValue == 1) {\n+                        isThisGroupAuthoritative = true;\n+                    }\n+                }\n+                //If group is not authoritative group, remove it from list of memberAuthoritativeGroups\n+                if (!isThisGroupAuthoritative) {\n+                    groupsIter.remove();\n+                }\n+            } catch (WrongAttributeAssignmentException ex) {\n+                throw new InternalErrorException(ex);\n+            }\n+        }\n+\n+        return memberGroups;\n+    }\n+\n+    /**\n+     * Gets the groupsManagerImpl for this instance.\n+     *\n+     * @return The groupsManagerImpl.\n+     */\n+    public GroupsManagerImplApi getGroupsManagerImpl() {\n+        return this.groupsManagerImpl;\n+    }\n+\n+    /**\n+     * Gets the perunBl.\n+     *\n+     * @return The perunBl.\n+     */\n+    public PerunBl getPerunBl() {\n+        return this.perunBl;\n+    }\n+\n+    public List<Group> getGroupsByAttribute(PerunSession sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException {\n+        getPerunBl().getAttributesManagerBl().checkNamespace(sess, attribute, AttributesManager.NS_GROUP_ATTR);\n+        if (!(getPerunBl().getAttributesManagerBl().isDefAttribute(sess, attribute) || getPerunBl().getAttributesManagerBl().isOptAttribute(sess, attribute))) {\n+            throw new WrongAttributeAssignmentException(\"This method can process only def and opt attributes\");\n+        }\n+        return getGroupsManagerImpl().getGroupsByAttribute(sess, attribute);\n+    }\n+\n+    public List<Pair<Group, Resource>> getGroupResourcePairsByAttribute(PerunSession sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException {\n+        getPerunBl().getAttributesManagerBl().checkNamespace(sess, attribute, AttributesManager.NS_GROUP_RESOURCE_ATTR);\n+        if (!(getPerunBl().getAttributesManagerBl().isDefAttribute(sess, attribute) || getPerunBl().getAttributesManagerBl().isOptAttribute(sess, attribute))) {\n+            throw new WrongAttributeAssignmentException(\"This method can process only def and opt attributes\");\n+        }\n+        return getGroupsManagerImpl().getGroupResourcePairsByAttribute(sess, attribute);\n+    }\n+\n+    public boolean isGroupMember(PerunSession sess, Group group, Member member) throws InternalErrorException {\n+        return getGroupsManagerImpl().isGroupMember(sess, group, member);\n+    }\n+\n+    public void checkGroupExists(PerunSession sess, Group group) throws InternalErrorException, GroupNotExistsException {\n+        getGroupsManagerImpl().checkGroupExists(sess, group);\n+    }\n+\n+    public List<Group> getGroupsByPerunBean(PerunSession sess, PerunBean perunBean) throws InternalErrorException {\n+        List<Group> groups = new ArrayList<Group>();\n+\n+        //All possible useful objects\n+        Vo vo = null;\n+        Facility facility = null;\n+        Group group = null;\n+        Member member = null;\n+        User user = null;\n+        Host host = null;\n+        Resource resource = null;\n+\n+        if (perunBean != null) {\n+            if (perunBean instanceof Vo) {\n+                vo = (Vo) perunBean;\n+            } else if (perunBean instanceof Facility) {\n+                facility = (Facility) perunBean;\n+            } else if (perunBean instanceof Group) {\n+                group = (Group) perunBean;\n+            } else if (perunBean instanceof Member) {\n+                member = (Member) perunBean;\n+            } else if (perunBean instanceof User) {\n+                user = (User) perunBean;\n+            } else if (perunBean instanceof Host) {\n+                host = (Host) perunBean;\n+            } else if (perunBean instanceof Resource) {\n+                resource = (Resource) perunBean;\n+            } else {\n+                throw new InternalErrorException(\"There is unrecognized object in primaryHolder of aidingAttr.\");\n+            }\n+        } else {\n+            throw new InternalErrorException(\"Aiding attribute must have primaryHolder which is not null.\");\n+        }\n+\n+        //Important For Groups not work with Subgroups! Invalid members are executed too.\n+\n+        if (group != null) {\n+            groups.add(group);\n+        } else if (member != null) {\n+            groups.addAll(getPerunBl().getGroupsManagerBl().getAllMemberGroups(sess, member));\n+        } else if (resource != null) {\n+            groups.addAll(getPerunBl().getResourcesManagerBl().getAssignedGroups(sess, resource));\n+        } else if (user != null) {\n+            List<Member> members = getPerunBl().getMembersManagerBl().getMembersByUser(sess, user);\n+            for (Member memberElement : members) {\n+                groups.addAll(getPerunBl().getGroupsManagerBl().getAllMemberGroups(sess, memberElement));\n+            }\n+        } else if (host != null) {\n+            facility = getPerunBl().getFacilitiesManagerBl().getFacilityForHost(sess, host);\n+            List<Resource> resourcesFromFacility = getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n+            for (Resource resourceElement : resourcesFromFacility) {\n+                groups.addAll(getPerunBl().getGroupsManagerBl().getAssignedGroupsToResource(sess, resourceElement));\n+            }\n+        } else if (facility != null) {\n+            List<Resource> resourcesFromFacility = getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n+            for (Resource resourceElement : resourcesFromFacility) {\n+                groups.addAll(getPerunBl().getGroupsManagerBl().getAssignedGroupsToResource(sess, resourceElement));\n+            }\n+        } else if (vo != null) {\n+            groups.addAll(getPerunBl().getGroupsManagerBl().getAllGroups(sess, vo));\n+        }\n+\n+        groups = new ArrayList<Group>(new HashSet<Group>(groups));\n+        return groups;\n+    }\n+\n+    public List<Member> filterMembersByMembershipTypeInGroup(List<Member> members) throws InternalErrorException {\n+        List<Member> filteredMembers = new ArrayList<Member>();\n+        Iterator<Member> membersIterator = members.iterator();\n+\n+        //Add members with direct membership type\n+        while (membersIterator.hasNext()) {\n+            Member m = membersIterator.next();\n+            if (m.getMembershipType().equals(MembershipType.DIRECT)) {\n+                filteredMembers.add(m);\n+                membersIterator.remove();\n+            }\n+        }\n+\n+        //Add not containing members with indirect membership type\n+        for (Member m : members) {\n+            if (!filteredMembers.contains(m)) {\n+                filteredMembers.add(m);\n+            }\n+        }\n+\n+        return filteredMembers;\n+    }\n+\n+    public RichGroup filterOnlyAllowedAttributes(PerunSession sess, RichGroup richGroup) throws InternalErrorException {\n+        if (richGroup == null) {\n+            throw new InternalErrorException(\"RichGroup can't be null.\");\n+        }\n+\n+        //Filtering richGroup attributes\n+        if (richGroup.getAttributes() != null) {\n+            List<Attribute> groupAttributes = richGroup.getAttributes();\n+            List<Attribute> allowedGroupAttributes = new ArrayList<Attribute>();\n+            for (Attribute groupAttr : groupAttributes) {\n+                if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.READ, groupAttr, richGroup, null)) {\n+                    groupAttr.setWritable(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttr, richGroup, null));\n+                    allowedGroupAttributes.add(groupAttr);\n+                }\n+            }\n+\n+            richGroup.setAttributes(allowedGroupAttributes);\n+        }\n+        return richGroup;\n+    }\n+\n+    public List<RichGroup> filterOnlyAllowedAttributes(PerunSession sess, List<RichGroup> richGroups) throws InternalErrorException {\n+        List<RichGroup> filteredRichGroups = new ArrayList<RichGroup>();\n+        if (richGroups == null || richGroups.isEmpty()) {\n+            return filteredRichGroups;\n+        }\n+\n+        for (RichGroup rg : richGroups) {\n+            filteredRichGroups.add(this.filterOnlyAllowedAttributes(sess, rg));\n+        }\n+\n+        return filteredRichGroups;\n+    }\n+\n+    public void setPerunBl(PerunBl perunBl) {\n+        this.perunBl = perunBl;\n+    }\n+\n+    public RichGroup convertGroupToRichGroupWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n+        return new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group));\n+    }\n+\n+    public RichGroup convertGroupToRichGroupWithAttributesByName(PerunSession sess, Group group, List<String> attrNames) throws InternalErrorException {\n+        if (attrNames == null) {\n+            return convertGroupToRichGroupWithAttributes(sess, group);\n+        }\n+        return new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group, attrNames));\n+    }\n+\n+    public List<RichGroup> convertGroupsToRichGroupsWithAttributes(PerunSession sess, List<Group> groups) throws InternalErrorException {\n+        List<RichGroup> richGroups = new ArrayList<>();\n+        for (Group group : groups) {\n+            richGroups.add(new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group)));\n+        }\n+        return richGroups;\n+    }\n+\n+    public List<RichGroup> convertGroupsToRichGroupsWithAttributes(PerunSession sess, List<Group> groups, List<String> attrNames) throws InternalErrorException {\n+        if (attrNames == null) {\n+            return convertGroupsToRichGroupsWithAttributes(sess, groups);\n+        }\n+        List<RichGroup> richGroups = new ArrayList<>();\n+        for (Group group : groups) {\n+            richGroups.add(new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group, attrNames)));\n+        }\n+        return richGroups;\n+    }\n+\n+    public List<RichGroup> getAllRichGroupsWithAttributesByNames(PerunSession sess, Vo vo, List<String> attrNames) throws InternalErrorException {\n+        return convertGroupsToRichGroupsWithAttributes(sess, this.getAllGroups(sess, vo), attrNames);\n+    }\n+\n+    public List<RichGroup> getRichSubGroupsWithAttributesByNames(PerunSession sess, Group parentGroup, List<String> attrNames) throws InternalErrorException {\n+        return convertGroupsToRichGroupsWithAttributes(sess, this.getSubGroups(sess, parentGroup), attrNames);\n+    }\n+\n+    public List<RichGroup> getAllRichSubGroupsWithAttributesByNames(PerunSession sess, Group parentGroup, List<String> attrNames) throws InternalErrorException {\n+        return convertGroupsToRichGroupsWithAttributes(sess, this.getAllSubGroups(sess, parentGroup), attrNames);\n+    }\n+\n+    public RichGroup getRichGroupByIdWithAttributesByNames(PerunSession sess, int groupId, List<String> attrNames) throws InternalErrorException, GroupNotExistsException {\n+        return convertGroupToRichGroupWithAttributesByName(sess, this.getGroupById(sess, groupId), attrNames);\n+    }\n+\n+    public void saveInformationAboutGroupSynchronization(PerunSession sess, Group group, boolean failedDueToException, String exceptionMessage)\n+            throws AttributeNotExistsException, InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, WrongAttributeValueException {\n+        //get current timestamp of this synchronization\n+        Date currentTimestamp = new Date();\n+        String originalExceptionMessage = exceptionMessage;\n+        //If session is null, throw an exception\n+        if (sess == null) {\n+            throw new InternalErrorException(\"Session is null when trying to save information about synchronization. Group: \" + group + \", timestamp: \" + currentTimestamp + \",message: \" + exceptionMessage);\n+        }\n+\n+        //If group is null, throw an exception\n+        if (group == null) {\n+            throw new InternalErrorException(\"Object group is null when trying to save information about synchronization. Timestamp: \" + currentTimestamp + \", message: \" + exceptionMessage);\n+        }\n+\n+        //if exceptionMessage is empty, use \"Empty message\" instead\n+        if (exceptionMessage != null && exceptionMessage.isEmpty()) {\n+            exceptionMessage = \"Empty message.\";\n+            //else trim the message on 1000 characters if not null\n+        } else if (exceptionMessage != null && exceptionMessage.length() > 1000) {\n+            exceptionMessage = exceptionMessage.substring(0, 1000) + \" ... message is too long, other info is in perun log file. If needed, please ask perun administrators.\";\n+        }\n+\n+        //Set correct format of currentTimestamp\n+        String correctTimestampString = BeansUtils.getDateFormatter().format(currentTimestamp);\n+\n+        //Get both attribute definition lastSynchroTimestamp and lastSynchroState\n+        //Get definitions and values, set values\n+        Attribute lastSynchronizationTimestamp = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, AttributesManager.NS_GROUP_ATTR_DEF + \":lastSynchronizationTimestamp\"));\n+        Attribute lastSynchronizationState = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, AttributesManager.NS_GROUP_ATTR_DEF + \":lastSynchronizationState\"));\n+        lastSynchronizationTimestamp.setValue(correctTimestampString);\n+        //if exception is null, set null to value => remove attribute instead of setting in method setAttributes\n+        lastSynchronizationState.setValue(exceptionMessage);\n+\n+        //attributes to set\n+        List<Attribute> attrsToSet = new ArrayList<>();\n+\n+        //null in exceptionMessage means no exception, success\n+        //Set lastSuccessSynchronizationTimestamp if this one is success\n+        if (exceptionMessage == null) {\n+            String attrName = AttributesManager.NS_GROUP_ATTR_DEF + \":lastSuccessSynchronizationTimestamp\";\n+            try {\n+                Attribute lastSuccessSynchronizationTimestamp = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, attrName));\n+                lastSuccessSynchronizationTimestamp.setValue(correctTimestampString);\n+                attrsToSet.add(lastSuccessSynchronizationTimestamp);\n+            } catch (AttributeNotExistsException ex) {\n+                log.error(\"Can't save lastSuccessSynchronizationTimestamp, because there is missing attribute with name {}\", attrName);\n+            }\n+        } else {\n+            //Log to auditer_log that synchronization failed or finished with some errors\n+            if (failedDueToException) {\n+                getPerunBl().getAuditer().log(sess, \"{} synchronization failed because of {}.\", group, originalExceptionMessage);\n+            } else {\n+                getPerunBl().getAuditer().log(sess, \"{} synchronization finished with errors: {}.\", group, originalExceptionMessage);\n+            }\n+        }\n+\n+        //set lastSynchronizationState and lastSynchronizationTimestamp\n+        attrsToSet.add(lastSynchronizationState);\n+        attrsToSet.add(lastSynchronizationTimestamp);\n+        ((PerunBl) sess.getPerun()).getAttributesManagerBl().setAttributes(sess, group, attrsToSet);\n+    }\n+\n+    @Override\n+    public List<Group> getGroupsWithAssignedExtSourceInVo(PerunSession sess, ExtSource source, Vo vo) throws InternalErrorException {\n+        return getGroupsManagerImpl().getGroupsWithAssignedExtSourceInVo(sess, source, vo);\n+    }\n+\n+    //----------- PRIVATE METHODS FOR  GROUP SYNCHRONIZATION -----------\n+\n+    /**\n+     * For lightweight synchronization prepare candidate to add and members to remove.\n+     * <p>\n+     * Get all subjects from loginSource and try to find users in Perun by their login and this ExtSource.\n+     * If found, look if this user is already in synchronized Group. If yes skip him, if not add him to candidateToAdd\n+     * If not found, add him to candidatesToAdd (from source itself or from memberSource if they are different)\n+     * <p>\n+     * Rest of former members need to be add to membersToRemove to remove them from group.\n+     * <p>\n+     * This method fill 2 member structures which get as parameters:\n+     * 1. candidateToAdd - New members of the group\n+     * 2. membersToRemove - Former members who are not in synchronized ExtSource now\n+     *\n+     * @param sess\n+     * @param group\n+     * @param loginSource\n+     * @param memberSource\n+     * @param groupMembers\n+     * @param candidatesToAdd\n+     * @param membersToRemove\n+     * @param skippedMembers\n+     * @throws InternalErrorException\n+     * @throws ExtSourceNotExistsException\n+     */\n+    private void categorizeMembersForLightweightSynchronization(PerunSession sess, Group group, ExtSource loginSource, ExtSource memberSource, List<RichMember> groupMembers, List<Candidate> candidatesToAdd, List<RichMember> membersToRemove, List<String> skippedMembers)\n+            throws InternalErrorException, ExtSourceNotExistsException {\n+        //Get subjects from loginSource\n+        List<Map<String, String>> subjects = getSubjectsFromExtSource(sess, loginSource, group);\n+\n+        //Prepare structure of userIds with richMembers to better work with actual members\n+        Map<Integer, RichMember> idsOfUsersInGroup = new HashMap<>();\n+        for (RichMember richMember : groupMembers) {\n+            idsOfUsersInGroup.put(richMember.getUserId(), richMember);\n+        }\n+\n+        //try to find users by login and loginSource\n+        for (Map<String, String> subjectFromLoginSource : subjects) {\n+            String login = subjectFromLoginSource.get(\"login\");\n+            // Skip subjects, which doesn't have login\n+            if (login == null || login.isEmpty()) {\n+                log.debug(\"Subject {} doesn't contain attribute login, skipping.\", subjectFromLoginSource);\n+                skippedMembers.add(\"MemberEntry:[\" + subjectFromLoginSource + \"] was skipped because login is missing\");\n+                continue;\n+            }\n+\n+            //try to find user from perun by login and member extSource (need to use memberSource because loginSource is not saved by synchronization)\n+            User user = null;\n+            Candidate candidate = null;\n+            try {\n+                UserExtSource userExtSource = getPerunBl().getUsersManagerBl().getUserExtSourceByExtLogin(sess, memberSource, login);\n+                user = getPerunBl().getUsersManagerBl().getUserByUserExtSource(sess, userExtSource);\n+                if (!idsOfUsersInGroup.containsKey(user.getId())) {\n+                    candidate = new Candidate(user, userExtSource);\n+                }\n+            } catch (UserExtSourceNotExistsException | UserNotExistsException ex) {\n+                //If not find, get more information about him from member extSource\n+                List<Map<String, String>> subjectToConvert = Arrays.asList(subjectFromLoginSource);\n+                List<Candidate> converetedCandidatesList = convertSubjectsToCandidates(sess, subjectToConvert, memberSource, loginSource, skippedMembers);\n+                //Empty means not found (skipped)\n+                if (!converetedCandidatesList.isEmpty()) {\n+                    //We add one subject so we take the one converted candidate\n+                    candidate = converetedCandidatesList.get(0);\n+                }\n+            }\n+\n+            //If user is not null now, we found it so we can use it from perun, in other case he is not in perun at all\n+            if (user != null && candidate == null) {\n+                //we can skip this one, because he is already in group, and remove him from the map\n+                idsOfUsersInGroup.remove(user.getId());\n+            } else if (candidate != null) {\n+                candidatesToAdd.add(candidate);\n+            } else {\n+                //Both null means that we can't find subject by login in extSource at all (will be in skipped members)\n+                log.debug(\"Subject with login {} was skipped because can't be found in extSource {}.\", login, memberSource);\n+            }\n+        }\n+\n+        //Rest of them need to be removed\n+        membersToRemove.addAll(idsOfUsersInGroup.values());\n+    }\n+\n+    /**\n+     * This method fill 3 member structures which get as parameters:\n+     * 1. membersToUpdate - Candidates with equivalent Members from Perun for purpose of updating attributes and statuses\n+     * 2. candidateToAdd - New members of the group\n+     * 3. membersToRemove - Former members who are not in synchronized ExtSource now\n+     *\n+     * @param sess\n+     * @param groupMembers    current group members\n+     * @param candidates      to be synchronized from extSource\n+     * @param membersToUpdate 1. container (more above)\n+     * @param candidatesToAdd 2. container (more above)\n+     * @param membersToRemove 3. container (more above)\n+     * @throws InternalErrorException if getting RichMembers without attributes for the group fail\n+     */\n+    private void categorizeMembersForSynchronization(PerunSession sess, List<RichMember> groupMembers, List<Candidate> candidates, List<Candidate> candidatesToAdd, Map<Candidate, RichMember> membersToUpdate, List<RichMember> membersToRemove) throws InternalErrorException {\n+        candidatesToAdd.addAll(candidates);\n+        membersToRemove.addAll(groupMembers);\n+        //mapping structure for more efficient searching\n+        Map<UserExtSource, RichMember> mappingStructure = new HashMap<>();\n+        for (RichMember rm : groupMembers) {\n+            for (UserExtSource ues : rm.getUserExtSources()) {\n+                mappingStructure.put(ues, rm);\n+            }\n+        }\n+\n+        //try to find already existing candidates between members in group\n+        for (Candidate candidate : candidates) {\n+            List<UserExtSource> candidateExtSources = candidate.getUserExtSources();\n+            for (UserExtSource key : candidateExtSources) {\n+                //candidate exists, will be updated\n+                if (mappingStructure.containsKey(key)) {\n+                    membersToUpdate.put(candidate, mappingStructure.get(key));\n+                    candidatesToAdd.remove(candidate);\n+                    membersToRemove.remove(mappingStructure.get(key));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get ExtSource by name from attribute group:groupMembersExtSource.\n+     * Attribute can be null so if is not set, use default source.\n+     *\n+     * @param sess\n+     * @param group         to be synchronized\n+     * @param defaultSource we need to have already default group source (for synchronization)\n+     * @return if exists, return membersExtSource, if not, return default group extSource\n+     * @throws InternalErrorException            if some internal error happens\n+     * @throws WrongAttributeAssignmentException if bad assignment of groupMembersExtSource attribute\n+     * @throws AttributeNotExistsException       if groupMembersExtSource attribute not exists in perun Database\n+     * @throws ExtSourceNotExistsException       if extSource set in Group attribute not exists\n+     */\n+    private ExtSource getGroupMembersExtSourceForSynchronization(PerunSession sess, Group group, ExtSource defaultSource) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, ExtSourceNotExistsException {\n+        //Prepare the groupMembersExtSource if it is set\n+        Attribute membersExtSourceNameAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPMEMBERSEXTSOURCE_ATTRNAME);\n+        ExtSource membersSource = null;\n+        // If the different extSource name for the members was set use it\n+        if (membersExtSourceNameAttr != null && membersExtSourceNameAttr.getValue() != null) {\n+            String membersExtSourceName = (String) membersExtSourceNameAttr.getValue();\n+            membersSource = getPerunBl().getExtSourcesManagerBl().getExtSourceByName(sess, membersExtSourceName);\n+            return membersSource;\n+            //Otherwise use use the group one\n+        } else {\n+            return defaultSource;\n+        }\n+    }\n+\n+    /**\n+     * Get ExtSource by name from attribute group:groupExtSource\n+     *\n+     * @param sess\n+     * @param group to be synchronized\n+     * @return default group extSource for synchronization\n+     * @throws InternalErrorException            if some internal error happens or attribute with extSource name is null\n+     * @throws WrongAttributeAssignmentException if bad assignment of groupExtSource attribute\n+     * @throws AttributeNotExistsException       if groupExtSource attribute not exists in perun Database\n+     * @throws ExtSourceNotExistsException       if extSource set in Group attribute not exists\n+     */\n+    private ExtSource getGroupExtSourceForSynchronization(PerunSession sess, Group group) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, ExtSourceNotExistsException {\n+        //Get extSource name from group attribute\n+        Attribute extSourceNameAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPEXTSOURCE_ATTRNAME);\n+        if (extSourceNameAttr == null || extSourceNameAttr.getValue() == null) {\n+            throw new InternalErrorException(\"ExtSource is not set for group: \" + group);\n+        }\n+        //return extSource by name\n+        return getPerunBl().getExtSourcesManagerBl().getExtSourceByName(sess, ((String) extSourceNameAttr.getValue()));\n+    }\n+\n+    /**\n+     * From membersSource extSource get attribute overwriteUserAttributes and prepare\n+     * list of attributes names to be overwrite for synchronized users.\n+     * <p>\n+     * Attribute has value (if set) in format \"name,name2,name3...\"\n+     * Method parse these names to list of names.\n+     * Return empty array if attribute is not set for extSource or if it is empty.\n+     *\n+     * @param membersSource to get attributes from\n+     * @return list of attribute names to be overwrite\n+     * @throws InternalErrorException if something happens in getting attributes from membersSource\n+     */\n+    private List<String> getOverwriteUserAttributesListFromExtSource(ExtSource membersSource) throws InternalErrorException {\n+        Map<String, String> membersSourceAttributes = getPerunBl().getExtSourcesManagerBl().getAttributes(membersSource);\n+        List<String> overwriteUserAttributesList = new ArrayList<>();\n+        String overwriteUserAttributes = membersSourceAttributes.get(\"overwriteUserAttributes\");\n+        if (overwriteUserAttributes != null && !overwriteUserAttributes.isEmpty()) {\n+            //remove all white spaces and invisible characters\n+            overwriteUserAttributes = overwriteUserAttributes.replaceAll(\"\\\\s\", \"\");\n+            overwriteUserAttributesList = Arrays.asList(overwriteUserAttributes.split(\",\"));\n+        }\n+        return overwriteUserAttributesList;\n+    }\n+\n+    /**\n+     * Return true if attribute group:lightweightSynchronization is set to true.\n+     * False if not.\n+     * <p>\n+     * True means: we don't want to update existing members (attributes, statuses etc.), just\n+     * add new members and remove former members\n+     * False means: we want to do whole synchronization process including updating operations\n+     *\n+     * @param sess\n+     * @param group to be synchronized\n+     * @return true if this is lightweightSynchronization, false if not\n+     * @throws InternalErrorException            if something happens while getting lightweightSynchronization attribute\n+     * @throws WrongAttributeAssignmentException if bad assignment of lightweightSynchronization attribute\n+     * @throws AttributeNotExistsException       if lightweightSynchronization attribute not exists in perun Database\n+     */\n+    private boolean isThisLightweightSynchronization(PerunSession sess, Group group) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+        Attribute lightweightSynchronzationAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPLIGHTWEIGHTSYNCHRONIZATION_ATTRNAME);\n+        boolean lightweightSynchronization = false;\n+        if (lightweightSynchronzationAttr != null && lightweightSynchronzationAttr.getValue() != null) {\n+            lightweightSynchronization = (Boolean) lightweightSynchronzationAttr.getValue();\n+        }\n+        return lightweightSynchronization;\n+    }\n+\n+    /**\n+     * Return List of subjects, where subject is map of attribute names and attribute values.\n+     * Every subject is structure for creating Candidate from ExtSource.\n+     *\n+     * @param sess\n+     * @param source to get subjects from\n+     * @param group  to be synchronized\n+     * @return list of subjects\n+     * @throws InternalErrorException if internal error occurs\n+     */\n+    private List<Map<String, String>> getSubjectsFromExtSource(PerunSession sess, ExtSource source, Group group) throws InternalErrorException {\n+        //Get all group attributes and store tham to map (info like query, time interval etc.)\n+        List<Attribute> groupAttributes = getPerunBl().getAttributesManagerBl().getAttributes(sess, group);\n+        Map<String, String> groupAttributesMap = new HashMap<String, String>();\n+        for (Attribute attr : groupAttributes) {\n+            String value = BeansUtils.attributeValueToString(attr);\n+            String name = attr.getName();\n+            groupAttributesMap.put(name, value);\n+        }\n+        //-- Get Subjects in form of map where left string is name of attribute and right string is value of attribute, every subject is one map\n+        List<Map<String, String>> subjects;\n+        try {\n+            subjects = ((ExtSourceSimpleApi) source).getGroupSubjects(groupAttributesMap);\n+            log.debug(\"Group synchronization {}: external group contains {} members.\", group, subjects.size());\n+        } catch (ExtSourceUnsupportedOperationException e2) {\n+            throw new InternalErrorException(\"ExtSource \" + source.getName() + \" doesn't support getGroupSubjects\", e2);\n+        }\n+        return subjects;\n+    }\n+\n+    /**\n+     * Convert List of subjects to list of Candidates.\n+     * <p>\n+     * To getting Candidate can use 1 of 3 possible options:\n+     * 1] membersSource and source are not equals => we have just login, other attributes neet to get from membersSource\n+     * 2] membersSource==source and membersSource is instance of ExtSourceApi => we already have all attributes in subject\n+     * 3] membersSource==source and membersSource is instance of SimplExtSourceApi => we have just login, need to read other attributes again\n+     * <p>\n+     * If candidate cannot be get for some reason, add this reason to skippedMembers list and skip him.\n+     *\n+     * @param sess\n+     * @param subjects       list of subjects from ExtSource (at least login should be here)\n+     * @param membersSource  optional member ExtSource (if members attributes are from other source then their logins)\n+     * @param source         default group ExtSource\n+     * @param skippedMembers not successfully synchronized members are skipped and information about it should be added here\n+     * @return list of successfully created candidates from subjects\n+     * @throws InternalErrorException      if some internal error occurs\n+     * @throws ExtSourceNotExistsException if membersSource not exists in Perun\n+     */\n+    private List<Candidate> convertSubjectsToCandidates(PerunSession sess, List<Map<String, String>> subjects, ExtSource membersSource, ExtSource source, List<String> skippedMembers) throws InternalErrorException, ExtSourceNotExistsException {\n+        List<Candidate> candidates = new ArrayList<>();\n+        for (Map<String, String> subject : subjects) {\n+            String login = subject.get(\"login\");\n+            // Skip subjects, which doesn't have login\n+            if (login == null || login.isEmpty()) {\n+                log.debug(\"Subject {} doesn't contain attribute login, skipping.\", subject);\n+                skippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because login is missing\");\n+                continue;\n+            }\n+            try {\n+                // One of three possible ways should happen to get Candidate\n+                // 1] sources of login and other attributes are not same\n+                if (!membersSource.equals(source)) {\n+                    //need to read attributes from the new memberSource, we can't use locally data there (there are from other extSource)\n+                    candidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, membersSource, login)));\n+                    // 2] sources are same and we work with source which is instance of ExtSourceApi\n+                } else if (membersSource instanceof ExtSourceApi) {\n+                    // we can use the data from this source without reading them again (all exists in the map of subject attributes)\n+                    candidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, subject, membersSource, login)));\n+                    // 3] sources are same and we work with source which is instace of ExtSourceSimpleApi\n+                } else if (membersSource instanceof ExtSourceSimpleApi) {\n+                    // we can't use the data from this source, we need to read them again (they are not in the map of subject attributes)\n+                    candidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, membersSource, login)));\n+                } else {\n+                    // this could not happen without change in extSource API code\n+                    throw new InternalErrorException(\"ExtSource is other instance than SimpleApi or Api and this is not supported!\");\n+                }\n+            } catch (CandidateNotExistsException e) {\n+                log.warn(\"getGroupSubjects subjects returned login {}, but it cannot be obtained using getCandidate()\", login);\n+                skippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because candidate can't be found by login:'\" + login + \"' in extSource \" + membersSource);\n+                continue;\n+            } catch (ExtSourceUnsupportedOperationException e) {\n+                log.warn(\"ExtSource {} doesn't support getCandidate operation.\", membersSource);\n+                skippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because extSource \" + membersSource + \" not support method getCandidate\");\n+                continue;\n+            } catch (ParserException e) {\n+                log.warn(\"Can't parse value {} from candidate with login {}\", e.getParsedValue(), login);\n+                skippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because of problem with parsing value '\" + e.getParsedValue() + \"'\");\n+                continue;\n+            }\n+        }\n+\n+        return candidates;\n+    }\n+\n+    /**\n+     * Get Map membersToUpdate and update their attributes, extSources, expirations and statuses.\n+     * <p>\n+     * For Member - updateAttributes\n+     * For User - updateAttributes if exists in list of overwriteUserAttributesList,\n+     * in other case just mergeAttributes.\n+     * <p>\n+     * updateAttributes = store new values\n+     * mergeAttributes = for List and Map add new values, do not remove old one,\n+     * for other cases store new values (like String, Integer etc.)\n+     *\n+     * @param sess\n+     * @param group                       to be synchronized\n+     * @param membersToUpdate             list of members for updating in Perun by information from extSource\n+     * @param overwriteUserAttributesList list of user attributes to be updated instead of merged\n+     * @throws InternalErrorException            if some internal error occurs\n+     * @throws AttributeNotExistsException       if some attributes not exists and for this reason can't be updated\n+     * @throws WrongAttributeAssignmentException if some attribute is updated in bad way (bad assignment)\n+     */\n+    private void updateExistingMembersWhileSynchronization(PerunSession sess, Group group, Map<Candidate, RichMember> membersToUpdate, List<String> overwriteUserAttributesList) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+        List<AttributeDefinition> attrDefs = new ArrayList<>();\n+        //Iterate through all subject attributes\n+        for (Candidate candidate : membersToUpdate.keySet()) {\n+            RichMember richMember = membersToUpdate.get(candidate);\n+\n+            //If member not exists in this moment (somebody remove him before start of updating), skip him and log it\n+            try {\n+                getPerunBl().getMembersManagerBl().checkMemberExists(sess, richMember);\n+            } catch (MemberNotExistsException ex) {\n+                //log it and skip this member\n+                log.debug(\"Someone removed member {} from group {} before updating process. Skip him.\", richMember, group);\n+                continue;\n+            }\n+\n+            //load attrDefinitions just once for first candidate\n+            if (attrDefs.isEmpty()) {\n+                for (String attrName : candidate.getAttributes().keySet()) {\n+                    try {\n+                        AttributeDefinition attrDef = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attrName);\n+                        attrDefs.add(attrDef);\n+                    } catch (AttributeNotExistsException ex) {\n+                        log.error(\"Can't synchronize attribute \" + attrName + \" for candidate \" + candidate + \" and for group \" + group);\n+                        //skip this attribute at all\n+                    }\n+                }\n+            }\n+\n+            //get RichMember with attributes\n+            richMember = getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, Arrays.asList(richMember), attrDefs).get(0);\n+            for (String attributeName : candidate.getAttributes().keySet()) {\n+                //update member attribute\n+                if (attributeName.startsWith(AttributesManager.NS_MEMBER_ATTR)) {\n+                    boolean attributeFound = false;\n+                    for (Attribute memberAttribute : richMember.getMemberAttributes()) {\n+                        if (memberAttribute.getName().equals(attributeName)) {\n+                            attributeFound = true;\n+                            Object subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), memberAttribute.getType());\n+                            if (subjectAttributeValue != null && !memberAttribute.getValue().equals(subjectAttributeValue)) {\n+                                log.trace(\"Group synchronization {}: value of the attribute {} for memberId {} changed. Original value {}, new value {}.\",\n+                                        new Object[] {group, memberAttribute, richMember.getId(), memberAttribute.getValue(), subjectAttributeValue});\n+                                memberAttribute.setValue(subjectAttributeValue);\n+                                try {\n+                                    getPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember, memberAttribute);\n+                                } catch (AttributeValueException e) {\n+                                    // There is a problem with attribute value, so set INVALID status for the member\n+                                    getPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n+                                } catch (WrongAttributeAssignmentException e) {\n+                                    throw new ConsistencyErrorException(e);\n+                                }\n+                            }\n+                            //we found it, but there is no change;\n+                            break;\n+                        }\n+                    }\n+                    //member has not set this attribute so set it now if possible\n+                    if (!attributeFound) {\n+                        Attribute newAttribute = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attributeName));\n+                        Object subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), newAttribute.getType());\n+                        newAttribute.setValue(subjectAttributeValue);\n+                        try {\n+                            // Try to set member's attributes\n+                            getPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember, newAttribute);\n+                            log.trace(\"Setting the {} value {}\", newAttribute, candidate.getAttributes().get(attributeName));\n+                        } catch (AttributeValueException e) {\n+                            // There is a problem with attribute value, so set INVALID status for the member\n+                            getPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n+                        }\n+                    }\n+                    //update user attribute\n+                } else if (attributeName.startsWith(AttributesManager.NS_USER_ATTR)) {\n+                    boolean attributeFound = false;\n+                    for (Attribute userAttribute : richMember.getUserAttributes()) {\n+                        if (userAttribute.getName().equals(attributeName)) {\n+                            attributeFound = true;\n+                            Object subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), userAttribute.getType());\n+                            if (!userAttribute.getValue().equals(subjectAttributeValue)) {\n+                                log.trace(\"Group synchronization {}: value of the attribute {} for memberId {} changed. Original value {}, new value {}.\",\n+                                        new Object[] {group, userAttribute, richMember.getId(), userAttribute.getValue(), subjectAttributeValue});\n+                                userAttribute.setValue(subjectAttributeValue);\n+                                try {\n+                                    //Choose set or merge by extSource attribute overwriteUserAttributes (if contains this one)\n+                                    if (overwriteUserAttributesList.contains(userAttribute.getName())) {\n+                                        getPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember.getUser(), userAttribute);\n+                                    } else {\n+                                        getPerunBl().getAttributesManagerBl().mergeAttributeValueInNestedTransaction(sess, richMember.getUser(), userAttribute);\n+                                    }\n+                                } catch (AttributeValueException e) {\n+                                    // There is a problem with attribute value, so set INVALID status for the member\n+                                    getPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n+                                } catch (WrongAttributeAssignmentException e) {\n+                                    throw new ConsistencyErrorException(e);\n+                                }\n+                            }\n+                            //we found it, but there is no change\n+                            break;\n+                        }\n+                    }\n+                    //user has not set this attribute so set it now if\n+                    if (!attributeFound) {\n+                        Attribute newAttribute = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attributeName));\n+                        Object subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), newAttribute.getType());\n+                        newAttribute.setValue(subjectAttributeValue);\n+                        try {\n+                            // Try to set user's attributes\n+                            getPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember.getUser(), newAttribute);\n+                            log.trace(\"Setting the {} value {}\", newAttribute, candidate.getAttributes().get(attributeName));\n+                        } catch (AttributeValueException e) {\n+                            // There is a problem with attribute value, so set INVALID status for the member\n+                            getPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n+                        }\n+                    }\n+                } else {\n+                    //we are not supporting other attributes then member or user so skip it without error, but log it\n+                    log.error(\"Attribute {} can't be set, because it is not member or user attribute.\", attributeName);\n+                }\n+            }\n+\n+            //Synchronize userExtSources (add not existing)\n+            for (UserExtSource ues : candidate.getUserExtSources()) {\n+                if (!getPerunBl().getUsersManagerBl().userExtSourceExists(sess, ues)) {\n+                    try {\n+                        getPerunBl().getUsersManagerBl().addUserExtSource(sess, richMember.getUser(), ues);\n+                    } catch (UserExtSourceExistsException e) {\n+                        throw new ConsistencyErrorException(\"Adding already existing userExtSource \" + ues, e);\n+                    }\n+                }\n+            }\n+\n+            //Set correct member Status\n+            // If the member has expired or disabled status, try to expire/validate him (depending on expiration date)\n+            if (richMember.getStatus().equals(Status.DISABLED) || richMember.getStatus().equals(Status.EXPIRED)) {\n+                Date now = new Date();\n+                Attribute membershipExpiration = getPerunBl().getAttributesManagerBl().getAttribute(sess, richMember, AttributesManager.NS_MEMBER_ATTR_DEF + \":membershipExpiration\");\n+                if (membershipExpiration.getValue() != null) {\n+                    try {\n+                        Date currentMembershipExpirationDate = BeansUtils.getDateFormatterWithoutTime().parse((String) membershipExpiration.getValue());\n+                        if (currentMembershipExpirationDate.before(now)) {\n+                            //disabled members which are after expiration date will be expired\n+                            if (richMember.getStatus().equals(Status.DISABLED)) {\n+                                try {\n+                                    perunBl.getMembersManagerBl().expireMember(sess, richMember);\n+                                    log.info(\"Switching member id {} to EXPIRE state, due to expiration {}.\", richMember.getId(), (String) membershipExpiration.getValue());\n+                                    log.debug(\"Switching member to EXPIRE state, additional info: membership expiration date='{}', system now date='{}'\", currentMembershipExpirationDate, now);\n+                                } catch (MemberNotValidYetException e) {\n+                                    log.error(\"Consistency error while trying to expire member id {}, exception {}\", richMember.getId(), e);\n+                                }\n+                            }\n+                        } else {\n+                            //disabled and expired members which are before expiration date will be validated\n+                            try {\n+                                perunBl.getMembersManagerBl().validateMember(sess, richMember);\n+                                log.info(\"Switching member id {} to VALID state, due to expiration {}.\", richMember.getId(), (String) membershipExpiration.getValue());\n+                                log.debug(\"Switching member to VALID state, additional info: membership expiration date='{}', system now date='{}'\", currentMembershipExpirationDate, now);\n+                            } catch (WrongAttributeValueException e) {\n+                                log.error(\"Error during validating member id {}, exception {}\", richMember.getId(), e);\n+                            } catch (WrongReferenceAttributeValueException e) {\n+                                log.error(\"Error during validating member id {}, exception {}\", richMember.getId(), e);\n+                            }\n+                        }\n+                    } catch (ParseException ex) {\n+                        log.error(\"Group synchronization: memberId {} expiration String cannot be parsed, exception {}.\", richMember.getId(), ex);\n+                    }\n+                }\n+            }\n+\n+            // If the member has INVALID status, try to validate the member\n+            try {\n+                if (richMember.getStatus().equals(Status.INVALID)) {\n+                    getPerunBl().getMembersManagerBl().validateMember(sess, richMember);\n+                }\n+            } catch (WrongAttributeValueException e) {\n+                log.info(\"Member id {} will stay in INVALID state, because there was problem with attributes {}.\", richMember.getId(), e);\n+            } catch (WrongReferenceAttributeValueException e) {\n+                log.info(\"Member id {} will stay in INVALID state, because there was problem with attributes {}.\", richMember.getId(), e);\n+            }\n+\n+            // If the member has still DISABLED status, try to validate the member\n+            try {\n+                if (richMember.getStatus().equals(Status.DISABLED)) {\n+                    getPerunBl().getMembersManagerBl().validateMember(sess, richMember);\n+                }\n+            } catch (WrongAttributeValueException e) {\n+                log.info(\"Switching member id {} into INVALID state from DISABLED, because there was problem with attributes {}.\", richMember.getId(), e);\n+            } catch (WrongReferenceAttributeValueException e) {\n+                log.info(\"Switching member id {} into INVALID state from DISABLED, because there was problem with attributes {}.\", richMember.getId(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get list of new candidates and add them to the Group.\n+     * <p>\n+     * If Candidate can't be added to Group, skip him and add this information to skippedMembers list.\n+     * <p>\n+     * When creating new member from Candidate, if user already exists, merge his attributes,\n+     * if attribute exists in list of overwriteUserAttributesList, update it instead of merging.\n+     *\n+     * @param sess\n+     * @param group                       to be synchronized\n+     * @param candidatesToAdd             list of new members (candidates)\n+     * @param overwriteUserAttributesList list of attributes to be updated for user if found\n+     * @param skippedMembers              list of not successfully synchronized members\n+     * @throws InternalErrorException if some internal error occurs\n+     */\n+    private void addMissingMembersWhileSynchronization(PerunSession sess, Group group, List<Candidate> candidatesToAdd, List<String> overwriteUserAttributesList, List<String> skippedMembers) throws InternalErrorException, GroupOperationsException {\n+        // Now add missing members\n+        for (Candidate candidate : candidatesToAdd) {\n+            Member member = null;\n+            try {\n+                // Check if the member is already in the VO (just not in the group)\n+                member = getPerunBl().getMembersManagerBl().getMemberByUserExtSources(sess, getPerunBl().getGroupsManagerBl().getVo(sess, group), candidate.getUserExtSources());\n+\n+                // member exists - update attributes\n+                Map<Candidate, RichMember> memberMap = new HashMap<>();\n+                memberMap.put(candidate, getPerunBl().getMembersManagerBl().getRichMember(sess, member));\n+                try {\n+                    updateExistingMembersWhileSynchronization(sess, group, memberMap, overwriteUserAttributesList);\n+                } catch (WrongAttributeAssignmentException | AttributeNotExistsException e) {\n+                    // if update fails, skip him\n+                    log.warn(\"Can't update member from candidate {} due to attribute value exception {}.\", candidate, e);\n+                    skippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because there was problem when updating member from candidate: Exception: \" + e.getName() + \" => '\" + e.getMessage() + \"'\");\n+                    continue;\n+                }\n+\n+            } catch (MemberNotExistsException e) {\n+                try {\n+                    // We have new member (candidate), so create him using synchronous createMember (and overwrite chosed user attributes)\n+                    member = getPerunBl().getMembersManagerBl().createMemberSync(sess, getPerunBl().getGroupsManagerBl().getVo(sess, group), candidate, null, overwriteUserAttributesList);\n+                    log.info(\"Group synchronization {}: New member id {} created during synchronization.\", group, member.getId());\n+                } catch (AlreadyMemberException e1) {\n+                    throw new ConsistencyErrorException(\"Trying to add existing member\");\n+                } catch (AttributeValueException e1) {\n+                    log.warn(\"Can't create member from candidate {} due to attribute value exception {}.\", candidate, e1);\n+                    skippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because there was problem when createing member from candidate: Exception: \" + e1.getName() + \" => '\" + e1.getMessage() + \"'\");\n+                    continue;\n+                } catch (ExtendMembershipException ex) {\n+                    log.warn(\"Can't create member from candidate {} due to membership expiration exception {}.\", candidate, ex);\n+                    skippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because membership expiration: Exception: \" + ex.getName() + \" => \" + ex.getMessage() + \"]\");\n+                    continue;\n+                }\n+            }\n+\n+            try {\n+                // Add the member to the group\n+                if (!group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+                    // Do not add members to the generic members group\n+                    try {\n+                        getPerunBl().getGroupsManagerBl().addMember(sess, group, member);\n+                    } catch (NotMemberOfParentGroupException | GroupNotExistsException ex) {\n+                        // Shouldn't happen, because every group has at least Members group as a parent\n+                        // Shouldn't happen, group should always exist\n+                        throw new ConsistencyErrorException(ex);\n+                    }\n+                }\n+                log.info(\"Group synchronization {}: New member id {} added.\", group, member.getId());\n+            } catch (AlreadyMemberException e) {\n+                //This part is ok, it means someone add member before synchronization ends, log it and skip this member\n+                log.debug(\"Member {} was added to group {} before adding process. Skip this member.\", member, group);\n+                continue;\n+            } catch (AttributeValueException e) {\n+                // There is a problem with attribute value, so set INVALID status of the member\n+                getPerunBl().getMembersManagerBl().invalidateMember(sess, member);\n+            }\n+\n+            // Try to validate member\n+            try {\n+                getPerunBl().getMembersManagerBl().validateMember(sess, member);\n+            } catch (AttributeValueException e) {\n+                log.warn(\"Member id {} will be in INVALID status due to wrong attributes {}.\", member.getId(), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Remove former members from group (if they are not listed in ExtSource yet).\n+     * <p>\n+     * If this is membersGroup (of some Vo) try to disableMember, if not possible then delete him.\n+     * If this is regular group (of some Vo) remove him and if this group is also\n+     * his last authoritative group, disable or delete him also in the Vo.\n+     *\n+     * @param sess\n+     * @param group           to be synchronized\n+     * @param membersToRemove list of members to be removed from Group\n+     * @throws InternalErrorException            if some internal error occurs\n+     * @throws WrongAttributeAssignmentException if there is some problem with assignment of attribute\n+     * @throws MemberAlreadyRemovedException     if member is already out of group when we trying to do this by synchronization\n+     */\n+    private void removeFormerMembersWhileSynchronization(PerunSession sess, Group group, List<RichMember> membersToRemove) throws InternalErrorException, WrongAttributeAssignmentException, MemberAlreadyRemovedException, GroupOperationsException, GroupNotExistsException {\n+        //First get information if this group is authoritative group\n+        boolean thisGroupIsAuthoritativeGroup = false;\n+        try {\n+            Attribute authoritativeGroupAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_D_AUTHORITATIVE_GROUP);\n+            if (authoritativeGroupAttr.getValue() != null) {\n+                Integer authoritativeGroupValue = (Integer) authoritativeGroupAttr.getValue();\n+                if (authoritativeGroupValue == 1) {\n+                    thisGroupIsAuthoritativeGroup = true;\n+                }\n+            }\n+        } catch (AttributeNotExistsException ex) {\n+            //Means that this group is not authoritative\n+            log.error(\"Attribute {} doesn't exists.\", A_G_D_AUTHORITATIVE_GROUP);\n+        }\n+\n+        //Second remove members (use authoritative group where is needed)\n+        for (RichMember member : membersToRemove) {\n+            // Member is missing in the external group, so remove him from the perun group\n+            try {\n+                //members group\n+                if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+                    // If the group is members group, the member must be disabled as a member of VO\n+                    try {\n+                        getPerunBl().getMembersManagerBl().disableMember(sess, member);\n+                        log.info(\"Group synchronization {}: Member id {} disabled.\", group, member.getId());\n+                    } catch (MemberNotValidYetException ex) {\n+                        //Member is still invalid in perun. We can delete him.\n+                        getPerunBl().getMembersManagerBl().deleteMember(sess, member);\n+                        log.info(\"Group synchronization {}: Member id {} would have been disabled but he has been deleted instead because he was invalid.\", group, member.getId());\n+                    }\n+                    //not members group\n+                } else {\n+                    //If this group is authoritative group, check if this is last authoritative group of this member\n+                    //If Yes = deleteMember (from Vo), if No = only removeMember\n+                    if (thisGroupIsAuthoritativeGroup) {\n+                        List<Group> memberAuthoritativeGroups = null;\n+                        try {\n+                            memberAuthoritativeGroups = getAllAuthoritativeGroupsOfMember(sess, member);\n+                        } catch (AttributeNotExistsException ex) {\n+                            //This means that no authoritative group can exists without this attribute\n+                            log.error(\"Attribute {} doesn't exists.\", A_G_D_AUTHORITATIVE_GROUP);\n+                        }\n+\n+                        //If list of member authoritativeGroups is not null, attribute exists\n+                        if (memberAuthoritativeGroups != null) {\n+                            memberAuthoritativeGroups.remove(group);\n+                            if (memberAuthoritativeGroups.isEmpty()) {\n+                                //First try to disable member, if is invalid, delete him from Vo\n+                                try {\n+                                    getPerunBl().getMembersManagerBl().disableMember(sess, member);\n+                                    log.info(\"Group synchronization {}: Member id {} disabled because synchronizer wants to remove him from last authoritativeGroup in Vo.\", group, member.getId());\n+                                    getPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n+                                    log.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n+                                } catch (MemberNotValidYetException ex) {\n+                                    //Member is still invalid in perun. We can delete him.\n+                                    getPerunBl().getMembersManagerBl().deleteMember(sess, member);\n+                                    log.info(\"Group synchronization {}: Member id {} would have been disabled but he has been deleted instead because he was invalid and synchronizer wants to remove him from last authoritativeGroup in Vo.\", group, member.getId());\n+                                }\n+                            } else {\n+                                //If there is still some other authoritative group for this member, only remove him from group\n+                                getPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n+                                log.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n+                            }\n+                            //If list of member authoritativeGroups is null, attribute not exists, only remove member from Group\n+                        } else {\n+                            getPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n+                            log.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n+                        }\n+                    } else {\n+                        getPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n+                        log.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n+                    }\n+                }\n+            } catch (NotGroupMemberException e) {\n+                throw new ConsistencyErrorException(\"Trying to remove non-existing user\");\n+            } catch (MemberAlreadyRemovedException ex) {\n+                //Member was probably removed before starting of synchronization removing process, log it and skip this member\n+                log.debug(\"Member {} was removed from group {} before removing process. Skip this member.\", member, group);\n+                continue;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Try to close both extSources (membersSource and group source)\n+     *\n+     * @param membersSource optional membersSource\n+     * @param source        default groupSource\n+     */\n+    private void closeExtSourcesAfterSynchronization(ExtSource membersSource, ExtSource source) {\n+        //Close open extSources (not empty ones) if they support this operation\n+        if (membersSource != null) {\n+            try {\n+                ((ExtSourceSimpleApi) membersSource).close();\n+            } catch (ExtSourceUnsupportedOperationException e) {\n+                // ExtSource doesn't support that functionality, so silently skip it.\n+            } catch (InternalErrorException e) {\n+                log.info(\"Can't close membersSource connection. Cause: {}\", e);\n+            }\n+        }\n+        if (source != null) {\n+            try {\n+                ((ExtSourceSimpleApi) source).close();\n+            } catch (ExtSourceUnsupportedOperationException e) {\n+                // ExtSource doesn't support that functionality, so silently skip it.\n+            } catch (InternalErrorException e) {\n+                log.info(\"Can't close extSource connection. Cause: {}\", e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void processRelationMembers(PerunSession sess, Group resultGroup, List<Member> changedMembers, int sourceGroupId, boolean addition) throws GroupOperationsException {\n+\n+        List<Member> newMembers;\n+\n+        try {\n+            if (addition) {\n+                newMembers = addIndirectMembers(sess, resultGroup, changedMembers, sourceGroupId);\n+            } else {\n+                newMembers = removeIndirectMembers(sess, resultGroup, changedMembers, sourceGroupId);\n+            }\n+\n+            if (newMembers.isEmpty()) {\n+                return;\n+            }\n+\n+            List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, resultGroup.getId());\n+            for (Integer groupId : relations) {\n+                processRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), newMembers, resultGroup.getId(), addition);\n+            }\n+        } catch (WrongReferenceAttributeValueException | WrongAttributeValueException | AlreadyMemberException |\n+                InternalErrorException | NotGroupMemberException | GroupNotExistsException ex) {\n+            throw new GroupOperationsException(ex);\n+        }\n+    }\n+\n+    @Override\n+    public Group createGroupUnion(PerunSession sess, Group resultGroup, Group operandGroup, boolean parentFlag) throws GroupOperationsException, InternalErrorException, GroupRelationAlreadyExists, GroupRelationNotAllowed {\n+\n+        // block inclusion to members group, since it doesn't make sense\n+        // allow inclusion of members group, since we want to delegate privileges on assigning all vo members to some service for group manager.\n+        if (resultGroup.getName().equals(VosManager.MEMBERS_GROUP)) {\n+            throw new GroupRelationNotAllowed(\"Union cannot be created when result group \" + resultGroup + \" is members group.\");\n+        }\n+\n+        // check if both groups are from same VO\n+        if (resultGroup.getVoId() != operandGroup.getVoId()) {\n+            throw new GroupRelationNotAllowed(\"Union cannot be created on groups: \" + resultGroup + \", \" + operandGroup + \". They are not from the same VO.\");\n+        }\n+\n+        // check if result group is the same as operand group\n+        if (resultGroup.getId() == operandGroup.getId()) {\n+            throw new GroupRelationNotAllowed(\"Result group \" + resultGroup + \" cannot be the same as operand group \" + operandGroup);\n+        }\n+\n+        // check if there is already a record of these two groups\n+        if (this.groupsManagerImpl.isRelationBetweenGroups(resultGroup, operandGroup)) {\n+            throw new GroupRelationAlreadyExists(\"There is already a relation defined between result group \" + resultGroup +\n+                    \" and operand group \" + operandGroup + \" or they are in hierarchical structure.\");\n+        }\n+\n+        // check cycle between groups\n+        if (checkGroupsCycle(sess, resultGroup.getId(), operandGroup.getId())) {\n+            throw new GroupRelationNotAllowed(\"Union between result group \" + resultGroup + \" and operand group \" + operandGroup + \" would create group cycle.\");\n+        }\n+\n+        // save group relation\n+        groupsManagerImpl.saveGroupRelation(sess, resultGroup, operandGroup, parentFlag);\n+\n+        // do the operation logic\n+        processRelationMembers(sess, resultGroup, getGroupMembers(sess, operandGroup), operandGroup.getId(), true);\n+\n+        return resultGroup;\n+    }\n+\n+    @Override\n+    public void removeGroupUnion(PerunSession sess, Group resultGroup, Group operandGroup, boolean parentFlag) throws GroupOperationsException, InternalErrorException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+        if (!groupsManagerImpl.isOneWayRelationBetweenGroups(resultGroup, operandGroup)) {\n+            throw new GroupRelationDoesNotExist(\"Union does not exist between result group \" + resultGroup + \" and operand group\" + operandGroup + \".\");\n+        }\n+\n+        if (parentFlag || groupsManagerImpl.isRelationRemovable(sess, resultGroup, operandGroup)) {\n+            processRelationMembers(sess, resultGroup, getGroupMembers(sess, operandGroup), operandGroup.getId(), false);\n+        } else {\n+            throw new GroupRelationCannotBeRemoved(\"Union between result group \" + resultGroup + \" and operand group\" + operandGroup +\n+                    \" cannot be removed, because it's part of the hierarchical structure of the groups.\");\n+        }\n+\n+        groupsManagerImpl.removeGroupUnion(sess, resultGroup, operandGroup);\n+    }\n+\n+    @Override\n+    public List<Group> getGroupUnions(PerunSession session, Group group, boolean reverseDirection) throws InternalErrorException {\n+        if (reverseDirection) {\n+            return groupsManagerImpl.getResultGroups(session, group.getId());\n+        } else {\n+            return groupsManagerImpl.getOperandGroups(session, group.getId());\n+        }\n+    }\n+\n+    /**\n+     * Check if cycle would be created by adding union between these groups.\n+     *\n+     * @param sess           perun session\n+     * @param resultGroupId  result group id\n+     * @param operandGroupId operand group id\n+     * @return true if cycle would be created; false otherwise\n+     * @throws InternalErrorException\n+     */\n+    private boolean checkGroupsCycle(PerunSession sess, int resultGroupId, int operandGroupId) throws InternalErrorException {\n+        List<Integer> groupsIds = groupsManagerImpl.getResultGroupsIds(sess, resultGroupId);\n+\n+        if (groupsIds.contains(operandGroupId)) {\n+            return true;\n+        }\n+\n+        for (Integer id : groupsIds) {\n+            if (checkGroupsCycle(sess, id, operandGroupId)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n }\n",
            "diff_size": 2415
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "2397",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/341/GroupsManagerBlImpl.java\nindex 80d1b77abcd..23c1cccbd50 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/codebuff/341/GroupsManagerBlImpl.java\n@@ -10,18 +10,15 @@ import java.util.List;\n import java.util.Map;\n import java.util.Random;\n import java.util.TreeMap;\n-\n import cz.metacentrum.perun.core.api.*;\n import cz.metacentrum.perun.core.api.exceptions.*;\n import cz.metacentrum.perun.core.implApi.ExtSourceApi;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import cz.metacentrum.perun.core.bl.GroupsManagerBl;\n import cz.metacentrum.perun.core.bl.PerunBl;\n import cz.metacentrum.perun.core.implApi.ExtSourceSimpleApi;\n import cz.metacentrum.perun.core.implApi.GroupsManagerImplApi;\n-\n import java.util.Comparator;\n import java.util.Date;\n import java.util.HashSet;\n@@ -35,2385 +32,2434 @@ import java.util.concurrent.ConcurrentLinkedQueue;\n  * @author Michal Prochazka michalp@ics.muni.cz\n  * @author Slavek Licehammer glory@ics.muni.cz\n  */\n+\n+\n public class GroupsManagerBlImpl implements GroupsManagerBl {\n \n-\tprivate final static Logger log = LoggerFactory.getLogger(GroupsManagerBlImpl.class);\n-\n-\tprivate final GroupsManagerImplApi groupsManagerImpl;\n-\tprivate PerunBl perunBl;\n-\n-\tprivate Map<Integer, GroupSynchronizerThread> groupSynchronizerThreads;\n-\tprivate static final String A_G_D_AUTHORITATIVE_GROUP = AttributesManager.NS_GROUP_ATTR_DEF + \":authoritativeGroup\";\n-\n-\t/**\n-\t * Create new instance of this class.\n-\t *\n-\t */\n-\tpublic GroupsManagerBlImpl(GroupsManagerImplApi groupsManagerImpl) {\n-\t\tthis.groupsManagerImpl = groupsManagerImpl;\n-\t\tthis.groupSynchronizerThreads = new HashMap<Integer, GroupSynchronizerThread>();\n-\t}\n-\n-\tpublic Group createGroup(PerunSession sess, Vo vo, Group group) throws GroupExistsException, InternalErrorException {\n-\t\tgroup = getGroupsManagerImpl().createGroup(sess, vo, group);\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} created in {}.\", group, vo);\n-\t\tgroup.setVoId(vo.getId());\n-\n-\n-\t\t//set creator as group admin unless he already have authz right on the group (he is VO admin)\n-\t\tUser user = sess.getPerunPrincipal().getUser();\n-\t\tif(user != null) {   //user can be null in tests\n-\t\t\tif(!AuthzResolverBlImpl.isAuthorized(sess, Role.VOADMIN, vo)) {\n-\t\t\t\ttry {\n-\t\t\t\t\tAuthzResolverBlImpl.setRole(sess, user, group, Role.GROUPADMIN);\n-\t\t\t\t} catch (AlreadyAdminException e) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(\"Newly created group already have an admin.\", e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn group;\n-\t}\n-\n-\tpublic Group createGroup(PerunSession sess, Group parentGroup, Group group) throws GroupExistsException, InternalErrorException, GroupOperationsException, GroupRelationNotAllowed, GroupRelationAlreadyExists {\n-\t\tVo vo = this.getVo(sess, parentGroup);\n-\n-\t\tgroup = getGroupsManagerImpl().createGroup(sess, vo, parentGroup, group);\n-\t\tparentGroup = createGroupUnion(sess, parentGroup, group, true);\n-\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} created in {} as subgroup of {}\", group, vo, parentGroup);\n-\n-\t\treturn group;\n-\t}\n-\n-\tpublic void deleteGroup(PerunSession sess, Group group, boolean forceDelete) throws InternalErrorException, RelationExistsException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthrow new java.lang.IllegalArgumentException(\"Built-in \" + group.getName() + \" group cannot be deleted separately.\");\n-\t\t}\n-\n-\t\tthis.deleteAnyGroup(sess, group, forceDelete);\n-\t}\n-\n-\tpublic void deleteGroups(PerunSession perunSession, List<Group> groups, boolean forceDelete) throws InternalErrorException, GroupAlreadyRemovedException, RelationExistsException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\t//Use sorting by group names reverse order (first name A:B:c then A:B etc.)\n-\t\tCollections.sort(groups, Collections.reverseOrder(\n-\t\t\t\tnew Comparator<Group>() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic int compare(Group groupToCompare,Group groupToCompareWith) {\n-\t\t\t\t\t\treturn groupToCompare.getName().compareTo(groupToCompareWith.getName());\n-\t\t\t\t\t}\n-\t\t\t\t}));\n-\n-\t\tfor(Group group: groups) {\n-\t\t\tthis.deleteGroup(perunSession, group, forceDelete);\n-\t\t}\n-\t}\n-\n-\tpublic void deleteMembersGroup(PerunSession sess, Vo vo) throws InternalErrorException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tGroup group;\n-\t\ttry {\n-\t\t\tgroup = getGroupByName(sess, vo, VosManager.MEMBERS_GROUP);\n-\t\t} catch (GroupNotExistsException e) {\n-\t\t\tthrow new ConsistencyErrorException(\"Built-in members group must exists.\",e);\n-\t\t}\n-\t\ttry {\n-\t\t\tthis.deleteAnyGroup(sess, group, true);\n-\t\t} catch (RelationExistsException e) {\n-\t\t\tthrow new ConsistencyErrorException(\"Built-in members group cannot have any relation in this stage.\",e);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * If forceDelete is false, delete only group which has no subgroup and no member.\n-\t * If forceDelete is true, delete group with all subgroups and members.\n-\t *\n-\t * @param sess\n-\t * @param group\n-\t * @param forceDelete if false, delete only empty group without subgroups. If true, delete group including subgroups and members.\n-\t * @throws InternalErrorException\n-\t * @throws RelationExistsException Raise only if forceDelete is false and the group has any subgroup or member.\n-\t * @throws GroupAlreadyRemovedException if there are 0 rows affected by deleting from DB\n-\t */\n-\tprotected void deleteAnyGroup(PerunSession sess, Group group, boolean forceDelete) throws InternalErrorException, RelationExistsException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tVo vo = this.getVo(sess, group);\n-\n-\t\tif (getGroupsManagerImpl().getSubGroupsCount(sess, group) > 0) {\n-\t\t\tif (!forceDelete) throw new RelationExistsException(\"Group group=\"+group+\" contains subgroups\");\n-\n-\t\t\t// make sure we delete all subgroups !!\n-\t\t\tList<Group> subGroups = getAllSubGroups(sess, group);\n-\n-\t\t\t// Use sorting by group names reverse order (first A:B:c then A:B etc.)\n-\t\t\t// to make sure we delete from the bottom in a hierarchy\n-\t\t\tCollections.sort(subGroups, Collections.reverseOrder(\n-\t\t\t\t\tnew Comparator<Group>() {\n-\t\t\t\t\t\t@Override\n-\t\t\t\t\t\tpublic int compare(Group groupToCompare,Group groupToCompareWith) {\n-\t\t\t\t\t\t\treturn groupToCompare.getName().compareTo(groupToCompareWith.getName());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}));\n-\n-\t\t\tfor (Group g : subGroups) {\n-\t\t\t\t//For auditer\n-\t\t\t\tList<Resource> subGroupResources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, g);\n-\t\t\t\tfor(Resource resource : subGroupResources) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, g, resource);\n-\t\t\t\t\t} catch(GroupNotDefinedOnResourceException ex) {\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t//remove subgroups' attributes\n-\t\t\t\ttry {\n-\t\t\t\t\tgetPerunBl().getAttributesManagerBl().removeAllAttributes(sess, g);\n-\t\t\t\t} catch(AttributeValueException ex) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(\"All resources was removed from this group. So all attributes values can be removed.\", ex);\n-\t\t\t\t}\n-\n-\t\t\t\t// delete all sub-groups reserved logins from KDC\n-\t\t\t\tList<Integer> list = getGroupsManagerImpl().getGroupApplicationIds(sess, group);\n-\t\t\t\tfor (Integer appId : list) {\n-\t\t\t\t\t// for each application\n-\t\t\t\t\tfor (Pair<String, String> login : getGroupsManagerImpl().getApplicationReservedLogins(appId)) {\n-\t\t\t\t\t\t// for all reserved logins - delete them in ext. system (e.g. KDC)\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// left = namespace / right = login\n-\t\t\t\t\t\t\tgetPerunBl().getUsersManagerBl().deletePassword(sess, login.getRight(), login.getLeft());\n-\t\t\t\t\t\t} catch (LoginNotExistsException ex) {\n-\t\t\t\t\t\t\tlog.error(\"Login: {} not exists in namespace: {} while deleting passwords.\", login.getRight(), login.getLeft());\n-\t\t\t\t\t\t} catch (PasswordDeletionFailedException | PasswordOperationTimeoutException ex) {\n-\t\t\t\t\t\t\tthrow new InternalErrorException(\"Failed to delete reserved login \"+login.getRight()+\" from KDC.\", ex);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t// delete all Groups reserved logins from DB\n-\t\t\t\tgetGroupsManagerImpl().deleteGroupReservedLogins(sess, group);\n-\n-\t\t\t\t//Remove all information about group on facilities (facilities contacts)\n-\t\t\t\tList<ContactGroup> groupContactGroups = getPerunBl().getFacilitiesManagerBl().getFacilityContactGroups(sess, group);\n-\t\t\t\tif(!groupContactGroups.isEmpty()) {\n-\t\t\t\t\tgetPerunBl().getFacilitiesManagerBl().removeAllGroupContacts(sess, group);\n-\t\t\t\t}\n-\n-\t\t\t\t//remove all assigned ExtSources to this group\n-\t\t\t\tList<ExtSource> assignedSources = getPerunBl().getExtSourcesManagerBl().getGroupExtSources(sess, group);\n-\t\t\t\tfor(ExtSource source: assignedSources) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getExtSourcesManagerBl().removeExtSource(sess, group, source);\n-\t\t\t\t\t} catch (ExtSourceNotAssignedException | ExtSourceAlreadyRemovedException ex) {\n-\t\t\t\t\t\t//Just log this, because if method can't remove it, it is probably not assigned now\n-\t\t\t\t\t\tlog.error(\"Try to remove not existing extSource {} from group {} when deleting group.\", source, group);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// 1. remove all relations with group g as an operand group.\n-\t\t\t\t// this removes all relations that depend on this group\n-\t\t\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, g.getId());\n-\t\t\t\tfor (Integer groupId : relations) {\n-\t\t\t\t\tremoveGroupUnion(sess, groupsManagerImpl.getGroupById(sess, groupId), g, true);\n-\t\t\t\t}\n-\n-\t\t\t\t// 2. remove all relations with group as a result group\n-\t\t\t\t// We can remove relations without recalculation (@see processRelationMembers)\n-\t\t\t\t// because all dependencies of group were deleted in step 1.\n-\t\t\t\tgroupsManagerImpl.removeResultGroupRelations(sess, g);\n-\n-\t\t\t\t// Group applications, submitted data and app_form are deleted on cascade with \"deleteGroup()\"\n-\n-\t\t\t\tList<Member> membersFromDeletedGroup = getGroupMembers(sess, g);\n-\t\t\t\t// Deletes also all direct and indirect members of the group\n-\t\t\t\tgetGroupsManagerImpl().deleteGroup(sess, vo, g);\n-\n-\t\t\t\tlogTotallyRemovedMembers(sess, g.getParentGroupId(), membersFromDeletedGroup);\n-\n-\t\t\t\tgetPerunBl().getAuditer().log(sess, \"{} deleted.\", g);\n-\n-\t\t\t}\n-\t\t}\n-\t\tif ((this.getGroupMembersCount(sess, group) > 0) && !forceDelete) {\n-\t\t\tthrow new RelationExistsException(\"Group group=\"+group+\" contains members\");\n-\t\t}\n-\n-\t\tList<Resource> assignedResources  = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\ttry {\n-\t\t\tfor(Resource resource : assignedResources) {\n-\t\t\t\tgetPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, group, resource);\n-\t\t\t}\n-\t\t\t//remove group's attributes\n-\t\t\tgetPerunBl().getAttributesManagerBl().removeAllAttributes(sess, group);\n-\t\t} catch(GroupNotDefinedOnResourceException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t} catch(AttributeValueException ex) {\n-\t\t\tthrow new ConsistencyErrorException(\"All resources was removed from this group, so no attributes should remain assigned.\", ex);\n-\t\t}\n-\n-\t\t// delete all Groups reserved logins from KDC\n-\t\tList<Integer> list = getGroupsManagerImpl().getGroupApplicationIds(sess, group);\n-\t\tfor (Integer appId : list) {\n-\t\t\t// for each application\n-\t\t\tfor (Pair<String, String> login : getGroupsManagerImpl().getApplicationReservedLogins(appId)) {\n-\t\t\t\t// for all reserved logins - delete them in ext. system (e.g. KDC)\n-\t\t\t\ttry {\n-\t\t\t\t\t// left = namespace / right = login\n-\t\t\t\t\tgetPerunBl().getUsersManagerBl().deletePassword(sess, login.getRight(), login.getLeft());\n-\t\t\t\t} catch (LoginNotExistsException ex) {\n-\t\t\t\t\tlog.error(\"Login: {} not exists in namespace: {} while deleting passwords.\", login.getRight(), login.getLeft());\n-\t\t\t\t} catch (PasswordDeletionFailedException | PasswordOperationTimeoutException ex) {\n-\t\t\t\t\tthrow new InternalErrorException(\"Failed to delete reserved login \"+login.getRight()+\" from KDC.\", ex);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t// delete all Groups reserved logins from DB\n-\t\tgetGroupsManagerImpl().deleteGroupReservedLogins(sess, group);\n-\n-\t\t//Remove all information about group on facilities (facilities contacts)\n-\t\tList<ContactGroup> groupContactGroups = getPerunBl().getFacilitiesManagerBl().getFacilityContactGroups(sess, group);\n-\t\tif(!groupContactGroups.isEmpty()) {\n-\t\t\tif(forceDelete) {\n-\t\t\t\tgetPerunBl().getFacilitiesManagerBl().removeAllGroupContacts(sess, group);\n-\t\t\t} else {\n-\t\t\t\tthrow new RelationExistsException(\"Group has still some facilities contacts: \" + groupContactGroups);\n-\t\t\t}\n-\t\t}\n-\n-\t\t//remove all assigned ExtSources to this group\n-\t\tList<ExtSource> assignedSources = getPerunBl().getExtSourcesManagerBl().getGroupExtSources(sess, group);\n-\t\tfor(ExtSource source: assignedSources) {\n-\t\t\ttry {\n-\t\t\t\tgetPerunBl().getExtSourcesManagerBl().removeExtSource(sess, group, source);\n-\t\t\t} catch (ExtSourceNotAssignedException | ExtSourceAlreadyRemovedException ex) {\n-\t\t\t\t//Just log this, because if method can't remove it, it is probably not assigned now\n-\t\t\t\tlog.error(\"Try to remove not existing extSource {} from group {} when deleting group.\", source, group);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// 1. remove all relations with group g as an operand group.\n-\t\t// this removes all relations that depend on this group\n-\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n-\t\tfor (Integer groupId : relations) {\n-\t\t\tremoveGroupUnion(sess, groupsManagerImpl.getGroupById(sess, groupId), group, true);\n-\t\t}\n-\n-\t\t// 2. remove all relations with group as a result group\n-\t\t// We can remove relations without recalculation (@see processRelationMembers)\n-\t\t// because all dependencies of group were deleted in step 1.\n-\t\tgroupsManagerImpl.removeResultGroupRelations(sess, group);\n-\n-\t\t// Group applications, submitted data and app_form are deleted on cascade with \"deleteGroup()\"\n-\t\tList<Member> membersFromDeletedGroup = getGroupMembers(sess, group);\n-\t\t// Deletes also all direct and indirect members of the group\n-\t\tgetGroupsManagerImpl().deleteGroup(sess, vo, group);\n-\n-\t\tlogTotallyRemovedMembers(sess, group.getParentGroupId(), membersFromDeletedGroup);\n-\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} deleted.\", group);\n-\t}\n-\n-\t/**\n-\t * Log members that were deleted from parent group totally to auditer.\n-\t *\n-\t * @param sess perun session\n-\t * @param parentGroupId group id\n-\t * @param membersFromDeletedGroup deleted members from child group\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate void logTotallyRemovedMembers(PerunSession sess, Integer parentGroupId, List<Member> membersFromDeletedGroup) throws InternalErrorException {\n-\t\twhile(parentGroupId != null) {\n-\t\t\tGroup parentGroup;\n-\t\t\ttry {\n-\t\t\t\tparentGroup = getGroupById(sess, parentGroupId);\n-\t\t\t} catch (GroupNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t\t// getting members from parent group AFTER the indirect members from subgroup were removed from this group.\n-\t\t\tList<Member> membersFromParentGroup = getGroupMembers(sess, parentGroup);\n-\t\t\t// removeAll will remove all members which remains in parent group even after they removal of INDIRECT records.\n-\t\t\tmembersFromDeletedGroup.removeAll(membersFromParentGroup);\n-\t\t\t// now all members which left in membersFromDeletedGroup list are totally removed members from this group,\n-\t\t\t// so we need to log them to auditer\n-\t\t\tfor(Member m: membersFromDeletedGroup) {\n-\t\t\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", m, parentGroup);\n-\t\t\t}\n-\t\t\tparentGroupId=parentGroup.getParentGroupId();\n-\t\t}\n-\t}\n-\n-\tpublic void deleteAllGroups(PerunSession sess, Vo vo) throws InternalErrorException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tfor(Group group: getGroupsManagerImpl().getGroups(sess, vo)) {\n-\n-\t\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\t\t// Do not delete built-in groups, they must be deleted using separate functions deleteMembersGroup\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tList<Resource> assignedResources  = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\t\ttry {\n-\t\t\t\tfor(Resource resource : assignedResources) {\n-\t\t\t\t\tgetPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, group, resource);\n-\t\t\t\t\tgetPerunBl().getAttributesManagerBl().removeAllAttributes(sess, resource, group);\n-\t\t\t\t}\n-\t\t\t\t//remove group's attributes\n-\t\t\t\tgetPerunBl().getAttributesManagerBl().removeAllAttributes(sess, group);\n-\t\t\t} catch(GroupNotDefinedOnResourceException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t} catch(AttributeValueException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(\"All resources was removed from this group. So all attributes values can be removed.\", ex);\n-\t\t\t} catch (WrongAttributeAssignmentException ex) {\n-\t\t\t\tthrow new InternalErrorException(ex);\n-\t\t\t}\n-\n-\t\t\ttry {\n-\t\t\t\tthis.deleteGroup(sess, group, true);\n-\t\t\t} catch (RelationExistsException | GroupNotExistsException e) {\n-\t\t\t\tthrow new ConsistencyErrorException(e);\n-\t\t\t}\n-\t\t}\n-\t\tgetPerunBl().getAuditer().log(sess, \"All group in {} deleted.\", vo);\n-\t}\n-\n-\tpublic Group updateGroup(PerunSession sess, Group group) throws InternalErrorException {\n-\n-\t\t// return group with correct updated name and shortName\n-\t\tgroup = getGroupsManagerImpl().updateGroup(sess, group);\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} updated.\", group);\n-\n-\t\tList<Group> allSubgroups = this.getAllSubGroups(sess, group);\n-\t\tString[] groupNames = group.getName().split(\":\");\n-\n-\t\tfor(Group g: allSubgroups) {\n-\t\t\tString[] subGroupNames = g.getName().split(\":\");\n-\t\t\tfor (int i=0; i<groupNames.length; i++) {\n-\t\t\t\tif (!subGroupNames[i].equals(groupNames[i])) {\n-\t\t\t\t\t// this part of name changed\n-\t\t\t\t\tsubGroupNames[i] = groupNames[i];\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// create new name\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tfor (String sgName : subGroupNames) {\n-\t\t\t\tsb.append(sgName).append(\":\");\n-\t\t\t}\n-\t\t\t// set name without last \":\"\n-\t\t\tg.setName(sb.toString().substring(0, sb.length()-1));\n-\t\t\t// for subgroups we must update whole name\n-\t\t\tgetGroupsManagerImpl().updateGroupName(sess, g);\n-\t\t\t// create auditer message for every updated group\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} updated.\", g);\n-\t\t}\n-\n-\t\treturn group;\n-\t}\n-\n-\tpublic Group getGroupById(PerunSession sess, int id) throws InternalErrorException, GroupNotExistsException {\n-\t\treturn getGroupsManagerImpl().getGroupById(sess, id);\n-\t}\n-\n-\tpublic List<Group> getGroupsToSynchronize(PerunSession sess) throws InternalErrorException{\n-\t\treturn getGroupsManagerImpl().getGroupsToSynchronize(sess);\n-\t}\n-\n-\tpublic Group getGroupByName(PerunSession sess, Vo vo, String name) throws InternalErrorException, GroupNotExistsException {\n-\t\treturn getGroupsManagerImpl().getGroupByName(sess, vo, name);\n-\t}\n-\n-\tpublic void addMemberToMembersGroup(PerunSession sess, Group group,  Member member) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, NotMemberOfParentGroupException, GroupNotExistsException, GroupOperationsException {\n-\t\t// Check if the group IS memebers or administrators group\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthis.addDirectMember(sess, group, member);\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"This method must be called only from methods VosManager.addAdmin and MembersManager.createMember.\");\n-\t\t}\n-\t}\n-\n-\tpublic void addMember(PerunSession sess, Group group, Member member) throws InternalErrorException, WrongReferenceAttributeValueException, GroupOperationsException, AlreadyMemberException, WrongAttributeValueException, GroupNotExistsException {\n-\t\t// Check if the group is NOT members or administrators group\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthrow new InternalErrorException(\"Cannot add member directly to the members group.\");\n-\t\t} else {\n-\t\t\tthis.addDirectMember(sess, group, member);\n-\t\t}\n-\t}\n-\n-\tprivate List<Group> getParentGroups(PerunSession sess, Group group)throws InternalErrorException {\n-\t\tif(group == null) return new ArrayList<Group>();\n-\t\ttry {\n-\t\t\tif (group.getParentGroupId() == null) return new ArrayList<Group>();\n-\t\t\tList<Group> groups = getParentGroups(sess,getGroupById(sess,group.getParentGroupId()));\n-\t\t\tgroups.add(getGroupById(sess, group.getParentGroupId()));\n-\t\t\treturn groups;\n-\t\t} catch(GroupNotExistsException ex) {\n-\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add a record of the member with a DIRECT membership type to the group.\n-\t *\n-\t * @param sess perun session\n-\t * @param group group to add member to\n-\t * @param member member to be added as DIRECT\n-\t * @throws InternalErrorException\n-\t * @throws AlreadyMemberException\n-\t * @throws WrongAttributeValueException\n-\t * @throws WrongReferenceAttributeValueException\n-\t * @throws GroupNotExistsException\n-\t * @throws GroupOperationsException\n-\t */\n-\tprotected void addDirectMember(PerunSession sess, Group group, Member member) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, GroupNotExistsException, GroupOperationsException {\n-\n-\t\tif(this.groupsManagerImpl.isDirectGroupMember(sess, group, member)) throw new AlreadyMemberException(member);\n-\n-\t\tboolean memberWasIndirectInGroup = this.isGroupMember(sess, group, member);\n-\n-\t\tmember = getGroupsManagerImpl().addMember(sess, group, member, MembershipType.DIRECT, group.getId());\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} added to {}.\", member, group);\n-\n-\t\t//If member was indirect in group before, we don't need to change anything in other groups\n-\t\tif(memberWasIndirectInGroup) return;\n-\t\t// check all relations with this group and call processRelationMembers to reflect changes of adding member to group\n-\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n-\t\tfor (Integer groupId : relations) {\n-\t\t\tprocessRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), Collections.singletonList(member), group.getId(), true);\n-\t\t}\n-\n-\t\tsetRequiredAttributes(sess, member, group);\n-\t}\n-\n-\t/**\n-\t * Add records of the members with an INDIRECT membership type to the group.\n-\t *\n-\t * @param sess perun session\n-\t * @param group group to add members to\n-\t * @param members list of members to add as INDIRECT\n-\t * @param sourceGroupId id of a group from which members originate\n-\t * @return list of members that were not members already\n-\t * @throws InternalErrorException\n-\t * @throws AlreadyMemberException\n-\t * @throws WrongAttributeValueException\n-\t * @throws WrongReferenceAttributeValueException\n-\t */\n-\tprotected List<Member> addIndirectMembers(PerunSession sess, Group group, List<Member> members, int sourceGroupId) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n-\t\t// save list of old group members\n-\t\tList<Member> oldMembers = this.getGroupMembers(sess, group);\n-\n-\t\tfor (Member member : members) {\n-\t\t\tgroupsManagerImpl.addMember(sess, group, member, MembershipType.INDIRECT, sourceGroupId);\n-\t\t}\n-\n-\t\t// get list of new members\n-\t\tList<Member> newMembers = this.getGroupMembers(sess, group);\n-\t\t// select only newly added members\n-\t\tnewMembers.removeAll(oldMembers);\n-\n-\t\tfor (Member member : newMembers) {\n-\t\t\tsetRequiredAttributes(sess, member, group);\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} added to {}.\", member, group);\n-\t\t}\n-\n-\t\treturn newMembers;\n-\t}\n-\n-\t/**\n-\t * Set required attributes when adding new direct or indirect members.\n-\t * @param sess perun session\n-\t * @param member member\n-\t * @param group group\n-\t * @throws InternalErrorException\n-\t * @throws WrongAttributeValueException\n-\t * @throws WrongReferenceAttributeValueException\n-\t */\n-\tprivate void setRequiredAttributes(PerunSession sess, Member member, Group group) throws InternalErrorException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n-\t\t// setting required attributes\n-\t\tUser user = getPerunBl().getUsersManagerBl().getUserByMember(sess, member);\n-\t\tList<Resource> resources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n-\t\tfor (Resource resource : resources) {\n-\t\t\tFacility facility = getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n-\t\t\t// check members attributes\n-\t\t\ttry {\n-\t\t\t\tgetPerunBl().getAttributesManagerBl().setRequiredAttributes(sess, facility, resource, user, member);\n-\t\t\t} catch(WrongAttributeAssignmentException | AttributeNotExistsException ex) {\n-\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Remove records of the members with an INDIRECT membership type from the group.\n-\t *\n-\t * @param sess perun session\n-\t * @param group group to remove records of INDIRECT members from\n-\t * @param members list of members to remove\n-\t * @param sourceGroupId id of a group from which members originate\n-\t * @return list of members that were removed (their only record in the group was deleted)\n-\t * @throws InternalErrorException\n-\t * @throws AlreadyMemberException\n-\t * @throws WrongAttributeValueException\n-\t * @throws WrongReferenceAttributeValueException\n-\t * @throws NotGroupMemberException\n-\t */\n-\tprotected List<Member> removeIndirectMembers(PerunSession sess, Group group, List<Member> members, int sourceGroupId) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, NotGroupMemberException {\n-\t\t// save list of old group members\n-\t\tList<Member> oldMembers = this.getGroupMembers(sess, group);\n-\n-\t\tfor (Member member: members) {\n-\t\t\tmember.setSourceGroupId(sourceGroupId);\n-\t\t\tgroupsManagerImpl.removeMember(sess, group, member);\n-\t\t}\n-\n-\t\t// get list of new members\n-\t\tList<Member> newMembers = this.getGroupMembers(sess, group);\n-\t\t// get only removed members\n-\t\toldMembers.removeAll(newMembers);\n-\n-\t\tfor(Member removedIndirectMember: oldMembers) {\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", removedIndirectMember, group);\n-\t\t}\n-\n-\t\treturn oldMembers;\n-\t}\n-\n-\tpublic void removeMember(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n-\t\t// Check if the group is NOT members or administrators group\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthrow new InternalErrorException(\"Cannot remove member directly from the members group.\");\n-\t\t} else {\n-\t\t\tthis.removeDirectMember(sess, group, member);\n-\t\t}\n-\t}\n-\n-\tpublic void removeMemberFromMembersOrAdministratorsGroup(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n-\t\t// Check if the group IS memebers or administrators group\n-\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthis.removeDirectMember(sess, group, member);\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"This method must be called only from methods VosManager.removeAdmin and MembersManager.deleteMember.\");\n-\t\t}\n-\t}\n-\n-\tprotected void removeDirectMember(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n-\t\tmember.setSourceGroupId(group.getId());\n-\t\tgetGroupsManagerImpl().removeMember(sess, group, member);\n-\t\tif (this.getGroupsManagerImpl().isGroupMember(sess, group, member)) {\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from {}.\", member, group);\n-\t\t\t//If member was indirect in group before, we don't need to change anything in other groups\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", member, group);\n-\t\t}\n-\n-\t\t// check all relations with this group and call processRelationMembers to reflect changes of removing member from group\n-\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n-\t\tfor (Integer groupId : relations) {\n-\t\t\tprocessRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), Collections.singletonList(member), group.getId(), false);\n-\t\t}\n-\n-\t}\n-\n-\tpublic List<Member> getGroupMembers(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn this.filterMembersByMembershipTypeInGroup(getGroupsManagerImpl().getGroupMembers(sess, group));\n-\t}\n-\n-\tpublic List<Member> getGroupMembers(PerunSession sess, Group group, Status status) throws InternalErrorException {\n-\t\tif (status == null) {\n-\t\t\treturn this.getGroupMembers(sess, group);\n-\t\t}\n-\t\treturn this.filterMembersByMembershipTypeInGroup(getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(status), false));\n-\t}\n-\n-\t@Override\n-\tpublic List<User> getGroupUsers(PerunSession perunSession, Group group) throws InternalErrorException {\n-\t\treturn new ArrayList<User>(new HashSet<User>(getGroupsManagerImpl().getGroupUsers(perunSession, group)));\n-\t}\n-\n-\tpublic List<Member> getGroupMembersExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(Status.INVALID), true);\n-\t}\n-\n-\tpublic List<Member> getGroupMembersExceptInvalidAndDisabled(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(Status.INVALID, Status.DISABLED), true);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembers(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn this.getGroupRichMembers(sess, group, null);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembersExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<Member> members = this.getGroupMembersExceptInvalid(sess, group);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembers(PerunSession sess, Group group, Status status) throws InternalErrorException {\n-\t\tList<Member> members = this.getGroupMembers(sess, group, status);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembersWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn this.getGroupRichMembersWithAttributes(sess, group, null);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembersWithAttributesExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<RichMember> richMembers = this.getGroupRichMembersExceptInvalid(sess, group);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n-\t}\n-\n-\tpublic List<RichMember> getGroupRichMembersWithAttributes(PerunSession sess, Group group, Status status) throws InternalErrorException {\n-\t\tList<RichMember> richMembers = this.getGroupRichMembers(sess, group, status);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n-\t}\n-\n-\tpublic int getGroupMembersCount(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<Member> members = this.getGroupMembers(sess, group);\n-\t\treturn members.size();\n-\t}\n-\n-\tpublic void addAdmin(PerunSession sess, Group group, User user) throws InternalErrorException, AlreadyAdminException {\n-\t\tAuthzResolverBlImpl.setRole(sess, user, group, Role.GROUPADMIN);\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} was added as admin of {}.\", user, group);\n-\t}\n-\n-\t@Override\n-\tpublic void addAdmin(PerunSession sess, Group group, Group authorizedGroup) throws InternalErrorException, AlreadyAdminException {\n-\t\tList<Group> listOfAdmins = getAdminGroups(sess, group);\n-\t\tif (listOfAdmins.contains(authorizedGroup)) throw new AlreadyAdminException(authorizedGroup);\n-\n-\t\tAuthzResolverBlImpl.setRole(sess, authorizedGroup, group, Role.GROUPADMIN);\n-\t\tgetPerunBl().getAuditer().log(sess, \"Group {} was added as admin of {}.\", authorizedGroup, group);\n-\t}\n-\n-\tpublic void removeAdmin(PerunSession sess, Group group, User user) throws InternalErrorException, UserNotAdminException {\n-\t\tAuthzResolverBlImpl.unsetRole(sess, user, group, Role.GROUPADMIN);\n-\t\tgetPerunBl().getAuditer().log(sess, \"{} was removed from admins of {}.\", user, group);\n-\t}\n-\n-\t@Override\n-\tpublic void removeAdmin(PerunSession sess, Group group, Group authorizedGroup) throws InternalErrorException, GroupNotAdminException {\n-\t\tList<Group> listOfAdmins = getAdminGroups(sess, group);\n-\t\tif (!listOfAdmins.contains(authorizedGroup)) throw new GroupNotAdminException(authorizedGroup);\n-\n-\t\tAuthzResolverBlImpl.unsetRole(sess, authorizedGroup, group, Role.GROUPADMIN);\n-\t\tgetPerunBl().getAuditer().log(sess, \"Group {} was removed from admins of {}.\", authorizedGroup, group);\n-\t}\n-\n-\tpublic List<User> getAdmins(PerunSession perunSession, Group group, boolean onlyDirectAdmins) throws InternalErrorException {\n-\t\tif(onlyDirectAdmins) {\n-\t\t\treturn getGroupsManagerImpl().getDirectAdmins(perunSession, group);\n-\t\t} else {\n-\t\t\treturn getGroupsManagerImpl().getAdmins(perunSession, group);\n-\t\t}\n-\t}\n-\n-\tpublic List<RichUser> getRichAdmins(PerunSession perunSession, Group group, List<String> specificAttributes, boolean allUserAttributes, boolean onlyDirectAdmins) throws InternalErrorException, UserNotExistsException {\n-\t\tList<User> users = this.getAdmins(perunSession, group, onlyDirectAdmins);\n-\t\tList<RichUser> richUsers;\n-\n-\t\tif(allUserAttributes) {\n-\t\t\trichUsers = perunBl.getUsersManagerBl().getRichUsersWithAttributesFromListOfUsers(perunSession, users);\n-\t\t} else {\n-\t\t\ttry {\n-\t\t\t\trichUsers = getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tthrow new InternalErrorException(\"One of Attribute not exist.\", ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn richUsers;\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<User> getAdmins(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getAdmins(sess, group);\n-\t}\n-\n-\t@Deprecated\n-\t@Override\n-\tpublic List<User> getDirectAdmins(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getDirectAdmins(sess, group);\n-\t}\n-\n-\t@Override\n-\tpublic List<Group> getAdminGroups(PerunSession sess, Group group) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupAdmins(sess, group);\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getRichAdmins(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n-\t\tList<User> users = this.getAdmins(perunSession, group);\n-\t\tList<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users);\n-\t\treturn richUsers;\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getDirectRichAdmins(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n-\t\tList<User> users = this.getDirectAdmins(perunSession, group);\n-\t\tList<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users);\n-\t\treturn richUsers;\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getRichAdminsWithAttributes(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n-\t\tList<User> users = this.getAdmins(perunSession, group);\n-\t\tList<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersWithAttributesFromListOfUsers(perunSession, users);\n-\t\treturn richUsers;\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getRichAdminsWithSpecificAttributes(PerunSession perunSession, Group group, List<String> specificAttributes) throws InternalErrorException, UserNotExistsException {\n-\t\ttry {\n-\t\t\treturn getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, this.getRichAdmins(perunSession, group), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new InternalErrorException(\"One of Attribute not exist.\", ex);\n-\t\t}\n-\t}\n-\n-\t@Deprecated\n-\tpublic List<RichUser> getDirectRichAdminsWithSpecificAttributes(PerunSession perunSession, Group group, List<String> specificAttributes) throws InternalErrorException, UserNotExistsException {\n-\t\ttry {\n-\t\t\treturn getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, this.getDirectRichAdmins(perunSession, group), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\tthrow new InternalErrorException(\"One of Attribute not exist.\", ex);\n-\t\t}\n-\t}\n-\n-\tpublic List<Group> getAssignedGroupsToResource(PerunSession sess, Resource resource) throws InternalErrorException {\n-\t\treturn getAssignedGroupsToResource(sess, resource, false);\n-\t}\n-\n-\tpublic List<Group> getAssignedGroupsToResource(PerunSession sess, Resource resource, boolean withSubGroups) throws InternalErrorException {\n-\t\tList<Group> assignedGroups = getGroupsManagerImpl().getAssignedGroupsToResource(sess, resource);\n-\t\tif(!withSubGroups) return assignedGroups;\n-\n-\t\tboolean done = assignedGroups.isEmpty();\n-\t\tList<Group> groupsToProcess = new ArrayList<Group>(assignedGroups);\n-\t\twhile(!done) {\n-\t\t\tList<Group> groupsToAdd = new ArrayList<Group>();\n-\t\t\tfor(Group group : groupsToProcess) {\n-\t\t\t\t//FIXME Do not get subgroups of the members group\n-\t\t\t\tif (!group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\t\t\tgroupsToAdd.addAll(this.getSubGroups(sess, group));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tgroupsToAdd.removeAll(assignedGroups);\n-\t\t\tassignedGroups.addAll(groupsToAdd);\n-\t\t\tgroupsToProcess = groupsToAdd;\n-\t\t\tdone = groupsToProcess.isEmpty();\n-\t\t}\n-\t\treturn assignedGroups;\n-\t}\n-\n-\tpublic List<Group> getAllGroups(PerunSession sess, Vo vo) throws InternalErrorException {\n-\t\tList<Group> groups = getGroupsManagerImpl().getAllGroups(sess, vo);\n-\n-\t\t// Sort\n-\t\tCollections.sort(groups);\n-\n-\t\treturn groups;\n-\t}\n-\n-\tpublic Map<Group, Object> getAllGroupsWithHierarchy(PerunSession sess, Vo vo) throws InternalErrorException {\n-\t\tMap<Group,Object> groupHierarchy = new TreeMap<Group, Object>();\n-\n-\t\t// Get the top level group = members\n-\t\ttry {\n-\t\t\tgroupHierarchy.put(this.getGroupByName(sess, vo, VosManager.MEMBERS_GROUP), null);\n-\t\t} catch (GroupNotExistsException e) {\n-\t\t\tthrow new ConsistencyErrorException(\"Built-in members group must exists.\",e);\n-\t\t}\n-\n-\t\t// Call recursively getGroupsForHierarchy, which finds all subgroups\n-\t\treturn getGroupsForHierarchy(sess, groupHierarchy);\n-\t}\n-\n-\t/**\n-\t *\n-\t * @param sess\n-\t * @param groups initialized HashMap containing pair <topLevelGropu, null>\n-\t * @return HashMap containing all VO groups hierarchically organized\n-\t */\n-\tprivate Map<Group, Object> getGroupsForHierarchy(PerunSession sess, Map<Group, Object> groups) throws InternalErrorException {\n-\t\tfor (Group group: groups.keySet()) {\n-\t\t\tList<Group> subGroups = this.getSubGroups(sess, group);\n-\n-\t\t\tMap<Group,Object> subGroupHierarchy = new TreeMap<Group, Object>();\n-\t\t\tfor (Group subGroup: subGroups) {\n-\t\t\t\tsubGroupHierarchy.put(subGroup, null);\n-\t\t\t}\n-\n-\t\t\tgroups.put(group, this.getGroupsForHierarchy(sess, subGroupHierarchy));\n-\t\t}\n-\n-\t\treturn groups;\n-\t}\n-\n-\tpublic List<Group> getSubGroups(PerunSession sess, Group parentGroup) throws InternalErrorException {\n-\t\tList<Group> subGroups = getGroupsManagerImpl().getSubGroups(sess, parentGroup);\n-\n-\t\t// Sort\n-\t\tCollections.sort(subGroups);\n-\n-\t\treturn subGroups;\n-\t}\n-\n-\tpublic List<Group> getAllSubGroups(PerunSession sess, Group parentGroup) throws InternalErrorException {\n-\t\tQueue<Group> groupsInQueue = new ConcurrentLinkedQueue<Group>();\n-\t\tgroupsInQueue.addAll(getGroupsManagerImpl().getSubGroups(sess, parentGroup));\n-\t\tList<Group> allSubGroups = new ArrayList<Group>();\n-\t\twhile(groupsInQueue.peek() != null) {\n-\t\t\tgroupsInQueue.addAll(getGroupsManagerImpl().getSubGroups(sess, groupsInQueue.peek()));\n-\t\t\tallSubGroups.add(groupsInQueue.poll());\n-\t\t}\n-\t\treturn allSubGroups;\n-\t}\n-\n-\tpublic Group getParentGroup(PerunSession sess, Group group) throws InternalErrorException, ParentGroupNotExistsException {\n-\t\tif(group.getParentGroupId() == null) {\n-\t\t\tVo vo = this.getVo(sess, group);\n-\t\t\ttry {\n-\t\t\t\treturn this.getGroupByName(sess, vo, VosManager.MEMBERS_GROUP);\n-\t\t\t} catch (GroupNotExistsException ex) {\n-\t\t\t\tthrow new ParentGroupNotExistsException(\"Members group not exist for vo\" + vo);\n-\t\t\t}\n-\t\t} else {\n-\t\t\treturn getGroupsManagerImpl().getParentGroup(sess, group);\n-\t\t}\n-\t}\n-\n-\tpublic List<Group> getGroups(PerunSession sess, Vo vo) throws InternalErrorException {\n-\t\tList<Group> groups = getGroupsManagerImpl().getGroups(sess, vo);\n-\n-\t\tCollections.sort(groups);\n-\n-\t\treturn groups;\n-\t}\n-\n-\tpublic List<Group> getGroupsByIds(PerunSession sess, List<Integer> groupsIds) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupsByIds(sess, groupsIds);\n-\t}\n-\n-\tpublic int getGroupsCount(PerunSession sess, Vo vo) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupsCount(sess, vo);\n-\t}\n-\n-\tpublic int getGroupsCount(PerunSession sess) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupsCount(sess);\n-\t}\n-\n-\tpublic int getSubGroupsCount(PerunSession sess, Group parentGroup) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getSubGroupsCount(sess, parentGroup);\n-\t}\n-\n-\tpublic Vo getVo(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tint voId = getGroupsManagerImpl().getVoId(sess, group);\n-\t\ttry {\n-\t\t\treturn getPerunBl().getVosManagerBl().getVoById(sess, voId);\n-\t\t} catch (VoNotExistsException e) {\n-\t\t\tthrow new ConsistencyErrorException(\"Group belongs to the non-existent VO\", e);\n-\t\t}\n-\t}\n-\n-\tpublic List<Group> getMemberGroups(PerunSession sess, Member member) throws InternalErrorException {\n-\t\tList<Group> groups = this.getAllMemberGroups(sess, member);\n-\t\t//Remove members group\n-\t\tif(!groups.isEmpty()) {\n-\t\t\tIterator<Group> iterator = groups.iterator();\n-\t\t\twhile(iterator.hasNext()) {\n-\t\t\t\tGroup g = iterator.next();\n-\t\t\t\tif(g.getName().equals(VosManager.MEMBERS_GROUP)) iterator.remove();\n-\t\t\t}\n-\t\t}\n-\t\t// Sort\n-\t\tCollections.sort(groups);\n-\t\treturn groups;\n-\t}\n-\n-\tpublic List<Group> getMemberDirectGroups(PerunSession sess, Member member) throws InternalErrorException {\n-\t\tList<Group> memberGroups = this.getMemberGroups(sess, member);\n-\n-\t\tIterator<Group> groupIterator = memberGroups.iterator();\n-\t\twhile(groupIterator.hasNext()) {\n-\t\t\tif(!getGroupsManagerImpl().isDirectGroupMember(sess, groupIterator.next(), member)) {\n-\t\t\t\tgroupIterator.remove();\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn memberGroups;\n-\t}\n-\n-\tpublic List<Group> getMemberGroupsByAttribute(PerunSession sess, Member member, Attribute attribute) throws WrongAttributeAssignmentException,InternalErrorException {\n-\t\tList<Group> memberGroups = this.getAllMemberGroups(sess, member);\n-\t\tmemberGroups.retainAll(this.getGroupsByAttribute(sess, attribute));\n-\t\treturn memberGroups;\n-\t}\n-\n-\tpublic List<Group> getAllMemberGroups(PerunSession sess, Member member) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getAllMemberGroups(sess, member);\n-\t}\n-\n-\tpublic List<Member> getParentGroupMembers(PerunSession sess, Group group) throws InternalErrorException {\n-\t\ttry {\n-\t\t\tGroup parentGroup = getParentGroup(sess, group);\n-\t\t\treturn getGroupMembers(sess, parentGroup);\n-\t\t} catch(ParentGroupNotExistsException ex) {\n-\t\t\t//group (from param) is top level group. Return VO members instead.\n-\t\t\tVo vo = getVo(sess, group);\n-\t\t\treturn getPerunBl().getMembersManagerBl().getMembers(sess, vo);\n-\t\t}\n-\t}\n-\n-\tpublic List<RichMember> getParentGroupRichMembers(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<Member> members = this.getParentGroupMembers(sess, group);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n-\t}\n-\n-\tpublic List<RichMember> getParentGroupRichMembersWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n-\t\tList<RichMember> richMembers = this.getParentGroupRichMembers(sess, group);\n-\n-\t\treturn getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n-\t}\n-\n-\tpublic boolean isUserMemberOfGroup(PerunSession sess, User user, Group group) throws InternalErrorException {\n-\t\treturn groupsManagerImpl.isUserMemberOfGroup(sess, user, group);\n-\t}\n-\n-\t/**\n-\t * Compare richMember userExtSources with Candidate's userExtSources, if some of the useExtSource fits.\n-\t *\n-\t * @param richMember\n-\t * @param candidate\n-\t * @return true if richMember.userExtSources contains some of the candidate.useExtSource\n-\t */\n-\tprotected boolean hasCandidateExistingMember(Candidate candidate, RichMember richMember) {\n-\t\tfor (UserExtSource ues: richMember.getUserExtSources()) {\n-\t\t\tif (candidate.getUserExtSources().contains(ues)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * This method run in separate transaction.\n-\t */\n-\tpublic List<String> synchronizeGroup(PerunSession sess, Group group) throws InternalErrorException, MemberAlreadyRemovedException, AttributeNotExistsException, WrongAttributeAssignmentException, ExtSourceNotExistsException, WrongAttributeValueException, WrongReferenceAttributeValueException, GroupOperationsException, NotMemberOfParentGroupException, GroupNotExistsException {\n-\t\t//needed variables for whole method\n-\t\tList<String> skippedMembers = new ArrayList<>();\n-\t\tExtSource source = null;\n-\t\tExtSource membersSource = null;\n-\n-\t\ttry {\n-\t\t\tlog.info(\"Group synchronization {}: started.\", group);\n-\n-\t\t\t//Initialization of group extSource\n-\t\t\tsource = getGroupExtSourceForSynchronization(sess, group);\n-\n-\t\t\t//Initialization of groupMembers extSource (if it is set), in other case set membersSource = source\n-\t\t\tmembersSource = getGroupMembersExtSourceForSynchronization(sess, group, source);\n-\n-\t\t\t//Prepare info about userAttributes which need to be overwrite (not just updated)\n-\t\t\tList<String> overwriteUserAttributesList = getOverwriteUserAttributesListFromExtSource(membersSource);\n-\n-\t\t\t//Get info about type of synchronization (with or without update)\n-\t\t\tboolean lightweightSynchronization = isThisLightweightSynchronization(sess, group);\n-\n-\t\t\tlog.info(\"Group synchronization {}: using configuration extSource for membership {}, extSource for members {}\", new Object[] {group, membersSource, membersSource.getName()});\n-\n-\t\t\t//Prepare containers for work with group members\n-\t\t\tList<Candidate> candidatesToAdd = new ArrayList<>();\n-\t\t\tMap<Candidate, RichMember> membersToUpdate = new HashMap<>();\n-\t\t\tList<RichMember> membersToRemove = new ArrayList<>();\n-\n-\t\t\t//get all actual members of group\n-\t\t\tList<RichMember> actualGroupMembers = getPerunBl().getGroupsManagerBl().getGroupRichMembers(sess, group);\n-\n-\t\t\tif(lightweightSynchronization) {\n-\t\t\t\tcategorizeMembersForLightweightSynchronization(sess, group, source, membersSource, actualGroupMembers, candidatesToAdd, membersToRemove, skippedMembers);\n-\t\t\t} else {\n-\t\t\t\t//Get subjects from extSource\n-\t\t\t\tList<Map<String, String>> subjects = getSubjectsFromExtSource(sess, source, group);\n-\t\t\t\t//Convert subjects to candidates\n-\t\t\t\tList<Candidate> candidates = convertSubjectsToCandidates(sess, subjects, membersSource, source, skippedMembers);\n-\n-\t\t\t\tcategorizeMembersForSynchronization(sess, actualGroupMembers, candidates, candidatesToAdd, membersToUpdate, membersToRemove);\n-\t\t\t}\n-\n-\t\t\t//Update members already presented in group\n-\t\t\tupdateExistingMembersWhileSynchronization(sess, group, membersToUpdate, overwriteUserAttributesList);\n-\n-\t\t\t//Add not presented candidates to group\n-\t\t\taddMissingMembersWhileSynchronization(sess, group, candidatesToAdd, overwriteUserAttributesList, skippedMembers);\n-\n-\t\t\t//Remove presented members in group who are not presented in synchronized ExtSource\n-\t\t\tremoveFormerMembersWhileSynchronization(sess, group, membersToRemove);\n-\n-\t\t\tlog.info(\"Group synchronization {}: ended.\", group);\n-\t\t} finally {\n-\t\t\tcloseExtSourcesAfterSynchronization(membersSource, source);\n-\t\t}\n-\n-\t\treturn skippedMembers;\n-\t}\n-\n-\t/**\n-\t * Force group synchronization.\n-\t *\n-\t * Adds the group synchronization process in the groupSynchronizerThreads.\n-\t *\n-\t * @param group\n-\t */\n-\tpublic void forceGroupSynchronization(PerunSession sess, Group group) throws GroupSynchronizationAlreadyRunningException {\n-\t\t// First check if the group is not currently in synchronization process\n-\t\tif (groupSynchronizerThreads.containsKey(group.getId()) && groupSynchronizerThreads.get(group.getId()).getState() != Thread.State.TERMINATED) {\n-\t\t\tthrow new GroupSynchronizationAlreadyRunningException(group);\n-\t\t} else {\n-\t\t\t// Remove from groupSynchronizerThreads if the thread was terminated\n-\t\t\tif (groupSynchronizerThreads.containsKey(group.getId())) {\n-\t\t\t\tgroupSynchronizerThreads.remove(group.getId());\n-\t\t\t}\n-\t\t\t// Start and run the new thread\n-\t\t\tGroupSynchronizerThread thread = new GroupSynchronizerThread(sess, group);\n-\t\t\tthread.start();\n-\t\t\tlog.info(\"Group synchronization thread started for group {}.\", group);\n-\n-\t\t\tgroupSynchronizerThreads.put(group.getId(), thread);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Synchronize all groups which have enabled synchronization. This method is run by the scheduler every 5 minutes.\n-\t *\n-\t * @throws InternalErrorException\n-\t */\n-\tpublic void synchronizeGroups(PerunSession sess) throws InternalErrorException {\n-\t\tRandom rand = new Random();\n-\n-\t\t// Firstly remove all terminated threads\n-\t\tList<Integer> threadsToRemove = new ArrayList<Integer>();\n-\t\tfor (Integer groupId: groupSynchronizerThreads.keySet()) {\n-\t\t\tif (groupSynchronizerThreads.get(groupId).getState() == Thread.State.TERMINATED) {\n-\t\t\t\tthreadsToRemove.add(groupId);\n-\t\t\t}\n-\t\t}\n-\t\tfor (Integer groupId: threadsToRemove) {\n-\t\t\tgroupSynchronizerThreads.remove(groupId);\n-\t\t\tlog.debug(\"Removing terminated group synchronization thread for group id={}\", groupId);\n-\t\t}\n-\n-\t\t// Get the default synchronization interval and synchronization timeout from the configuration file\n-\t\tint intervalMultiplier = Integer.parseInt(BeansUtils.getPropertyFromConfiguration(\"perun.group.synchronization.interval\"));\n-\t\tint timeout = Integer.parseInt(BeansUtils.getPropertyFromConfiguration(\"perun.group.synchronization.timeout\"));\n-\n-\t\t// Get the number of seconds from the epoch, so we can divide it by the synchronization interval value\n-\t\tlong minutesFromEpoch = System.currentTimeMillis()/1000/60;\n-\n-\t\t// Get the groups with synchronization enabled\n-\t\tList<Group> groups = groupsManagerImpl.getGroupsToSynchronize(sess);\n-\n-\t\tint numberOfNewSynchronizations = 0;\n-\t\tint numberOfActiveSynchronizations = 0;\n-\t\tint numberOfTerminatedSynchronizations = 0;\n-\t\tfor (Group group: groups) {\n-\t\t\t// Get the synchronization interval\n-\t\t\ttry {\n-\t\t\t\tAttribute intervalAttribute = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPSYNCHROINTERVAL_ATTRNAME);\n-\t\t\t\tif (intervalAttribute.getValue() != null) {\n-\t\t\t\t\tintervalMultiplier = Integer.parseInt((String) intervalAttribute.getValue());\n-\t\t\t\t} else {\n-\t\t\t\t\tlog.warn(\"Group {} hasn't set synchronization interval, using default {} seconds\", group, intervalMultiplier);\n-\t\t\t\t}\n-\t\t\t} catch (AttributeNotExistsException e) {\n-\t\t\t\tthrow new ConsistencyErrorException(\"Required attribute \" + GroupsManager.GROUPSYNCHROINTERVAL_ATTRNAME + \" isn't defined in Perun!\",e);\n-\t\t\t} catch (WrongAttributeAssignmentException e) {\n-\t\t\t\tlog.error(\"Cannot synchronize group \" + group +\" due to exception:\", e);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t// Multiply with 5 to get real minutes\n-\t\t\tintervalMultiplier = intervalMultiplier*5;\n-\n-\t\t\t// If the minutesFromEpoch can be divided by the intervalMultiplier, then synchronize\n-\t\t\tif ((minutesFromEpoch % intervalMultiplier) == 0) {\n-\t\t\t\t// It's time to synchronize\n-\t\t\t\tlog.info(\"Scheduling synchronization for the group {}. Interval {} minutes.\", group, intervalMultiplier);\n-\n-\t\t\t\t// Run each synchronization in separate thread, but do not start new one, if previous hasn't finished yet\n-\t\t\t\tif (groupSynchronizerThreads.containsKey(group.getId())) {\n-\t\t\t\t\t// Check the running time of the thread\n-\t\t\t\t\tlong timeDiff = System.currentTimeMillis() - groupSynchronizerThreads.get(group.getId()).getStartTime();\n-\n-\t\t\t\t\t// If the time is greater than timeout set in the configuration file (in minutes)\n-\t\t\t\t\tif (timeDiff/1000/60 > timeout) {\n-\t\t\t\t\t\t// Timeout reach, stop the thread\n-\t\t\t\t\t\tlog.warn(\"Timeout {} minutes of the synchronization thread for the group {} reached.\", timeout, group);\n-\t\t\t\t\t\tgroupSynchronizerThreads.get(group.getId()).interrupt();\n-\t\t\t\t\t\tgroupSynchronizerThreads.remove(group.getId());\n-\t\t\t\t\t\tnumberOfTerminatedSynchronizations++;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tnumberOfActiveSynchronizations++;\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// Start and run the new thread\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\t// Do not overload externalSource, run each synchronization in 0-30s steps\n-\t\t\t\t\t\tThread.sleep(rand.nextInt(30000));\n-\t\t\t\t\t} catch (InterruptedException e) {\n-\t\t\t\t\t\t// Do nothing\n-\t\t\t\t\t}\n-\t\t\t\t\tGroupSynchronizerThread thread = new GroupSynchronizerThread(sess, group);\n-\t\t\t\t\tthread.start();\n-\t\t\t\t\tlog.info(\"Group synchronization thread started for group {}.\", group);\n-\n-\t\t\t\t\tgroupSynchronizerThreads.put(group.getId(), thread);\n-\t\t\t\t\tnumberOfNewSynchronizations++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (groups.size() > 0) {\n-\t\t\tlog.info(\"Synchronizing {} groups, active {}, new {}, terminated {}.\",\n-\t\t\t\t\tnew Object[] {groups.size(), numberOfActiveSynchronizations, numberOfNewSynchronizations, numberOfTerminatedSynchronizations});\n-\t\t}\n-\t}\n-\n-\tprivate static class GroupSynchronizerThread extends Thread {\n-\n-\t\t// all synchronization runs under synchronizer identity.\n-\t\tfinal PerunPrincipal pp = new PerunPrincipal(\"perunSynchronizer\", ExtSourcesManager.EXTSOURCE_NAME_INTERNAL, ExtSourcesManager.EXTSOURCE_INTERNAL);\n-\t\tprivate PerunBl perunBl;\n-\t\tprivate PerunSession sess;\n-\t\tprivate Group group;\n-\t\tprivate long startTime;\n-\n-\t\tpublic GroupSynchronizerThread(PerunSession sess, Group group) {\n-\t\t\t// take only reference to perun\n-\t\t\tthis.perunBl = (PerunBl) sess.getPerun();\n-\t\t\tthis.group = group;\n-\t\t\ttry {\n-\t\t\t\t// create own session\n-\t\t\t\tthis.sess = perunBl.getPerunSession(pp, new PerunClient());\n-\t\t\t} catch (InternalErrorException ex) {\n-\t\t\t\tlog.error(\"Unable to create internal session for Synchronizer with credentials {} because of exception {}\", pp, ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\tpublic void run() {\n-\t\t\t//text of exception if was thrown, null in exceptionMessage means \"no exception, it's ok\"\n-\t\t\tString exceptionMessage = null;\n-\t\t\t//text with all skipped members and reasons of this skipping\n-\t\t\tString skippedMembersMessage = null;\n-\t\t\t//if exception which produce fail of whole synchronization was thrown\n-\t\t\tboolean failedDueToException = false;\n-\n-\t\t\ttry {\n-\t\t\t\tlog.debug(\"Synchronization thread for group {} has started.\", group);\n-\t\t\t\t// Set the start time, so we can check the timeout of the thread\n-\t\t\t\tstartTime = System.currentTimeMillis();\n-\n-\t\t\t\t//synchronize Group and get information about skipped Members\n-\t\t\t\tList<String> skippedMembers = perunBl.getGroupsManagerBl().synchronizeGroup(sess, group);\n-\n-\t\t\t\tif(!skippedMembers.isEmpty()) {\n-\t\t\t\t\tskippedMembersMessage = \"These members from extSource were skipped: { \";\n-\n-\t\t\t\t\tfor(String skippedMember: skippedMembers) {\n-\t\t\t\t\t\tif(skippedMember == null) continue;\n-\n-\t\t\t\t\t\tskippedMembersMessage+= skippedMember + \", \";\n-\t\t\t\t\t}\n-\t\t\t\t\tskippedMembersMessage+= \" }\";\n-\t\t\t\t\texceptionMessage = skippedMembersMessage;\n-\t\t\t\t}\n-\n-\t\t\t\tlog.debug(\"Synchronization thread for group {} has finished in {} ms.\", group, System.currentTimeMillis()-startTime);\n-\t\t\t} catch (WrongAttributeValueException | WrongReferenceAttributeValueException | InternalErrorException |\n-\t\t\t\t\tWrongAttributeAssignmentException | MemberAlreadyRemovedException | GroupNotExistsException |\n-\t\t\t\t\tGroupOperationsException | NotMemberOfParentGroupException | AttributeNotExistsException | ExtSourceNotExistsException e) {\n-\t\t\t\tfailedDueToException = true;\n-\t\t\t\texceptionMessage = \"Cannot synchronize group \";\n-\t\t\t\tlog.error(exceptionMessage + group, e);\n-\t\t\t\texceptionMessage+= \"due to exception: \" + e.getName() + \" => \" + e.getMessage();\n-\t\t\t} catch (Exception e) {\n-\t\t\t\t//If some other exception has been thrown, log it and throw again\n-\t\t\t\tfailedDueToException = true;\n-\t\t\t\texceptionMessage = \"Cannot synchronize group \";\n-\t\t\t\tlog.error(exceptionMessage + group, e);\n-\t\t\t\texceptionMessage+= \"due to unexpected exception: \" + e.getClass().getName() + \" => \" + e.getMessage();\n-\t\t\t\tthrow e;\n-\t\t\t} finally {\n-\t\t\t\t//Save information about group synchronization, this method run in new transaction\n-\t\t\t\ttry {\n-\t\t\t\t\tperunBl.getGroupsManagerBl().saveInformationAboutGroupSynchronization(sess, group, failedDueToException, exceptionMessage);\n-\t\t\t\t} catch (Exception ex) {\n-\t\t\t\t\tlog.error(\"When synchronization group \" + group + \", exception was thrown.\", ex);\n-\t\t\t\t\tlog.info(\"Info about exception from synchronization: \" + skippedMembersMessage);\n-\t\t\t\t}\n-\t\t\t\tlog.debug(\"GroupSynchronizerThread finished for group: {}\", group);\n-\t\t\t}\n-\t\t}\n-\n-\t\tpublic long getStartTime() {\n-\t\t\treturn startTime;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get all groups of member (except members group) where authoritativeGroup attribute is set to 1 (true)\n-\t *\n-\t * @param sess\n-\t * @param member\n-\t * @return list of groups with authoritativeAttribute set to 1\n-\t *\n-\t * @throws AttributeNotExistsException if authoritativeGroup attribute not exists\n-\t * @throws InternalErrorException\n-\t */\n-\tList<Group> getAllAuthoritativeGroupsOfMember(PerunSession sess, Member member) throws AttributeNotExistsException, InternalErrorException {\n-\t\t//Get all member groups except membersGroup\n-\t\tList<Group> memberGroups = this.getMemberGroups(sess, member);\n-\t\tIterator<Group> groupsIter = memberGroups.iterator();\n-\t\t//Iterate through all groups and remove those which have not authoritativeGroup attribute set to 1\n-\t\twhile(groupsIter.hasNext()) {\n-\t\t\tGroup group = groupsIter.next();\n-\t\t\ttry {\n-\t\t\t\tboolean isThisGroupAuthoritative = false;\n-\t\t\t\tAttribute authoritativeGroup = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_D_AUTHORITATIVE_GROUP);\n-\t\t\t\tif(authoritativeGroup.getValue() != null) {\n-\t\t\t\t\tInteger attrValue = (Integer) authoritativeGroup.getValue();\n-\t\t\t\t\tif(attrValue == 1) isThisGroupAuthoritative = true;\n-\t\t\t\t}\n-\t\t\t\t//If group is not authoritative group, remove it from list of memberAuthoritativeGroups\n-\t\t\t\tif(!isThisGroupAuthoritative) groupsIter.remove();\n-\t\t\t} catch(WrongAttributeAssignmentException ex) {\n-\t\t\t\tthrow new InternalErrorException(ex);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn memberGroups;\n-\t}\n-\n-\t/**\n-\t * Gets the groupsManagerImpl for this instance.\n-\t *\n-\t * @return The groupsManagerImpl.\n-\t */\n-\tpublic GroupsManagerImplApi getGroupsManagerImpl() {\n-\t\treturn this.groupsManagerImpl;\n-\t}\n-\n-\t/**\n-\t * Gets the perunBl.\n-\t *\n-\t * @return The perunBl.\n-\t */\n-\tpublic PerunBl getPerunBl() {\n-\t\treturn this.perunBl;\n-\t}\n-\n-\tpublic List<Group> getGroupsByAttribute(PerunSession sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tgetPerunBl().getAttributesManagerBl().checkNamespace(sess, attribute, AttributesManager.NS_GROUP_ATTR);\n-\t\tif(!(getPerunBl().getAttributesManagerBl().isDefAttribute(sess, attribute) || getPerunBl().getAttributesManagerBl().isOptAttribute(sess, attribute))) throw new WrongAttributeAssignmentException(\"This method can process only def and opt attributes\");\n-\t\treturn getGroupsManagerImpl().getGroupsByAttribute(sess, attribute);\n-\t}\n-\n-\tpublic List<Pair<Group, Resource>> getGroupResourcePairsByAttribute(PerunSession sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException {\n-\t\tgetPerunBl().getAttributesManagerBl().checkNamespace(sess, attribute, AttributesManager.NS_GROUP_RESOURCE_ATTR);\n-\t\tif(!(getPerunBl().getAttributesManagerBl().isDefAttribute(sess, attribute) || getPerunBl().getAttributesManagerBl().isOptAttribute(sess, attribute))) throw new WrongAttributeAssignmentException(\"This method can process only def and opt attributes\");\n-\t\treturn getGroupsManagerImpl().getGroupResourcePairsByAttribute(sess, attribute);\n-\t}\n-\n-\tpublic boolean isGroupMember(PerunSession sess, Group group, Member member) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().isGroupMember(sess, group, member);\n-\t}\n-\n-\tpublic void checkGroupExists(PerunSession sess, Group group) throws InternalErrorException, GroupNotExistsException {\n-\t\tgetGroupsManagerImpl().checkGroupExists(sess, group);\n-\t}\n-\n-\tpublic List<Group> getGroupsByPerunBean(PerunSession sess, PerunBean perunBean) throws InternalErrorException {\n-\t\tList<Group> groups = new ArrayList<Group>();\n-\n-\t\t//All possible useful objects\n-\t\tVo vo = null;\n-\t\tFacility facility = null;\n-\t\tGroup group = null;\n-\t\tMember member = null;\n-\t\tUser user = null;\n-\t\tHost host = null;\n-\t\tResource resource = null;\n-\n-\t\tif(perunBean != null) {\n-\t\t\tif(perunBean instanceof Vo) vo = (Vo) perunBean;\n-\t\t\telse if(perunBean instanceof Facility) facility = (Facility) perunBean;\n-\t\t\telse if(perunBean instanceof Group) group = (Group) perunBean;\n-\t\t\telse if(perunBean instanceof Member) member = (Member) perunBean;\n-\t\t\telse if(perunBean instanceof User) user = (User) perunBean;\n-\t\t\telse if(perunBean instanceof Host) host = (Host) perunBean;\n-\t\t\telse if(perunBean instanceof Resource) resource = (Resource) perunBean;\n-\t\t\telse {\n-\t\t\t\tthrow new InternalErrorException(\"There is unrecognized object in primaryHolder of aidingAttr.\");\n-\t\t\t}\n-\t\t} else {\n-\t\t\tthrow new InternalErrorException(\"Aiding attribute must have primaryHolder which is not null.\");\n-\t\t}\n-\n-\t\t//Important For Groups not work with Subgroups! Invalid members are executed too.\n-\n-\t\tif(group != null) {\n-\t\t\tgroups.add(group);\n-\t\t} else if(member != null) {\n-\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAllMemberGroups(sess, member));\n-\t\t} else if(resource != null) {\n-\t\t\tgroups.addAll(getPerunBl().getResourcesManagerBl().getAssignedGroups(sess, resource));\n-\t\t} else if(user != null) {\n-\t\t\tList<Member> members = getPerunBl().getMembersManagerBl().getMembersByUser(sess, user);\n-\t\t\tfor(Member memberElement: members) {\n-\t\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAllMemberGroups(sess, memberElement));\n-\t\t\t}\n-\t\t} else if(host != null) {\n-\t\t\tfacility = getPerunBl().getFacilitiesManagerBl().getFacilityForHost(sess, host);\n-\t\t\tList<Resource> resourcesFromFacility = getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n-\t\t\tfor(Resource resourceElement: resourcesFromFacility) {\n-\t\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAssignedGroupsToResource(sess, resourceElement));\n-\t\t\t}\n-\t\t} else if(facility != null) {\n-\t\t\tList<Resource> resourcesFromFacility = getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n-\t\t\tfor(Resource resourceElement: resourcesFromFacility) {\n-\t\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAssignedGroupsToResource(sess, resourceElement));\n-\t\t\t}\n-\t\t} else if(vo != null) {\n-\t\t\tgroups.addAll(getPerunBl().getGroupsManagerBl().getAllGroups(sess, vo));\n-\t\t}\n-\n-\t\tgroups = new ArrayList<Group>(new HashSet<Group>(groups));\n-\t\treturn groups;\n-\t}\n-\n-\tpublic List<Member> filterMembersByMembershipTypeInGroup(List<Member> members) throws InternalErrorException {\n-\t\tList<Member> filteredMembers = new ArrayList<Member>();\n-\t\tIterator<Member> membersIterator = members.iterator();\n-\n-\t\t//Add members with direct membership type\n-\t\twhile(membersIterator.hasNext()) {\n-\t\t\tMember m = membersIterator.next();\n-\t\t\tif(m.getMembershipType().equals(MembershipType.DIRECT)) {\n-\t\t\t\tfilteredMembers.add(m);\n-\t\t\t\tmembersIterator.remove();\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Add not containing members with indirect membership type\n-\t\tfor(Member m: members) {\n-\t\t\tif(!filteredMembers.contains(m)) filteredMembers.add(m);\n-\t\t}\n-\n-\t\treturn filteredMembers;\n-\t}\n-\n-\tpublic RichGroup filterOnlyAllowedAttributes(PerunSession sess, RichGroup richGroup) throws InternalErrorException {\n-\t\tif(richGroup == null) throw new InternalErrorException(\"RichGroup can't be null.\");\n-\n-\t\t//Filtering richGroup attributes\n-\t\tif(richGroup.getAttributes() != null) {\n-\t\t\tList<Attribute> groupAttributes = richGroup.getAttributes();\n-\t\t\tList<Attribute> allowedGroupAttributes = new ArrayList<Attribute>();\n-\t\t\tfor(Attribute groupAttr : groupAttributes) {\n-\t\t\t\tif(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.READ, groupAttr, richGroup, null)) {\n-\t\t\t\t\tgroupAttr.setWritable(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttr, richGroup, null));\n-\t\t\t\t\tallowedGroupAttributes.add(groupAttr);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\trichGroup.setAttributes(allowedGroupAttributes);\n-\t\t}\n-\t\treturn richGroup;\n-\t}\n-\n-\tpublic List<RichGroup> filterOnlyAllowedAttributes(PerunSession sess, List<RichGroup> richGroups) throws InternalErrorException {\n-\t\tList<RichGroup> filteredRichGroups = new ArrayList<RichGroup>();\n-\t\tif(richGroups == null || richGroups.isEmpty()) return filteredRichGroups;\n-\n-\t\tfor(RichGroup rg : richGroups) {\n-\t\t\tfilteredRichGroups.add(this.filterOnlyAllowedAttributes(sess, rg));\n-\t\t}\n-\n-\t\treturn filteredRichGroups;\n-\t}\n-\n-\tpublic void setPerunBl(PerunBl perunBl) {\n-\t\tthis.perunBl = perunBl;\n-\t}\n-\n-\tpublic RichGroup convertGroupToRichGroupWithAttributes(PerunSession sess, Group group) throws InternalErrorException{\n-\t\treturn new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group));\n-\t}\n-\n-\tpublic RichGroup convertGroupToRichGroupWithAttributesByName(PerunSession sess, Group group, List<String> attrNames) throws InternalErrorException{\n-\t\tif (attrNames == null) return convertGroupToRichGroupWithAttributes(sess, group);\n-\t\treturn new RichGroup(group,this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group, attrNames));\n-\t}\n-\n-\tpublic List<RichGroup> convertGroupsToRichGroupsWithAttributes(PerunSession sess, List<Group> groups) throws InternalErrorException {\n-\t\tList<RichGroup> richGroups = new ArrayList<>();\n-\t\tfor(Group group: groups) {\n-\t\t\trichGroups.add(new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group)));\n-\t\t}\n-\t\treturn richGroups;\n-\t}\n-\n-\tpublic List<RichGroup> convertGroupsToRichGroupsWithAttributes(PerunSession sess, List<Group> groups, List<String> attrNames) throws InternalErrorException {\n-\t\tif (attrNames == null) return convertGroupsToRichGroupsWithAttributes(sess, groups);\n-\t\tList<RichGroup> richGroups = new ArrayList<>();\n-\t\tfor(Group group: groups) {\n-\t\t\trichGroups.add(new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group, attrNames)));\n-\t\t}\n-\t\treturn richGroups;\n-\t}\n-\n-\tpublic List<RichGroup> getAllRichGroupsWithAttributesByNames(PerunSession sess, Vo vo, List<String> attrNames)throws InternalErrorException{\n-\t\treturn convertGroupsToRichGroupsWithAttributes(sess, this.getAllGroups(sess, vo), attrNames);\n-\t}\n-\n-\tpublic List<RichGroup> getRichSubGroupsWithAttributesByNames(PerunSession sess, Group parentGroup, List<String> attrNames)throws InternalErrorException{\n-\t\treturn convertGroupsToRichGroupsWithAttributes(sess, this.getSubGroups(sess, parentGroup), attrNames);\n-\t}\n-\n-\tpublic List<RichGroup> getAllRichSubGroupsWithAttributesByNames(PerunSession sess, Group parentGroup, List<String> attrNames)throws InternalErrorException{\n-\t\treturn convertGroupsToRichGroupsWithAttributes(sess, this.getAllSubGroups(sess, parentGroup), attrNames);\n-\t}\n-\n-\tpublic RichGroup getRichGroupByIdWithAttributesByNames(PerunSession sess, int groupId, List<String> attrNames)throws InternalErrorException, GroupNotExistsException{\n-\t\treturn convertGroupToRichGroupWithAttributesByName(sess, this.getGroupById(sess, groupId), attrNames);\n-\t}\n-\n-\tpublic void saveInformationAboutGroupSynchronization(PerunSession sess, Group group, boolean failedDueToException, String exceptionMessage) throws AttributeNotExistsException, InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, WrongAttributeValueException {\n-\t\t//get current timestamp of this synchronization\n-\t\tDate currentTimestamp = new Date();\n-\t\tString originalExceptionMessage = exceptionMessage;\n-\t\t//If session is null, throw an exception\n-\t\tif (sess == null) {\n-\t\t\tthrow new InternalErrorException(\"Session is null when trying to save information about synchronization. Group: \" + group + \", timestamp: \" + currentTimestamp + \",message: \" + exceptionMessage);\n-\t\t}\n-\n-\t\t//If group is null, throw an exception\n-\t\tif (group == null) {\n-\t\t\tthrow new InternalErrorException(\"Object group is null when trying to save information about synchronization. Timestamp: \" + currentTimestamp + \", message: \" + exceptionMessage);\n-\t\t}\n-\n-\t\t//if exceptionMessage is empty, use \"Empty message\" instead\n-\t\tif (exceptionMessage != null && exceptionMessage.isEmpty()) {\n-\t\t\texceptionMessage = \"Empty message.\";\n-\t\t//else trim the message on 1000 characters if not null\n-\t\t} else if (exceptionMessage != null && exceptionMessage.length() > 1000) {\n-\t\t\texceptionMessage = exceptionMessage.substring(0, 1000) + \" ... message is too long, other info is in perun log file. If needed, please ask perun administrators.\";\n-\t\t}\n-\n-\t\t//Set correct format of currentTimestamp\n-\t\tString correctTimestampString = BeansUtils.getDateFormatter().format(currentTimestamp);\n-\n-\t\t//Get both attribute definition lastSynchroTimestamp and lastSynchroState\n-\t\t//Get definitions and values, set values\n-\t\tAttribute lastSynchronizationTimestamp = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, AttributesManager.NS_GROUP_ATTR_DEF + \":lastSynchronizationTimestamp\"));\n-\t\tAttribute lastSynchronizationState = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, AttributesManager.NS_GROUP_ATTR_DEF + \":lastSynchronizationState\"));\n-\t\tlastSynchronizationTimestamp.setValue(correctTimestampString);\n-\t\t//if exception is null, set null to value => remove attribute instead of setting in method setAttributes\n-\t\tlastSynchronizationState.setValue(exceptionMessage);\n-\n-\t\t//attributes to set\n-\t\tList<Attribute> attrsToSet = new ArrayList<>();\n-\n-\t\t//null in exceptionMessage means no exception, success\n-\t\t//Set lastSuccessSynchronizationTimestamp if this one is success\n-\t\tif(exceptionMessage == null) {\n-\t\t\tString attrName = AttributesManager.NS_GROUP_ATTR_DEF + \":lastSuccessSynchronizationTimestamp\";\n-\t\t\ttry {\n-\t\t\t\tAttribute lastSuccessSynchronizationTimestamp = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, attrName));\n-\t\t\t\tlastSuccessSynchronizationTimestamp.setValue(correctTimestampString);\n-\t\t\t\tattrsToSet.add(lastSuccessSynchronizationTimestamp);\n-\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\tlog.error(\"Can't save lastSuccessSynchronizationTimestamp, because there is missing attribute with name {}\",attrName);\n-\t\t\t}\n-\t\t} else {\n-\t\t\t//Log to auditer_log that synchronization failed or finished with some errors\n-\t\t\tif(failedDueToException) {\n-\t\t\t\tgetPerunBl().getAuditer().log(sess, \"{} synchronization failed because of {}.\", group, originalExceptionMessage);\n-\t\t\t} else {\n-\t\t\t\tgetPerunBl().getAuditer().log(sess, \"{} synchronization finished with errors: {}.\", group, originalExceptionMessage);\n-\t\t\t}\n-\t\t}\n-\n-\t\t//set lastSynchronizationState and lastSynchronizationTimestamp\n-\t\tattrsToSet.add(lastSynchronizationState);\n-\t\tattrsToSet.add(lastSynchronizationTimestamp);\n-\t\t((PerunBl) sess.getPerun()).getAttributesManagerBl().setAttributes(sess, group, attrsToSet);\n-\t}\n-\n-\t@Override\n-\tpublic List<Group> getGroupsWithAssignedExtSourceInVo(PerunSession sess, ExtSource source, Vo vo) throws InternalErrorException {\n-\t\treturn getGroupsManagerImpl().getGroupsWithAssignedExtSourceInVo(sess, source, vo);\n-\t}\n-\n-\t//----------- PRIVATE METHODS FOR  GROUP SYNCHRONIZATION -----------\n-\n-\t/**\n-\t * For lightweight synchronization prepare candidate to add and members to remove.\n-\t *\n-\t * Get all subjects from loginSource and try to find users in Perun by their login and this ExtSource.\n-\t * If found, look if this user is already in synchronized Group. If yes skip him, if not add him to candidateToAdd\n-\t * If not found, add him to candidatesToAdd (from source itself or from memberSource if they are different)\n-\t *\n-\t * Rest of former members need to be add to membersToRemove to remove them from group.\n-\t *\n-\t * This method fill 2 member structures which get as parameters:\n-\t * 1. candidateToAdd - New members of the group\n-\t * 2. membersToRemove - Former members who are not in synchronized ExtSource now\n-\t *\n-\t * @param sess\n-\t * @param group\n-\t * @param loginSource\n-\t * @param memberSource\n-\t * @param groupMembers\n-\t * @param candidatesToAdd\n-\t * @param membersToRemove\n-\t * @param skippedMembers\n-\t * @throws InternalErrorException\n-\t * @throws ExtSourceNotExistsException\n-\t */\n-\tprivate void categorizeMembersForLightweightSynchronization(PerunSession sess, Group group, ExtSource loginSource, ExtSource memberSource, List<RichMember> groupMembers, List<Candidate> candidatesToAdd, List<RichMember> membersToRemove, List<String> skippedMembers) throws InternalErrorException, ExtSourceNotExistsException {\n-\t\t//Get subjects from loginSource\n-\t\tList<Map<String, String>> subjects = getSubjectsFromExtSource(sess, loginSource, group);\n-\n-\t\t//Prepare structure of userIds with richMembers to better work with actual members\n-\t\tMap<Integer, RichMember> idsOfUsersInGroup = new HashMap<>();\n-\t\tfor(RichMember richMember: groupMembers) {\n-\t\t\tidsOfUsersInGroup.put(richMember.getUserId(), richMember);\n-\t\t}\n-\n-\t\t//try to find users by login and loginSource\n-\t\tfor(Map<String, String> subjectFromLoginSource : subjects) {\n-\t\t\tString login = subjectFromLoginSource.get(\"login\");\n-\t\t\t// Skip subjects, which doesn't have login\n-\t\t\tif (login == null || login.isEmpty()) {\n-\t\t\t\tlog.debug(\"Subject {} doesn't contain attribute login, skipping.\", subjectFromLoginSource);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subjectFromLoginSource + \"] was skipped because login is missing\");\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t//try to find user from perun by login and member extSource (need to use memberSource because loginSource is not saved by synchronization)\n-\t\t\tUser user = null;\n-\t\t\tCandidate candidate = null;\n-\t\t\ttry {\n-\t\t\t\tUserExtSource userExtSource = getPerunBl().getUsersManagerBl().getUserExtSourceByExtLogin(sess, memberSource, login);\n-\t\t\t\tuser = getPerunBl().getUsersManagerBl().getUserByUserExtSource(sess, userExtSource);\n-\t\t\t\tif(!idsOfUsersInGroup.containsKey(user.getId())) {\n-\t\t\t\t\tcandidate = new Candidate(user, userExtSource);\n-\t\t\t\t}\n-\t\t\t} catch (UserExtSourceNotExistsException | UserNotExistsException ex) {\n-\t\t\t\t//If not find, get more information about him from member extSource\n-\t\t\t\tList<Map<String, String>> subjectToConvert = Arrays.asList(subjectFromLoginSource);\n-\t\t\t\tList<Candidate> converetedCandidatesList = convertSubjectsToCandidates(sess, subjectToConvert, memberSource, loginSource, skippedMembers);\n-\t\t\t\t//Empty means not found (skipped)\n-\t\t\t\tif(!converetedCandidatesList.isEmpty()) {\n-\t\t\t\t\t//We add one subject so we take the one converted candidate\n-\t\t\t\t\tcandidate = converetedCandidatesList.get(0);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//If user is not null now, we found it so we can use it from perun, in other case he is not in perun at all\n-\t\t\tif(user != null && candidate == null) {\n-\t\t\t\t//we can skip this one, because he is already in group, and remove him from the map\n-\t\t\t\tidsOfUsersInGroup.remove(user.getId());\n-\t\t\t} else if (candidate != null) {\n-\t\t\t\tcandidatesToAdd.add(candidate);\n-\t\t\t} else {\n-\t\t\t\t//Both null means that we can't find subject by login in extSource at all (will be in skipped members)\n-\t\t\t\tlog.debug(\"Subject with login {} was skipped because can't be found in extSource {}.\", login, memberSource);\n-\t\t\t}\n-\t\t}\n-\n-\t\t//Rest of them need to be removed\n-\t\tmembersToRemove.addAll(idsOfUsersInGroup.values());\n-\t}\n-\n-\t/**\n-\t * This method fill 3 member structures which get as parameters:\n-\t * 1. membersToUpdate - Candidates with equivalent Members from Perun for purpose of updating attributes and statuses\n-\t * 2. candidateToAdd - New members of the group\n-\t * 3. membersToRemove - Former members who are not in synchronized ExtSource now\n-\t *\n-\t * @param sess\n-\t * @param groupMembers current group members\n-\t * @param candidates to be synchronized from extSource\n-\t * @param membersToUpdate 1. container (more above)\n-\t * @param candidatesToAdd 2. container (more above)\n-\t * @param membersToRemove 3. container (more above)\n-\t *\n-\t * @throws InternalErrorException if getting RichMembers without attributes for the group fail\n-\t */\n-\tprivate void categorizeMembersForSynchronization(PerunSession sess, List<RichMember> groupMembers, List<Candidate> candidates, List<Candidate> candidatesToAdd, Map<Candidate, RichMember> membersToUpdate, List<RichMember> membersToRemove) throws InternalErrorException {\n-\t\tcandidatesToAdd.addAll(candidates);\n-\t\tmembersToRemove.addAll(groupMembers);\n-\t\t//mapping structure for more efficient searching\n-\t\tMap<UserExtSource, RichMember> mappingStructure = new HashMap<>();\n-\t\tfor(RichMember rm: groupMembers) {\n-\t\t\tfor(UserExtSource ues: rm.getUserExtSources()) {\n-\t\t\t\tmappingStructure.put(ues, rm);\n-\t\t\t}\n-\t\t}\n-\n-\t\t//try to find already existing candidates between members in group\n-\t\tfor(Candidate candidate: candidates) {\n-\t\t\tList<UserExtSource> candidateExtSources = candidate.getUserExtSources();\n-\t\t\tfor(UserExtSource key: candidateExtSources) {\n-\t\t\t\t//candidate exists, will be updated\n-\t\t\t\tif(mappingStructure.containsKey(key)) {\n-\t\t\t\t\tmembersToUpdate.put(candidate, mappingStructure.get(key));\n-\t\t\t\t\tcandidatesToAdd.remove(candidate);\n-\t\t\t\t\tmembersToRemove.remove(mappingStructure.get(key));\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get ExtSource by name from attribute group:groupMembersExtSource.\n-\t * Attribute can be null so if is not set, use default source.\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t * @param defaultSource we need to have already default group source (for synchronization)\n-\t *\n-\t * @return if exists, return membersExtSource, if not, return default group extSource\n-\t *\n-\t * @throws InternalErrorException if some internal error happens\n-\t * @throws WrongAttributeAssignmentException if bad assignment of groupMembersExtSource attribute\n-\t * @throws AttributeNotExistsException if groupMembersExtSource attribute not exists in perun Database\n-\t * @throws ExtSourceNotExistsException if extSource set in Group attribute not exists\n-\t */\n-\tprivate ExtSource getGroupMembersExtSourceForSynchronization(PerunSession sess, Group group, ExtSource defaultSource) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, ExtSourceNotExistsException {\n-\t\t//Prepare the groupMembersExtSource if it is set\n-\t\tAttribute membersExtSourceNameAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPMEMBERSEXTSOURCE_ATTRNAME);\n-\t\tExtSource membersSource = null;\n-\t\t// If the different extSource name for the members was set use it\n-\t\tif (membersExtSourceNameAttr != null && membersExtSourceNameAttr.getValue() != null) {\n-\t\t\tString membersExtSourceName = (String) membersExtSourceNameAttr.getValue();\n-\t\t\tmembersSource = getPerunBl().getExtSourcesManagerBl().getExtSourceByName(sess, membersExtSourceName);\n-\t\t\treturn membersSource;\n-\t\t//Otherwise use use the group one\n-\t\t} else {\n-\t\t\treturn defaultSource;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get ExtSource by name from attribute group:groupExtSource\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t *\n-\t * @return default group extSource for synchronization\n-\t *\n-\t * @throws InternalErrorException if some internal error happens or attribute with extSource name is null\n-\t * @throws WrongAttributeAssignmentException if bad assignment of groupExtSource attribute\n-\t * @throws AttributeNotExistsException if groupExtSource attribute not exists in perun Database\n-\t * @throws ExtSourceNotExistsException if extSource set in Group attribute not exists\n-\t */\n-\tprivate ExtSource getGroupExtSourceForSynchronization(PerunSession sess, Group group) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, ExtSourceNotExistsException {\n-\t\t//Get extSource name from group attribute\n-\t\tAttribute extSourceNameAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPEXTSOURCE_ATTRNAME);\n-\t\tif (extSourceNameAttr == null || extSourceNameAttr.getValue() == null) {\n-\t\t\tthrow new InternalErrorException(\"ExtSource is not set for group: \" + group);\n-\t\t}\n-\t\t//return extSource by name\n-\t\treturn getPerunBl().getExtSourcesManagerBl().getExtSourceByName(sess, ((String) extSourceNameAttr.getValue()));\n-\t}\n-\n-\t/**\n-\t * From membersSource extSource get attribute overwriteUserAttributes and prepare\n-\t * list of attributes names to be overwrite for synchronized users.\n-\t *\n-\t * Attribute has value (if set) in format \"name,name2,name3...\"\n-\t * Method parse these names to list of names.\n-\t * Return empty array if attribute is not set for extSource or if it is empty.\n-\t *\n-\t * @param membersSource to get attributes from\n-\t *\n-\t * @return list of attribute names to be overwrite\n-\t *\n-\t * @throws InternalErrorException if something happens in getting attributes from membersSource\n-\t */\n-\tprivate List<String> getOverwriteUserAttributesListFromExtSource(ExtSource membersSource) throws InternalErrorException {\n-\t\tMap<String, String> membersSourceAttributes = getPerunBl().getExtSourcesManagerBl().getAttributes(membersSource);\n-\t\tList<String> overwriteUserAttributesList = new ArrayList<>();\n-\t\tString overwriteUserAttributes = membersSourceAttributes.get(\"overwriteUserAttributes\");\n-\t\tif(overwriteUserAttributes != null && !overwriteUserAttributes.isEmpty()) {\n-\t\t\t//remove all white spaces and invisible characters\n-\t\t\toverwriteUserAttributes = overwriteUserAttributes.replaceAll(\"\\\\s\", \"\");\n-\t\t\toverwriteUserAttributesList = Arrays.asList(overwriteUserAttributes.split(\",\"));\n-\t\t}\n-\t\treturn overwriteUserAttributesList;\n-\t}\n-\n-\t/**\n-\t * Return true if attribute group:lightweightSynchronization is set to true.\n-\t * False if not.\n-\t *\n-\t * True means: we don't want to update existing members (attributes, statuses etc.), just\n-\t * add new members and remove former members\n-\t * False means: we want to do whole synchronization process including updating operations\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t *\n-\t * @return true if this is lightweightSynchronization, false if not\n-\t *\n-\t * @throws InternalErrorException if something happens while getting lightweightSynchronization attribute\n-\t * @throws WrongAttributeAssignmentException if bad assignment of lightweightSynchronization attribute\n-\t * @throws AttributeNotExistsException if lightweightSynchronization attribute not exists in perun Database\n-\t */\n-\tprivate boolean isThisLightweightSynchronization(PerunSession sess, Group group) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n-\t\tAttribute lightweightSynchronzationAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPLIGHTWEIGHTSYNCHRONIZATION_ATTRNAME);\n-\t\tboolean lightweightSynchronization = false;\n-\t\tif(lightweightSynchronzationAttr != null && lightweightSynchronzationAttr.getValue() != null) {\n-\t\t\tlightweightSynchronization = (Boolean) lightweightSynchronzationAttr.getValue();\n-\t\t}\n-\t\treturn lightweightSynchronization;\n-\t}\n-\n-\t/**\n-\t * Return List of subjects, where subject is map of attribute names and attribute values.\n-\t * Every subject is structure for creating Candidate from ExtSource.\n-\t *\n-\t * @param sess\n-\t * @param source to get subjects from\n-\t * @param group to be synchronized\n-\t *\n-\t * @return list of subjects\n-\t *\n-\t * @throws InternalErrorException if internal error occurs\n-\t */\n-\tprivate List<Map<String, String>> getSubjectsFromExtSource(PerunSession sess, ExtSource source, Group group) throws InternalErrorException {\n-\t\t//Get all group attributes and store tham to map (info like query, time interval etc.)\n-\t\tList<Attribute> groupAttributes = getPerunBl().getAttributesManagerBl().getAttributes(sess, group);\n-\t\tMap<String, String> groupAttributesMap = new HashMap<String, String>();\n-\t\tfor (Attribute attr: groupAttributes) {\n-\t\t\tString value = BeansUtils.attributeValueToString(attr);\n-\t\t\tString name = attr.getName();\n-\t\t\tgroupAttributesMap.put(name, value);\n-\t\t}\n-\t\t//-- Get Subjects in form of map where left string is name of attribute and right string is value of attribute, every subject is one map\n-\t\tList<Map<String, String>> subjects;\n-\t\ttry {\n-\t\t\tsubjects = ((ExtSourceSimpleApi) source).getGroupSubjects(groupAttributesMap);\n-\t\t\tlog.debug(\"Group synchronization {}: external group contains {} members.\", group, subjects.size());\n-\t\t} catch (ExtSourceUnsupportedOperationException e2) {\n-\t\t\tthrow new InternalErrorException(\"ExtSource \" + source.getName() + \" doesn't support getGroupSubjects\", e2);\n-\t\t}\n-\t\treturn subjects;\n-\t}\n-\n-\t/**\n-\t * Convert List of subjects to list of Candidates.\n-\t *\n-\t * To getting Candidate can use 1 of 3 possible options:\n-\t * 1] membersSource and source are not equals => we have just login, other attributes neet to get from membersSource\n-\t * 2] membersSource==source and membersSource is instance of ExtSourceApi => we already have all attributes in subject\n-\t * 3] membersSource==source and membersSource is instance of SimplExtSourceApi => we have just login, need to read other attributes again\n-\t *\n-\t * If candidate cannot be get for some reason, add this reason to skippedMembers list and skip him.\n-\t *\n-\t * @param sess\n-\t * @param subjects list of subjects from ExtSource (at least login should be here)\n-\t * @param membersSource optional member ExtSource (if members attributes are from other source then their logins)\n-\t * @param source default group ExtSource\n-\t * @param skippedMembers not successfully synchronized members are skipped and information about it should be added here\n-\t *\n-\t * @return list of successfully created candidates from subjects\n-\t *\n-\t * @throws InternalErrorException if some internal error occurs\n-\t * @throws ExtSourceNotExistsException if membersSource not exists in Perun\n-\t */\n-\tprivate List<Candidate> convertSubjectsToCandidates(PerunSession sess, List<Map<String, String>> subjects, ExtSource membersSource, ExtSource source, List<String> skippedMembers) throws InternalErrorException, ExtSourceNotExistsException {\n-\t\tList<Candidate> candidates = new ArrayList<>();\n-\t\tfor (Map<String, String> subject: subjects) {\n-\t\t\tString login = subject.get(\"login\");\n-\t\t\t// Skip subjects, which doesn't have login\n-\t\t\tif (login == null || login.isEmpty()) {\n-\t\t\t\tlog.debug(\"Subject {} doesn't contain attribute login, skipping.\", subject);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because login is missing\");\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\t// One of three possible ways should happen to get Candidate\n-\t\t\t\t// 1] sources of login and other attributes are not same\n-\t\t\t\tif(!membersSource.equals(source)) {\n-\t\t\t\t\t//need to read attributes from the new memberSource, we can't use locally data there (there are from other extSource)\n-\t\t\t\t\tcandidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, membersSource, login)));\n-\t\t\t\t// 2] sources are same and we work with source which is instance of ExtSourceApi\n-\t\t\t\t} else if (membersSource instanceof ExtSourceApi) {\n-\t\t\t\t\t// we can use the data from this source without reading them again (all exists in the map of subject attributes)\n-\t\t\t\t\tcandidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, subject, membersSource, login)));\n-\t\t\t\t// 3] sources are same and we work with source which is instace of ExtSourceSimpleApi\n-\t\t\t\t} else if (membersSource instanceof ExtSourceSimpleApi) {\n-\t\t\t\t\t// we can't use the data from this source, we need to read them again (they are not in the map of subject attributes)\n-\t\t\t\t\tcandidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, membersSource, login)));\n-\t\t\t\t} else {\n-\t\t\t\t\t// this could not happen without change in extSource API code\n-\t\t\t\t\tthrow new InternalErrorException(\"ExtSource is other instance than SimpleApi or Api and this is not supported!\");\n-\t\t\t\t}\n-\t\t\t} catch (CandidateNotExistsException e) {\n-\t\t\t\tlog.warn(\"getGroupSubjects subjects returned login {}, but it cannot be obtained using getCandidate()\", login);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because candidate can't be found by login:'\" + login + \"' in extSource \" + membersSource);\n-\t\t\t\tcontinue;\n-\t\t\t} catch (ExtSourceUnsupportedOperationException e) {\n-\t\t\t\tlog.warn(\"ExtSource {} doesn't support getCandidate operation.\", membersSource);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because extSource \" + membersSource + \" not support method getCandidate\");\n-\t\t\t\tcontinue;\n-\t\t\t} catch (ParserException e) {\n-\t\t\t\tlog.warn(\"Can't parse value {} from candidate with login {}\", e.getParsedValue(), login);\n-\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because of problem with parsing value '\" + e.getParsedValue() + \"'\");\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn candidates;\n-\t}\n-\n-\t/**\n-\t * Get Map membersToUpdate and update their attributes, extSources, expirations and statuses.\n-\t *\n-\t * For Member - updateAttributes\n-\t * For User - updateAttributes if exists in list of overwriteUserAttributesList,\n-\t *            in other case just mergeAttributes.\n-\t *\n-\t * updateAttributes = store new values\n-\t * mergeAttributes = for List and Map add new values, do not remove old one,\n-\t *                   for other cases store new values (like String, Integer etc.)\n-\t *\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t * @param membersToUpdate list of members for updating in Perun by information from extSource\n-\t * @param overwriteUserAttributesList list of user attributes to be updated instead of merged\n-\t *\n-\t * @throws InternalErrorException if some internal error occurs\n-\t * @throws AttributeNotExistsException if some attributes not exists and for this reason can't be updated\n-\t * @throws WrongAttributeAssignmentException if some attribute is updated in bad way (bad assignment)\n-\t */\n-\tprivate void updateExistingMembersWhileSynchronization(PerunSession sess, Group group, Map<Candidate, RichMember> membersToUpdate, List<String> overwriteUserAttributesList) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n-\t\tList<AttributeDefinition> attrDefs = new ArrayList<>();\n-\t\t//Iterate through all subject attributes\n-\t\tfor(Candidate candidate: membersToUpdate.keySet()) {\n-\t\t\tRichMember richMember = membersToUpdate.get(candidate);\n-\n-\t\t\t//If member not exists in this moment (somebody remove him before start of updating), skip him and log it\n-\t\t\ttry {\n-\t\t\t\tgetPerunBl().getMembersManagerBl().checkMemberExists(sess, richMember);\n-\t\t\t} catch (MemberNotExistsException ex) {\n-\t\t\t\t//log it and skip this member\n-\t\t\t\tlog.debug(\"Someone removed member {} from group {} before updating process. Skip him.\", richMember, group);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t//load attrDefinitions just once for first candidate\n-\t\t\tif(attrDefs.isEmpty()) {\n-\t\t\t\tfor(String attrName : candidate.getAttributes().keySet()) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tAttributeDefinition attrDef = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attrName);\n-\t\t\t\t\t\tattrDefs.add(attrDef);\n-\t\t\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\t\t\tlog.error(\"Can't synchronize attribute \" + attrName + \" for candidate \" + candidate + \" and for group \" + group);\n-\t\t\t\t\t\t//skip this attribute at all\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//get RichMember with attributes\n-\t\t\trichMember = getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, Arrays.asList(richMember), attrDefs).get(0);\n-\t\t\tfor (String attributeName : candidate.getAttributes().keySet()) {\n-\t\t\t\t//update member attribute\n-\t\t\t\tif(attributeName.startsWith(AttributesManager.NS_MEMBER_ATTR)) {\n-\t\t\t\t\tboolean attributeFound = false;\n-\t\t\t\t\tfor (Attribute memberAttribute: richMember.getMemberAttributes()) {\n-\t\t\t\t\t\tif(memberAttribute.getName().equals(attributeName)) {\n-\t\t\t\t\t\t\tattributeFound = true;\n-\t\t\t\t\t\t\tObject subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), memberAttribute.getType());\n-\t\t\t\t\t\t\tif (subjectAttributeValue != null && !memberAttribute.getValue().equals(subjectAttributeValue)) {\n-\t\t\t\t\t\t\t\tlog.trace(\"Group synchronization {}: value of the attribute {} for memberId {} changed. Original value {}, new value {}.\",\n-\t\t\t\t\t\t\t\t\t\tnew Object[] {group, memberAttribute, richMember.getId(), memberAttribute.getValue(), subjectAttributeValue});\n-\t\t\t\t\t\t\t\tmemberAttribute.setValue(subjectAttributeValue);\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember, memberAttribute);\n-\t\t\t\t\t\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t\t\t\t\t\t// There is a problem with attribute value, so set INVALID status for the member\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n-\t\t\t\t\t\t\t\t} catch\t(WrongAttributeAssignmentException e) {\n-\t\t\t\t\t\t\t\t\tthrow new ConsistencyErrorException(e);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t//we found it, but there is no change;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\t//member has not set this attribute so set it now if possible\n-\t\t\t\t\tif(!attributeFound) {\n-\t\t\t\t\t\tAttribute newAttribute = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attributeName));\n-\t\t\t\t\t\tObject subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), newAttribute.getType());\n-\t\t\t\t\t\tnewAttribute.setValue(subjectAttributeValue);\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// Try to set member's attributes\n-\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember, newAttribute);\n-\t\t\t\t\t\t\tlog.trace(\"Setting the {} value {}\", newAttribute, candidate.getAttributes().get(attributeName));\n-\t\t\t\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t\t\t\t// There is a problem with attribute value, so set INVALID status for the member\n-\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t//update user attribute\n-\t\t\t\t} else if(attributeName.startsWith(AttributesManager.NS_USER_ATTR)) {\n-\t\t\t\t\tboolean attributeFound = false;\n-\t\t\t\t\tfor (Attribute userAttribute: richMember.getUserAttributes()) {\n-\t\t\t\t\t\tif(userAttribute.getName().equals(attributeName)) {\n-\t\t\t\t\t\t\tattributeFound = true;\n-\t\t\t\t\t\t\tObject subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), userAttribute.getType());\n-\t\t\t\t\t\t\tif (!userAttribute.getValue().equals(subjectAttributeValue)) {\n-\t\t\t\t\t\t\t\tlog.trace(\"Group synchronization {}: value of the attribute {} for memberId {} changed. Original value {}, new value {}.\",\n-\t\t\t\t\t\t\t\t\t\tnew Object[] {group, userAttribute, richMember.getId(), userAttribute.getValue(), subjectAttributeValue});\n-\t\t\t\t\t\t\t\tuserAttribute.setValue(subjectAttributeValue);\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\t//Choose set or merge by extSource attribute overwriteUserAttributes (if contains this one)\n-\t\t\t\t\t\t\t\t\tif(overwriteUserAttributesList.contains(userAttribute.getName())) {\n-\t\t\t\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember.getUser(), userAttribute);\n-\t\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().mergeAttributeValueInNestedTransaction(sess, richMember.getUser(), userAttribute);\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t\t\t\t\t\t// There is a problem with attribute value, so set INVALID status for the member\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n-\t\t\t\t\t\t\t\t} catch (WrongAttributeAssignmentException e) {\n-\t\t\t\t\t\t\t\t\tthrow new ConsistencyErrorException(e);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t//we found it, but there is no change\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\t//user has not set this attribute so set it now if\n-\t\t\t\t\tif(!attributeFound) {\n-\t\t\t\t\t\tAttribute newAttribute = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attributeName));\n-\t\t\t\t\t\tObject subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), newAttribute.getType());\n-\t\t\t\t\t\tnewAttribute.setValue(subjectAttributeValue);\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// Try to set user's attributes\n-\t\t\t\t\t\t\tgetPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember.getUser(), newAttribute);\n-\t\t\t\t\t\t\tlog.trace(\"Setting the {} value {}\", newAttribute, candidate.getAttributes().get(attributeName));\n-\t\t\t\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t\t\t\t// There is a problem with attribute value, so set INVALID status for the member\n-\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t//we are not supporting other attributes then member or user so skip it without error, but log it\n-\t\t\t\t\tlog.error(\"Attribute {} can't be set, because it is not member or user attribute.\", attributeName);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//Synchronize userExtSources (add not existing)\n-\t\t\tfor (UserExtSource ues : candidate.getUserExtSources()) {\n-\t\t\t\tif (!getPerunBl().getUsersManagerBl().userExtSourceExists(sess, ues)) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getUsersManagerBl().addUserExtSource(sess, richMember.getUser(), ues);\n-\t\t\t\t\t} catch (UserExtSourceExistsException e) {\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(\"Adding already existing userExtSource \" + ues, e);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t//Set correct member Status\n-\t\t\t// If the member has expired or disabled status, try to expire/validate him (depending on expiration date)\n-\t\t\tif (richMember.getStatus().equals(Status.DISABLED) || richMember.getStatus().equals(Status.EXPIRED)) {\n-\t\t\t\tDate now = new Date();\n-\t\t\t\tAttribute membershipExpiration = getPerunBl().getAttributesManagerBl().getAttribute(sess, richMember, AttributesManager.NS_MEMBER_ATTR_DEF + \":membershipExpiration\");\n-\t\t\t\tif(membershipExpiration.getValue() != null) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tDate currentMembershipExpirationDate = BeansUtils.getDateFormatterWithoutTime().parse((String) membershipExpiration.getValue());\n-\t\t\t\t\t\tif (currentMembershipExpirationDate.before(now)) {\n-\t\t\t\t\t\t\t//disabled members which are after expiration date will be expired\n-\t\t\t\t\t\t\tif (richMember.getStatus().equals(Status.DISABLED)) {\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tperunBl.getMembersManagerBl().expireMember(sess, richMember);\n-\t\t\t\t\t\t\t\t\tlog.info(\"Switching member id {} to EXPIRE state, due to expiration {}.\", richMember.getId(), (String) membershipExpiration.getValue());\n-\t\t\t\t\t\t\t\t\tlog.debug(\"Switching member to EXPIRE state, additional info: membership expiration date='{}', system now date='{}'\", currentMembershipExpirationDate, now);\n-\t\t\t\t\t\t\t\t} catch (MemberNotValidYetException e) {\n-\t\t\t\t\t\t\t\t\tlog.error(\"Consistency error while trying to expire member id {}, exception {}\", richMember.getId(), e);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t//disabled and expired members which are before expiration date will be validated\n-\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\tperunBl.getMembersManagerBl().validateMember(sess, richMember);\n-\t\t\t\t\t\t\t\tlog.info(\"Switching member id {} to VALID state, due to expiration {}.\", richMember.getId(), (String) membershipExpiration.getValue());\n-\t\t\t\t\t\t\t\tlog.debug(\"Switching member to VALID state, additional info: membership expiration date='{}', system now date='{}'\", currentMembershipExpirationDate, now);\n-\t\t\t\t\t\t\t} catch (WrongAttributeValueException e) {\n-\t\t\t\t\t\t\t\tlog.error(\"Error during validating member id {}, exception {}\", richMember.getId(), e);\n-\t\t\t\t\t\t\t} catch (WrongReferenceAttributeValueException e) {\n-\t\t\t\t\t\t\t\tlog.error(\"Error during validating member id {}, exception {}\", richMember.getId(), e);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} catch (ParseException ex) {\n-\t\t\t\t\t\tlog.error(\"Group synchronization: memberId {} expiration String cannot be parsed, exception {}.\",richMember.getId(), ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// If the member has INVALID status, try to validate the member\n-\t\t\ttry {\n-\t\t\t\tif (richMember.getStatus().equals(Status.INVALID)) {\n-\t\t\t\t\tgetPerunBl().getMembersManagerBl().validateMember(sess, richMember);\n-\t\t\t\t}\n-\t\t\t} catch (WrongAttributeValueException e) {\n-\t\t\t\tlog.info(\"Member id {} will stay in INVALID state, because there was problem with attributes {}.\", richMember.getId(), e);\n-\t\t\t} catch (WrongReferenceAttributeValueException e) {\n-\t\t\t\tlog.info(\"Member id {} will stay in INVALID state, because there was problem with attributes {}.\", richMember.getId(), e);\n-\t\t\t}\n-\n-\t\t\t// If the member has still DISABLED status, try to validate the member\n-\t\t\ttry {\n-\t\t\t\tif (richMember.getStatus().equals(Status.DISABLED)) {\n-\t\t\t\t\tgetPerunBl().getMembersManagerBl().validateMember(sess, richMember);\n-\t\t\t\t}\n-\t\t\t} catch (WrongAttributeValueException e) {\n-\t\t\t\tlog.info(\"Switching member id {} into INVALID state from DISABLED, because there was problem with attributes {}.\", richMember.getId(), e);\n-\t\t\t} catch (WrongReferenceAttributeValueException e) {\n-\t\t\t\tlog.info(\"Switching member id {} into INVALID state from DISABLED, because there was problem with attributes {}.\", richMember.getId(), e);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get list of new candidates and add them to the Group.\n-\t *\n-\t * If Candidate can't be added to Group, skip him and add this information to skippedMembers list.\n-\t *\n-\t * When creating new member from Candidate, if user already exists, merge his attributes,\n-\t * if attribute exists in list of overwriteUserAttributesList, update it instead of merging.\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t * @param candidatesToAdd list of new members (candidates)\n-\t * @param overwriteUserAttributesList list of attributes to be updated for user if found\n-\t * @param skippedMembers list of not successfully synchronized members\n-\t *\n-\t * @throws InternalErrorException if some internal error occurs\n-\t */\n-\tprivate void addMissingMembersWhileSynchronization(PerunSession sess, Group group, List<Candidate> candidatesToAdd, List<String> overwriteUserAttributesList, List<String> skippedMembers) throws InternalErrorException, GroupOperationsException {\n-\t\t// Now add missing members\n-\t\tfor (Candidate candidate: candidatesToAdd) {\n-\t\t\tMember member = null;\n-\t\t\ttry {\n-\t\t\t\t// Check if the member is already in the VO (just not in the group)\n-\t\t\t\tmember = getPerunBl().getMembersManagerBl().getMemberByUserExtSources(sess, getPerunBl().getGroupsManagerBl().getVo(sess, group), candidate.getUserExtSources());\n-\n-\t\t\t\t// member exists - update attributes\n-\t\t\t\tMap<Candidate,RichMember> memberMap = new HashMap<>();\n-\t\t\t\tmemberMap.put(candidate, getPerunBl().getMembersManagerBl().getRichMember(sess, member));\n-\t\t\t\ttry {\n-\t\t\t\t\tupdateExistingMembersWhileSynchronization(sess, group, memberMap, overwriteUserAttributesList);\n-\t\t\t\t} catch (WrongAttributeAssignmentException | AttributeNotExistsException e) {\n-\t\t\t\t\t// if update fails, skip him\n-\t\t\t\t\tlog.warn(\"Can't update member from candidate {} due to attribute value exception {}.\", candidate, e);\n-\t\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because there was problem when updating member from candidate: Exception: \" + e.getName() + \" => '\" + e.getMessage() + \"'\");\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\n-\t\t\t} catch (MemberNotExistsException e) {\n-\t\t\t\ttry {\n-\t\t\t\t\t// We have new member (candidate), so create him using synchronous createMember (and overwrite chosed user attributes)\n-\t\t\t\t\tmember = getPerunBl().getMembersManagerBl().createMemberSync(sess, getPerunBl().getGroupsManagerBl().getVo(sess, group), candidate, null, overwriteUserAttributesList);\n-\t\t\t\t\tlog.info(\"Group synchronization {}: New member id {} created during synchronization.\", group, member.getId());\n-\t\t\t\t} catch (AlreadyMemberException e1) {\n-\t\t\t\t\tthrow new ConsistencyErrorException(\"Trying to add existing member\");\n-\t\t\t\t} catch (AttributeValueException e1) {\n-\t\t\t\t\tlog.warn(\"Can't create member from candidate {} due to attribute value exception {}.\", candidate, e1);\n-\t\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because there was problem when createing member from candidate: Exception: \" + e1.getName() + \" => '\" + e1.getMessage() + \"'\");\n-\t\t\t\t\tcontinue;\n-\t\t\t\t} catch (ExtendMembershipException ex) {\n-\t\t\t\t\tlog.warn(\"Can't create member from candidate {} due to membership expiration exception {}.\", candidate, ex);\n-\t\t\t\t\tskippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because membership expiration: Exception: \" + ex.getName() + \" => \" + ex.getMessage() + \"]\");\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\ttry {\n-\t\t\t\t// Add the member to the group\n-\t\t\t\tif (!group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\t\t\t// Do not add members to the generic members group\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().addMember(sess, group, member);\n-\t\t\t\t\t} catch(NotMemberOfParentGroupException | GroupNotExistsException ex) {\n-\t\t\t\t\t\t// Shouldn't happen, because every group has at least Members group as a parent\n-\t\t\t\t\t\t// Shouldn't happen, group should always exist\n-\t\t\t\t\t\tthrow new ConsistencyErrorException(ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tlog.info(\"Group synchronization {}: New member id {} added.\", group, member.getId());\n-\t\t\t} catch (AlreadyMemberException e) {\n-\t\t\t\t//This part is ok, it means someone add member before synchronization ends, log it and skip this member\n-\t\t\t\tlog.debug(\"Member {} was added to group {} before adding process. Skip this member.\", member, group);\n-\t\t\t\tcontinue;\n-\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\t// There is a problem with attribute value, so set INVALID status of the member\n-\t\t\t\tgetPerunBl().getMembersManagerBl().invalidateMember(sess, member);\n-\t\t\t}\n-\n-\t\t\t// Try to validate member\n-\t\t\ttry {\n-\t\t\t\tgetPerunBl().getMembersManagerBl().validateMember(sess, member);\n-\t\t\t} catch (AttributeValueException e) {\n-\t\t\t\tlog.warn(\"Member id {} will be in INVALID status due to wrong attributes {}.\", member.getId(), e);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Remove former members from group (if they are not listed in ExtSource yet).\n-\t *\n-\t * If this is membersGroup (of some Vo) try to disableMember, if not possible then delete him.\n-\t * If this is regular group (of some Vo) remove him and if this group is also\n-\t * his last authoritative group, disable or delete him also in the Vo.\n-\t *\n-\t * @param sess\n-\t * @param group to be synchronized\n-\t * @param membersToRemove list of members to be removed from Group\n-\t *\n-\t * @throws InternalErrorException if some internal error occurs\n-\t * @throws WrongAttributeAssignmentException if there is some problem with assignment of attribute\n-\t * @throws MemberAlreadyRemovedException if member is already out of group when we trying to do this by synchronization\n-\t */\n-\tprivate void removeFormerMembersWhileSynchronization(PerunSession sess, Group group, List<RichMember> membersToRemove) throws InternalErrorException, WrongAttributeAssignmentException, MemberAlreadyRemovedException, GroupOperationsException, GroupNotExistsException {\n-\t\t//First get information if this group is authoritative group\n-\t\tboolean thisGroupIsAuthoritativeGroup = false;\n-\t\ttry {\n-\t\t\tAttribute authoritativeGroupAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_D_AUTHORITATIVE_GROUP);\n-\t\t\tif(authoritativeGroupAttr.getValue() != null) {\n-\t\t\t\tInteger authoritativeGroupValue = (Integer) authoritativeGroupAttr.getValue();\n-\t\t\t\tif(authoritativeGroupValue == 1) thisGroupIsAuthoritativeGroup = true;\n-\t\t\t}\n-\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t//Means that this group is not authoritative\n-\t\t\tlog.error(\"Attribute {} doesn't exists.\", A_G_D_AUTHORITATIVE_GROUP);\n-\t\t}\n-\n-\t\t//Second remove members (use authoritative group where is needed)\n-\t\tfor (RichMember member: membersToRemove) {\n-\t\t\t// Member is missing in the external group, so remove him from the perun group\n-\t\t\ttry {\n-\t\t\t\t//members group\n-\t\t\t\tif (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\t\t\t// If the group is members group, the member must be disabled as a member of VO\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().disableMember(sess, member);\n-\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} disabled.\", group, member.getId());\n-\t\t\t\t\t} catch(MemberNotValidYetException ex) {\n-\t\t\t\t\t\t//Member is still invalid in perun. We can delete him.\n-\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().deleteMember(sess, member);\n-\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} would have been disabled but he has been deleted instead because he was invalid.\", group, member.getId());\n-\t\t\t\t\t}\n-\t\t\t\t\t//not members group\n-\t\t\t\t} else {\n-\t\t\t\t\t//If this group is authoritative group, check if this is last authoritative group of this member\n-\t\t\t\t\t//If Yes = deleteMember (from Vo), if No = only removeMember\n-\t\t\t\t\tif(thisGroupIsAuthoritativeGroup) {\n-\t\t\t\t\t\tList<Group> memberAuthoritativeGroups = null;\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tmemberAuthoritativeGroups = getAllAuthoritativeGroupsOfMember(sess, member);\n-\t\t\t\t\t\t} catch (AttributeNotExistsException ex) {\n-\t\t\t\t\t\t\t//This means that no authoritative group can exists without this attribute\n-\t\t\t\t\t\t\tlog.error(\"Attribute {} doesn't exists.\", A_G_D_AUTHORITATIVE_GROUP);\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t//If list of member authoritativeGroups is not null, attribute exists\n-\t\t\t\t\t\tif(memberAuthoritativeGroups != null) {\n-\t\t\t\t\t\t\tmemberAuthoritativeGroups.remove(group);\n-\t\t\t\t\t\t\tif(memberAuthoritativeGroups.isEmpty()) {\n-\t\t\t\t\t\t\t\t//First try to disable member, if is invalid, delete him from Vo\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().disableMember(sess, member);\n-\t\t\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} disabled because synchronizer wants to remove him from last authoritativeGroup in Vo.\", group, member.getId());\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n-\t\t\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n-\t\t\t\t\t\t\t\t} catch(MemberNotValidYetException ex) {\n-\t\t\t\t\t\t\t\t\t//Member is still invalid in perun. We can delete him.\n-\t\t\t\t\t\t\t\t\tgetPerunBl().getMembersManagerBl().deleteMember(sess, member);\n-\t\t\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} would have been disabled but he has been deleted instead because he was invalid and synchronizer wants to remove him from last authoritativeGroup in Vo.\", group, member.getId());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t//If there is still some other authoritative group for this member, only remove him from group\n-\t\t\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n-\t\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t//If list of member authoritativeGroups is null, attribute not exists, only remove member from Group\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n-\t\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tgetPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n-\t\t\t\t\t\tlog.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (NotGroupMemberException e) {\n-\t\t\t\tthrow new ConsistencyErrorException(\"Trying to remove non-existing user\");\n-\t\t\t} catch (MemberAlreadyRemovedException ex) {\n-\t\t\t\t//Member was probably removed before starting of synchronization removing process, log it and skip this member\n-\t\t\t\tlog.debug(\"Member {} was removed from group {} before removing process. Skip this member.\", member, group);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Try to close both extSources (membersSource and group source)\n-\t *\n-\t * @param membersSource optional membersSource\n-\t * @param source default groupSource\n-\t */\n-\tprivate void closeExtSourcesAfterSynchronization(ExtSource membersSource, ExtSource source) {\n-\t\t//Close open extSources (not empty ones) if they support this operation\n-\t\tif(membersSource != null) {\n-\t\t\ttry {\n-\t\t\t\t((ExtSourceSimpleApi) membersSource).close();\n-\t\t\t} catch (ExtSourceUnsupportedOperationException e) {\n-\t\t\t\t// ExtSource doesn't support that functionality, so silently skip it.\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.info(\"Can't close membersSource connection. Cause: {}\", e);\n-\t\t\t}\n-\t\t}\n-\t\tif(source != null) {\n-\t\t\ttry {\n-\t\t\t\t((ExtSourceSimpleApi) source).close();\n-\t\t\t} catch (ExtSourceUnsupportedOperationException e) {\n-\t\t\t\t// ExtSource doesn't support that functionality, so silently skip it.\n-\t\t\t} catch (InternalErrorException e) {\n-\t\t\t\tlog.info(\"Can't close extSource connection. Cause: {}\", e);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void processRelationMembers(PerunSession sess, Group resultGroup, List<Member> changedMembers, int sourceGroupId, boolean addition) throws GroupOperationsException {\n-\n-\t\tList<Member> newMembers;\n-\n-\t\ttry {\n-\t\t\tif (addition) {\n-\t\t\t\tnewMembers = addIndirectMembers(sess, resultGroup, changedMembers, sourceGroupId);\n-\t\t\t} else {\n-\t\t\t\tnewMembers = removeIndirectMembers(sess, resultGroup, changedMembers, sourceGroupId);\n-\t\t\t}\n-\n-\t\t\tif (newMembers.isEmpty()) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tList<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, resultGroup.getId());\n-\t\t\tfor (Integer groupId : relations) {\n-\t\t\t\tprocessRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), newMembers, resultGroup.getId(), addition);\n-\t\t\t}\n-\t\t} catch (WrongReferenceAttributeValueException | WrongAttributeValueException | AlreadyMemberException |\n-\t\t\t\tInternalErrorException | NotGroupMemberException | GroupNotExistsException ex) {\n-\t\t\tthrow new GroupOperationsException(ex);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Group createGroupUnion(PerunSession sess, Group resultGroup, Group operandGroup, boolean parentFlag) throws GroupOperationsException, InternalErrorException, GroupRelationAlreadyExists, GroupRelationNotAllowed {\n-\n-\t\t// block inclusion to members group, since it doesn't make sense\n-\t\t// allow inclusion of members group, since we want to delegate privileges on assigning all vo members to some service for group manager.\n-\t\tif(resultGroup.getName().equals(VosManager.MEMBERS_GROUP)) {\n-\t\t\tthrow new GroupRelationNotAllowed(\"Union cannot be created when result group \" + resultGroup + \" is members group.\");\n-\t\t}\n-\n-\t\t// check if both groups are from same VO\n-\t\tif (resultGroup.getVoId() != operandGroup.getVoId()) {\n-\t\t\tthrow new GroupRelationNotAllowed(\"Union cannot be created on groups: \" + resultGroup + \", \" + operandGroup + \". They are not from the same VO.\");\n-\t\t}\n-\n-\t\t// check if result group is the same as operand group\n-\t\tif (resultGroup.getId() == operandGroup.getId()) {\n-\t\t\tthrow new GroupRelationNotAllowed(\"Result group \" + resultGroup + \" cannot be the same as operand group \" + operandGroup);\n-\t\t} \n-\n-\t\t// check if there is already a record of these two groups\n-\t\tif (this.groupsManagerImpl.isRelationBetweenGroups(resultGroup, operandGroup)) {\n-\t\t\tthrow new GroupRelationAlreadyExists(\"There is already a relation defined between result group \" + resultGroup +\n-\t\t\t\t\t\" and operand group \" + operandGroup + \" or they are in hierarchical structure.\");\n-\t\t}\n-\n-\t\t// check cycle between groups\n-\t\tif (checkGroupsCycle(sess, resultGroup.getId(), operandGroup.getId())) {\n-\t\t\tthrow new GroupRelationNotAllowed(\"Union between result group \" + resultGroup + \" and operand group \" + operandGroup + \" would create group cycle.\");\n-\t\t}\n-\n-\t\t// save group relation\n-\t\tgroupsManagerImpl.saveGroupRelation(sess, resultGroup, operandGroup, parentFlag);\n-\n-\t\t// do the operation logic\n-\t\tprocessRelationMembers(sess, resultGroup, getGroupMembers(sess, operandGroup), operandGroup.getId(), true);\n-\n-\t\treturn resultGroup;\n-\t}\n-\n-\t@Override\n-\tpublic void removeGroupUnion(PerunSession sess, Group resultGroup, Group operandGroup, boolean parentFlag) throws GroupOperationsException, InternalErrorException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n-\t\tif (!groupsManagerImpl.isOneWayRelationBetweenGroups(resultGroup, operandGroup)) {\n-\t\t\tthrow new GroupRelationDoesNotExist(\"Union does not exist between result group \" + resultGroup + \" and operand group\" + operandGroup + \".\");\n-\t\t}\n-\n-\t\tif (parentFlag || groupsManagerImpl.isRelationRemovable(sess, resultGroup, operandGroup)) {\n-\t\t\tprocessRelationMembers(sess, resultGroup, getGroupMembers(sess, operandGroup), operandGroup.getId(), false);\n-\t\t} else {\n-\t\t\tthrow new GroupRelationCannotBeRemoved(\"Union between result group \" + resultGroup + \" and operand group\" + operandGroup +\n-\t\t\t\t\t\" cannot be removed, because it's part of the hierarchical structure of the groups.\");\n-\t\t}\n-\n-\t\tgroupsManagerImpl.removeGroupUnion(sess, resultGroup, operandGroup);\n-\t}\n-\n-\t@Override\n-\tpublic List<Group> getGroupUnions(PerunSession session, Group group, boolean reverseDirection) throws InternalErrorException {\n-\t\tif (reverseDirection) {\n-\t\t\treturn groupsManagerImpl.getResultGroups(session, group.getId());\n-\t\t} else {\n-\t\t\treturn groupsManagerImpl.getOperandGroups(session, group.getId());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Check if cycle would be created by adding union between these groups.\n-\t *\n-\t * @param sess perun session\n-\t * @param resultGroupId result group id\n-\t * @param operandGroupId operand group id\n-\t * @return true if cycle would be created; false otherwise\n-\t * @throws InternalErrorException\n-\t */\n-\tprivate boolean checkGroupsCycle(PerunSession sess, int resultGroupId, int operandGroupId) throws InternalErrorException {\n-\t\tList<Integer> groupsIds = groupsManagerImpl.getResultGroupsIds(sess, resultGroupId);\n-\n-\t\tif (groupsIds.contains(operandGroupId)) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tfor (Integer id: groupsIds) {\n-\t\t\tif(checkGroupsCycle(sess, id, operandGroupId)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-}\n+\n+ private final static Logger log = LoggerFactory.getLogger(GroupsManagerBlImpl.class);\n+ private final GroupsManagerImplApi groupsManagerImpl;\n+ private PerunBl perunBl;\n+ private Map<Integer, GroupSynchronizerThread> groupSynchronizerThreads;\n+ private static final String A_G_D_AUTHORITATIVE_GROUP = AttributesManager.NS_GROUP_ATTR_DEF + \":authoritativeGroup\";\n+\n+ /**\n+  * Create new instance of this class.\n+  *\n+  */\n+\n+\n+ public GroupsManagerBlImpl(GroupsManagerImplApi groupsManagerImpl) {\n+  this.groupsManagerImpl = groupsManagerImpl;\n+  this.groupSynchronizerThreads = new HashMap<Integer, GroupSynchronizerThread>();\n+ }\n+\n+ public Group createGroup(PerunSession sess, Vo vo, Group group) throws GroupExistsException, InternalErrorException {\n+  group = getGroupsManagerImpl().createGroup(sess, vo, group);\n+  getPerunBl().getAuditer().log(sess, \"{} created in {}.\", group, vo);\n+  group.setVoId(vo.getId());\n+\n+\n+  //set creator as group admin unless he already have authz right on the group (he is VO admin)\n+  User user = sess.getPerunPrincipal().getUser();\n+  if (user != null) {   //user can be null in tests\n+   if (!AuthzResolverBlImpl.isAuthorized(sess, Role.VOADMIN, vo)) {\n+    try {\n+     AuthzResolverBlImpl.setRole(sess, user, group, Role.GROUPADMIN);\n+    } catch (AlreadyAdminException e) {\n+     throw new ConsistencyErrorException(\"Newly created group already have an admin.\", e);\n+    }\n+   }\n+  }\n+\n+  return group;\n+ }\n+\n+ public Group createGroup(PerunSession sess, Group parentGroup, Group group) throws GroupExistsException, InternalErrorException, GroupOperationsException, GroupRelationNotAllowed, GroupRelationAlreadyExists {\n+  Vo vo = this.getVo(sess, parentGroup);\n+  group = getGroupsManagerImpl().createGroup(sess, vo, parentGroup, group);\n+  parentGroup = createGroupUnion(sess, parentGroup, group, true);\n+  getPerunBl().getAuditer().log(sess, \"{} created in {} as subgroup of {}\", group, vo, parentGroup);\n+  return group;\n+ }\n+\n+ public void deleteGroup(PerunSession sess, Group group, boolean forceDelete) throws InternalErrorException, RelationExistsException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+  if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+   throw new java.lang.IllegalArgumentException(\"Built-in \" + group.getName() + \" group cannot be deleted separately.\");\n+  }\n+\n+  this.deleteAnyGroup(sess, group, forceDelete);\n+ }\n+\n+ public void deleteGroups(PerunSession perunSession, List<Group> groups, boolean forceDelete) throws InternalErrorException, GroupAlreadyRemovedException, RelationExistsException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+  //Use sorting by group names reverse order (first name A:B:c then A:B etc.)\n+  Collections.sort(groups, Collections.reverseOrder(new Comparator<Group>() {\n+                            @Override\n+                            public int compare(Group groupToCompare, Group groupToCompareWith) {\n+                             return groupToCompare.getName().compareTo(groupToCompareWith.getName());\n+                            }\n+                           }));\n+  for (Group group : groups) {\n+   this.deleteGroup(perunSession, group, forceDelete);\n+  }\n+ }\n+\n+ public void deleteMembersGroup(PerunSession sess, Vo vo) throws InternalErrorException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+  Group group;\n+  try {\n+   group = getGroupByName(sess, vo, VosManager.MEMBERS_GROUP);\n+  } catch (GroupNotExistsException e) {\n+   throw new ConsistencyErrorException(\"Built-in members group must exists.\", e);\n+  }\n+\n+  try {\n+   this.deleteAnyGroup(sess, group, true);\n+  } catch (RelationExistsException e) {\n+   throw new ConsistencyErrorException(\"Built-in members group cannot have any relation in this stage.\", e);\n+  }\n+ }\n+\n+ /**\n+  * If forceDelete is false, delete only group which has no subgroup and no member.\n+  * If forceDelete is true, delete group with all subgroups and members.\n+  *\n+  * @param sess\n+  * @param group\n+  * @param forceDelete if false, delete only empty group without subgroups. If true, delete group including subgroups and members.\n+  * @throws InternalErrorException\n+  * @throws RelationExistsException Raise only if forceDelete is false and the group has any subgroup or member.\n+  * @throws GroupAlreadyRemovedException if there are 0 rows affected by deleting from DB\n+  */\n+\n+ protected void deleteAnyGroup(PerunSession sess, Group group, boolean forceDelete) throws InternalErrorException, RelationExistsException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupNotExistsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+  Vo vo = this.getVo(sess, group);\n+  if (getGroupsManagerImpl().getSubGroupsCount(sess, group) > 0) {\n+   if (!forceDelete) throw new RelationExistsException(\"Group group=\" + group + \" contains subgroups\");\n+\n+   // make sure we delete all subgroups !!\n+   List<Group> subGroups = getAllSubGroups(sess, group);\n+\n+   // Use sorting by group names reverse order (first A:B:c then A:B etc.)\n+   // to make sure we delete from the bottom in a hierarchy\n+   Collections.sort(subGroups, Collections.reverseOrder(new Comparator<Group>() {\n+                                @Override\n+                                public int compare(Group groupToCompare, Group groupToCompareWith) {\n+                                 return groupToCompare.getName().compareTo(groupToCompareWith.getName());\n+                                }\n+                               }));\n+   for (Group g : subGroups) {\n+    //For auditer\n+    List<Resource> subGroupResources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, g);\n+    for (Resource resource : subGroupResources) {\n+     try {\n+      getPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, g, resource);\n+     } catch (GroupNotDefinedOnResourceException ex) {\n+      throw new ConsistencyErrorException(ex);\n+     }\n+    }\n+\n+    //remove subgroups' attributes\n+\n+    try {\n+     getPerunBl().getAttributesManagerBl().removeAllAttributes(sess, g);\n+    } catch (AttributeValueException ex) {\n+     throw new ConsistencyErrorException(\"All resources was removed from this group. So all attributes values can be removed.\", ex);\n+    }\n+\n+    // delete all sub-groups reserved logins from KDC\n+    List<Integer> list = getGroupsManagerImpl().getGroupApplicationIds(sess, group);\n+    for (Integer appId : list) {\n+     // for each application\n+\n+     for (Pair<String, String> login : getGroupsManagerImpl().getApplicationReservedLogins(appId)) {\n+      // for all reserved logins - delete them in ext. system (e.g. KDC)\n+      try {\n+       // left = namespace / right = login\n+       getPerunBl().getUsersManagerBl().deletePassword(sess, login.getRight(), login.getLeft());\n+      } catch (LoginNotExistsException ex) {\n+       log.error(\"Login: {} not exists in namespace: {} while deleting passwords.\", login.getRight(), login.getLeft());\n+      } catch (PasswordDeletionFailedException | PasswordOperationTimeoutException ex) {\n+       throw new InternalErrorException(\"Failed to delete reserved login \" + login.getRight() + \" from KDC.\", ex);\n+      }\n+     }\n+    }\n+    // delete all Groups reserved logins from DB\n+    getGroupsManagerImpl().deleteGroupReservedLogins(sess, group);\n+\n+    //Remove all information about group on facilities (facilities contacts)\n+    List<ContactGroup> groupContactGroups = getPerunBl().getFacilitiesManagerBl().getFacilityContactGroups(sess, group);\n+    if (!groupContactGroups.isEmpty()) {\n+     getPerunBl().getFacilitiesManagerBl().removeAllGroupContacts(sess, group);\n+    }\n+\n+    //remove all assigned ExtSources to this group\n+    List<ExtSource> assignedSources = getPerunBl().getExtSourcesManagerBl().getGroupExtSources(sess, group);\n+    for (ExtSource source : assignedSources) {\n+     try {\n+      getPerunBl().getExtSourcesManagerBl().removeExtSource(sess, group, source);\n+     } catch (ExtSourceNotAssignedException | ExtSourceAlreadyRemovedException ex) {\n+      //Just log this, because if method can't remove it, it is probably not assigned now\n+      log.error(\"Try to remove not existing extSource {} from group {} when deleting group.\", source, group);\n+     }\n+    }\n+\n+    // 1. remove all relations with group g as an operand group.\n+    // this removes all relations that depend on this group\n+    List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, g.getId());\n+    for (Integer groupId : relations) {\n+     removeGroupUnion(sess, groupsManagerImpl.getGroupById(sess, groupId), g, true);\n+    }\n+\n+    // 2. remove all relations with group as a result group\n+    // We can remove relations without recalculation (@see processRelationMembers)\n+    // because all dependencies of group were deleted in step 1.\n+    groupsManagerImpl.removeResultGroupRelations(sess, g);\n+\n+    // Group applications, submitted data and app_form are deleted on cascade with \"deleteGroup()\"\n+    List<Member> membersFromDeletedGroup = getGroupMembers(sess, g);\n+    // Deletes also all direct and indirect members of the group\n+    getGroupsManagerImpl().deleteGroup(sess, vo, g);\n+    logTotallyRemovedMembers(sess, g.getParentGroupId(), membersFromDeletedGroup);\n+    getPerunBl().getAuditer().log(sess, \"{} deleted.\", g);\n+   }\n+  }\n+  if ((this.getGroupMembersCount(sess, group) > 0) && !forceDelete) {\n+   throw new RelationExistsException(\"Group group=\" + group + \" contains members\");\n+  }\n+  List<Resource> assignedResources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+  try {\n+\n+   for (Resource resource : assignedResources) {\n+    getPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, group, resource);\n+   }\n+   //remove group's attributes\n+   getPerunBl().getAttributesManagerBl().removeAllAttributes(sess, group);\n+  } catch (GroupNotDefinedOnResourceException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  } catch (AttributeValueException ex) {\n+   throw new ConsistencyErrorException(\"All resources was removed from this group, so no attributes should remain assigned.\", ex);\n+  }\n+\n+  // delete all Groups reserved logins from KDC\n+  List<Integer> list = getGroupsManagerImpl().getGroupApplicationIds(sess, group);\n+  for (Integer appId : list) {\n+   // for each application\n+\n+   for (Pair<String, String> login : getGroupsManagerImpl().getApplicationReservedLogins(appId)) {\n+    // for all reserved logins - delete them in ext. system (e.g. KDC)\n+    try {\n+     // left = namespace / right = login\n+     getPerunBl().getUsersManagerBl().deletePassword(sess, login.getRight(), login.getLeft());\n+    } catch (LoginNotExistsException ex) {\n+     log.error(\"Login: {} not exists in namespace: {} while deleting passwords.\", login.getRight(), login.getLeft());\n+    } catch (PasswordDeletionFailedException | PasswordOperationTimeoutException ex) {\n+     throw new InternalErrorException(\"Failed to delete reserved login \" + login.getRight() + \" from KDC.\", ex);\n+    }\n+   }\n+  }\n+  // delete all Groups reserved logins from DB\n+  getGroupsManagerImpl().deleteGroupReservedLogins(sess, group);\n+\n+  //Remove all information about group on facilities (facilities contacts)\n+  List<ContactGroup> groupContactGroups = getPerunBl().getFacilitiesManagerBl().getFacilityContactGroups(sess, group);\n+  if (!groupContactGroups.isEmpty()) {\n+   if (forceDelete) {\n+    getPerunBl().getFacilitiesManagerBl().removeAllGroupContacts(sess, group);\n+   } else {\n+    throw new RelationExistsException(\"Group has still some facilities contacts: \" + groupContactGroups);\n+   }\n+  }\n+\n+  //remove all assigned ExtSources to this group\n+  List<ExtSource> assignedSources = getPerunBl().getExtSourcesManagerBl().getGroupExtSources(sess, group);\n+  for (ExtSource source : assignedSources) {\n+   try {\n+    getPerunBl().getExtSourcesManagerBl().removeExtSource(sess, group, source);\n+   } catch (ExtSourceNotAssignedException | ExtSourceAlreadyRemovedException ex) {\n+    //Just log this, because if method can't remove it, it is probably not assigned now\n+    log.error(\"Try to remove not existing extSource {} from group {} when deleting group.\", source, group);\n+   }\n+  }\n+\n+  // 1. remove all relations with group g as an operand group.\n+  // this removes all relations that depend on this group\n+  List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n+  for (Integer groupId : relations) {\n+   removeGroupUnion(sess, groupsManagerImpl.getGroupById(sess, groupId), group, true);\n+  }\n+\n+  // 2. remove all relations with group as a result group\n+  // We can remove relations without recalculation (@see processRelationMembers)\n+  // because all dependencies of group were deleted in step 1.\n+  groupsManagerImpl.removeResultGroupRelations(sess, group);\n+\n+  // Group applications, submitted data and app_form are deleted on cascade with \"deleteGroup()\"\n+  List<Member> membersFromDeletedGroup = getGroupMembers(sess, group);\n+  // Deletes also all direct and indirect members of the group\n+  getGroupsManagerImpl().deleteGroup(sess, vo, group);\n+  logTotallyRemovedMembers(sess, group.getParentGroupId(), membersFromDeletedGroup);\n+  getPerunBl().getAuditer().log(sess, \"{} deleted.\", group);\n+ }\n+\n+ /**\n+  * Log members that were deleted from parent group totally to auditer.\n+  *\n+  * @param sess perun session\n+  * @param parentGroupId group id\n+  * @param membersFromDeletedGroup deleted members from child group\n+  * @throws InternalErrorException\n+  */\n+\n+\n+ private void logTotallyRemovedMembers(PerunSession sess, Integer parentGroupId, List<Member> membersFromDeletedGroup) throws InternalErrorException {\n+  while (parentGroupId != null) {\n+   Group parentGroup;\n+   try {\n+    parentGroup = getGroupById(sess, parentGroupId);\n+   } catch (GroupNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+   // getting members from parent group AFTER the indirect members from subgroup were removed from this group.\n+   List<Member> membersFromParentGroup = getGroupMembers(sess, parentGroup);\n+   // removeAll will remove all members which remains in parent group even after they removal of INDIRECT records.\n+   membersFromDeletedGroup.removeAll(membersFromParentGroup);\n+   // now all members which left in membersFromDeletedGroup list are totally removed members from this group,\n+   // so we need to log them to auditer\n+   for (Member m : membersFromDeletedGroup) {\n+    getPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", m, parentGroup);\n+   }\n+   parentGroupId = parentGroup.getParentGroupId();\n+  }\n+ }\n+\n+ public void deleteAllGroups(PerunSession sess, Vo vo) throws InternalErrorException, GroupAlreadyRemovedException, GroupAlreadyRemovedFromResourceException, GroupOperationsException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+\n+  for (Group group : getGroupsManagerImpl().getGroups(sess, vo)) {\n+   if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+    // Do not delete built-in groups, they must be deleted using separate functions deleteMembersGroup\n+    continue;\n+   }\n+   List<Resource> assignedResources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+   try {\n+\n+    for (Resource resource : assignedResources) {\n+     getPerunBl().getResourcesManagerBl().removeGroupFromResource(sess, group, resource);\n+     getPerunBl().getAttributesManagerBl().removeAllAttributes(sess, resource, group);\n+    }\n+    //remove group's attributes\n+    getPerunBl().getAttributesManagerBl().removeAllAttributes(sess, group);\n+   } catch (GroupNotDefinedOnResourceException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   } catch (AttributeValueException ex) {\n+    throw new ConsistencyErrorException(\"All resources was removed from this group. So all attributes values can be removed.\", ex);\n+   } catch (WrongAttributeAssignmentException ex) {\n+    throw new InternalErrorException(ex);\n+   }\n+\n+   try {\n+    this.deleteGroup(sess, group, true);\n+   } catch (RelationExistsException | GroupNotExistsException e) {\n+    throw new ConsistencyErrorException(e);\n+   }\n+  }\n+  getPerunBl().getAuditer().log(sess, \"All group in {} deleted.\", vo);\n+ }\n+\n+ public Group updateGroup(PerunSession sess, Group group) throws InternalErrorException {\n+\n+  // return group with correct updated name and shortName\n+  group = getGroupsManagerImpl().updateGroup(sess, group);\n+  getPerunBl().getAuditer().log(sess, \"{} updated.\", group);\n+  List<Group> allSubgroups = this.getAllSubGroups(sess, group);\n+  String[] groupNames = group.getName().split(\":\");\n+  for (Group g : allSubgroups) {\n+   String[] subGroupNames = g.getName().split(\":\");\n+   for (int i = 0; i<groupNames.length; i++) {\n+    if (!subGroupNames[i].equals(groupNames[i])) {\n+     // this part of name changed\n+     subGroupNames[i] = groupNames[i];\n+    }\n+   }\n+   // create new name\n+   StringBuilder sb = new StringBuilder();\n+   for (String sgName : subGroupNames) {\n+    sb.append(sgName).append(\":\");\n+   }\n+   // set name without last \":\"\n+   g.setName(sb.toString().substring(0, sb.length()-1));\n+   // for subgroups we must update whole name\n+   getGroupsManagerImpl().updateGroupName(sess, g);\n+   // create auditer message for every updated group\n+   getPerunBl().getAuditer().log(sess, \"{} updated.\", g);\n+  }\n+\n+  return group;\n+ }\n+\n+ public Group getGroupById(PerunSession sess, int id) throws InternalErrorException, GroupNotExistsException {\n+  return getGroupsManagerImpl().getGroupById(sess, id);\n+ }\n+\n+ public List<Group> getGroupsToSynchronize(PerunSession sess) throws InternalErrorException {\n+  return getGroupsManagerImpl().getGroupsToSynchronize(sess);\n+ }\n+\n+ public Group getGroupByName(PerunSession sess, Vo vo, String name) throws InternalErrorException, GroupNotExistsException {\n+  return getGroupsManagerImpl().getGroupByName(sess, vo, name);\n+ }\n+\n+ public void addMemberToMembersGroup(PerunSession sess, Group group, Member member) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, NotMemberOfParentGroupException, GroupNotExistsException, GroupOperationsException {\n+  // Check if the group IS memebers or administrators group\n+  if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+   this.addDirectMember(sess, group, member);\n+  } else {\n+   throw new InternalErrorException(\"This method must be called only from methods VosManager.addAdmin and MembersManager.createMember.\");\n+  }\n+ }\n+\n+ public void addMember(PerunSession sess, Group group, Member member) throws InternalErrorException, WrongReferenceAttributeValueException, GroupOperationsException, AlreadyMemberException, WrongAttributeValueException, GroupNotExistsException {\n+  // Check if the group is NOT members or administrators group\n+  if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+   throw new InternalErrorException(\"Cannot add member directly to the members group.\");\n+  } else {\n+   this.addDirectMember(sess, group, member);\n+  }\n+ }\n+\n+\n+ private List<Group> getParentGroups(PerunSession sess, Group group) throws InternalErrorException {\n+  if (group == null)\n+   return new ArrayList<Group>();\n+\n+  try {\n+   if (group.getParentGroupId() == null)\n+    return new ArrayList<Group>();\n+   List<Group> groups = getParentGroups(sess, getGroupById(sess, group.getParentGroupId()));\n+   groups.add(getGroupById(sess, group.getParentGroupId()));\n+   return groups;\n+  } catch (GroupNotExistsException ex) {\n+   throw new ConsistencyErrorException(ex);\n+  }\n+ }\n+\n+ /**\n+  * Add a record of the member with a DIRECT membership type to the group.\n+  *\n+  * @param sess perun session\n+  * @param group group to add member to\n+  * @param member member to be added as DIRECT\n+  * @throws InternalErrorException\n+  * @throws AlreadyMemberException\n+  * @throws WrongAttributeValueException\n+  * @throws WrongReferenceAttributeValueException\n+  * @throws GroupNotExistsException\n+  * @throws GroupOperationsException\n+  */\n+\n+ protected void addDirectMember(PerunSession sess, Group group, Member member) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, GroupNotExistsException, GroupOperationsException {\n+  if (this.groupsManagerImpl.isDirectGroupMember(sess, group, member)) throw new AlreadyMemberException(member);\n+\n+  boolean memberWasIndirectInGroup = this.isGroupMember(sess, group, member);\n+  member = getGroupsManagerImpl().addMember(sess, group, member, MembershipType.DIRECT, group.getId());\n+  getPerunBl().getAuditer().log(sess, \"{} added to {}.\", member, group);\n+\n+  //If member was indirect in group before, we don't need to change anything in other groups\n+  if (memberWasIndirectInGroup)\n+   return;\n+  // check all relations with this group and call processRelationMembers to reflect changes of adding member to group\n+  List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n+  for (Integer groupId : relations) {\n+   processRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), Collections.singletonList(member), group.getId(), true);\n+  }\n+  setRequiredAttributes(sess, member, group);\n+ }\n+\n+ /**\n+  * Add records of the members with an INDIRECT membership type to the group.\n+  *\n+  * @param sess perun session\n+  * @param group group to add members to\n+  * @param members list of members to add as INDIRECT\n+  * @param sourceGroupId id of a group from which members originate\n+  * @return list of members that were not members already\n+  * @throws InternalErrorException\n+  * @throws AlreadyMemberException\n+  * @throws WrongAttributeValueException\n+  * @throws WrongReferenceAttributeValueException\n+  */\n+\n+ protected List<Member> addIndirectMembers(PerunSession sess, Group group, List<Member> members, int sourceGroupId) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n+  // save list of old group members\n+  List<Member> oldMembers = this.getGroupMembers(sess, group);\n+  for (Member member : members) {\n+   groupsManagerImpl.addMember(sess, group, member, MembershipType.INDIRECT, sourceGroupId);\n+  }\n+\n+  // get list of new members\n+  List<Member> newMembers = this.getGroupMembers(sess, group);\n+  // select only newly added members\n+  newMembers.removeAll(oldMembers);\n+  for (Member member : newMembers) {\n+   setRequiredAttributes(sess, member, group);\n+   getPerunBl().getAuditer().log(sess, \"{} added to {}.\", member, group);\n+  }\n+\n+  return newMembers;\n+ }\n+\n+ /**\n+  * Set required attributes when adding new direct or indirect members.\n+  * @param sess perun session\n+  * @param member member\n+  * @param group group\n+  * @throws InternalErrorException\n+  * @throws WrongAttributeValueException\n+  * @throws WrongReferenceAttributeValueException\n+  */\n+\n+\n+ private void setRequiredAttributes(PerunSession sess, Member member, Group group) throws InternalErrorException, WrongAttributeValueException, WrongReferenceAttributeValueException {\n+  // setting required attributes\n+  User user = getPerunBl().getUsersManagerBl().getUserByMember(sess, member);\n+  List<Resource> resources = getPerunBl().getResourcesManagerBl().getAssignedResources(sess, group);\n+  for (Resource resource : resources) {\n+   Facility facility = getPerunBl().getResourcesManagerBl().getFacility(sess, resource);\n+   // check members attributes\n+   try {\n+    getPerunBl().getAttributesManagerBl().setRequiredAttributes(sess, facility, resource, user, member);\n+   } catch (WrongAttributeAssignmentException | AttributeNotExistsException ex) {\n+    throw new ConsistencyErrorException(ex);\n+   }\n+  }\n+ }\n+\n+ /**\n+  * Remove records of the members with an INDIRECT membership type from the group.\n+  *\n+  * @param sess perun session\n+  * @param group group to remove records of INDIRECT members from\n+  * @param members list of members to remove\n+  * @param sourceGroupId id of a group from which members originate\n+  * @return list of members that were removed (their only record in the group was deleted)\n+  * @throws InternalErrorException\n+  * @throws AlreadyMemberException\n+  * @throws WrongAttributeValueException\n+  * @throws WrongReferenceAttributeValueException\n+  * @throws NotGroupMemberException\n+  */\n+\n+ protected List<Member> removeIndirectMembers(PerunSession sess, Group group, List<Member> members, int sourceGroupId) throws InternalErrorException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, NotGroupMemberException {\n+  // save list of old group members\n+  List<Member> oldMembers = this.getGroupMembers(sess, group);\n+  for (Member member : members) {\n+   member.setSourceGroupId(sourceGroupId);\n+   groupsManagerImpl.removeMember(sess, group, member);\n+  }\n+\n+  // get list of new members\n+  List<Member> newMembers = this.getGroupMembers(sess, group);\n+  // get only removed members\n+  oldMembers.removeAll(newMembers);\n+  for (Member removedIndirectMember : oldMembers) {\n+   getPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", removedIndirectMember, group);\n+  }\n+\n+  return oldMembers;\n+ }\n+\n+ public void removeMember(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n+  // Check if the group is NOT members or administrators group\n+  if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+   throw new InternalErrorException(\"Cannot remove member directly from the members group.\");\n+  } else {\n+   this.removeDirectMember(sess, group, member);\n+  }\n+ }\n+\n+ public void removeMemberFromMembersOrAdministratorsGroup(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n+  // Check if the group IS memebers or administrators group\n+  if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+   this.removeDirectMember(sess, group, member);\n+  } else {\n+   throw new InternalErrorException(\"This method must be called only from methods VosManager.removeAdmin and MembersManager.deleteMember.\");\n+  }\n+ }\n+\n+ protected void removeDirectMember(PerunSession sess, Group group, Member member) throws InternalErrorException, NotGroupMemberException, GroupNotExistsException, GroupOperationsException {\n+  member.setSourceGroupId(group.getId());\n+  getGroupsManagerImpl().removeMember(sess, group, member);\n+  if (this.getGroupsManagerImpl().isGroupMember(sess, group, member)) {\n+   getPerunBl().getAuditer().log(sess, \"{} was removed from {}.\", member, group);\n+   //If member was indirect in group before, we don't need to change anything in other groups\n+   return;\n+  } else {\n+   getPerunBl().getAuditer().log(sess, \"{} was removed from {} totally.\", member, group);\n+  }\n+\n+  // check all relations with this group and call processRelationMembers to reflect changes of removing member from group\n+  List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, group.getId());\n+  for (Integer groupId : relations) {\n+   processRelationMembers(sess,\n+    groupsManagerImpl.getGroupById(sess, groupId),\n+     Collections.singletonList(member),\n+      group.getId(), false);\n+  }\n+ }\n+\n+ public List<Member> getGroupMembers(PerunSession sess, Group group) throws InternalErrorException {\n+  return this.filterMembersByMembershipTypeInGroup(getGroupsManagerImpl().getGroupMembers(sess, group));\n+ }\n+\n+ public List<Member> getGroupMembers(PerunSession sess, Group group, Status status) throws InternalErrorException {\n+  if (status == null) {\n+   return this.getGroupMembers(sess, group);\n+  }\n+\n+  return this.filterMembersByMembershipTypeInGroup(getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(status), false));\n+ }\n+\n+ @Override\n+ public List<User> getGroupUsers(PerunSession perunSession, Group group) throws InternalErrorException {\n+  return new ArrayList<User>(new HashSet<User>(getGroupsManagerImpl().getGroupUsers(perunSession, group)));\n+ }\n+\n+ public List<Member> getGroupMembersExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n+  return getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(Status.INVALID), true);\n+ }\n+\n+ public List<Member> getGroupMembersExceptInvalidAndDisabled(PerunSession sess, Group group) throws InternalErrorException {\n+  return getGroupsManagerImpl().getGroupMembers(sess, group, Arrays.asList(Status.INVALID, Status.DISABLED), true);\n+ }\n+\n+ public List<RichMember> getGroupRichMembers(PerunSession sess, Group group) throws InternalErrorException {\n+  return this.getGroupRichMembers(sess, group, null);\n+ }\n+\n+ public List<RichMember> getGroupRichMembersExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n+  List<Member> members = this.getGroupMembersExceptInvalid(sess, group);\n+  return getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n+ }\n+\n+ public List<RichMember> getGroupRichMembers(PerunSession sess, Group group, Status status) throws InternalErrorException {\n+  List<Member> members = this.getGroupMembers(sess, group, status);\n+  return getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n+ }\n+\n+ public List<RichMember> getGroupRichMembersWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n+  return this.getGroupRichMembersWithAttributes(sess, group, null);\n+ }\n+\n+ public List<RichMember> getGroupRichMembersWithAttributesExceptInvalid(PerunSession sess, Group group) throws InternalErrorException {\n+  List<RichMember> richMembers = this.getGroupRichMembersExceptInvalid(sess, group);\n+  return getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n+ }\n+\n+ public List<RichMember> getGroupRichMembersWithAttributes(PerunSession sess, Group group, Status status) throws InternalErrorException {\n+  List<RichMember> richMembers = this.getGroupRichMembers(sess, group, status);\n+  return getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n+ }\n+\n+ public int getGroupMembersCount(PerunSession sess, Group group) throws InternalErrorException {\n+  List<Member> members = this.getGroupMembers(sess, group);\n+  return members.size();\n+ }\n+\n+ public void addAdmin(PerunSession sess, Group group, User user) throws InternalErrorException, AlreadyAdminException {\n+  AuthzResolverBlImpl.setRole(sess, user, group, Role.GROUPADMIN);\n+  getPerunBl().getAuditer().log(sess, \"{} was added as admin of {}.\", user, group);\n+ }\n+\n+ @Override\n+ public void addAdmin(PerunSession sess, Group group, Group authorizedGroup) throws InternalErrorException, AlreadyAdminException {\n+  List<Group> listOfAdmins = getAdminGroups(sess, group);\n+  if (listOfAdmins.contains(authorizedGroup)) throw new AlreadyAdminException(authorizedGroup);\n+  AuthzResolverBlImpl.setRole(sess, authorizedGroup, group, Role.GROUPADMIN);\n+  getPerunBl().getAuditer().log(sess, \"Group {} was added as admin of {}.\", authorizedGroup, group);\n+ }\n+\n+ public void removeAdmin(PerunSession sess, Group group, User user) throws InternalErrorException, UserNotAdminException {\n+  AuthzResolverBlImpl.unsetRole(sess, user, group, Role.GROUPADMIN);\n+  getPerunBl().getAuditer().log(sess, \"{} was removed from admins of {}.\", user, group);\n+ }\n+\n+ @Override\n+ public void removeAdmin(PerunSession sess, Group group, Group authorizedGroup) throws InternalErrorException, GroupNotAdminException {\n+  List<Group> listOfAdmins = getAdminGroups(sess, group);\n+  if (!listOfAdmins.contains(authorizedGroup)) throw new GroupNotAdminException(authorizedGroup);\n+  AuthzResolverBlImpl.unsetRole(sess, authorizedGroup, group, Role.GROUPADMIN);\n+  getPerunBl().getAuditer().log(sess, \"Group {} was removed from admins of {}.\", authorizedGroup, group);\n+ }\n+\n+ public List<User> getAdmins(PerunSession perunSession, Group group, boolean onlyDirectAdmins) throws InternalErrorException {\n+  if (onlyDirectAdmins) {\n+   return getGroupsManagerImpl().getDirectAdmins(perunSession, group);\n+  } else {\n+   return getGroupsManagerImpl().getAdmins(perunSession, group);\n+  }\n+ }\n+\n+ public List<RichUser> getRichAdmins(PerunSession perunSession, Group group, List<String> specificAttributes, boolean allUserAttributes, boolean onlyDirectAdmins) throws InternalErrorException, UserNotExistsException {\n+  List<User> users = this.getAdmins(perunSession, group, onlyDirectAdmins);\n+  List<RichUser> richUsers;\n+  if (allUserAttributes) {\n+   richUsers = perunBl.getUsersManagerBl().getRichUsersWithAttributesFromListOfUsers(perunSession, users);\n+  } else {\n+   try {\n+    richUsers = getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n+   } catch (AttributeNotExistsException ex) {\n+    throw new InternalErrorException(\"One of Attribute not exist.\", ex);\n+   }\n+  }\n+\n+  return richUsers;\n+ }\n+\n+ @Deprecated\n+ public List<User> getAdmins(PerunSession sess, Group group) throws InternalErrorException {\n+  return getGroupsManagerImpl().getAdmins(sess, group);\n+ }\n+\n+ @Deprecated\n+ @Override\n+ public List<User> getDirectAdmins(PerunSession sess, Group group) throws InternalErrorException {\n+  return getGroupsManagerImpl().getDirectAdmins(sess, group);\n+ }\n+\n+ @Override\n+ public List<Group> getAdminGroups(PerunSession sess, Group group) throws InternalErrorException {\n+  return getGroupsManagerImpl().getGroupAdmins(sess, group);\n+ }\n+\n+ @Deprecated\n+ public List<RichUser> getRichAdmins(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n+  List<User> users = this.getAdmins(perunSession, group);\n+  List<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users);\n+  return richUsers;\n+ }\n+\n+ @Deprecated\n+ public List<RichUser> getDirectRichAdmins(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n+  List<User> users = this.getDirectAdmins(perunSession, group);\n+  List<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersFromListOfUsers(perunSession, users);\n+  return richUsers;\n+ }\n+\n+ @Deprecated\n+ public List<RichUser> getRichAdminsWithAttributes(PerunSession perunSession, Group group) throws InternalErrorException, UserNotExistsException {\n+  List<User> users = this.getAdmins(perunSession, group);\n+  List<RichUser> richUsers = perunBl.getUsersManagerBl().getRichUsersWithAttributesFromListOfUsers(perunSession, users);\n+  return richUsers;\n+ }\n+\n+ @Deprecated\n+ public List<RichUser> getRichAdminsWithSpecificAttributes(PerunSession perunSession, Group group, List<String> specificAttributes) throws InternalErrorException, UserNotExistsException {\n+  try {\n+   return getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, this.getRichAdmins(perunSession, group), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n+  } catch (AttributeNotExistsException ex) {\n+   throw new InternalErrorException(\"One of Attribute not exist.\", ex);\n+  }\n+ }\n+\n+ @Deprecated\n+ public List<RichUser> getDirectRichAdminsWithSpecificAttributes(PerunSession perunSession, Group group, List<String> specificAttributes) throws InternalErrorException, UserNotExistsException {\n+  try {\n+   return getPerunBl().getUsersManagerBl().convertUsersToRichUsersWithAttributes(perunSession, this.getDirectRichAdmins(perunSession, group), getPerunBl().getAttributesManagerBl().getAttributesDefinition(perunSession, specificAttributes));\n+  } catch (AttributeNotExistsException ex) {\n+   throw new InternalErrorException(\"One of Attribute not exist.\", ex);\n+  }\n+ }\n+\n+ public List<Group> getAssignedGroupsToResource(PerunSession sess, Resource resource) throws InternalErrorException {\n+  return getAssignedGroupsToResource(sess, resource, false);\n+ }\n+\n+ public List<Group> getAssignedGroupsToResource(PerunSession sess, Resource resource, boolean withSubGroups) throws InternalErrorException {\n+  List<Group> assignedGroups = getGroupsManagerImpl().getAssignedGroupsToResource(sess, resource);\n+  if (!withSubGroups)\n+   return assignedGroups;\n+\n+  boolean done = assignedGroups.isEmpty();\n+  List<Group> groupsToProcess = new ArrayList<Group>(assignedGroups);\n+  while (!done) {\n+   List<Group> groupsToAdd = new ArrayList<Group>();\n+   for (Group group : groupsToProcess) {\n+    //FIXME Do not get subgroups of the members group\n+    if (!group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+     groupsToAdd.addAll(this.getSubGroups(sess, group));\n+    }\n+   }\n+   groupsToAdd.removeAll(assignedGroups);\n+   assignedGroups.addAll(groupsToAdd);\n+   groupsToProcess = groupsToAdd;\n+   done = groupsToProcess.isEmpty();\n+  }\n+\n+  return assignedGroups;\n+ }\n+\n+ public List<Group> getAllGroups(PerunSession sess, Vo vo) throws InternalErrorException {\n+  List<Group> groups = getGroupsManagerImpl().getAllGroups(sess, vo);\n+\n+  // Sort\n+  Collections.sort(groups);\n+  return groups;\n+ }\n+\n+ public Map<Group, Object> getAllGroupsWithHierarchy(PerunSession sess, Vo vo) throws InternalErrorException {\n+  Map<Group, Object> groupHierarchy = new TreeMap<Group, Object>();\n+\n+  // Get the top level group = members\n+  try {\n+   groupHierarchy.put(this.getGroupByName(sess, vo, VosManager.MEMBERS_GROUP), null);\n+  } catch (GroupNotExistsException e) {\n+   throw new ConsistencyErrorException(\"Built-in members group must exists.\", e);\n+  }\n+\n+  // Call recursively getGroupsForHierarchy, which finds all subgroups\n+\n+  return getGroupsForHierarchy(sess, groupHierarchy);\n+ }\n+\n+ /**\n+  *\n+  * @param sess\n+  * @param groups initialized HashMap containing pair <topLevelGropu, null>\n+  * @return HashMap containing all VO groups hierarchically organized\n+  */\n+\n+\n+ private Map<Group, Object> getGroupsForHierarchy(PerunSession sess, Map<Group, Object> groups) throws InternalErrorException {\n+\n+  for (Group group : groups.keySet()) {\n+   List<Group> subGroups = this.getSubGroups(sess, group);\n+   Map<Group, Object> subGroupHierarchy = new TreeMap<Group, Object>();\n+   for (Group subGroup : subGroups) {\n+    subGroupHierarchy.put(subGroup, null);\n+   }\n+   groups.put(group, this.getGroupsForHierarchy(sess, subGroupHierarchy));\n+  }\n+\n+  return groups;\n+ }\n+\n+ public List<Group> getSubGroups(PerunSession sess, Group parentGroup) throws InternalErrorException {\n+  List<Group> subGroups = getGroupsManagerImpl().getSubGroups(sess, parentGroup);\n+\n+  // Sort\n+  Collections.sort(subGroups);\n+  return subGroups;\n+ }\n+\n+ public List<Group> getAllSubGroups(PerunSession sess, Group parentGroup) throws InternalErrorException {\n+  Queue<Group> groupsInQueue = new ConcurrentLinkedQueue<Group>();\n+  groupsInQueue.addAll(getGroupsManagerImpl().getSubGroups(sess, parentGroup));\n+  List<Group> allSubGroups = new ArrayList<Group>();\n+  while (groupsInQueue.peek() != null) {\n+   groupsInQueue.addAll(getGroupsManagerImpl().getSubGroups(sess, groupsInQueue.peek()));\n+   allSubGroups.add(groupsInQueue.poll());\n+  }\n+\n+  return allSubGroups;\n+ }\n+\n+ public Group getParentGroup(PerunSession sess, Group group) throws InternalErrorException, ParentGroupNotExistsException {\n+  if (group.getParentGroupId() == null) {\n+   Vo vo = this.getVo(sess, group);\n+   try {\n+    return this.getGroupByName(sess, vo, VosManager.MEMBERS_GROUP);\n+   } catch (GroupNotExistsException ex) {\n+    throw new ParentGroupNotExistsException(\"Members group not exist for vo\" + vo);\n+   }\n+  } else {\n+   return getGroupsManagerImpl().getParentGroup(sess, group);\n+  }\n+ }\n+\n+ public List<Group> getGroups(PerunSession sess, Vo vo) throws InternalErrorException {\n+  List<Group> groups = getGroupsManagerImpl().getGroups(sess, vo);\n+  Collections.sort(groups);\n+  return groups;\n+ }\n+\n+ public List<Group> getGroupsByIds(PerunSession sess, List<Integer> groupsIds) throws InternalErrorException {\n+  return getGroupsManagerImpl().getGroupsByIds(sess, groupsIds);\n+ }\n+\n+ public int getGroupsCount(PerunSession sess, Vo vo) throws InternalErrorException {\n+  return getGroupsManagerImpl().getGroupsCount(sess, vo);\n+ }\n+\n+ public int getGroupsCount(PerunSession sess) throws InternalErrorException {\n+  return getGroupsManagerImpl().getGroupsCount(sess);\n+ }\n+\n+ public int getSubGroupsCount(PerunSession sess, Group parentGroup) throws InternalErrorException {\n+  return getGroupsManagerImpl().getSubGroupsCount(sess, parentGroup);\n+ }\n+\n+ public Vo getVo(PerunSession sess, Group group) throws InternalErrorException {\n+  int voId = getGroupsManagerImpl().getVoId(sess, group);\n+  try {\n+   return getPerunBl().getVosManagerBl().getVoById(sess, voId);\n+  } catch (VoNotExistsException e) {\n+   throw new ConsistencyErrorException(\"Group belongs to the non-existent VO\", e);\n+  }\n+ }\n+\n+ public List<Group> getMemberGroups(PerunSession sess, Member member) throws InternalErrorException {\n+  List<Group> groups = this.getAllMemberGroups(sess, member);\n+  //Remove members group\n+  if (!groups.isEmpty()) {\n+   Iterator<Group> iterator = groups.iterator();\n+   while (iterator.hasNext()) {\n+    Group g = iterator.next();\n+    if (g.getName().equals(VosManager.MEMBERS_GROUP)) iterator.remove();\n+   }\n+  }\n+  // Sort\n+  Collections.sort(groups);\n+  return groups;\n+ }\n+\n+ public List<Group> getMemberDirectGroups(PerunSession sess, Member member) throws InternalErrorException {\n+  List<Group> memberGroups = this.getMemberGroups(sess, member);\n+  Iterator<Group> groupIterator = memberGroups.iterator();\n+  while (groupIterator.hasNext()) {\n+   if (!getGroupsManagerImpl().isDirectGroupMember(sess, groupIterator.next(), member)) {\n+    groupIterator.remove();\n+   }\n+  }\n+\n+  return memberGroups;\n+ }\n+\n+ public List<Group> getMemberGroupsByAttribute(PerunSession sess, Member member, Attribute attribute) throws WrongAttributeAssignmentException, InternalErrorException {\n+  List<Group> memberGroups = this.getAllMemberGroups(sess, member);\n+  memberGroups.retainAll(this.getGroupsByAttribute(sess, attribute));\n+  return memberGroups;\n+ }\n+\n+ public List<Group> getAllMemberGroups(PerunSession sess, Member member) throws InternalErrorException {\n+  return getGroupsManagerImpl().getAllMemberGroups(sess, member);\n+ }\n+\n+ public List<Member> getParentGroupMembers(PerunSession sess, Group group) throws InternalErrorException {\n+  try {\n+   Group parentGroup = getParentGroup(sess, group);\n+   return getGroupMembers(sess, parentGroup);\n+  } catch (ParentGroupNotExistsException ex) {\n+   //group (from param) is top level group. Return VO members instead.\n+   Vo vo = getVo(sess, group);\n+   return getPerunBl().getMembersManagerBl().getMembers(sess, vo);\n+  }\n+ }\n+\n+ public List<RichMember> getParentGroupRichMembers(PerunSession sess, Group group) throws InternalErrorException {\n+  List<Member> members = this.getParentGroupMembers(sess, group);\n+  return getPerunBl().getMembersManagerBl().convertMembersToRichMembers(sess, members);\n+ }\n+\n+ public List<RichMember> getParentGroupRichMembersWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n+  List<RichMember> richMembers = this.getParentGroupRichMembers(sess, group);\n+  return getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, richMembers);\n+ }\n+\n+ public boolean isUserMemberOfGroup(PerunSession sess, User user, Group group) throws InternalErrorException {\n+  return groupsManagerImpl.isUserMemberOfGroup(sess, user, group);\n+ }\n+\n+ /**\n+  * Compare richMember userExtSources with Candidate's userExtSources, if some of the useExtSource fits.\n+  *\n+  * @param richMember\n+  * @param candidate\n+  * @return true if richMember.userExtSources contains some of the candidate.useExtSource\n+  */\n+\n+ protected boolean hasCandidateExistingMember(Candidate candidate, RichMember richMember) {\n+\n+  for (UserExtSource ues : richMember.getUserExtSources()) {\n+   if (candidate.getUserExtSources().contains(ues)) {\n+    return true;\n+   }\n+  }\n+\n+  return false;\n+ }\n+\n+ /**\n+  * This method run in separate transaction.\n+  */\n+\n+ public List<String> synchronizeGroup(PerunSession sess, Group group) throws InternalErrorException, MemberAlreadyRemovedException, AttributeNotExistsException, WrongAttributeAssignmentException, ExtSourceNotExistsException, WrongAttributeValueException, WrongReferenceAttributeValueException, GroupOperationsException, NotMemberOfParentGroupException, GroupNotExistsException {\n+  //needed variables for whole method\n+  List<String> skippedMembers = new ArrayList<>();\n+  ExtSource source = null;\n+  ExtSource membersSource = null;\n+  try {\n+   log.info(\"Group synchronization {}: started.\", group);\n+\n+   //Initialization of group extSource\n+   source = getGroupExtSourceForSynchronization(sess, group);\n+\n+   //Initialization of groupMembers extSource (if it is set), in other case set membersSource = source\n+   membersSource = getGroupMembersExtSourceForSynchronization(sess, group, source);\n+\n+   //Prepare info about userAttributes which need to be overwrite (not just updated)\n+   List<String> overwriteUserAttributesList = getOverwriteUserAttributesListFromExtSource(membersSource);\n+\n+   //Get info about type of synchronization (with or without update)\n+   boolean lightweightSynchronization = isThisLightweightSynchronization(sess, group);\n+   log.info(\"Group synchronization {}: using configuration extSource for membership {}, extSource for members {}\", new Object[] {group, membersSource, membersSource.getName()});\n+\n+   //Prepare containers for work with group members\n+   List<Candidate> candidatesToAdd = new ArrayList<>();\n+   Map<Candidate, RichMember> membersToUpdate = new HashMap<>();\n+   List<RichMember> membersToRemove = new ArrayList<>();\n+\n+   //get all actual members of group\n+   List<RichMember> actualGroupMembers = getPerunBl().getGroupsManagerBl().getGroupRichMembers(sess, group);\n+   if (lightweightSynchronization) {\n+    categorizeMembersForLightweightSynchronization(sess, group, source, membersSource, actualGroupMembers, candidatesToAdd, membersToRemove, skippedMembers);\n+   } else {\n+    //Get subjects from extSource\n+    List<Map<String, String>> subjects = getSubjectsFromExtSource(sess, source, group);\n+    //Convert subjects to candidates\n+    List<Candidate> candidates = convertSubjectsToCandidates(sess, subjects, membersSource, source, skippedMembers);\n+    categorizeMembersForSynchronization(sess, actualGroupMembers, candidates, candidatesToAdd, membersToUpdate, membersToRemove);\n+   }\n+\n+   //Update members already presented in group\n+   updateExistingMembersWhileSynchronization(sess, group, membersToUpdate, overwriteUserAttributesList);\n+\n+   //Add not presented candidates to group\n+   addMissingMembersWhileSynchronization(sess, group, candidatesToAdd, overwriteUserAttributesList, skippedMembers);\n+\n+   //Remove presented members in group who are not presented in synchronized ExtSource\n+   removeFormerMembersWhileSynchronization(sess, group, membersToRemove);\n+   log.info(\"Group synchronization {}: ended.\", group);\n+\n+  } finally {\n+   closeExtSourcesAfterSynchronization(membersSource, source);\n+  }\n+\n+  return skippedMembers;\n+ }\n+\n+ /**\n+  * Force group synchronization.\n+  *\n+  * Adds the group synchronization process in the groupSynchronizerThreads.\n+  *\n+  * @param group\n+  */\n+\n+ public void forceGroupSynchronization(PerunSession sess, Group group) throws GroupSynchronizationAlreadyRunningException {\n+  // First check if the group is not currently in synchronization process\n+  if (groupSynchronizerThreads.containsKey(group.getId()) && groupSynchronizerThreads.get(group.getId()).getState() != Thread.State.TERMINATED) {\n+   throw new GroupSynchronizationAlreadyRunningException(group);\n+  } else {\n+   // Remove from groupSynchronizerThreads if the thread was terminated\n+   if (groupSynchronizerThreads.containsKey(group.getId())) {\n+    groupSynchronizerThreads.remove(group.getId());\n+   }\n+   // Start and run the new thread\n+   GroupSynchronizerThread thread = new GroupSynchronizerThread(sess, group);\n+   thread.start();\n+   log.info(\"Group synchronization thread started for group {}.\", group);\n+   groupSynchronizerThreads.put(group.getId(), thread);\n+  }\n+ }\n+\n+ /**\n+  * Synchronize all groups which have enabled synchronization. This method is run by the scheduler every 5 minutes.\n+  *\n+  * @throws InternalErrorException\n+  */\n+\n+ public void synchronizeGroups(PerunSession sess) throws InternalErrorException {\n+  Random rand = new Random();\n+\n+  // Firstly remove all terminated threads\n+  List<Integer> threadsToRemove = new ArrayList<Integer>();\n+  for (Integer groupId : groupSynchronizerThreads.keySet()) {\n+   if (groupSynchronizerThreads.get(groupId).getState() == Thread.State.TERMINATED) {\n+    threadsToRemove.add(groupId);\n+   }\n+  }\n+\n+  for (Integer groupId : threadsToRemove) {\n+   groupSynchronizerThreads.remove(groupId);\n+   log.debug(\"Removing terminated group synchronization thread for group id={}\", groupId);\n+  }\n+\n+  // Get the default synchronization interval and synchronization timeout from the configuration file\n+\n+  int intervalMultiplier = Integer.parseInt(BeansUtils.getPropertyFromConfiguration(\"perun.group.synchronization.interval\"));\n+  int timeout = Integer.parseInt(BeansUtils.getPropertyFromConfiguration(\"perun.group.synchronization.timeout\"));\n+\n+  // Get the number of seconds from the epoch, so we can divide it by the synchronization interval value\n+  long minutesFromEpoch = System.currentTimeMillis() / 1000 / 60;\n+\n+  // Get the groups with synchronization enabled\n+  List<Group> groups = groupsManagerImpl.getGroupsToSynchronize(sess);\n+  int numberOfNewSynchronizations = 0;\n+  int numberOfActiveSynchronizations = 0;\n+  int numberOfTerminatedSynchronizations = 0;\n+  for (Group group : groups) {\n+   // Get the synchronization interval\n+   try {\n+    Attribute intervalAttribute = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPSYNCHROINTERVAL_ATTRNAME);\n+    if (intervalAttribute.getValue() != null) {\n+     intervalMultiplier = Integer.parseInt((String) intervalAttribute.getValue());\n+    } else {\n+     log.warn(\"Group {} hasn't set synchronization interval, using default {} seconds\", group, intervalMultiplier);\n+    }\n+   } catch (AttributeNotExistsException e) {\n+    throw new ConsistencyErrorException(\"Required attribute \" + GroupsManager.GROUPSYNCHROINTERVAL_ATTRNAME + \" isn't defined in Perun!\", e);\n+   } catch (WrongAttributeAssignmentException e) {\n+    log.error(\"Cannot synchronize group \" + group + \" due to exception:\", e);\n+    continue;\n+   }\n+\n+   // Multiply with 5 to get real minutes\n+   intervalMultiplier = intervalMultiplier * 5;\n+\n+   // If the minutesFromEpoch can be divided by the intervalMultiplier, then synchronize\n+   if ((minutesFromEpoch % intervalMultiplier) == 0) {\n+    // It's time to synchronize\n+    log.info(\"Scheduling synchronization for the group {}. Interval {} minutes.\", group, intervalMultiplier);\n+\n+    // Run each synchronization in separate thread, but do not start new one, if previous hasn't finished yet\n+    if (groupSynchronizerThreads.containsKey(group.getId())) {\n+     // Check the running time of the thread\n+     long timeDiff = System.currentTimeMillis()- groupSynchronizerThreads.get(group.getId()).getStartTime();\n+\n+     // If the time is greater than timeout set in the configuration file (in minutes)\n+     if (timeDiff / 1000 / 60 > timeout) {\n+      // Timeout reach, stop the thread\n+      log.warn(\"Timeout {} minutes of the synchronization thread for the group {} reached.\", timeout, group);\n+      groupSynchronizerThreads.get(group.getId()).interrupt();\n+      groupSynchronizerThreads.remove(group.getId());\n+      numberOfTerminatedSynchronizations++;\n+     } else {\n+      numberOfActiveSynchronizations++;\n+     }\n+    } else {\n+     // Start and run the new thread\n+     try {\n+      // Do not overload externalSource, run each synchronization in 0-30s steps\n+      Thread.sleep(rand.nextInt(30000));\n+     } catch (InterruptedException e) {\n+      // Do nothing\n+\n+     }\n+     GroupSynchronizerThread thread = new GroupSynchronizerThread(sess, group);\n+     thread.start();\n+     log.info(\"Group synchronization thread started for group {}.\", group);\n+     groupSynchronizerThreads.put(group.getId(), thread);\n+     numberOfNewSynchronizations++;\n+    }\n+   }\n+  }\n+  if (groups.size() > 0) {\n+   log.info(\"Synchronizing {} groups, active {}, new {}, terminated {}.\", new Object[] {groups.size(), numberOfActiveSynchronizations, numberOfNewSynchronizations, numberOfTerminatedSynchronizations});\n+  }\n+ }\n+\n+\n+ private static class GroupSynchronizerThread extends Thread {\n+\n+  // all synchronization runs under synchronizer identity.\n+\n+  final PerunPrincipal pp = new PerunPrincipal(\"perunSynchronizer\", ExtSourcesManager.EXTSOURCE_NAME_INTERNAL, ExtSourcesManager.EXTSOURCE_INTERNAL);\n+  private PerunBl perunBl;\n+  private PerunSession sess;\n+  private Group group;\n+  private long startTime;\n+\n+\n+  public GroupSynchronizerThread(PerunSession sess, Group group) {\n+   // take only reference to perun\n+   this.perunBl = (PerunBl) sess.getPerun();\n+   this.group = group;\n+\n+   try {\n+    // create own session\n+    this.sess = perunBl.getPerunSession(pp, new PerunClient());\n+   } catch (InternalErrorException ex) {\n+    log.error(\"Unable to create internal session for Synchronizer with credentials {} because of exception {}\",\n+    pp,\n+    ex);\n+   }\n+  }\n+\n+  public void run() {\n+   //text of exception if was thrown, null in exceptionMessage means \"no exception, it's ok\"\n+   String exceptionMessage = null;\n+   //text with all skipped members and reasons of this skipping\n+   String skippedMembersMessage = null;\n+   //if exception which produce fail of whole synchronization was thrown\n+   boolean failedDueToException = false;\n+   try {\n+    log.debug(\"Synchronization thread for group {} has started.\", group);\n+    // Set the start time, so we can check the timeout of the thread\n+    startTime = System.currentTimeMillis();\n+\n+    //synchronize Group and get information about skipped Members\n+    List<String> skippedMembers = perunBl.getGroupsManagerBl().synchronizeGroup(sess, group);\n+    if (!skippedMembers.isEmpty()) {\n+     skippedMembersMessage = \"These members from extSource were skipped: { \";\n+     for (String skippedMember : skippedMembers) {\n+      if (skippedMember == null) continue;\n+      skippedMembersMessage += skippedMember + \", \";\n+     }\n+     skippedMembersMessage += \" }\";\n+     exceptionMessage = skippedMembersMessage;\n+    }\n+    log.debug(\"Synchronization thread for group {} has finished in {} ms.\",\n+    group,\n+    System.currentTimeMillis()- startTime);\n+\n+   } catch (WrongAttributeValueException |WrongReferenceAttributeValueException| InternalErrorException| WrongAttributeAssignmentException| MemberAlreadyRemovedException| GroupNotExistsException| GroupOperationsException| NotMemberOfParentGroupException| AttributeNotExistsException| ExtSourceNotExistsException e) {\n+    failedDueToException = true;\n+    exceptionMessage = \"Cannot synchronize group \";\n+    log.error(exceptionMessage + group, e);\n+    exceptionMessage += \"due to exception: \" + e.getName() + \" => \" + e.getMessage();\n+   } catch (Exception e) {\n+    //If some other exception has been thrown, log it and throw again\n+    failedDueToException = true;\n+    exceptionMessage = \"Cannot synchronize group \";\n+    log.error(exceptionMessage + group, e);\n+    exceptionMessage += \"due to unexpected exception: \" + e.getClass().getName() + \" => \" + e.getMessage();\n+    throw e;\n+   } finally {\n+    //Save information about group synchronization, this method run in new transaction\n+    try {\n+     perunBl.getGroupsManagerBl().saveInformationAboutGroupSynchronization(sess, group, failedDueToException, exceptionMessage);\n+    } catch (Exception ex) {\n+     log.error(\"When synchronization group \" + group + \", exception was thrown.\", ex);\n+     log.info(\"Info about exception from synchronization: \" + skippedMembersMessage);\n+    }\n+    log.debug(\"GroupSynchronizerThread finished for group: {}\", group);\n+   }\n+  }\n+\n+  public long getStartTime() {\n+   return startTime;\n+  }\n+ }\n+\n+ /**\n+  * Get all groups of member (except members group) where authoritativeGroup attribute is set to 1 (true)\n+  *\n+  * @param sess\n+  * @param member\n+  * @return list of groups with authoritativeAttribute set to 1\n+  *\n+  * @throws AttributeNotExistsException if authoritativeGroup attribute not exists\n+  * @throws InternalErrorException\n+  */\n+\n+ List<Group> getAllAuthoritativeGroupsOfMember(PerunSession sess, Member member) throws AttributeNotExistsException, InternalErrorException {\n+  //Get all member groups except membersGroup\n+  List<Group> memberGroups = this.getMemberGroups(sess, member);\n+  Iterator<Group> groupsIter = memberGroups.iterator();\n+  //Iterate through all groups and remove those which have not authoritativeGroup attribute set to 1\n+  while (groupsIter.hasNext()) {\n+   Group group = groupsIter.next();\n+   try {\n+\n+    boolean isThisGroupAuthoritative = false;\n+    Attribute authoritativeGroup = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_D_AUTHORITATIVE_GROUP);\n+    if (authoritativeGroup.getValue() != null) {\n+     Integer attrValue = (Integer) authoritativeGroup.getValue();\n+     if (attrValue == 1) isThisGroupAuthoritative = true;\n+    }\n+    //If group is not authoritative group, remove it from list of memberAuthoritativeGroups\n+    if (!isThisGroupAuthoritative) groupsIter.remove();\n+   } catch (WrongAttributeAssignmentException ex) {\n+    throw new InternalErrorException(ex);\n+   }\n+  }\n+\n+  return memberGroups;\n+ }\n+\n+ /**\n+  * Gets the groupsManagerImpl for this instance.\n+  *\n+  * @return The groupsManagerImpl.\n+  */\n+\n+ public GroupsManagerImplApi getGroupsManagerImpl() {\n+  return this.groupsManagerImpl;\n+ }\n+\n+ /**\n+  * Gets the perunBl.\n+  *\n+  * @return The perunBl.\n+  */\n+\n+ public PerunBl getPerunBl() {\n+  return this.perunBl;\n+ }\n+\n+ public List<Group> getGroupsByAttribute(PerunSession sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException {\n+  getPerunBl().getAttributesManagerBl().checkNamespace(sess, attribute, AttributesManager.NS_GROUP_ATTR);\n+  if (!(getPerunBl().getAttributesManagerBl().isDefAttribute(sess, attribute) || getPerunBl().getAttributesManagerBl().isOptAttribute(sess, attribute))) throw new WrongAttributeAssignmentException(\"This method can process only def and opt attributes\");\n+  return getGroupsManagerImpl().getGroupsByAttribute(sess, attribute);\n+ }\n+\n+ public List<Pair<Group, Resource>> getGroupResourcePairsByAttribute(PerunSession sess, Attribute attribute) throws InternalErrorException, WrongAttributeAssignmentException {\n+  getPerunBl().getAttributesManagerBl().checkNamespace(sess, attribute, AttributesManager.NS_GROUP_RESOURCE_ATTR);\n+  if (!(getPerunBl().getAttributesManagerBl().isDefAttribute(sess, attribute) || getPerunBl().getAttributesManagerBl().isOptAttribute(sess, attribute))) throw new WrongAttributeAssignmentException(\"This method can process only def and opt attributes\");\n+  return getGroupsManagerImpl().getGroupResourcePairsByAttribute(sess, attribute);\n+ }\n+\n+ public boolean isGroupMember(PerunSession sess, Group group, Member member) throws InternalErrorException {\n+  return getGroupsManagerImpl().isGroupMember(sess, group, member);\n+ }\n+\n+ public void checkGroupExists(PerunSession sess, Group group) throws InternalErrorException, GroupNotExistsException {\n+  getGroupsManagerImpl().checkGroupExists(sess, group);\n+ }\n+\n+ public List<Group> getGroupsByPerunBean(PerunSession sess, PerunBean perunBean) throws InternalErrorException {\n+  List<Group> groups = new ArrayList<Group>();\n+\n+  //All possible useful objects\n+  Vo vo = null;\n+  Facility facility = null;\n+  Group group = null;\n+  Member member = null;\n+  User user = null;\n+  Host host = null;\n+  Resource resource = null;\n+  if (perunBean != null) {\n+   if (perunBean instanceof Vo) vo = (Vo) perunBean;\n+   else if (perunBean instanceof Facility) facility = (Facility) perunBean;\n+   else if (perunBean instanceof Group) group = (Group) perunBean;\n+   else if (perunBean instanceof Member) member = (Member) perunBean;\n+   else if (perunBean instanceof User) user = (User) perunBean;\n+   else if (perunBean instanceof Host) host = (Host) perunBean;\n+   else if (perunBean instanceof Resource) resource = (Resource) perunBean;\n+   else {\n+         throw new InternalErrorException(\"There is unrecognized object in primaryHolder of aidingAttr.\");\n+        }\n+  } else {\n+   throw new InternalErrorException(\"Aiding attribute must have primaryHolder which is not null.\");\n+  }\n+\n+  //Important For Groups not work with Subgroups! Invalid members are executed too.\n+  if (group != null) {\n+   groups.add(group);\n+  } else if (member != null) {\n+   groups.addAll(getPerunBl().getGroupsManagerBl().getAllMemberGroups(sess, member));\n+  } else if (resource != null) {\n+          groups.addAll(getPerunBl().getResourcesManagerBl().getAssignedGroups(sess, resource));\n+         } else if (user != null) {\n+          List<Member> members = getPerunBl().getMembersManagerBl().getMembersByUser(sess, user);\n+          for (Member memberElement : members) {\n+           groups.addAll(getPerunBl().getGroupsManagerBl().getAllMemberGroups(sess, memberElement));\n+          }\n+         } else if (host != null) {\n+                 facility = getPerunBl().getFacilitiesManagerBl().getFacilityForHost(sess, host);\n+                 List<Resource> resourcesFromFacility = getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n+                 for (Resource resourceElement : resourcesFromFacility) {\n+                  groups.addAll(getPerunBl().getGroupsManagerBl().getAssignedGroupsToResource(sess, resourceElement));\n+                 }\n+                } else if (facility != null) {\n+                 List<Resource> resourcesFromFacility = getPerunBl().getFacilitiesManagerBl().getAssignedResources(sess, facility);\n+                 for (Resource resourceElement : resourcesFromFacility) {\n+                  groups.addAll(getPerunBl().getGroupsManagerBl().getAssignedGroupsToResource(sess, resourceElement));\n+                 }\n+                } else if (vo != null) {\n+                        groups.addAll(getPerunBl().getGroupsManagerBl().getAllGroups(sess, vo));\n+                       }\n+  groups = new ArrayList<Group>(new HashSet<Group>(groups));\n+  return groups;\n+ }\n+\n+ public List<Member> filterMembersByMembershipTypeInGroup(List<Member> members) throws InternalErrorException {\n+  List<Member> filteredMembers = new ArrayList<Member>();\n+  Iterator<Member> membersIterator = members.iterator();\n+\n+  //Add members with direct membership type\n+  while (membersIterator.hasNext()) {\n+   Member m = membersIterator.next();\n+   if (m.getMembershipType().equals(MembershipType.DIRECT)) {\n+    filteredMembers.add(m);\n+    membersIterator.remove();\n+   }\n+  }\n+\n+  //Add not containing members with indirect membership type\n+\n+  for (Member m : members) {\n+   if (!filteredMembers.contains(m)) filteredMembers.add(m);\n+  }\n+\n+  return filteredMembers;\n+ }\n+\n+ public RichGroup filterOnlyAllowedAttributes(PerunSession sess, RichGroup richGroup) throws InternalErrorException {\n+  if (richGroup == null) throw new InternalErrorException(\"RichGroup can't be null.\");\n+\n+  //Filtering richGroup attributes\n+  if (richGroup.getAttributes() != null) {\n+   List<Attribute> groupAttributes = richGroup.getAttributes();\n+   List<Attribute> allowedGroupAttributes = new ArrayList<Attribute>();\n+   for (Attribute groupAttr : groupAttributes) {\n+    if (AuthzResolver.isAuthorizedForAttribute(sess, ActionType.READ, groupAttr, richGroup, null)) {\n+     groupAttr.setWritable(AuthzResolver.isAuthorizedForAttribute(sess, ActionType.WRITE, groupAttr, richGroup, null));\n+     allowedGroupAttributes.add(groupAttr);\n+    }\n+   }\n+   richGroup.setAttributes(allowedGroupAttributes);\n+  }\n+\n+  return richGroup;\n+ }\n+\n+ public List<RichGroup> filterOnlyAllowedAttributes(PerunSession sess, List<RichGroup> richGroups) throws InternalErrorException {\n+  List<RichGroup> filteredRichGroups = new ArrayList<RichGroup>();\n+  if (richGroups == null || richGroups.isEmpty())\n+   return filteredRichGroups;\n+  for (RichGroup rg : richGroups) {\n+   filteredRichGroups.add(this.filterOnlyAllowedAttributes(sess, rg));\n+  }\n+\n+  return filteredRichGroups;\n+ }\n+\n+ public void setPerunBl(PerunBl perunBl) {\n+  this.perunBl = perunBl;\n+ }\n+\n+ public RichGroup convertGroupToRichGroupWithAttributes(PerunSession sess, Group group) throws InternalErrorException {\n+  return new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group));\n+ }\n+\n+ public RichGroup convertGroupToRichGroupWithAttributesByName(PerunSession sess, Group group, List<String> attrNames) throws InternalErrorException {\n+  if (attrNames == null)\n+   return convertGroupToRichGroupWithAttributes(sess, group);\n+  return new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group, attrNames));\n+ }\n+\n+ public List<RichGroup> convertGroupsToRichGroupsWithAttributes(PerunSession sess, List<Group> groups) throws InternalErrorException {\n+  List<RichGroup> richGroups = new ArrayList<>();\n+  for (Group group : groups) {\n+   richGroups.add(new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group)));\n+  }\n+\n+  return richGroups;\n+ }\n+\n+ public List<RichGroup> convertGroupsToRichGroupsWithAttributes(PerunSession sess, List<Group> groups, List<String> attrNames) throws InternalErrorException {\n+  if (attrNames == null)\n+   return convertGroupsToRichGroupsWithAttributes(sess, groups);\n+  List<RichGroup> richGroups = new ArrayList<>();\n+  for (Group group : groups) {\n+   richGroups.add(new RichGroup(group, this.getPerunBl().getAttributesManagerBl().getAttributes(sess, group, attrNames)));\n+  }\n+\n+  return richGroups;\n+ }\n+\n+ public List<RichGroup> getAllRichGroupsWithAttributesByNames(PerunSession sess, Vo vo, List<String> attrNames) throws InternalErrorException {\n+  return convertGroupsToRichGroupsWithAttributes(sess, this.getAllGroups(sess, vo), attrNames);\n+ }\n+\n+ public List<RichGroup> getRichSubGroupsWithAttributesByNames(PerunSession sess, Group parentGroup, List<String> attrNames) throws InternalErrorException {\n+  return convertGroupsToRichGroupsWithAttributes(sess, this.getSubGroups(sess, parentGroup), attrNames);\n+ }\n+\n+ public List<RichGroup> getAllRichSubGroupsWithAttributesByNames(PerunSession sess, Group parentGroup, List<String> attrNames) throws InternalErrorException {\n+  return convertGroupsToRichGroupsWithAttributes(sess, this.getAllSubGroups(sess, parentGroup), attrNames);\n+ }\n+\n+ public RichGroup getRichGroupByIdWithAttributesByNames(PerunSession sess, int groupId, List<String> attrNames) throws InternalErrorException, GroupNotExistsException {\n+  return convertGroupToRichGroupWithAttributesByName(sess, this.getGroupById(sess, groupId), attrNames);\n+ }\n+\n+ public void saveInformationAboutGroupSynchronization(PerunSession sess, Group group, boolean failedDueToException, String exceptionMessage) throws AttributeNotExistsException, InternalErrorException, WrongReferenceAttributeValueException, WrongAttributeAssignmentException, WrongAttributeValueException {\n+  //get current timestamp of this synchronization\n+  Date currentTimestamp = new Date();\n+  String originalExceptionMessage = exceptionMessage;\n+  //If session is null, throw an exception\n+  if (sess == null) {\n+   throw new InternalErrorException(\"Session is null when trying to save information about synchronization. Group: \" + group + \", timestamp: \" + currentTimestamp + \",message: \" + exceptionMessage);\n+  }\n+\n+  //If group is null, throw an exception\n+  if (group == null) {\n+   throw new InternalErrorException(\"Object group is null when trying to save information about synchronization. Timestamp: \" + currentTimestamp + \", message: \" + exceptionMessage);\n+  }\n+\n+  //if exceptionMessage is empty, use \"Empty message\" instead\n+  if (exceptionMessage != null && exceptionMessage.isEmpty()) {\n+   exceptionMessage = \"Empty message.\";\n+  //else trim the message on 1000 characters if not null\n+  } else if (exceptionMessage != null && exceptionMessage.length() > 1000) {\n+   exceptionMessage = exceptionMessage.substring(0, 1000) + \" ... message is too long, other info is in perun log file. If needed, please ask perun administrators.\";\n+  }\n+\n+  //Set correct format of currentTimestamp\n+  String correctTimestampString = BeansUtils.getDateFormatter().format(currentTimestamp);\n+\n+  //Get both attribute definition lastSynchroTimestamp and lastSynchroState\n+  //Get definitions and values, set values\n+  Attribute lastSynchronizationTimestamp = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, AttributesManager.NS_GROUP_ATTR_DEF + \":lastSynchronizationTimestamp\"));\n+  Attribute lastSynchronizationState = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, AttributesManager.NS_GROUP_ATTR_DEF + \":lastSynchronizationState\"));\n+  lastSynchronizationTimestamp.setValue(correctTimestampString);\n+  //if exception is null, set null to value => remove attribute instead of setting in method setAttributes\n+  lastSynchronizationState.setValue(exceptionMessage);\n+\n+  //attributes to set\n+  List<Attribute> attrsToSet = new ArrayList<>();\n+\n+  //null in exceptionMessage means no exception, success\n+  //Set lastSuccessSynchronizationTimestamp if this one is success\n+  if (exceptionMessage == null) {\n+   String attrName = AttributesManager.NS_GROUP_ATTR_DEF + \":lastSuccessSynchronizationTimestamp\";\n+   try {\n+    Attribute lastSuccessSynchronizationTimestamp = new Attribute(((PerunBl) sess.getPerun()).getAttributesManagerBl().getAttributeDefinition(sess, attrName));\n+    lastSuccessSynchronizationTimestamp.setValue(correctTimestampString);\n+    attrsToSet.add(lastSuccessSynchronizationTimestamp);\n+   } catch (AttributeNotExistsException ex) {\n+    log.error(\"Can't save lastSuccessSynchronizationTimestamp, because there is missing attribute with name {}\",\n+    attrName);\n+   }\n+  } else {\n+   //Log to auditer_log that synchronization failed or finished with some errors\n+   if (failedDueToException) {\n+    getPerunBl().getAuditer().log(sess, \"{} synchronization failed because of {}.\", group, originalExceptionMessage);\n+   } else {\n+    getPerunBl().getAuditer().log(sess, \"{} synchronization finished with errors: {}.\", group, originalExceptionMessage);\n+   }\n+  }\n+\n+  //set lastSynchronizationState and lastSynchronizationTimestamp\n+  attrsToSet.add(lastSynchronizationState);\n+  attrsToSet.add(lastSynchronizationTimestamp);\n+  ((PerunBl) sess.getPerun()).getAttributesManagerBl().setAttributes(sess, group, attrsToSet);\n+ }\n+\n+ @Override\n+ public List<Group> getGroupsWithAssignedExtSourceInVo(PerunSession sess, ExtSource source, Vo vo) throws InternalErrorException {\n+  return getGroupsManagerImpl().getGroupsWithAssignedExtSourceInVo(sess, source, vo);\n+ }\n+\n+ //----------- PRIVATE METHODS FOR  GROUP SYNCHRONIZATION -----------\n+\n+ /**\n+  * For lightweight synchronization prepare candidate to add and members to remove.\n+  *\n+  * Get all subjects from loginSource and try to find users in Perun by their login and this ExtSource.\n+  * If found, look if this user is already in synchronized Group. If yes skip him, if not add him to candidateToAdd\n+  * If not found, add him to candidatesToAdd (from source itself or from memberSource if they are different)\n+  *\n+  * Rest of former members need to be add to membersToRemove to remove them from group.\n+  *\n+  * This method fill 2 member structures which get as parameters:\n+  * 1. candidateToAdd - New members of the group\n+  * 2. membersToRemove - Former members who are not in synchronized ExtSource now\n+  *\n+  * @param sess\n+  * @param group\n+  * @param loginSource\n+  * @param memberSource\n+  * @param groupMembers\n+  * @param candidatesToAdd\n+  * @param membersToRemove\n+  * @param skippedMembers\n+  * @throws InternalErrorException\n+  * @throws ExtSourceNotExistsException\n+  */\n+\n+\n+ private void categorizeMembersForLightweightSynchronization(PerunSession sess, Group group, ExtSource loginSource, ExtSource memberSource, List<RichMember> groupMembers, List<Candidate> candidatesToAdd, List<RichMember> membersToRemove, List<String> skippedMembers) throws InternalErrorException, ExtSourceNotExistsException {\n+  //Get subjects from loginSource\n+  List<Map<String, String>> subjects = getSubjectsFromExtSource(sess, loginSource, group);\n+\n+  //Prepare structure of userIds with richMembers to better work with actual members\n+  Map<Integer, RichMember> idsOfUsersInGroup = new HashMap<>();\n+  for (RichMember richMember : groupMembers) {\n+   idsOfUsersInGroup.put(richMember.getUserId(), richMember);\n+  }\n+\n+  //try to find users by login and loginSource\n+\n+  for (Map<String, String> subjectFromLoginSource : subjects) {\n+   String login = subjectFromLoginSource.get(\"login\");\n+   // Skip subjects, which doesn't have login\n+   if (login == null || login.isEmpty()) {\n+    log.debug(\"Subject {} doesn't contain attribute login, skipping.\", subjectFromLoginSource);\n+    skippedMembers.add(\"MemberEntry:[\" + subjectFromLoginSource + \"] was skipped because login is missing\");\n+    continue;\n+   }\n+\n+   //try to find user from perun by login and member extSource (need to use memberSource because loginSource is not saved by synchronization)\n+   User user = null;\n+   Candidate candidate = null;\n+   try {\n+    UserExtSource userExtSource = getPerunBl().getUsersManagerBl().getUserExtSourceByExtLogin(sess, memberSource, login);\n+    user = getPerunBl().getUsersManagerBl().getUserByUserExtSource(sess, userExtSource);\n+    if (!idsOfUsersInGroup.containsKey(user.getId())) {\n+     candidate = new Candidate(user, userExtSource);\n+    }\n+   } catch (UserExtSourceNotExistsException | UserNotExistsException ex) {\n+    //If not find, get more information about him from member extSource\n+    List<Map<String, String>> subjectToConvert = Arrays.asList(subjectFromLoginSource);\n+    List<Candidate> converetedCandidatesList = convertSubjectsToCandidates(sess, subjectToConvert, memberSource, loginSource, skippedMembers);\n+    //Empty means not found (skipped)\n+    if (!converetedCandidatesList.isEmpty()) {\n+     //We add one subject so we take the one converted candidate\n+     candidate = converetedCandidatesList.get(0);\n+    }\n+   }\n+\n+   //If user is not null now, we found it so we can use it from perun, in other case he is not in perun at all\n+   if (user != null && candidate == null) {\n+    //we can skip this one, because he is already in group, and remove him from the map\n+    idsOfUsersInGroup.remove(user.getId());\n+   } else if (candidate != null) {\n+    candidatesToAdd.add(candidate);\n+   } else {\n+    //Both null means that we can't find subject by login in extSource at all (will be in skipped members)\n+    log.debug(\"Subject with login {} was skipped because can't be found in extSource {}.\", login, memberSource);\n+   }\n+  }\n+\n+  //Rest of them need to be removed\n+  membersToRemove.addAll(idsOfUsersInGroup.values());\n+ }\n+\n+ /**\n+  * This method fill 3 member structures which get as parameters:\n+  * 1. membersToUpdate - Candidates with equivalent Members from Perun for purpose of updating attributes and statuses\n+  * 2. candidateToAdd - New members of the group\n+  * 3. membersToRemove - Former members who are not in synchronized ExtSource now\n+  *\n+  * @param sess\n+  * @param groupMembers current group members\n+  * @param candidates to be synchronized from extSource\n+  * @param membersToUpdate 1. container (more above)\n+  * @param candidatesToAdd 2. container (more above)\n+  * @param membersToRemove 3. container (more above)\n+  *\n+  * @throws InternalErrorException if getting RichMembers without attributes for the group fail\n+  */\n+\n+\n+ private void categorizeMembersForSynchronization(PerunSession sess, List<RichMember> groupMembers, List<Candidate> candidates, List<Candidate> candidatesToAdd, Map<Candidate, RichMember> membersToUpdate, List<RichMember> membersToRemove) throws InternalErrorException {\n+  candidatesToAdd.addAll(candidates);\n+  membersToRemove.addAll(groupMembers);\n+  //mapping structure for more efficient searching\n+  Map<UserExtSource, RichMember> mappingStructure = new HashMap<>();\n+  for (RichMember rm : groupMembers) {\n+\n+   for (UserExtSource ues : rm.getUserExtSources()) {\n+    mappingStructure.put(ues, rm);\n+   }\n+  }\n+\n+  //try to find already existing candidates between members in group\n+\n+  for (Candidate candidate : candidates) {\n+   List<UserExtSource> candidateExtSources = candidate.getUserExtSources();\n+   for (UserExtSource key : candidateExtSources) {\n+    //candidate exists, will be updated\n+    if (mappingStructure.containsKey(key)) {\n+     membersToUpdate.put(candidate, mappingStructure.get(key));\n+     candidatesToAdd.remove(candidate);\n+     membersToRemove.remove(mappingStructure.get(key));\n+     break;\n+    }\n+   }\n+  }\n+ }\n+\n+ /**\n+  * Get ExtSource by name from attribute group:groupMembersExtSource.\n+  * Attribute can be null so if is not set, use default source.\n+  *\n+  * @param sess\n+  * @param group to be synchronized\n+  * @param defaultSource we need to have already default group source (for synchronization)\n+  *\n+  * @return if exists, return membersExtSource, if not, return default group extSource\n+  *\n+  * @throws InternalErrorException if some internal error happens\n+  * @throws WrongAttributeAssignmentException if bad assignment of groupMembersExtSource attribute\n+  * @throws AttributeNotExistsException if groupMembersExtSource attribute not exists in perun Database\n+  * @throws ExtSourceNotExistsException if extSource set in Group attribute not exists\n+  */\n+\n+\n+ private ExtSource getGroupMembersExtSourceForSynchronization(PerunSession sess, Group group, ExtSource defaultSource) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, ExtSourceNotExistsException {\n+  //Prepare the groupMembersExtSource if it is set\n+  Attribute membersExtSourceNameAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPMEMBERSEXTSOURCE_ATTRNAME);\n+  ExtSource membersSource = null;\n+  // If the different extSource name for the members was set use it\n+  if (membersExtSourceNameAttr != null && membersExtSourceNameAttr.getValue() != null) {\n+   String membersExtSourceName = (String) membersExtSourceNameAttr.getValue();\n+   membersSource = getPerunBl().getExtSourcesManagerBl().getExtSourceByName(sess, membersExtSourceName);\n+   return membersSource;\n+  //Otherwise use use the group one\n+  } else {\n+   return defaultSource;\n+  }\n+ }\n+\n+ /**\n+  * Get ExtSource by name from attribute group:groupExtSource\n+  *\n+  * @param sess\n+  * @param group to be synchronized\n+  *\n+  * @return default group extSource for synchronization\n+  *\n+  * @throws InternalErrorException if some internal error happens or attribute with extSource name is null\n+  * @throws WrongAttributeAssignmentException if bad assignment of groupExtSource attribute\n+  * @throws AttributeNotExistsException if groupExtSource attribute not exists in perun Database\n+  * @throws ExtSourceNotExistsException if extSource set in Group attribute not exists\n+  */\n+\n+\n+ private ExtSource getGroupExtSourceForSynchronization(PerunSession sess, Group group) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException, ExtSourceNotExistsException {\n+  //Get extSource name from group attribute\n+  Attribute extSourceNameAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPEXTSOURCE_ATTRNAME);\n+  if (extSourceNameAttr == null || extSourceNameAttr.getValue() == null) {\n+   throw new InternalErrorException(\"ExtSource is not set for group: \" + group);\n+  }\n+  //return extSource by name\n+\n+  return getPerunBl().getExtSourcesManagerBl().getExtSourceByName(sess, ((String) extSourceNameAttr.getValue()));\n+ }\n+\n+ /**\n+  * From membersSource extSource get attribute overwriteUserAttributes and prepare\n+  * list of attributes names to be overwrite for synchronized users.\n+  *\n+  * Attribute has value (if set) in format \"name,name2,name3...\"\n+  * Method parse these names to list of names.\n+  * Return empty array if attribute is not set for extSource or if it is empty.\n+  *\n+  * @param membersSource to get attributes from\n+  *\n+  * @return list of attribute names to be overwrite\n+  *\n+  * @throws InternalErrorException if something happens in getting attributes from membersSource\n+  */\n+\n+\n+ private List<String> getOverwriteUserAttributesListFromExtSource(ExtSource membersSource) throws InternalErrorException {\n+  Map<String, String> membersSourceAttributes = getPerunBl().getExtSourcesManagerBl().getAttributes(membersSource);\n+  List<String> overwriteUserAttributesList = new ArrayList<>();\n+  String overwriteUserAttributes = membersSourceAttributes.get(\"overwriteUserAttributes\");\n+  if (overwriteUserAttributes != null && !overwriteUserAttributes.isEmpty()) {\n+   //remove all white spaces and invisible characters\n+   overwriteUserAttributes = overwriteUserAttributes.replaceAll(\"\\\\s\", \"\");\n+   overwriteUserAttributesList = Arrays.asList(overwriteUserAttributes.split(\",\"));\n+  }\n+\n+  return overwriteUserAttributesList;\n+ }\n+\n+ /**\n+  * Return true if attribute group:lightweightSynchronization is set to true.\n+  * False if not.\n+  *\n+  * True means: we don't want to update existing members (attributes, statuses etc.), just\n+  * add new members and remove former members\n+  * False means: we want to do whole synchronization process including updating operations\n+  *\n+  * @param sess\n+  * @param group to be synchronized\n+  *\n+  * @return true if this is lightweightSynchronization, false if not\n+  *\n+  * @throws InternalErrorException if something happens while getting lightweightSynchronization attribute\n+  * @throws WrongAttributeAssignmentException if bad assignment of lightweightSynchronization attribute\n+  * @throws AttributeNotExistsException if lightweightSynchronization attribute not exists in perun Database\n+  */\n+\n+\n+ private boolean isThisLightweightSynchronization(PerunSession sess, Group group) throws InternalErrorException, WrongAttributeAssignmentException, AttributeNotExistsException {\n+  Attribute lightweightSynchronzationAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, GroupsManager.GROUPLIGHTWEIGHTSYNCHRONIZATION_ATTRNAME);\n+  boolean lightweightSynchronization = false;\n+  if (lightweightSynchronzationAttr != null && lightweightSynchronzationAttr.getValue() != null) {\n+   lightweightSynchronization = (Boolean) lightweightSynchronzationAttr.getValue();\n+  }\n+\n+  return lightweightSynchronization;\n+ }\n+\n+ /**\n+  * Return List of subjects, where subject is map of attribute names and attribute values.\n+  * Every subject is structure for creating Candidate from ExtSource.\n+  *\n+  * @param sess\n+  * @param source to get subjects from\n+  * @param group to be synchronized\n+  *\n+  * @return list of subjects\n+  *\n+  * @throws InternalErrorException if internal error occurs\n+  */\n+\n+\n+ private List<Map<String, String>> getSubjectsFromExtSource(PerunSession sess, ExtSource source, Group group) throws InternalErrorException {\n+  //Get all group attributes and store tham to map (info like query, time interval etc.)\n+  List<Attribute> groupAttributes = getPerunBl().getAttributesManagerBl().getAttributes(sess, group);\n+  Map<String, String> groupAttributesMap = new HashMap<String, String>();\n+  for (Attribute attr : groupAttributes) {\n+   String value = BeansUtils.attributeValueToString(attr);\n+   String name = attr.getName();\n+   groupAttributesMap.put(name, value);\n+  }\n+  //-- Get Subjects in form of map where left string is name of attribute and right string is value of attribute, every subject is one map\n+  List<Map<String, String>> subjects;\n+  try {\n+   subjects = ((ExtSourceSimpleApi) source).getGroupSubjects(groupAttributesMap);\n+   log.debug(\"Group synchronization {}: external group contains {} members.\", group, subjects.size());\n+  } catch (ExtSourceUnsupportedOperationException e2) {\n+   throw new InternalErrorException(\"ExtSource \" + source.getName() + \" doesn't support getGroupSubjects\", e2);\n+  }\n+\n+  return subjects;\n+ }\n+\n+ /**\n+  * Convert List of subjects to list of Candidates.\n+  *\n+  * To getting Candidate can use 1 of 3 possible options:\n+  * 1] membersSource and source are not equals => we have just login, other attributes neet to get from membersSource\n+  * 2] membersSource==source and membersSource is instance of ExtSourceApi => we already have all attributes in subject\n+  * 3] membersSource==source and membersSource is instance of SimplExtSourceApi => we have just login, need to read other attributes again\n+  *\n+  * If candidate cannot be get for some reason, add this reason to skippedMembers list and skip him.\n+  *\n+  * @param sess\n+  * @param subjects list of subjects from ExtSource (at least login should be here)\n+  * @param membersSource optional member ExtSource (if members attributes are from other source then their logins)\n+  * @param source default group ExtSource\n+  * @param skippedMembers not successfully synchronized members are skipped and information about it should be added here\n+  *\n+  * @return list of successfully created candidates from subjects\n+  *\n+  * @throws InternalErrorException if some internal error occurs\n+  * @throws ExtSourceNotExistsException if membersSource not exists in Perun\n+  */\n+\n+\n+ private List<Candidate> convertSubjectsToCandidates(PerunSession sess, List<Map<String, String>> subjects, ExtSource membersSource, ExtSource source, List<String> skippedMembers) throws InternalErrorException, ExtSourceNotExistsException {\n+  List<Candidate> candidates = new ArrayList<>();\n+  for (Map<String, String> subject : subjects) {\n+   String login = subject.get(\"login\");\n+   // Skip subjects, which doesn't have login\n+   if (login == null || login.isEmpty()) {\n+    log.debug(\"Subject {} doesn't contain attribute login, skipping.\", subject);\n+    skippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because login is missing\");\n+    continue;\n+   }\n+\n+   try {\n+    // One of three possible ways should happen to get Candidate\n+    // 1] sources of login and other attributes are not same\n+    if (!membersSource.equals(source)) {\n+     //need to read attributes from the new memberSource, we can't use locally data there (there are from other extSource)\n+     candidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, membersSource, login)));\n+    // 2] sources are same and we work with source which is instance of ExtSourceApi\n+    } else if (membersSource instanceof ExtSourceApi) {\n+     // we can use the data from this source without reading them again (all exists in the map of subject attributes)\n+     candidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, subject, membersSource, login)));\n+    // 3] sources are same and we work with source which is instace of ExtSourceSimpleApi\n+    } else if (membersSource instanceof ExtSourceSimpleApi) {\n+     // we can't use the data from this source, we need to read them again (they are not in the map of subject attributes)\n+            candidates.add((getPerunBl().getExtSourcesManagerBl().getCandidate(sess, membersSource, login)));\n+           } else {\n+     // this could not happen without change in extSource API code\n+            throw new InternalErrorException(\"ExtSource is other instance than SimpleApi or Api and this is not supported!\");\n+           }\n+   } catch (CandidateNotExistsException e) {\n+    log.warn(\"getGroupSubjects subjects returned login {}, but it cannot be obtained using getCandidate()\", login);\n+    skippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because candidate can't be found by login:'\" + login + \"' in extSource \" + membersSource);\n+    continue;\n+   } catch (ExtSourceUnsupportedOperationException e) {\n+    log.warn(\"ExtSource {} doesn't support getCandidate operation.\", membersSource);\n+    skippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because extSource \" + membersSource + \" not support method getCandidate\");\n+    continue;\n+   } catch (ParserException e) {\n+    log.warn(\"Can't parse value {} from candidate with login {}\", e.getParsedValue(), login);\n+    skippedMembers.add(\"MemberEntry:[\" + subject + \"] was skipped because of problem with parsing value '\" + e.getParsedValue() + \"'\");\n+    continue;\n+   }\n+  }\n+\n+  return candidates;\n+ }\n+\n+ /**\n+  * Get Map membersToUpdate and update their attributes, extSources, expirations and statuses.\n+  *\n+  * For Member - updateAttributes\n+  * For User - updateAttributes if exists in list of overwriteUserAttributesList,\n+  *            in other case just mergeAttributes.\n+  *\n+  * updateAttributes = store new values\n+  * mergeAttributes = for List and Map add new values, do not remove old one,\n+  *                   for other cases store new values (like String, Integer etc.)\n+  *\n+  *\n+  * @param sess\n+  * @param group to be synchronized\n+  * @param membersToUpdate list of members for updating in Perun by information from extSource\n+  * @param overwriteUserAttributesList list of user attributes to be updated instead of merged\n+  *\n+  * @throws InternalErrorException if some internal error occurs\n+  * @throws AttributeNotExistsException if some attributes not exists and for this reason can't be updated\n+  * @throws WrongAttributeAssignmentException if some attribute is updated in bad way (bad assignment)\n+  */\n+\n+\n+ private void updateExistingMembersWhileSynchronization(PerunSession sess, Group group, Map<Candidate, RichMember> membersToUpdate, List<String> overwriteUserAttributesList) throws InternalErrorException, AttributeNotExistsException, WrongAttributeAssignmentException {\n+  List<AttributeDefinition> attrDefs = new ArrayList<>();\n+  //Iterate through all subject attributes\n+  for (Candidate candidate : membersToUpdate.keySet()) {\n+   RichMember richMember = membersToUpdate.get(candidate);\n+\n+   //If member not exists in this moment (somebody remove him before start of updating), skip him and log it\n+   try {\n+    getPerunBl().getMembersManagerBl().checkMemberExists(sess, richMember);\n+   } catch (MemberNotExistsException ex) {\n+    //log it and skip this member\n+    log.debug(\"Someone removed member {} from group {} before updating process. Skip him.\", richMember, group);\n+    continue;\n+   }\n+\n+   //load attrDefinitions just once for first candidate\n+   if (attrDefs.isEmpty()) {\n+\n+    for (String attrName : candidate.getAttributes().keySet()) {\n+     try {\n+      AttributeDefinition attrDef = getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attrName);\n+      attrDefs.add(attrDef);\n+     } catch (AttributeNotExistsException ex) {\n+      log.error(\"Can't synchronize attribute \" + attrName + \" for candidate \" + candidate + \" and for group \" + group);\n+      //skip this attribute at all\n+     }\n+    }\n+   }\n+\n+   //get RichMember with attributes\n+   richMember = getPerunBl().getMembersManagerBl().convertMembersToRichMembersWithAttributes(sess, Arrays.asList(richMember), attrDefs).get(0);\n+   for (String attributeName : candidate.getAttributes().keySet()) {\n+    //update member attribute\n+    if (attributeName.startsWith(AttributesManager.NS_MEMBER_ATTR)) {\n+\n+     boolean attributeFound = false;\n+     for (Attribute memberAttribute : richMember.getMemberAttributes()) {\n+      if (memberAttribute.getName().equals(attributeName)) {\n+       attributeFound = true;\n+       Object subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), memberAttribute.getType());\n+       if (subjectAttributeValue != null && !memberAttribute.getValue().equals(subjectAttributeValue)) {\n+        log.trace(\"Group synchronization {}: value of the attribute {} for memberId {} changed. Original value {}, new value {}.\", new Object[] {group, memberAttribute, richMember.getId(), memberAttribute.getValue(), subjectAttributeValue});\n+        memberAttribute.setValue(subjectAttributeValue);\n+\n+        try {\n+         getPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember, memberAttribute);\n+        } catch (AttributeValueException e) {\n+         // There is a problem with attribute value, so set INVALID status for the member\n+         getPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n+        } catch (WrongAttributeAssignmentException e) {\n+         throw new ConsistencyErrorException(e);\n+        }\n+       }\n+       //we found it, but there is no change;\n+       break;\n+      }\n+     }\n+     //member has not set this attribute so set it now if possible\n+     if (!attributeFound) {\n+      Attribute newAttribute = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attributeName));\n+      Object subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), newAttribute.getType());\n+      newAttribute.setValue(subjectAttributeValue);\n+\n+      try {\n+       // Try to set member's attributes\n+       getPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember, newAttribute);\n+       log.trace(\"Setting the {} value {}\", newAttribute, candidate.getAttributes().get(attributeName));\n+      } catch (AttributeValueException e) {\n+       // There is a problem with attribute value, so set INVALID status for the member\n+       getPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n+      }\n+     }\n+    //update user attribute\n+    } else if (attributeName.startsWith(AttributesManager.NS_USER_ATTR)) {\n+\n+     boolean attributeFound = false;\n+     for (Attribute userAttribute : richMember.getUserAttributes()) {\n+      if (userAttribute.getName().equals(attributeName)) {\n+       attributeFound = true;\n+       Object subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), userAttribute.getType());\n+       if (!userAttribute.getValue().equals(subjectAttributeValue)) {\n+        log.trace(\"Group synchronization {}: value of the attribute {} for memberId {} changed. Original value {}, new value {}.\", new Object[] {group, userAttribute, richMember.getId(), userAttribute.getValue(), subjectAttributeValue});\n+        userAttribute.setValue(subjectAttributeValue);\n+\n+        try {\n+         //Choose set or merge by extSource attribute overwriteUserAttributes (if contains this one)\n+         if (overwriteUserAttributesList.contains(userAttribute.getName())) {\n+          getPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember.getUser(), userAttribute);\n+         } else {\n+          getPerunBl().getAttributesManagerBl().mergeAttributeValueInNestedTransaction(sess, richMember.getUser(), userAttribute);\n+         }\n+        } catch (AttributeValueException e) {\n+         // There is a problem with attribute value, so set INVALID status for the member\n+         getPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n+        } catch (WrongAttributeAssignmentException e) {\n+         throw new ConsistencyErrorException(e);\n+        }\n+       }\n+       //we found it, but there is no change\n+       break;\n+      }\n+     }\n+     //user has not set this attribute so set it now if\n+     if (!attributeFound) {\n+      Attribute newAttribute = new Attribute(getPerunBl().getAttributesManagerBl().getAttributeDefinition(sess, attributeName));\n+      Object subjectAttributeValue = getPerunBl().getAttributesManagerBl().stringToAttributeValue(candidate.getAttributes().get(attributeName), newAttribute.getType());\n+      newAttribute.setValue(subjectAttributeValue);\n+\n+      try {\n+       // Try to set user's attributes\n+       getPerunBl().getAttributesManagerBl().setAttributeInNestedTransaction(sess, richMember.getUser(), newAttribute);\n+       log.trace(\"Setting the {} value {}\", newAttribute, candidate.getAttributes().get(attributeName));\n+      } catch (AttributeValueException e) {\n+       // There is a problem with attribute value, so set INVALID status for the member\n+       getPerunBl().getMembersManagerBl().invalidateMember(sess, richMember);\n+      }\n+     }\n+    } else {\n+     //we are not supporting other attributes then member or user so skip it without error, but log it\n+     log.error(\"Attribute {} can't be set, because it is not member or user attribute.\", attributeName);\n+    }\n+   }\n+\n+   //Synchronize userExtSources (add not existing)\n+\n+   for (UserExtSource ues : candidate.getUserExtSources()) {\n+    if (!getPerunBl().getUsersManagerBl().userExtSourceExists(sess, ues)) {\n+     try {\n+      getPerunBl().getUsersManagerBl().addUserExtSource(sess, richMember.getUser(), ues);\n+     } catch (UserExtSourceExistsException e) {\n+      throw new ConsistencyErrorException(\"Adding already existing userExtSource \" + ues, e);\n+     }\n+    }\n+   }\n+\n+   //Set correct member Status\n+   // If the member has expired or disabled status, try to expire/validate him (depending on expiration date)\n+   if (richMember.getStatus().equals(Status.DISABLED) || richMember.getStatus().equals(Status.EXPIRED)) {\n+    Date now = new Date();\n+    Attribute membershipExpiration = getPerunBl().getAttributesManagerBl().getAttribute(sess, richMember, AttributesManager.NS_MEMBER_ATTR_DEF + \":membershipExpiration\");\n+    if (membershipExpiration.getValue() != null) {\n+     try {\n+      Date currentMembershipExpirationDate = BeansUtils.getDateFormatterWithoutTime().parse((String) membershipExpiration.getValue());\n+      if (currentMembershipExpirationDate.before(now)) {\n+       //disabled members which are after expiration date will be expired\n+       if (richMember.getStatus().equals(Status.DISABLED)) {\n+        try {\n+         perunBl.getMembersManagerBl().expireMember(sess, richMember);\n+         log.info(\"Switching member id {} to EXPIRE state, due to expiration {}.\",\n+         richMember.getId(),\n+          (String) membershipExpiration.getValue());\n+         log.debug(\"Switching member to EXPIRE state, additional info: membership expiration date='{}', system now date='{}'\", currentMembershipExpirationDate, now);\n+        } catch (MemberNotValidYetException e) {\n+         log.error(\"Consistency error while trying to expire member id {}, exception {}\", richMember.getId(), e);\n+        }\n+       }\n+      } else {\n+       //disabled and expired members which are before expiration date will be validated\n+       try {\n+        perunBl.getMembersManagerBl().validateMember(sess, richMember);\n+        log.info(\"Switching member id {} to VALID state, due to expiration {}.\",\n+        richMember.getId(),\n+         (String) membershipExpiration.getValue());\n+        log.debug(\"Switching member to VALID state, additional info: membership expiration date='{}', system now date='{}'\", currentMembershipExpirationDate, now);\n+       } catch (WrongAttributeValueException e) {\n+        log.error(\"Error during validating member id {}, exception {}\", richMember.getId(), e);\n+       } catch (WrongReferenceAttributeValueException e) {\n+        log.error(\"Error during validating member id {}, exception {}\", richMember.getId(), e);\n+       }\n+      }\n+     } catch (ParseException ex) {\n+      log.error(\"Group synchronization: memberId {} expiration String cannot be parsed, exception {}.\",\n+      richMember.getId(),\n+      ex);\n+     }\n+    }\n+   }\n+\n+   // If the member has INVALID status, try to validate the member\n+\n+   try {\n+    if (richMember.getStatus().equals(Status.INVALID)) {\n+     getPerunBl().getMembersManagerBl().validateMember(sess, richMember);\n+    }\n+   } catch (WrongAttributeValueException e) {\n+    log.info(\"Member id {} will stay in INVALID state, because there was problem with attributes {}.\",\n+    richMember.getId(),\n+    e);\n+   } catch (WrongReferenceAttributeValueException e) {\n+    log.info(\"Member id {} will stay in INVALID state, because there was problem with attributes {}.\",\n+    richMember.getId(),\n+    e);\n+   }\n+\n+   // If the member has still DISABLED status, try to validate the member\n+\n+   try {\n+    if (richMember.getStatus().equals(Status.DISABLED)) {\n+     getPerunBl().getMembersManagerBl().validateMember(sess, richMember);\n+    }\n+   } catch (WrongAttributeValueException e) {\n+    log.info(\"Switching member id {} into INVALID state from DISABLED, because there was problem with attributes {}.\", richMember.getId(), e);\n+   } catch (WrongReferenceAttributeValueException e) {\n+    log.info(\"Switching member id {} into INVALID state from DISABLED, because there was problem with attributes {}.\", richMember.getId(), e);\n+   }\n+  }\n+ }\n+\n+ /**\n+  * Get list of new candidates and add them to the Group.\n+  *\n+  * If Candidate can't be added to Group, skip him and add this information to skippedMembers list.\n+  *\n+  * When creating new member from Candidate, if user already exists, merge his attributes,\n+  * if attribute exists in list of overwriteUserAttributesList, update it instead of merging.\n+  *\n+  * @param sess\n+  * @param group to be synchronized\n+  * @param candidatesToAdd list of new members (candidates)\n+  * @param overwriteUserAttributesList list of attributes to be updated for user if found\n+  * @param skippedMembers list of not successfully synchronized members\n+  *\n+  * @throws InternalErrorException if some internal error occurs\n+  */\n+\n+\n+ private void addMissingMembersWhileSynchronization(PerunSession sess, Group group, List<Candidate> candidatesToAdd, List<String> overwriteUserAttributesList, List<String> skippedMembers) throws InternalErrorException, GroupOperationsException {\n+  // Now add missing members\n+\n+  for (Candidate candidate : candidatesToAdd) {\n+   Member member = null;\n+   try {\n+    // Check if the member is already in the VO (just not in the group)\n+    member = getPerunBl().getMembersManagerBl().getMemberByUserExtSources(sess, getPerunBl().getGroupsManagerBl().getVo(sess, group), candidate.getUserExtSources());\n+\n+    // member exists - update attributes\n+    Map<Candidate, RichMember> memberMap = new HashMap<>();\n+    memberMap.put(candidate, getPerunBl().getMembersManagerBl().getRichMember(sess, member));\n+\n+    try {\n+     updateExistingMembersWhileSynchronization(sess, group, memberMap, overwriteUserAttributesList);\n+    } catch (WrongAttributeAssignmentException | AttributeNotExistsException e) {\n+     // if update fails, skip him\n+     log.warn(\"Can't update member from candidate {} due to attribute value exception {}.\", candidate, e);\n+     skippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because there was problem when updating member from candidate: Exception: \" + e.getName() + \" => '\" + e.getMessage() + \"'\");\n+     continue;\n+    }\n+   } catch (MemberNotExistsException e) {\n+    try {\n+     // We have new member (candidate), so create him using synchronous createMember (and overwrite chosed user attributes)\n+     member = getPerunBl().getMembersManagerBl().createMemberSync(sess, getPerunBl().getGroupsManagerBl().getVo(sess, group), candidate, null, overwriteUserAttributesList);\n+     log.info(\"Group synchronization {}: New member id {} created during synchronization.\", group, member.getId());\n+    } catch (AlreadyMemberException e1) {\n+     throw new ConsistencyErrorException(\"Trying to add existing member\");\n+    } catch (AttributeValueException e1) {\n+     log.warn(\"Can't create member from candidate {} due to attribute value exception {}.\", candidate, e1);\n+     skippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because there was problem when createing member from candidate: Exception: \" + e1.getName() + \" => '\" + e1.getMessage() + \"'\");\n+     continue;\n+    } catch (ExtendMembershipException ex) {\n+     log.warn(\"Can't create member from candidate {} due to membership expiration exception {}.\", candidate, ex);\n+     skippedMembers.add(\"MemberEntry:[\" + candidate + \"] was skipped because membership expiration: Exception: \" + ex.getName() + \" => \" + ex.getMessage() + \"]\");\n+     continue;\n+    }\n+   }\n+\n+   try {\n+    // Add the member to the group\n+    if (!group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+     // Do not add members to the generic members group\n+     try {\n+      getPerunBl().getGroupsManagerBl().addMember(sess, group, member);\n+     } catch (NotMemberOfParentGroupException | GroupNotExistsException ex) {\n+      // Shouldn't happen, because every group has at least Members group as a parent\n+      // Shouldn't happen, group should always exist\n+      throw new ConsistencyErrorException(ex);\n+     }\n+    }\n+    log.info(\"Group synchronization {}: New member id {} added.\", group, member.getId());\n+   } catch (AlreadyMemberException e) {\n+    //This part is ok, it means someone add member before synchronization ends, log it and skip this member\n+    log.debug(\"Member {} was added to group {} before adding process. Skip this member.\", member, group);\n+    continue;\n+   } catch (AttributeValueException e) {\n+    // There is a problem with attribute value, so set INVALID status of the member\n+    getPerunBl().getMembersManagerBl().invalidateMember(sess, member);\n+   }\n+\n+   // Try to validate member\n+\n+   try {\n+    getPerunBl().getMembersManagerBl().validateMember(sess, member);\n+   } catch (AttributeValueException e) {\n+    log.warn(\"Member id {} will be in INVALID status due to wrong attributes {}.\", member.getId(), e);\n+   }\n+  }\n+ }\n+\n+ /**\n+  * Remove former members from group (if they are not listed in ExtSource yet).\n+  *\n+  * If this is membersGroup (of some Vo) try to disableMember, if not possible then delete him.\n+  * If this is regular group (of some Vo) remove him and if this group is also\n+  * his last authoritative group, disable or delete him also in the Vo.\n+  *\n+  * @param sess\n+  * @param group to be synchronized\n+  * @param membersToRemove list of members to be removed from Group\n+  *\n+  * @throws InternalErrorException if some internal error occurs\n+  * @throws WrongAttributeAssignmentException if there is some problem with assignment of attribute\n+  * @throws MemberAlreadyRemovedException if member is already out of group when we trying to do this by synchronization\n+  */\n+\n+\n+ private void removeFormerMembersWhileSynchronization(PerunSession sess, Group group, List<RichMember> membersToRemove) throws InternalErrorException, WrongAttributeAssignmentException, MemberAlreadyRemovedException, GroupOperationsException, GroupNotExistsException {\n+  //First get information if this group is authoritative group\n+\n+                                                                                                                                                                                                                                                                            boolean thisGroupIsAuthoritativeGroup = false;\n+                                                                                                                                                                                                                                                                            try {\n+                                                                                                                                                                                                                                                                             Attribute authoritativeGroupAttr = getPerunBl().getAttributesManagerBl().getAttribute(sess, group, A_G_D_AUTHORITATIVE_GROUP);\n+                                                                                                                                                                                                                                                                             if (authoritativeGroupAttr.getValue() != null) {\n+                                                                                                                                                                                                                                                                              Integer authoritativeGroupValue = (Integer) authoritativeGroupAttr.getValue();\n+                                                                                                                                                                                                                                                                              if (authoritativeGroupValue == 1) thisGroupIsAuthoritativeGroup = true;\n+                                                                                                                                                                                                                                                                             }\n+                                                                                                                                                                                                                                                                            } catch (AttributeNotExistsException ex) {\n+   //Means that this group is not authoritative\n+                                                                                                                                                                                                                                                                             log.error(\"Attribute {} doesn't exists.\", A_G_D_AUTHORITATIVE_GROUP);\n+                                                                                                                                                                                                                                                                            }\n+\n+  //Second remove members (use authoritative group where is needed)\n+\n+                                                                                                                                                                                                                                                                            for (RichMember member : membersToRemove) {\n+   // Member is missing in the external group, so remove him from the perun group\n+                                                                                                                                                                                                                                                                             try {\n+    //members group\n+                                                                                                                                                                                                                                                                              if (group.getName().equals(VosManager.MEMBERS_GROUP)) {\n+     // If the group is members group, the member must be disabled as a member of VO\n+                                                                                                                                                                                                                                                                               try {\n+                                                                                                                                                                                                                                                                                getPerunBl().getMembersManagerBl().disableMember(sess, member);\n+                                                                                                                                                                                                                                                                                log.info(\"Group synchronization {}: Member id {} disabled.\", group, member.getId());\n+                                                                                                                                                                                                                                                                               } catch (MemberNotValidYetException ex) {\n+      //Member is still invalid in perun. We can delete him.\n+                                                                                                                                                                                                                                                                                getPerunBl().getMembersManagerBl().deleteMember(sess, member);\n+                                                                                                                                                                                                                                                                                log.info(\"Group synchronization {}: Member id {} would have been disabled but he has been deleted instead because he was invalid.\", group, member.getId());\n+                                                                                                                                                                                                                                                                               }\n+     //not members group\n+                                                                                                                                                                                                                                                                              } else {\n+     //If this group is authoritative group, check if this is last authoritative group of this member\n+     //If Yes = deleteMember (from Vo), if No = only removeMember\n+                                                                                                                                                                                                                                                                               if (thisGroupIsAuthoritativeGroup) {\n+                                                                                                                                                                                                                                                                                List<Group> memberAuthoritativeGroups = null;\n+                                                                                                                                                                                                                                                                                try {\n+                                                                                                                                                                                                                                                                                 memberAuthoritativeGroups = getAllAuthoritativeGroupsOfMember(sess, member);\n+                                                                                                                                                                                                                                                                                } catch (AttributeNotExistsException ex) {\n+       //This means that no authoritative group can exists without this attribute\n+                                                                                                                                                                                                                                                                                 log.error(\"Attribute {} doesn't exists.\", A_G_D_AUTHORITATIVE_GROUP);\n+                                                                                                                                                                                                                                                                                }\n+\n+      //If list of member authoritativeGroups is not null, attribute exists\n+                                                                                                                                                                                                                                                                                if (memberAuthoritativeGroups != null) {\n+                                                                                                                                                                                                                                                                                 memberAuthoritativeGroups.remove(group);\n+                                                                                                                                                                                                                                                                                 if (memberAuthoritativeGroups.isEmpty()) {\n+        //First try to disable member, if is invalid, delete him from Vo\n+                                                                                                                                                                                                                                                                                  try {\n+                                                                                                                                                                                                                                                                                   getPerunBl().getMembersManagerBl().disableMember(sess, member);\n+                                                                                                                                                                                                                                                                                   log.info(\"Group synchronization {}: Member id {} disabled because synchronizer wants to remove him from last authoritativeGroup in Vo.\", group, member.getId());\n+                                                                                                                                                                                                                                                                                   getPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n+                                                                                                                                                                                                                                                                                   log.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n+                                                                                                                                                                                                                                                                                  } catch (MemberNotValidYetException ex) {\n+         //Member is still invalid in perun. We can delete him.\n+                                                                                                                                                                                                                                                                                   getPerunBl().getMembersManagerBl().deleteMember(sess, member);\n+                                                                                                                                                                                                                                                                                   log.info(\"Group synchronization {}: Member id {} would have been disabled but he has been deleted instead because he was invalid and synchronizer wants to remove him from last authoritativeGroup in Vo.\", group, member.getId());\n+                                                                                                                                                                                                                                                                                  }\n+                                                                                                                                                                                                                                                                                 } else {\n+        //If there is still some other authoritative group for this member, only remove him from group\n+                                                                                                                                                                                                                                                                                  getPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n+                                                                                                                                                                                                                                                                                  log.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n+                                                                                                                                                                                                                                                                                 }\n+       //If list of member authoritativeGroups is null, attribute not exists, only remove member from Group\n+                                                                                                                                                                                                                                                                                } else {\n+                                                                                                                                                                                                                                                                                 getPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n+                                                                                                                                                                                                                                                                                 log.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n+                                                                                                                                                                                                                                                                                }\n+                                                                                                                                                                                                                                                                               } else {\n+                                                                                                                                                                                                                                                                                getPerunBl().getGroupsManagerBl().removeMember(sess, group, member);\n+                                                                                                                                                                                                                                                                                log.info(\"Group synchronization {}: Member id {} removed.\", group, member.getId());\n+                                                                                                                                                                                                                                                                               }\n+                                                                                                                                                                                                                                                                              }\n+                                                                                                                                                                                                                                                                             } catch (NotGroupMemberException e) {\n+                                                                                                                                                                                                                                                                              throw new ConsistencyErrorException(\"Trying to remove non-existing user\");\n+                                                                                                                                                                                                                                                                             } catch (MemberAlreadyRemovedException ex) {\n+    //Member was probably removed before starting of synchronization removing process, log it and skip this member\n+                                                                                                                                                                                                                                                                              log.debug(\"Member {} was removed from group {} before removing process. Skip this member.\", member, group);\n+                                                                                                                                                                                                                                                                              continue;\n+                                                                                                                                                                                                                                                                             }\n+                                                                                                                                                                                                                                                                            }\n+ }\n+\n+ /**\n+  * Try to close both extSources (membersSource and group source)\n+  *\n+  * @param membersSource optional membersSource\n+  * @param source default groupSource\n+  */\n+\n+\n+ private void closeExtSourcesAfterSynchronization(ExtSource membersSource, ExtSource source) {\n+  //Close open extSources (not empty ones) if they support this operation\n+  if (membersSource != null) {\n+   try {\n+    ((ExtSourceSimpleApi) membersSource).close();\n+   } catch (ExtSourceUnsupportedOperationException e) {\n+    // ExtSource doesn't support that functionality, so silently skip it.\n+\n+   } catch (InternalErrorException e) {\n+    log.info(\"Can't close membersSource connection. Cause: {}\", e);\n+   }\n+  }\n+  if (source != null) {\n+   try {\n+    ((ExtSourceSimpleApi) source).close();\n+   } catch (ExtSourceUnsupportedOperationException e) {\n+    // ExtSource doesn't support that functionality, so silently skip it.\n+\n+   } catch (InternalErrorException e) {\n+    log.info(\"Can't close extSource connection. Cause: {}\", e);\n+   }\n+  }\n+ }\n+\n+ @Override\n+ public void processRelationMembers(PerunSession sess, Group resultGroup, List<Member> changedMembers, int sourceGroupId, boolean addition) throws GroupOperationsException {\n+  List<Member> newMembers;\n+  try {\n+   if (addition) {\n+    newMembers = addIndirectMembers(sess, resultGroup, changedMembers, sourceGroupId);\n+   } else {\n+    newMembers = removeIndirectMembers(sess, resultGroup, changedMembers, sourceGroupId);\n+   }\n+   if (newMembers.isEmpty()) {\n+    return;\n+   }\n+   List<Integer> relations = groupsManagerImpl.getResultGroupsIds(sess, resultGroup.getId());\n+   for (Integer groupId : relations) {\n+    processRelationMembers(sess, groupsManagerImpl.getGroupById(sess, groupId), newMembers, resultGroup.getId(), addition);\n+   }\n+  } catch (WrongReferenceAttributeValueException |WrongAttributeValueException| AlreadyMemberException| InternalErrorException| NotGroupMemberException| GroupNotExistsException ex) {\n+   throw new GroupOperationsException(ex);\n+  }\n+ }\n+\n+ @Override\n+ public Group createGroupUnion(PerunSession sess, Group resultGroup, Group operandGroup, boolean parentFlag) throws GroupOperationsException, InternalErrorException, GroupRelationAlreadyExists, GroupRelationNotAllowed {\n+\n+  // block inclusion to members group, since it doesn't make sense\n+  // allow inclusion of members group, since we want to delegate privileges on assigning all vo members to some service for group manager.\n+  if (resultGroup.getName().equals(VosManager.MEMBERS_GROUP)) {\n+   throw new GroupRelationNotAllowed(\"Union cannot be created when result group \" + resultGroup + \" is members group.\");\n+  }\n+\n+  // check if both groups are from same VO\n+  if (resultGroup.getVoId() != operandGroup.getVoId()) {\n+   throw new GroupRelationNotAllowed(\"Union cannot be created on groups: \" + resultGroup + \", \" + operandGroup + \". They are not from the same VO.\");\n+  }\n+\n+  // check if result group is the same as operand group\n+  if (resultGroup.getId() == operandGroup.getId()) {\n+   throw new GroupRelationNotAllowed(\"Result group \" + resultGroup + \" cannot be the same as operand group \" + operandGroup);\n+  } \n+\n+  // check if there is already a record of these two groups\n+  if (this.groupsManagerImpl.isRelationBetweenGroups(resultGroup, operandGroup)) {\n+   throw new GroupRelationAlreadyExists(\"There is already a relation defined between result group \" + resultGroup + \" and operand group \" + operandGroup + \" or they are in hierarchical structure.\");\n+  }\n+\n+  // check cycle between groups\n+  if (checkGroupsCycle(sess, resultGroup.getId(), operandGroup.getId())) {\n+   throw new GroupRelationNotAllowed(\"Union between result group \" + resultGroup + \" and operand group \" + operandGroup + \" would create group cycle.\");\n+  }\n+\n+  // save group relation\n+  groupsManagerImpl.saveGroupRelation(sess, resultGroup, operandGroup, parentFlag);\n+\n+  // do the operation logic\n+  processRelationMembers(sess, resultGroup, getGroupMembers(sess, operandGroup), operandGroup.getId(), true);\n+  return resultGroup;\n+ }\n+\n+ @Override\n+ public void removeGroupUnion(PerunSession sess, Group resultGroup, Group operandGroup, boolean parentFlag) throws GroupOperationsException, InternalErrorException, GroupRelationDoesNotExist, GroupRelationCannotBeRemoved {\n+  if (!groupsManagerImpl.isOneWayRelationBetweenGroups(resultGroup, operandGroup)) {\n+   throw new GroupRelationDoesNotExist(\"Union does not exist between result group \" + resultGroup + \" and operand group\" + operandGroup + \".\");\n+  }\n+  if (parentFlag || groupsManagerImpl.isRelationRemovable(sess, resultGroup, operandGroup)) {\n+   processRelationMembers(sess, resultGroup, getGroupMembers(sess, operandGroup), operandGroup.getId(), false);\n+  } else {\n+   throw new GroupRelationCannotBeRemoved(\"Union between result group \" + resultGroup + \" and operand group\" + operandGroup + \" cannot be removed, because it's part of the hierarchical structure of the groups.\");\n+  }\n+  groupsManagerImpl.removeGroupUnion(sess, resultGroup, operandGroup);\n+ }\n+\n+ @Override\n+ public List<Group> getGroupUnions(PerunSession session, Group group, boolean reverseDirection) throws InternalErrorException {\n+  if (reverseDirection) {\n+   return groupsManagerImpl.getResultGroups(session, group.getId());\n+  } else {\n+   return groupsManagerImpl.getOperandGroups(session, group.getId());\n+  }\n+ }\n+\n+ /**\n+  * Check if cycle would be created by adding union between these groups.\n+  *\n+  * @param sess perun session\n+  * @param resultGroupId result group id\n+  * @param operandGroupId operand group id\n+  * @return true if cycle would be created; false otherwise\n+  * @throws InternalErrorException\n+  */\n+\n+\n+ private boolean checkGroupsCycle(PerunSession sess, int resultGroupId, int operandGroupId) throws InternalErrorException {\n+  List<Integer> groupsIds = groupsManagerImpl.getResultGroupsIds(sess, resultGroupId);\n+  if (groupsIds.contains(operandGroupId)) {\n+   return true;\n+  }\n+\n+  for (Integer id : groupsIds) {\n+   if (checkGroupsCycle(sess, id, operandGroupId)) {\n+    return true;\n+   }\n+  }\n+\n+  return false;\n+ }\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 2432
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/341/GroupsManagerBlImpl.java\nindex 80d1b77abcd..2e81bfaeccd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_random/341/GroupsManagerBlImpl.java\n@@ -2345,7 +2345,7 @@ public class GroupsManagerBlImpl implements GroupsManagerBl {\n \t\t// check if result group is the same as operand group\n \t\tif (resultGroup.getId() == operandGroup.getId()) {\n \t\t\tthrow new GroupRelationNotAllowed(\"Result group \" + resultGroup + \" cannot be the same as operand group \" + operandGroup);\n-\t\t} \n+\t\t}\n \n \t\t// check if there is already a record of these two groups\n \t\tif (this.groupsManagerImpl.isRelationBetweenGroups(resultGroup, operandGroup)) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/341/GroupsManagerBlImpl.java\nindex 80d1b77abcd..315bff97204 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/errored/1/341/GroupsManagerBlImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/CESNET-perun/styler_three_grams/341/GroupsManagerBlImpl.java\n@@ -2345,7 +2345,7 @@ public class GroupsManagerBlImpl implements GroupsManagerBl {\n \t\t// check if result group is the same as operand group\n \t\tif (resultGroup.getId() == operandGroup.getId()) {\n \t\t\tthrow new GroupRelationNotAllowed(\"Result group \" + resultGroup + \" cannot be the same as operand group \" + operandGroup);\n-\t\t} \n+\t\t\t\t}\n \n \t\t// check if there is already a record of these two groups\n \t\tif (this.groupsManagerImpl.isRelationBetweenGroups(resultGroup, operandGroup)) {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}