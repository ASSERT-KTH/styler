{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "347",
    "information": {
        "errors": [
            {
                "line": "32",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "class ExprTokenizer\n{\n\t//\n\t// The tokens\n\t//\n\tpublic static String toString(final int token)",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "33",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/347/ExprTokenizer.java\nindex a0b9906552d..68c33f9d967 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/347/ExprTokenizer.java\n@@ -29,7 +29,7 @@ import org.genxdm.xpath.v10.ExprParseException;\n  */\r\n class ExprTokenizer\r\n {\r\n-\t//\r\n+//  // The tokens\r\n \t// The tokens\r\n \t//\r\n \tpublic static String toString(final int token)\r\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/347/ExprTokenizer.java\nindex a0b9906552d..9ff69cadda2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/347/ExprTokenizer.java\n@@ -3,7 +3,7 @@\n  * license details\r\n  * Portions copyright (c) 2002, Bill Lindsey : see copying.txt for license\r\n  * details\r\n- * \r\n+ *\r\n  * Portions copyright (c) 2009-2011 TIBCO Software Inc.\r\n  *\r\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n@@ -18,540 +18,511 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n+\r\n package org.genxdm.processor.xpath.v10.expressions;\r\n \r\n import org.genxdm.xpath.v10.ExprParseException;\r\n \r\n /**\r\n  * lexical analyser for XPath 1.0\r\n- * \r\n+ *\r\n  * @see http://www.w3c.org/TR/xpath\r\n  */\r\n-class ExprTokenizer\r\n-{\r\n-\t//\r\n-\t// The tokens\r\n-\t//\r\n-\tpublic static String toString(final int token)\r\n-\t{\r\n-\t\t// An enumeration would solve this problem...\r\n-\t\tswitch (token)\r\n-\t\t{\r\n-\t\t\tcase TOK_EOF:\r\n-\t\t\t{\r\n-\t\t\t\treturn \"EOF\";\r\n-\t\t\t}\r\n-\t\t\tdefault:\r\n-\t\t\t{\r\n-\t\t\t\treturn \"TOKEN[\".concat(Integer.toString(token)).concat(\"]\");\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n+class ExprTokenizer {\r\n+    //\r\n+    // The tokens\r\n+    //\r\n+    public static String toString(final int token) {\r\n+        // An enumeration would solve this problem...\r\n+        switch (token) {\r\n+            case TOK_EOF: {\r\n+                return \"EOF\";\r\n+            }\r\n+            default: {\r\n+                return \"TOKEN[\".concat(Integer.toString(token)).concat(\"]\");\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // end of string being tokenized\r\n+    static final int TOK_EOF = 0;\r\n+\r\n+    // a qName\r\n+    static final int TOK_QNAME = TOK_EOF + 1;\r\n+\r\n+    // \"*\" (wildcard) ?\r\n+    static final int TOK_STAR = TOK_QNAME + 1;\r\n+\r\n+    // \"foo:*\" ?\r\n+    static final int TOK_NAME_COLON_STAR = TOK_STAR + 1;\r\n+\r\n+    // \"@\" (attribute axis specifier)\r\n+    static final int TOK_AT = TOK_NAME_COLON_STAR + 1;\r\n+\r\n+    // \".\" (node self)\r\n+    static final int TOK_DOT = TOK_AT + 1;\r\n+\r\n+    // \"..\" parent axis\r\n+    static final int TOK_DOT_DOT = TOK_DOT + 1;\r\n+\r\n+    // \"comment(\"\r\n+    static final int TOK_COMMENT_LPAR = TOK_DOT_DOT + 1;\r\n+\r\n+    // \"processing-instruction(\" ??\r\n+    static final int TOK_PROCESSING_INSTRUCTION_LPAR = TOK_COMMENT_LPAR + 1;\r\n+\r\n+    // \"text(\"\r\n+    static final int TOK_TEXT_LPAR = TOK_PROCESSING_INSTRUCTION_LPAR + 1;\r\n+\r\n+    // \"node(\"\r\n+    static final int TOK_NODE_LPAR = TOK_TEXT_LPAR + 1;\r\n+\r\n+    // \"*\" ?? same as star?\r\n+    static final int TOK_MULTIPLY = TOK_NODE_LPAR + 1;\r\n+\r\n+    // \"(\"\r\n+    static final int TOK_LPAR = TOK_MULTIPLY + 1;\r\n+\r\n+    // \")\"\r\n+    static final int TOK_RPAR = TOK_LPAR + 1;\r\n+\r\n+    // \"[\"\r\n+    static final int TOK_LSQB = TOK_RPAR + 1;\r\n+\r\n+    // \"]\"\r\n+    static final int TOK_RSQB = TOK_LSQB + 1;\r\n+\r\n+    // 'xxx ' | \" xxx \"\r\n+    static final int TOK_LITERAL = TOK_RSQB + 1;\r\n+\r\n+    // [0-9].?[0-9]*\r\n+    static final int TOK_NUMBER = TOK_LITERAL + 1;\r\n+\r\n+    // e.g. \"ancestor-or-self::\"\r\n+    static final int TOK_AXIS = TOK_NUMBER + 1;\r\n+\r\n+    // \"foo(\"\r\n+    static final int TOK_FUNCTION_LPAR = TOK_AXIS + 1;\r\n+\r\n+    // ?? maybe: \"colonized name(\" ??\r\n+    static final int TOK_CNAME_LPAR = TOK_FUNCTION_LPAR + 1;\r\n+\r\n+    // \"$foo\"\r\n+    static final int TOK_VARIABLE_REF = TOK_CNAME_LPAR + 1;\r\n+\r\n+    // \"/\"\r\n+    static final int TOK_SLASH = TOK_VARIABLE_REF + 1;\r\n+\r\n+    // \"//\"\r\n+    static final int TOK_SLASH_SLASH = TOK_SLASH + 1;\r\n \r\n-\t// end of string being tokenized\r\n-\tstatic final int TOK_EOF = 0;\r\n+    // \"|\"\r\n+    static final int TOK_VBAR = TOK_SLASH_SLASH + 1;\r\n \r\n-\t// a qName\r\n-\tstatic final int TOK_QNAME = TOK_EOF + 1;\r\n+    // \",\"\r\n+    static final int TOK_COMMA = TOK_VBAR + 1;\r\n \r\n-\t// \"*\" (wildcard) ?\r\n-\tstatic final int TOK_STAR = TOK_QNAME + 1;\r\n+    // \"+\"\r\n+    static final int TOK_PLUS = TOK_COMMA + 1;\r\n \r\n-\t// \"foo:*\" ?\r\n-\tstatic final int TOK_NAME_COLON_STAR = TOK_STAR + 1;\r\n+    // \"-\"\r\n+    static final int TOK_MINUS = TOK_PLUS + 1;\r\n \r\n-\t// \"@\" (attribute axis specifier)\r\n-\tstatic final int TOK_AT = TOK_NAME_COLON_STAR + 1;\r\n+    // \"=\"\r\n+    static final int TOK_EQUALS = TOK_MINUS + 1;\r\n \r\n-\t// \".\" (node self)\r\n-\tstatic final int TOK_DOT = TOK_AT + 1;\r\n+    // \"!+\"\r\n+    static final int TOK_NOT_EQUALS = TOK_EQUALS + 1;\r\n \r\n-\t// \"..\" parent axis\r\n-\tstatic final int TOK_DOT_DOT = TOK_DOT + 1;\r\n+    // \">\"\r\n+    static final int TOK_GT = TOK_NOT_EQUALS + 1;\r\n \r\n-\t// \"comment(\"\r\n-\tstatic final int TOK_COMMENT_LPAR = TOK_DOT_DOT + 1;\r\n+    // \"<\"\r\n+    static final int TOK_LT = TOK_GT + 1;\r\n \r\n-\t// \"processing-instruction(\" ??\r\n-\tstatic final int TOK_PROCESSING_INSTRUCTION_LPAR = TOK_COMMENT_LPAR + 1;\r\n+    // \">=\"\r\n+    static final int TOK_GTE = TOK_LT + 1;\r\n \r\n-\t// \"text(\"\r\n-\tstatic final int TOK_TEXT_LPAR = TOK_PROCESSING_INSTRUCTION_LPAR + 1;\r\n+    // \"<=\"\r\n+    static final int TOK_LTE = TOK_GTE + 1;\r\n \r\n-\t// \"node(\"\r\n-\tstatic final int TOK_NODE_LPAR = TOK_TEXT_LPAR + 1;\r\n+    // \"and\"\r\n+    static final int TOK_AND = TOK_LTE + 1;\r\n \r\n-\t// \"*\" ?? same as star?\r\n-\tstatic final int TOK_MULTIPLY = TOK_NODE_LPAR + 1;\r\n+    // \"or\" (why is this different from TOK_VBAR?)\r\n+    static final int TOK_OR = TOK_AND + 1;\r\n \r\n-\t// \"(\"\r\n-\tstatic final int TOK_LPAR = TOK_MULTIPLY + 1;\r\n+    // \"mod\"\r\n+    static final int TOK_MOD = TOK_OR + 1;\r\n \r\n-\t// \")\"\r\n-\tstatic final int TOK_RPAR = TOK_LPAR + 1;\r\n+    // \"div\"\r\n+    static final int TOK_DIV = TOK_MOD + 1;\r\n \r\n-\t// \"[\"\r\n-\tstatic final int TOK_LSQB = TOK_RPAR + 1;\r\n+    int currentToken = TOK_EOF;\r\n \r\n-\t// \"]\"\r\n-\tstatic final int TOK_RSQB = TOK_LSQB + 1;\r\n+    String currentTokenValue = null;\r\n \r\n-\t// 'xxx ' | \" xxx \"\r\n-\tstatic final int TOK_LITERAL = TOK_RSQB + 1;\r\n+    private int currentTokenStartIndex = 0;\r\n \r\n-\t// [0-9].?[0-9]*\r\n-\tstatic final int TOK_NUMBER = TOK_LITERAL + 1;\r\n+    private final String expr;\r\n \r\n-\t// e.g. \"ancestor-or-self::\"\r\n-\tstatic final int TOK_AXIS = TOK_NUMBER + 1;\r\n+    private int exprIndex = 0;\r\n \r\n-\t// \"foo(\"\r\n-\tstatic final int TOK_FUNCTION_LPAR = TOK_AXIS + 1;\r\n+    private final int exprLength;\r\n \r\n-\t// ?? maybe: \"colonized name(\" ??\r\n-\tstatic final int TOK_CNAME_LPAR = TOK_FUNCTION_LPAR + 1;\r\n+    private boolean recognizeOperator = false;\r\n \r\n-\t// \"$foo\"\r\n-\tstatic final int TOK_VARIABLE_REF = TOK_CNAME_LPAR + 1;\r\n+    /**\r\n+     * construct with the string to be tokenized\r\n+     */\r\n+    ExprTokenizer(final String s) {\r\n+        this.expr = s;\r\n+        this.exprLength = s.length();\r\n+    }\r\n \r\n-\t// \"/\"\r\n-\tstatic final int TOK_SLASH = TOK_VARIABLE_REF + 1;\r\n-\r\n-\t// \"//\"\r\n-\tstatic final int TOK_SLASH_SLASH = TOK_SLASH + 1;\r\n-\r\n-\t// \"|\"\r\n-\tstatic final int TOK_VBAR = TOK_SLASH_SLASH + 1;\r\n-\r\n-\t// \",\"\r\n-\tstatic final int TOK_COMMA = TOK_VBAR + 1;\r\n-\r\n-\t// \"+\"\r\n-\tstatic final int TOK_PLUS = TOK_COMMA + 1;\r\n-\r\n-\t// \"-\"\r\n-\tstatic final int TOK_MINUS = TOK_PLUS + 1;\r\n-\r\n-\t// \"=\"\r\n-\tstatic final int TOK_EQUALS = TOK_MINUS + 1;\r\n-\r\n-\t// \"!+\"\r\n-\tstatic final int TOK_NOT_EQUALS = TOK_EQUALS + 1;\r\n-\r\n-\t// \">\"\r\n-\tstatic final int TOK_GT = TOK_NOT_EQUALS + 1;\r\n-\r\n-\t// \"<\"\r\n-\tstatic final int TOK_LT = TOK_GT + 1;\r\n-\r\n-\t// \">=\"\r\n-\tstatic final int TOK_GTE = TOK_LT + 1;\r\n-\r\n-\t// \"<=\"\r\n-\tstatic final int TOK_LTE = TOK_GTE + 1;\r\n-\r\n-\t// \"and\"\r\n-\tstatic final int TOK_AND = TOK_LTE + 1;\r\n-\r\n-\t// \"or\" (why is this different from TOK_VBAR?)\r\n-\tstatic final int TOK_OR = TOK_AND + 1;\r\n-\r\n-\t// \"mod\"\r\n-\tstatic final int TOK_MOD = TOK_OR + 1;\r\n-\r\n-\t// \"div\"\r\n-\tstatic final int TOK_DIV = TOK_MOD + 1;\r\n-\r\n-\tint currentToken = TOK_EOF;\r\n-\tString currentTokenValue = null;\r\n-\r\n-\tprivate int currentTokenStartIndex = 0;\r\n-\tprivate final String expr;\r\n-\tprivate int exprIndex = 0;\r\n-\tprivate final int exprLength;\r\n-\tprivate boolean recognizeOperator = false;\r\n-\r\n-\t/**\r\n-\t * construct with the string to be tokenized\r\n-\t */\r\n-\tExprTokenizer(final String s)\r\n-\t{\r\n-\t\tthis.expr = s;\r\n-\t\tthis.exprLength = s.length();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * lexes the next token, leaving the token type in <code>currentToken</code>, and the value (if applicable) in <code>tokenValue</code>\r\n-\t * \r\n-\t */\r\n-\tvoid next() throws ExprParseException\r\n-\t{\r\n-\t\tcurrentTokenValue = null;\r\n-\t\tcurrentTokenStartIndex = exprIndex;\r\n-\r\n-\t\t// a mode switch\r\n-\t\tboolean currentMaybeOperator = recognizeOperator;\r\n-\t\trecognizeOperator = true;\r\n-\r\n-\t\tfor (;;)\r\n-\t\t{\r\n-\t\t\tif (exprIndex >= exprLength)\r\n-\t\t\t{\r\n-\t\t\t\tcurrentToken = TOK_EOF;\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\tchar c = expr.charAt(exprIndex++);\r\n-\r\n-\t\t\tswitch (c)\r\n-\t\t\t{\r\n-\t\t\t\tcase ' ':\r\n-\t\t\t\tcase '\\t':\r\n-\t\t\t\tcase '\\r':\r\n-\t\t\t\tcase '\\n':\r\n-\t\t\t\t\tcurrentTokenStartIndex = exprIndex;\r\n-\t\t\t\tbreak;\r\n-\r\n-\t\t\t\tcase '<':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_LTE;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_LT;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '>':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_GTE;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_GT;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '/':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '/')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_SLASH_SLASH;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_SLASH;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '=':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_EQUALS;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '!':\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_NOT_EQUALS;\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\r\n-\r\n-\t\t\t\tcase ',':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_COMMA;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '|':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_VBAR;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '+':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_PLUS;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '-':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_MINUS;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '(':\r\n-\t\t\t\t\tcurrentToken = TOK_LPAR;\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase ')':\r\n-\t\t\t\t\tcurrentToken = TOK_RPAR;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '[':\r\n-\t\t\t\t\tcurrentToken = TOK_LSQB;\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase ']':\r\n-\t\t\t\t\tcurrentToken = TOK_RSQB;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '\"':\r\n-\t\t\t\tcase '\\'':\r\n-\t\t\t\t\texprIndex = expr.indexOf(c, exprIndex);\r\n-\t\t\t\t\tif (exprIndex < 0)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex = currentTokenStartIndex + 1;\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"missing quote\");\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex++);\r\n-\t\t\t\t\tcurrentToken = TOK_LITERAL;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '$':\r\n-\t\t\t\t\tscanName();\r\n-\t\t\t\t\tif (exprIndex == currentTokenStartIndex + 1)\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == ':')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tscanName();\r\n-\t\t\t\t\t\tif (expr.charAt(exprIndex - 1) == ':')\r\n-\t\t\t\t\t\t\tthrow new ExprParseException(\"bad character after :\");\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex);\r\n-\t\t\t\t\tcurrentToken = TOK_VARIABLE_REF;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '*':\r\n-\t\t\t\t\tif (currentMaybeOperator)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\tcurrentToken = TOK_MULTIPLY;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_STAR;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '@':\r\n-\t\t\t\t\tcurrentToken = TOK_AT;\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '0':\r\n-\t\t\t\tcase '1':\r\n-\t\t\t\tcase '2':\r\n-\t\t\t\tcase '3':\r\n-\t\t\t\tcase '4':\r\n-\t\t\t\tcase '5':\r\n-\t\t\t\tcase '6':\r\n-\t\t\t\tcase '7':\r\n-\t\t\t\tcase '8':\r\n-\t\t\t\tcase '9':\r\n-\t\t\t\t\tscanDigits();\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '.')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tif (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\t\tscanDigits();\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\tcurrentToken = TOK_NUMBER;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '.':\r\n-\t\t\t\t\tif (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n-\t\t\t\t\t{\r\n-\r\n-\t\t\t\t\t\t++exprIndex;\r\n-\t\t\t\t\t\tscanDigits();\r\n-\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\t\tcurrentToken = TOK_NUMBER;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '.')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_DOT_DOT;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_DOT;\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tdefault:\r\n-\t\t\t\t\t--exprIndex;\r\n-\t\t\t\t\tscanName();\r\n-\t\t\t\t\tif (exprIndex == currentTokenStartIndex)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (isAxis())\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\tcurrentToken = TOK_AXIS;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == ':')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '*')\r\n-\t\t\t\t\t\t{\r\n-\r\n-\t\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex++ - 1);\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_NAME_COLON_STAR;\r\n-\t\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t\t}\r\n-\r\n-\t\t\t\t\t\tscanName();\r\n-\t\t\t\t\t\tif (expr.charAt(exprIndex - 1) == ':')\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\tthrow new ExprParseException(\"bad character after :\");\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\t\tif (followingParen())\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_CNAME_LPAR;\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_QNAME;\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\tif (currentMaybeOperator)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tif (currentTokenValue.equals(\"and\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_AND;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"or\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_OR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"mod\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_MOD;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"div\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_DIV;\r\n-\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t\tthrow new ExprParseException(\"unrecognized operator name\");\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (followingParen())\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tif (currentTokenValue.equals(\"processing-instruction\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_PROCESSING_INSTRUCTION_LPAR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"comment\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_COMMENT_LPAR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"node\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_NODE_LPAR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"text\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_TEXT_LPAR;\r\n-\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_FUNCTION_LPAR;\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_QNAME;\r\n-\t\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tprivate void scanName()\r\n-\t{\r\n-\t\tif (exprIndex < exprLength && isNameStartChar(expr.charAt(exprIndex)))\r\n-\t\t\twhile (++exprIndex < exprLength && isNameChar(expr.charAt(exprIndex)))\r\n-\t\t\t\t;\r\n-\t}\r\n-\r\n-\tprivate void scanDigits()\r\n-\t{\r\n-\t\twhile (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n-\t\t\texprIndex++;\r\n-\t}\r\n-\r\n-\tprivate boolean followingParen()\r\n-\t{\r\n-\t\tfor (int i = exprIndex; i < exprLength; i++)\r\n-\t\t{\r\n-\t\t\tswitch (expr.charAt(i))\r\n-\t\t\t{\r\n-\t\t\t\tcase '(':\r\n-\t\t\t\t\texprIndex = i + 1;\r\n-\t\t\t\t\treturn true;\r\n-\t\t\t\tcase ' ':\r\n-\t\t\t\tcase '\\r':\r\n-\t\t\t\tcase '\\n':\r\n-\t\t\t\tcase '\\t':\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\t\treturn false;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tprivate boolean isAxis()\r\n-\t{\r\n-\t\tfor (int i = exprIndex; i < exprLength; i++)\r\n-\t\t{\r\n-\t\t\tswitch (expr.charAt(i))\r\n-\t\t\t{\r\n-\t\t\t\tcase ':':\r\n-\t\t\t\t\tif (i + 1 < exprLength && expr.charAt(i + 1) == ':')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\t\texprIndex = i + 2;\r\n-\t\t\t\t\t\treturn true;\r\n-\t\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase ' ':\r\n-\t\t\t\tcase '\\r':\r\n-\t\t\t\tcase '\\n':\r\n-\t\t\t\tcase '\\t':\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\t\treturn false;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tstatic private final String nameStartChars = \"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n-\tstatic private final String nameChars = \".-0123456789\";\r\n-\tstatic private final String digits = \"0123456789\";\r\n-\r\n-\tprivate static final boolean isDigit(char c)\r\n-\t{\r\n-\t\treturn digits.indexOf(c) >= 0;\r\n-\t}\r\n-\r\n-\t@SuppressWarnings(\"unused\")\r\n-\tprivate static final boolean isSpace(char c)\r\n-\t{\r\n-\t\tswitch (c)\r\n-\t\t{\r\n-\t\t\tcase ' ':\r\n-\t\t\tcase '\\r':\r\n-\t\t\tcase '\\n':\r\n-\t\t\tcase '\\t':\r\n-\t\t\t\treturn true;\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tprivate static final boolean isNameStartChar(char c)\r\n-\t{\r\n-\t\treturn nameStartChars.indexOf(c) >= 0 || c >= 0x80;\r\n-\t}\r\n-\r\n-\tprivate static final boolean isNameChar(char c)\r\n-\t{\r\n-\t\treturn nameStartChars.indexOf(c) >= 0 || nameChars.indexOf(c) >= 0 || c >= 0x80;\r\n-\t}\r\n+    /**\r\n+     * lexes the next token, leaving the token type in <code>currentToken</code>, and the value (if applicable) in <code>tokenValue</code>\r\n+     */\r\n+    void next() throws ExprParseException {\r\n+        currentTokenValue = null;\r\n+        currentTokenStartIndex = exprIndex;\r\n+\r\n+        // a mode switch\r\n+        boolean currentMaybeOperator = recognizeOperator;\r\n+        recognizeOperator = true;\r\n+\r\n+        for (; ; ) {\r\n+            if (exprIndex >= exprLength) {\r\n+                currentToken = TOK_EOF;\r\n+                return;\r\n+            }\r\n+            char c = expr.charAt(exprIndex++);\r\n+\r\n+            switch (c) {\r\n+                case ' ':\r\n+                case '\\t':\r\n+                case '\\r':\r\n+                case '\\n':\r\n+                    currentTokenStartIndex = exprIndex;\r\n+                    break;\r\n+\r\n+                case '<':\r\n+                    recognizeOperator = false;\r\n+                    if (exprIndex < exprLength && expr.charAt(exprIndex) == '=') {\r\n+                        exprIndex++;\r\n+                        currentToken = TOK_LTE;\r\n+                    } else {\r\n+                        currentToken = TOK_LT;\r\n+                    }\r\n+                    return;\r\n+\r\n+                case '>':\r\n+                    recognizeOperator = false;\r\n+                    if (exprIndex < exprLength && expr.charAt(exprIndex) == '=') {\r\n+                        exprIndex++;\r\n+                        currentToken = TOK_GTE;\r\n+                    } else {\r\n+                        currentToken = TOK_GT;\r\n+                    }\r\n+                    return;\r\n+\r\n+                case '/':\r\n+                    recognizeOperator = false;\r\n+                    if (exprIndex < exprLength && expr.charAt(exprIndex) == '/') {\r\n+                        exprIndex++;\r\n+                        currentToken = TOK_SLASH_SLASH;\r\n+                    } else {\r\n+                        currentToken = TOK_SLASH;\r\n+                    }\r\n+                    return;\r\n+\r\n+                case '=':\r\n+                    recognizeOperator = false;\r\n+                    currentToken = TOK_EQUALS;\r\n+                    return;\r\n+\r\n+                case '!':\r\n+                    if (exprIndex < exprLength && expr.charAt(exprIndex) == '=') {\r\n+                        exprIndex++;\r\n+                        currentToken = TOK_NOT_EQUALS;\r\n+                        recognizeOperator = false;\r\n+                        return;\r\n+                    }\r\n+                    throw new ExprParseException(\"illegal character\");\r\n+\r\n+                case ',':\r\n+                    recognizeOperator = false;\r\n+                    currentToken = TOK_COMMA;\r\n+                    return;\r\n+\r\n+                case '|':\r\n+                    recognizeOperator = false;\r\n+                    currentToken = TOK_VBAR;\r\n+                    return;\r\n+\r\n+                case '+':\r\n+                    recognizeOperator = false;\r\n+                    currentToken = TOK_PLUS;\r\n+                    return;\r\n+\r\n+                case '-':\r\n+                    recognizeOperator = false;\r\n+                    currentToken = TOK_MINUS;\r\n+                    return;\r\n+\r\n+                case '(':\r\n+                    currentToken = TOK_LPAR;\r\n+                    recognizeOperator = false;\r\n+                    return;\r\n+\r\n+                case ')':\r\n+                    currentToken = TOK_RPAR;\r\n+                    return;\r\n+\r\n+                case '[':\r\n+                    currentToken = TOK_LSQB;\r\n+                    recognizeOperator = false;\r\n+                    return;\r\n+\r\n+                case ']':\r\n+                    currentToken = TOK_RSQB;\r\n+                    return;\r\n+\r\n+                case '\"':\r\n+                case '\\'':\r\n+                    exprIndex = expr.indexOf(c, exprIndex);\r\n+                    if (exprIndex < 0) {\r\n+                        exprIndex = currentTokenStartIndex + 1;\r\n+                        throw new ExprParseException(\"missing quote\");\r\n+                    }\r\n+                    currentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex++);\r\n+                    currentToken = TOK_LITERAL;\r\n+                    return;\r\n+\r\n+                case '$':\r\n+                    scanName();\r\n+                    if (exprIndex == currentTokenStartIndex + 1) {\r\n+                        throw new ExprParseException(\"illegal character\");\r\n+                    }\r\n+                    if (exprIndex < exprLength && expr.charAt(exprIndex) == ':') {\r\n+                        exprIndex++;\r\n+                        scanName();\r\n+                        if (expr.charAt(exprIndex - 1) == ':') {\r\n+                            throw new ExprParseException(\"bad character after :\");\r\n+                        }\r\n+                    }\r\n+                    currentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex);\r\n+                    currentToken = TOK_VARIABLE_REF;\r\n+                    return;\r\n+\r\n+                case '*':\r\n+                    if (currentMaybeOperator) {\r\n+                        recognizeOperator = false;\r\n+                        currentToken = TOK_MULTIPLY;\r\n+                    } else {\r\n+                        currentToken = TOK_STAR;\r\n+                    }\r\n+                    return;\r\n+\r\n+                case '@':\r\n+                    currentToken = TOK_AT;\r\n+                    recognizeOperator = false;\r\n+                    return;\r\n+\r\n+                case '0':\r\n+                case '1':\r\n+                case '2':\r\n+                case '3':\r\n+                case '4':\r\n+                case '5':\r\n+                case '6':\r\n+                case '7':\r\n+                case '8':\r\n+                case '9':\r\n+                    scanDigits();\r\n+                    if (exprIndex < exprLength && expr.charAt(exprIndex) == '.') {\r\n+                        exprIndex++;\r\n+                        if (exprIndex < exprLength && isDigit(expr.charAt(exprIndex))) {\r\n+                            exprIndex++;\r\n+                            scanDigits();\r\n+                        }\r\n+                    }\r\n+                    currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n+                    currentToken = TOK_NUMBER;\r\n+                    return;\r\n+\r\n+                case '.':\r\n+                    if (exprIndex < exprLength && isDigit(expr.charAt(exprIndex))) {\r\n+\r\n+                        ++exprIndex;\r\n+                        scanDigits();\r\n+                        currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n+                        currentToken = TOK_NUMBER;\r\n+                        return;\r\n+                    }\r\n+                    if (exprIndex < exprLength && expr.charAt(exprIndex) == '.') {\r\n+                        exprIndex++;\r\n+                        currentToken = TOK_DOT_DOT;\r\n+                    } else {\r\n+                        currentToken = TOK_DOT;\r\n+                    }\r\n+                    recognizeOperator = false;\r\n+                    return;\r\n+\r\n+                default:\r\n+                    --exprIndex;\r\n+                    scanName();\r\n+                    if (exprIndex == currentTokenStartIndex) {\r\n+                        throw new ExprParseException(\"illegal character\");\r\n+                    }\r\n+                    if (isAxis()) {\r\n+                        recognizeOperator = false;\r\n+                        currentToken = TOK_AXIS;\r\n+                        return;\r\n+                    }\r\n+                    if (exprIndex < exprLength && expr.charAt(exprIndex) == ':') {\r\n+                        exprIndex++;\r\n+                        if (exprIndex < exprLength && expr.charAt(exprIndex) == '*') {\r\n+\r\n+                            currentTokenValue =\r\n+                                expr.substring(currentTokenStartIndex, exprIndex++ - 1);\r\n+                            currentToken = TOK_NAME_COLON_STAR;\r\n+                            return;\r\n+                        }\r\n+\r\n+                        scanName();\r\n+                        if (expr.charAt(exprIndex - 1) == ':') {\r\n+                            throw new ExprParseException(\"bad character after :\");\r\n+                        }\r\n+                        currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n+                        if (followingParen()) {\r\n+                            recognizeOperator = false;\r\n+                            currentToken = TOK_CNAME_LPAR;\r\n+                        } else {\r\n+                            currentToken = TOK_QNAME;\r\n+                        }\r\n+                        return;\r\n+                    }\r\n+                    currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n+                    if (currentMaybeOperator) {\r\n+                        if (currentTokenValue.equals(\"and\")) {\r\n+                            currentToken = TOK_AND;\r\n+                        } else if (currentTokenValue.equals(\"or\")) {\r\n+                            currentToken = TOK_OR;\r\n+                        } else if (currentTokenValue.equals(\"mod\")) {\r\n+                            currentToken = TOK_MOD;\r\n+                        } else if (currentTokenValue.equals(\"div\")) {\r\n+                            currentToken = TOK_DIV;\r\n+                        } else {\r\n+                            throw new ExprParseException(\"unrecognized operator name\");\r\n+                        }\r\n+                        recognizeOperator = false;\r\n+                        return;\r\n+                    }\r\n+                    if (followingParen()) {\r\n+                        if (currentTokenValue.equals(\"processing-instruction\")) {\r\n+                            currentToken = TOK_PROCESSING_INSTRUCTION_LPAR;\r\n+                        } else if (currentTokenValue.equals(\"comment\")) {\r\n+                            currentToken = TOK_COMMENT_LPAR;\r\n+                        } else if (currentTokenValue.equals(\"node\")) {\r\n+                            currentToken = TOK_NODE_LPAR;\r\n+                        } else if (currentTokenValue.equals(\"text\")) {\r\n+                            currentToken = TOK_TEXT_LPAR;\r\n+                        } else {\r\n+                            currentToken = TOK_FUNCTION_LPAR;\r\n+                        }\r\n+                        recognizeOperator = false;\r\n+                    } else {\r\n+                        currentToken = TOK_QNAME;\r\n+                    }\r\n+                    return;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void scanName() {\r\n+        if (exprIndex < exprLength && isNameStartChar(expr.charAt(exprIndex))) {\r\n+            while (++exprIndex < exprLength && isNameChar(expr.charAt(exprIndex))) {\r\n+                ;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void scanDigits() {\r\n+        while (exprIndex < exprLength && isDigit(expr.charAt(exprIndex))) {\r\n+            exprIndex++;\r\n+        }\r\n+    }\r\n+\r\n+    private boolean followingParen() {\r\n+        for (int i = exprIndex; i < exprLength; i++) {\r\n+            switch (expr.charAt(i)) {\r\n+                case '(':\r\n+                    exprIndex = i + 1;\r\n+                    return true;\r\n+                case ' ':\r\n+                case '\\r':\r\n+                case '\\n':\r\n+                case '\\t':\r\n+                    break;\r\n+                default:\r\n+                    return false;\r\n+            }\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    private boolean isAxis() {\r\n+        for (int i = exprIndex; i < exprLength; i++) {\r\n+            switch (expr.charAt(i)) {\r\n+                case ':':\r\n+                    if (i + 1 < exprLength && expr.charAt(i + 1) == ':') {\r\n+                        currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n+                        exprIndex = i + 2;\r\n+                        return true;\r\n+                    }\r\n+                    break;\r\n+                case ' ':\r\n+                case '\\r':\r\n+                case '\\n':\r\n+                case '\\t':\r\n+                    break;\r\n+                default:\r\n+                    return false;\r\n+            }\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    static private final String nameStartChars =\r\n+        \"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n+\r\n+    static private final String nameChars = \".-0123456789\";\r\n+\r\n+    static private final String digits = \"0123456789\";\r\n+\r\n+    private static final boolean isDigit(char c) {\r\n+        return digits.indexOf(c) >= 0;\r\n+    }\r\n+\r\n+    @SuppressWarnings(\"unused\")\r\n+    private static final boolean isSpace(char c) {\r\n+        switch (c) {\r\n+            case ' ':\r\n+            case '\\r':\r\n+            case '\\n':\r\n+            case '\\t':\r\n+                return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    private static final boolean isNameStartChar(char c) {\r\n+        return nameStartChars.indexOf(c) >= 0 || c >= 0x80;\r\n+    }\r\n+\r\n+    private static final boolean isNameChar(char c) {\r\n+        return nameStartChars.indexOf(c) >= 0 || nameChars.indexOf(c) >= 0 || c >= 0x80;\r\n+    }\r\n \r\n }\r\n",
            "diff_size": 578
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "33",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/347/ExprTokenizer.java\nindex a0b9906552d..85e561e9317 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/naturalize/347/ExprTokenizer.java\n@@ -28,25 +28,25 @@ import org.genxdm.xpath.v10.ExprParseException;\n  * @see http://www.w3c.org/TR/xpath\r\n  */\r\n class ExprTokenizer\r\n-{\r\n-\t//\r\n+{\n+    //\r\n \t// The tokens\r\n \t//\r\n \tpublic static String toString(final int token)\r\n-\t{\r\n-\t\t// An enumeration would solve this problem...\r\n+\t{\n+    // An enumeration would solve this problem...\r\n \t\tswitch (token)\r\n-\t\t{\r\n-\t\t\tcase TOK_EOF:\r\n-\t\t\t{\r\n-\t\t\t\treturn \"EOF\";\r\n-\t\t\t}\r\n+\t\t{\n+    case TOK_EOF:\r\n+\t\t\t{\n+    return \"EOF\";\n+    }\r\n \t\t\tdefault:\r\n-\t\t\t{\r\n-\t\t\t\treturn \"TOKEN[\".concat(Integer.toString(token)).concat(\"]\");\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n+\t\t\t{\n+    return \"TOKEN[\".concat(Integer.toString(token)).concat(\"]\");\n+    }\n+    }\n+    }\r\n \r\n \t// end of string being tokenized\r\n \tstatic final int TOK_EOF = 0;\r\n@@ -175,18 +175,18 @@ class ExprTokenizer\n \t * construct with the string to be tokenized\r\n \t */\r\n \tExprTokenizer(final String s)\r\n-\t{\r\n-\t\tthis.expr = s;\r\n-\t\tthis.exprLength = s.length();\r\n-\t}\r\n+\t{\n+    this.expr = s;\r\n+\t\tthis.exprLength = s.length();\n+    }\r\n \r\n \t/**\r\n \t * lexes the next token, leaving the token type in <code>currentToken</code>, and the value (if applicable) in <code>tokenValue</code>\r\n \t * \r\n \t */\r\n \tvoid next() throws ExprParseException\r\n-\t{\r\n-\t\tcurrentTokenValue = null;\r\n+\t{\n+    currentTokenValue = null;\r\n \t\tcurrentTokenStartIndex = exprIndex;\r\n \r\n \t\t// a mode switch\r\n@@ -194,152 +194,134 @@ class ExprTokenizer\n \t\trecognizeOperator = true;\r\n \r\n \t\tfor (;;)\r\n-\t\t{\r\n-\t\t\tif (exprIndex >= exprLength)\r\n-\t\t\t{\r\n-\t\t\t\tcurrentToken = TOK_EOF;\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n+\t\t{\n+    if (exprIndex >= exprLength)\r\n+\t\t\t{\n+    currentToken = TOK_EOF;\r\n+\t\t\t\treturn;\n+    }\r\n \t\t\tchar c = expr.charAt(exprIndex++);\r\n \r\n \t\t\tswitch (c)\r\n-\t\t\t{\r\n-\t\t\t\tcase ' ':\r\n+\t\t\t{\n+    case ' ':\r\n \t\t\t\tcase '\\t':\r\n \t\t\t\tcase '\\r':\r\n-\t\t\t\tcase '\\n':\r\n-\t\t\t\t\tcurrentTokenStartIndex = exprIndex;\r\n-\t\t\t\tbreak;\r\n-\r\n-\t\t\t\tcase '<':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n+\t\t\t\tcase '\\n':\n+currentTokenStartIndex = exprIndex;\n+    break;\n+case '<':\n+recognizeOperator = false;\r\n \t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_LTE;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_LT;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '>':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n+\t\t\t\t\t{\n+    exprIndex++;\r\n+\t\t\t\t\t\tcurrentToken = TOK_LTE;\n+    }\r\n+\t\t\t\t\telse\n+    currentToken = TOK_LT;\n+return;\n+case '>':\n+recognizeOperator = false;\r\n \t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_GTE;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_GT;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '/':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n+\t\t\t\t\t{\n+    exprIndex++;\r\n+\t\t\t\t\t\tcurrentToken = TOK_GTE;\n+    }\r\n+\t\t\t\t\telse\n+    currentToken = TOK_GT;\n+return;\n+case '/':\n+recognizeOperator = false;\r\n \t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '/')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_SLASH_SLASH;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_SLASH;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '=':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n+\t\t\t\t\t{\n+    exprIndex++;\r\n+\t\t\t\t\t\tcurrentToken = TOK_SLASH_SLASH;\n+    }\r\n+\t\t\t\t\telse\n+    currentToken = TOK_SLASH;\n+return;\n+case '=':\n+recognizeOperator = false;\r\n \t\t\t\t\tcurrentToken = TOK_EQUALS;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '!':\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n+\t\t\t\t\treturn;\n+case '!':\n+if (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n+\t\t\t\t\t{\n+    exprIndex++;\r\n \t\t\t\t\t\tcurrentToken = TOK_NOT_EQUALS;\r\n \t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\r\n-\r\n-\t\t\t\tcase ',':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n+\t\t\t\t\t\treturn;\n+    }\r\n+\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\n+case ',':\n+recognizeOperator = false;\r\n \t\t\t\t\tcurrentToken = TOK_COMMA;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '|':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n+\t\t\t\t\treturn;\n+case '|':\n+recognizeOperator = false;\r\n \t\t\t\t\tcurrentToken = TOK_VBAR;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '+':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n+\t\t\t\t\treturn;\n+case '+':\n+recognizeOperator = false;\r\n \t\t\t\t\tcurrentToken = TOK_PLUS;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '-':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n+\t\t\t\t\treturn;\n+case '-':\n+recognizeOperator = false;\r\n \t\t\t\t\tcurrentToken = TOK_MINUS;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '(':\r\n-\t\t\t\t\tcurrentToken = TOK_LPAR;\r\n+\t\t\t\t\treturn;\n+case '(':\n+currentToken = TOK_LPAR;\r\n \t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase ')':\r\n-\t\t\t\t\tcurrentToken = TOK_RPAR;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '[':\r\n-\t\t\t\t\tcurrentToken = TOK_LSQB;\r\n+\t\t\t\t\treturn;\n+case ')':\n+currentToken = TOK_RPAR;\r\n+\t\t\t\t\treturn;\n+case '[':\n+currentToken = TOK_LSQB;\r\n \t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase ']':\r\n-\t\t\t\t\tcurrentToken = TOK_RSQB;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '\"':\r\n-\t\t\t\tcase '\\'':\r\n-\t\t\t\t\texprIndex = expr.indexOf(c, exprIndex);\r\n+\t\t\t\t\treturn;\n+case ']':\n+currentToken = TOK_RSQB;\r\n+\t\t\t\t\treturn;\n+case '\"':\r\n+\t\t\t\tcase '\\'':\n+exprIndex = expr.indexOf(c, exprIndex);\r\n \t\t\t\t\tif (exprIndex < 0)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex = currentTokenStartIndex + 1;\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"missing quote\");\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t{\n+    exprIndex = currentTokenStartIndex + 1;\r\n+\t\t\t\t\t\tthrow new ExprParseException(\"missing quote\");\n+    }\r\n \t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex++);\r\n \t\t\t\t\tcurrentToken = TOK_LITERAL;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '$':\r\n-\t\t\t\t\tscanName();\r\n-\t\t\t\t\tif (exprIndex == currentTokenStartIndex + 1)\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == ':')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n+\t\t\t\t\treturn;\n+case '$':\n+scanName();\r\n+\t\t\t\t\tif (exprIndex == currentTokenStartIndex + 1)\n+    throw new ExprParseException(\"illegal character\");\n+if (exprIndex < exprLength && expr.charAt(exprIndex) == ':')\r\n+\t\t\t\t\t{\n+    exprIndex++;\r\n \t\t\t\t\t\tscanName();\r\n-\t\t\t\t\t\tif (expr.charAt(exprIndex - 1) == ':')\r\n-\t\t\t\t\t\t\tthrow new ExprParseException(\"bad character after :\");\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t\tif (expr.charAt(exprIndex - 1) == ':')\n+    throw new ExprParseException(\"bad character after :\");\n+    }\r\n \t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex);\r\n \t\t\t\t\tcurrentToken = TOK_VARIABLE_REF;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '*':\r\n-\t\t\t\t\tif (currentMaybeOperator)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\tcurrentToken = TOK_MULTIPLY;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_STAR;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '@':\r\n-\t\t\t\t\tcurrentToken = TOK_AT;\r\n+\t\t\t\t\treturn;\n+case '*':\n+if (currentMaybeOperator)\r\n+\t\t\t\t\t{\n+    recognizeOperator = false;\r\n+\t\t\t\t\t\tcurrentToken = TOK_MULTIPLY;\n+    }\r\n+\t\t\t\t\telse\n+    currentToken = TOK_STAR;\n+return;\n+case '@':\n+currentToken = TOK_AT;\r\n \t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '0':\r\n+\t\t\t\t\treturn;\n+case '0':\r\n \t\t\t\tcase '1':\r\n \t\t\t\tcase '2':\r\n \t\t\t\tcase '3':\r\n@@ -348,210 +330,204 @@ class ExprTokenizer\n \t\t\t\tcase '6':\r\n \t\t\t\tcase '7':\r\n \t\t\t\tcase '8':\r\n-\t\t\t\tcase '9':\r\n-\t\t\t\t\tscanDigits();\r\n+\t\t\t\tcase '9':\n+scanDigits();\r\n \t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '.')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n+\t\t\t\t\t{\n+    exprIndex++;\r\n \t\t\t\t\t\tif (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\t\tscanDigits();\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t\t{\n+    exprIndex++;\r\n+\t\t\t\t\t\t\tscanDigits();\n+    }\n+    }\r\n \t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n \t\t\t\t\tcurrentToken = TOK_NUMBER;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '.':\r\n-\t\t\t\t\tif (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n-\t\t\t\t\t{\r\n-\r\n-\t\t\t\t\t\t++exprIndex;\r\n+\t\t\t\t\treturn;\n+case '.':\n+if (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n+\t\t\t\t\t{\n+    ++exprIndex;\r\n \t\t\t\t\t\tscanDigits();\r\n \t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n \t\t\t\t\t\tcurrentToken = TOK_NUMBER;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t\treturn;\n+    }\r\n \t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '.')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_DOT_DOT;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_DOT;\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tdefault:\r\n-\t\t\t\t\t--exprIndex;\r\n+\t\t\t\t\t{\n+    exprIndex++;\r\n+\t\t\t\t\t\tcurrentToken = TOK_DOT_DOT;\n+    }\r\n+\t\t\t\t\telse\n+    currentToken = TOK_DOT;\n+recognizeOperator = false;\r\n+\t\t\t\t\treturn;\n+    default:\n+--exprIndex;\r\n \t\t\t\t\tscanName();\r\n \t\t\t\t\tif (exprIndex == currentTokenStartIndex)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t{\n+    throw new ExprParseException(\"illegal character\");\n+    }\r\n \t\t\t\t\tif (isAxis())\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n+\t\t\t\t\t{\n+    recognizeOperator = false;\r\n \t\t\t\t\t\tcurrentToken = TOK_AXIS;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t\treturn;\n+    }\r\n \t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == ':')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n+\t\t\t\t\t{\n+    exprIndex++;\r\n \t\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '*')\r\n-\t\t\t\t\t\t{\r\n-\r\n-\t\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex++ - 1);\r\n+\t\t\t\t\t\t{\n+    currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex++ - 1);\r\n \t\t\t\t\t\t\tcurrentToken = TOK_NAME_COLON_STAR;\r\n-\t\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\treturn;\n+    }\r\n \r\n \t\t\t\t\t\tscanName();\r\n \t\t\t\t\t\tif (expr.charAt(exprIndex - 1) == ':')\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\tthrow new ExprParseException(\"bad character after :\");\r\n-\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t{\n+    throw new ExprParseException(\"bad character after :\");\n+    }\r\n \t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n \t\t\t\t\t\tif (followingParen())\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_CNAME_LPAR;\r\n-\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t{\n+    recognizeOperator = false;\r\n+\t\t\t\t\t\t\tcurrentToken = TOK_CNAME_LPAR;\n+    }\r\n \t\t\t\t\t\telse\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_QNAME;\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t\t{\n+    currentToken = TOK_QNAME;\n+    }\r\n+\t\t\t\t\t\treturn;\n+    }\r\n \t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n \t\t\t\t\tif (currentMaybeOperator)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tif (currentTokenValue.equals(\"and\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_AND;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"or\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_OR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"mod\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_MOD;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"div\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_DIV;\r\n-\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t\tthrow new ExprParseException(\"unrecognized operator name\");\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n+\t\t\t\t\t{\n+    if (currentTokenValue.equals(\"and\"))\n+    currentToken = TOK_AND;\n+    else if (currentTokenValue.equals(\"or\"))\n+    currentToken = TOK_OR;\n+    else if (currentTokenValue.equals(\"mod\"))\n+    currentToken = TOK_MOD;\n+    else if (currentTokenValue.equals(\"div\"))\n+    currentToken = TOK_DIV;\n+    else\n+throw new ExprParseException(\"unrecognized operator name\");\n+recognizeOperator = false;\r\n+\t\t\t\t\t\treturn;\n+    }\r\n \t\t\t\t\tif (followingParen())\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tif (currentTokenValue.equals(\"processing-instruction\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_PROCESSING_INSTRUCTION_LPAR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"comment\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_COMMENT_LPAR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"node\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_NODE_LPAR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"text\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_TEXT_LPAR;\r\n-\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_FUNCTION_LPAR;\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_QNAME;\r\n-\t\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n+\t\t\t\t\t{\n+    if (currentTokenValue.equals(\"processing-instruction\"))\n+    currentToken = TOK_PROCESSING_INSTRUCTION_LPAR;\n+    else if (currentTokenValue.equals(\"comment\"))\n+    currentToken = TOK_COMMENT_LPAR;\n+    else if (currentTokenValue.equals(\"node\"))\n+    currentToken = TOK_NODE_LPAR;\n+    else if (currentTokenValue.equals(\"text\"))\n+    currentToken = TOK_TEXT_LPAR;\n+    else\n+    currentToken = TOK_FUNCTION_LPAR;\n+recognizeOperator = false;\n+    }\r\n+\t\t\t\t\telse\n+    currentToken = TOK_QNAME;\n+return;\n+    }\n+    }\n+    }\r\n \r\n \tprivate void scanName()\r\n-\t{\r\n-\t\tif (exprIndex < exprLength && isNameStartChar(expr.charAt(exprIndex)))\r\n-\t\t\twhile (++exprIndex < exprLength && isNameChar(expr.charAt(exprIndex)))\r\n-\t\t\t\t;\r\n-\t}\r\n+\t{\n+    if (exprIndex < exprLength && isNameStartChar(expr.charAt(exprIndex)))\n+while (++exprIndex < exprLength && isNameChar(expr.charAt(exprIndex)));\n+    }\r\n \r\n \tprivate void scanDigits()\r\n-\t{\r\n-\t\twhile (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n-\t\t\texprIndex++;\r\n-\t}\r\n+\t{\n+    while (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\n+    exprIndex++;\n+    }\r\n \r\n \tprivate boolean followingParen()\r\n-\t{\r\n-\t\tfor (int i = exprIndex; i < exprLength; i++)\r\n-\t\t{\r\n-\t\t\tswitch (expr.charAt(i))\r\n-\t\t\t{\r\n-\t\t\t\tcase '(':\r\n-\t\t\t\t\texprIndex = i + 1;\r\n-\t\t\t\t\treturn true;\r\n-\t\t\t\tcase ' ':\r\n+\t{\n+    for (int i = exprIndex; i < exprLength; i++)\r\n+\t\t{\n+    switch (expr.charAt(i))\r\n+\t\t\t{\n+    case '(':\n+exprIndex = i + 1;\r\n+\t\t\t\t\treturn true;\n+case ' ':\r\n \t\t\t\tcase '\\r':\r\n \t\t\t\tcase '\\n':\r\n \t\t\t\tcase '\\t':\r\n \t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\t\treturn false;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n+\t\t\t\tdefault:\n+    return false;\n+    }\n+    }\r\n+\t\treturn false;\n+    }\r\n \r\n \tprivate boolean isAxis()\r\n-\t{\r\n-\t\tfor (int i = exprIndex; i < exprLength; i++)\r\n-\t\t{\r\n-\t\t\tswitch (expr.charAt(i))\r\n-\t\t\t{\r\n-\t\t\t\tcase ':':\r\n-\t\t\t\t\tif (i + 1 < exprLength && expr.charAt(i + 1) == ':')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n+\t{\n+    for (int i = exprIndex; i < exprLength; i++)\r\n+\t\t{\n+    switch (expr.charAt(i))\r\n+\t\t\t{\n+    case ':':\n+if (i + 1 < exprLength && expr.charAt(i + 1) == ':')\r\n+\t\t\t\t\t{\n+    currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n \t\t\t\t\t\texprIndex = i + 2;\r\n-\t\t\t\t\t\treturn true;\r\n-\t\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n+\t\t\t\t\t\treturn true;\n+    }\n+break;\r\n \t\t\t\tcase ' ':\r\n \t\t\t\tcase '\\r':\r\n \t\t\t\tcase '\\n':\r\n \t\t\t\tcase '\\t':\r\n \t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\t\treturn false;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n+\t\t\t\tdefault:\n+    return false;\n+    }\n+    }\r\n+\t\treturn false;\n+    }\r\n \r\n \tstatic private final String nameStartChars = \"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n \tstatic private final String nameChars = \".-0123456789\";\r\n \tstatic private final String digits = \"0123456789\";\r\n \r\n \tprivate static final boolean isDigit(char c)\r\n-\t{\r\n-\t\treturn digits.indexOf(c) >= 0;\r\n-\t}\r\n+\t{\n+    return digits.indexOf(c) >= 0;\n+    }\r\n \r\n \t@SuppressWarnings(\"unused\")\r\n \tprivate static final boolean isSpace(char c)\r\n-\t{\r\n-\t\tswitch (c)\r\n-\t\t{\r\n-\t\t\tcase ' ':\r\n+\t{\n+    switch (c)\r\n+\t\t{\n+    case ' ':\r\n \t\t\tcase '\\r':\r\n \t\t\tcase '\\n':\r\n-\t\t\tcase '\\t':\r\n-\t\t\t\treturn true;\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n+\t\t\tcase '\\t':\n+    return true;\n+    }\r\n+\t\treturn false;\n+    }\r\n \r\n \tprivate static final boolean isNameStartChar(char c)\r\n-\t{\r\n-\t\treturn nameStartChars.indexOf(c) >= 0 || c >= 0x80;\r\n-\t}\r\n+\t{\n+    return nameStartChars.indexOf(c) >= 0 || c >= 0x80;\n+    }\r\n \r\n \tprivate static final boolean isNameChar(char c)\r\n-\t{\r\n-\t\treturn nameStartChars.indexOf(c) >= 0 || nameChars.indexOf(c) >= 0 || c >= 0x80;\r\n-\t}\r\n-\r\n-}\r\n+\t{\n+    return nameStartChars.indexOf(c) >= 0 || nameChars.indexOf(c) >= 0 || c >= 0x80;\n+    }\n+    }\n\\ No newline at end of file\n",
            "diff_size": 292
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/347/ExprTokenizer.java\nindex a0b9906552d..77fbbd383ea 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/347/ExprTokenizer.java\n@@ -18,540 +18,519 @@\n  * See the License for the specific language governing permissions and\r\n  * limitations under the License.\r\n  */\r\n-package org.genxdm.processor.xpath.v10.expressions;\r\n-\r\n+package org.genxdm.processor.xpath.v10.expressions;\n+\n import org.genxdm.xpath.v10.ExprParseException;\r\n \r\n /**\r\n  * lexical analyser for XPath 1.0\r\n  * \r\n  * @see http://www.w3c.org/TR/xpath\r\n- */\r\n-class ExprTokenizer\r\n+ */\n+\n+class ExprTokenizer\n {\r\n-\t//\r\n-\t// The tokens\r\n-\t//\r\n-\tpublic static String toString(final int token)\r\n-\t{\r\n-\t\t// An enumeration would solve this problem...\r\n-\t\tswitch (token)\r\n-\t\t{\r\n-\t\t\tcase TOK_EOF:\r\n-\t\t\t{\r\n-\t\t\t\treturn \"EOF\";\r\n-\t\t\t}\r\n-\t\t\tdefault:\r\n-\t\t\t{\r\n-\t\t\t\treturn \"TOKEN[\".concat(Integer.toString(token)).concat(\"]\");\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t// end of string being tokenized\r\n-\tstatic final int TOK_EOF = 0;\r\n-\r\n-\t// a qName\r\n-\tstatic final int TOK_QNAME = TOK_EOF + 1;\r\n-\r\n-\t// \"*\" (wildcard) ?\r\n-\tstatic final int TOK_STAR = TOK_QNAME + 1;\r\n-\r\n-\t// \"foo:*\" ?\r\n-\tstatic final int TOK_NAME_COLON_STAR = TOK_STAR + 1;\r\n-\r\n-\t// \"@\" (attribute axis specifier)\r\n-\tstatic final int TOK_AT = TOK_NAME_COLON_STAR + 1;\r\n-\r\n-\t// \".\" (node self)\r\n-\tstatic final int TOK_DOT = TOK_AT + 1;\r\n-\r\n-\t// \"..\" parent axis\r\n-\tstatic final int TOK_DOT_DOT = TOK_DOT + 1;\r\n+    //\r\n+    // The tokens\r\n+    //\n+    public static String toString(final int token)\n+    {\r\n+        // An enumeration would solve this problem...\n+        switch (token)\n+        {\n+            case TOK_EOF:\n+            {\n+                return \"EOF\";\n+            }\n+            default:\n+            {\n+                return \"TOKEN[\".concat(Integer.toString(token)).concat(\"]\");\n+            }\n+        }\n+    }\r\n \r\n-\t// \"comment(\"\r\n-\tstatic final int TOK_COMMENT_LPAR = TOK_DOT_DOT + 1;\r\n+    // end of string being tokenized\n+\n+    static final int TOK_EOF = 0;\r\n \r\n-\t// \"processing-instruction(\" ??\r\n-\tstatic final int TOK_PROCESSING_INSTRUCTION_LPAR = TOK_COMMENT_LPAR + 1;\r\n+    // a qName\n+    static final int TOK_QNAME = TOK_EOF + 1;\r\n \r\n-\t// \"text(\"\r\n-\tstatic final int TOK_TEXT_LPAR = TOK_PROCESSING_INSTRUCTION_LPAR + 1;\r\n+    // \"*\" (wildcard) ?\n+    static final int TOK_STAR = TOK_QNAME + 1;\r\n \r\n-\t// \"node(\"\r\n-\tstatic final int TOK_NODE_LPAR = TOK_TEXT_LPAR + 1;\r\n+    // \"foo:*\" ?\n+    static final int TOK_NAME_COLON_STAR = TOK_STAR + 1;\r\n \r\n-\t// \"*\" ?? same as star?\r\n-\tstatic final int TOK_MULTIPLY = TOK_NODE_LPAR + 1;\r\n+    // \"@\" (attribute axis specifier)\n+    static final int TOK_AT = TOK_NAME_COLON_STAR + 1;\r\n \r\n-\t// \"(\"\r\n-\tstatic final int TOK_LPAR = TOK_MULTIPLY + 1;\r\n+    // \".\" (node self)\n+    static final int TOK_DOT = TOK_AT + 1;\r\n \r\n-\t// \")\"\r\n-\tstatic final int TOK_RPAR = TOK_LPAR + 1;\r\n+    // \"..\" parent axis\n+    static final int TOK_DOT_DOT = TOK_DOT + 1;\r\n \r\n-\t// \"[\"\r\n-\tstatic final int TOK_LSQB = TOK_RPAR + 1;\r\n+    // \"comment(\"\n+    static final int TOK_COMMENT_LPAR = TOK_DOT_DOT + 1;\r\n \r\n-\t// \"]\"\r\n-\tstatic final int TOK_RSQB = TOK_LSQB + 1;\r\n+    // \"processing-instruction(\" ??\n+    static final int TOK_PROCESSING_INSTRUCTION_LPAR = TOK_COMMENT_LPAR + 1;\r\n \r\n-\t// 'xxx ' | \" xxx \"\r\n-\tstatic final int TOK_LITERAL = TOK_RSQB + 1;\r\n+    // \"text(\"\n+    static final int TOK_TEXT_LPAR = TOK_PROCESSING_INSTRUCTION_LPAR + 1;\r\n \r\n-\t// [0-9].?[0-9]*\r\n-\tstatic final int TOK_NUMBER = TOK_LITERAL + 1;\r\n+    // \"node(\"\n+    static final int TOK_NODE_LPAR = TOK_TEXT_LPAR + 1;\r\n \r\n-\t// e.g. \"ancestor-or-self::\"\r\n-\tstatic final int TOK_AXIS = TOK_NUMBER + 1;\r\n+    // \"*\" ?? same as star?\n+    static final int TOK_MULTIPLY = TOK_NODE_LPAR + 1;\r\n \r\n-\t// \"foo(\"\r\n-\tstatic final int TOK_FUNCTION_LPAR = TOK_AXIS + 1;\r\n+    // \"(\"\n+    static final int TOK_LPAR = TOK_MULTIPLY + 1;\r\n \r\n-\t// ?? maybe: \"colonized name(\" ??\r\n-\tstatic final int TOK_CNAME_LPAR = TOK_FUNCTION_LPAR + 1;\r\n+    // \")\"\n+    static final int TOK_RPAR = TOK_LPAR + 1;\r\n \r\n-\t// \"$foo\"\r\n-\tstatic final int TOK_VARIABLE_REF = TOK_CNAME_LPAR + 1;\r\n+    // \"[\"\n+    static final int TOK_LSQB = TOK_RPAR + 1;\r\n \r\n-\t// \"/\"\r\n-\tstatic final int TOK_SLASH = TOK_VARIABLE_REF + 1;\r\n-\r\n-\t// \"//\"\r\n-\tstatic final int TOK_SLASH_SLASH = TOK_SLASH + 1;\r\n-\r\n-\t// \"|\"\r\n-\tstatic final int TOK_VBAR = TOK_SLASH_SLASH + 1;\r\n-\r\n-\t// \",\"\r\n-\tstatic final int TOK_COMMA = TOK_VBAR + 1;\r\n-\r\n-\t// \"+\"\r\n-\tstatic final int TOK_PLUS = TOK_COMMA + 1;\r\n-\r\n-\t// \"-\"\r\n-\tstatic final int TOK_MINUS = TOK_PLUS + 1;\r\n-\r\n-\t// \"=\"\r\n-\tstatic final int TOK_EQUALS = TOK_MINUS + 1;\r\n-\r\n-\t// \"!+\"\r\n-\tstatic final int TOK_NOT_EQUALS = TOK_EQUALS + 1;\r\n-\r\n-\t// \">\"\r\n-\tstatic final int TOK_GT = TOK_NOT_EQUALS + 1;\r\n-\r\n-\t// \"<\"\r\n-\tstatic final int TOK_LT = TOK_GT + 1;\r\n-\r\n-\t// \">=\"\r\n-\tstatic final int TOK_GTE = TOK_LT + 1;\r\n-\r\n-\t// \"<=\"\r\n-\tstatic final int TOK_LTE = TOK_GTE + 1;\r\n-\r\n-\t// \"and\"\r\n-\tstatic final int TOK_AND = TOK_LTE + 1;\r\n-\r\n-\t// \"or\" (why is this different from TOK_VBAR?)\r\n-\tstatic final int TOK_OR = TOK_AND + 1;\r\n-\r\n-\t// \"mod\"\r\n-\tstatic final int TOK_MOD = TOK_OR + 1;\r\n-\r\n-\t// \"div\"\r\n-\tstatic final int TOK_DIV = TOK_MOD + 1;\r\n-\r\n-\tint currentToken = TOK_EOF;\r\n-\tString currentTokenValue = null;\r\n-\r\n-\tprivate int currentTokenStartIndex = 0;\r\n-\tprivate final String expr;\r\n-\tprivate int exprIndex = 0;\r\n-\tprivate final int exprLength;\r\n-\tprivate boolean recognizeOperator = false;\r\n-\r\n-\t/**\r\n-\t * construct with the string to be tokenized\r\n-\t */\r\n-\tExprTokenizer(final String s)\r\n-\t{\r\n-\t\tthis.expr = s;\r\n-\t\tthis.exprLength = s.length();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * lexes the next token, leaving the token type in <code>currentToken</code>, and the value (if applicable) in <code>tokenValue</code>\r\n-\t * \r\n-\t */\r\n-\tvoid next() throws ExprParseException\r\n-\t{\r\n-\t\tcurrentTokenValue = null;\r\n-\t\tcurrentTokenStartIndex = exprIndex;\r\n-\r\n-\t\t// a mode switch\r\n-\t\tboolean currentMaybeOperator = recognizeOperator;\r\n-\t\trecognizeOperator = true;\r\n-\r\n-\t\tfor (;;)\r\n-\t\t{\r\n-\t\t\tif (exprIndex >= exprLength)\r\n-\t\t\t{\r\n-\t\t\t\tcurrentToken = TOK_EOF;\r\n-\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t\tchar c = expr.charAt(exprIndex++);\r\n-\r\n-\t\t\tswitch (c)\r\n-\t\t\t{\r\n-\t\t\t\tcase ' ':\r\n-\t\t\t\tcase '\\t':\r\n-\t\t\t\tcase '\\r':\r\n-\t\t\t\tcase '\\n':\r\n-\t\t\t\t\tcurrentTokenStartIndex = exprIndex;\r\n-\t\t\t\tbreak;\r\n-\r\n-\t\t\t\tcase '<':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_LTE;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_LT;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '>':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_GTE;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_GT;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '/':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '/')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_SLASH_SLASH;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_SLASH;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '=':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_EQUALS;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '!':\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_NOT_EQUALS;\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\r\n-\r\n-\t\t\t\tcase ',':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_COMMA;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '|':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_VBAR;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '+':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_PLUS;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '-':\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\tcurrentToken = TOK_MINUS;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '(':\r\n-\t\t\t\t\tcurrentToken = TOK_LPAR;\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase ')':\r\n-\t\t\t\t\tcurrentToken = TOK_RPAR;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '[':\r\n-\t\t\t\t\tcurrentToken = TOK_LSQB;\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase ']':\r\n-\t\t\t\t\tcurrentToken = TOK_RSQB;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '\"':\r\n-\t\t\t\tcase '\\'':\r\n-\t\t\t\t\texprIndex = expr.indexOf(c, exprIndex);\r\n-\t\t\t\t\tif (exprIndex < 0)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex = currentTokenStartIndex + 1;\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"missing quote\");\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex++);\r\n-\t\t\t\t\tcurrentToken = TOK_LITERAL;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '$':\r\n-\t\t\t\t\tscanName();\r\n-\t\t\t\t\tif (exprIndex == currentTokenStartIndex + 1)\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == ':')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tscanName();\r\n-\t\t\t\t\t\tif (expr.charAt(exprIndex - 1) == ':')\r\n-\t\t\t\t\t\t\tthrow new ExprParseException(\"bad character after :\");\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex);\r\n-\t\t\t\t\tcurrentToken = TOK_VARIABLE_REF;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '*':\r\n-\t\t\t\t\tif (currentMaybeOperator)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\tcurrentToken = TOK_MULTIPLY;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_STAR;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '@':\r\n-\t\t\t\t\tcurrentToken = TOK_AT;\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '0':\r\n-\t\t\t\tcase '1':\r\n-\t\t\t\tcase '2':\r\n-\t\t\t\tcase '3':\r\n-\t\t\t\tcase '4':\r\n-\t\t\t\tcase '5':\r\n-\t\t\t\tcase '6':\r\n-\t\t\t\tcase '7':\r\n-\t\t\t\tcase '8':\r\n-\t\t\t\tcase '9':\r\n-\t\t\t\t\tscanDigits();\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '.')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tif (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\t\tscanDigits();\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\tcurrentToken = TOK_NUMBER;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tcase '.':\r\n-\t\t\t\t\tif (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n-\t\t\t\t\t{\r\n-\r\n-\t\t\t\t\t\t++exprIndex;\r\n-\t\t\t\t\t\tscanDigits();\r\n-\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\t\tcurrentToken = TOK_NUMBER;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '.')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tcurrentToken = TOK_DOT_DOT;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_DOT;\r\n-\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\treturn;\r\n-\r\n-\t\t\t\tdefault:\r\n-\t\t\t\t\t--exprIndex;\r\n-\t\t\t\t\tscanName();\r\n-\t\t\t\t\tif (exprIndex == currentTokenStartIndex)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tthrow new ExprParseException(\"illegal character\");\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (isAxis())\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\tcurrentToken = TOK_AXIS;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == ':')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\texprIndex++;\r\n-\t\t\t\t\t\tif (exprIndex < exprLength && expr.charAt(exprIndex) == '*')\r\n-\t\t\t\t\t\t{\r\n-\r\n-\t\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex++ - 1);\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_NAME_COLON_STAR;\r\n-\t\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t\t}\r\n-\r\n-\t\t\t\t\t\tscanName();\r\n-\t\t\t\t\t\tif (expr.charAt(exprIndex - 1) == ':')\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\tthrow new ExprParseException(\"bad character after :\");\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\t\tif (followingParen())\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_CNAME_LPAR;\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t{\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_QNAME;\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\tif (currentMaybeOperator)\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tif (currentTokenValue.equals(\"and\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_AND;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"or\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_OR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"mod\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_MOD;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"div\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_DIV;\r\n-\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t\tthrow new ExprParseException(\"unrecognized operator name\");\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t\treturn;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (followingParen())\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tif (currentTokenValue.equals(\"processing-instruction\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_PROCESSING_INSTRUCTION_LPAR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"comment\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_COMMENT_LPAR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"node\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_NODE_LPAR;\r\n-\t\t\t\t\t\telse if (currentTokenValue.equals(\"text\"))\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_TEXT_LPAR;\r\n-\t\t\t\t\t\telse\r\n-\t\t\t\t\t\t\tcurrentToken = TOK_FUNCTION_LPAR;\r\n-\t\t\t\t\t\trecognizeOperator = false;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\telse\r\n-\t\t\t\t\t\tcurrentToken = TOK_QNAME;\r\n-\t\t\t\t\treturn;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tprivate void scanName()\r\n-\t{\r\n-\t\tif (exprIndex < exprLength && isNameStartChar(expr.charAt(exprIndex)))\r\n-\t\t\twhile (++exprIndex < exprLength && isNameChar(expr.charAt(exprIndex)))\r\n-\t\t\t\t;\r\n-\t}\r\n-\r\n-\tprivate void scanDigits()\r\n-\t{\r\n-\t\twhile (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\r\n-\t\t\texprIndex++;\r\n-\t}\r\n-\r\n-\tprivate boolean followingParen()\r\n-\t{\r\n-\t\tfor (int i = exprIndex; i < exprLength; i++)\r\n-\t\t{\r\n-\t\t\tswitch (expr.charAt(i))\r\n-\t\t\t{\r\n-\t\t\t\tcase '(':\r\n-\t\t\t\t\texprIndex = i + 1;\r\n-\t\t\t\t\treturn true;\r\n-\t\t\t\tcase ' ':\r\n-\t\t\t\tcase '\\r':\r\n-\t\t\t\tcase '\\n':\r\n-\t\t\t\tcase '\\t':\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\t\treturn false;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tprivate boolean isAxis()\r\n-\t{\r\n-\t\tfor (int i = exprIndex; i < exprLength; i++)\r\n-\t\t{\r\n-\t\t\tswitch (expr.charAt(i))\r\n-\t\t\t{\r\n-\t\t\t\tcase ':':\r\n-\t\t\t\t\tif (i + 1 < exprLength && expr.charAt(i + 1) == ':')\r\n-\t\t\t\t\t{\r\n-\t\t\t\t\t\tcurrentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\r\n-\t\t\t\t\t\texprIndex = i + 2;\r\n-\t\t\t\t\t\treturn true;\r\n-\t\t\t\t\t}\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tcase ' ':\r\n-\t\t\t\tcase '\\r':\r\n-\t\t\t\tcase '\\n':\r\n-\t\t\t\tcase '\\t':\r\n-\t\t\t\tbreak;\r\n-\t\t\t\tdefault:\r\n-\t\t\t\t\treturn false;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tstatic private final String nameStartChars = \"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n-\tstatic private final String nameChars = \".-0123456789\";\r\n-\tstatic private final String digits = \"0123456789\";\r\n-\r\n-\tprivate static final boolean isDigit(char c)\r\n-\t{\r\n-\t\treturn digits.indexOf(c) >= 0;\r\n-\t}\r\n-\r\n-\t@SuppressWarnings(\"unused\")\r\n-\tprivate static final boolean isSpace(char c)\r\n-\t{\r\n-\t\tswitch (c)\r\n-\t\t{\r\n-\t\t\tcase ' ':\r\n-\t\t\tcase '\\r':\r\n-\t\t\tcase '\\n':\r\n-\t\t\tcase '\\t':\r\n-\t\t\t\treturn true;\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\tprivate static final boolean isNameStartChar(char c)\r\n-\t{\r\n-\t\treturn nameStartChars.indexOf(c) >= 0 || c >= 0x80;\r\n-\t}\r\n-\r\n-\tprivate static final boolean isNameChar(char c)\r\n-\t{\r\n-\t\treturn nameStartChars.indexOf(c) >= 0 || nameChars.indexOf(c) >= 0 || c >= 0x80;\r\n-\t}\r\n-\r\n-}\r\n+    // \"]\"\n+    static final int TOK_RSQB = TOK_LSQB + 1;\r\n+\r\n+    // 'xxx ' | \" xxx \"\n+    static final int TOK_LITERAL = TOK_RSQB + 1;\r\n+\r\n+    // [0-9].?[0-9]*\n+    static final int TOK_NUMBER = TOK_LITERAL + 1;\r\n+\r\n+    // e.g. \"ancestor-or-self::\"\n+    static final int TOK_AXIS = TOK_NUMBER + 1;\r\n+\r\n+    // \"foo(\"\n+    static final int TOK_FUNCTION_LPAR = TOK_AXIS + 1;\r\n+\r\n+    // ?? maybe: \"colonized name(\" ??\n+    static final int TOK_CNAME_LPAR = TOK_FUNCTION_LPAR + 1;\r\n+\r\n+    // \"$foo\"\n+    static final int TOK_VARIABLE_REF = TOK_CNAME_LPAR + 1;\r\n+\r\n+    // \"/\"\n+    static final int TOK_SLASH = TOK_VARIABLE_REF + 1;\r\n+\r\n+    // \"//\"\n+    static final int TOK_SLASH_SLASH = TOK_SLASH + 1;\r\n+\r\n+    // \"|\"\n+    static final int TOK_VBAR = TOK_SLASH_SLASH + 1;\r\n+\r\n+    // \",\"\n+    static final int TOK_COMMA = TOK_VBAR + 1;\r\n+\r\n+    // \"+\"\n+    static final int TOK_PLUS = TOK_COMMA + 1;\r\n+\r\n+    // \"-\"\n+    static final int TOK_MINUS = TOK_PLUS + 1;\r\n+\r\n+    // \"=\"\n+    static final int TOK_EQUALS = TOK_MINUS + 1;\r\n+\r\n+    // \"!+\"\n+    static final int TOK_NOT_EQUALS = TOK_EQUALS + 1;\r\n+\r\n+    // \">\"\n+    static final int TOK_GT = TOK_NOT_EQUALS + 1;\r\n+\r\n+    // \"<\"\n+    static final int TOK_LT = TOK_GT + 1;\r\n+\r\n+    // \">=\"\n+    static final int TOK_GTE = TOK_LT + 1;\r\n+\r\n+    // \"<=\"\n+    static final int TOK_LTE = TOK_GTE + 1;\r\n+\r\n+    // \"and\"\n+    static final int TOK_AND = TOK_LTE + 1;\r\n+\r\n+    // \"or\" (why is this different from TOK_VBAR?)\n+    static final int TOK_OR = TOK_AND + 1;\r\n+\r\n+    // \"mod\"\n+    static final int TOK_MOD = TOK_OR + 1;\r\n+\r\n+    // \"div\"\n+    static final int TOK_DIV = TOK_MOD + 1;\n+    int currentToken = TOK_EOF;\n+    String currentTokenValue = null;\n+    private int currentTokenStartIndex = 0;\n+    private final String expr;\n+    private int exprIndex = 0;\n+    private final int exprLength;\n+    private boolean recognizeOperator = false;\r\n+\r\n+    /**\r\n+     * construct with the string to be tokenized\r\n+     */\n+\n+    ExprTokenizer(final String s)\n+    {\n+        this.expr = s;\n+        this.exprLength = s.length();\n+    }\r\n+\r\n+    /**\r\n+     * lexes the next token, leaving the token type in <code>currentToken</code>, and the value (if applicable) in <code>tokenValue</code>\r\n+     * \r\n+     */\n+\n+    void next()\n+        throws ExprParseException\n+    {\n+        currentTokenValue = null;\n+        currentTokenStartIndex = exprIndex;\r\n+\r\n+        // a mode switch\n+\n+        boolean currentMaybeOperator = recognizeOperator;\n+        recognizeOperator = true;\n+        for (;;)\n+        {\n+            if (exprIndex >= exprLength)\n+            {\n+                currentToken = TOK_EOF;\n+                return;\n+            }\n+\n+            char c = expr.charAt(exprIndex++);\n+\n+            switch (c)\n+            {\n+                case ' ':\n+                case '\\t':\n+                case '\\r':\n+                case '\\n':\n+                currentTokenStartIndex = exprIndex;\n+                break;\n+                case '<':\n+                recognizeOperator = false;\n+                if (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\n+                {\n+                    exprIndex++;\n+                    currentToken = TOK_LTE;\n+                }\n+                else\n+                    currentToken = TOK_LT;\n+                return;\n+                case '>':\n+                recognizeOperator = false;\n+                if (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\n+                {\n+                    exprIndex++;\n+                    currentToken = TOK_GTE;\n+                }\n+                else\n+                    currentToken = TOK_GT;\n+                return;\n+                case '/':\n+                recognizeOperator = false;\n+                if (exprIndex < exprLength && expr.charAt(exprIndex) == '/')\n+                {\n+                    exprIndex++;\n+                    currentToken = TOK_SLASH_SLASH;\n+                }\n+                else\n+                    currentToken = TOK_SLASH;\n+                return;\n+                case '=':\n+                recognizeOperator = false;\n+                currentToken = TOK_EQUALS;\n+                return;\n+                case '!':\n+                if (exprIndex < exprLength && expr.charAt(exprIndex) == '=')\n+                {\n+                    exprIndex++;\n+                    currentToken = TOK_NOT_EQUALS;\n+                    recognizeOperator = false;\n+                    return;\n+                }\n+                throw new ExprParseException(\"illegal character\");\n+                case ',':\n+                recognizeOperator = false;\n+                currentToken = TOK_COMMA;\n+                return;\n+                case '|':\n+                recognizeOperator = false;\n+                currentToken = TOK_VBAR;\n+                return;\n+                case '+':\n+                recognizeOperator = false;\n+                currentToken = TOK_PLUS;\n+                return;\n+                case '-':\n+                recognizeOperator = false;\n+                currentToken = TOK_MINUS;\n+                return;\n+                case '(':\n+                currentToken = TOK_LPAR;\n+                recognizeOperator = false;\n+                return;\n+                case ')':\n+                currentToken = TOK_RPAR;\n+                return;\n+                case '[':\n+                currentToken = TOK_LSQB;\n+                recognizeOperator = false;\n+                return;\n+                case ']':\n+                currentToken = TOK_RSQB;\n+                return;\n+                case '\"':\n+                case '\\'':\n+                exprIndex = expr.indexOf(c, exprIndex);\n+                if (exprIndex < 0)\n+                {\n+                    exprIndex = currentTokenStartIndex + 1;\n+                    throw new ExprParseException(\"missing quote\");\n+                }\n+                currentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex++);\n+                currentToken = TOK_LITERAL;\n+                return;\n+                case '$':\n+                scanName();\n+                if (exprIndex == currentTokenStartIndex + 1)\n+                    throw new ExprParseException(\"illegal character\");\n+                if (exprIndex < exprLength && expr.charAt(exprIndex) == ':')\n+                {\n+                    exprIndex++;\n+                    scanName();\n+                    if (expr.charAt(exprIndex - 1) == ':')\n+                        throw new ExprParseException(\"bad character after :\");\n+                }\n+                currentTokenValue = expr.substring(currentTokenStartIndex + 1, exprIndex);\n+                currentToken = TOK_VARIABLE_REF;\n+                return;\n+                case '*':\n+                if (currentMaybeOperator)\n+                {\n+                    recognizeOperator = false;\n+                    currentToken = TOK_MULTIPLY;\n+                }\n+                else\n+                    currentToken = TOK_STAR;\n+                return;\n+                case '@':\n+                currentToken = TOK_AT;\n+                recognizeOperator = false;\n+                return;\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                scanDigits();\n+                if (exprIndex < exprLength && expr.charAt(exprIndex) == '.')\n+                {\n+                    exprIndex++;\n+                    if (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\n+                    {\n+                        exprIndex++;\n+                        scanDigits();\n+                    }\n+                }\n+                currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\n+                currentToken = TOK_NUMBER;\n+                return;\n+                case '.':\n+                if (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\n+                {\n+                    ++exprIndex;\n+                    scanDigits();\n+                    currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\n+                    currentToken = TOK_NUMBER;\n+                    return;\n+                }\n+                if (exprIndex < exprLength && expr.charAt(exprIndex) == '.')\n+                {\n+                    exprIndex++;\n+                    currentToken = TOK_DOT_DOT;\n+                }\n+                else\n+                    currentToken = TOK_DOT;\n+                recognizeOperator = false;\n+                return;\n+                default:\n+                --exprIndex;\n+                scanName();\n+                if (exprIndex == currentTokenStartIndex)\n+                {\n+                    throw new ExprParseException(\"illegal character\");\n+                }\n+                if (isAxis())\n+                {\n+                    recognizeOperator = false;\n+                    currentToken = TOK_AXIS;\n+                    return;\n+                }\n+                if (exprIndex < exprLength && expr.charAt(exprIndex) == ':')\n+                {\n+                    exprIndex++;\n+                    if (exprIndex < exprLength && expr.charAt(exprIndex) == '*')\n+                    {\n+                        currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex++ - 1);\n+                        currentToken = TOK_NAME_COLON_STAR;\n+                        return;\n+                    }\n+                    scanName();\n+                    if (expr.charAt(exprIndex - 1) == ':')\n+                    {\n+                        throw new ExprParseException(\"bad character after :\");\n+                    }\n+                    currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\n+                    if (followingParen())\n+                    {\n+                        recognizeOperator = false;\n+                        currentToken = TOK_CNAME_LPAR;\n+                    }\n+                    else\n+                    {\n+                        currentToken = TOK_QNAME;\n+                    }\n+                    return;\n+                }\n+                currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\n+                if (currentMaybeOperator)\n+                {\n+                    if (currentTokenValue.equals(\"and\"))\n+                        currentToken = TOK_AND;\n+                    else if (currentTokenValue.equals(\"or\"))\n+                    currentToken = TOK_OR;\n+                    else if (currentTokenValue.equals(\"mod\"))\n+                    currentToken = TOK_MOD;\n+                    else if (currentTokenValue.equals(\"div\"))\n+                    currentToken = TOK_DIV;\n+                    else\n+                    throw new ExprParseException(\"unrecognized operator name\");\n+                    recognizeOperator = false;\n+                    return;\n+                }\n+                if (followingParen())\n+                {\n+                    if (currentTokenValue.equals(\"processing-instruction\"))\n+                        currentToken = TOK_PROCESSING_INSTRUCTION_LPAR;\n+                    else if (currentTokenValue.equals(\"comment\"))\n+                    currentToken = TOK_COMMENT_LPAR;\n+                    else if (currentTokenValue.equals(\"node\"))\n+                    currentToken = TOK_NODE_LPAR;\n+                    else if (currentTokenValue.equals(\"text\"))\n+                    currentToken = TOK_TEXT_LPAR;\n+                    else\n+                    currentToken = TOK_FUNCTION_LPAR;\n+                    recognizeOperator = false;\n+                }\n+                else\n+                    currentToken = TOK_QNAME;\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void scanName()\n+    {\n+        if (exprIndex < exprLength && isNameStartChar(expr.charAt(exprIndex)))\n+        while (++exprIndex < exprLength && isNameChar(expr.charAt(exprIndex)))\n+        ;\n+    }\n+\n+    private void scanDigits()\n+    {\n+        while (exprIndex < exprLength && isDigit(expr.charAt(exprIndex)))\n+        exprIndex++;\n+    }\n+\n+    private boolean followingParen()\n+    {\n+        for (int i = exprIndex; i < exprLength; i++)\n+        {\n+            switch (expr.charAt(i))\n+            {\n+                case '(':\n+                exprIndex = i + 1;\n+                return true;\n+                case ' ':\n+                case '\\r':\n+                case '\\n':\n+                case '\\t':\n+                break;\n+                default:\n+                    return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isAxis()\n+    {\n+        for (int i = exprIndex; i < exprLength; i++)\n+        {\n+            switch (expr.charAt(i))\n+            {\n+                case ':':\n+                if (i + 1 < exprLength && expr.charAt(i + 1) == ':')\n+                {\n+                    currentTokenValue = expr.substring(currentTokenStartIndex, exprIndex);\n+                    exprIndex = i + 2;\n+                    return true;\n+                }\n+                break;\n+                case ' ':\n+                case '\\r':\n+                case '\\n':\n+                case '\\t':\n+                break;\n+                default:\n+                    return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static private final String nameStartChars = \"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+    static private final String nameChars = \".-0123456789\";\n+    static private final String digits = \"0123456789\";\n+    private static final boolean isDigit(char c)\n+    {\n+        return digits.indexOf(c) >= 0;\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static final boolean isSpace(char c)\n+    {\n+        switch (c)\n+        {\n+            case ' ':\n+            case '\\r':\n+            case '\\n':\n+            case '\\t':\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    private static final boolean isNameStartChar(char c)\n+    {\n+        return nameStartChars.indexOf(c) >= 0 || c >= 0x80;\n+    }\n+\n+    private static final boolean isNameChar(char c)\n+    {\n+        return nameStartChars.indexOf(c) >= 0 || nameChars.indexOf(c) >= 0 || c >= 0x80;\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 516
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "33",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/347/ExprTokenizer.java\nindex a0b9906552d..68c33f9d967 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/347/ExprTokenizer.java\n@@ -29,7 +29,7 @@ import org.genxdm.xpath.v10.ExprParseException;\n  */\r\n class ExprTokenizer\r\n {\r\n-\t//\r\n+//  // The tokens\r\n \t// The tokens\r\n \t//\r\n \tpublic static String toString(final int token)\r\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "34",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/347/ExprTokenizer.java\nindex a0b9906552d..b287ef95325 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/347/ExprTokenizer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/347/ExprTokenizer.java\n@@ -29,8 +29,8 @@ import org.genxdm.xpath.v10.ExprParseException;\n  */\r\n class ExprTokenizer\r\n {\r\n-\t//\r\n-\t// The tokens\r\n+    //\r\n+ // The tokens\r\n \t//\r\n \tpublic static String toString(final int token)\r\n \t{\r\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}