{
    "project_name": "IQSS-dataverse",
    "error_id": "59",
    "information": {
        "errors": [
            {
                "line": "448",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            if ( tkn.getExpireTime().before( new Timestamp(new Date().getTime())) ) {\n                em.remove(tkn);\n\t\tlogger.info(\"attempted access with expired token: \" + apiToken);\n                return null;\n            }\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/59/AuthenticationServiceBean.java\nindex 349a86301a6..fdf85706469 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/59/AuthenticationServiceBean.java\n@@ -445,7 +445,7 @@ public class AuthenticationServiceBean {\n         if ( tkn.getExpireTime() != null ) {\n             if ( tkn.getExpireTime().before( new Timestamp(new Date().getTime())) ) {\n                 em.remove(tkn);\n-\t\tlogger.info(\"attempted access with expired token: \" + apiToken);\n+        logger.info(\"attempted access with expired token: \" + apiToken);\n                 return null;\n             }\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/59/AuthenticationServiceBean.java\nindex 349a86301a6..919bb973878 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/59/AuthenticationServiceBean.java\n@@ -73,410 +73,425 @@ import javax.validation.ValidatorFactory;\n  * AuthenticationService is for general authentication-related operations.\n  * It's no longer responsible for registering and listing\n  * AuthenticationProviders! A dedicated singleton has been created for that\n- * purpose - AuthenticationProvidersRegistrationServiceBean - and all the \n- * related code has been moved there. \n- * \n+ * purpose - AuthenticationProvidersRegistrationServiceBean - and all the\n+ * related code has been moved there.\n  */\n @Named\n @Stateless\n public class AuthenticationServiceBean {\n-    private static final Logger logger = Logger.getLogger(AuthenticationServiceBean.class.getName());\n-    \n-    @EJB\n-    AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationService;\n-    \n-    @EJB\n-    BuiltinUserServiceBean builtinUserServiceBean;\n-    \n-    @EJB\n-    IndexServiceBean indexService;\n-    \n-    @EJB\n-    protected ActionLogServiceBean actionLogSvc;\n-    \n-    @EJB\n-    UserNotificationServiceBean userNotificationService;\n+  private static final Logger logger = Logger.getLogger(AuthenticationServiceBean.class.getName());\n \n-    @EJB\n-    ConfirmEmailServiceBean confirmEmailService;\n-    \n-    @EJB\n-    PasswordResetServiceBean passwordResetServiceBean;\n+  @EJB\n+  AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationService;\n \n-    @EJB\n-    UserServiceBean userService;\n+  @EJB\n+  BuiltinUserServiceBean builtinUserServiceBean;\n \n-    @EJB\n-    PasswordValidatorServiceBean passwordValidatorService;\n-    \n-    @EJB\n-    DvObjectServiceBean dvObjSvc;\n-    \n-    @EJB\n-    RoleAssigneeServiceBean roleAssigneeSvc;\n-    \n-    @EJB\n-    GuestbookResponseServiceBean gbRespSvc;\n-    \n-    @EJB\n-    DatasetVersionServiceBean datasetVersionService;\n-    \n-    @EJB \n-    ExplicitGroupServiceBean explicitGroupService;\n+  @EJB\n+  IndexServiceBean indexService;\n \n-    @EJB\n-    SavedSearchServiceBean savedSearchService;\n+  @EJB\n+  protected ActionLogServiceBean actionLogSvc;\n \n-    @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n-    private EntityManager em;\n-        \n-        \n-    public AbstractOAuth2AuthenticationProvider getOAuth2Provider( String id ) {\n-        return authProvidersRegistrationService.getOAuth2AuthProvidersMap().get(id);\n-    }\n-    \n-    public Set<AbstractOAuth2AuthenticationProvider> getOAuth2Providers() {\n-        return new HashSet<>(authProvidersRegistrationService.getOAuth2AuthProvidersMap().values());\n-    }\n-    \n-    public Set<String> getAuthenticationProviderIds() {\n-        return authProvidersRegistrationService.getAuthenticationProvidersMap().keySet();\n-    }\n+  @EJB\n+  UserNotificationServiceBean userNotificationService;\n \n-    public Collection<AuthenticationProvider> getAuthenticationProviders() {\n-        return authProvidersRegistrationService.getAuthenticationProvidersMap().values();\n-    }\n-    \n-    public <T extends AuthenticationProvider> Set<String> getAuthenticationProviderIdsOfType( Class<T> aClass ) {\n-        Set<String> retVal = new TreeSet<>();\n-        for ( Map.Entry<String, AuthenticationProvider> p : authProvidersRegistrationService.getAuthenticationProvidersMap().entrySet() ) {\n-            if ( aClass.isAssignableFrom( p.getValue().getClass() ) ) {\n-                retVal.add( p.getKey() );\n-            }\n-        }\n-        return retVal;\n-    }\n-    \n-    public AuthenticationProviderFactory getProviderFactory( String alias ) {\n-        return authProvidersRegistrationService.getProviderFactoriesMap().get(alias);\n-    }\n-    \n-    public AuthenticationProvider getAuthenticationProvider( String id ) {\n-        return authProvidersRegistrationService.getAuthenticationProvidersMap().get( id );\n-    }\n-    \n-    public AuthenticatedUser findByID(Object pk){\n-        if (pk==null){\n-            return null;\n-        }\n-        return em.find(AuthenticatedUser.class, pk);\n-    }\n-\n-    public void removeApiToken(AuthenticatedUser user){\n-        if (user!=null) {\n-            ApiToken apiToken = findApiTokenByUser(user);\n-            if (apiToken != null) {\n-                em.remove(apiToken);\n-            }\n-        }\n-    }\n-    \n-    public boolean isOrcidEnabled() {\n-        return authProvidersRegistrationService.getOAuth2AuthProvidersMap().values().stream().anyMatch( s -> s.getId().toLowerCase().contains(\"orcid\") );\n-    }\n-    \n-    /**\n-     * Use with care! This method was written primarily for developers\n-     * interested in API testing who want to:\n-     * \n-     * 1. Create a temporary user and get an API token.\n-     * \n-     * 2. Do some work with that API token.\n-     * \n-     * 3. Delete all the stuff that was created with the API token.\n-     * \n-     * 4. Delete the temporary user.\n-     * \n-     * Before calling this method, make sure you've deleted all the stuff tied\n-     * to the user, including stuff they've created, role assignments, group\n-     * assignments, etc. See the \"removeAuthentictedUserItems\" (sic) method.\n-     */\n-    public void deleteAuthenticatedUser(Object pk) {\n-        AuthenticatedUser user = em.find(AuthenticatedUser.class, pk);\n+  @EJB\n+  ConfirmEmailServiceBean confirmEmailService;\n \n-        if (user != null) {\n-            ApiToken apiToken = findApiTokenByUser(user);\n-            if (apiToken != null) {\n-                em.remove(apiToken);\n-            }\n-            // @todo: this should be handed down to the service instead of doing it here.\n-            ConfirmEmailData confirmEmailData = confirmEmailService.findSingleConfirmEmailDataByUser(user);\n-            if (confirmEmailData != null) {\n-                /**\n-                 * @todo This could probably be a cascade delete instead.\n-                 */\n-                em.remove(confirmEmailData);\n-            }\n-            userNotificationService.findByUser(user.getId()).forEach(userNotificationService::delete);\n-            \n-            AuthenticationProvider prv = lookupProvider(user);\n-            if ( prv != null && prv.isUserDeletionAllowed() ) {\n-                prv.deleteUser(user.getAuthenticatedUserLookup().getPersistentUserId());\n-            }\n-            \n-            actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"deleteUser\")\n-                .setInfo(user.getUserIdentifier()));\n-            em.remove(user.getAuthenticatedUserLookup());         \n-            em.remove(user);\n+  @EJB\n+  PasswordResetServiceBean passwordResetServiceBean;\n \n-        }\n-    }\n-            \n-    public AuthenticatedUser getAuthenticatedUser( String identifier ) {\n-        try {\n-            return em.createNamedQuery(\"AuthenticatedUser.findByIdentifier\", AuthenticatedUser.class)\n-                    .setParameter(\"identifier\", identifier)\n-                    .getSingleResult();\n-        } catch ( NoResultException nre ) {\n-            return null;\n-        }\n-    }\n-    \n-    public AuthenticatedUser getAuthenticatedUserWithProvider( String identifier ) {\n-        try {\n-            AuthenticatedUser authenticatedUser = em.createNamedQuery(\"AuthenticatedUser.findByIdentifier\", AuthenticatedUser.class)\n-                    .setParameter(\"identifier\", identifier)\n-                    .getSingleResult();\n-            AuthenticatedUserLookup aul = em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthUser\", AuthenticatedUserLookup.class)\n-                    .setParameter(\"authUser\", authenticatedUser)\n-                    .getSingleResult();\n-            authenticatedUser.setAuthProviderId(aul.getAuthenticationProviderId());\n-            \n-            return authenticatedUser;\n-        } catch ( NoResultException nre ) {\n-            return null;\n-        }\n-    }\n-    \n-    public AuthenticatedUser getAdminUser() {\n-        try {\n-            return em.createNamedQuery(\"AuthenticatedUser.findAdminUser\", AuthenticatedUser.class)\n-                    .setMaxResults(1)\n-                    .getSingleResult();\n-        } catch (Exception ex) {\n-            return null;\n-        }\n-    }\n+  @EJB\n+  UserServiceBean userService;\n \n-    public AuthenticatedUser getAuthenticatedUserByEmail( String email ) {\n-        try {\n-            return em.createNamedQuery(\"AuthenticatedUser.findByEmail\", AuthenticatedUser.class)\n-                    .setParameter(\"email\", email)\n-                    .getSingleResult();\n-        } catch ( NoResultException ex ) {\n-            logger.log(Level.INFO, \"no user found using {0}\", email);\n-            return null;\n-        } catch ( NonUniqueResultException ex ) {\n-            logger.log(Level.INFO, \"multiple users found using {0}: {1}\", new Object[]{email, ex});\n-            return null;\n-        }\n-    }\n+  @EJB\n+  PasswordValidatorServiceBean passwordValidatorService;\n \n-    /**\n-     * Returns an {@link AuthenticatedUser} matching the passed provider id and the authentication request. If\n-     *  no such user exist, it is created and then returned.\n-     * \n-     * <strong>Invariant:</strong> upon successful return from this call, an {@link AuthenticatedUser} record \n-     * matching the request and provider exists in the database.\n-     * \n-     * @param authenticationProviderId\n-     * @param req\n-     * @return The authenticated user for the passed provider id and authentication request.\n-     * @throws AuthenticationFailedException \n-     */\n-    public AuthenticatedUser getUpdateAuthenticatedUser( String authenticationProviderId, AuthenticationRequest req ) throws AuthenticationFailedException {\n-        AuthenticationProvider prv = getAuthenticationProvider(authenticationProviderId);\n-        if ( prv == null ) throw new IllegalArgumentException(\"No authentication provider listed under id \" + authenticationProviderId );\n-        if ( ! (prv instanceof CredentialsAuthenticationProvider) ) {\n-            throw new IllegalArgumentException( authenticationProviderId + \" does not support credentials-based authentication.\" );\n-        }\n-        AuthenticationResponse resp = ((CredentialsAuthenticationProvider)prv).authenticate(req);\n-        \n-        if ( resp.getStatus() == AuthenticationResponse.Status.SUCCESS ) {\n-            // yay! see if we already have this user.\n-            AuthenticatedUser user = lookupUser(authenticationProviderId, resp.getUserId());\n-\n-            if (user != null && !user.isDeactivated()) {\n-                user = userService.updateLastLogin(user);\n-            }\n-            \n-            if ( user == null ) {\n-                throw new IllegalStateException(\"Authenticated user does not exist. The functionality to support creating one at this point in authentication has been removed.\");\n-                //return createAuthenticatedUser(\n-                //        new UserRecordIdentifier(authenticationProviderId, resp.getUserId()), resp.getUserId(), resp.getUserDisplayInfo(), true );\n-            } else {\n-                if (BuiltinAuthenticationProvider.PROVIDER_ID.equals(user.getAuthenticatedUserLookup().getAuthenticationProviderId())) {\n-                    return user;\n-                } else {\n-                    return updateAuthenticatedUser(user, resp.getUserDisplayInfo());\n-                }\n-            }\n-        } else { \n-            throw new AuthenticationFailedException(resp, \"Authentication Failed: \" + resp.getMessage());\n-        }\n-    }\n-    \n-    /**\n-     * @param email\n-     * @return {@code true} iff the none of the authenticated users has the passed email address.\n-     */\n-    public boolean isEmailAddressAvailable(String email) {\n-        return em.createNamedQuery(\"AuthenticatedUser.findByEmail\", AuthenticatedUser.class)\n-                 .setParameter(\"email\", email)\n-                 .getResultList().isEmpty();\n-    }\n-    \n-    public AuthenticatedUser lookupUser(UserRecordIdentifier id) {\n-        return lookupUser(id.repoId, id.userIdInRepo);\n-    }\n-    \n-    public AuthenticatedUser lookupUser(String authPrvId, String userPersistentId) {\n-        TypedQuery<AuthenticatedUserLookup> typedQuery = em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthPrvID_PersUserId\", AuthenticatedUserLookup.class);\n-        typedQuery.setParameter(\"authPrvId\", authPrvId);\n-        typedQuery.setParameter(\"persUserId\", userPersistentId);\n-        try {\n-            AuthenticatedUserLookup au = typedQuery.getSingleResult();\n-            return au.getAuthenticatedUser();\n-        } catch (NoResultException | NonUniqueResultException ex) {\n-            return null;\n-        }\n-    }\n-    \n-    public AuthenticationProvider lookupProvider( AuthenticatedUser user )  {\n-        return authProvidersRegistrationService.getAuthenticationProvidersMap().get(user.getAuthenticatedUserLookup().getAuthenticationProviderId());\n-    }\n-    \n-    public ApiToken findApiToken(String token) {\n-        try {\n-            return em.createNamedQuery(\"ApiToken.findByTokenString\", ApiToken.class)\n-                    .setParameter(\"tokenString\", token)\n-                    .getSingleResult();\n-        } catch (NoResultException ex) {\n-            return null;\n-        }\n-    }\n-    \n-    public ApiToken findApiTokenByUser(AuthenticatedUser au) {\n-        if (au == null) {\n-            return null;\n-        }\n-        TypedQuery<ApiToken> typedQuery = em.createNamedQuery(\"ApiToken.findByUser\", ApiToken.class);\n-        typedQuery.setParameter(\"user\", au);\n-        List<ApiToken> tokens = typedQuery.getResultList();\n-        Timestamp latest = new Timestamp(java.time.Instant.now().getEpochSecond()*1000);\n-        if (tokens.isEmpty()) {\n-            // Normal case - no token exists\n-            return null;\n-        }\n-        if (tokens.size() == 1) {\n-            // Normal case - one token that may or may not have expired\n-            ApiToken token = tokens.get(0);\n-            if (token.getExpireTime().before(latest)) {\n-                // Don't return an expired token which is unusable, delete it instead\n-                em.remove(token);\n-                return null;\n-            } else {\n-                return tokens.get(0);\n-            }\n+  @EJB\n+  DvObjectServiceBean dvObjSvc;\n+\n+  @EJB\n+  RoleAssigneeServiceBean roleAssigneeSvc;\n+\n+  @EJB\n+  GuestbookResponseServiceBean gbRespSvc;\n+\n+  @EJB\n+  DatasetVersionServiceBean datasetVersionService;\n+\n+  @EJB\n+  ExplicitGroupServiceBean explicitGroupService;\n+\n+  @EJB\n+  SavedSearchServiceBean savedSearchService;\n+\n+  @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n+  private EntityManager em;\n+\n+\n+  public AbstractOAuth2AuthenticationProvider getOAuth2Provider(String id) {\n+    return authProvidersRegistrationService.getOAuth2AuthProvidersMap().get(id);\n+  }\n+\n+  public Set<AbstractOAuth2AuthenticationProvider> getOAuth2Providers() {\n+    return new HashSet<>(authProvidersRegistrationService.getOAuth2AuthProvidersMap().values());\n+  }\n+\n+  public Set<String> getAuthenticationProviderIds() {\n+    return authProvidersRegistrationService.getAuthenticationProvidersMap().keySet();\n+  }\n+\n+  public Collection<AuthenticationProvider> getAuthenticationProviders() {\n+    return authProvidersRegistrationService.getAuthenticationProvidersMap().values();\n+  }\n+\n+  public <T extends AuthenticationProvider> Set<String> getAuthenticationProviderIdsOfType(Class<T> aClass) {\n+    Set<String> retVal = new TreeSet<>();\n+    for (Map.Entry<String, AuthenticationProvider> p : authProvidersRegistrationService.getAuthenticationProvidersMap()\n+      .entrySet()) {\n+      if (aClass.isAssignableFrom(p.getValue().getClass())) {\n+        retVal.add(p.getKey());\n+      }\n+    }\n+    return retVal;\n+  }\n+\n+  public AuthenticationProviderFactory getProviderFactory(String alias) {\n+    return authProvidersRegistrationService.getProviderFactoriesMap().get(alias);\n+  }\n+\n+  public AuthenticationProvider getAuthenticationProvider(String id) {\n+    return authProvidersRegistrationService.getAuthenticationProvidersMap().get(id);\n+  }\n+\n+  public AuthenticatedUser findByID(Object pk) {\n+    if (pk == null) {\n+      return null;\n+    }\n+    return em.find(AuthenticatedUser.class, pk);\n+  }\n+\n+  public void removeApiToken(AuthenticatedUser user) {\n+    if (user != null) {\n+      ApiToken apiToken = findApiTokenByUser(user);\n+      if (apiToken != null) {\n+        em.remove(apiToken);\n+      }\n+    }\n+  }\n+\n+  public boolean isOrcidEnabled() {\n+    return authProvidersRegistrationService.getOAuth2AuthProvidersMap().values().stream()\n+      .anyMatch(s -> s.getId().toLowerCase().contains(\"orcid\"));\n+  }\n+\n+  /**\n+   * Use with care! This method was written primarily for developers\n+   * interested in API testing who want to:\n+   * <p>\n+   * 1. Create a temporary user and get an API token.\n+   * <p>\n+   * 2. Do some work with that API token.\n+   * <p>\n+   * 3. Delete all the stuff that was created with the API token.\n+   * <p>\n+   * 4. Delete the temporary user.\n+   * <p>\n+   * Before calling this method, make sure you've deleted all the stuff tied\n+   * to the user, including stuff they've created, role assignments, group\n+   * assignments, etc. See the \"removeAuthentictedUserItems\" (sic) method.\n+   */\n+  public void deleteAuthenticatedUser(Object pk) {\n+    AuthenticatedUser user = em.find(AuthenticatedUser.class, pk);\n+\n+    if (user != null) {\n+      ApiToken apiToken = findApiTokenByUser(user);\n+      if (apiToken != null) {\n+        em.remove(apiToken);\n+      }\n+      // @todo: this should be handed down to the service instead of doing it here.\n+      ConfirmEmailData confirmEmailData = confirmEmailService.findSingleConfirmEmailDataByUser(user);\n+      if (confirmEmailData != null) {\n+        /**\n+         * @todo This could probably be a cascade delete instead.\n+         */\n+        em.remove(confirmEmailData);\n+      }\n+      userNotificationService.findByUser(user.getId()).forEach(userNotificationService::delete);\n+\n+      AuthenticationProvider prv = lookupProvider(user);\n+      if (prv != null && prv.isUserDeletionAllowed()) {\n+        prv.deleteUser(user.getAuthenticatedUserLookup().getPersistentUserId());\n+      }\n+\n+      actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"deleteUser\")\n+        .setInfo(user.getUserIdentifier()));\n+      em.remove(user.getAuthenticatedUserLookup());\n+      em.remove(user);\n+\n+    }\n+  }\n+\n+  public AuthenticatedUser getAuthenticatedUser(String identifier) {\n+    try {\n+      return em.createNamedQuery(\"AuthenticatedUser.findByIdentifier\", AuthenticatedUser.class)\n+        .setParameter(\"identifier\", identifier)\n+        .getSingleResult();\n+    } catch (NoResultException nre) {\n+      return null;\n+    }\n+  }\n+\n+  public AuthenticatedUser getAuthenticatedUserWithProvider(String identifier) {\n+    try {\n+      AuthenticatedUser authenticatedUser =\n+        em.createNamedQuery(\"AuthenticatedUser.findByIdentifier\", AuthenticatedUser.class)\n+          .setParameter(\"identifier\", identifier)\n+          .getSingleResult();\n+      AuthenticatedUserLookup aul =\n+        em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthUser\", AuthenticatedUserLookup.class)\n+          .setParameter(\"authUser\", authenticatedUser)\n+          .getSingleResult();\n+      authenticatedUser.setAuthProviderId(aul.getAuthenticationProviderId());\n+\n+      return authenticatedUser;\n+    } catch (NoResultException nre) {\n+      return null;\n+    }\n+  }\n+\n+  public AuthenticatedUser getAdminUser() {\n+    try {\n+      return em.createNamedQuery(\"AuthenticatedUser.findAdminUser\", AuthenticatedUser.class)\n+        .setMaxResults(1)\n+        .getSingleResult();\n+    } catch (Exception ex) {\n+      return null;\n+    }\n+  }\n+\n+  public AuthenticatedUser getAuthenticatedUserByEmail(String email) {\n+    try {\n+      return em.createNamedQuery(\"AuthenticatedUser.findByEmail\", AuthenticatedUser.class)\n+        .setParameter(\"email\", email)\n+        .getSingleResult();\n+    } catch (NoResultException ex) {\n+      logger.log(Level.INFO, \"no user found using {0}\", email);\n+      return null;\n+    } catch (NonUniqueResultException ex) {\n+      logger.log(Level.INFO, \"multiple users found using {0}: {1}\", new Object[] {email, ex});\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Returns an {@link AuthenticatedUser} matching the passed provider id and the authentication request. If\n+   * no such user exist, it is created and then returned.\n+   *\n+   * <strong>Invariant:</strong> upon successful return from this call, an {@link AuthenticatedUser} record\n+   * matching the request and provider exists in the database.\n+   *\n+   * @param authenticationProviderId\n+   * @param req\n+   * @return The authenticated user for the passed provider id and authentication request.\n+   * @throws AuthenticationFailedException\n+   */\n+  public AuthenticatedUser getUpdateAuthenticatedUser(String authenticationProviderId, AuthenticationRequest req)\n+    throws AuthenticationFailedException {\n+    AuthenticationProvider prv = getAuthenticationProvider(authenticationProviderId);\n+    if (prv == null) {\n+      throw new IllegalArgumentException(\"No authentication provider listed under id \" + authenticationProviderId);\n+    }\n+    if (!(prv instanceof CredentialsAuthenticationProvider)) {\n+      throw new IllegalArgumentException(\n+        authenticationProviderId + \" does not support credentials-based authentication.\");\n+    }\n+    AuthenticationResponse resp = ((CredentialsAuthenticationProvider) prv).authenticate(req);\n+\n+    if (resp.getStatus() == AuthenticationResponse.Status.SUCCESS) {\n+      // yay! see if we already have this user.\n+      AuthenticatedUser user = lookupUser(authenticationProviderId, resp.getUserId());\n+\n+      if (user != null && !user.isDeactivated()) {\n+        user = userService.updateLastLogin(user);\n+      }\n+\n+      if (user == null) {\n+        throw new IllegalStateException(\n+          \"Authenticated user does not exist. The functionality to support creating one at this point in authentication has been removed.\");\n+        //return createAuthenticatedUser(\n+        //        new UserRecordIdentifier(authenticationProviderId, resp.getUserId()), resp.getUserId(), resp.getUserDisplayInfo(), true );\n+      } else {\n+        if (BuiltinAuthenticationProvider.PROVIDER_ID\n+          .equals(user.getAuthenticatedUserLookup().getAuthenticationProviderId())) {\n+          return user;\n         } else {\n-            // We have more than one due to https://github.com/IQSS/dataverse/issues/6389 or\n-            // similar, so we should delete all but one token.\n-            // Since having an expired token also makes no sense, if we only have an expired\n-            // token, remove that as well\n-            ApiToken goodToken = null;\n-            for (ApiToken token : tokens) {\n-                Timestamp time = token.getExpireTime();\n-                if (time.before(latest)) {\n-                    em.remove(token);\n-                } else {\n-                    if(goodToken != null) {\n-                      em.remove(goodToken);\n-                      goodToken = null;\n-                    }\n-                    latest = time;\n-                    goodToken = token;\n-                }\n-            }\n-            // Null if there are no un-expired ones\n-            return goodToken;\n-        }\n+          return updateAuthenticatedUser(user, resp.getUserDisplayInfo());\n+        }\n+      }\n+    } else {\n+      throw new AuthenticationFailedException(resp, \"Authentication Failed: \" + resp.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * @param email\n+   * @return {@code true} iff the none of the authenticated users has the passed email address.\n+   */\n+  public boolean isEmailAddressAvailable(String email) {\n+    return em.createNamedQuery(\"AuthenticatedUser.findByEmail\", AuthenticatedUser.class)\n+      .setParameter(\"email\", email)\n+      .getResultList().isEmpty();\n+  }\n+\n+  public AuthenticatedUser lookupUser(UserRecordIdentifier id) {\n+    return lookupUser(id.repoId, id.userIdInRepo);\n+  }\n+\n+  public AuthenticatedUser lookupUser(String authPrvId, String userPersistentId) {\n+    TypedQuery<AuthenticatedUserLookup> typedQuery =\n+      em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthPrvID_PersUserId\", AuthenticatedUserLookup.class);\n+    typedQuery.setParameter(\"authPrvId\", authPrvId);\n+    typedQuery.setParameter(\"persUserId\", userPersistentId);\n+    try {\n+      AuthenticatedUserLookup au = typedQuery.getSingleResult();\n+      return au.getAuthenticatedUser();\n+    } catch (NoResultException | NonUniqueResultException ex) {\n+      return null;\n+    }\n+  }\n+\n+  public AuthenticationProvider lookupProvider(AuthenticatedUser user) {\n+    return authProvidersRegistrationService.getAuthenticationProvidersMap()\n+      .get(user.getAuthenticatedUserLookup().getAuthenticationProviderId());\n+  }\n+\n+  public ApiToken findApiToken(String token) {\n+    try {\n+      return em.createNamedQuery(\"ApiToken.findByTokenString\", ApiToken.class)\n+        .setParameter(\"tokenString\", token)\n+        .getSingleResult();\n+    } catch (NoResultException ex) {\n+      return null;\n+    }\n+  }\n+\n+  public ApiToken findApiTokenByUser(AuthenticatedUser au) {\n+    if (au == null) {\n+      return null;\n+    }\n+    TypedQuery<ApiToken> typedQuery = em.createNamedQuery(\"ApiToken.findByUser\", ApiToken.class);\n+    typedQuery.setParameter(\"user\", au);\n+    List<ApiToken> tokens = typedQuery.getResultList();\n+    Timestamp latest = new Timestamp(java.time.Instant.now().getEpochSecond() * 1000);\n+    if (tokens.isEmpty()) {\n+      // Normal case - no token exists\n+      return null;\n+    }\n+    if (tokens.size() == 1) {\n+      // Normal case - one token that may or may not have expired\n+      ApiToken token = tokens.get(0);\n+      if (token.getExpireTime().before(latest)) {\n+        // Don't return an expired token which is unusable, delete it instead\n+        em.remove(token);\n+        return null;\n+      } else {\n+        return tokens.get(0);\n+      }\n+    } else {\n+      // We have more than one due to https://github.com/IQSS/dataverse/issues/6389 or\n+      // similar, so we should delete all but one token.\n+      // Since having an expired token also makes no sense, if we only have an expired\n+      // token, remove that as well\n+      ApiToken goodToken = null;\n+      for (ApiToken token : tokens) {\n+        Timestamp time = token.getExpireTime();\n+        if (time.before(latest)) {\n+          em.remove(token);\n+        } else {\n+          if (goodToken != null) {\n+            em.remove(goodToken);\n+            goodToken = null;\n+          }\n+          latest = time;\n+          goodToken = token;\n+        }\n+      }\n+      // Null if there are no un-expired ones\n+      return goodToken;\n+    }\n+  }\n+\n+\n+  // A method for generating a new API token;\n+  // TODO: this is a simple, one-size-fits-all solution; we'll need\n+  // to expand this system, to be able to generate tokens with different\n+  // lifecycles/valid for specific actions only, etc.\n+  // -- L.A. 4.0 beta12\n+  public ApiToken generateApiTokenForUser(AuthenticatedUser au) {\n+    if (au == null) {\n+      return null;\n+    }\n+\n+    ApiToken apiToken = new ApiToken();\n+    apiToken.setTokenString(java.util.UUID.randomUUID().toString());\n+    apiToken.setAuthenticatedUser(au);\n+    Calendar c = Calendar.getInstance();\n+    apiToken.setCreateTime(new Timestamp(c.getTimeInMillis()));\n+    c.roll(Calendar.YEAR, 1);\n+    apiToken.setExpireTime(new Timestamp(c.getTimeInMillis()));\n+    save(apiToken);\n+    actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"generateApiToken\")\n+      .setInfo(\"user:\" + au.getIdentifier() + \" token:\" + apiToken.getTokenString()));\n+\n+    return apiToken;\n+  }\n+\n+  public AuthenticatedUser lookupUser(String apiToken) {\n+    ApiToken tkn = findApiToken(apiToken);\n+    if (tkn == null) {\n+      return null;\n+    }\n+\n+    if (tkn.isDisabled()) {\n+      return null;\n+    }\n+    if (tkn.getExpireTime() != null) {\n+      if (tkn.getExpireTime().before(new Timestamp(new Date().getTime()))) {\n+        em.remove(tkn);\n+        logger.info(\"attempted access with expired token: \" + apiToken);\n+        return null;\n+      }\n     }\n-    \n-    \n-    // A method for generating a new API token;\n-    // TODO: this is a simple, one-size-fits-all solution; we'll need\n-    // to expand this system, to be able to generate tokens with different\n-    // lifecycles/valid for specific actions only, etc. \n-    // -- L.A. 4.0 beta12\n-    public ApiToken generateApiTokenForUser(AuthenticatedUser au) {\n-        if (au == null) {\n-            return null;\n-        }\n \n-        ApiToken apiToken = new ApiToken();\n-        apiToken.setTokenString(java.util.UUID.randomUUID().toString());\n-        apiToken.setAuthenticatedUser(au);\n-        Calendar c = Calendar.getInstance();\n-        apiToken.setCreateTime(new Timestamp(c.getTimeInMillis()));\n-        c.roll(Calendar.YEAR, 1);\n-        apiToken.setExpireTime(new Timestamp(c.getTimeInMillis()));\n-        save(apiToken);\n-        actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"generateApiToken\")\n-            .setInfo(\"user:\" + au.getIdentifier() + \" token:\" +  apiToken.getTokenString()));\n-\n-        return apiToken;\n-    }\n-\n-    public AuthenticatedUser lookupUser( String apiToken ) {\n-        ApiToken tkn = findApiToken(apiToken);\n-        if ( tkn == null ) return null;\n-        \n-        if ( tkn.isDisabled() ) return null;\n-        if ( tkn.getExpireTime() != null ) {\n-            if ( tkn.getExpireTime().before( new Timestamp(new Date().getTime())) ) {\n-                em.remove(tkn);\n-\t\tlogger.info(\"attempted access with expired token: \" + apiToken);\n-                return null;\n-            }\n-        }\n-        \n-        AuthenticatedUser user = tkn.getAuthenticatedUser();\n-        if (!user.isDeactivated()) {\n-            return user;\n-        } else {\n-            logger.info(\"attempted access with token from deactivated user: \" + apiToken);\n-            return null;\n-        }\n+    AuthenticatedUser user = tkn.getAuthenticatedUser();\n+    if (!user.isDeactivated()) {\n+      return user;\n+    } else {\n+      logger.info(\"attempted access with token from deactivated user: \" + apiToken);\n+      return null;\n     }\n-    \n-    public AuthenticatedUser lookupUserForWorkflowInvocationID(String wfId) {\n-        try {\n-            PendingWorkflowInvocation pwfi = em.find(PendingWorkflowInvocation.class, wfId);\n-            if (pwfi == null) {\n-                return null;\n-            }\n-            if (pwfi.getUserId().startsWith(AuthenticatedUser.IDENTIFIER_PREFIX)) {\n-                if (pwfi.getLocalData().containsKey(PendingWorkflowInvocation.AUTHORIZED)\n-                        && Boolean.parseBoolean(pwfi.getLocalData().get(PendingWorkflowInvocation.AUTHORIZED))) {\n-                    return getAuthenticatedUser(\n-                            pwfi.getUserId().substring(AuthenticatedUser.IDENTIFIER_PREFIX.length()));\n-                }\n-            }\n-        } catch (NoResultException ex) {\n-            return null;\n-        }\n+  }\n+\n+  public AuthenticatedUser lookupUserForWorkflowInvocationID(String wfId) {\n+    try {\n+      PendingWorkflowInvocation pwfi = em.find(PendingWorkflowInvocation.class, wfId);\n+      if (pwfi == null) {\n         return null;\n+      }\n+      if (pwfi.getUserId().startsWith(AuthenticatedUser.IDENTIFIER_PREFIX)) {\n+        if (pwfi.getLocalData().containsKey(PendingWorkflowInvocation.AUTHORIZED)\n+          && Boolean.parseBoolean(pwfi.getLocalData().get(PendingWorkflowInvocation.AUTHORIZED))) {\n+          return getAuthenticatedUser(\n+            pwfi.getUserId().substring(AuthenticatedUser.IDENTIFIER_PREFIX.length()));\n+        }\n+      }\n+    } catch (NoResultException ex) {\n+      return null;\n     }\n+    return null;\n+  }\n     \n     /*\n     getDeleteUserErrorMessages( AuthenticatedUser au )\n@@ -487,465 +502,498 @@ public class AuthenticationServiceBean {\n \n     An empty string is returned if the user is 'deletable'\n     */\n-    \n-    public String getDeleteUserErrorMessages(AuthenticatedUser au) {\n-        String retVal = \"\";\n-        List<String> reasons= new ArrayList();\n-        if (!dvObjSvc.findByAuthenticatedUserId(au).isEmpty()) {\n-            reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.dvobjects\"));\n-        }\n \n-        if (!roleAssigneeSvc.getAssignmentsFor(au.getIdentifier()).isEmpty()) {\n-            reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.roleAssignments\"));\n-        }\n+  public String getDeleteUserErrorMessages(AuthenticatedUser au) {\n+    String retVal = \"\";\n+    List<String> reasons = new ArrayList();\n+    if (!dvObjSvc.findByAuthenticatedUserId(au).isEmpty()) {\n+      reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.dvobjects\"));\n+    }\n \n-        if (!gbRespSvc.findByAuthenticatedUserId(au).isEmpty()) {\n-            reasons.add( BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.gbResps\"));\n-        }\n+    if (!roleAssigneeSvc.getAssignmentsFor(au.getIdentifier()).isEmpty()) {\n+      reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.roleAssignments\"));\n+    }\n \n-        if (!datasetVersionService.getDatasetVersionUsersByAuthenticatedUser(au).isEmpty()) {\n-            reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.versionUser\"));\n-        }\n+    if (!gbRespSvc.findByAuthenticatedUserId(au).isEmpty()) {\n+      reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.gbResps\"));\n+    }\n \n-        if (!savedSearchService.findByAuthenticatedUser(au).isEmpty()) {\n-            reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.savedSearches\"));\n-        }\n-        \n-        if (!reasons.isEmpty()) {\n-            retVal = BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.prefix\", Arrays.asList(au.getIdentifier()));\n-            retVal += \" \" + reasons.stream().collect(Collectors.joining(\"; \")) + \".\";\n-        }\n-        \n+    if (!datasetVersionService.getDatasetVersionUsersByAuthenticatedUser(au).isEmpty()) {\n+      reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.versionUser\"));\n+    }\n \n+    if (!savedSearchService.findByAuthenticatedUser(au).isEmpty()) {\n+      reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.savedSearches\"));\n+    }\n \n-        return retVal;\n+    if (!reasons.isEmpty()) {\n+      retVal = BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.prefix\", Arrays.asList(au.getIdentifier()));\n+      retVal += \" \" + reasons.stream().collect(Collectors.joining(\"; \")) + \".\";\n     }\n-    \n-    public void removeAuthentictedUserItems(AuthenticatedUser au){\n+\n+\n+    return retVal;\n+  }\n+\n+  public void removeAuthentictedUserItems(AuthenticatedUser au) {\n         /* if the user has pending access requests, is the member of a group or \n         we will delete them here \n         */\n \n-        deletePendingAccessRequests(au);\n-        \n-        deleteBannerMessages(au);\n-               \n-        if (!explicitGroupService.findGroups(au).isEmpty()) {\n-            for(ExplicitGroup explicitGroup: explicitGroupService.findGroups(au)){\n-                explicitGroup.removeByRoleAssgineeIdentifier(au.getIdentifier());\n-            }            \n-        }\n-        \n-    }\n-    \n-    private void deleteBannerMessages(AuthenticatedUser  au){\n-        \n-       em.createNativeQuery(\"delete from userbannermessage where user_id  = \"+au.getId()).executeUpdate();\n-        \n-    }\n-    \n-    private void deletePendingAccessRequests(AuthenticatedUser  au){\n-        \n-       em.createNativeQuery(\"delete from fileaccessrequests where authenticated_user_id  = \"+au.getId()).executeUpdate();\n-        \n-    }\n-    \n-    public AuthenticatedUser save( AuthenticatedUser user ) {\n-        em.persist(user);\n-        em.flush();\n-        return user;\n-    }\n-    \n-    public AuthenticatedUser update( AuthenticatedUser user ) {\n-        return em.merge(user);\n-    }\n-    \n-    public ApiToken save( ApiToken aToken ) {\n-        if ( aToken.getId() == null ) {\n-            em.persist(aToken);\n-            return aToken;\n-        } else { \n-            return em.merge( aToken );\n-            \n-        }\n-    }\n-    \n+    deletePendingAccessRequests(au);\n+\n+    deleteBannerMessages(au);\n+\n+    if (!explicitGroupService.findGroups(au).isEmpty()) {\n+      for (ExplicitGroup explicitGroup : explicitGroupService.findGroups(au)) {\n+        explicitGroup.removeByRoleAssgineeIdentifier(au.getIdentifier());\n+      }\n+    }\n+\n+  }\n+\n+  private void deleteBannerMessages(AuthenticatedUser au) {\n+\n+    em.createNativeQuery(\"delete from userbannermessage where user_id  = \" + au.getId()).executeUpdate();\n+\n+  }\n+\n+  private void deletePendingAccessRequests(AuthenticatedUser au) {\n+\n+    em.createNativeQuery(\"delete from fileaccessrequests where authenticated_user_id  = \" + au.getId()).executeUpdate();\n+\n+  }\n+\n+  public AuthenticatedUser save(AuthenticatedUser user) {\n+    em.persist(user);\n+    em.flush();\n+    return user;\n+  }\n+\n+  public AuthenticatedUser update(AuthenticatedUser user) {\n+    return em.merge(user);\n+  }\n+\n+  public ApiToken save(ApiToken aToken) {\n+    if (aToken.getId() == null) {\n+      em.persist(aToken);\n+      return aToken;\n+    } else {\n+      return em.merge(aToken);\n+\n+    }\n+  }\n+\n+  /**\n+   * Associates the passed {@link AuthenticatedUser} with a new provider.\n+   *\n+   * @param authenticatedUser        the authenticated being re-associated\n+   * @param authenticationProviderId Id of the new provider\n+   * @param persistentIdInProvider   Id of the user in the new provider\n+   * @return {@code true} iff the change was successful.\n+   */\n+  public boolean updateProvider(AuthenticatedUser authenticatedUser, String authenticationProviderId,\n+                                String persistentIdInProvider) {\n+    try {\n+      AuthenticatedUserLookup aul =\n+        em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthUser\", AuthenticatedUserLookup.class)\n+          .setParameter(\"authUser\", authenticatedUser)\n+          .getSingleResult();\n+      aul.setAuthenticationProviderId(authenticationProviderId);\n+      aul.setPersistentUserId(persistentIdInProvider);\n+      actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth,\n+        authenticatedUser.getIdentifier() + \" now associated with provider \" + authenticationProviderId + \" id: \" +\n+          persistentIdInProvider));\n+      return true;\n+\n+    } catch (NoResultException | NonUniqueResultException ex) {\n+      logger\n+        .log(Level.WARNING, \"Error converting user \" + authenticatedUser.getUserIdentifier() + \": \" + ex.getMessage(),\n+          ex);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Creates an authenticated user based on the passed\n+   * {@code userDisplayInfo}, a lookup entry for them based\n+   * UserIdentifier.getLookupStringPerAuthProvider (within the supplied\n+   * authentication provider), and internal user identifier (used for role\n+   * assignments, etc.) based on UserIdentifier.getInternalUserIdentifer.\n+   *\n+   * @param userRecordId\n+   * @param proposedAuthenticatedUserIdentifier\n+   * @param userDisplayInfo\n+   * @param generateUniqueIdentifier            if {@code true}, create a new, unique user identifier for the created user, if the suggested one exists.\n+   * @return the newly created user, or {@code null} if the proposed identifier exists and {@code generateUniqueIdentifier} was {@code false}.\n+   * @throws EJBException which may wrap an ConstraintViolationException if the proposed user does not pass bean validation.\n+   */\n+  public AuthenticatedUser createAuthenticatedUser(UserRecordIdentifier userRecordId,\n+                                                   String proposedAuthenticatedUserIdentifier,\n+                                                   AuthenticatedUserDisplayInfo userDisplayInfo,\n+                                                   boolean generateUniqueIdentifier) {\n+    AuthenticatedUser authenticatedUser = new AuthenticatedUser();\n+    // set account creation time & initial login time (same timestamp)\n+    authenticatedUser.setCreatedTime(new Timestamp(new Date().getTime()));\n+    authenticatedUser.setLastLoginTime(authenticatedUser.getCreatedTime());\n+\n+    authenticatedUser.applyDisplayInfo(userDisplayInfo);\n+\n+    // we have no desire for leading or trailing whitespace in identifiers\n+    if (proposedAuthenticatedUserIdentifier != null) {\n+      proposedAuthenticatedUserIdentifier = proposedAuthenticatedUserIdentifier.trim();\n+    }\n+    // we now select a username for the generated AuthenticatedUser, or give up\n+    String internalUserIdentifer = proposedAuthenticatedUserIdentifier;\n+    // TODO should lock table authenticated users for write here\n+    if (identifierExists(internalUserIdentifer)) {\n+      if (!generateUniqueIdentifier) {\n+        return null;\n+      }\n+      int i = 1;\n+      String identifier = internalUserIdentifer + i;\n+      while (identifierExists(identifier)) {\n+        i += 1;\n+      }\n+      authenticatedUser.setUserIdentifier(identifier);\n+    } else {\n+      authenticatedUser.setUserIdentifier(internalUserIdentifer);\n+    }\n+    authenticatedUser = save(authenticatedUser);\n+    // TODO should unlock table authenticated users for write here\n+    AuthenticatedUserLookup auusLookup = userRecordId.createAuthenticatedUserLookup(authenticatedUser);\n+    em.persist(auusLookup);\n+    authenticatedUser.setAuthenticatedUserLookup(auusLookup);\n+\n+    if (ShibAuthenticationProvider.PROVIDER_ID.equals(auusLookup.getAuthenticationProviderId())) {\n+      Timestamp emailConfirmedNow = new Timestamp(new Date().getTime());\n+      // Email addresses for Shib users are confirmed by the Identity Provider.\n+      authenticatedUser.setEmailConfirmed(emailConfirmedNow);\n+      authenticatedUser = save(authenticatedUser);\n+    } else {\n+      /* @todo Rather than creating a token directly here it might be\n+       * better to do something like \"startConfirmEmailProcessForNewUser\". */\n+      confirmEmailService.createToken(authenticatedUser);\n+    }\n+\n+    actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"createUser\")\n+      .setInfo(authenticatedUser.getIdentifier()));\n+\n+    return authenticatedUser;\n+  }\n+\n+  /**\n+   * Checks whether the {@code idtf} is already taken by another {@link AuthenticatedUser}.\n+   *\n+   * @param idtf\n+   * @return {@code true} iff there's already a user by that username.\n+   */\n+  public boolean identifierExists(String idtf) {\n+    return em.createNamedQuery(\"AuthenticatedUser.countOfIdentifier\", Number.class)\n+      .setParameter(\"identifier\", idtf)\n+      .getSingleResult().intValue() > 0;\n+  }\n+\n+  public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser user,\n+                                                   AuthenticatedUserDisplayInfo userDisplayInfo) {\n+    user.applyDisplayInfo(userDisplayInfo);\n+    actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"updateUser\")\n+      .setInfo(user.getIdentifier()));\n+    return update(user);\n+  }\n+\n+  public List<AuthenticatedUser> findAllAuthenticatedUsers() {\n+    return em.createNamedQuery(\"AuthenticatedUser.findAll\", AuthenticatedUser.class).getResultList();\n+  }\n+\n+  public List<AuthenticatedUser> findSuperUsers() {\n+    return em.createNamedQuery(\"AuthenticatedUser.findSuperUsers\", AuthenticatedUser.class).getResultList();\n+  }\n+\n+\n+  public Set<AuthenticationProviderFactory> listProviderFactories() {\n+    return new HashSet<>(authProvidersRegistrationService.getProviderFactoriesMap().values());\n+  }\n+\n+  public Timestamp getCurrentTimestamp() {\n+    return new Timestamp(new Date().getTime());\n+  }\n+\n+  // TODO should probably be moved to the Shib provider - this is a classic Shib-specific\n+  //      use case. This class should deal with general autnetications.\n+  @Deprecated\n+  /**\n+   * @deprecated. Switch to convertBuiltInUserToRemoteUser instead.\n+   * @todo. Switch to convertBuiltInUserToRemoteUser instead.\n+   */\n+  public AuthenticatedUser convertBuiltInToShib(AuthenticatedUser builtInUserToConvert, String shibProviderId,\n+                                                UserIdentifier newUserIdentifierInLookupTable) {\n+    logger.info(\"converting user \" + builtInUserToConvert.getId() + \" from builtin to shib\");\n+    String builtInUserIdentifier = builtInUserToConvert.getIdentifier();\n+    logger.info(\"builtin user identifier: \" + builtInUserIdentifier);\n+    TypedQuery<AuthenticatedUserLookup> typedQuery =\n+      em.createQuery(\"SELECT OBJECT(o) FROM AuthenticatedUserLookup AS o WHERE o.authenticatedUser = :auid\",\n+        AuthenticatedUserLookup.class);\n+    typedQuery.setParameter(\"auid\", builtInUserToConvert);\n+    AuthenticatedUserLookup authuserLookup;\n+    try {\n+      authuserLookup = typedQuery.getSingleResult();\n+    } catch (NoResultException | NonUniqueResultException ex) {\n+      logger.info(\"exception caught: \" + ex);\n+      return null;\n+    }\n+    if (authuserLookup == null) {\n+      return null;\n+    }\n+\n+    String oldProviderId = authuserLookup.getAuthenticationProviderId();\n+    logger.info(\"we expect this to be 'builtin': \" + oldProviderId);\n+    authuserLookup.setAuthenticationProviderId(shibProviderId);\n+    String oldUserLookupIdentifier = authuserLookup.getPersistentUserId();\n+    logger.info(\"this should be 'pete' or whatever the old builtin username was: \" + oldUserLookupIdentifier);\n+    String perUserShibIdentifier = newUserIdentifierInLookupTable.getLookupStringPerAuthProvider();\n+    authuserLookup.setPersistentUserId(perUserShibIdentifier);\n     /**\n-     * Associates the passed {@link AuthenticatedUser} with a new provider.\n-     * @param authenticatedUser the authenticated being re-associated\n-     * @param authenticationProviderId Id of the new provider\n-     * @param persistentIdInProvider Id of the user in the new provider\n-     * @return {@code true} iff the change was successful.\n+     * @todo this should be a transaction of some kind. We want to update\n+     * the authenticateduserlookup and also delete the row from the\n+     * builtinuser table in a single transaction.\n      */\n-    public boolean updateProvider( AuthenticatedUser authenticatedUser, String authenticationProviderId, String persistentIdInProvider ) {\n-        try {\n-            AuthenticatedUserLookup aul = em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthUser\", AuthenticatedUserLookup.class)\n-                    .setParameter(\"authUser\", authenticatedUser)\n-                    .getSingleResult();\n-            aul.setAuthenticationProviderId(authenticationProviderId);\n-            aul.setPersistentUserId(persistentIdInProvider);\n-            actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth,\n-                    authenticatedUser.getIdentifier() + \" now associated with provider \" + authenticationProviderId + \" id: \" + persistentIdInProvider) );\n-            return true;\n-            \n-        } catch ( NoResultException | NonUniqueResultException ex ) {\n-            logger.log(Level.WARNING, \"Error converting user \" + authenticatedUser.getUserIdentifier() + \": \" + ex.getMessage(), ex);\n-            return false;\n-        }\n-    }\n-\n+    em.persist(authuserLookup);\n+    String builtinUsername = builtInUserIdentifier.replaceFirst(AuthenticatedUser.IDENTIFIER_PREFIX, \"\");\n+    BuiltinUser builtin = builtinUserServiceBean.findByUserName(builtinUsername);\n+    if (builtin != null) {\n+      // These were created by AuthenticationResponse.Status.BREAKOUT in canLogInAsBuiltinUser\n+      List<PasswordResetData> oldTokens = passwordResetServiceBean.findPasswordResetDataByDataverseUser(builtin);\n+      for (PasswordResetData oldToken : oldTokens) {\n+        em.remove(oldToken);\n+      }\n+      em.remove(builtin);\n+    } else {\n+      logger.info(\"Couldn't delete builtin user because could find it based on username \" + builtinUsername);\n+    }\n+    AuthenticatedUser shibUser = lookupUser(shibProviderId, perUserShibIdentifier);\n+    if (shibUser != null) {\n+      return shibUser;\n+    }\n+    return null;\n+  }\n+\n+  public AuthenticatedUser convertBuiltInUserToRemoteUser(AuthenticatedUser builtInUserToConvert, String newProviderId,\n+                                                          UserIdentifier newUserIdentifierInLookupTable) {\n+    logger.info(\"converting user \" + builtInUserToConvert.getId() + \" from builtin to remote\");\n+    String builtInUserIdentifier = builtInUserToConvert.getIdentifier();\n+    logger.info(\"builtin user identifier: \" + builtInUserIdentifier);\n+    TypedQuery<AuthenticatedUserLookup> typedQuery =\n+      em.createQuery(\"SELECT OBJECT(o) FROM AuthenticatedUserLookup AS o WHERE o.authenticatedUser = :auid\",\n+        AuthenticatedUserLookup.class);\n+    typedQuery.setParameter(\"auid\", builtInUserToConvert);\n+    AuthenticatedUserLookup authuserLookup;\n+    try {\n+      authuserLookup = typedQuery.getSingleResult();\n+    } catch (NoResultException | NonUniqueResultException ex) {\n+      logger.info(\"exception caught: \" + ex);\n+      return null;\n+    }\n+    if (authuserLookup == null) {\n+      return null;\n+    }\n+\n+    String oldProviderId = authuserLookup.getAuthenticationProviderId();\n+    logger.info(\"we expect this to be 'builtin': \" + oldProviderId);\n+    authuserLookup.setAuthenticationProviderId(newProviderId);\n+    String oldUserLookupIdentifier = authuserLookup.getPersistentUserId();\n+    logger.info(\"this should be 'pete' or whatever the old builtin username was: \" + oldUserLookupIdentifier);\n+    String perUserIdentifier = newUserIdentifierInLookupTable.getLookupStringPerAuthProvider();\n+    authuserLookup.setPersistentUserId(perUserIdentifier);\n     /**\n-     * Creates an authenticated user based on the passed\n-     * {@code userDisplayInfo}, a lookup entry for them based\n-     * UserIdentifier.getLookupStringPerAuthProvider (within the supplied\n-     * authentication provider), and internal user identifier (used for role\n-     * assignments, etc.) based on UserIdentifier.getInternalUserIdentifer.\n-     *\n-     * @param userRecordId\n-     * @param proposedAuthenticatedUserIdentifier\n-     * @param userDisplayInfo\n-     * @param generateUniqueIdentifier if {@code true}, create a new, unique user identifier for the created user, if the suggested one exists.\n-     * @return the newly created user, or {@code null} if the proposed identifier exists and {@code generateUniqueIdentifier} was {@code false}.\n-     * @throws EJBException which may wrap an ConstraintViolationException if the proposed user does not pass bean validation.\n+     * @todo this should be a transaction of some kind. We want to update\n+     * the authenticateduserlookup and also delete the row from the\n+     * builtinuser table in a single transaction.\n      */\n-    public AuthenticatedUser createAuthenticatedUser(UserRecordIdentifier userRecordId,\n-            String proposedAuthenticatedUserIdentifier,\n-            AuthenticatedUserDisplayInfo userDisplayInfo,\n-            boolean generateUniqueIdentifier) {\n-        AuthenticatedUser authenticatedUser = new AuthenticatedUser();\n-        // set account creation time & initial login time (same timestamp)\n-        authenticatedUser.setCreatedTime(new Timestamp(new Date().getTime()));\n-        authenticatedUser.setLastLoginTime(authenticatedUser.getCreatedTime());\n-        \n-        authenticatedUser.applyDisplayInfo(userDisplayInfo);\n-\n-        // we have no desire for leading or trailing whitespace in identifiers\n-        if (proposedAuthenticatedUserIdentifier != null) {\n-            proposedAuthenticatedUserIdentifier = proposedAuthenticatedUserIdentifier.trim();\n-        }\n-        // we now select a username for the generated AuthenticatedUser, or give up\n-        String internalUserIdentifer = proposedAuthenticatedUserIdentifier;\n-        // TODO should lock table authenticated users for write here\n-        if ( identifierExists(internalUserIdentifer) ) {\n-            if ( ! generateUniqueIdentifier ) {\n-                return null;\n-            }\n-            int i=1;\n-            String identifier = internalUserIdentifer + i;\n-            while ( identifierExists(identifier) ) {\n-                i += 1;\n-            }\n-            authenticatedUser.setUserIdentifier(identifier);\n-        } else {\n-            authenticatedUser.setUserIdentifier(internalUserIdentifer);\n-        }\n-        authenticatedUser = save( authenticatedUser );\n-        // TODO should unlock table authenticated users for write here\n-        AuthenticatedUserLookup auusLookup = userRecordId.createAuthenticatedUserLookup(authenticatedUser);\n-        em.persist( auusLookup );\n-        authenticatedUser.setAuthenticatedUserLookup(auusLookup);\n-\n-        if (ShibAuthenticationProvider.PROVIDER_ID.equals(auusLookup.getAuthenticationProviderId())) {\n-            Timestamp emailConfirmedNow = new Timestamp(new Date().getTime());\n-            // Email addresses for Shib users are confirmed by the Identity Provider.\n-            authenticatedUser.setEmailConfirmed(emailConfirmedNow);\n-            authenticatedUser = save(authenticatedUser);\n-        } else {\n-            /* @todo Rather than creating a token directly here it might be\n-             * better to do something like \"startConfirmEmailProcessForNewUser\". */\n-            confirmEmailService.createToken(authenticatedUser);\n-        }\n-        \n-        actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"createUser\")\n-            .setInfo(authenticatedUser.getIdentifier()));\n-\n-        return authenticatedUser;\n-    }\n-    \n+    em.persist(authuserLookup);\n+    String builtinUsername = builtInUserIdentifier.replaceFirst(AuthenticatedUser.IDENTIFIER_PREFIX, \"\");\n+    BuiltinUser builtin = builtinUserServiceBean.findByUserName(builtinUsername);\n+    if (builtin != null) {\n+      // These were created by AuthenticationResponse.Status.BREAKOUT in canLogInAsBuiltinUser\n+      List<PasswordResetData> oldTokens = passwordResetServiceBean.findPasswordResetDataByDataverseUser(builtin);\n+      for (PasswordResetData oldToken : oldTokens) {\n+        em.remove(oldToken);\n+      }\n+      em.remove(builtin);\n+    } else {\n+      logger.info(\"Couldn't delete builtin user because could find it based on username \" + builtinUsername);\n+    }\n+    AuthenticatedUser nonBuiltinUser = lookupUser(newProviderId, perUserIdentifier);\n+    if (nonBuiltinUser != null) {\n+      return nonBuiltinUser;\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * @param idOfAuthUserToConvert The id of the remote AuthenticatedUser\n+   *                              (Shibboleth user or OAuth user) to convert to a BuiltinUser.\n+   * @param newEmailAddress       The new email address that will be used instead of\n+   *                              the user's old email address from the institution that they have left.\n+   * @return BuiltinUser\n+   * @throws java.lang.Exception You must catch and report back to the user (a\n+   *                             superuser) any Exceptions.\n+   */\n+  public BuiltinUser convertRemoteToBuiltIn(Long idOfAuthUserToConvert, String newEmailAddress) throws Exception {\n+    AuthenticatedUser authenticatedUser = findByID(idOfAuthUserToConvert);\n+    if (authenticatedUser == null) {\n+      throw new Exception(\"User id \" + idOfAuthUserToConvert + \" not found.\");\n+    }\n+    AuthenticatedUser existingUserWithSameEmail = getAuthenticatedUserByEmail(newEmailAddress);\n+    if (existingUserWithSameEmail != null) {\n+      throw new Exception(\"User id \" + idOfAuthUserToConvert + \" (\" + authenticatedUser.getIdentifier() +\n+        \") cannot be converted from remote to BuiltIn because the email address \" + newEmailAddress +\n+        \" is already in use by user id \" + existingUserWithSameEmail.getId() + \" (\" +\n+        existingUserWithSameEmail.getIdentifier() + \").\");\n+    }\n+    BuiltinUser builtinUser = new BuiltinUser();\n+    builtinUser.setUserName(authenticatedUser.getUserIdentifier());\n+    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n+    Validator validator = factory.getValidator();\n+    Set<ConstraintViolation<BuiltinUser>> violations = validator.validate(builtinUser);\n+    int numViolations = violations.size();\n+    if (numViolations > 0) {\n+      StringBuilder logMsg = new StringBuilder();\n+      for (ConstraintViolation<?> violation : violations) {\n+        logMsg.append(\" Invalid value: <<<\").append(violation.getInvalidValue()).append(\">>> for \")\n+          .append(violation.getPropertyPath()).append(\" at \").append(violation.getLeafBean()).append(\" - \")\n+          .append(violation.getMessage());\n+      }\n+      throw new Exception(\"User id \" + idOfAuthUserToConvert +\n+        \" cannot be converted from remote to BuiltIn because of constraint violations on the BuiltIn user that would be created: \" +\n+        numViolations + \". Details: \" + logMsg);\n+    }\n+    try {\n+      builtinUser = builtinUserServiceBean.save(builtinUser);\n+    } catch (IllegalArgumentException ex) {\n+      throw new Exception(\"User id \" + idOfAuthUserToConvert +\n+        \" cannot be converted from remote to BuiltIn because of an IllegalArgumentException creating the row in the builtinuser table: \" +\n+        ex);\n+    }\n+    AuthenticatedUserLookup lookup = authenticatedUser.getAuthenticatedUserLookup();\n+    if (lookup == null) {\n+      throw new Exception(\"User id \" + idOfAuthUserToConvert + \" does not have an 'authenticateduserlookup' row\");\n+    }\n+    String providerId = lookup.getAuthenticationProviderId();\n+    if (providerId == null) {\n+      throw new Exception(\"User id \" + idOfAuthUserToConvert + \" provider id is null.\");\n+    }\n+    String builtinProviderId = BuiltinAuthenticationProvider.PROVIDER_ID;\n+    if (providerId.equals(builtinProviderId)) {\n+      throw new Exception(\"User id \" + idOfAuthUserToConvert +\n+        \" cannot be converted from remote to BuiltIn because current provider id is '\" + providerId +\n+        \"' which is the same as '\" + builtinProviderId + \"'. This user is already a BuiltIn user.\");\n+    }\n+    lookup.setAuthenticationProviderId(BuiltinAuthenticationProvider.PROVIDER_ID);\n+    lookup.setPersistentUserId(authenticatedUser.getUserIdentifier());\n+    em.persist(lookup);\n+    authenticatedUser.setEmail(newEmailAddress);\n+    em.persist(authenticatedUser);\n+    em.flush();\n+    return builtinUser;\n+  }\n+\n+  public AuthenticatedUser canLogInAsBuiltinUser(String username, String password) {\n+    logger.fine(\"checking to see if \" + username + \" knows the password...\");\n+    if (password == null) {\n+      logger.info(\"password was null\");\n+      return null;\n+    }\n+\n+    AuthenticationRequest authReq = new AuthenticationRequest();\n     /**\n-     * Checks whether the {@code idtf} is already taken by another {@link AuthenticatedUser}.\n-     * @param idtf\n-     * @return {@code true} iff there's already a user by that username.\n+     * @todo Should the credential key really be a Bundle key?\n+     * BuiltinAuthenticationProvider.KEY_USERNAME_OR_EMAIL, for example, is\n+     * \"login.builtin.credential.usernameOrEmail\" as of this writing.\n      */\n-    public boolean identifierExists( String idtf ) {\n-        return em.createNamedQuery(\"AuthenticatedUser.countOfIdentifier\", Number.class)\n-                .setParameter(\"identifier\", idtf)\n-                .getSingleResult().intValue() > 0;\n-    }\n-    \n-    public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser user, AuthenticatedUserDisplayInfo userDisplayInfo) {\n-        user.applyDisplayInfo(userDisplayInfo);\n-        actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"updateUser\")\n-            .setInfo(user.getIdentifier()));\n-        return update(user);\n-    }\n-    \n-    public List<AuthenticatedUser> findAllAuthenticatedUsers() {\n-        return em.createNamedQuery(\"AuthenticatedUser.findAll\", AuthenticatedUser.class).getResultList();\n-    }\n-\n-    public List<AuthenticatedUser> findSuperUsers() {\n-        return em.createNamedQuery(\"AuthenticatedUser.findSuperUsers\", AuthenticatedUser.class).getResultList();\n-    }\n-    \n-    \n-    public Set<AuthenticationProviderFactory> listProviderFactories() {\n-        return new HashSet<>( authProvidersRegistrationService.getProviderFactoriesMap().values() ); \n-    }\n-    \n-    public Timestamp getCurrentTimestamp() {\n-        return new Timestamp(new Date().getTime());\n-    }\n-\n-    // TODO should probably be moved to the Shib provider - this is a classic Shib-specific\n-    //      use case. This class should deal with general autnetications.\n-    @Deprecated\n+    authReq.putCredential(BuiltinAuthenticationProvider.KEY_USERNAME_OR_EMAIL, username);\n+    authReq.putCredential(BuiltinAuthenticationProvider.KEY_PASSWORD, password);\n     /**\n-     * @deprecated. Switch to convertBuiltInUserToRemoteUser instead.\n-     * @todo. Switch to convertBuiltInUserToRemoteUser instead.\n+     * @todo Should probably set IP address here.\n      */\n-    public AuthenticatedUser convertBuiltInToShib(AuthenticatedUser builtInUserToConvert, String shibProviderId, UserIdentifier newUserIdentifierInLookupTable) {\n-        logger.info(\"converting user \" + builtInUserToConvert.getId() + \" from builtin to shib\");\n-        String builtInUserIdentifier = builtInUserToConvert.getIdentifier();\n-        logger.info(\"builtin user identifier: \" + builtInUserIdentifier);\n-        TypedQuery<AuthenticatedUserLookup> typedQuery = em.createQuery(\"SELECT OBJECT(o) FROM AuthenticatedUserLookup AS o WHERE o.authenticatedUser = :auid\", AuthenticatedUserLookup.class);\n-        typedQuery.setParameter(\"auid\", builtInUserToConvert);\n-        AuthenticatedUserLookup authuserLookup;\n-        try {\n-            authuserLookup = typedQuery.getSingleResult();\n-        } catch (NoResultException | NonUniqueResultException ex) {\n-            logger.info(\"exception caught: \" + ex);\n-            return null;\n-        }\n-        if (authuserLookup == null) {\n-            return null;\n-        }\n+//        authReq.setIpAddress(session.getUser().getRequestMetadata().getIpAddress());\n \n-        String oldProviderId = authuserLookup.getAuthenticationProviderId();\n-        logger.info(\"we expect this to be 'builtin': \" + oldProviderId);\n-        authuserLookup.setAuthenticationProviderId(shibProviderId);\n-        String oldUserLookupIdentifier = authuserLookup.getPersistentUserId();\n-        logger.info(\"this should be 'pete' or whatever the old builtin username was: \" + oldUserLookupIdentifier);\n-        String perUserShibIdentifier = newUserIdentifierInLookupTable.getLookupStringPerAuthProvider();\n-        authuserLookup.setPersistentUserId(perUserShibIdentifier);\n+    String credentialsAuthProviderId = BuiltinAuthenticationProvider.PROVIDER_ID;\n+    try {\n+      AuthenticatedUser au = getUpdateAuthenticatedUser(credentialsAuthProviderId, authReq);\n+      logger.fine(\"User authenticated:\" + au.getEmail());\n+      return au;\n+    } catch (AuthenticationFailedException ex) {\n+      logger.info(\"The username and/or password entered is invalid: \" + ex.getResponse().getMessage());\n+      if (AuthenticationResponse.Status.BREAKOUT.equals(ex.getResponse().getStatus())) {\n         /**\n-         * @todo this should be a transaction of some kind. We want to update\n-         * the authenticateduserlookup and also delete the row from the\n-         * builtinuser table in a single transaction.\n+         * Note that this \"BREAKOUT\" status creates PasswordResetData!\n+         * We'll delete it just before blowing away the BuiltinUser in\n+         * AuthenticationServiceBean.convertBuiltInToShib\n          */\n-        em.persist(authuserLookup);\n-        String builtinUsername = builtInUserIdentifier.replaceFirst(AuthenticatedUser.IDENTIFIER_PREFIX, \"\");\n-        BuiltinUser builtin = builtinUserServiceBean.findByUserName(builtinUsername);\n-        if (builtin != null) {\n-            // These were created by AuthenticationResponse.Status.BREAKOUT in canLogInAsBuiltinUser\n-            List<PasswordResetData> oldTokens = passwordResetServiceBean.findPasswordResetDataByDataverseUser(builtin);\n-            for (PasswordResetData oldToken : oldTokens) {\n-                em.remove(oldToken);\n+        logger.info(\n+          \"AuthenticationFailedException caught in canLogInAsBuiltinUser: The username and/or password entered is invalid: \" +\n+            ex.getResponse().getMessage() + \" - Maybe the user (\" + username +\n+            \") hasn't upgraded their password? Checking the old password...\");\n+        BuiltinUser builtinUser = builtinUserServiceBean.findByUserName(username);\n+        if (builtinUser != null) {\n+          boolean userAuthenticated = PasswordEncryption.getVersion(builtinUser.getPasswordEncryptionVersion())\n+            .check(password, builtinUser.getEncryptedPassword());\n+          if (userAuthenticated == true) {\n+            AuthenticatedUser authUser =\n+              lookupUser(BuiltinAuthenticationProvider.PROVIDER_ID, builtinUser.getUserName());\n+            if (authUser != null) {\n+              return authUser;\n+            } else {\n+              logger.info(\"canLogInAsBuiltinUser: Couldn't find AuthenticatedUser based on BuiltinUser username \" +\n+                builtinUser.getUserName());\n             }\n-            em.remove(builtin);\n+          } else {\n+            logger.info(\"canLogInAsBuiltinUser: User doesn't know old pre-bcrypt password either.\");\n+          }\n         } else {\n-            logger.info(\"Couldn't delete builtin user because could find it based on username \" + builtinUsername);\n-        }\n-        AuthenticatedUser shibUser = lookupUser(shibProviderId, perUserShibIdentifier);\n-        if (shibUser != null) {\n-            return shibUser;\n-        }\n-        return null;\n-    }\n-\n-    public AuthenticatedUser convertBuiltInUserToRemoteUser(AuthenticatedUser builtInUserToConvert, String newProviderId, UserIdentifier newUserIdentifierInLookupTable) {\n-        logger.info(\"converting user \" + builtInUserToConvert.getId() + \" from builtin to remote\");\n-        String builtInUserIdentifier = builtInUserToConvert.getIdentifier();\n-        logger.info(\"builtin user identifier: \" + builtInUserIdentifier);\n-        TypedQuery<AuthenticatedUserLookup> typedQuery = em.createQuery(\"SELECT OBJECT(o) FROM AuthenticatedUserLookup AS o WHERE o.authenticatedUser = :auid\", AuthenticatedUserLookup.class);\n-        typedQuery.setParameter(\"auid\", builtInUserToConvert);\n-        AuthenticatedUserLookup authuserLookup;\n-        try {\n-            authuserLookup = typedQuery.getSingleResult();\n-        } catch (NoResultException | NonUniqueResultException ex) {\n-            logger.info(\"exception caught: \" + ex);\n-            return null;\n-        }\n-        if (authuserLookup == null) {\n-            return null;\n-        }\n-\n-        String oldProviderId = authuserLookup.getAuthenticationProviderId();\n-        logger.info(\"we expect this to be 'builtin': \" + oldProviderId);\n-        authuserLookup.setAuthenticationProviderId(newProviderId);\n-        String oldUserLookupIdentifier = authuserLookup.getPersistentUserId();\n-        logger.info(\"this should be 'pete' or whatever the old builtin username was: \" + oldUserLookupIdentifier);\n-        String perUserIdentifier = newUserIdentifierInLookupTable.getLookupStringPerAuthProvider();\n-        authuserLookup.setPersistentUserId(perUserIdentifier);\n+          logger\n+            .info(\"canLogInAsBuiltinUser: Couldn't run `check` because no BuiltinUser found with username \" + username);\n+        }\n+      }\n+      return null;\n+    } catch (EJBException ex) {\n+      Throwable cause = ex;\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(ex + \" \");\n+      while (cause.getCause() != null) {\n+        cause = cause.getCause();\n+        sb.append(cause.getClass().getCanonicalName() + \" \");\n+        sb.append(cause.getMessage()).append(\" \");\n         /**\n-         * @todo this should be a transaction of some kind. We want to update\n-         * the authenticateduserlookup and also delete the row from the\n-         * builtinuser table in a single transaction.\n+         * @todo Investigate why authSvc.authenticate is throwing\n+         * NullPointerException. If you convert a Shib user or an OAuth\n+         * user to a Builtin user, the password will be null.\n          */\n-        em.persist(authuserLookup);\n-        String builtinUsername = builtInUserIdentifier.replaceFirst(AuthenticatedUser.IDENTIFIER_PREFIX, \"\");\n-        BuiltinUser builtin = builtinUserServiceBean.findByUserName(builtinUsername);\n-        if (builtin != null) {\n-            // These were created by AuthenticationResponse.Status.BREAKOUT in canLogInAsBuiltinUser\n-            List<PasswordResetData> oldTokens = passwordResetServiceBean.findPasswordResetDataByDataverseUser(builtin);\n-            for (PasswordResetData oldToken : oldTokens) {\n-                em.remove(oldToken);\n+        if (cause instanceof NullPointerException) {\n+          for (int i = 0; i < 2; i++) {\n+            StackTraceElement stacktrace = cause.getStackTrace()[i];\n+            if (stacktrace != null) {\n+              String classCanonicalName = stacktrace.getClass().getCanonicalName();\n+              String methodName = stacktrace.getMethodName();\n+              int lineNumber = stacktrace.getLineNumber();\n+              String error =\n+                \"at \" + stacktrace.getClassName() + \".\" + stacktrace.getMethodName() + \"(\" + stacktrace.getFileName() +\n+                  \":\" + lineNumber + \") \";\n+              sb.append(error);\n             }\n-            em.remove(builtin);\n-        } else {\n-            logger.info(\"Couldn't delete builtin user because could find it based on username \" + builtinUsername);\n-        }\n-        AuthenticatedUser nonBuiltinUser = lookupUser(newProviderId, perUserIdentifier);\n-        if (nonBuiltinUser != null) {\n-            return nonBuiltinUser;\n+          }\n         }\n-        return null;\n+      }\n+      logger.info(\"When trying to validate password, exception calling authSvc.authenticate: \" + sb.toString());\n+      return null;\n     }\n+  }\n \n-    /**\n-     * @param idOfAuthUserToConvert The id of the remote AuthenticatedUser\n-     * (Shibboleth user or OAuth user) to convert to a BuiltinUser.\n-     * @param newEmailAddress The new email address that will be used instead of\n-     * the user's old email address from the institution that they have left.\n-     * @return BuiltinUser\n-     * @throws java.lang.Exception You must catch and report back to the user (a\n-     * superuser) any Exceptions.\n-     */\n-    public BuiltinUser convertRemoteToBuiltIn(Long idOfAuthUserToConvert, String newEmailAddress) throws Exception {\n-        AuthenticatedUser authenticatedUser = findByID(idOfAuthUserToConvert);\n-        if (authenticatedUser == null) {\n-            throw new Exception(\"User id \" + idOfAuthUserToConvert + \" not found.\");\n-        }\n-        AuthenticatedUser existingUserWithSameEmail = getAuthenticatedUserByEmail(newEmailAddress);\n-        if (existingUserWithSameEmail != null) {\n-            throw new Exception(\"User id \" + idOfAuthUserToConvert + \" (\" + authenticatedUser.getIdentifier() + \") cannot be converted from remote to BuiltIn because the email address \" + newEmailAddress + \" is already in use by user id \" + existingUserWithSameEmail.getId() + \" (\" + existingUserWithSameEmail.getIdentifier() + \").\");\n-        }\n-        BuiltinUser builtinUser = new BuiltinUser();\n-        builtinUser.setUserName(authenticatedUser.getUserIdentifier());\n-        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n-        Validator validator = factory.getValidator();\n-        Set<ConstraintViolation<BuiltinUser>> violations = validator.validate(builtinUser);\n-        int numViolations = violations.size();\n-        if (numViolations > 0) {\n-            StringBuilder logMsg = new StringBuilder();\n-            for (ConstraintViolation<?> violation : violations) {\n-                logMsg.append(\" Invalid value: <<<\").append(violation.getInvalidValue()).append(\">>> for \").append(violation.getPropertyPath()).append(\" at \").append(violation.getLeafBean()).append(\" - \").append(violation.getMessage());\n-            }\n-            throw new Exception(\"User id \" + idOfAuthUserToConvert + \" cannot be converted from remote to BuiltIn because of constraint violations on the BuiltIn user that would be created: \" + numViolations + \". Details: \" + logMsg);\n-        }\n-        try {\n-            builtinUser = builtinUserServiceBean.save(builtinUser);\n-        } catch (IllegalArgumentException ex) {\n-            throw new Exception(\"User id \" + idOfAuthUserToConvert + \" cannot be converted from remote to BuiltIn because of an IllegalArgumentException creating the row in the builtinuser table: \" + ex);\n-        }\n-        AuthenticatedUserLookup lookup = authenticatedUser.getAuthenticatedUserLookup();\n-        if (lookup == null) {\n-            throw new Exception(\"User id \" + idOfAuthUserToConvert + \" does not have an 'authenticateduserlookup' row\");\n-        }\n-        String providerId = lookup.getAuthenticationProviderId();\n-        if (providerId == null) {\n-            throw new Exception(\"User id \" + idOfAuthUserToConvert + \" provider id is null.\");\n-        }\n-        String builtinProviderId = BuiltinAuthenticationProvider.PROVIDER_ID;\n-        if (providerId.equals(builtinProviderId)) {\n-            throw new Exception(\"User id \" + idOfAuthUserToConvert + \" cannot be converted from remote to BuiltIn because current provider id is '\" + providerId + \"' which is the same as '\" + builtinProviderId + \"'. This user is already a BuiltIn user.\");\n-        }\n-        lookup.setAuthenticationProviderId(BuiltinAuthenticationProvider.PROVIDER_ID);\n-        lookup.setPersistentUserId(authenticatedUser.getUserIdentifier());\n-        em.persist(lookup);\n-        authenticatedUser.setEmail(newEmailAddress);\n-        em.persist(authenticatedUser);\n-        em.flush();\n-        return builtinUser;\n-    }\n-\n-    public AuthenticatedUser canLogInAsBuiltinUser(String username, String password) {\n-        logger.fine(\"checking to see if \" + username + \" knows the password...\");\n-        if (password == null) {\n-            logger.info(\"password was null\");\n-            return null;\n-        }\n-\n-        AuthenticationRequest authReq = new AuthenticationRequest();\n-        /**\n-         * @todo Should the credential key really be a Bundle key?\n-         * BuiltinAuthenticationProvider.KEY_USERNAME_OR_EMAIL, for example, is\n-         * \"login.builtin.credential.usernameOrEmail\" as of this writing.\n-         */\n-        authReq.putCredential(BuiltinAuthenticationProvider.KEY_USERNAME_OR_EMAIL, username);\n-        authReq.putCredential(BuiltinAuthenticationProvider.KEY_PASSWORD, password);\n-        /**\n-         * @todo Should probably set IP address here.\n-         */\n-//        authReq.setIpAddress(session.getUser().getRequestMetadata().getIpAddress());\n-\n-        String credentialsAuthProviderId = BuiltinAuthenticationProvider.PROVIDER_ID;\n-        try {\n-            AuthenticatedUser au = getUpdateAuthenticatedUser(credentialsAuthProviderId, authReq);\n-            logger.fine(\"User authenticated:\" + au.getEmail());\n-            return au;\n-        } catch (AuthenticationFailedException ex) {\n-            logger.info(\"The username and/or password entered is invalid: \" + ex.getResponse().getMessage());\n-            if (AuthenticationResponse.Status.BREAKOUT.equals(ex.getResponse().getStatus())) {\n-                /**\n-                 * Note that this \"BREAKOUT\" status creates PasswordResetData!\n-                 * We'll delete it just before blowing away the BuiltinUser in\n-                 * AuthenticationServiceBean.convertBuiltInToShib\n-                 */\n-                logger.info(\"AuthenticationFailedException caught in canLogInAsBuiltinUser: The username and/or password entered is invalid: \" + ex.getResponse().getMessage() + \" - Maybe the user (\" + username + \") hasn't upgraded their password? Checking the old password...\");\n-                BuiltinUser builtinUser = builtinUserServiceBean.findByUserName(username);\n-                if (builtinUser != null) {\n-                    boolean userAuthenticated = PasswordEncryption.getVersion(builtinUser.getPasswordEncryptionVersion()).check(password, builtinUser.getEncryptedPassword());\n-                    if (userAuthenticated == true) {\n-                        AuthenticatedUser authUser = lookupUser(BuiltinAuthenticationProvider.PROVIDER_ID, builtinUser.getUserName());\n-                        if (authUser != null) {\n-                            return authUser;\n-                        } else {\n-                            logger.info(\"canLogInAsBuiltinUser: Couldn't find AuthenticatedUser based on BuiltinUser username \" + builtinUser.getUserName());\n-                        }\n-                    } else {\n-                        logger.info(\"canLogInAsBuiltinUser: User doesn't know old pre-bcrypt password either.\");\n-                    }\n-                } else {\n-                    logger.info(\"canLogInAsBuiltinUser: Couldn't run `check` because no BuiltinUser found with username \" + username);\n-                }\n-            }\n-            return null;\n-        } catch (EJBException ex) {\n-            Throwable cause = ex;\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(ex + \" \");\n-            while (cause.getCause() != null) {\n-                cause = cause.getCause();\n-                sb.append(cause.getClass().getCanonicalName() + \" \");\n-                sb.append(cause.getMessage()).append(\" \");\n-                /**\n-                 * @todo Investigate why authSvc.authenticate is throwing\n-                 * NullPointerException. If you convert a Shib user or an OAuth\n-                 * user to a Builtin user, the password will be null.\n-                 */\n-                if (cause instanceof NullPointerException) {\n-                    for (int i = 0; i < 2; i++) {\n-                        StackTraceElement stacktrace = cause.getStackTrace()[i];\n-                        if (stacktrace != null) {\n-                            String classCanonicalName = stacktrace.getClass().getCanonicalName();\n-                            String methodName = stacktrace.getMethodName();\n-                            int lineNumber = stacktrace.getLineNumber();\n-                            String error = \"at \" + stacktrace.getClassName() + \".\" + stacktrace.getMethodName() + \"(\" + stacktrace.getFileName() + \":\" + lineNumber + \") \";\n-                            sb.append(error);\n-                        }\n-                    }\n-                }\n-            }\n-            logger.info(\"When trying to validate password, exception calling authSvc.authenticate: \" + sb.toString());\n-            return null;\n-        }\n-    }\n-    \n-    public List <WorkflowComment> getWorkflowCommentsByAuthenticatedUser(AuthenticatedUser user){ \n-        Query query = em.createQuery(\"SELECT wc FROM WorkflowComment wc WHERE wc.authenticatedUser.id = :auid\");\n-        query.setParameter(\"auid\", user.getId());       \n-        return query.getResultList();\n-    }\n+  public List<WorkflowComment> getWorkflowCommentsByAuthenticatedUser(AuthenticatedUser user) {\n+    Query query = em.createQuery(\"SELECT wc FROM WorkflowComment wc WHERE wc.authenticatedUser.id = :auid\");\n+    query.setParameter(\"auid\", user.getId());\n+    return query.getResultList();\n+  }\n \n }\n",
            "diff_size": 1323
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/59/AuthenticationServiceBean.java\nindex 349a86301a6..c1a994b6bee 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/59/AuthenticationServiceBean.java\n@@ -77,29 +77,32 @@ import javax.validation.ValidatorFactory;\n  * related code has been moved there. \n  * \n  */\n+\n+\n @Named\n @Stateless\n public class AuthenticationServiceBean {\n+\n     private static final Logger logger = Logger.getLogger(AuthenticationServiceBean.class.getName());\n-    \n+\n     @EJB\n     AuthenticationProvidersRegistrationServiceBean authProvidersRegistrationService;\n-    \n+\n     @EJB\n     BuiltinUserServiceBean builtinUserServiceBean;\n-    \n+\n     @EJB\n     IndexServiceBean indexService;\n-    \n+\n     @EJB\n     protected ActionLogServiceBean actionLogSvc;\n-    \n+\n     @EJB\n     UserNotificationServiceBean userNotificationService;\n \n     @EJB\n     ConfirmEmailServiceBean confirmEmailService;\n-    \n+\n     @EJB\n     PasswordResetServiceBean passwordResetServiceBean;\n \n@@ -108,20 +111,20 @@ public class AuthenticationServiceBean {\n \n     @EJB\n     PasswordValidatorServiceBean passwordValidatorService;\n-    \n+\n     @EJB\n     DvObjectServiceBean dvObjSvc;\n-    \n+\n     @EJB\n     RoleAssigneeServiceBean roleAssigneeSvc;\n-    \n+\n     @EJB\n     GuestbookResponseServiceBean gbRespSvc;\n-    \n+\n     @EJB\n     DatasetVersionServiceBean datasetVersionService;\n-    \n-    @EJB \n+\n+    @EJB\n     ExplicitGroupServiceBean explicitGroupService;\n \n     @EJB\n@@ -129,16 +132,15 @@ public class AuthenticationServiceBean {\n \n     @PersistenceContext(unitName = \"VDCNet-ejbPU\")\n     private EntityManager em;\n-        \n-        \n-    public AbstractOAuth2AuthenticationProvider getOAuth2Provider( String id ) {\n+\n+    public AbstractOAuth2AuthenticationProvider getOAuth2Provider(String id) {\n         return authProvidersRegistrationService.getOAuth2AuthProvidersMap().get(id);\n     }\n-    \n+\n     public Set<AbstractOAuth2AuthenticationProvider> getOAuth2Providers() {\n         return new HashSet<>(authProvidersRegistrationService.getOAuth2AuthProvidersMap().values());\n     }\n-    \n+\n     public Set<String> getAuthenticationProviderIds() {\n         return authProvidersRegistrationService.getAuthenticationProvidersMap().keySet();\n     }\n@@ -146,43 +148,43 @@ public class AuthenticationServiceBean {\n     public Collection<AuthenticationProvider> getAuthenticationProviders() {\n         return authProvidersRegistrationService.getAuthenticationProvidersMap().values();\n     }\n-    \n-    public <T extends AuthenticationProvider> Set<String> getAuthenticationProviderIdsOfType( Class<T> aClass ) {\n+\n+    public <T extends AuthenticationProvider> Set<String> getAuthenticationProviderIdsOfType(Class<T> aClass) {\n         Set<String> retVal = new TreeSet<>();\n-        for ( Map.Entry<String, AuthenticationProvider> p : authProvidersRegistrationService.getAuthenticationProvidersMap().entrySet() ) {\n-            if ( aClass.isAssignableFrom( p.getValue().getClass() ) ) {\n-                retVal.add( p.getKey() );\n+        for (Map.Entry<String, AuthenticationProvider> p : authProvidersRegistrationService.getAuthenticationProvidersMap().entrySet()) {\n+            if (aClass.isAssignableFrom(p.getValue().getClass())) {\n+                retVal.add(p.getKey());\n             }\n         }\n         return retVal;\n     }\n-    \n-    public AuthenticationProviderFactory getProviderFactory( String alias ) {\n+\n+    public AuthenticationProviderFactory getProviderFactory(String alias) {\n         return authProvidersRegistrationService.getProviderFactoriesMap().get(alias);\n     }\n-    \n-    public AuthenticationProvider getAuthenticationProvider( String id ) {\n-        return authProvidersRegistrationService.getAuthenticationProvidersMap().get( id );\n+\n+    public AuthenticationProvider getAuthenticationProvider(String id) {\n+        return authProvidersRegistrationService.getAuthenticationProvidersMap().get(id);\n     }\n-    \n-    public AuthenticatedUser findByID(Object pk){\n-        if (pk==null){\n+\n+    public AuthenticatedUser findByID(Object pk) {\n+        if (pk == null) {\n             return null;\n         }\n         return em.find(AuthenticatedUser.class, pk);\n     }\n \n-    public void removeApiToken(AuthenticatedUser user){\n-        if (user!=null) {\n+    public void removeApiToken(AuthenticatedUser user) {\n+        if (user != null) {\n             ApiToken apiToken = findApiTokenByUser(user);\n             if (apiToken != null) {\n                 em.remove(apiToken);\n             }\n         }\n     }\n-    \n+\n     public boolean isOrcidEnabled() {\n-        return authProvidersRegistrationService.getOAuth2AuthProvidersMap().values().stream().anyMatch( s -> s.getId().toLowerCase().contains(\"orcid\") );\n+        return authProvidersRegistrationService.getOAuth2AuthProvidersMap().values().stream().anyMatch(s -> s.getId().toLowerCase().contains(\"orcid\"));\n     }\n     \n     /**\n@@ -201,15 +203,16 @@ public class AuthenticationServiceBean {\n      * to the user, including stuff they've created, role assignments, group\n      * assignments, etc. See the \"removeAuthentictedUserItems\" (sic) method.\n      */\n+\n     public void deleteAuthenticatedUser(Object pk) {\n         AuthenticatedUser user = em.find(AuthenticatedUser.class, pk);\n-\n         if (user != null) {\n             ApiToken apiToken = findApiTokenByUser(user);\n             if (apiToken != null) {\n                 em.remove(apiToken);\n             }\n             // @todo: this should be handed down to the service instead of doing it here.\n+\n             ConfirmEmailData confirmEmailData = confirmEmailService.findSingleConfirmEmailDataByUser(user);\n             if (confirmEmailData != null) {\n                 /**\n@@ -218,65 +221,50 @@ public class AuthenticationServiceBean {\n                 em.remove(confirmEmailData);\n             }\n             userNotificationService.findByUser(user.getId()).forEach(userNotificationService::delete);\n-            \n             AuthenticationProvider prv = lookupProvider(user);\n-            if ( prv != null && prv.isUserDeletionAllowed() ) {\n+            if (prv != null && prv.isUserDeletionAllowed()) {\n                 prv.deleteUser(user.getAuthenticatedUserLookup().getPersistentUserId());\n             }\n-            \n-            actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"deleteUser\")\n-                .setInfo(user.getUserIdentifier()));\n-            em.remove(user.getAuthenticatedUserLookup());         \n+            actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"deleteUser\").setInfo(user.getUserIdentifier()));\n+            em.remove(user.getAuthenticatedUserLookup());\n             em.remove(user);\n-\n         }\n     }\n-            \n-    public AuthenticatedUser getAuthenticatedUser( String identifier ) {\n+\n+    public AuthenticatedUser getAuthenticatedUser(String identifier) {\n         try {\n-            return em.createNamedQuery(\"AuthenticatedUser.findByIdentifier\", AuthenticatedUser.class)\n-                    .setParameter(\"identifier\", identifier)\n-                    .getSingleResult();\n-        } catch ( NoResultException nre ) {\n+            return em.createNamedQuery(\"AuthenticatedUser.findByIdentifier\", AuthenticatedUser.class).setParameter(\"identifier\", identifier).getSingleResult();\n+        } catch (NoResultException nre) {\n             return null;\n         }\n     }\n-    \n-    public AuthenticatedUser getAuthenticatedUserWithProvider( String identifier ) {\n+\n+    public AuthenticatedUser getAuthenticatedUserWithProvider(String identifier) {\n         try {\n-            AuthenticatedUser authenticatedUser = em.createNamedQuery(\"AuthenticatedUser.findByIdentifier\", AuthenticatedUser.class)\n-                    .setParameter(\"identifier\", identifier)\n-                    .getSingleResult();\n-            AuthenticatedUserLookup aul = em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthUser\", AuthenticatedUserLookup.class)\n-                    .setParameter(\"authUser\", authenticatedUser)\n-                    .getSingleResult();\n+            AuthenticatedUser authenticatedUser = em.createNamedQuery(\"AuthenticatedUser.findByIdentifier\", AuthenticatedUser.class).setParameter(\"identifier\", identifier).getSingleResult();\n+            AuthenticatedUserLookup aul = em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthUser\", AuthenticatedUserLookup.class).setParameter(\"authUser\", authenticatedUser).getSingleResult();\n             authenticatedUser.setAuthProviderId(aul.getAuthenticationProviderId());\n-            \n             return authenticatedUser;\n-        } catch ( NoResultException nre ) {\n+        } catch (NoResultException nre) {\n             return null;\n         }\n     }\n-    \n+\n     public AuthenticatedUser getAdminUser() {\n         try {\n-            return em.createNamedQuery(\"AuthenticatedUser.findAdminUser\", AuthenticatedUser.class)\n-                    .setMaxResults(1)\n-                    .getSingleResult();\n+            return em.createNamedQuery(\"AuthenticatedUser.findAdminUser\", AuthenticatedUser.class).setMaxResults(1).getSingleResult();\n         } catch (Exception ex) {\n             return null;\n         }\n     }\n \n-    public AuthenticatedUser getAuthenticatedUserByEmail( String email ) {\n+    public AuthenticatedUser getAuthenticatedUserByEmail(String email) {\n         try {\n-            return em.createNamedQuery(\"AuthenticatedUser.findByEmail\", AuthenticatedUser.class)\n-                    .setParameter(\"email\", email)\n-                    .getSingleResult();\n-        } catch ( NoResultException ex ) {\n+            return em.createNamedQuery(\"AuthenticatedUser.findByEmail\", AuthenticatedUser.class).setParameter(\"email\", email).getSingleResult();\n+        } catch (NoResultException ex) {\n             logger.log(Level.INFO, \"no user found using {0}\", email);\n             return null;\n-        } catch ( NonUniqueResultException ex ) {\n+        } catch (NonUniqueResultException ex) {\n             logger.log(Level.INFO, \"multiple users found using {0}: {1}\", new Object[]{email, ex});\n             return null;\n         }\n@@ -294,23 +282,23 @@ public class AuthenticationServiceBean {\n      * @return The authenticated user for the passed provider id and authentication request.\n      * @throws AuthenticationFailedException \n      */\n-    public AuthenticatedUser getUpdateAuthenticatedUser( String authenticationProviderId, AuthenticationRequest req ) throws AuthenticationFailedException {\n+\n+    public AuthenticatedUser getUpdateAuthenticatedUser(String authenticationProviderId, AuthenticationRequest req) throws AuthenticationFailedException {\n         AuthenticationProvider prv = getAuthenticationProvider(authenticationProviderId);\n-        if ( prv == null ) throw new IllegalArgumentException(\"No authentication provider listed under id \" + authenticationProviderId );\n-        if ( ! (prv instanceof CredentialsAuthenticationProvider) ) {\n-            throw new IllegalArgumentException( authenticationProviderId + \" does not support credentials-based authentication.\" );\n+        if (prv == null) throw new IllegalArgumentException(\"No authentication provider listed under id \" + authenticationProviderId);\n+        if (!(prv instanceof CredentialsAuthenticationProvider)) {\n+            throw new IllegalArgumentException(authenticationProviderId + \" does not support credentials-based authentication.\");\n         }\n-        AuthenticationResponse resp = ((CredentialsAuthenticationProvider)prv).authenticate(req);\n-        \n-        if ( resp.getStatus() == AuthenticationResponse.Status.SUCCESS ) {\n+\n+        AuthenticationResponse resp = ((CredentialsAuthenticationProvider) prv).authenticate(req);\n+        if (resp.getStatus() == AuthenticationResponse.Status.SUCCESS) {\n             // yay! see if we already have this user.\n             AuthenticatedUser user = lookupUser(authenticationProviderId, resp.getUserId());\n-\n             if (user != null && !user.isDeactivated()) {\n                 user = userService.updateLastLogin(user);\n             }\n-            \n-            if ( user == null ) {\n+\n+            if (user == null) {\n                 throw new IllegalStateException(\"Authenticated user does not exist. The functionality to support creating one at this point in authentication has been removed.\");\n                 //return createAuthenticatedUser(\n                 //        new UserRecordIdentifier(authenticationProviderId, resp.getUserId()), resp.getUserId(), resp.getUserDisplayInfo(), true );\n@@ -321,7 +309,7 @@ public class AuthenticationServiceBean {\n                     return updateAuthenticatedUser(user, resp.getUserDisplayInfo());\n                 }\n             }\n-        } else { \n+        } else {\n             throw new AuthenticationFailedException(resp, \"Authentication Failed: \" + resp.getMessage());\n         }\n     }\n@@ -330,16 +318,15 @@ public class AuthenticationServiceBean {\n      * @param email\n      * @return {@code true} iff the none of the authenticated users has the passed email address.\n      */\n+\n     public boolean isEmailAddressAvailable(String email) {\n-        return em.createNamedQuery(\"AuthenticatedUser.findByEmail\", AuthenticatedUser.class)\n-                 .setParameter(\"email\", email)\n-                 .getResultList().isEmpty();\n+        return em.createNamedQuery(\"AuthenticatedUser.findByEmail\", AuthenticatedUser.class).setParameter(\"email\", email).getResultList().isEmpty();\n     }\n-    \n+\n     public AuthenticatedUser lookupUser(UserRecordIdentifier id) {\n         return lookupUser(id.repoId, id.userIdInRepo);\n     }\n-    \n+\n     public AuthenticatedUser lookupUser(String authPrvId, String userPersistentId) {\n         TypedQuery<AuthenticatedUserLookup> typedQuery = em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthPrvID_PersUserId\", AuthenticatedUserLookup.class);\n         typedQuery.setParameter(\"authPrvId\", authPrvId);\n@@ -351,33 +338,33 @@ public class AuthenticationServiceBean {\n             return null;\n         }\n     }\n-    \n-    public AuthenticationProvider lookupProvider( AuthenticatedUser user )  {\n+\n+    public AuthenticationProvider lookupProvider(AuthenticatedUser user) {\n         return authProvidersRegistrationService.getAuthenticationProvidersMap().get(user.getAuthenticatedUserLookup().getAuthenticationProviderId());\n     }\n-    \n+\n     public ApiToken findApiToken(String token) {\n         try {\n-            return em.createNamedQuery(\"ApiToken.findByTokenString\", ApiToken.class)\n-                    .setParameter(\"tokenString\", token)\n-                    .getSingleResult();\n+            return em.createNamedQuery(\"ApiToken.findByTokenString\", ApiToken.class).setParameter(\"tokenString\", token).getSingleResult();\n         } catch (NoResultException ex) {\n             return null;\n         }\n     }\n-    \n+\n     public ApiToken findApiTokenByUser(AuthenticatedUser au) {\n         if (au == null) {\n             return null;\n         }\n+\n         TypedQuery<ApiToken> typedQuery = em.createNamedQuery(\"ApiToken.findByUser\", ApiToken.class);\n         typedQuery.setParameter(\"user\", au);\n         List<ApiToken> tokens = typedQuery.getResultList();\n-        Timestamp latest = new Timestamp(java.time.Instant.now().getEpochSecond()*1000);\n+        Timestamp latest = new Timestamp(java.time.Instant.now().getEpochSecond() * 1000);\n         if (tokens.isEmpty()) {\n             // Normal case - no token exists\n             return null;\n         }\n+\n         if (tokens.size() == 1) {\n             // Normal case - one token that may or may not have expired\n             ApiToken token = tokens.get(0);\n@@ -399,9 +386,9 @@ public class AuthenticationServiceBean {\n                 if (time.before(latest)) {\n                     em.remove(token);\n                 } else {\n-                    if(goodToken != null) {\n-                      em.remove(goodToken);\n-                      goodToken = null;\n+                    if (goodToken != null) {\n+                        em.remove(goodToken);\n+                        goodToken = null;\n                     }\n                     latest = time;\n                     goodToken = token;\n@@ -418,6 +405,7 @@ public class AuthenticationServiceBean {\n     // to expand this system, to be able to generate tokens with different\n     // lifecycles/valid for specific actions only, etc. \n     // -- L.A. 4.0 beta12\n+\n     public ApiToken generateApiTokenForUser(AuthenticatedUser au) {\n         if (au == null) {\n             return null;\n@@ -431,25 +419,22 @@ public class AuthenticationServiceBean {\n         c.roll(Calendar.YEAR, 1);\n         apiToken.setExpireTime(new Timestamp(c.getTimeInMillis()));\n         save(apiToken);\n-        actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"generateApiToken\")\n-            .setInfo(\"user:\" + au.getIdentifier() + \" token:\" +  apiToken.getTokenString()));\n-\n+        actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"generateApiToken\").setInfo(\"user:\" + au.getIdentifier() + \" token:\" + apiToken.getTokenString()));\n         return apiToken;\n     }\n \n-    public AuthenticatedUser lookupUser( String apiToken ) {\n+    public AuthenticatedUser lookupUser(String apiToken) {\n         ApiToken tkn = findApiToken(apiToken);\n-        if ( tkn == null ) return null;\n-        \n-        if ( tkn.isDisabled() ) return null;\n-        if ( tkn.getExpireTime() != null ) {\n-            if ( tkn.getExpireTime().before( new Timestamp(new Date().getTime())) ) {\n+        if (tkn == null) return null;\n+        if (tkn.isDisabled()) return null;\n+        if (tkn.getExpireTime() != null) {\n+            if (tkn.getExpireTime().before(new Timestamp(new Date().getTime()))) {\n                 em.remove(tkn);\n-\t\tlogger.info(\"attempted access with expired token: \" + apiToken);\n+                logger.info(\"attempted access with expired token: \" + apiToken);\n                 return null;\n             }\n         }\n-        \n+\n         AuthenticatedUser user = tkn.getAuthenticatedUser();\n         if (!user.isDeactivated()) {\n             return user;\n@@ -458,18 +443,17 @@ public class AuthenticationServiceBean {\n             return null;\n         }\n     }\n-    \n+\n     public AuthenticatedUser lookupUserForWorkflowInvocationID(String wfId) {\n         try {\n             PendingWorkflowInvocation pwfi = em.find(PendingWorkflowInvocation.class, wfId);\n             if (pwfi == null) {\n                 return null;\n             }\n+\n             if (pwfi.getUserId().startsWith(AuthenticatedUser.IDENTIFIER_PREFIX)) {\n-                if (pwfi.getLocalData().containsKey(PendingWorkflowInvocation.AUTHORIZED)\n-                        && Boolean.parseBoolean(pwfi.getLocalData().get(PendingWorkflowInvocation.AUTHORIZED))) {\n-                    return getAuthenticatedUser(\n-                            pwfi.getUserId().substring(AuthenticatedUser.IDENTIFIER_PREFIX.length()));\n+                if (pwfi.getLocalData().containsKey(PendingWorkflowInvocation.AUTHORIZED) && Boolean.parseBoolean(pwfi.getLocalData().get(PendingWorkflowInvocation.AUTHORIZED))) {\n+                    return getAuthenticatedUser(pwfi.getUserId().substring(AuthenticatedUser.IDENTIFIER_PREFIX.length()));\n                 }\n             }\n         } catch (NoResultException ex) {\n@@ -487,10 +471,10 @@ public class AuthenticationServiceBean {\n \n     An empty string is returned if the user is 'deletable'\n     */\n-    \n+\n     public String getDeleteUserErrorMessages(AuthenticatedUser au) {\n         String retVal = \"\";\n-        List<String> reasons= new ArrayList();\n+        List<String> reasons = new ArrayList();\n         if (!dvObjSvc.findByAuthenticatedUserId(au).isEmpty()) {\n             reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.dvobjects\"));\n         }\n@@ -500,7 +484,7 @@ public class AuthenticationServiceBean {\n         }\n \n         if (!gbRespSvc.findByAuthenticatedUserId(au).isEmpty()) {\n-            reasons.add( BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.gbResps\"));\n+            reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.gbResps\"));\n         }\n \n         if (!datasetVersionService.getDatasetVersionUsersByAuthenticatedUser(au).isEmpty()) {\n@@ -510,63 +494,51 @@ public class AuthenticationServiceBean {\n         if (!savedSearchService.findByAuthenticatedUser(au).isEmpty()) {\n             reasons.add(BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.savedSearches\"));\n         }\n-        \n+\n         if (!reasons.isEmpty()) {\n             retVal = BundleUtil.getStringFromBundle(\"admin.api.deleteUser.failure.prefix\", Arrays.asList(au.getIdentifier()));\n             retVal += \" \" + reasons.stream().collect(Collectors.joining(\"; \")) + \".\";\n         }\n-        \n-\n-\n         return retVal;\n     }\n-    \n-    public void removeAuthentictedUserItems(AuthenticatedUser au){\n+\n+    public void removeAuthentictedUserItems(AuthenticatedUser au) {\n         /* if the user has pending access requests, is the member of a group or \n         we will delete them here \n         */\n-\n         deletePendingAccessRequests(au);\n-        \n         deleteBannerMessages(au);\n-               \n         if (!explicitGroupService.findGroups(au).isEmpty()) {\n-            for(ExplicitGroup explicitGroup: explicitGroupService.findGroups(au)){\n+            for (ExplicitGroup explicitGroup : explicitGroupService.findGroups(au)) {\n                 explicitGroup.removeByRoleAssgineeIdentifier(au.getIdentifier());\n-            }            \n+            }\n         }\n-        \n     }\n-    \n-    private void deleteBannerMessages(AuthenticatedUser  au){\n-        \n-       em.createNativeQuery(\"delete from userbannermessage where user_id  = \"+au.getId()).executeUpdate();\n-        \n+\n+    private void deleteBannerMessages(AuthenticatedUser au) {\n+        em.createNativeQuery(\"delete from userbannermessage where user_id  = \" + au.getId()).executeUpdate();\n     }\n-    \n-    private void deletePendingAccessRequests(AuthenticatedUser  au){\n-        \n-       em.createNativeQuery(\"delete from fileaccessrequests where authenticated_user_id  = \"+au.getId()).executeUpdate();\n-        \n+\n+    private void deletePendingAccessRequests(AuthenticatedUser au) {\n+        em.createNativeQuery(\"delete from fileaccessrequests where authenticated_user_id  = \" + au.getId()).executeUpdate();\n     }\n-    \n-    public AuthenticatedUser save( AuthenticatedUser user ) {\n+\n+    public AuthenticatedUser save(AuthenticatedUser user) {\n         em.persist(user);\n         em.flush();\n         return user;\n     }\n-    \n-    public AuthenticatedUser update( AuthenticatedUser user ) {\n+\n+    public AuthenticatedUser update(AuthenticatedUser user) {\n         return em.merge(user);\n     }\n-    \n-    public ApiToken save( ApiToken aToken ) {\n-        if ( aToken.getId() == null ) {\n+\n+    public ApiToken save(ApiToken aToken) {\n+        if (aToken.getId() == null) {\n             em.persist(aToken);\n             return aToken;\n-        } else { \n-            return em.merge( aToken );\n-            \n+        } else {\n+            return em.merge(aToken);\n         }\n     }\n     \n@@ -577,19 +549,19 @@ public class AuthenticationServiceBean {\n      * @param persistentIdInProvider Id of the user in the new provider\n      * @return {@code true} iff the change was successful.\n      */\n-    public boolean updateProvider( AuthenticatedUser authenticatedUser, String authenticationProviderId, String persistentIdInProvider ) {\n+\n+    public boolean updateProvider(AuthenticatedUser authenticatedUser, String authenticationProviderId, String persistentIdInProvider) {\n         try {\n-            AuthenticatedUserLookup aul = em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthUser\", AuthenticatedUserLookup.class)\n-                    .setParameter(\"authUser\", authenticatedUser)\n-                    .getSingleResult();\n+            AuthenticatedUserLookup aul = em.createNamedQuery(\"AuthenticatedUserLookup.findByAuthUser\", AuthenticatedUserLookup.class).setParameter(\"authUser\", authenticatedUser).getSingleResult();\n             aul.setAuthenticationProviderId(authenticationProviderId);\n             aul.setPersistentUserId(persistentIdInProvider);\n-            actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth,\n-                    authenticatedUser.getIdentifier() + \" now associated with provider \" + authenticationProviderId + \" id: \" + persistentIdInProvider) );\n+            actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth, authenticatedUser.getIdentifier() + \" now associated with provider \" + authenticationProviderId + \" id: \" + persistentIdInProvider));\n             return true;\n-            \n-        } catch ( NoResultException | NonUniqueResultException ex ) {\n-            logger.log(Level.WARNING, \"Error converting user \" + authenticatedUser.getUserIdentifier() + \": \" + ex.getMessage(), ex);\n+        } catch (NoResultException | NonUniqueResultException ex) {\n+            logger.log(Level.WARNING,\n+                       \"Error converting user \"\n+                    + authenticatedUser.getUserIdentifier() + \": \" + ex.getMessage(),\n+                       ex);\n             return false;\n         }\n     }\n@@ -608,15 +580,12 @@ public class AuthenticationServiceBean {\n      * @return the newly created user, or {@code null} if the proposed identifier exists and {@code generateUniqueIdentifier} was {@code false}.\n      * @throws EJBException which may wrap an ConstraintViolationException if the proposed user does not pass bean validation.\n      */\n-    public AuthenticatedUser createAuthenticatedUser(UserRecordIdentifier userRecordId,\n-            String proposedAuthenticatedUserIdentifier,\n-            AuthenticatedUserDisplayInfo userDisplayInfo,\n-            boolean generateUniqueIdentifier) {\n+\n+    public AuthenticatedUser createAuthenticatedUser(UserRecordIdentifier userRecordId, String proposedAuthenticatedUserIdentifier, AuthenticatedUserDisplayInfo userDisplayInfo, boolean generateUniqueIdentifier) {\n         AuthenticatedUser authenticatedUser = new AuthenticatedUser();\n         // set account creation time & initial login time (same timestamp)\n         authenticatedUser.setCreatedTime(new Timestamp(new Date().getTime()));\n         authenticatedUser.setLastLoginTime(authenticatedUser.getCreatedTime());\n-        \n         authenticatedUser.applyDisplayInfo(userDisplayInfo);\n \n         // we have no desire for leading or trailing whitespace in identifiers\n@@ -624,27 +593,28 @@ public class AuthenticationServiceBean {\n             proposedAuthenticatedUserIdentifier = proposedAuthenticatedUserIdentifier.trim();\n         }\n         // we now select a username for the generated AuthenticatedUser, or give up\n+\n         String internalUserIdentifer = proposedAuthenticatedUserIdentifier;\n         // TODO should lock table authenticated users for write here\n-        if ( identifierExists(internalUserIdentifer) ) {\n-            if ( ! generateUniqueIdentifier ) {\n+        if (identifierExists(internalUserIdentifer)) {\n+            if (!generateUniqueIdentifier) {\n                 return null;\n             }\n-            int i=1;\n+\n+            int i = 1;\n             String identifier = internalUserIdentifer + i;\n-            while ( identifierExists(identifier) ) {\n+            while (identifierExists(identifier)) {\n                 i += 1;\n             }\n             authenticatedUser.setUserIdentifier(identifier);\n         } else {\n             authenticatedUser.setUserIdentifier(internalUserIdentifer);\n         }\n-        authenticatedUser = save( authenticatedUser );\n+        authenticatedUser = save(authenticatedUser);\n         // TODO should unlock table authenticated users for write here\n         AuthenticatedUserLookup auusLookup = userRecordId.createAuthenticatedUserLookup(authenticatedUser);\n-        em.persist( auusLookup );\n+        em.persist(auusLookup);\n         authenticatedUser.setAuthenticatedUserLookup(auusLookup);\n-\n         if (ShibAuthenticationProvider.PROVIDER_ID.equals(auusLookup.getAuthenticationProviderId())) {\n             Timestamp emailConfirmedNow = new Timestamp(new Date().getTime());\n             // Email addresses for Shib users are confirmed by the Identity Provider.\n@@ -655,10 +625,7 @@ public class AuthenticationServiceBean {\n              * better to do something like \"startConfirmEmailProcessForNewUser\". */\n             confirmEmailService.createToken(authenticatedUser);\n         }\n-        \n-        actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"createUser\")\n-            .setInfo(authenticatedUser.getIdentifier()));\n-\n+        actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"createUser\").setInfo(authenticatedUser.getIdentifier()));\n         return authenticatedUser;\n     }\n     \n@@ -667,19 +634,17 @@ public class AuthenticationServiceBean {\n      * @param idtf\n      * @return {@code true} iff there's already a user by that username.\n      */\n-    public boolean identifierExists( String idtf ) {\n-        return em.createNamedQuery(\"AuthenticatedUser.countOfIdentifier\", Number.class)\n-                .setParameter(\"identifier\", idtf)\n-                .getSingleResult().intValue() > 0;\n+\n+    public boolean identifierExists(String idtf) {\n+        return em.createNamedQuery(\"AuthenticatedUser.countOfIdentifier\", Number.class).setParameter(\"identifier\", idtf).getSingleResult().intValue() > 0;\n     }\n-    \n+\n     public AuthenticatedUser updateAuthenticatedUser(AuthenticatedUser user, AuthenticatedUserDisplayInfo userDisplayInfo) {\n         user.applyDisplayInfo(userDisplayInfo);\n-        actionLogSvc.log( new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"updateUser\")\n-            .setInfo(user.getIdentifier()));\n+        actionLogSvc.log(new ActionLogRecord(ActionLogRecord.ActionType.Auth, \"updateUser\").setInfo(user.getIdentifier()));\n         return update(user);\n     }\n-    \n+\n     public List<AuthenticatedUser> findAllAuthenticatedUsers() {\n         return em.createNamedQuery(\"AuthenticatedUser.findAll\", AuthenticatedUser.class).getResultList();\n     }\n@@ -687,18 +652,18 @@ public class AuthenticationServiceBean {\n     public List<AuthenticatedUser> findSuperUsers() {\n         return em.createNamedQuery(\"AuthenticatedUser.findSuperUsers\", AuthenticatedUser.class).getResultList();\n     }\n-    \n-    \n+\n     public Set<AuthenticationProviderFactory> listProviderFactories() {\n-        return new HashSet<>( authProvidersRegistrationService.getProviderFactoriesMap().values() ); \n+        return new HashSet<>(authProvidersRegistrationService.getProviderFactoriesMap().values());\n     }\n-    \n+\n     public Timestamp getCurrentTimestamp() {\n         return new Timestamp(new Date().getTime());\n     }\n \n     // TODO should probably be moved to the Shib provider - this is a classic Shib-specific\n     //      use case. This class should deal with general autnetications.\n+\n     @Deprecated\n     /**\n      * @deprecated. Switch to convertBuiltInUserToRemoteUser instead.\n@@ -708,7 +673,8 @@ public class AuthenticationServiceBean {\n         logger.info(\"converting user \" + builtInUserToConvert.getId() + \" from builtin to shib\");\n         String builtInUserIdentifier = builtInUserToConvert.getIdentifier();\n         logger.info(\"builtin user identifier: \" + builtInUserIdentifier);\n-        TypedQuery<AuthenticatedUserLookup> typedQuery = em.createQuery(\"SELECT OBJECT(o) FROM AuthenticatedUserLookup AS o WHERE o.authenticatedUser = :auid\", AuthenticatedUserLookup.class);\n+        TypedQuery<AuthenticatedUserLookup> typedQuery = em.createQuery(\"SELECT OBJECT(o) FROM AuthenticatedUserLookup AS o WHERE o.authenticatedUser = :auid\",\n+                                                                        AuthenticatedUserLookup.class);\n         typedQuery.setParameter(\"auid\", builtInUserToConvert);\n         AuthenticatedUserLookup authuserLookup;\n         try {\n@@ -717,6 +683,7 @@ public class AuthenticationServiceBean {\n             logger.info(\"exception caught: \" + ex);\n             return null;\n         }\n+\n         if (authuserLookup == null) {\n             return null;\n         }\n@@ -746,6 +713,7 @@ public class AuthenticationServiceBean {\n         } else {\n             logger.info(\"Couldn't delete builtin user because could find it based on username \" + builtinUsername);\n         }\n+\n         AuthenticatedUser shibUser = lookupUser(shibProviderId, perUserShibIdentifier);\n         if (shibUser != null) {\n             return shibUser;\n@@ -757,7 +725,8 @@ public class AuthenticationServiceBean {\n         logger.info(\"converting user \" + builtInUserToConvert.getId() + \" from builtin to remote\");\n         String builtInUserIdentifier = builtInUserToConvert.getIdentifier();\n         logger.info(\"builtin user identifier: \" + builtInUserIdentifier);\n-        TypedQuery<AuthenticatedUserLookup> typedQuery = em.createQuery(\"SELECT OBJECT(o) FROM AuthenticatedUserLookup AS o WHERE o.authenticatedUser = :auid\", AuthenticatedUserLookup.class);\n+        TypedQuery<AuthenticatedUserLookup> typedQuery = em.createQuery(\"SELECT OBJECT(o) FROM AuthenticatedUserLookup AS o WHERE o.authenticatedUser = :auid\",\n+                                                                        AuthenticatedUserLookup.class);\n         typedQuery.setParameter(\"auid\", builtInUserToConvert);\n         AuthenticatedUserLookup authuserLookup;\n         try {\n@@ -766,6 +735,7 @@ public class AuthenticationServiceBean {\n             logger.info(\"exception caught: \" + ex);\n             return null;\n         }\n+\n         if (authuserLookup == null) {\n             return null;\n         }\n@@ -795,6 +765,7 @@ public class AuthenticationServiceBean {\n         } else {\n             logger.info(\"Couldn't delete builtin user because could find it based on username \" + builtinUsername);\n         }\n+\n         AuthenticatedUser nonBuiltinUser = lookupUser(newProviderId, perUserIdentifier);\n         if (nonBuiltinUser != null) {\n             return nonBuiltinUser;\n@@ -811,15 +782,18 @@ public class AuthenticationServiceBean {\n      * @throws java.lang.Exception You must catch and report back to the user (a\n      * superuser) any Exceptions.\n      */\n+\n     public BuiltinUser convertRemoteToBuiltIn(Long idOfAuthUserToConvert, String newEmailAddress) throws Exception {\n         AuthenticatedUser authenticatedUser = findByID(idOfAuthUserToConvert);\n         if (authenticatedUser == null) {\n             throw new Exception(\"User id \" + idOfAuthUserToConvert + \" not found.\");\n         }\n+\n         AuthenticatedUser existingUserWithSameEmail = getAuthenticatedUserByEmail(newEmailAddress);\n         if (existingUserWithSameEmail != null) {\n             throw new Exception(\"User id \" + idOfAuthUserToConvert + \" (\" + authenticatedUser.getIdentifier() + \") cannot be converted from remote to BuiltIn because the email address \" + newEmailAddress + \" is already in use by user id \" + existingUserWithSameEmail.getId() + \" (\" + existingUserWithSameEmail.getIdentifier() + \").\");\n         }\n+\n         BuiltinUser builtinUser = new BuiltinUser();\n         builtinUser.setUserName(authenticatedUser.getUserIdentifier());\n         ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n@@ -838,14 +812,17 @@ public class AuthenticationServiceBean {\n         } catch (IllegalArgumentException ex) {\n             throw new Exception(\"User id \" + idOfAuthUserToConvert + \" cannot be converted from remote to BuiltIn because of an IllegalArgumentException creating the row in the builtinuser table: \" + ex);\n         }\n+\n         AuthenticatedUserLookup lookup = authenticatedUser.getAuthenticatedUserLookup();\n         if (lookup == null) {\n             throw new Exception(\"User id \" + idOfAuthUserToConvert + \" does not have an 'authenticateduserlookup' row\");\n         }\n+\n         String providerId = lookup.getAuthenticationProviderId();\n         if (providerId == null) {\n             throw new Exception(\"User id \" + idOfAuthUserToConvert + \" provider id is null.\");\n         }\n+\n         String builtinProviderId = BuiltinAuthenticationProvider.PROVIDER_ID;\n         if (providerId.equals(builtinProviderId)) {\n             throw new Exception(\"User id \" + idOfAuthUserToConvert + \" cannot be converted from remote to BuiltIn because current provider id is '\" + providerId + \"' which is the same as '\" + builtinProviderId + \"'. This user is already a BuiltIn user.\");\n@@ -878,7 +855,6 @@ public class AuthenticationServiceBean {\n          * @todo Should probably set IP address here.\n          */\n //        authReq.setIpAddress(session.getUser().getRequestMetadata().getIpAddress());\n-\n         String credentialsAuthProviderId = BuiltinAuthenticationProvider.PROVIDER_ID;\n         try {\n             AuthenticatedUser au = getUpdateAuthenticatedUser(credentialsAuthProviderId, authReq);\n@@ -941,11 +917,11 @@ public class AuthenticationServiceBean {\n             return null;\n         }\n     }\n-    \n-    public List <WorkflowComment> getWorkflowCommentsByAuthenticatedUser(AuthenticatedUser user){ \n+\n+    public List<WorkflowComment> getWorkflowCommentsByAuthenticatedUser(AuthenticatedUser user) {\n         Query query = em.createQuery(\"SELECT wc FROM WorkflowComment wc WHERE wc.authenticatedUser.id = :auid\");\n-        query.setParameter(\"auid\", user.getId());       \n+        query.setParameter(\"auid\", user.getId());\n         return query.getResultList();\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 219
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/59/AuthenticationServiceBean.java\nindex 349a86301a6..fdf85706469 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/59/AuthenticationServiceBean.java\n@@ -445,7 +445,7 @@ public class AuthenticationServiceBean {\n         if ( tkn.getExpireTime() != null ) {\n             if ( tkn.getExpireTime().before( new Timestamp(new Date().getTime())) ) {\n                 em.remove(tkn);\n-\t\tlogger.info(\"attempted access with expired token: \" + apiToken);\n+        logger.info(\"attempted access with expired token: \" + apiToken);\n                 return null;\n             }\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/59/AuthenticationServiceBean.java\nindex 349a86301a6..053472887fb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/59/AuthenticationServiceBean.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/59/AuthenticationServiceBean.java\n@@ -445,7 +445,7 @@ public class AuthenticationServiceBean {\n         if ( tkn.getExpireTime() != null ) {\n             if ( tkn.getExpireTime().before( new Timestamp(new Date().getTime())) ) {\n                 em.remove(tkn);\n-\t\tlogger.info(\"attempted access with expired token: \" + apiToken);\n+                logger.info(\"attempted access with expired token: \" + apiToken);\n                 return null;\n             }\n         }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}