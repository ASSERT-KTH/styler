{
    "project_name": "vostok-hercules",
    "error_id": "83",
    "information": {
        "errors": [
            {
                "line": "123",
                "severity": "warning",
                "message": "Line is longer than 160 characters (found 221).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                int retryCount = retryLimit;\n                do {\n                    ByteArrayOutputStream dataStream = new ByteArrayOutputStream(readyToSend.size() * EXPECTED_EVENT_SIZE_BYTES);//TODO: Replace EXPECTED_EVENT_SIZE_BYTES with heuristic is depending on Hercules event size\n                    readyToSend.values().forEach(wrapper -> writeEventToStream(dataStream, wrapper));\n                    ElasticResponseHandler.Result result = client.index(dataStream.toByteArray());\n",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "123",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 221).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/83/ElasticSender.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/83/ElasticSender.java\nindex eb4c20c7c5e..61c5d2786ae 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/83/ElasticSender.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/83/ElasticSender.java\n@@ -33,213 +33,214 @@ import static ru.kontur.vostok.hercules.util.throwable.ThrowableUtil.toUnchecked\n  * @author Gregory Koshelev\n  */\n public class ElasticSender extends Sender {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ElasticSender.class);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ElasticSender.class);\n \n-    private static final int EXPECTED_EVENT_SIZE_BYTES = 2_048;\n+  private static final int EXPECTED_EVENT_SIZE_BYTES = 2_048;\n \n-    private final IndexPolicy indexPolicy;\n-    private final IndexResolver indexResolver;\n+  private final IndexPolicy indexPolicy;\n+  private final IndexResolver indexResolver;\n \n-    private final EventMappingWriter eventMappingWriter;\n+  private final EventMappingWriter eventMappingWriter;\n \n-    private final ElasticClient client;\n+  private final ElasticClient client;\n \n-    private final int retryLimit;\n-    private final boolean retryOnUnknownErrors;\n+  private final int retryLimit;\n+  private final boolean retryOnUnknownErrors;\n \n-    private final boolean leproseryEnable;\n-    private final LeproserySender leproserySender;\n+  private final boolean leproseryEnable;\n+  private final LeproserySender leproserySender;\n \n-    private final IndicesMetricsCollector totalEventsIndicesMetricsCollector;\n-    private final IndicesMetricsCollector nonRetryableEventsIndicesMetricsCollector;\n-    private final Meter droppedNonRetryableErrorsMeter;\n-    private final Meter indexValidationErrorsMeter;\n+  private final IndicesMetricsCollector totalEventsIndicesMetricsCollector;\n+  private final IndicesMetricsCollector nonRetryableEventsIndicesMetricsCollector;\n+  private final Meter droppedNonRetryableErrorsMeter;\n+  private final Meter indexValidationErrorsMeter;\n \n-    public ElasticSender(Properties properties, MetricsCollector metricsCollector) {\n-        super(properties, metricsCollector);\n+  public ElasticSender(Properties properties, MetricsCollector metricsCollector) {\n+    super(properties, metricsCollector);\n \n-        this.indexPolicy = PropertiesUtil.get(Props.INDEX_POLICY, properties).get();\n-        if (indexPolicy == IndexPolicy.STATIC) {\n-            ParameterValue<String> indexNameValue = PropertiesUtil.get(Props.INDEX_NAME, properties);\n-            if (indexNameValue.isEmpty()) {\n-                throw new IllegalArgumentException(\"Index name must be defined if 'static' index policy is used\");\n-            }\n-            Optional<String> indexNameOptional = Optional.of(indexNameValue.get()).map(IndexResolver::sanitize);\n-            this.indexResolver = (e) -> indexNameOptional;\n-        } else {\n-            this.indexResolver = LogEventIndexResolver.forPolicy(indexPolicy);\n-        }\n-\n-        this.eventMappingWriter = new EventMappingWriter(PropertiesUtil.ofScope(properties, \"elastic.mapping\"));\n-\n-        this.client = new ElasticClient(PropertiesUtil.ofScope(properties, \"elastic.client\"), indexPolicy, metricsCollector);\n+    this.indexPolicy = PropertiesUtil.get(Props.INDEX_POLICY, properties).get();\n+    if (indexPolicy == IndexPolicy.STATIC) {\n+      ParameterValue<String> indexNameValue = PropertiesUtil.get(Props.INDEX_NAME, properties);\n+      if (indexNameValue.isEmpty()) {\n+        throw new IllegalArgumentException(\"Index name must be defined if 'static' index policy is used\");\n+      }\n+      Optional<String> indexNameOptional = Optional.of(indexNameValue.get()).map(IndexResolver::sanitize);\n+      this.indexResolver = (e) -> indexNameOptional;\n+    } else {\n+      this.indexResolver = LogEventIndexResolver.forPolicy(indexPolicy);\n+    }\n \n-        this.retryLimit = PropertiesUtil.get(Props.RETRY_LIMIT, properties).get();\n-        this.retryOnUnknownErrors = PropertiesUtil.get(Props.RETRY_ON_UNKNOWN_ERRORS, properties).get();\n+    this.eventMappingWriter = new EventMappingWriter(PropertiesUtil.ofScope(properties, \"elastic.mapping\"));\n \n-        this.leproseryEnable = PropertiesUtil.get(Props.LEPROSERY_ENABLE, properties).get();\n-        this.leproserySender = leproseryEnable\n-                ? new LeproserySender(PropertiesUtil.ofScope(properties, Scopes.LEPROSERY), metricsCollector, eventMappingWriter)\n-                : null;\n+    this.client = new ElasticClient(PropertiesUtil.ofScope(properties, \"elastic.client\"), indexPolicy, metricsCollector);\n \n-        this.totalEventsIndicesMetricsCollector = new IndicesMetricsCollector(\"totalEvents\", 10_000, metricsCollector);\n-        this.nonRetryableEventsIndicesMetricsCollector = new IndicesMetricsCollector(\"nonRetryableEvents\", 10_000, metricsCollector);\n-        this.droppedNonRetryableErrorsMeter = metricsCollector.meter(\"droppedNonRetryableErrors\");\n-        this.indexValidationErrorsMeter = metricsCollector.meter(\"indexValidationErrors\");\n-    }\n+    this.retryLimit = PropertiesUtil.get(Props.RETRY_LIMIT, properties).get();\n+    this.retryOnUnknownErrors = PropertiesUtil.get(Props.RETRY_ON_UNKNOWN_ERRORS, properties).get();\n \n-    @Override\n-    public ProcessorStatus ping() {\n-        return client.ping() ? ProcessorStatus.AVAILABLE : ProcessorStatus.UNAVAILABLE;\n-    }\n+    this.leproseryEnable = PropertiesUtil.get(Props.LEPROSERY_ENABLE, properties).get();\n+    this.leproserySender = leproseryEnable\n+      ? new LeproserySender(PropertiesUtil.ofScope(properties, Scopes.LEPROSERY), metricsCollector, eventMappingWriter)\n+      : null;\n \n-    @Override\n-    protected int send(List<Event> events) throws BackendServiceFailedException {\n-        if (events.size() == 0) {\n-            return 0;\n-        }\n+    this.totalEventsIndicesMetricsCollector = new IndicesMetricsCollector(\"totalEvents\", 10_000, metricsCollector);\n+    this.nonRetryableEventsIndicesMetricsCollector = new IndicesMetricsCollector(\"nonRetryableEvents\", 10_000, metricsCollector);\n+    this.droppedNonRetryableErrorsMeter = metricsCollector.meter(\"droppedNonRetryableErrors\");\n+    this.indexValidationErrorsMeter = metricsCollector.meter(\"indexValidationErrors\");\n+  }\n \n-        int droppedCount;\n-        Map<EventWrapper, ValidationResult> nonRetryableErrorsMap = new HashMap<>(events.size());\n-        //event-id -> event-wrapper\n-        Map<String, EventWrapper> readyToSend = new HashMap<>(events.size());\n-        for (Event event : events) {\n-            Optional<String> index = indexResolver.resolve(event);\n-            String nonNullIndex = index.orElse(\"null\");\n-            EventWrapper wrapper = new EventWrapper(event, nonNullIndex);\n-            totalEventsIndicesMetricsCollector.markEvent(nonNullIndex);\n-            if (index.isPresent()) {\n-                readyToSend.put(wrapper.getId(), wrapper);\n-            } else {\n-                indexValidationErrorsMeter.mark();\n-                nonRetryableErrorsMap.put(wrapper, ValidationResult.error(\"Event index is null\"));\n-            }\n-        }\n+  @Override\n+  public ProcessorStatus ping() {\n+    return client.ping() ? ProcessorStatus.AVAILABLE : ProcessorStatus.UNAVAILABLE;\n+  }\n \n-        try {\n-            if (!readyToSend.isEmpty()) {\n-                int retryCount = retryLimit;\n-                do {\n-                    ByteArrayOutputStream dataStream = new ByteArrayOutputStream(readyToSend.size() * EXPECTED_EVENT_SIZE_BYTES);//TODO: Replace EXPECTED_EVENT_SIZE_BYTES with heuristic is depending on Hercules event size\n-                    readyToSend.values().forEach(wrapper -> writeEventToStream(dataStream, wrapper));\n-                    ElasticResponseHandler.Result result = client.index(dataStream.toByteArray());\n-\n-                    if (result.getTotalErrors() != 0) {\n-                        resultProcess(result).forEach((eventId, validationResult) ->\n-                                nonRetryableErrorsMap.put(readyToSend.remove(eventId), validationResult));\n-                    } else {\n-                        readyToSend.clear();\n-                    }\n-                } while (!readyToSend.isEmpty() && 0 < retryCount--);\n-\n-                if (!readyToSend.isEmpty()) {\n-                    throw new Exception(\"Have retryable errors in elasticsearch response\");\n-                }\n-            }\n-\n-            droppedCount = errorsProcess(nonRetryableErrorsMap);\n-        } catch (Exception ex) {\n-            throw new BackendServiceFailedException(ex);\n-        }\n-\n-        return events.size() - droppedCount;\n+  @Override\n+  protected int send(List<Event> events) throws BackendServiceFailedException {\n+    if (events.size() == 0) {\n+      return 0;\n     }\n \n-    private Map<String, ValidationResult> resultProcess(ElasticResponseHandler.Result result) {\n-        LOGGER.info(\n-                \"Error statistics (retryable/non retryable/unknown/total): {}/{}/{}/{}\",\n-                result.getRetryableErrorCount(),\n-                result.getNonRetryableErrorCount(),\n-                result.getUnknownErrorCount(),\n-                result.getTotalErrors()\n-        );\n-\n-        Map<String, ValidationResult> errorsMap = new HashMap<>(result.getErrors().size());\n-        for (Map.Entry<String, ErrorInfo> entry : result.getErrors().entrySet()) {\n-            String eventId = entry.getKey();\n-            ErrorInfo errorInfo = entry.getValue();\n-            ErrorType type = errorInfo.getType();\n-            if (type.equals(ErrorType.NON_RETRYABLE) || (type.equals(ErrorType.UNKNOWN) && !retryOnUnknownErrors)) {\n-                errorsMap.put(eventId, ValidationResult.error(errorInfo.getError()));\n-            }\n-        }\n-        return errorsMap;\n+    int droppedCount;\n+    Map<EventWrapper, ValidationResult> nonRetryableErrorsMap = new HashMap<>(events.size());\n+    //event-id -> event-wrapper\n+    Map<String, EventWrapper> readyToSend = new HashMap<>(events.size());\n+    for (Event event : events) {\n+      Optional<String> index = indexResolver.resolve(event);\n+      String nonNullIndex = index.orElse(\"null\");\n+      EventWrapper wrapper = new EventWrapper(event, nonNullIndex);\n+      totalEventsIndicesMetricsCollector.markEvent(nonNullIndex);\n+      if (index.isPresent()) {\n+        readyToSend.put(wrapper.getId(), wrapper);\n+      } else {\n+        indexValidationErrorsMeter.mark();\n+        nonRetryableErrorsMap.put(wrapper, ValidationResult.error(\"Event index is null\"));\n+      }\n     }\n \n-    /**\n-     * @return count of dropped events\n-     */\n-    private int errorsProcess(Map<EventWrapper, ValidationResult> nonRetryableErrorsInfo) {\n-        if (nonRetryableErrorsInfo.isEmpty()) {\n-            return 0;\n+    try {\n+      if (!readyToSend.isEmpty()) {\n+        int retryCount = retryLimit;\n+        do {\n+          ByteArrayOutputStream dataStream = new ByteArrayOutputStream(\n+            readyToSend.size() * EXPECTED_EVENT_SIZE_BYTES);//TODO: Replace EXPECTED_EVENT_SIZE_BYTES with heuristic is depending on Hercules event size\n+          readyToSend.values().forEach(wrapper -> writeEventToStream(dataStream, wrapper));\n+          ElasticResponseHandler.Result result = client.index(dataStream.toByteArray());\n+\n+          if (result.getTotalErrors() != 0) {\n+            resultProcess(result).forEach((eventId, validationResult) ->\n+              nonRetryableErrorsMap.put(readyToSend.remove(eventId), validationResult));\n+          } else {\n+            readyToSend.clear();\n+          }\n+        } while (!readyToSend.isEmpty() && 0 < retryCount--);\n+\n+        if (!readyToSend.isEmpty()) {\n+          throw new Exception(\"Have retryable errors in elasticsearch response\");\n         }\n+      }\n \n-        for (EventWrapper wrapper : nonRetryableErrorsInfo.keySet()) {\n-            nonRetryableEventsIndicesMetricsCollector.markEvent(wrapper.getIndex());\n-        }\n+      droppedCount = errorsProcess(nonRetryableErrorsMap);\n+    } catch (Exception ex) {\n+      throw new BackendServiceFailedException(ex);\n+    }\n \n-        if (leproseryEnable) {\n-            try {\n-                leproserySender.convertAndSend(nonRetryableErrorsInfo);\n-                return 0;\n-            } catch (Exception ex) {\n-                LOGGER.warn(\"Failed to send non retryable events to leprosery\", ex);\n-                droppedNonRetryableErrorsMeter.mark(nonRetryableErrorsInfo.size());\n-                return nonRetryableErrorsInfo.size();\n-            }\n-        } else {\n-            nonRetryableErrorsInfo.forEach((wrapper, validationResult) ->\n-                    LOGGER.warn(\"Non retryable error info: id = {}, index = {}, reason = {}\",\n-                            wrapper.getId(),\n-                            wrapper.getIndex(),\n-                            validationResult.error()));\n-            droppedNonRetryableErrorsMeter.mark(nonRetryableErrorsInfo.size());\n-            return nonRetryableErrorsInfo.size();\n-        }\n+    return events.size() - droppedCount;\n+  }\n+\n+  private Map<String, ValidationResult> resultProcess(ElasticResponseHandler.Result result) {\n+    LOGGER.info(\n+      \"Error statistics (retryable/non retryable/unknown/total): {}/{}/{}/{}\",\n+      result.getRetryableErrorCount(),\n+      result.getNonRetryableErrorCount(),\n+      result.getUnknownErrorCount(),\n+      result.getTotalErrors()\n+    );\n+\n+    Map<String, ValidationResult> errorsMap = new HashMap<>(result.getErrors().size());\n+    for (Map.Entry<String, ErrorInfo> entry : result.getErrors().entrySet()) {\n+      String eventId = entry.getKey();\n+      ErrorInfo errorInfo = entry.getValue();\n+      ErrorType type = errorInfo.getType();\n+      if (type.equals(ErrorType.NON_RETRYABLE) || (type.equals(ErrorType.UNKNOWN) && !retryOnUnknownErrors)) {\n+        errorsMap.put(eventId, ValidationResult.error(errorInfo.getError()));\n+      }\n+    }\n+    return errorsMap;\n+  }\n+\n+  /**\n+   * @return count of dropped events\n+   */\n+  private int errorsProcess(Map<EventWrapper, ValidationResult> nonRetryableErrorsInfo) {\n+    if (nonRetryableErrorsInfo.isEmpty()) {\n+      return 0;\n     }\n \n-    private void writeEventToStream(ByteArrayOutputStream stream, EventWrapper wrapper) {\n-        toUnchecked(() -> {\n-            IndexToElasticJsonWriter.writeIndex(stream, wrapper.getIndex(), wrapper.getId());\n-            stream.write('\\n');\n-            eventMappingWriter.write(stream, wrapper.getEvent());\n-            stream.write('\\n');\n-        });\n+    for (EventWrapper wrapper : nonRetryableErrorsInfo.keySet()) {\n+      nonRetryableEventsIndicesMetricsCollector.markEvent(wrapper.getIndex());\n     }\n \n-    private static class Props {\n-        static final Parameter<IndexPolicy> INDEX_POLICY =\n-                Parameter.enumParameter(\"elastic.index.policy\", IndexPolicy.class).\n-                        withDefault(IndexPolicy.DAILY).\n-                        build();\n-\n-        static final Parameter<String> INDEX_NAME =\n-                Parameter.stringParameter(\"elastic.index.name\").\n-                        withValidator((v) -> {\n-                            if (!IndexValidator.isValidIndexName(v)) {\n-                                return ValidationResult.error(\"Invalid index name\");\n-                            }\n-                            if (!IndexValidator.isValidLength(v)) {\n-                                return ValidationResult.error(\"Index name exceeds length limit\");\n-                            }\n-                            return ValidationResult.ok();\n-                        }).\n-                        build();\n-\n-        static final Parameter<Integer> RETRY_LIMIT = Parameter\n-                .integerParameter(\"retryLimit\")\n-                .withDefault(3)\n-                .withValidator(IntegerValidators.nonNegative())\n-                .build();\n-\n-        static final Parameter<Boolean> RETRY_ON_UNKNOWN_ERRORS = Parameter\n-                .booleanParameter(\"retryOnUnknownErrors\")\n-                .withDefault(Boolean.FALSE)\n-                .build();\n-\n-        static final Parameter<Boolean> LEPROSERY_ENABLE = Parameter\n-                .booleanParameter(\"leprosery.enable\")\n-                .withDefault(false)\n-                .build();\n+    if (leproseryEnable) {\n+      try {\n+        leproserySender.convertAndSend(nonRetryableErrorsInfo);\n+        return 0;\n+      } catch (Exception ex) {\n+        LOGGER.warn(\"Failed to send non retryable events to leprosery\", ex);\n+        droppedNonRetryableErrorsMeter.mark(nonRetryableErrorsInfo.size());\n+        return nonRetryableErrorsInfo.size();\n+      }\n+    } else {\n+      nonRetryableErrorsInfo.forEach((wrapper, validationResult) ->\n+        LOGGER.warn(\"Non retryable error info: id = {}, index = {}, reason = {}\",\n+          wrapper.getId(),\n+          wrapper.getIndex(),\n+          validationResult.error()));\n+      droppedNonRetryableErrorsMeter.mark(nonRetryableErrorsInfo.size());\n+      return nonRetryableErrorsInfo.size();\n     }\n+  }\n+\n+  private void writeEventToStream(ByteArrayOutputStream stream, EventWrapper wrapper) {\n+    toUnchecked(() -> {\n+      IndexToElasticJsonWriter.writeIndex(stream, wrapper.getIndex(), wrapper.getId());\n+      stream.write('\\n');\n+      eventMappingWriter.write(stream, wrapper.getEvent());\n+      stream.write('\\n');\n+    });\n+  }\n+\n+  private static class Props {\n+    static final Parameter<IndexPolicy> INDEX_POLICY =\n+      Parameter.enumParameter(\"elastic.index.policy\", IndexPolicy.class).\n+        withDefault(IndexPolicy.DAILY).\n+        build();\n+\n+    static final Parameter<String> INDEX_NAME =\n+      Parameter.stringParameter(\"elastic.index.name\").\n+        withValidator((v) -> {\n+          if (!IndexValidator.isValidIndexName(v)) {\n+            return ValidationResult.error(\"Invalid index name\");\n+          }\n+          if (!IndexValidator.isValidLength(v)) {\n+            return ValidationResult.error(\"Index name exceeds length limit\");\n+          }\n+          return ValidationResult.ok();\n+        }).\n+        build();\n+\n+    static final Parameter<Integer> RETRY_LIMIT = Parameter\n+      .integerParameter(\"retryLimit\")\n+      .withDefault(3)\n+      .withValidator(IntegerValidators.nonNegative())\n+      .build();\n+\n+    static final Parameter<Boolean> RETRY_ON_UNKNOWN_ERRORS = Parameter\n+      .booleanParameter(\"retryOnUnknownErrors\")\n+      .withDefault(Boolean.FALSE)\n+      .build();\n+\n+    static final Parameter<Boolean> LEPROSERY_ENABLE = Parameter\n+      .booleanParameter(\"leprosery.enable\")\n+      .withDefault(false)\n+      .build();\n+  }\n }\n",
            "diff_size": 254
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "120",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 221).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/83/ElasticSender.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/83/ElasticSender.java\nindex eb4c20c7c5e..42d83b59719 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/83/ElasticSender.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/83/ElasticSender.java\n@@ -36,8 +36,7 @@ public class ElasticSender extends Sender {\n     private static final Logger LOGGER = LoggerFactory.getLogger(ElasticSender.class);\n \n     private static final int EXPECTED_EVENT_SIZE_BYTES = 2_048;\n-\n-    private final IndexPolicy indexPolicy;\n+private final IndexPolicy indexPolicy;\n     private final IndexResolver indexResolver;\n \n     private final EventMappingWriter eventMappingWriter;\n@@ -79,10 +78,8 @@ public class ElasticSender extends Sender {\n \n         this.leproseryEnable = PropertiesUtil.get(Props.LEPROSERY_ENABLE, properties).get();\n         this.leproserySender = leproseryEnable\n-                ? new LeproserySender(PropertiesUtil.ofScope(properties, Scopes.LEPROSERY), metricsCollector, eventMappingWriter)\n-                : null;\n-\n-        this.totalEventsIndicesMetricsCollector = new IndicesMetricsCollector(\"totalEvents\", 10_000, metricsCollector);\n+                ? new LeproserySender(PropertiesUtil.ofScope(properties, Scopes.LEPROSERY), metricsCollector, eventMappingWriter) : null;\n+this.totalEventsIndicesMetricsCollector = new IndicesMetricsCollector(\"totalEvents\", 10_000, metricsCollector);\n         this.nonRetryableEventsIndicesMetricsCollector = new IndicesMetricsCollector(\"nonRetryableEvents\", 10_000, metricsCollector);\n         this.droppedNonRetryableErrorsMeter = metricsCollector.meter(\"droppedNonRetryableErrors\");\n         this.indexValidationErrorsMeter = metricsCollector.meter(\"indexValidationErrors\");\n@@ -125,8 +122,7 @@ public class ElasticSender extends Sender {\n                     ElasticResponseHandler.Result result = client.index(dataStream.toByteArray());\n \n                     if (result.getTotalErrors() != 0) {\n-                        resultProcess(result).forEach((eventId, validationResult) ->\n-                                nonRetryableErrorsMap.put(readyToSend.remove(eventId), validationResult));\n+                        resultProcess(result).forEach((eventId, validationResult) -> nonRetryableErrorsMap.put(readyToSend.remove(eventId), validationResult));\n                     } else {\n                         readyToSend.clear();\n                     }\n@@ -188,8 +184,7 @@ public class ElasticSender extends Sender {\n                 return nonRetryableErrorsInfo.size();\n             }\n         } else {\n-            nonRetryableErrorsInfo.forEach((wrapper, validationResult) ->\n-                    LOGGER.warn(\"Non retryable error info: id = {}, index = {}, reason = {}\",\n+            nonRetryableErrorsInfo.forEach((wrapper, validationResult) -> LOGGER.warn(\"Non retryable error info: id = {}, index = {}, reason = {}\",\n                             wrapper.getId(),\n                             wrapper.getIndex(),\n                             validationResult.error()));\n@@ -209,13 +204,10 @@ public class ElasticSender extends Sender {\n \n     private static class Props {\n         static final Parameter<IndexPolicy> INDEX_POLICY =\n-                Parameter.enumParameter(\"elastic.index.policy\", IndexPolicy.class).\n-                        withDefault(IndexPolicy.DAILY).\n-                        build();\n+                Parameter.enumParameter(\"elastic.index.policy\", IndexPolicy.class).withDefault(IndexPolicy.DAILY).build();\n \n         static final Parameter<String> INDEX_NAME =\n-                Parameter.stringParameter(\"elastic.index.name\").\n-                        withValidator((v) -> {\n+                Parameter.stringParameter(\"elastic.index.name\").withValidator((v) -> {\n                             if (!IndexValidator.isValidIndexName(v)) {\n                                 return ValidationResult.error(\"Invalid index name\");\n                             }\n@@ -223,8 +215,7 @@ public class ElasticSender extends Sender {\n                                 return ValidationResult.error(\"Index name exceeds length limit\");\n                             }\n                             return ValidationResult.ok();\n-                        }).\n-                        build();\n+                        }).build();\n \n         static final Parameter<Integer> RETRY_LIMIT = Parameter\n                 .integerParameter(\"retryLimit\")\n@@ -242,4 +233,4 @@ public class ElasticSender extends Sender {\n                 .withDefault(false)\n                 .build();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 18
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "124",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 221).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "147",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 218).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "185",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 212).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/83/ElasticSender.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/83/ElasticSender.java\nindex eb4c20c7c5e..74d5b194c0b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/83/ElasticSender.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/83/ElasticSender.java\n@@ -19,7 +19,6 @@ import ru.kontur.vostok.hercules.util.parameter.ParameterValue;\n import ru.kontur.vostok.hercules.util.properties.PropertiesUtil;\n import ru.kontur.vostok.hercules.util.validation.IntegerValidators;\n import ru.kontur.vostok.hercules.util.validation.ValidationResult;\n-\n import java.io.ByteArrayOutputStream;\n import java.util.HashMap;\n import java.util.List;\n@@ -32,24 +31,19 @@ import static ru.kontur.vostok.hercules.util.throwable.ThrowableUtil.toUnchecked\n /**\n  * @author Gregory Koshelev\n  */\n+\n public class ElasticSender extends Sender {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(ElasticSender.class);\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(ElasticSender.class);\n     private static final int EXPECTED_EVENT_SIZE_BYTES = 2_048;\n-\n     private final IndexPolicy indexPolicy;\n     private final IndexResolver indexResolver;\n-\n     private final EventMappingWriter eventMappingWriter;\n-\n     private final ElasticClient client;\n-\n     private final int retryLimit;\n     private final boolean retryOnUnknownErrors;\n-\n     private final boolean leproseryEnable;\n     private final LeproserySender leproserySender;\n-\n     private final IndicesMetricsCollector totalEventsIndicesMetricsCollector;\n     private final IndicesMetricsCollector nonRetryableEventsIndicesMetricsCollector;\n     private final Meter droppedNonRetryableErrorsMeter;\n@@ -57,31 +51,38 @@ public class ElasticSender extends Sender {\n \n     public ElasticSender(Properties properties, MetricsCollector metricsCollector) {\n         super(properties, metricsCollector);\n-\n-        this.indexPolicy = PropertiesUtil.get(Props.INDEX_POLICY, properties).get();\n+        this.indexPolicy = PropertiesUtil.get(Props.INDEX_POLICY, properties)\n+        .get();\n         if (indexPolicy == IndexPolicy.STATIC) {\n             ParameterValue<String> indexNameValue = PropertiesUtil.get(Props.INDEX_NAME, properties);\n             if (indexNameValue.isEmpty()) {\n                 throw new IllegalArgumentException(\"Index name must be defined if 'static' index policy is used\");\n             }\n-            Optional<String> indexNameOptional = Optional.of(indexNameValue.get()).map(IndexResolver::sanitize);\n+\n+            Optional<String> indexNameOptional = Optional.of(indexNameValue.get())\n+            .map(IndexResolver::sanitize);\n             this.indexResolver = (e) -> indexNameOptional;\n         } else {\n             this.indexResolver = LogEventIndexResolver.forPolicy(indexPolicy);\n         }\n \n         this.eventMappingWriter = new EventMappingWriter(PropertiesUtil.ofScope(properties, \"elastic.mapping\"));\n-\n-        this.client = new ElasticClient(PropertiesUtil.ofScope(properties, \"elastic.client\"), indexPolicy, metricsCollector);\n-\n-        this.retryLimit = PropertiesUtil.get(Props.RETRY_LIMIT, properties).get();\n-        this.retryOnUnknownErrors = PropertiesUtil.get(Props.RETRY_ON_UNKNOWN_ERRORS, properties).get();\n-\n-        this.leproseryEnable = PropertiesUtil.get(Props.LEPROSERY_ENABLE, properties).get();\n-        this.leproserySender = leproseryEnable\n-                ? new LeproserySender(PropertiesUtil.ofScope(properties, Scopes.LEPROSERY), metricsCollector, eventMappingWriter)\n-                : null;\n-\n+        this.client = new ElasticClient(\n+            PropertiesUtil.ofScope(properties, \"elastic.client\"),\n+            indexPolicy,\n+            metricsCollector\n+        );\n+        this.retryLimit = PropertiesUtil.get(Props.RETRY_LIMIT, properties)\n+        .get();\n+        this.retryOnUnknownErrors = PropertiesUtil.get(Props.RETRY_ON_UNKNOWN_ERRORS, properties)\n+        .get();\n+        this.leproseryEnable = PropertiesUtil.get(Props.LEPROSERY_ENABLE, properties)\n+        .get();\n+        this.leproserySender = leproseryEnable ? new LeproserySender(\n+            PropertiesUtil.ofScope(properties, Scopes.LEPROSERY),\n+            metricsCollector,\n+            eventMappingWriter\n+                               ) : null;\n         this.totalEventsIndicesMetricsCollector = new IndicesMetricsCollector(\"totalEvents\", 10_000, metricsCollector);\n         this.nonRetryableEventsIndicesMetricsCollector = new IndicesMetricsCollector(\"nonRetryableEvents\", 10_000, metricsCollector);\n         this.droppedNonRetryableErrorsMeter = metricsCollector.meter(\"droppedNonRetryableErrors\");\n@@ -122,16 +123,14 @@ public class ElasticSender extends Sender {\n                 do {\n                     ByteArrayOutputStream dataStream = new ByteArrayOutputStream(readyToSend.size() * EXPECTED_EVENT_SIZE_BYTES);//TODO: Replace EXPECTED_EVENT_SIZE_BYTES with heuristic is depending on Hercules event size\n                     readyToSend.values().forEach(wrapper -> writeEventToStream(dataStream, wrapper));\n-                    ElasticResponseHandler.Result result = client.index(dataStream.toByteArray());\n \n+                    ElasticResponseHandler.Result result = client.index(dataStream.toByteArray());\n                     if (result.getTotalErrors() != 0) {\n-                        resultProcess(result).forEach((eventId, validationResult) ->\n-                                nonRetryableErrorsMap.put(readyToSend.remove(eventId), validationResult));\n+                        resultProcess(result).forEach((eventId, validationResult) -> nonRetryableErrorsMap.put(readyToSend.remove(eventId), validationResult));\n                     } else {\n                         readyToSend.clear();\n                     }\n                 } while (!readyToSend.isEmpty() && 0 < retryCount--);\n-\n                 if (!readyToSend.isEmpty()) {\n                     throw new Exception(\"Have retryable errors in elasticsearch response\");\n                 }\n@@ -141,21 +140,16 @@ public class ElasticSender extends Sender {\n         } catch (Exception ex) {\n             throw new BackendServiceFailedException(ex);\n         }\n-\n         return events.size() - droppedCount;\n     }\n \n     private Map<String, ValidationResult> resultProcess(ElasticResponseHandler.Result result) {\n-        LOGGER.info(\n-                \"Error statistics (retryable/non retryable/unknown/total): {}/{}/{}/{}\",\n-                result.getRetryableErrorCount(),\n-                result.getNonRetryableErrorCount(),\n-                result.getUnknownErrorCount(),\n-                result.getTotalErrors()\n-        );\n+        LOGGER.info(\"Error statistics (retryable/non retryable/unknown/total): {}/{}/{}/{}\", result.getRetryableErrorCount(), result.getNonRetryableErrorCount(), result.getUnknownErrorCount(), result.getTotalErrors());\n \n-        Map<String, ValidationResult> errorsMap = new HashMap<>(result.getErrors().size());\n-        for (Map.Entry<String, ErrorInfo> entry : result.getErrors().entrySet()) {\n+        Map<String, ValidationResult> errorsMap = new HashMap<>(result.getErrors()\n+        .size());\n+        for (Map.Entry<String, ErrorInfo> entry : result.getErrors()\n+        .entrySet()) {\n             String eventId = entry.getKey();\n             ErrorInfo errorInfo = entry.getValue();\n             ErrorType type = errorInfo.getType();\n@@ -169,6 +163,7 @@ public class ElasticSender extends Sender {\n     /**\n      * @return count of dropped events\n      */\n+\n     private int errorsProcess(Map<EventWrapper, ValidationResult> nonRetryableErrorsInfo) {\n         if (nonRetryableErrorsInfo.isEmpty()) {\n             return 0;\n@@ -177,7 +172,6 @@ public class ElasticSender extends Sender {\n         for (EventWrapper wrapper : nonRetryableErrorsInfo.keySet()) {\n             nonRetryableEventsIndicesMetricsCollector.markEvent(wrapper.getIndex());\n         }\n-\n         if (leproseryEnable) {\n             try {\n                 leproserySender.convertAndSend(nonRetryableErrorsInfo);\n@@ -188,11 +182,7 @@ public class ElasticSender extends Sender {\n                 return nonRetryableErrorsInfo.size();\n             }\n         } else {\n-            nonRetryableErrorsInfo.forEach((wrapper, validationResult) ->\n-                    LOGGER.warn(\"Non retryable error info: id = {}, index = {}, reason = {}\",\n-                            wrapper.getId(),\n-                            wrapper.getIndex(),\n-                            validationResult.error()));\n+            nonRetryableErrorsInfo.forEach((wrapper, validationResult) -> LOGGER.warn(\"Non retryable error info: id = {}, index = {}, reason = {}\", wrapper.getId(), wrapper.getIndex(), validationResult.error()));\n             droppedNonRetryableErrorsMeter.mark(nonRetryableErrorsInfo.size());\n             return nonRetryableErrorsInfo.size();\n         }\n@@ -208,38 +198,33 @@ public class ElasticSender extends Sender {\n     }\n \n     private static class Props {\n-        static final Parameter<IndexPolicy> INDEX_POLICY =\n-                Parameter.enumParameter(\"elastic.index.policy\", IndexPolicy.class).\n-                        withDefault(IndexPolicy.DAILY).\n-                        build();\n-\n-        static final Parameter<String> INDEX_NAME =\n-                Parameter.stringParameter(\"elastic.index.name\").\n-                        withValidator((v) -> {\n-                            if (!IndexValidator.isValidIndexName(v)) {\n-                                return ValidationResult.error(\"Invalid index name\");\n-                            }\n-                            if (!IndexValidator.isValidLength(v)) {\n-                                return ValidationResult.error(\"Index name exceeds length limit\");\n-                            }\n-                            return ValidationResult.ok();\n-                        }).\n-                        build();\n-\n-        static final Parameter<Integer> RETRY_LIMIT = Parameter\n-                .integerParameter(\"retryLimit\")\n-                .withDefault(3)\n-                .withValidator(IntegerValidators.nonNegative())\n-                .build();\n-\n-        static final Parameter<Boolean> RETRY_ON_UNKNOWN_ERRORS = Parameter\n-                .booleanParameter(\"retryOnUnknownErrors\")\n-                .withDefault(Boolean.FALSE)\n-                .build();\n-\n-        static final Parameter<Boolean> LEPROSERY_ENABLE = Parameter\n-                .booleanParameter(\"leprosery.enable\")\n-                .withDefault(false)\n-                .build();\n+        static final Parameter<IndexPolicy> INDEX_POLICY = Parameter.enumParameter(\"elastic.index.policy\", IndexPolicy.class)\n+        .withDefault(IndexPolicy.DAILY)\n+        .build();\n+\n+        static final Parameter<String> INDEX_NAME = Parameter.stringParameter(\"elastic.index.name\")\n+        .withValidator((v) -> {\n+            if (!IndexValidator.isValidIndexName(v)) {\n+                return ValidationResult.error(\"Invalid index name\");\n+            }\n+            if (!IndexValidator.isValidLength(v)) {\n+                return ValidationResult.error(\"Index name exceeds length limit\");\n+            }\n+            return ValidationResult.ok();\n+        })\n+        .build();\n+\n+        static final Parameter<Integer> RETRY_LIMIT = Parameter.integerParameter(\"retryLimit\")\n+        .withDefault(3)\n+        .withValidator(IntegerValidators.nonNegative())\n+        .build();\n+\n+        static final Parameter<Boolean> RETRY_ON_UNKNOWN_ERRORS = Parameter.booleanParameter(\"retryOnUnknownErrors\")\n+        .withDefault(Boolean.FALSE)\n+        .build();\n+\n+        static final Parameter<Boolean> LEPROSERY_ENABLE = Parameter.booleanParameter(\"leprosery.enable\")\n+        .withDefault(false)\n+        .build();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 89
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "123",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 302).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "123",
                    "column": "100",
                    "severity": "warning",
                    "message": "'*' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/83/ElasticSender.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/83/ElasticSender.java\nindex eb4c20c7c5e..5228aa7fc4e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/83/ElasticSender.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/83/ElasticSender.java\n@@ -120,8 +120,8 @@ public class ElasticSender extends Sender {\n             if (!readyToSend.isEmpty()) {\n                 int retryCount = retryLimit;\n                 do {\n-                    ByteArrayOutputStream dataStream = new ByteArrayOutputStream(readyToSend.size() * EXPECTED_EVENT_SIZE_BYTES);//TODO: Replace EXPECTED_EVENT_SIZE_BYTES with heuristic is depending on Hercules event size\n-                    readyToSend.values().forEach(wrapper -> writeEventToStream(dataStream, wrapper));\n+                    ByteArrayOutputStream dataStream = new ByteArrayOutputStream(readyToSend.size()* EXPECTED_EVENT_SIZE_BYTES );//TODO: Replace EXPECTED_EVENT_SIZE_BYTES with heuristic is depending on Hercules event sizereadyToSend.values().forEach(wrapper -> writeEventToStream(dataStream, wrapper));\n+                    ElasticResponseHandler.values().forEach(wrapper -> writeEventToStream(dataStream, wrapper));\n                     ElasticResponseHandler.Result result = client.index(dataStream.toByteArray());\n \n                     if (result.getTotalErrors() != 0) {\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "123",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 221).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}