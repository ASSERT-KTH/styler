{
    "project_name": "IQSS-dataverse",
    "error_id": "87",
    "information": {
        "errors": [
            {
                "line": "709",
                "column": "17",
                "severity": "error",
                "message": "'{' at column 17 should have line break after.",
                "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
            }
        ]
    },
    "source_code": "\n        } else {\n            try {json.getString(\"value\");}\n            catch (ClassCastException cce) {\n                throw new JsonParseException(\"Invalid value submitted for \" + dft.getName() + \". It should be a single value.\");\n            }            ",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/87/JsonParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/87/JsonParser.java\nindex a902d93daca..e447cec69dc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/87/JsonParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/87/JsonParser.java\n@@ -706,7 +706,8 @@ public class JsonParser {\n             }\n \n         } else {\n-            try {json.getString(\"value\");}\n+            try{\n+                json.getString(\"value\");}\n             catch (ClassCastException cce) {\n                 throw new JsonParseException(\"Invalid value submitted for \" + dft.getName() + \". It should be a single value.\");\n             }            \n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/87/JsonParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/87/JsonParser.java\nindex a902d93daca..5aae7170ebb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/87/JsonParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/87/JsonParser.java\n@@ -48,79 +48,80 @@ import javax.json.JsonValue.ValueType;\n  */\n public class JsonParser {\n \n-    private static final Logger logger = Logger.getLogger(JsonParser.class.getCanonicalName());\n+  private static final Logger logger = Logger.getLogger(JsonParser.class.getCanonicalName());\n+\n+  DatasetFieldServiceBean datasetFieldSvc;\n+  MetadataBlockServiceBean blockService;\n+  SettingsServiceBean settingsService;\n+\n+  /**\n+   * if lenient, we will accept alternate spellings for controlled vocabulary values\n+   */\n+  boolean lenient = false;\n+\n+  public JsonParser(DatasetFieldServiceBean datasetFieldSvc, MetadataBlockServiceBean blockService,\n+                    SettingsServiceBean settingsService) {\n+    this.datasetFieldSvc = datasetFieldSvc;\n+    this.blockService = blockService;\n+    this.settingsService = settingsService;\n+  }\n+\n+  public JsonParser() {\n+    this(null, null, null);\n+  }\n+\n+  public boolean isLenient() {\n+    return lenient;\n+  }\n+\n+  public void setLenient(boolean lenient) {\n+    this.lenient = lenient;\n+  }\n+\n+  public Dataverse parseDataverse(JsonObject jobj) throws JsonParseException {\n+    Dataverse dv = new Dataverse();\n \n-    DatasetFieldServiceBean datasetFieldSvc;\n-    MetadataBlockServiceBean blockService;\n-    SettingsServiceBean settingsService;\n-    \n     /**\n-     * if lenient, we will accept alternate spellings for controlled vocabulary values\n+     * @todo Instead of this getMandatoryString method we should run the\n+     * String through ConstraintValidator. See EMailValidatorTest and\n+     * EMailValidator for examples. That way we can check not only if it's\n+     * required or not but other bean validation rules such as \"must match\n+     * this regex\".\n      */\n-    boolean lenient = false;  \n-\n-    public JsonParser(DatasetFieldServiceBean datasetFieldSvc, MetadataBlockServiceBean blockService, SettingsServiceBean settingsService) {\n-        this.datasetFieldSvc = datasetFieldSvc;\n-        this.blockService = blockService;\n-        this.settingsService = settingsService;\n-    }\n-\n-    public JsonParser() {\n-        this( null,null,null );\n-    }\n-    \n-    public boolean isLenient() {\n-        return lenient;\n-    }\n-\n-    public void setLenient(boolean lenient) {\n-        this.lenient = lenient;\n-    }\n-\n-    public Dataverse parseDataverse(JsonObject jobj) throws JsonParseException {\n-        Dataverse dv = new Dataverse();\n-\n-        /**\n-         * @todo Instead of this getMandatoryString method we should run the\n-         * String through ConstraintValidator. See EMailValidatorTest and\n-         * EMailValidator for examples. That way we can check not only if it's\n-         * required or not but other bean validation rules such as \"must match\n-         * this regex\".\n-         */\n-        dv.setAlias(getMandatoryString(jobj, \"alias\"));\n-        dv.setName(getMandatoryString(jobj, \"name\"));\n-        dv.setDescription(jobj.getString(\"description\", null));\n-        dv.setPermissionRoot(jobj.getBoolean(\"permissionRoot\", false));\n-        dv.setFacetRoot(jobj.getBoolean(\"facetRoot\", false));\n-        dv.setAffiliation(jobj.getString(\"affiliation\", null));\n-      \n-        if (jobj.containsKey(\"dataverseContacts\")) {\n-            JsonArray dvContacts = jobj.getJsonArray(\"dataverseContacts\");\n-            int i = 0;\n-            List<DataverseContact> dvContactList = new LinkedList<>();\n-            for (JsonValue jsv : dvContacts) {\n-                DataverseContact dvc = new DataverseContact(dv);\n-                dvc.setContactEmail(getMandatoryString((JsonObject) jsv, \"contactEmail\"));\n-                dvc.setDisplayOrder(i++);\n-                dvContactList.add(dvc);\n-            }\n-            dv.setDataverseContacts(dvContactList);\n-        }\n-        \n-        if (jobj.containsKey(\"theme\")) {\n-            DataverseTheme theme = parseDataverseTheme(jobj.getJsonObject(\"theme\"));\n-            dv.setDataverseTheme(theme);\n-            theme.setDataverse(dv);\n-        }\n+    dv.setAlias(getMandatoryString(jobj, \"alias\"));\n+    dv.setName(getMandatoryString(jobj, \"name\"));\n+    dv.setDescription(jobj.getString(\"description\", null));\n+    dv.setPermissionRoot(jobj.getBoolean(\"permissionRoot\", false));\n+    dv.setFacetRoot(jobj.getBoolean(\"facetRoot\", false));\n+    dv.setAffiliation(jobj.getString(\"affiliation\", null));\n \n-        dv.setDataverseType(Dataverse.DataverseType.UNCATEGORIZED); // default\n-        if (jobj.containsKey(\"dataverseType\")) {\n-            for (Dataverse.DataverseType dvtype : Dataverse.DataverseType.values()) {\n-                if (dvtype.name().equals(jobj.getString(\"dataverseType\"))) {\n-                    dv.setDataverseType(dvtype);\n-                }\n-            }\n+    if (jobj.containsKey(\"dataverseContacts\")) {\n+      JsonArray dvContacts = jobj.getJsonArray(\"dataverseContacts\");\n+      int i = 0;\n+      List<DataverseContact> dvContactList = new LinkedList<>();\n+      for (JsonValue jsv : dvContacts) {\n+        DataverseContact dvc = new DataverseContact(dv);\n+        dvc.setContactEmail(getMandatoryString((JsonObject) jsv, \"contactEmail\"));\n+        dvc.setDisplayOrder(i++);\n+        dvContactList.add(dvc);\n+      }\n+      dv.setDataverseContacts(dvContactList);\n+    }\n+\n+    if (jobj.containsKey(\"theme\")) {\n+      DataverseTheme theme = parseDataverseTheme(jobj.getJsonObject(\"theme\"));\n+      dv.setDataverseTheme(theme);\n+      theme.setDataverse(dv);\n+    }\n+\n+    dv.setDataverseType(Dataverse.DataverseType.UNCATEGORIZED); // default\n+    if (jobj.containsKey(\"dataverseType\")) {\n+      for (Dataverse.DataverseType dvtype : Dataverse.DataverseType.values()) {\n+        if (dvtype.name().equals(jobj.getString(\"dataverseType\"))) {\n+          dv.setDataverseType(dvtype);\n         }\n+      }\n+    }\n \n         /*  We decided that subject is not user set, but gotten from the subject of the dataverse's\n             datasets - leavig this code in for now, in case we need to go back to it at some point\n@@ -147,729 +148,758 @@ public class JsonParser {\n             dv.setDataverseSubjects(dvSubjectList);\n         }\n         */\n-                \n-        return dv;\n-    }\n-    \n-    public DataverseTheme parseDataverseTheme(JsonObject obj) {\n \n-        DataverseTheme theme = new DataverseTheme();\n+    return dv;\n+  }\n \n-        if (obj.containsKey(\"backgroundColor\")) {\n-            theme.setBackgroundColor(obj.getString(\"backgroundColor\", null));\n-        }\n-        if (obj.containsKey(\"linkColor\")) {\n-            theme.setLinkColor(obj.getString(\"linkColor\", null));\n-        }\n-        if (obj.containsKey(\"linkUrl\")) {\n-            theme.setLinkUrl(obj.getString(\"linkUrl\", null));\n-        }\n-        if (obj.containsKey(\"logo\")) {\n-            theme.setLogo(obj.getString(\"logo\", null));\n-        }\n-        if (obj.containsKey(\"logoAlignment\")) {\n-            String align = obj.getString(\"logoAlignment\");\n-            if (align.equalsIgnoreCase(\"left\")) {\n-                theme.setLogoAlignment(DataverseTheme.Alignment.LEFT);\n-            }\n-            if (align.equalsIgnoreCase(\"right\")) {\n-                theme.setLogoAlignment(DataverseTheme.Alignment.RIGHT);\n-            }\n-            if (align.equalsIgnoreCase(\"center\")) {\n-                theme.setLogoAlignment(DataverseTheme.Alignment.CENTER);\n-            }\n-        }\n-        if (obj.containsKey(\"logoBackgroundColor\")) {\n-            theme.setLogoBackgroundColor(obj.getString(\"logoBackgroundColor\", null));\n-        }\n-        if (obj.containsKey(\"logoFormat\")) {\n-            String format = obj.getString(\"logoFormat\");\n-            if (format.equalsIgnoreCase(\"square\")) {\n-                theme.setLogoFormat(DataverseTheme.ImageFormat.SQUARE);\n-            }\n-            if (format.equalsIgnoreCase(\"rectangle\")) {\n-                theme.setLogoFormat(DataverseTheme.ImageFormat.RECTANGLE);\n-            }\n-        }\n-        if (obj.containsKey(\"tagline\")) {\n-            theme.setTagline(obj.getString(\"tagline\", null));\n-        }\n-        if (obj.containsKey(\"textColor\")) {\n-            theme.setTextColor(obj.getString(\"textColor\", null));\n-        }\n+  public DataverseTheme parseDataverseTheme(JsonObject obj) {\n \n-        return theme;\n-    }\n-\n-    private static String getMandatoryString(JsonObject jobj, String name) throws JsonParseException {\n-        if (jobj.containsKey(name)) {\n-            return jobj.getString(name);\n-        }\n-        throw new JsonParseException(\"Field \" + name + \" is mandatory\");\n-    }\n-\n-    public IpGroup parseIpGroup(JsonObject obj) {\n-        IpGroup retVal = new IpGroup();\n-\n-        if (obj.containsKey(\"id\")) {\n-            retVal.setId(Long.valueOf(obj.getInt(\"id\")));\n-        }\n-        retVal.setDisplayName(obj.getString(\"name\", null));\n-        retVal.setDescription(obj.getString(\"description\", null));\n-        retVal.setPersistedGroupAlias(obj.getString(\"alias\", null));\n-\n-        if ( obj.containsKey(\"ranges\") ) {\n-            obj.getJsonArray(\"ranges\").stream()\n-                    .filter( jv -> jv.getValueType()==JsonValue.ValueType.ARRAY )\n-                    .map( jv -> (JsonArray)jv )\n-                    .forEach( rr -> {\n-                        retVal.add(\n-                            IpAddressRange.make(IpAddress.valueOf(rr.getString(0)),\n-                                                IpAddress.valueOf(rr.getString(1))));\n-            });\n-        }\n-        if ( obj.containsKey(\"addresses\") ) {\n-            obj.getJsonArray(\"addresses\").stream()\n-                    .map( jsVal -> IpAddress.valueOf(((JsonString)jsVal).getString()) )\n-                    .map( addr -> IpAddressRange.make(addr, addr) )\n-                    .forEach( retVal::add );\n-        }\n-\n-        return retVal;\n-    }\n-    \n-    public MailDomainGroup parseMailDomainGroup(JsonObject obj) throws JsonParseException {\n-        MailDomainGroup grp = new MailDomainGroup();\n-        \n-        if (obj.containsKey(\"id\")) {\n-            grp.setId(obj.getJsonNumber(\"id\").longValue());\n-        }\n-        grp.setDisplayName(getMandatoryString(obj, \"name\"));\n-        grp.setDescription(obj.getString(\"description\", null));\n-        grp.setPersistedGroupAlias(getMandatoryString(obj, \"alias\"));\n-        grp.setIsRegEx(obj.getBoolean(\"regex\", false));\n-        if ( obj.containsKey(\"domains\") ) {\n-            List<String> domains =\n-                Optional.ofNullable(obj.getJsonArray(\"domains\"))\n-                    .orElse(Json.createArrayBuilder().build())\n-                    .getValuesAs(JsonString.class)\n-                    .stream()\n-                    .map(JsonString::getString)\n-                    // only validate if this group hasn't regex support enabled\n-                    .filter(d -> (grp.isRegEx() || DomainValidator.getInstance().isValid(d)))\n-                    .collect(Collectors.toList());\n-            if (domains.isEmpty())\n-                throw new JsonParseException(\"Field domains may not be an empty array or contain invalid domains. Enabled regex support?\");\n-            grp.setEmailDomains(domains);\n+    DataverseTheme theme = new DataverseTheme();\n+\n+    if (obj.containsKey(\"backgroundColor\")) {\n+      theme.setBackgroundColor(obj.getString(\"backgroundColor\", null));\n+    }\n+    if (obj.containsKey(\"linkColor\")) {\n+      theme.setLinkColor(obj.getString(\"linkColor\", null));\n+    }\n+    if (obj.containsKey(\"linkUrl\")) {\n+      theme.setLinkUrl(obj.getString(\"linkUrl\", null));\n+    }\n+    if (obj.containsKey(\"logo\")) {\n+      theme.setLogo(obj.getString(\"logo\", null));\n+    }\n+    if (obj.containsKey(\"logoAlignment\")) {\n+      String align = obj.getString(\"logoAlignment\");\n+      if (align.equalsIgnoreCase(\"left\")) {\n+        theme.setLogoAlignment(DataverseTheme.Alignment.LEFT);\n+      }\n+      if (align.equalsIgnoreCase(\"right\")) {\n+        theme.setLogoAlignment(DataverseTheme.Alignment.RIGHT);\n+      }\n+      if (align.equalsIgnoreCase(\"center\")) {\n+        theme.setLogoAlignment(DataverseTheme.Alignment.CENTER);\n+      }\n+    }\n+    if (obj.containsKey(\"logoBackgroundColor\")) {\n+      theme.setLogoBackgroundColor(obj.getString(\"logoBackgroundColor\", null));\n+    }\n+    if (obj.containsKey(\"logoFormat\")) {\n+      String format = obj.getString(\"logoFormat\");\n+      if (format.equalsIgnoreCase(\"square\")) {\n+        theme.setLogoFormat(DataverseTheme.ImageFormat.SQUARE);\n+      }\n+      if (format.equalsIgnoreCase(\"rectangle\")) {\n+        theme.setLogoFormat(DataverseTheme.ImageFormat.RECTANGLE);\n+      }\n+    }\n+    if (obj.containsKey(\"tagline\")) {\n+      theme.setTagline(obj.getString(\"tagline\", null));\n+    }\n+    if (obj.containsKey(\"textColor\")) {\n+      theme.setTextColor(obj.getString(\"textColor\", null));\n+    }\n+\n+    return theme;\n+  }\n+\n+  private static String getMandatoryString(JsonObject jobj, String name) throws JsonParseException {\n+    if (jobj.containsKey(name)) {\n+      return jobj.getString(name);\n+    }\n+    throw new JsonParseException(\"Field \" + name + \" is mandatory\");\n+  }\n+\n+  public IpGroup parseIpGroup(JsonObject obj) {\n+    IpGroup retVal = new IpGroup();\n+\n+    if (obj.containsKey(\"id\")) {\n+      retVal.setId(Long.valueOf(obj.getInt(\"id\")));\n+    }\n+    retVal.setDisplayName(obj.getString(\"name\", null));\n+    retVal.setDescription(obj.getString(\"description\", null));\n+    retVal.setPersistedGroupAlias(obj.getString(\"alias\", null));\n+\n+    if (obj.containsKey(\"ranges\")) {\n+      obj.getJsonArray(\"ranges\").stream()\n+        .filter(jv -> jv.getValueType() == JsonValue.ValueType.ARRAY)\n+        .map(jv -> (JsonArray) jv)\n+        .forEach(rr -> {\n+          retVal.add(\n+            IpAddressRange.make(IpAddress.valueOf(rr.getString(0)),\n+              IpAddress.valueOf(rr.getString(1))));\n+        });\n+    }\n+    if (obj.containsKey(\"addresses\")) {\n+      obj.getJsonArray(\"addresses\").stream()\n+        .map(jsVal -> IpAddress.valueOf(((JsonString) jsVal).getString()))\n+        .map(addr -> IpAddressRange.make(addr, addr))\n+        .forEach(retVal::add);\n+    }\n+\n+    return retVal;\n+  }\n+\n+  public MailDomainGroup parseMailDomainGroup(JsonObject obj) throws JsonParseException {\n+    MailDomainGroup grp = new MailDomainGroup();\n+\n+    if (obj.containsKey(\"id\")) {\n+      grp.setId(obj.getJsonNumber(\"id\").longValue());\n+    }\n+    grp.setDisplayName(getMandatoryString(obj, \"name\"));\n+    grp.setDescription(obj.getString(\"description\", null));\n+    grp.setPersistedGroupAlias(getMandatoryString(obj, \"alias\"));\n+    grp.setIsRegEx(obj.getBoolean(\"regex\", false));\n+    if (obj.containsKey(\"domains\")) {\n+      List<String> domains =\n+        Optional.ofNullable(obj.getJsonArray(\"domains\"))\n+          .orElse(Json.createArrayBuilder().build())\n+          .getValuesAs(JsonString.class)\n+          .stream()\n+          .map(JsonString::getString)\n+          // only validate if this group hasn't regex support enabled\n+          .filter(d -> (grp.isRegEx() || DomainValidator.getInstance().isValid(d)))\n+          .collect(Collectors.toList());\n+      if (domains.isEmpty()) {\n+        throw new JsonParseException(\n+          \"Field domains may not be an empty array or contain invalid domains. Enabled regex support?\");\n+      }\n+      grp.setEmailDomains(domains);\n+    } else {\n+      throw new JsonParseException(\"Field domains is mandatory.\");\n+    }\n+\n+    return grp;\n+  }\n+\n+  public DatasetVersion parseDatasetVersion(JsonObject obj) throws JsonParseException {\n+    return parseDatasetVersion(obj, new DatasetVersion());\n+  }\n+\n+  public Dataset parseDataset(JsonObject obj) throws JsonParseException {\n+    Dataset dataset = new Dataset();\n+\n+    dataset.setAuthority(\n+      obj.getString(\"authority\", null) == null ? settingsService.getValueForKey(SettingsServiceBean.Key.Authority) :\n+        obj.getString(\"authority\"));\n+    dataset.setProtocol(\n+      obj.getString(\"protocol\", null) == null ? settingsService.getValueForKey(SettingsServiceBean.Key.Protocol) :\n+        obj.getString(\"protocol\"));\n+    dataset.setIdentifier(obj.getString(\"identifier\", null));\n+\n+    DatasetVersion dsv = new DatasetVersion();\n+    dsv.setDataset(dataset);\n+    dsv = parseDatasetVersion(obj.getJsonObject(\"datasetVersion\"), dsv);\n+    List<DatasetVersion> versions = new ArrayList<>(1);\n+    versions.add(dsv);\n+\n+    dataset.setVersions(versions);\n+    return dataset;\n+  }\n+\n+  public DatasetVersion parseDatasetVersion(JsonObject obj, DatasetVersion dsv) throws JsonParseException {\n+    try {\n+\n+      String archiveNote = obj.getString(\"archiveNote\", null);\n+      if (archiveNote != null) {\n+        dsv.setArchiveNote(archiveNote);\n+      }\n+\n+      dsv.setDeaccessionLink(obj.getString(\"deaccessionLink\", null));\n+      int versionNumberInt = obj.getInt(\"versionNumber\", -1);\n+      Long versionNumber = null;\n+      if (versionNumberInt != -1) {\n+        versionNumber = new Long(versionNumberInt);\n+      }\n+      dsv.setVersionNumber(versionNumber);\n+      dsv.setMinorVersionNumber(parseLong(obj.getString(\"minorVersionNumber\", null)));\n+      // if the existing datasetversion doesn not have an id\n+      // use the id from the json object.\n+      if (dsv.getId() == null) {\n+        dsv.setId(parseLong(obj.getString(\"id\", null)));\n+      }\n+\n+      String versionStateStr = obj.getString(\"versionState\", null);\n+      if (versionStateStr != null) {\n+        dsv.setVersionState(DatasetVersion.VersionState.valueOf(versionStateStr));\n+      }\n+      dsv.setReleaseTime(parseDate(obj.getString(\"releaseDate\", null)));\n+      dsv.setLastUpdateTime(parseTime(obj.getString(\"lastUpdateTime\", null)));\n+      dsv.setCreateTime(parseTime(obj.getString(\"createTime\", null)));\n+      dsv.setArchiveTime(parseTime(obj.getString(\"archiveTime\", null)));\n+      dsv.setUNF(obj.getString(\"UNF\", null));\n+      // Terms of Use related fields\n+      TermsOfUseAndAccess terms = new TermsOfUseAndAccess();\n+      terms.setTermsOfUse(obj.getString(\"termsOfUse\", null));\n+      terms.setTermsOfAccess(obj.getString(\"termsOfAccess\", null));\n+      terms.setConfidentialityDeclaration(obj.getString(\"confidentialityDeclaration\", null));\n+      terms.setSpecialPermissions(obj.getString(\"specialPermissions\", null));\n+      terms.setRestrictions(obj.getString(\"restrictions\", null));\n+      terms.setCitationRequirements(obj.getString(\"citationRequirements\", null));\n+      terms.setDepositorRequirements(obj.getString(\"depositorRequirements\", null));\n+      terms.setConditions(obj.getString(\"conditions\", null));\n+      terms.setDisclaimer(obj.getString(\"disclaimer\", null));\n+      terms.setDataAccessPlace(obj.getString(\"dataAccessPlace\", null));\n+      terms.setOriginalArchive(obj.getString(\"originalArchive\", null));\n+      terms.setAvailabilityStatus(obj.getString(\"availabilityStatus\", null));\n+      terms.setContactForAccess(obj.getString(\"contactForAccess\", null));\n+      terms.setSizeOfCollection(obj.getString(\"sizeOfCollection\", null));\n+      terms.setStudyCompletion(obj.getString(\"studyCompletion\", null));\n+      terms.setLicense(parseLicense(obj.getString(\"license\", null)));\n+      terms.setFileAccessRequest(obj.getBoolean(\"fileAccessRequest\", false));\n+      dsv.setTermsOfUseAndAccess(terms);\n+\n+      dsv.setDatasetFields(parseMetadataBlocks(obj.getJsonObject(\"metadataBlocks\")));\n+\n+      JsonArray filesJson = obj.getJsonArray(\"files\");\n+      if (filesJson == null) {\n+        filesJson = obj.getJsonArray(\"fileMetadatas\");\n+      }\n+      if (filesJson != null) {\n+        dsv.setFileMetadatas(parseFiles(filesJson, dsv));\n+      }\n+      return dsv;\n+\n+    } catch (ParseException ex) {\n+      throw new JsonParseException(\"Error parsing date:\" + ex.getMessage(), ex);\n+    } catch (NumberFormatException ex) {\n+      throw new JsonParseException(\"Error parsing number:\" + ex.getMessage(), ex);\n+    }\n+  }\n+\n+  private License parseLicense(String inString) {\n+    if (inString != null && inString.equalsIgnoreCase(\"CC0\")) {\n+      return TermsOfUseAndAccess.License.CC0;\n+    }\n+    return TermsOfUseAndAccess.License.NONE;\n+  }\n+\n+  public List<DatasetField> parseMetadataBlocks(JsonObject json) throws JsonParseException {\n+    Set<String> keys = json.keySet();\n+    List<DatasetField> fields = new LinkedList<>();\n+\n+    for (String blockName : keys) {\n+      JsonObject blockJson = json.getJsonObject(blockName);\n+      JsonArray fieldsJson = blockJson.getJsonArray(\"fields\");\n+      fields.addAll(parseFieldsFromArray(fieldsJson, true));\n+    }\n+    return fields;\n+  }\n+\n+  public List<DatasetField> parseMultipleFields(JsonObject json) throws JsonParseException {\n+    JsonArray fieldsJson = json.getJsonArray(\"fields\");\n+    List<DatasetField> fields = parseFieldsFromArray(fieldsJson, false);\n+    return fields;\n+  }\n+\n+  public List<DatasetField> parseMultipleFieldsForDelete(JsonObject json) throws JsonParseException {\n+    List<DatasetField> fields = new LinkedList<>();\n+    for (JsonObject fieldJson : json.getJsonArray(\"fields\").getValuesAs(JsonObject.class)) {\n+      fields.add(parseFieldForDelete(fieldJson));\n+    }\n+    return fields;\n+  }\n+\n+  private List<DatasetField> parseFieldsFromArray(JsonArray fieldsArray, Boolean testType) throws JsonParseException {\n+    List<DatasetField> fields = new LinkedList<>();\n+    for (JsonObject fieldJson : fieldsArray.getValuesAs(JsonObject.class)) {\n+      try {\n+        DatasetField field = parseField(fieldJson, testType);\n+        if (field != null) {\n+          fields.add(field);\n+        }\n+      } catch (CompoundVocabularyException ex) {\n+        DatasetFieldType fieldType = datasetFieldSvc.findByNameOpt(fieldJson.getString(\"typeName\", \"\"));\n+        if (lenient && (DatasetFieldConstant.geographicCoverage).equals(fieldType.getName())) {\n+          fields.add(remapGeographicCoverage(ex));\n         } else {\n-            throw new JsonParseException(\"Field domains is mandatory.\");\n-        }\n-        \n-        return grp;\n-    }\n-\n-    public DatasetVersion parseDatasetVersion(JsonObject obj) throws JsonParseException {\n-        return parseDatasetVersion(obj, new DatasetVersion());\n-    }\n-\n-    public Dataset parseDataset(JsonObject obj) throws JsonParseException {\n-        Dataset dataset = new Dataset();\n-\n-        dataset.setAuthority(obj.getString(\"authority\", null) == null ? settingsService.getValueForKey(SettingsServiceBean.Key.Authority) : obj.getString(\"authority\"));\n-        dataset.setProtocol(obj.getString(\"protocol\", null) == null ? settingsService.getValueForKey(SettingsServiceBean.Key.Protocol) : obj.getString(\"protocol\"));\n-        dataset.setIdentifier(obj.getString(\"identifier\",null));\n-\n-        DatasetVersion dsv = new DatasetVersion(); \n-        dsv.setDataset(dataset);\n-        dsv = parseDatasetVersion(obj.getJsonObject(\"datasetVersion\"), dsv);\n-        List<DatasetVersion> versions = new ArrayList<>(1);\n-        versions.add(dsv);\n-\n-        dataset.setVersions(versions);\n-        return dataset;\n-    }\n-\n-    public DatasetVersion parseDatasetVersion(JsonObject obj, DatasetVersion dsv) throws JsonParseException {\n-        try {\n-\n-            String archiveNote = obj.getString(\"archiveNote\", null);\n-            if (archiveNote != null) {\n-                dsv.setArchiveNote(archiveNote);\n+          // if not lenient mode, re-throw exception\n+          throw ex;\n+        }\n+      }\n+\n+    }\n+    return fields;\n+\n+  }\n+\n+  public List<FileMetadata> parseFiles(JsonArray metadatasJson, DatasetVersion dsv) throws JsonParseException {\n+    List<FileMetadata> fileMetadatas = new LinkedList<>();\n+    if (metadatasJson != null) {\n+      for (JsonObject filemetadataJson : metadatasJson.getValuesAs(JsonObject.class)) {\n+        String label = filemetadataJson.getString(\"label\");\n+        String directoryLabel = filemetadataJson.getString(\"directoryLabel\", null);\n+        String description = filemetadataJson.getString(\"description\", null);\n+\n+        FileMetadata fileMetadata = new FileMetadata();\n+        fileMetadata.setLabel(label);\n+        fileMetadata.setDirectoryLabel(directoryLabel);\n+        fileMetadata.setDescription(description);\n+        fileMetadata.setDatasetVersion(dsv);\n+\n+        if (filemetadataJson.containsKey(\"dataFile\")) {\n+          DataFile dataFile = parseDataFile(filemetadataJson.getJsonObject(\"dataFile\"));\n+          dataFile.getFileMetadatas().add(fileMetadata);\n+          dataFile.setOwner(dsv.getDataset());\n+          fileMetadata.setDataFile(dataFile);\n+          if (dsv.getDataset() != null) {\n+            if (dsv.getDataset().getFiles() == null) {\n+              dsv.getDataset().setFiles(new ArrayList<>());\n             }\n+            dsv.getDataset().getFiles().add(dataFile);\n+          }\n+        }\n+\n+        fileMetadatas.add(fileMetadata);\n+        fileMetadata.setCategories(getCategories(filemetadataJson, dsv.getDataset()));\n+      }\n+    }\n+\n+    return fileMetadatas;\n+  }\n+\n+  public DataFile parseDataFile(JsonObject datafileJson) {\n+    DataFile dataFile = new DataFile();\n+\n+    Timestamp timestamp = new Timestamp(new Date().getTime());\n+    dataFile.setCreateDate(timestamp);\n+    dataFile.setModificationTime(timestamp);\n+    dataFile.setPermissionModificationTime(timestamp);\n+\n+    if (datafileJson.containsKey(\"filesize\")) {\n+      dataFile.setFilesize(datafileJson.getJsonNumber(\"filesize\").longValueExact());\n+    }\n+\n+    String contentType = datafileJson.getString(\"contentType\", null);\n+    if (contentType == null) {\n+      contentType = \"application/octet-stream\";\n+    }\n+    String storageIdentifier = datafileJson.getString(\"storageIdentifier\", \" \");\n+    JsonObject checksum = datafileJson.getJsonObject(\"checksum\");\n+    if (checksum != null) {\n+      // newer style that allows for SHA-1 rather than MD5\n+      /**\n+       * @todo Add more error checking. Do we really expect people to set\n+       * file metadata without uploading files? Some day we'd like to work\n+       * on a \"native\" API that allows for multipart upload of the JSON\n+       * describing the files (this \"parseDataFile\" method) and the bits\n+       * of the files themselves. See\n+       * https://github.com/IQSS/dataverse/issues/1612\n+       */\n+      String type = checksum.getString(\"type\");\n+      if (type != null) {\n+        String value = checksum.getString(\"value\");\n+        if (value != null) {\n+          try {\n+            dataFile.setChecksumType(DataFile.ChecksumType.fromString(type));\n+            dataFile.setChecksumValue(value);\n+          } catch (IllegalArgumentException ex) {\n+            logger.info(\"Invalid\");\n+          }\n+        }\n+      }\n+    } else {\n+      // older, MD5 logic, still her for backward compatibility\n+      String md5 = datafileJson.getString(\"md5\", null);\n+      if (md5 == null) {\n+        md5 = \"unknown\";\n+      }\n+      dataFile.setChecksumType(DataFile.ChecksumType.MD5);\n+      dataFile.setChecksumValue(md5);\n+    }\n+\n+    // TODO:\n+    // unf (if available)... etc.?\n+\n+    dataFile.setContentType(contentType);\n+    dataFile.setStorageIdentifier(storageIdentifier);\n+\n+    return dataFile;\n+  }\n+\n+  /**\n+   * Special processing for GeographicCoverage compound field:\n+   * Handle parsing exceptions caused by invalid controlled vocabulary in the \"country\" field by\n+   * putting the invalid data in \"otherGeographicCoverage\" in a new compound value.\n+   *\n+   * @param ex - contains the invalid values to be processed\n+   * @return a compound DatasetField that contains the newly created values, in addition to\n+   * the original valid values.\n+   * @throws JsonParseException\n+   */\n+  private DatasetField remapGeographicCoverage(CompoundVocabularyException ex) throws JsonParseException {\n+    List<HashSet<FieldDTO>> geoCoverageList = new ArrayList<>();\n+    // For each exception, create HashSet of otherGeographic Coverage and add to list\n+    for (ControlledVocabularyException vocabEx : ex.getExList()) {\n+      HashSet<FieldDTO> set = new HashSet<>();\n+      set.add(FieldDTO.createPrimitiveFieldDTO(DatasetFieldConstant.otherGeographicCoverage, vocabEx.getStrValue()));\n+      geoCoverageList.add(set);\n+    }\n+    FieldDTO geoCoverageDTO =\n+      FieldDTO.createMultipleCompoundFieldDTO(DatasetFieldConstant.geographicCoverage, geoCoverageList);\n+\n+    // convert DTO to datasetField so we can back valid values.\n+    Gson gson = new Gson();\n+    String jsonString = gson.toJson(geoCoverageDTO);\n+    JsonReader jsonReader = Json.createReader(new StringReader(jsonString));\n+    JsonObject obj = jsonReader.readObject();\n+    DatasetField geoCoverageField = parseField(obj);\n+\n+    // add back valid values\n+    for (DatasetFieldCompoundValue dsfcv : ex.getValidValues()) {\n+      if (!dsfcv.getChildDatasetFields().isEmpty()) {\n+        dsfcv.setParentDatasetField(geoCoverageField);\n+        geoCoverageField.getDatasetFieldCompoundValues().add(dsfcv);\n+      }\n+    }\n+    return geoCoverageField;\n+  }\n+\n+\n+  public DatasetField parseFieldForDelete(JsonObject json) throws JsonParseException {\n+    DatasetField ret = new DatasetField();\n+    DatasetFieldType type = datasetFieldSvc.findByNameOpt(json.getString(\"typeName\", \"\"));\n+    if (type == null) {\n+      throw new JsonParseException(\"Can't find type '\" + json.getString(\"typeName\", \"\") + \"'\");\n+    }\n+    return ret;\n+  }\n+\n+\n+  public DatasetField parseField(JsonObject json) throws JsonParseException {\n+    return parseField(json, true);\n+  }\n+\n+\n+  public DatasetField parseField(JsonObject json, Boolean testType) throws JsonParseException {\n+    if (json == null) {\n+      return null;\n+    }\n+\n+    DatasetField ret = new DatasetField();\n+    DatasetFieldType type = datasetFieldSvc.findByNameOpt(json.getString(\"typeName\", \"\"));\n+\n+\n+    if (type == null) {\n+      logger.fine(\"Can't find type '\" + json.getString(\"typeName\", \"\") + \"'\");\n+      return null;\n+    }\n+    if (testType && type.isAllowMultiples() != json.getBoolean(\"multiple\")) {\n+      throw new JsonParseException(\"incorrect multiple   for field \" + json.getString(\"typeName\", \"\"));\n+    }\n+    if (testType && type.isCompound() && !json.getString(\"typeClass\").equals(\"compound\")) {\n+      throw new JsonParseException(\n+        \"incorrect  typeClass for field \" + json.getString(\"typeName\", \"\") + \", should be compound.\");\n+    }\n+    if (testType && !type.isControlledVocabulary() && type.isPrimitive() &&\n+      !json.getString(\"typeClass\").equals(\"primitive\")) {\n+      throw new JsonParseException(\n+        \"incorrect  typeClass for field: \" + json.getString(\"typeName\", \"\") + \", should be primitive\");\n+    }\n+    if (testType && type.isControlledVocabulary() && !json.getString(\"typeClass\").equals(\"controlledVocabulary\")) {\n+      throw new JsonParseException(\n+        \"incorrect  typeClass for field \" + json.getString(\"typeName\", \"\") + \", should be controlledVocabulary\");\n+    }\n+\n+    ret.setDatasetFieldType(type);\n+\n+    if (type.isCompound()) {\n+      List<DatasetFieldCompoundValue> vals = parseCompoundValue(type, json, testType);\n+      for (DatasetFieldCompoundValue dsfcv : vals) {\n+        dsfcv.setParentDatasetField(ret);\n+      }\n+      ret.setDatasetFieldCompoundValues(vals);\n+\n+    } else if (type.isControlledVocabulary()) {\n+      List<ControlledVocabularyValue> vals = parseControlledVocabularyValue(type, json);\n+      for (ControlledVocabularyValue cvv : vals) {\n+        cvv.setDatasetFieldType(type);\n+      }\n+      ret.setControlledVocabularyValues(vals);\n+\n+    } else {\n+      // primitive\n+      List<DatasetFieldValue> values = parsePrimitiveValue(type, json);\n+      for (DatasetFieldValue val : values) {\n+        val.setDatasetField(ret);\n+      }\n+      ret.setDatasetFieldValues(values);\n+    }\n+\n+    return ret;\n+  }\n+\n+  public List<DatasetFieldCompoundValue> parseCompoundValue(DatasetFieldType compoundType, JsonObject json)\n+    throws JsonParseException {\n+    return parseCompoundValue(compoundType, json, true);\n+  }\n \n-            dsv.setDeaccessionLink(obj.getString(\"deaccessionLink\", null));\n-            int versionNumberInt = obj.getInt(\"versionNumber\", -1);\n-            Long versionNumber = null;\n-            if (versionNumberInt !=-1) {\n-                versionNumber = new Long(versionNumberInt);\n-            }\n-            dsv.setVersionNumber(versionNumber);\n-            dsv.setMinorVersionNumber(parseLong(obj.getString(\"minorVersionNumber\", null)));\n-            // if the existing datasetversion doesn not have an id\n-            // use the id from the json object.\n-            if (dsv.getId()==null) {\n-                 dsv.setId(parseLong(obj.getString(\"id\", null)));\n-            }\n-           \n-            String versionStateStr = obj.getString(\"versionState\", null);\n-            if (versionStateStr != null) {\n-                dsv.setVersionState(DatasetVersion.VersionState.valueOf(versionStateStr));\n-            }\n-            dsv.setReleaseTime(parseDate(obj.getString(\"releaseDate\", null)));\n-            dsv.setLastUpdateTime(parseTime(obj.getString(\"lastUpdateTime\", null)));\n-            dsv.setCreateTime(parseTime(obj.getString(\"createTime\", null)));\n-            dsv.setArchiveTime(parseTime(obj.getString(\"archiveTime\", null)));\n-            dsv.setUNF(obj.getString(\"UNF\", null));\n-            // Terms of Use related fields\n-            TermsOfUseAndAccess terms = new TermsOfUseAndAccess();\n-            terms.setTermsOfUse(obj.getString(\"termsOfUse\", null));           \n-            terms.setTermsOfAccess(obj.getString(\"termsOfAccess\", null));\n-            terms.setConfidentialityDeclaration(obj.getString(\"confidentialityDeclaration\", null));\n-            terms.setSpecialPermissions(obj.getString(\"specialPermissions\", null));\n-            terms.setRestrictions(obj.getString(\"restrictions\", null));\n-            terms.setCitationRequirements(obj.getString(\"citationRequirements\", null));\n-            terms.setDepositorRequirements(obj.getString(\"depositorRequirements\", null));\n-            terms.setConditions(obj.getString(\"conditions\", null));\n-            terms.setDisclaimer(obj.getString(\"disclaimer\", null));\n-            terms.setDataAccessPlace(obj.getString(\"dataAccessPlace\", null));\n-            terms.setOriginalArchive(obj.getString(\"originalArchive\", null));\n-            terms.setAvailabilityStatus(obj.getString(\"availabilityStatus\", null));\n-            terms.setContactForAccess(obj.getString(\"contactForAccess\", null));\n-            terms.setSizeOfCollection(obj.getString(\"sizeOfCollection\", null));\n-            terms.setStudyCompletion(obj.getString(\"studyCompletion\", null));\n-            terms.setLicense(parseLicense(obj.getString(\"license\", null)));\n-            terms.setFileAccessRequest(obj.getBoolean(\"fileAccessRequest\", false));\n-            dsv.setTermsOfUseAndAccess(terms);\n-            \n-            dsv.setDatasetFields(parseMetadataBlocks(obj.getJsonObject(\"metadataBlocks\")));\n-\n-            JsonArray filesJson = obj.getJsonArray(\"files\");\n-            if (filesJson == null) {\n-                filesJson = obj.getJsonArray(\"fileMetadatas\");\n-            }\n-            if (filesJson != null) {\n-                dsv.setFileMetadatas(parseFiles(filesJson, dsv));\n-            }\n-            return dsv;\n-\n-        } catch (ParseException ex) {\n-            throw new JsonParseException(\"Error parsing date:\" + ex.getMessage(), ex);\n-        } catch (NumberFormatException ex) {\n-            throw new JsonParseException(\"Error parsing number:\" + ex.getMessage(), ex);\n-        }\n-    }\n-    \n-    private License parseLicense(String inString) {\n-        if (inString != null && inString.equalsIgnoreCase(\"CC0\")) {\n-            return TermsOfUseAndAccess.License.CC0;\n-        }\n-        return TermsOfUseAndAccess.License.NONE;       \n-    }\n-\n-    public List<DatasetField> parseMetadataBlocks(JsonObject json) throws JsonParseException {\n-        Set<String> keys = json.keySet();\n+  public List<DatasetFieldCompoundValue> parseCompoundValue(DatasetFieldType compoundType, JsonObject json,\n+                                                            Boolean testType) throws JsonParseException {\n+    List<ControlledVocabularyException> vocabExceptions = new ArrayList<>();\n+    List<DatasetFieldCompoundValue> vals = new LinkedList<>();\n+    if (compoundType.isAllowMultiples()) {\n+      int order = 0;\n+      try {\n+        json.getJsonArray(\"value\").getValuesAs(JsonObject.class);\n+      } catch (ClassCastException cce) {\n+        throw new JsonParseException(\n+          \"Invalid values submitted for \" + compoundType.getName() + \". It should be an array of values.\");\n+      }\n+      for (JsonObject obj : json.getJsonArray(\"value\").getValuesAs(JsonObject.class)) {\n+        DatasetFieldCompoundValue cv = new DatasetFieldCompoundValue();\n         List<DatasetField> fields = new LinkedList<>();\n-\n-        for (String blockName : keys) {\n-            JsonObject blockJson = json.getJsonObject(blockName);\n-            JsonArray fieldsJson = blockJson.getJsonArray(\"fields\");\n-            fields.addAll(parseFieldsFromArray(fieldsJson, true));\n-        }\n-        return fields;\n-    }\n-    \n-    public List<DatasetField> parseMultipleFields(JsonObject json) throws JsonParseException {\n-        JsonArray fieldsJson = json.getJsonArray(\"fields\");\n-        List<DatasetField> fields = parseFieldsFromArray(fieldsJson, false);\n-        return fields;\n-    }\n-    \n-    public List<DatasetField> parseMultipleFieldsForDelete(JsonObject json) throws JsonParseException {\n-        List<DatasetField> fields = new LinkedList<>();\n-        for (JsonObject fieldJson : json.getJsonArray(\"fields\").getValuesAs(JsonObject.class)) {\n-            fields.add(parseFieldForDelete(fieldJson));\n-        }\n-        return fields;\n-    }\n-    \n-    private List<DatasetField> parseFieldsFromArray(JsonArray fieldsArray, Boolean testType) throws JsonParseException {\n-            List<DatasetField> fields = new LinkedList<>();\n-            for (JsonObject fieldJson : fieldsArray.getValuesAs(JsonObject.class)) {\n-                try {\n-                    DatasetField field = parseField(fieldJson, testType);\n-                    if (field != null) {\n-                        fields.add(field);\n-                    }\n-                } catch (CompoundVocabularyException ex) {\n-                    DatasetFieldType fieldType = datasetFieldSvc.findByNameOpt(fieldJson.getString(\"typeName\", \"\"));\n-                    if (lenient && (DatasetFieldConstant.geographicCoverage).equals(fieldType.getName())) {\n-                        fields.add(remapGeographicCoverage( ex));                       \n-                    } else {\n-                        // if not lenient mode, re-throw exception\n-                        throw ex;\n-                    }\n-                } \n-\n-            }\n-        return fields;\n-        \n-    }\n-    \n-    public List<FileMetadata> parseFiles(JsonArray metadatasJson, DatasetVersion dsv) throws JsonParseException {\n-        List<FileMetadata> fileMetadatas = new LinkedList<>();\n-        if (metadatasJson != null) {\n-            for (JsonObject filemetadataJson : metadatasJson.getValuesAs(JsonObject.class)) {\n-                String label = filemetadataJson.getString(\"label\");\n-                String directoryLabel = filemetadataJson.getString(\"directoryLabel\", null);\n-                String description = filemetadataJson.getString(\"description\", null);\n-\n-                FileMetadata fileMetadata = new FileMetadata();\n-                fileMetadata.setLabel(label);\n-                fileMetadata.setDirectoryLabel(directoryLabel);\n-                fileMetadata.setDescription(description);\n-                fileMetadata.setDatasetVersion(dsv);\n-                \n-                if ( filemetadataJson.containsKey(\"dataFile\") ) {\n-                    DataFile dataFile = parseDataFile(filemetadataJson.getJsonObject(\"dataFile\"));\n-                    dataFile.getFileMetadatas().add(fileMetadata);\n-                    dataFile.setOwner(dsv.getDataset());\n-                    fileMetadata.setDataFile(dataFile);\n-                    if (dsv.getDataset() != null) {\n-                        if (dsv.getDataset().getFiles() == null) {\n-                            dsv.getDataset().setFiles(new ArrayList<>());\n-                        }\n-                        dsv.getDataset().getFiles().add(dataFile);\n-                    }\n-                }\n-                \n-                fileMetadatas.add(fileMetadata);\n-                fileMetadata.setCategories(getCategories(filemetadataJson, dsv.getDataset()));\n+        for (String fieldName : obj.keySet()) {\n+          JsonObject childFieldJson = obj.getJsonObject(fieldName);\n+          DatasetField f = null;\n+          try {\n+            f = parseField(childFieldJson, testType);\n+          } catch (ControlledVocabularyException ex) {\n+            vocabExceptions.add(ex);\n+          }\n+\n+          if (f != null) {\n+            if (!compoundType.getChildDatasetFieldTypes().contains(f.getDatasetFieldType())) {\n+              throw new JsonParseException(\n+                \"field \" + f.getDatasetFieldType().getName() + \" is not a child of \" + compoundType.getName());\n             }\n+            f.setParentDatasetFieldCompoundValue(cv);\n+            fields.add(f);\n+          }\n         }\n-\n-        return fileMetadatas;\n-    }\n-    \n-    public DataFile parseDataFile(JsonObject datafileJson) {\n-        DataFile dataFile = new DataFile();\n-        \n-        Timestamp timestamp = new Timestamp(new Date().getTime());\n-        dataFile.setCreateDate(timestamp);\n-        dataFile.setModificationTime(timestamp);\n-        dataFile.setPermissionModificationTime(timestamp);\n-        \n-        if ( datafileJson.containsKey(\"filesize\") ) {\n-            dataFile.setFilesize(datafileJson.getJsonNumber(\"filesize\").longValueExact());\n+        if (!fields.isEmpty()) {\n+          cv.setChildDatasetFields(fields);\n+          cv.setDisplayOrder(order);\n+          vals.add(cv);\n         }\n-        \n-        String contentType = datafileJson.getString(\"contentType\", null);\n-        if (contentType == null) {\n-            contentType = \"application/octet-stream\";\n-        }\n-        String storageIdentifier = datafileJson.getString(\"storageIdentifier\", \" \");\n-        JsonObject checksum = datafileJson.getJsonObject(\"checksum\");\n-        if (checksum != null) {\n-            // newer style that allows for SHA-1 rather than MD5\n-            /**\n-             * @todo Add more error checking. Do we really expect people to set\n-             * file metadata without uploading files? Some day we'd like to work\n-             * on a \"native\" API that allows for multipart upload of the JSON\n-             * describing the files (this \"parseDataFile\" method) and the bits\n-             * of the files themselves. See\n-             * https://github.com/IQSS/dataverse/issues/1612\n-             */\n-            String type = checksum.getString(\"type\");\n-            if (type != null) {\n-                String value = checksum.getString(\"value\");\n-                if (value != null) {\n-                    try {\n-                        dataFile.setChecksumType(DataFile.ChecksumType.fromString(type));\n-                        dataFile.setChecksumValue(value);\n-                    } catch (IllegalArgumentException ex) {\n-                        logger.info(\"Invalid\");\n-                    }\n-                }\n-            }\n-        } else {\n-            // older, MD5 logic, still her for backward compatibility\n-            String md5 = datafileJson.getString(\"md5\", null);\n-            if (md5 == null) {\n-                md5 = \"unknown\";\n-            }\n-            dataFile.setChecksumType(DataFile.ChecksumType.MD5);\n-            dataFile.setChecksumValue(md5);\n-        }\n-\n-        // TODO: \n-        // unf (if available)... etc.?\n-        \n-        dataFile.setContentType(contentType);\n-        dataFile.setStorageIdentifier(storageIdentifier);\n-        \n-        return dataFile;\n-    }\n-    /**\n-     * Special processing for GeographicCoverage compound field:\n-     * Handle parsing exceptions caused by invalid controlled vocabulary in the \"country\" field by\n-     * putting the invalid data in \"otherGeographicCoverage\" in a new compound value.\n-     * \n-     * @param ex - contains the invalid values to be processed\n-     * @return a compound DatasetField that contains the newly created values, in addition to \n-     * the original valid values.\n-     * @throws JsonParseException \n-     */\n-    private DatasetField remapGeographicCoverage(CompoundVocabularyException ex) throws JsonParseException{\n-        List<HashSet<FieldDTO>> geoCoverageList = new ArrayList<>();\n-        // For each exception, create HashSet of otherGeographic Coverage and add to list\n-        for (ControlledVocabularyException vocabEx : ex.getExList()) {\n-            HashSet<FieldDTO> set = new HashSet<>();\n-            set.add(FieldDTO.createPrimitiveFieldDTO(DatasetFieldConstant.otherGeographicCoverage, vocabEx.getStrValue()));\n-            geoCoverageList.add(set);\n-        }\n-        FieldDTO geoCoverageDTO = FieldDTO.createMultipleCompoundFieldDTO(DatasetFieldConstant.geographicCoverage, geoCoverageList);\n-\n-        // convert DTO to datasetField so we can back valid values.\n-        Gson gson = new Gson();\n-        String jsonString = gson.toJson(geoCoverageDTO);\n-        JsonReader jsonReader = Json.createReader(new StringReader(jsonString));\n-        JsonObject obj = jsonReader.readObject();\n-        DatasetField geoCoverageField = parseField(obj);\n-\n-        // add back valid values\n-        for (DatasetFieldCompoundValue dsfcv : ex.getValidValues()) {\n-            if (!dsfcv.getChildDatasetFields().isEmpty()) {\n-                dsfcv.setParentDatasetField(geoCoverageField);\n-                geoCoverageField.getDatasetFieldCompoundValues().add(dsfcv);\n-            }\n-        }\n-        return geoCoverageField;\n-    }\n-    \n-    \n-    public DatasetField parseFieldForDelete(JsonObject json) throws JsonParseException{\n-        DatasetField ret = new DatasetField();\n-        DatasetFieldType type = datasetFieldSvc.findByNameOpt(json.getString(\"typeName\", \"\"));   \n-        if (type == null) {\n-            throw new JsonParseException(\"Can't find type '\" + json.getString(\"typeName\", \"\") + \"'\");\n-        }\n-        return ret;\n-    }\n-     \n-    \n-    public DatasetField parseField(JsonObject json) throws JsonParseException{\n-        return parseField(json, true);\n-    }\n-    \n-    \n-    public DatasetField parseField(JsonObject json, Boolean testType) throws JsonParseException {\n-        if (json == null) {\n-            return null;\n-        }\n-\n-        DatasetField ret = new DatasetField();\n-        DatasetFieldType type = datasetFieldSvc.findByNameOpt(json.getString(\"typeName\", \"\"));\n-    \n+        order++;\n+      }\n \n-        if (type == null) {\n-            logger.fine(\"Can't find type '\" + json.getString(\"typeName\", \"\") + \"'\");\n-            return null;\n-        }\n-        if (testType && type.isAllowMultiples() != json.getBoolean(\"multiple\")) {\n-            throw new JsonParseException(\"incorrect multiple   for field \" + json.getString(\"typeName\", \"\"));\n-        }\n-        if (testType && type.isCompound() && !json.getString(\"typeClass\").equals(\"compound\")) {\n-            throw new JsonParseException(\"incorrect  typeClass for field \" + json.getString(\"typeName\", \"\") + \", should be compound.\");\n-        }\n-        if (testType && !type.isControlledVocabulary() && type.isPrimitive() && !json.getString(\"typeClass\").equals(\"primitive\")) {\n-            throw new JsonParseException(\"incorrect  typeClass for field: \" + json.getString(\"typeName\", \"\") + \", should be primitive\");\n-        }\n-        if (testType && type.isControlledVocabulary() && !json.getString(\"typeClass\").equals(\"controlledVocabulary\")) {\n-            throw new JsonParseException(\"incorrect  typeClass for field \" + json.getString(\"typeName\", \"\") + \", should be controlledVocabulary\");\n-        }\n-       \n-        ret.setDatasetFieldType(type);\n-               \n-        if (type.isCompound()) {\n-            List<DatasetFieldCompoundValue> vals = parseCompoundValue(type, json, testType);\n-            for (DatasetFieldCompoundValue dsfcv : vals) {\n-                dsfcv.setParentDatasetField(ret);\n-            }\n-            ret.setDatasetFieldCompoundValues(vals);\n \n-        } else if (type.isControlledVocabulary()) {\n-            List<ControlledVocabularyValue> vals = parseControlledVocabularyValue(type, json);\n-            for (ControlledVocabularyValue cvv : vals) {\n-                cvv.setDatasetFieldType(type);\n-            }\n-            ret.setControlledVocabularyValues(vals);\n+    } else {\n \n-        } else {\n-            // primitive\n-                List<DatasetFieldValue> values = parsePrimitiveValue(type, json);\n-                for (DatasetFieldValue val : values) {\n-                    val.setDatasetField(ret);\n-                }\n-                ret.setDatasetFieldValues(values);\n-            }\n-\n-        return ret;\n-    }\n-    \n-     public List<DatasetFieldCompoundValue> parseCompoundValue(DatasetFieldType compoundType, JsonObject json) throws JsonParseException {\n-         return parseCompoundValue(compoundType, json, true);\n-     }\n-    \n-    public List<DatasetFieldCompoundValue> parseCompoundValue(DatasetFieldType compoundType, JsonObject json, Boolean testType) throws JsonParseException {\n-        List<ControlledVocabularyException> vocabExceptions = new ArrayList<>();\n-        List<DatasetFieldCompoundValue> vals = new LinkedList<>();\n-        if (compoundType.isAllowMultiples()) {\n-            int order = 0;\n-            try {\n-                json.getJsonArray(\"value\").getValuesAs(JsonObject.class);\n-            } catch (ClassCastException cce) {\n-                throw new JsonParseException(\"Invalid values submitted for \" + compoundType.getName() + \". It should be an array of values.\");\n-            }\n-            for (JsonObject obj : json.getJsonArray(\"value\").getValuesAs(JsonObject.class)) {\n-                DatasetFieldCompoundValue cv = new DatasetFieldCompoundValue();\n-                List<DatasetField> fields = new LinkedList<>();\n-                for (String fieldName : obj.keySet()) {\n-                    JsonObject childFieldJson = obj.getJsonObject(fieldName);\n-                    DatasetField f=null;\n-                    try {\n-                        f = parseField(childFieldJson, testType);\n-                    } catch(ControlledVocabularyException ex) {\n-                        vocabExceptions.add(ex);\n-                    }\n-                    \n-                    if (f!=null) {\n-                        if (!compoundType.getChildDatasetFieldTypes().contains(f.getDatasetFieldType())) {\n-                            throw new JsonParseException(\"field \" + f.getDatasetFieldType().getName() + \" is not a child of \" + compoundType.getName());\n-                        }\n-                        f.setParentDatasetFieldCompoundValue(cv);\n-                            fields.add(f);\n-                    }\n-                }\n-                if (!fields.isEmpty()) {\n-                    cv.setChildDatasetFields(fields);\n-                    cv.setDisplayOrder(order);\n-                    vals.add(cv);\n-                }\n-                order++;\n-            }\n-\n-           \n-\n-        } else {\n-            \n-            DatasetFieldCompoundValue cv = new DatasetFieldCompoundValue();\n-            List<DatasetField> fields = new LinkedList<>();\n-            JsonObject value = json.getJsonObject(\"value\");\n-            for (String key : value.keySet()) {\n-                JsonObject childFieldJson = value.getJsonObject(key);\n-                DatasetField f = null;\n-                try {\n-                    f=parseField(childFieldJson, testType);\n-                } catch(ControlledVocabularyException ex ) {\n-                    vocabExceptions.add(ex);\n-                }\n-                if (f!=null) {\n-                    f.setParentDatasetFieldCompoundValue(cv);\n-                    fields.add(f);\n-                }\n-            }\n-            if (!fields.isEmpty()) {\n-                cv.setChildDatasetFields(fields);\n-                vals.add(cv);\n-            }\n-      \n-    }\n-        if (!vocabExceptions.isEmpty()) {\n-            throw new CompoundVocabularyException( \"Invalid controlled vocabulary in compound field \", vocabExceptions, vals);\n-        }\n-          return vals;\n-    }\n-\n-    public List<DatasetFieldValue> parsePrimitiveValue(DatasetFieldType dft , JsonObject json) throws JsonParseException {\n-\n-        List<DatasetFieldValue> vals = new LinkedList<>();\n-        if (dft.isAllowMultiples()) {\n-           try {\n-            json.getJsonArray(\"value\").getValuesAs(JsonObject.class);\n-            } catch (ClassCastException cce) {\n-                throw new JsonParseException(\"Invalid values submitted for \" + dft.getName() + \". It should be an array of values.\");\n-            }\n-            for (JsonString val : json.getJsonArray(\"value\").getValuesAs(JsonString.class)) {\n-                DatasetFieldValue datasetFieldValue = new DatasetFieldValue();\n-                datasetFieldValue.setDisplayOrder(vals.size() - 1);\n-                datasetFieldValue.setValue(val.getString().trim());\n-                vals.add(datasetFieldValue);\n-            }\n-\n-        } else {\n-            try {json.getString(\"value\");}\n-            catch (ClassCastException cce) {\n-                throw new JsonParseException(\"Invalid value submitted for \" + dft.getName() + \". It should be a single value.\");\n-            }            \n-            DatasetFieldValue datasetFieldValue = new DatasetFieldValue();\n-            datasetFieldValue.setValue(json.getString(\"value\", \"\").trim());\n-            vals.add(datasetFieldValue);\n-        }\n-\n-        return vals;\n-    }\n-    \n-    public Workflow parseWorkflow(JsonObject json) throws JsonParseException {\n-        Workflow retVal = new Workflow();\n-        validate(\"\", json, \"name\", ValueType.STRING);\n-        validate(\"\", json, \"steps\", ValueType.ARRAY);\n-        retVal.setName( json.getString(\"name\") );\n-        JsonArray stepArray = json.getJsonArray(\"steps\");\n-        List<WorkflowStepData> steps = new ArrayList<>(stepArray.size());\n-        for ( JsonValue jv : stepArray ) {\n-            steps.add(parseStepData((JsonObject) jv));\n-        }\n-        retVal.setSteps(steps);\n-        return retVal;\n-    }\n-    \n-    public WorkflowStepData parseStepData( JsonObject json ) throws JsonParseException {\n-        WorkflowStepData wsd = new WorkflowStepData();\n-        validate(\"step\", json, \"provider\", ValueType.STRING);\n-        validate(\"step\", json, \"stepType\", ValueType.STRING);\n-        \n-        wsd.setProviderId(json.getString(\"provider\"));\n-        wsd.setStepType(json.getString(\"stepType\"));\n-        if ( json.containsKey(\"parameters\") ) {\n-            JsonObject params = json.getJsonObject(\"parameters\");\n-            Map<String,String> paramMap = new HashMap<>();\n-            params.keySet().forEach(k -> paramMap.put(k,jsonValueToString(params.get(k))));\n-            wsd.setStepParameters(paramMap);\n-        }\n-        if ( json.containsKey(\"requiredSettings\") ) {\n-            JsonObject settings = json.getJsonObject(\"requiredSettings\");\n-            Map<String,String> settingsMap = new HashMap<>();\n-            settings.keySet().forEach(k -> settingsMap.put(k,jsonValueToString(settings.get(k))));\n-            wsd.setStepSettings(settingsMap);\n-        }\n-        return wsd;\n-    }\n-    \n-    private String jsonValueToString(JsonValue jv) {\n-        switch ( jv.getValueType() ) {\n-            case STRING: return ((JsonString)jv).getString();\n-            default: return jv.toString();\n-        }\n-    }\n-    \n-    public List<ControlledVocabularyValue> parseControlledVocabularyValue(DatasetFieldType cvvType, JsonObject json) throws JsonParseException {\n+      DatasetFieldCompoundValue cv = new DatasetFieldCompoundValue();\n+      List<DatasetField> fields = new LinkedList<>();\n+      JsonObject value = json.getJsonObject(\"value\");\n+      for (String key : value.keySet()) {\n+        JsonObject childFieldJson = value.getJsonObject(key);\n+        DatasetField f = null;\n         try {\n-            if (cvvType.isAllowMultiples()) {\n-                try {\n-                    json.getJsonArray(\"value\").getValuesAs(JsonObject.class);\n-                } catch (ClassCastException cce) {\n-                    throw new JsonParseException(\"Invalid values submitted for \" + cvvType.getName() + \". It should be an array of values.\");\n-                }                \n-                List<ControlledVocabularyValue> vals = new LinkedList<>();\n-                for (JsonString strVal : json.getJsonArray(\"value\").getValuesAs(JsonString.class)) {\n-                    String strValue = strVal.getString();\n-                    ControlledVocabularyValue cvv = datasetFieldSvc.findControlledVocabularyValueByDatasetFieldTypeAndStrValue(cvvType, strValue, lenient);\n-                    if (cvv == null) {\n-                        throw new ControlledVocabularyException(\"Value '\" + strValue + \"' does not exist in type '\" + cvvType.getName() + \"'\", cvvType, strValue);\n-                    }\n-                    // Only add value to the list if it is not a duplicate \n-                    if (strValue.equals(\"Other\")) {\n-                        System.out.println(\"vals = \" + vals + \", contains: \" + vals.contains(cvv));\n-                    }\n-                    if (!vals.contains(cvv)) {\n-                        vals.add(cvv);\n-                    }\n-                }\n-                return vals;\n-\n-            } else {\n-                try {\n-                    json.getString(\"value\");\n-                } catch (ClassCastException cce) {\n-                    throw new JsonParseException(\"Invalid value submitted for \" + cvvType.getName() + \". It should be a single value.\");\n-                }\n-                String strValue = json.getString(\"value\", \"\");\n-                ControlledVocabularyValue cvv = datasetFieldSvc.findControlledVocabularyValueByDatasetFieldTypeAndStrValue(cvvType, strValue, lenient);\n-                if (cvv == null) {\n-                    throw new ControlledVocabularyException(\"Value '\" + strValue + \"' does not exist in type '\" + cvvType.getName() + \"'\", cvvType, strValue);\n-                }\n-                return Collections.singletonList(cvv);\n-            }\n+          f = parseField(childFieldJson, testType);\n+        } catch (ControlledVocabularyException ex) {\n+          vocabExceptions.add(ex);\n+        }\n+        if (f != null) {\n+          f.setParentDatasetFieldCompoundValue(cv);\n+          fields.add(f);\n+        }\n+      }\n+      if (!fields.isEmpty()) {\n+        cv.setChildDatasetFields(fields);\n+        vals.add(cv);\n+      }\n+\n+    }\n+    if (!vocabExceptions.isEmpty()) {\n+      throw new CompoundVocabularyException(\"Invalid controlled vocabulary in compound field \", vocabExceptions, vals);\n+    }\n+    return vals;\n+  }\n+\n+  public List<DatasetFieldValue> parsePrimitiveValue(DatasetFieldType dft, JsonObject json) throws JsonParseException {\n+\n+    List<DatasetFieldValue> vals = new LinkedList<>();\n+    if (dft.isAllowMultiples()) {\n+      try {\n+        json.getJsonArray(\"value\").getValuesAs(JsonObject.class);\n+      } catch (ClassCastException cce) {\n+        throw new JsonParseException(\n+          \"Invalid values submitted for \" + dft.getName() + \". It should be an array of values.\");\n+      }\n+      for (JsonString val : json.getJsonArray(\"value\").getValuesAs(JsonString.class)) {\n+        DatasetFieldValue datasetFieldValue = new DatasetFieldValue();\n+        datasetFieldValue.setDisplayOrder(vals.size() - 1);\n+        datasetFieldValue.setValue(val.getString().trim());\n+        vals.add(datasetFieldValue);\n+      }\n+\n+    } else {\n+      try {\n+        json.getString(\"value\");\n+      } catch (ClassCastException cce) {\n+        throw new JsonParseException(\"Invalid value submitted for \" + dft.getName() + \". It should be a single value.\");\n+      }\n+      DatasetFieldValue datasetFieldValue = new DatasetFieldValue();\n+      datasetFieldValue.setValue(json.getString(\"value\", \"\").trim());\n+      vals.add(datasetFieldValue);\n+    }\n+\n+    return vals;\n+  }\n+\n+  public Workflow parseWorkflow(JsonObject json) throws JsonParseException {\n+    Workflow retVal = new Workflow();\n+    validate(\"\", json, \"name\", ValueType.STRING);\n+    validate(\"\", json, \"steps\", ValueType.ARRAY);\n+    retVal.setName(json.getString(\"name\"));\n+    JsonArray stepArray = json.getJsonArray(\"steps\");\n+    List<WorkflowStepData> steps = new ArrayList<>(stepArray.size());\n+    for (JsonValue jv : stepArray) {\n+      steps.add(parseStepData((JsonObject) jv));\n+    }\n+    retVal.setSteps(steps);\n+    return retVal;\n+  }\n+\n+  public WorkflowStepData parseStepData(JsonObject json) throws JsonParseException {\n+    WorkflowStepData wsd = new WorkflowStepData();\n+    validate(\"step\", json, \"provider\", ValueType.STRING);\n+    validate(\"step\", json, \"stepType\", ValueType.STRING);\n+\n+    wsd.setProviderId(json.getString(\"provider\"));\n+    wsd.setStepType(json.getString(\"stepType\"));\n+    if (json.containsKey(\"parameters\")) {\n+      JsonObject params = json.getJsonObject(\"parameters\");\n+      Map<String, String> paramMap = new HashMap<>();\n+      params.keySet().forEach(k -> paramMap.put(k, jsonValueToString(params.get(k))));\n+      wsd.setStepParameters(paramMap);\n+    }\n+    if (json.containsKey(\"requiredSettings\")) {\n+      JsonObject settings = json.getJsonObject(\"requiredSettings\");\n+      Map<String, String> settingsMap = new HashMap<>();\n+      settings.keySet().forEach(k -> settingsMap.put(k, jsonValueToString(settings.get(k))));\n+      wsd.setStepSettings(settingsMap);\n+    }\n+    return wsd;\n+  }\n+\n+  private String jsonValueToString(JsonValue jv) {\n+    switch (jv.getValueType()) {\n+      case STRING:\n+        return ((JsonString) jv).getString();\n+      default:\n+        return jv.toString();\n+    }\n+  }\n+\n+  public List<ControlledVocabularyValue> parseControlledVocabularyValue(DatasetFieldType cvvType, JsonObject json)\n+    throws JsonParseException {\n+    try {\n+      if (cvvType.isAllowMultiples()) {\n+        try {\n+          json.getJsonArray(\"value\").getValuesAs(JsonObject.class);\n         } catch (ClassCastException cce) {\n-            throw new JsonParseException(\"Invalid values submitted for \" + cvvType.getName());\n+          throw new JsonParseException(\n+            \"Invalid values submitted for \" + cvvType.getName() + \". It should be an array of values.\");\n+        }\n+        List<ControlledVocabularyValue> vals = new LinkedList<>();\n+        for (JsonString strVal : json.getJsonArray(\"value\").getValuesAs(JsonString.class)) {\n+          String strValue = strVal.getString();\n+          ControlledVocabularyValue cvv =\n+            datasetFieldSvc.findControlledVocabularyValueByDatasetFieldTypeAndStrValue(cvvType, strValue, lenient);\n+          if (cvv == null) {\n+            throw new ControlledVocabularyException(\n+              \"Value '\" + strValue + \"' does not exist in type '\" + cvvType.getName() + \"'\", cvvType, strValue);\n+          }\n+          // Only add value to the list if it is not a duplicate\n+          if (strValue.equals(\"Other\")) {\n+            System.out.println(\"vals = \" + vals + \", contains: \" + vals.contains(cvv));\n+          }\n+          if (!vals.contains(cvv)) {\n+            vals.add(cvv);\n+          }\n         }\n-    }\n-\n-    Date parseDate(String str) throws ParseException {\n-        return str == null ? null : Util.getDateFormat().parse(str);\n-    }\n-\n-    Date parseTime(String str) throws ParseException {\n-        return str == null ? null : Util.getDateTimeFormat().parse(str);\n-    }\n-\n-    Long parseLong(String str) throws NumberFormatException {\n-        return (str == null) ? null : Long.valueOf(str);\n-    }\n-\n-    int parsePrimitiveInt(String str, int defaultValue) {\n-        return str == null ? defaultValue : Integer.parseInt(str);\n-    }\n-    \n-    public String parseHarvestingClient(JsonObject obj, HarvestingClient harvestingClient) throws JsonParseException {\n-        \n-        String dataverseAlias = obj.getString(\"dataverseAlias\",null);\n-        \n-        harvestingClient.setName(obj.getString(\"nickName\",null));\n-        harvestingClient.setHarvestType(obj.getString(\"type\",null));\n-        harvestingClient.setHarvestingUrl(obj.getString(\"harvestUrl\",null));\n-        harvestingClient.setArchiveUrl(obj.getString(\"archiveUrl\",null));\n-        harvestingClient.setArchiveDescription(obj.getString(\"archiveDescription\"));\n-        harvestingClient.setMetadataPrefix(obj.getString(\"metadataFormat\",null));\n-        harvestingClient.setHarvestingSet(obj.getString(\"set\",null));\n-\n-        return dataverseAlias;\n-    }\n+        return vals;\n \n-    private List<DataFileCategory> getCategories(JsonObject filemetadataJson, Dataset dataset) {\n-        JsonArray categories = filemetadataJson.getJsonArray(OptionalFileParams.CATEGORIES_ATTR_NAME);\n-        if (categories == null || categories.isEmpty() || dataset == null) {\n-            return null;\n-        }\n-        List<DataFileCategory> dataFileCategories = new ArrayList<>();\n-        for (Object category : categories.getValuesAs(JsonString.class)) {\n-            JsonString categoryAsJsonString;\n-            try {\n-                categoryAsJsonString = (JsonString) category;\n-            } catch (ClassCastException ex) {\n-                logger.info(\"ClassCastException caught in getCategories: \" + ex);\n-                return null;\n-            }\n-            DataFileCategory dfc = new DataFileCategory();\n-            dfc.setDataset(dataset);\n-            dfc.setName(categoryAsJsonString.getString());\n-            dataFileCategories.add(dfc);\n-        }\n-        return dataFileCategories;\n-    }\n-    \n-    /**\n-     * Validate than a JSON object has a field of an expected type, or throw an\n-     * inforamtive exception.\n-     * @param objectName\n-     * @param jobject\n-     * @param fieldName\n-     * @param expectedValueType\n-     * @throws JsonParseException \n-     */\n-    private void validate(String objectName, JsonObject jobject, String fieldName, ValueType expectedValueType) throws JsonParseException {\n-        if ( (!jobject.containsKey(fieldName)) \n-              || (jobject.get(fieldName).getValueType()!=expectedValueType) ) {\n-            throw new JsonParseException( objectName + \" missing a field named '\"+fieldName+\"' of type \" + expectedValueType );\n-        }\n-    }\n+      } else {\n+        try {\n+          json.getString(\"value\");\n+        } catch (ClassCastException cce) {\n+          throw new JsonParseException(\n+            \"Invalid value submitted for \" + cvvType.getName() + \". It should be a single value.\");\n+        }\n+        String strValue = json.getString(\"value\", \"\");\n+        ControlledVocabularyValue cvv =\n+          datasetFieldSvc.findControlledVocabularyValueByDatasetFieldTypeAndStrValue(cvvType, strValue, lenient);\n+        if (cvv == null) {\n+          throw new ControlledVocabularyException(\n+            \"Value '\" + strValue + \"' does not exist in type '\" + cvvType.getName() + \"'\", cvvType, strValue);\n+        }\n+        return Collections.singletonList(cvv);\n+      }\n+    } catch (ClassCastException cce) {\n+      throw new JsonParseException(\"Invalid values submitted for \" + cvvType.getName());\n+    }\n+  }\n+\n+  Date parseDate(String str) throws ParseException {\n+    return str == null ? null : Util.getDateFormat().parse(str);\n+  }\n+\n+  Date parseTime(String str) throws ParseException {\n+    return str == null ? null : Util.getDateTimeFormat().parse(str);\n+  }\n+\n+  Long parseLong(String str) throws NumberFormatException {\n+    return (str == null) ? null : Long.valueOf(str);\n+  }\n+\n+  int parsePrimitiveInt(String str, int defaultValue) {\n+    return str == null ? defaultValue : Integer.parseInt(str);\n+  }\n+\n+  public String parseHarvestingClient(JsonObject obj, HarvestingClient harvestingClient) throws JsonParseException {\n+\n+    String dataverseAlias = obj.getString(\"dataverseAlias\", null);\n+\n+    harvestingClient.setName(obj.getString(\"nickName\", null));\n+    harvestingClient.setHarvestType(obj.getString(\"type\", null));\n+    harvestingClient.setHarvestingUrl(obj.getString(\"harvestUrl\", null));\n+    harvestingClient.setArchiveUrl(obj.getString(\"archiveUrl\", null));\n+    harvestingClient.setArchiveDescription(obj.getString(\"archiveDescription\"));\n+    harvestingClient.setMetadataPrefix(obj.getString(\"metadataFormat\", null));\n+    harvestingClient.setHarvestingSet(obj.getString(\"set\", null));\n+\n+    return dataverseAlias;\n+  }\n+\n+  private List<DataFileCategory> getCategories(JsonObject filemetadataJson, Dataset dataset) {\n+    JsonArray categories = filemetadataJson.getJsonArray(OptionalFileParams.CATEGORIES_ATTR_NAME);\n+    if (categories == null || categories.isEmpty() || dataset == null) {\n+      return null;\n+    }\n+    List<DataFileCategory> dataFileCategories = new ArrayList<>();\n+    for (Object category : categories.getValuesAs(JsonString.class)) {\n+      JsonString categoryAsJsonString;\n+      try {\n+        categoryAsJsonString = (JsonString) category;\n+      } catch (ClassCastException ex) {\n+        logger.info(\"ClassCastException caught in getCategories: \" + ex);\n+        return null;\n+      }\n+      DataFileCategory dfc = new DataFileCategory();\n+      dfc.setDataset(dataset);\n+      dfc.setName(categoryAsJsonString.getString());\n+      dataFileCategories.add(dfc);\n+    }\n+    return dataFileCategories;\n+  }\n+\n+  /**\n+   * Validate than a JSON object has a field of an expected type, or throw an\n+   * inforamtive exception.\n+   *\n+   * @param objectName\n+   * @param jobject\n+   * @param fieldName\n+   * @param expectedValueType\n+   * @throws JsonParseException\n+   */\n+  private void validate(String objectName, JsonObject jobject, String fieldName, ValueType expectedValueType)\n+    throws JsonParseException {\n+    if ((!jobject.containsKey(fieldName))\n+      || (jobject.get(fieldName).getValueType() != expectedValueType)) {\n+      throw new JsonParseException(\n+        objectName + \" missing a field named '\" + fieldName + \"' of type \" + expectedValueType);\n+    }\n+  }\n }\n",
            "diff_size": 1355
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/87/JsonParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/87/JsonParser.java\nindex a902d93daca..e447cec69dc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/87/JsonParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/87/JsonParser.java\n@@ -706,7 +706,8 @@ public class JsonParser {\n             }\n \n         } else {\n-            try {json.getString(\"value\");}\n+            try{\n+                json.getString(\"value\");}\n             catch (ClassCastException cce) {\n                 throw new JsonParseException(\"Invalid value submitted for \" + dft.getName() + \". It should be a single value.\");\n             }            \n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/87/JsonParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/87/JsonParser.java\nindex a902d93daca..d2fed72ef43 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/87/JsonParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/87/JsonParser.java\n@@ -706,7 +706,8 @@ public class JsonParser {\n             }\n \n         } else {\n-            try {json.getString(\"value\");}\n+            try {\n+                json.getString(\"value\");}\n             catch (ClassCastException cce) {\n                 throw new JsonParseException(\"Invalid value submitted for \" + dft.getName() + \". It should be a single value.\");\n             }            \n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}