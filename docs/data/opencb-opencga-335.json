{
    "project_name": "opencb-opencga",
    "error_id": "335",
    "information": {
        "errors": [
            {
                "line": "268",
                "severity": "error",
                "message": "Line matches the illegal pattern 'Trailing whitespace'.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpCheck"
            }
        ]
    },
    "source_code": "                            List<Integer> motherFiles = allSamples.get(mother).getFiles();\n                            List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n                            boolean parentInSeparatedFile = \n                                    motherFiles.size() == sampleFiles.size() && motherFiles.containsAll(sampleFiles);\n                            boolean[] filter = buildParentGtFilter(gtMap.get(mother), includeDiscrepancies, parentInSeparatedFile);\n                            if (!isFullyCoveredParentFilter(filter)) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/335/SampleIndexQueryParser.java\nindex 183d4bbcd79..d3d06cca3be 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/335/SampleIndexQueryParser.java\n@@ -265,7 +265,7 @@ public class SampleIndexQueryParser {\n                                     .equals(metadataManager.getLoadSplitData(studyId, motherId));\n                             List<Integer> motherFiles = allSamples.get(mother).getFiles();\n                             List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n-                            boolean parentInSeparatedFile = \n+                            boolean parentInSeparatedFile =\n                                     motherFiles.size() == sampleFiles.size() && motherFiles.containsAll(sampleFiles);\n                             boolean[] filter = buildParentGtFilter(gtMap.get(mother), includeDiscrepancies, parentInSeparatedFile);\n                             if (!isFullyCoveredParentFilter(filter)) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/335/SampleIndexQueryParser.java\nindex 183d4bbcd79..054b8191ad1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/335/SampleIndexQueryParser.java\n@@ -41,1206 +41,1207 @@ import static org.opencb.opencga.storage.hadoop.variant.index.sample.VariantFile\n  * Created by jacobo on 06/01/19.\n  */\n public class SampleIndexQueryParser {\n-    private static Logger logger = LoggerFactory.getLogger(SampleIndexQueryParser.class);\n-    private final SampleIndexConfiguration configuration;\n-    private final VariantStorageMetadataManager metadataManager;\n-\n-    public SampleIndexQueryParser(VariantStorageMetadataManager metadataManager) {\n-        this(metadataManager, SampleIndexConfiguration.defaultConfiguration());\n-    }\n-\n-    public SampleIndexQueryParser(VariantStorageMetadataManager metadataManager, SampleIndexConfiguration configuration) {\n-        this.configuration = configuration;\n-        this.metadataManager = metadataManager;\n+  private static Logger logger = LoggerFactory.getLogger(SampleIndexQueryParser.class);\n+  private final SampleIndexConfiguration configuration;\n+  private final VariantStorageMetadataManager metadataManager;\n+\n+  public SampleIndexQueryParser(VariantStorageMetadataManager metadataManager) {\n+    this(metadataManager, SampleIndexConfiguration.defaultConfiguration());\n+  }\n+\n+  public SampleIndexQueryParser(VariantStorageMetadataManager metadataManager, SampleIndexConfiguration configuration) {\n+    this.configuration = configuration;\n+    this.metadataManager = metadataManager;\n+  }\n+\n+  /**\n+   * Determine if a given query can be used to query with the SampleIndex.\n+   *\n+   * @param query Query\n+   * @return if the query is valid\n+   */\n+  public static boolean validSampleIndexQuery(Query query) {\n+    ParsedVariantQuery.VariantQueryXref xref = VariantQueryParser.parseXrefs(query);\n+    if (!xref.getIds().isEmpty() || !xref.getVariants().isEmpty() || !xref.getOtherXrefs().isEmpty()) {\n+      // Can not be used for specific variant IDs. Only regions and genes\n+      return false;\n     }\n \n-    /**\n-     * Determine if a given query can be used to query with the SampleIndex.\n-     * @param query Query\n-     * @return      if the query is valid\n-     */\n-    public static boolean validSampleIndexQuery(Query query) {\n-        ParsedVariantQuery.VariantQueryXref xref = VariantQueryParser.parseXrefs(query);\n-        if (!xref.getIds().isEmpty() || !xref.getVariants().isEmpty() || !xref.getOtherXrefs().isEmpty()) {\n-            // Can not be used for specific variant IDs. Only regions and genes\n-            return false;\n-        }\n-\n-        if (isValidParam(query, GENOTYPE)) {\n-            HashMap<Object, List<String>> gtMap = new HashMap<>();\n-            QueryOperation queryOperation = VariantQueryUtils.parseGenotypeFilter(query.getString(GENOTYPE.key()), gtMap);\n-            boolean allValid = true;\n-            boolean anyValid = false;\n-            for (List<String> gts : gtMap.values()) {\n-                boolean valid = true;\n-                for (String gt : gts) {\n-                    // Despite invalid genotypes (i.e. genotypes not in the index) can be used to filter within AND queries,\n-                    // we require at least one sample where all the genotypes are valid\n-                    valid &= !isNegated(gt) && SampleIndexSchema.validGenotype(gt);\n-                }\n-                anyValid |= valid;\n-                allValid &= valid;\n-            }\n-            if (queryOperation == QueryOperation.AND) {\n-                // Intersect sample filters. If any sample filter is valid, the SampleIndex can be used.\n-                return anyValid;\n-            } else {\n-                // Union of all sample filters. All sample filters must be valid to use the SampleIndex.\n-                return allValid;\n-            }\n-        }\n-        if (isValidParam(query, SAMPLE, true)) {\n-            return true;\n-        }\n-        if (isValidParam(query, SAMPLE_MENDELIAN_ERROR, true)) {\n-            return true;\n-        }\n-        if (isValidParam(query, SAMPLE_DE_NOVO, true)) {\n-            return true;\n+    if (isValidParam(query, GENOTYPE)) {\n+      HashMap<Object, List<String>> gtMap = new HashMap<>();\n+      QueryOperation queryOperation = VariantQueryUtils.parseGenotypeFilter(query.getString(GENOTYPE.key()), gtMap);\n+      boolean allValid = true;\n+      boolean anyValid = false;\n+      for (List<String> gts : gtMap.values()) {\n+        boolean valid = true;\n+        for (String gt : gts) {\n+          // Despite invalid genotypes (i.e. genotypes not in the index) can be used to filter within AND queries,\n+          // we require at least one sample where all the genotypes are valid\n+          valid &= !isNegated(gt) && SampleIndexSchema.validGenotype(gt);\n         }\n-        return false;\n+        anyValid |= valid;\n+        allValid &= valid;\n+      }\n+      if (queryOperation == QueryOperation.AND) {\n+        // Intersect sample filters. If any sample filter is valid, the SampleIndex can be used.\n+        return anyValid;\n+      } else {\n+        // Union of all sample filters. All sample filters must be valid to use the SampleIndex.\n+        return allValid;\n+      }\n     }\n-\n-    public SingleSampleIndexQuery parse(List<Region> regions, String study, String sample, List<String> genotypes) {\n-        return parse(regions, study, Collections.singletonMap(sample, genotypes), null).forSample(sample);\n+    if (isValidParam(query, SAMPLE, true)) {\n+      return true;\n     }\n-\n-    public SampleIndexQuery parse(List<Region> regions, String study, Map<String, List<String>> samplesMap, QueryOperation queryOperation) {\n-        if (queryOperation == null) {\n-            queryOperation = QueryOperation.OR;\n-        }\n-        String gtFilter = samplesMap.entrySet()\n-                .stream()\n-                .map(e -> e.getKey() + \":\" + String.join(\",\", e.getValue()))\n-                .collect(Collectors.joining(queryOperation.separator()));\n-\n-        return parse(new Query(REGION.key(), regions).append(STUDY.key(), study).append(GENOTYPE.key(), gtFilter));\n+    if (isValidParam(query, SAMPLE_MENDELIAN_ERROR, true)) {\n+      return true;\n     }\n+    if (isValidParam(query, SAMPLE_DE_NOVO, true)) {\n+      return true;\n+    }\n+    return false;\n+  }\n \n-    /**\n-     * Build SampleIndexQuery. Extract Regions (+genes), Study, Sample and Genotypes.\n-     * <p>\n-     * Assumes that the query is valid.\n-     *\n-     * @param query           Input query. Will be modified.\n-     * @return Valid SampleIndexQuery\n-     * @see SampleIndexQueryParser#validSampleIndexQuery(Query)\n-     */\n-    public SampleIndexQuery parse(Query query) {\n-        // TODO: Accept variant IDs?\n-\n-        // Extract study\n-        StudyMetadata defaultStudy = VariantQueryParser.getDefaultStudy(query, metadataManager);\n-\n-        if (defaultStudy == null) {\n-            throw VariantQueryException.missingStudyForSample(\"\", metadataManager.getStudyNames());\n-        }\n-        int studyId = defaultStudy.getId();\n-        String study = defaultStudy.getName();\n-\n-        List<String> allGenotypes = getAllLoadedGenotypes(defaultStudy);\n-        List<String> validGenotypes = allGenotypes.stream().filter(SampleIndexSchema::validGenotype).collect(Collectors.toList());\n-        List<String> mainGenotypes = GenotypeClass.MAIN_ALT.filter(validGenotypes);\n-\n-\n-        boolean partialIndex = false;\n-\n-        QueryOperation queryOperation;\n-        // Map from all samples to query to its list of genotypes.\n-        Map<String, List<String>> samplesMap = new HashMap<>();\n-        // Samples that are returning data from more than one file\n-        Set<String> multiFileSamples = new HashSet<>();\n-        // Samples that are querying\n-        Set<String> negatedSamples = new HashSet<>();\n-        // Samples from the query that can not be used to filter. e.g. samples with invalid or negated genotypes\n-        // If any, the query is not covered.\n-        List<String> negatedGenotypesSamples = new LinkedList<>();\n-        // Samples from the query that are parents of any other sample in the query, with the FamilyIndex calculated.\n-        // These samples are excluded form the smaplesMap\n-        Set<String> parentsInQuery = new HashSet<>();\n-\n-        // Father/Mother filters\n-        Map<String, boolean[]> fatherFilterMap = new HashMap<>();\n-        Map<String, boolean[]> motherFilterMap = new HashMap<>();\n-\n-        Set<String> mendelianErrorSet = new HashSet<>();\n-        boolean onlyDeNovo = false;\n-\n-        // Extract sample and genotypes to filter\n-        if (isValidParam(query, GENOTYPE)) {\n-            // Get samples with non negated genotypes\n-\n-            Map<Object, List<String>> map = new HashMap<>();\n-            Map<String, SampleMetadata> allSamples = new HashMap<>();\n-            queryOperation = parseGenotypeFilter(query.getString(GENOTYPE.key()), map);\n-\n-            // Extract parents from each sample\n-            Map<String, List<String>> gtMap = new HashMap<>();\n-            Map<String, List<String>> parentsMap = new HashMap<>();\n-            for (Map.Entry<Object, List<String>> entry : map.entrySet()) {\n-                Object sample = entry.getKey();\n-                Integer sampleId = metadataManager.getSampleId(studyId, sample);\n-\n-                SampleMetadata sampleMetadata = metadataManager.getSampleMetadata(studyId, sampleId);\n-                allSamples.put(sampleMetadata.getName(), sampleMetadata);\n-\n-                List<String> gts = GenotypeClass.filter(entry.getValue(), allGenotypes);\n-                if (gts.stream().allMatch(SampleIndexSchema::validGenotype)) {\n-                    if (sampleMetadata.getFamilyIndexStatus() == TaskMetadata.Status.READY) {\n-                        String fatherName = null;\n-                        if (sampleMetadata.getFather() != null) {\n-                            fatherName = metadataManager.getSampleName(studyId, sampleMetadata.getFather());\n-                        }\n-                        String motherName = null;\n-                        if (sampleMetadata.getMother() != null) {\n-                            motherName = metadataManager.getSampleName(studyId, sampleMetadata.getMother());\n-                        }\n-                        if (fatherName != null || motherName != null) {\n-                            parentsMap.put(sampleMetadata.getName(), Arrays.asList(fatherName, motherName));\n-                        }\n-                    }\n-                } else {\n-                    negatedSamples.add(sampleMetadata.getName());\n-                }\n-                if (VariantStorageEngine.SplitData.MULTI.equals(sampleMetadata.getSplitData())) {\n-                    multiFileSamples.add(sampleMetadata.getName());\n-                }\n-\n-                gtMap.put(sampleMetadata.getName(), gts);\n-            }\n-\n-            // Determine which samples are parents, and which are children\n-            Set<String> childrenSet = findChildren(gtMap, queryOperation, parentsMap);\n-            Set<String> parentsSet = new HashSet<>();\n-            for (String child : childrenSet) {\n-                // may add null values\n-                parentsSet.addAll(parentsMap.get(child));\n-            }\n-\n-            boolean partialGtIndex = false;\n-            for (Map.Entry<String, List<String>> entry : gtMap.entrySet()) {\n-                String sampleName = entry.getKey();\n-                if (queryOperation != QueryOperation.OR && parentsSet.contains(sampleName) && !childrenSet.contains(sampleName)) {\n-                    // We can skip parents, as their genotype filter will be tested in the child\n-                    // Discard parents that are not children of another sample\n-                    // Parents filter can only be used when intersecting (AND) with child\n-                    logger.debug(\"Discard parent {}\", sampleName);\n-                    parentsInQuery.add(sampleName);\n-\n-                    // Remove from negatedSamples (if present)\n-                    negatedSamples.remove(sampleName);\n-\n-                    continue;\n-                }\n-                if (hasNegatedGenotypeFilter(queryOperation, entry.getValue())) {\n-                    // Discard samples with negated genotypes\n-                    negatedGenotypesSamples.add(sampleName);\n-                    partialIndex = true;\n-                    partialGtIndex = true;\n-                } else {\n-                    samplesMap.put(sampleName, entry.getValue());\n-                    if (queryOperation != QueryOperation.OR && childrenSet.contains(sampleName)) {\n-                        // Parents filter can only be used when intersecting (AND) with child\n-                        List<String> parents = parentsMap.get(sampleName);\n-                        String father = parents.get(0);\n-                        String mother = parents.get(1);\n-\n-                        if (father != null) {\n-                            Integer fatherId = metadataManager.getSampleId(studyId, father);\n-                            boolean includeDiscrepancies = VariantStorageEngine.SplitData.MULTI\n-                                    .equals(metadataManager.getLoadSplitData(studyId, fatherId));\n-                            List<Integer> fatherFiles = allSamples.get(father).getFiles();\n-                            List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n-                            boolean parentInSeparatedFile =\n-                                    fatherFiles.size() == sampleFiles.size() && fatherFiles.containsAll(sampleFiles);\n-                            boolean[] filter = buildParentGtFilter(gtMap.get(father), includeDiscrepancies, parentInSeparatedFile);\n-                            if (!isFullyCoveredParentFilter(filter)) {\n-                                partialGtIndex = true;\n-                            }\n-                            fatherFilterMap.put(sampleName, filter);\n-                        }\n-                        if (mother != null) {\n-                            Integer motherId = metadataManager.getSampleId(studyId, mother);\n-                            boolean includeDiscrepancies = VariantStorageEngine.SplitData.MULTI\n-                                    .equals(metadataManager.getLoadSplitData(studyId, motherId));\n-                            List<Integer> motherFiles = allSamples.get(mother).getFiles();\n-                            List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n-                            boolean parentInSeparatedFile = \n-                                    motherFiles.size() == sampleFiles.size() && motherFiles.containsAll(sampleFiles);\n-                            boolean[] filter = buildParentGtFilter(gtMap.get(mother), includeDiscrepancies, parentInSeparatedFile);\n-                            if (!isFullyCoveredParentFilter(filter)) {\n-                                partialGtIndex = true;\n-                            }\n-                            motherFilterMap.put(sampleName, filter);\n-                        }\n-                    }\n-                }\n-                // If not all genotypes are valid, query is not covered\n-                if (!negatedSamples.isEmpty()) {\n-                    partialGtIndex = true;\n-                }\n-            }\n-\n-            for (String negatedSample : negatedSamples) {\n-                List<String> negatedGenotypes = new ArrayList<>(validGenotypes);\n-                negatedGenotypes.removeAll(samplesMap.get(negatedSample));\n-                samplesMap.put(negatedSample, negatedGenotypes);\n-            }\n-\n-            if (!partialGtIndex) {\n-                // Do not remove genotypes list if FORMAT is present.\n-                if (!isValidParam(query, SAMPLE_DATA)) {\n-                    query.remove(GENOTYPE.key());\n-                }\n-            }\n-        } else if (isValidParam(query, SAMPLE)) {\n-            // Filter by all non negated samples\n-            String samplesStr = query.getString(SAMPLE.key());\n-            queryOperation = VariantQueryUtils.checkOperator(samplesStr);\n-            List<String> samples = VariantQueryUtils.splitValue(samplesStr, queryOperation);\n-            for (String s : samples) {\n-                if (!isNegated(s)) {\n-                    samplesMap.put(s, mainGenotypes);\n-                }\n-            }\n+  public SingleSampleIndexQuery parse(List<Region> regions, String study, String sample, List<String> genotypes) {\n+    return parse(regions, study, Collections.singletonMap(sample, genotypes), null).forSample(sample);\n+  }\n \n-            if (!isValidParam(query, SAMPLE_DATA)) {\n-                // Do not remove FORMAT\n-                query.remove(SAMPLE.key());\n+  public SampleIndexQuery parse(List<Region> regions, String study, Map<String, List<String>> samplesMap, QueryOperation queryOperation) {\n+    if (queryOperation == null) {\n+      queryOperation = QueryOperation.OR;\n+    }\n+    String gtFilter = samplesMap.entrySet()\n+        .stream()\n+        .map(e -> e.getKey() + \":\" + String.join(\",\", e.getValue()))\n+        .collect(Collectors.joining(queryOperation.separator()));\n+\n+    return parse(new Query(REGION.key(), regions).append(STUDY.key(), study).append(GENOTYPE.key(), gtFilter));\n+  }\n+\n+  /**\n+   * Build SampleIndexQuery. Extract Regions (+genes), Study, Sample and Genotypes.\n+   * <p>\n+   * Assumes that the query is valid.\n+   *\n+   * @param query Input query. Will be modified.\n+   * @return Valid SampleIndexQuery\n+   * @see SampleIndexQueryParser#validSampleIndexQuery(Query)\n+   */\n+  public SampleIndexQuery parse(Query query) {\n+    // TODO: Accept variant IDs?\n+\n+    // Extract study\n+    StudyMetadata defaultStudy = VariantQueryParser.getDefaultStudy(query, metadataManager);\n+\n+    if (defaultStudy == null) {\n+      throw VariantQueryException.missingStudyForSample(\"\", metadataManager.getStudyNames());\n+    }\n+    int studyId = defaultStudy.getId();\n+    String study = defaultStudy.getName();\n+\n+    List<String> allGenotypes = getAllLoadedGenotypes(defaultStudy);\n+    List<String> validGenotypes = allGenotypes.stream().filter(SampleIndexSchema::validGenotype).collect(Collectors.toList());\n+    List<String> mainGenotypes = GenotypeClass.MAIN_ALT.filter(validGenotypes);\n+\n+\n+    boolean partialIndex = false;\n+\n+    QueryOperation queryOperation;\n+    // Map from all samples to query to its list of genotypes.\n+    Map<String, List<String>> samplesMap = new HashMap<>();\n+    // Samples that are returning data from more than one file\n+    Set<String> multiFileSamples = new HashSet<>();\n+    // Samples that are querying\n+    Set<String> negatedSamples = new HashSet<>();\n+    // Samples from the query that can not be used to filter. e.g. samples with invalid or negated genotypes\n+    // If any, the query is not covered.\n+    List<String> negatedGenotypesSamples = new LinkedList<>();\n+    // Samples from the query that are parents of any other sample in the query, with the FamilyIndex calculated.\n+    // These samples are excluded form the smaplesMap\n+    Set<String> parentsInQuery = new HashSet<>();\n+\n+    // Father/Mother filters\n+    Map<String, boolean[]> fatherFilterMap = new HashMap<>();\n+    Map<String, boolean[]> motherFilterMap = new HashMap<>();\n+\n+    Set<String> mendelianErrorSet = new HashSet<>();\n+    boolean onlyDeNovo = false;\n+\n+    // Extract sample and genotypes to filter\n+    if (isValidParam(query, GENOTYPE)) {\n+      // Get samples with non negated genotypes\n+\n+      Map<Object, List<String>> map = new HashMap<>();\n+      Map<String, SampleMetadata> allSamples = new HashMap<>();\n+      queryOperation = parseGenotypeFilter(query.getString(GENOTYPE.key()), map);\n+\n+      // Extract parents from each sample\n+      Map<String, List<String>> gtMap = new HashMap<>();\n+      Map<String, List<String>> parentsMap = new HashMap<>();\n+      for (Map.Entry<Object, List<String>> entry : map.entrySet()) {\n+        Object sample = entry.getKey();\n+        Integer sampleId = metadataManager.getSampleId(studyId, sample);\n+\n+        SampleMetadata sampleMetadata = metadataManager.getSampleMetadata(studyId, sampleId);\n+        allSamples.put(sampleMetadata.getName(), sampleMetadata);\n+\n+        List<String> gts = GenotypeClass.filter(entry.getValue(), allGenotypes);\n+        if (gts.stream().allMatch(SampleIndexSchema::validGenotype)) {\n+          if (sampleMetadata.getFamilyIndexStatus() == TaskMetadata.Status.READY) {\n+            String fatherName = null;\n+            if (sampleMetadata.getFather() != null) {\n+              fatherName = metadataManager.getSampleName(studyId, sampleMetadata.getFather());\n             }\n-        } else if (isValidParam(query, SAMPLE_MENDELIAN_ERROR)) {\n-            onlyDeNovo = false;\n-            ParsedQuery<String> mendelianError = splitValue(query, SAMPLE_MENDELIAN_ERROR);\n-            mendelianErrorSet = new HashSet<>(mendelianError.getValues());\n-            queryOperation = mendelianError.getOperation();\n-            for (String s : mendelianErrorSet) {\n-                // Return any genotype\n-                samplesMap.put(s, mainGenotypes);\n+            String motherName = null;\n+            if (sampleMetadata.getMother() != null) {\n+              motherName = metadataManager.getSampleName(studyId, sampleMetadata.getMother());\n             }\n-            query.remove(SAMPLE_MENDELIAN_ERROR.key());\n-            // Reading any MendelianError could return variants from GT=0/0, which is not annotated in the SampleIndex,\n-            // so the index is partial.\n-            partialIndex = true;\n-        } else if (isValidParam(query, SAMPLE_DE_NOVO)) {\n-            onlyDeNovo = true;\n-            ParsedQuery<String> sampleDeNovo = splitValue(query, SAMPLE_DE_NOVO);\n-            mendelianErrorSet = new HashSet<>(sampleDeNovo.getValues());\n-            queryOperation = sampleDeNovo.getOperation();\n-            for (String s : mendelianErrorSet) {\n-                // Return any genotype\n-                samplesMap.put(s, mainGenotypes);\n+            if (fatherName != null || motherName != null) {\n+              parentsMap.put(sampleMetadata.getName(), Arrays.asList(fatherName, motherName));\n             }\n-            query.remove(SAMPLE_DE_NOVO.key());\n-        //} else if (isValidParam(query, FILE)) {\n-            // Add FILEs filter ?\n+          }\n         } else {\n-            throw new IllegalStateException(\"Unable to query SamplesIndex\");\n+          negatedSamples.add(sampleMetadata.getName());\n         }\n-\n-        boolean partialFilesIndex = false;\n-        if (!negatedGenotypesSamples.isEmpty() || !parentsInQuery.isEmpty()) {\n-            Set<Integer> sampleFiles = new HashSet<>(samplesMap.size());\n-            for (String sample : samplesMap.keySet()) {\n-                Integer sampleId = metadataManager.getSampleId(studyId, sample);\n-                sampleFiles.addAll(metadataManager.getSampleMetadata(studyId, sampleId).getFiles());\n-            }\n-\n-            // If the file of any other sample is not between the files of the samples in the query, mark as partial\n-            for (String sample : negatedGenotypesSamples) {\n-                Integer sampleId = metadataManager.getSampleId(studyId, sample);\n-                for (Integer file : metadataManager.getSampleMetadata(studyId, sampleId).getFiles()) {\n-                    if (!sampleFiles.contains(file)) {\n-                        partialFilesIndex = true;\n-                        break;\n-                    }\n-                }\n-            }\n-            // If the file of any parent is not between the files of the samples in the query, mark as partial\n-            for (String sample : parentsInQuery) {\n-                Integer sampleId = metadataManager.getSampleId(studyId, sample);\n-                for (Integer file : metadataManager.getSampleMetadata(studyId, sampleId).getFiles()) {\n-                    if (!sampleFiles.contains(file)) {\n-                        partialFilesIndex = true;\n-                        break;\n-                    }\n-                }\n-            }\n-\n+        if (VariantStorageEngine.SplitData.MULTI.equals(sampleMetadata.getSplitData())) {\n+          multiFileSamples.add(sampleMetadata.getName());\n         }\n-        Map<String, Values<SampleFileIndexQuery>> fileIndexMap = new HashMap<>(samplesMap.size());\n-        for (String sample : samplesMap.keySet()) {\n-            Values<SampleFileIndexQuery> fileIndexQuery =\n-                    parseFilesQuery(query, studyId, sample, multiFileSamples.contains(sample), partialFilesIndex);\n \n-            fileIndexMap.put(sample, fileIndexQuery);\n+        gtMap.put(sampleMetadata.getName(), gts);\n+      }\n+\n+      // Determine which samples are parents, and which are children\n+      Set<String> childrenSet = findChildren(gtMap, queryOperation, parentsMap);\n+      Set<String> parentsSet = new HashSet<>();\n+      for (String child : childrenSet) {\n+        // may add null values\n+        parentsSet.addAll(parentsMap.get(child));\n+      }\n+\n+      boolean partialGtIndex = false;\n+      for (Map.Entry<String, List<String>> entry : gtMap.entrySet()) {\n+        String sampleName = entry.getKey();\n+        if (queryOperation != QueryOperation.OR && parentsSet.contains(sampleName) && !childrenSet.contains(sampleName)) {\n+          // We can skip parents, as their genotype filter will be tested in the child\n+          // Discard parents that are not children of another sample\n+          // Parents filter can only be used when intersecting (AND) with child\n+          logger.debug(\"Discard parent {}\", sampleName);\n+          parentsInQuery.add(sampleName);\n+\n+          // Remove from negatedSamples (if present)\n+          negatedSamples.remove(sampleName);\n+\n+          continue;\n         }\n-\n-        boolean allSamplesAnnotated = true;\n-        if (negatedGenotypesSamples.isEmpty()) {\n-            for (String sample : samplesMap.keySet()) {\n-                Integer sampleId = metadataManager.getSampleId(studyId, sample);\n-                SampleMetadata sampleMetadata = metadataManager.getSampleMetadata(studyId, sampleId);\n-                if (!SampleIndexDBAdaptor.getSampleIndexAnnotationStatus(sampleMetadata).equals(TaskMetadata.Status.READY)) {\n-                    allSamplesAnnotated = false;\n-                    break;\n-                }\n-            }\n+        if (hasNegatedGenotypeFilter(queryOperation, entry.getValue())) {\n+          // Discard samples with negated genotypes\n+          negatedGenotypesSamples.add(sampleName);\n+          partialIndex = true;\n+          partialGtIndex = true;\n         } else {\n-            allSamplesAnnotated = false;\n-        }\n+          samplesMap.put(sampleName, entry.getValue());\n+          if (queryOperation != QueryOperation.OR && childrenSet.contains(sampleName)) {\n+            // Parents filter can only be used when intersecting (AND) with child\n+            List<String> parents = parentsMap.get(sampleName);\n+            String father = parents.get(0);\n+            String mother = parents.get(1);\n \n-        boolean completeIndex = allSamplesAnnotated && !partialIndex;\n-        SampleAnnotationIndexQuery annotationIndexQuery = parseAnnotationIndexQuery(query, completeIndex);\n-        Set<VariantType> variantTypes = null;\n-        if (isValidParam(query, TYPE)) {\n-            List<String> typesStr = query.getAsStringList(VariantQueryParam.TYPE.key());\n-            if (!typesStr.isEmpty()) {\n-                variantTypes = new HashSet<>(typesStr.size());\n-                for (String type : typesStr) {\n-                    variantTypes.add(VariantType.valueOf(type));\n-                }\n-                if (variantTypes.contains(VariantType.COPY_NUMBER_GAIN)) {\n-                    // Can not distinguish between COPY_NUMBER_GAIN and COPY_NUMBER. Filter only by COPY_NUMBER\n-                    variantTypes.remove(VariantType.COPY_NUMBER_GAIN);\n-                    variantTypes.add(VariantType.COPY_NUMBER);\n-                }\n-                if (variantTypes.contains(VariantType.COPY_NUMBER_LOSS)) {\n-                    // Can not distinguish between COPY_NUMBER_LOSS and COPY_NUMBER. Filter only by COPY_NUMBER\n-                    variantTypes.remove(VariantType.COPY_NUMBER_LOSS);\n-                    variantTypes.add(VariantType.COPY_NUMBER);\n-                }\n+            if (father != null) {\n+              Integer fatherId = metadataManager.getSampleId(studyId, father);\n+              boolean includeDiscrepancies = VariantStorageEngine.SplitData.MULTI\n+                  .equals(metadataManager.getLoadSplitData(studyId, fatherId));\n+              List<Integer> fatherFiles = allSamples.get(father).getFiles();\n+              List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n+              boolean parentInSeparatedFile =\n+                  fatherFiles.size() == sampleFiles.size() && fatherFiles.containsAll(sampleFiles);\n+              boolean[] filter = buildParentGtFilter(gtMap.get(father), includeDiscrepancies, parentInSeparatedFile);\n+              if (!isFullyCoveredParentFilter(filter)) {\n+                partialGtIndex = true;\n+              }\n+              fatherFilterMap.put(sampleName, filter);\n             }\n-            if (!hasCopyNumberGainFilter(typesStr) && !hasCopyNumberLossFilter(typesStr)) {\n-                query.remove(TYPE.key());\n+            if (mother != null) {\n+              Integer motherId = metadataManager.getSampleId(studyId, mother);\n+              boolean includeDiscrepancies = VariantStorageEngine.SplitData.MULTI\n+                  .equals(metadataManager.getLoadSplitData(studyId, motherId));\n+              List<Integer> motherFiles = allSamples.get(mother).getFiles();\n+              List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n+              boolean parentInSeparatedFile =\n+                  motherFiles.size() == sampleFiles.size() && motherFiles.containsAll(sampleFiles);\n+              boolean[] filter = buildParentGtFilter(gtMap.get(mother), includeDiscrepancies, parentInSeparatedFile);\n+              if (!isFullyCoveredParentFilter(filter)) {\n+                partialGtIndex = true;\n+              }\n+              motherFilterMap.put(sampleName, filter);\n             }\n+          }\n         }\n-\n-        // Extract regions\n-        List<Region> regions = new ArrayList<>();\n-        if (isValidParam(query, REGION)) {\n-            regions.addAll(Region.parseRegions(query.getString(REGION.key()), true));\n-            query.remove(REGION.key());\n+        // If not all genotypes are valid, query is not covered\n+        if (!negatedSamples.isEmpty()) {\n+          partialGtIndex = true;\n+        }\n+      }\n+\n+      for (String negatedSample : negatedSamples) {\n+        List<String> negatedGenotypes = new ArrayList<>(validGenotypes);\n+        negatedGenotypes.removeAll(samplesMap.get(negatedSample));\n+        samplesMap.put(negatedSample, negatedGenotypes);\n+      }\n+\n+      if (!partialGtIndex) {\n+        // Do not remove genotypes list if FORMAT is present.\n+        if (!isValidParam(query, SAMPLE_DATA)) {\n+          query.remove(GENOTYPE.key());\n+        }\n+      }\n+    } else if (isValidParam(query, SAMPLE)) {\n+      // Filter by all non negated samples\n+      String samplesStr = query.getString(SAMPLE.key());\n+      queryOperation = VariantQueryUtils.checkOperator(samplesStr);\n+      List<String> samples = VariantQueryUtils.splitValue(samplesStr, queryOperation);\n+      for (String s : samples) {\n+        if (!isNegated(s)) {\n+          samplesMap.put(s, mainGenotypes);\n         }\n+      }\n+\n+      if (!isValidParam(query, SAMPLE_DATA)) {\n+        // Do not remove FORMAT\n+        query.remove(SAMPLE.key());\n+      }\n+    } else if (isValidParam(query, SAMPLE_MENDELIAN_ERROR)) {\n+      onlyDeNovo = false;\n+      ParsedQuery<String> mendelianError = splitValue(query, SAMPLE_MENDELIAN_ERROR);\n+      mendelianErrorSet = new HashSet<>(mendelianError.getValues());\n+      queryOperation = mendelianError.getOperation();\n+      for (String s : mendelianErrorSet) {\n+        // Return any genotype\n+        samplesMap.put(s, mainGenotypes);\n+      }\n+      query.remove(SAMPLE_MENDELIAN_ERROR.key());\n+      // Reading any MendelianError could return variants from GT=0/0, which is not annotated in the SampleIndex,\n+      // so the index is partial.\n+      partialIndex = true;\n+    } else if (isValidParam(query, SAMPLE_DE_NOVO)) {\n+      onlyDeNovo = true;\n+      ParsedQuery<String> sampleDeNovo = splitValue(query, SAMPLE_DE_NOVO);\n+      mendelianErrorSet = new HashSet<>(sampleDeNovo.getValues());\n+      queryOperation = sampleDeNovo.getOperation();\n+      for (String s : mendelianErrorSet) {\n+        // Return any genotype\n+        samplesMap.put(s, mainGenotypes);\n+      }\n+      query.remove(SAMPLE_DE_NOVO.key());\n+      //} else if (isValidParam(query, FILE)) {\n+      // Add FILEs filter ?\n+    } else {\n+      throw new IllegalStateException(\"Unable to query SamplesIndex\");\n+    }\n \n-        if (isValidParam(query, ANNOT_GENE_REGIONS)) {\n-            regions.addAll(Region.parseRegions(query.getString(ANNOT_GENE_REGIONS.key()), true));\n-            if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE) || isValidParam(query, ANNOT_BIOTYPE)) {\n-                query.put(ANNOT_GENE_REGIONS.key(), SKIP_GENE_REGIONS);\n-            } else {\n-                query.remove(ANNOT_GENE_REGIONS.key());\n-                query.remove(GENE.key());\n-            }\n+    boolean partialFilesIndex = false;\n+    if (!negatedGenotypesSamples.isEmpty() || !parentsInQuery.isEmpty()) {\n+      Set<Integer> sampleFiles = new HashSet<>(samplesMap.size());\n+      for (String sample : samplesMap.keySet()) {\n+        Integer sampleId = metadataManager.getSampleId(studyId, sample);\n+        sampleFiles.addAll(metadataManager.getSampleMetadata(studyId, sampleId).getFiles());\n+      }\n+\n+      // If the file of any other sample is not between the files of the samples in the query, mark as partial\n+      for (String sample : negatedGenotypesSamples) {\n+        Integer sampleId = metadataManager.getSampleId(studyId, sample);\n+        for (Integer file : metadataManager.getSampleMetadata(studyId, sampleId).getFiles()) {\n+          if (!sampleFiles.contains(file)) {\n+            partialFilesIndex = true;\n+            break;\n+          }\n         }\n-        List<List<Region>> regionGroups = groupRegions(regions);\n+      }\n+      // If the file of any parent is not between the files of the samples in the query, mark as partial\n+      for (String sample : parentsInQuery) {\n+        Integer sampleId = metadataManager.getSampleId(studyId, sample);\n+        for (Integer file : metadataManager.getSampleMetadata(studyId, sampleId).getFiles()) {\n+          if (!sampleFiles.contains(file)) {\n+            partialFilesIndex = true;\n+            break;\n+          }\n+        }\n+      }\n \n-        return new SampleIndexQuery(regionGroups, variantTypes, study, samplesMap, multiFileSamples, negatedSamples,\n-                fatherFilterMap, motherFilterMap,\n-                fileIndexMap, annotationIndexQuery, mendelianErrorSet, onlyDeNovo, queryOperation);\n     }\n+    Map<String, Values<SampleFileIndexQuery>> fileIndexMap = new HashMap<>(samplesMap.size());\n+    for (String sample : samplesMap.keySet()) {\n+      Values<SampleFileIndexQuery> fileIndexQuery =\n+          parseFilesQuery(query, studyId, sample, multiFileSamples.contains(sample), partialFilesIndex);\n \n-    /**\n-     * Merge and group regions by chunk start.\n-     * Concurrent groups of regions are merged into one single group.\n-     * Resulting groups are sorted using {@link VariantQueryUtils#REGION_COMPARATOR}.\n-     * Each group will be translated to a SCAN.\n-     *\n-     * @param regions List of regions to group\n-     * @return Grouped regions\n-     */\n-    public static List<List<Region>> groupRegions(List<Region> regions) {\n-        regions = mergeRegions(regions);\n-        List<List<Region>> regionGroups = new ArrayList<>(regions\n-                .stream()\n-                .collect(Collectors.groupingBy(r -> r.getChromosome() + \"_\" + SampleIndexSchema.getChunkStart(r.getStart())))\n-                .values());\n-\n-        if (!regionGroups.isEmpty()) {\n-            regionGroups.forEach(l -> l.sort(REGION_COMPARATOR));\n-            regionGroups.sort(Comparator.comparing(l -> l.get(0), REGION_COMPARATOR));\n-\n-            //Merge consecutive groups\n-            Iterator<List<Region>> iterator = regionGroups.iterator();\n-            List<Region> prevGroup = iterator.next();\n-            while (iterator.hasNext()) {\n-                List<Region> group = iterator.next();\n-                Region prevRegion = prevGroup.get(prevGroup.size() - 1);\n-                Region region = group.get(0);\n-                // Merge if the distance between groups is less than 1 batch size\n-                // TODO: This rule could be changed to reduce the number of small queries, even if more data is fetched.\n-                if (region.getChromosome().equals(prevRegion.getChromosome())\n-                        && Math.abs(region.getStart() - prevRegion.getEnd()) < SampleIndexSchema.BATCH_SIZE) {\n-                    // Merge groups\n-                    prevGroup.addAll(group);\n-                    iterator.remove();\n-                } else {\n-                    prevGroup = group;\n-                }\n-            }\n-        }\n-        return regionGroups;\n+      fileIndexMap.put(sample, fileIndexQuery);\n     }\n \n-    protected static boolean hasNegatedGenotypeFilter(QueryOperation queryOperation, List<String> gts) {\n-        boolean anyNegated = false;\n-        for (String gt : gts) {\n-            if (queryOperation == QueryOperation.OR && !SampleIndexSchema.validGenotype(gt)) {\n-                // Invalid genotypes (i.e. genotypes not in the index) are not allowed in OR queries\n-                throw new IllegalStateException(\"Genotype '\" + gt + \"' not in the SampleIndex.\");\n-            }\n-            anyNegated |= isNegated(gt);\n+    boolean allSamplesAnnotated = true;\n+    if (negatedGenotypesSamples.isEmpty()) {\n+      for (String sample : samplesMap.keySet()) {\n+        Integer sampleId = metadataManager.getSampleId(studyId, sample);\n+        SampleMetadata sampleMetadata = metadataManager.getSampleMetadata(studyId, sampleId);\n+        if (!SampleIndexDBAdaptor.getSampleIndexAnnotationStatus(sampleMetadata).equals(TaskMetadata.Status.READY)) {\n+          allSamplesAnnotated = false;\n+          break;\n         }\n-        return anyNegated;\n+      }\n+    } else {\n+      allSamplesAnnotated = false;\n     }\n \n-    /**\n-     * Determine which samples are valid children.\n-     *\n-     * i.e. sample with non negated genotype filter and parents in the query\n-     *\n-     * @param gtMap Genotype filter map\n-     * @param queryOperation Query operation\n-     * @param parentsMap Parents map\n-     * @return Set with all children from the query\n-     */\n-    protected Set<String> findChildren(Map<String, List<String>> gtMap, QueryOperation queryOperation,\n-                                              Map<String, List<String>> parentsMap) {\n-        Set<String> childrenSet = new HashSet<>(parentsMap.size());\n-        for (Map.Entry<String, List<String>> entry : parentsMap.entrySet()) {\n-            String child = entry.getKey();\n-            List<String> parents = entry.getValue();\n-\n-            if (hasNegatedGenotypeFilter(queryOperation, gtMap.get(child))) {\n-                // Discard children with negated iterators\n-                continue;\n-            }\n-\n-            // Remove parents not in query\n-            for (int i = 0; i < parents.size(); i++) {\n-                String parent = parents.get(i);\n-                if (!gtMap.containsKey(parent)) {\n-                    parents.set(i, null);\n-                }\n-            }\n-\n-            String father = parents.get(0);\n-            String mother = parents.get(1);\n-            if (father != null || mother != null) {\n-                // Is a child if has any parent\n-                childrenSet.add(child);\n-            }\n+    boolean completeIndex = allSamplesAnnotated && !partialIndex;\n+    SampleAnnotationIndexQuery annotationIndexQuery = parseAnnotationIndexQuery(query, completeIndex);\n+    Set<VariantType> variantTypes = null;\n+    if (isValidParam(query, TYPE)) {\n+      List<String> typesStr = query.getAsStringList(VariantQueryParam.TYPE.key());\n+      if (!typesStr.isEmpty()) {\n+        variantTypes = new HashSet<>(typesStr.size());\n+        for (String type : typesStr) {\n+          variantTypes.add(VariantType.valueOf(type));\n+        }\n+        if (variantTypes.contains(VariantType.COPY_NUMBER_GAIN)) {\n+          // Can not distinguish between COPY_NUMBER_GAIN and COPY_NUMBER. Filter only by COPY_NUMBER\n+          variantTypes.remove(VariantType.COPY_NUMBER_GAIN);\n+          variantTypes.add(VariantType.COPY_NUMBER);\n+        }\n+        if (variantTypes.contains(VariantType.COPY_NUMBER_LOSS)) {\n+          // Can not distinguish between COPY_NUMBER_LOSS and COPY_NUMBER. Filter only by COPY_NUMBER\n+          variantTypes.remove(VariantType.COPY_NUMBER_LOSS);\n+          variantTypes.add(VariantType.COPY_NUMBER);\n         }\n-        return childrenSet;\n+      }\n+      if (!hasCopyNumberGainFilter(typesStr) && !hasCopyNumberLossFilter(typesStr)) {\n+        query.remove(TYPE.key());\n+      }\n     }\n \n-    protected static boolean[] buildParentGtFilter(List<String> parentGts, boolean includeDiscrepancies, boolean parentInSeparatedFile) {\n-        boolean[] filter = new boolean[GenotypeCodec.NUM_CODES]; // all false by default\n-        for (String gt : parentGts) {\n-            filter[GenotypeCodec.encode(gt)] = true;\n-        }\n-        if (includeDiscrepancies) {\n-            filter[GenotypeCodec.DISCREPANCY_SIMPLE] = true;\n-            filter[GenotypeCodec.DISCREPANCY_ANY] = true;\n+    // Extract regions\n+    List<Region> regions = new ArrayList<>();\n+    if (isValidParam(query, REGION)) {\n+      regions.addAll(Region.parseRegions(query.getString(REGION.key()), true));\n+      query.remove(REGION.key());\n+    }\n+\n+    if (isValidParam(query, ANNOT_GENE_REGIONS)) {\n+      regions.addAll(Region.parseRegions(query.getString(ANNOT_GENE_REGIONS.key()), true));\n+      if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE) || isValidParam(query, ANNOT_BIOTYPE)) {\n+        query.put(ANNOT_GENE_REGIONS.key(), SKIP_GENE_REGIONS);\n+      } else {\n+        query.remove(ANNOT_GENE_REGIONS.key());\n+        query.remove(GENE.key());\n+      }\n+    }\n+    List<List<Region>> regionGroups = groupRegions(regions);\n+\n+    return new SampleIndexQuery(regionGroups, variantTypes, study, samplesMap, multiFileSamples, negatedSamples,\n+        fatherFilterMap, motherFilterMap,\n+        fileIndexMap, annotationIndexQuery, mendelianErrorSet, onlyDeNovo, queryOperation);\n+  }\n+\n+  /**\n+   * Merge and group regions by chunk start.\n+   * Concurrent groups of regions are merged into one single group.\n+   * Resulting groups are sorted using {@link VariantQueryUtils#REGION_COMPARATOR}.\n+   * Each group will be translated to a SCAN.\n+   *\n+   * @param regions List of regions to group\n+   * @return Grouped regions\n+   */\n+  public static List<List<Region>> groupRegions(List<Region> regions) {\n+    regions = mergeRegions(regions);\n+    List<List<Region>> regionGroups = new ArrayList<>(regions\n+        .stream()\n+        .collect(Collectors.groupingBy(r -> r.getChromosome() + \"_\" + SampleIndexSchema.getChunkStart(r.getStart())))\n+        .values());\n+\n+    if (!regionGroups.isEmpty()) {\n+      regionGroups.forEach(l -> l.sort(REGION_COMPARATOR));\n+      regionGroups.sort(Comparator.comparing(l -> l.get(0), REGION_COMPARATOR));\n+\n+      //Merge consecutive groups\n+      Iterator<List<Region>> iterator = regionGroups.iterator();\n+      List<Region> prevGroup = iterator.next();\n+      while (iterator.hasNext()) {\n+        List<Region> group = iterator.next();\n+        Region prevRegion = prevGroup.get(prevGroup.size() - 1);\n+        Region region = group.get(0);\n+        // Merge if the distance between groups is less than 1 batch size\n+        // TODO: This rule could be changed to reduce the number of small queries, even if more data is fetched.\n+        if (region.getChromosome().equals(prevRegion.getChromosome())\n+            && Math.abs(region.getStart() - prevRegion.getEnd()) < SampleIndexSchema.BATCH_SIZE) {\n+          // Merge groups\n+          prevGroup.addAll(group);\n+          iterator.remove();\n+        } else {\n+          prevGroup = group;\n         }\n-        if (!parentInSeparatedFile) {\n-            // If parents were in separated files, missing and hom_ref might be registered as \"unknown\"\n-            if (filter[GenotypeCodec.MISSING_HOM] || filter[GenotypeCodec.HOM_REF_UNPHASED] || filter[GenotypeCodec.HOM_REF_PHASED]) {\n-                filter[GenotypeCodec.UNKNOWN] = true;\n-            }\n+      }\n+    }\n+    return regionGroups;\n+  }\n+\n+  protected static boolean hasNegatedGenotypeFilter(QueryOperation queryOperation, List<String> gts) {\n+    boolean anyNegated = false;\n+    for (String gt : gts) {\n+      if (queryOperation == QueryOperation.OR && !SampleIndexSchema.validGenotype(gt)) {\n+        // Invalid genotypes (i.e. genotypes not in the index) are not allowed in OR queries\n+        throw new IllegalStateException(\"Genotype '\" + gt + \"' not in the SampleIndex.\");\n+      }\n+      anyNegated |= isNegated(gt);\n+    }\n+    return anyNegated;\n+  }\n+\n+  /**\n+   * Determine which samples are valid children.\n+   * <p>\n+   * i.e. sample with non negated genotype filter and parents in the query\n+   *\n+   * @param gtMap          Genotype filter map\n+   * @param queryOperation Query operation\n+   * @param parentsMap     Parents map\n+   * @return Set with all children from the query\n+   */\n+  protected Set<String> findChildren(Map<String, List<String>> gtMap, QueryOperation queryOperation,\n+                                     Map<String, List<String>> parentsMap) {\n+    Set<String> childrenSet = new HashSet<>(parentsMap.size());\n+    for (Map.Entry<String, List<String>> entry : parentsMap.entrySet()) {\n+      String child = entry.getKey();\n+      List<String> parents = entry.getValue();\n+\n+      if (hasNegatedGenotypeFilter(queryOperation, gtMap.get(child))) {\n+        // Discard children with negated iterators\n+        continue;\n+      }\n+\n+      // Remove parents not in query\n+      for (int i = 0; i < parents.size(); i++) {\n+        String parent = parents.get(i);\n+        if (!gtMap.containsKey(parent)) {\n+          parents.set(i, null);\n         }\n-        return filter;\n+      }\n+\n+      String father = parents.get(0);\n+      String mother = parents.get(1);\n+      if (father != null || mother != null) {\n+        // Is a child if has any parent\n+        childrenSet.add(child);\n+      }\n     }\n+    return childrenSet;\n+  }\n \n-    public static boolean isFullyCoveredParentFilter(boolean[] filter) {\n-        for (int i = 0; i < filter.length; i++) {\n-            if (filter[i]) {\n-                if (GenotypeCodec.isAmbiguousCode(i)) {\n-                    return false;\n-                }\n-            }\n+  protected static boolean[] buildParentGtFilter(List<String> parentGts, boolean includeDiscrepancies, boolean parentInSeparatedFile) {\n+    boolean[] filter = new boolean[GenotypeCodec.NUM_CODES]; // all false by default\n+    for (String gt : parentGts) {\n+      filter[GenotypeCodec.encode(gt)] = true;\n+    }\n+    if (includeDiscrepancies) {\n+      filter[GenotypeCodec.DISCREPANCY_SIMPLE] = true;\n+      filter[GenotypeCodec.DISCREPANCY_ANY] = true;\n+    }\n+    if (!parentInSeparatedFile) {\n+      // If parents were in separated files, missing and hom_ref might be registered as \"unknown\"\n+      if (filter[GenotypeCodec.MISSING_HOM] || filter[GenotypeCodec.HOM_REF_UNPHASED] || filter[GenotypeCodec.HOM_REF_PHASED]) {\n+        filter[GenotypeCodec.UNKNOWN] = true;\n+      }\n+    }\n+    return filter;\n+  }\n+\n+  public static boolean isFullyCoveredParentFilter(boolean[] filter) {\n+    for (int i = 0; i < filter.length; i++) {\n+      if (filter[i]) {\n+        if (GenotypeCodec.isAmbiguousCode(i)) {\n+          return false;\n         }\n-        return true;\n+      }\n     }\n+    return true;\n+  }\n \n \n-    protected Values<SampleFileIndexQuery> parseFilesQuery(Query query, int studyId, String sample,\n+  protected Values<SampleFileIndexQuery> parseFilesQuery(Query query, int studyId, String sample,\n                                                          boolean multiFileSample, boolean partialFilesIndex) {\n-        return parseFilesQuery(query, sample, multiFileSample, partialFilesIndex, s -> {\n-            Integer sampleId = metadataManager.getSampleId(studyId, s);\n-            List<Integer> fileIds = metadataManager.getFileIdsFromSampleId(studyId, sampleId);\n-            List<String> fileNames = new ArrayList<>(fileIds.size());\n-            for (Integer fileId : fileIds) {\n-                fileNames.add(metadataManager.getFileName(studyId, fileId));\n-            }\n-            return fileNames;\n-        });\n-    }\n-\n-    protected Values<SampleFileIndexQuery> parseFilesQuery(Query query, String sample, boolean multiFileSample, boolean partialFilesIndex,\n+    return parseFilesQuery(query, sample, multiFileSample, partialFilesIndex, s -> {\n+      Integer sampleId = metadataManager.getSampleId(studyId, s);\n+      List<Integer> fileIds = metadataManager.getFileIdsFromSampleId(studyId, sampleId);\n+      List<String> fileNames = new ArrayList<>(fileIds.size());\n+      for (Integer fileId : fileIds) {\n+        fileNames.add(metadataManager.getFileName(studyId, fileId));\n+      }\n+      return fileNames;\n+    });\n+  }\n+\n+  protected Values<SampleFileIndexQuery> parseFilesQuery(Query query, String sample, boolean multiFileSample, boolean partialFilesIndex,\n                                                          Function<String, List<String>> filesFromSample) {\n-        ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> fileDataParsedQuery = parseFileData(query);\n-        List<String> filesFromFileData = fileDataParsedQuery.getValues(KeyValues::getKey);\n-\n-        boolean splitFileDataQuery = false;\n-        if (fileDataParsedQuery.getOperation() == QueryOperation.AND) {\n-            splitFileDataQuery = true;\n-        } else if (fileDataParsedQuery.getOperation() == QueryOperation.OR && multiFileSample) {\n-            List<String> files = filesFromSample.apply(sample);\n-            if (files.containsAll(filesFromFileData)) {\n-                // All samples from the query are from the same sample (aka multi-query sample)\n-                splitFileDataQuery = true;\n-            }\n-        }\n-        if (splitFileDataQuery) {\n-            List<SampleFileIndexQuery> fileIndexQueries = new ArrayList<>(filesFromFileData.size());\n-            boolean fileDataCovered = true;\n-            for (String fileFromFileData : filesFromFileData) {\n-                Query subQuery = new Query(query);\n+    ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> fileDataParsedQuery = parseFileData(query);\n+    List<String> filesFromFileData = fileDataParsedQuery.getValues(KeyValues::getKey);\n+\n+    boolean splitFileDataQuery = false;\n+    if (fileDataParsedQuery.getOperation() == QueryOperation.AND) {\n+      splitFileDataQuery = true;\n+    } else if (fileDataParsedQuery.getOperation() == QueryOperation.OR && multiFileSample) {\n+      List<String> files = filesFromSample.apply(sample);\n+      if (files.containsAll(filesFromFileData)) {\n+        // All samples from the query are from the same sample (aka multi-query sample)\n+        splitFileDataQuery = true;\n+      }\n+    }\n+    if (splitFileDataQuery) {\n+      List<SampleFileIndexQuery> fileIndexQueries = new ArrayList<>(filesFromFileData.size());\n+      boolean fileDataCovered = true;\n+      for (String fileFromFileData : filesFromFileData) {\n+        Query subQuery = new Query(query);\n //                    subQuery.remove(FILE.key());\n-                subQuery.put(FILE_DATA.key(), fileDataParsedQuery.getValue(kv -> kv.getKey().equals(fileFromFileData)).toQuery());\n-                fileIndexQueries.add(parseFileQuery(subQuery, sample, multiFileSample, partialFilesIndex, filesFromSample));\n-                if (isValidParam(subQuery, FILE_DATA)) {\n-                    // This subquery did not remove the fileData, so it's not fully covered. Can't remove the fileData filter.\n-                    fileDataCovered = false;\n-                }\n-            }\n-            if (fileDataCovered && !partialFilesIndex) {\n-                query.remove(FILE_DATA.key());\n-            }\n-            return new Values<>(fileDataParsedQuery.getOperation(), fileIndexQueries);\n+        subQuery.put(FILE_DATA.key(), fileDataParsedQuery.getValue(kv -> kv.getKey().equals(fileFromFileData)).toQuery());\n+        fileIndexQueries.add(parseFileQuery(subQuery, sample, multiFileSample, partialFilesIndex, filesFromSample));\n+        if (isValidParam(subQuery, FILE_DATA)) {\n+          // This subquery did not remove the fileData, so it's not fully covered. Can't remove the fileData filter.\n+          fileDataCovered = false;\n         }\n-        return new Values<>(null,\n-                Collections.singletonList(parseFileQuery(query, sample, multiFileSample, partialFilesIndex, filesFromSample)));\n+      }\n+      if (fileDataCovered && !partialFilesIndex) {\n+        query.remove(FILE_DATA.key());\n+      }\n+      return new Values<>(fileDataParsedQuery.getOperation(), fileIndexQueries);\n     }\n+    return new Values<>(null,\n+        Collections.singletonList(parseFileQuery(query, sample, multiFileSample, partialFilesIndex, filesFromSample)));\n+  }\n \n-    protected SampleFileIndexQuery parseFileQuery(Query query, String sample, boolean multiFileSample, boolean partialFilesIndex,\n-                                                  Function<String, List<String>> filesFromSample) {\n-        short fileIndexMask = 0;\n-        List<String> files = null;\n+  protected SampleFileIndexQuery parseFileQuery(Query query, String sample, boolean multiFileSample, boolean partialFilesIndex,\n+                                                Function<String, List<String>> filesFromSample) {\n+    short fileIndexMask = 0;\n+    List<String> files = null;\n \n-        Set<Integer> typeCodes = Collections.emptySet();\n+    Set<Integer> typeCodes = Collections.emptySet();\n \n-        if (isValidParam(query, TYPE)) {\n-            List<String> types = new ArrayList<>(query.getAsStringList(VariantQueryParam.TYPE.key()));\n-            if (!types.isEmpty()) {\n-                typeCodes = new HashSet<>(types.size());\n-                fileIndexMask |= VariantFileIndexConverter.TYPE_MASK;\n+    if (isValidParam(query, TYPE)) {\n+      List<String> types = new ArrayList<>(query.getAsStringList(VariantQueryParam.TYPE.key()));\n+      if (!types.isEmpty()) {\n+        typeCodes = new HashSet<>(types.size());\n+        fileIndexMask |= VariantFileIndexConverter.TYPE_MASK;\n \n-                for (String type : types) {\n-                    typeCodes.add(VariantFileIndexConverter.getTypeCode(VariantType.valueOf(type.toUpperCase())));\n-                }\n-            }\n-            if (!typeCodes.contains(TYPE_OTHER_CODE)\n-                    && !hasCopyNumberGainFilter(types)\n-                    && !hasCopyNumberLossFilter(types)) {\n-                query.remove(TYPE.key());\n-            }\n+        for (String type : types) {\n+          typeCodes.add(VariantFileIndexConverter.getTypeCode(VariantType.valueOf(type.toUpperCase())));\n         }\n+      }\n+      if (!typeCodes.contains(TYPE_OTHER_CODE)\n+          && !hasCopyNumberGainFilter(types)\n+          && !hasCopyNumberLossFilter(types)) {\n+        query.remove(TYPE.key());\n+      }\n+    }\n \n-        List<Integer> sampleFilesFilter = new ArrayList<>();\n-        // Can only filter by file if the sample was multiFile\n-        if (multiFileSample) {\n-            // Lazy get files from sample\n-            if (files == null) {\n-                files = filesFromSample.apply(sample);\n-            }\n-            List<String> filesFromQuery;\n-            if (isValidParam(query, FILE)) {\n-                ParsedQuery<String> filesQuery = splitValue(query, FILE);\n-                filesFromQuery = filesQuery.getValues();\n-            } else if (isValidParam(query, FILE_DATA)) {\n-                ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> fileData = parseFileData(query);\n-                filesFromQuery = fileData.getValues(KeyValues::getKey);\n-            } else {\n-                filesFromQuery = null;\n-            }\n-            if (filesFromQuery != null) {\n-                for (String file : filesFromQuery) {\n-                    int indexOf = files.indexOf(file);\n-                    if (indexOf >= 0) {\n-                        sampleFilesFilter.add(indexOf);\n-                    }\n-                }\n-                fileIndexMask |= VariantFileIndexConverter.FILE_IDX_MASK;\n-            }\n+    List<Integer> sampleFilesFilter = new ArrayList<>();\n+    // Can only filter by file if the sample was multiFile\n+    if (multiFileSample) {\n+      // Lazy get files from sample\n+      if (files == null) {\n+        files = filesFromSample.apply(sample);\n+      }\n+      List<String> filesFromQuery;\n+      if (isValidParam(query, FILE)) {\n+        ParsedQuery<String> filesQuery = splitValue(query, FILE);\n+        filesFromQuery = filesQuery.getValues();\n+      } else if (isValidParam(query, FILE_DATA)) {\n+        ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> fileData = parseFileData(query);\n+        filesFromQuery = fileData.getValues(KeyValues::getKey);\n+      } else {\n+        filesFromQuery = null;\n+      }\n+      if (filesFromQuery != null) {\n+        for (String file : filesFromQuery) {\n+          int indexOf = files.indexOf(file);\n+          if (indexOf >= 0) {\n+            sampleFilesFilter.add(indexOf);\n+          }\n         }\n+        fileIndexMask |= VariantFileIndexConverter.FILE_IDX_MASK;\n+      }\n+    }\n \n-        boolean filterPass = false;\n-        boolean filterPassCovered = false;\n-        if (isValidParam(query, FILTER)) {\n-            Values<String> filterValues = splitValue(query, FILTER);\n-\n-            if (filterValues.size() == 1) {\n-                if (filterValues.get(0).equals(VCFConstants.PASSES_FILTERS_v4)) {\n-                    // PASS\n-                    fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n-                    filterPass = true;\n-                    filterPassCovered = true;\n-                } else if (filterValues.get(0).equals(VariantQueryUtils.NOT + VCFConstants.PASSES_FILTERS_v4)) {\n-                    // !PASS\n-                    fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n-                    filterPassCovered = true;\n-                } else if (!isNegated(filterValues.get(0))) {\n-                    // Non negated filter, other than PASS\n-                    filterPass = false;\n-                    fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n-                }\n-            } else {\n-                if (!filterValues.contains(VCFConstants.PASSES_FILTERS_v4)) {\n-                    if (filterValues.getValues().stream().noneMatch(VariantQueryUtils::isNegated)) {\n-                        // None negated filter, without PASS\n-                        filterPass = false;\n-                        fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n-                    }\n-                } // else --> Mix PASS and other filters. Can not use index\n-            }\n-        }\n-        if (filterPassCovered && !partialFilesIndex) {\n-            query.remove(FILTER.key());\n+    boolean filterPass = false;\n+    boolean filterPassCovered = false;\n+    if (isValidParam(query, FILTER)) {\n+      Values<String> filterValues = splitValue(query, FILTER);\n+\n+      if (filterValues.size() == 1) {\n+        if (filterValues.get(0).equals(VCFConstants.PASSES_FILTERS_v4)) {\n+          // PASS\n+          fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n+          filterPass = true;\n+          filterPassCovered = true;\n+        } else if (filterValues.get(0).equals(VariantQueryUtils.NOT + VCFConstants.PASSES_FILTERS_v4)) {\n+          // !PASS\n+          fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n+          filterPassCovered = true;\n+        } else if (!isNegated(filterValues.get(0))) {\n+          // Non negated filter, other than PASS\n+          filterPass = false;\n+          fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n         }\n+      } else {\n+        if (!filterValues.contains(VCFConstants.PASSES_FILTERS_v4)) {\n+          if (filterValues.getValues().stream().noneMatch(VariantQueryUtils::isNegated)) {\n+            // None negated filter, without PASS\n+            filterPass = false;\n+            fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n+          }\n+        } // else --> Mix PASS and other filters. Can not use index\n+      }\n+    }\n+    if (filterPassCovered && !partialFilesIndex) {\n+      query.remove(FILTER.key());\n+    }\n \n-        RangeQuery qualQuery = null;\n-        if (isValidParam(query, QUAL)) {\n-            String qualValue = query.getString(QUAL.key());\n-            List<String> qualValues = VariantQueryUtils.splitValues(qualValue).getValues();\n-            if (qualValues.size() == 1) {\n+    RangeQuery qualQuery = null;\n+    if (isValidParam(query, QUAL)) {\n+      String qualValue = query.getString(QUAL.key());\n+      List<String> qualValues = VariantQueryUtils.splitValues(qualValue).getValues();\n+      if (qualValues.size() == 1) {\n \n-                fileIndexMask |= VariantFileIndexConverter.QUAL_MASK;\n+        fileIndexMask |= VariantFileIndexConverter.QUAL_MASK;\n \n-                OpValue<String> opValue = parseOpValue(qualValue);\n-                double value = Double.parseDouble(opValue.getValue());\n-                qualQuery = getRangeQuery(opValue.getOp(), value, SampleIndexConfiguration.QUAL_THRESHOLDS, 0, IndexUtils.MAX);\n+        OpValue<String> opValue = parseOpValue(qualValue);\n+        double value = Double.parseDouble(opValue.getValue());\n+        qualQuery = getRangeQuery(opValue.getOp(), value, SampleIndexConfiguration.QUAL_THRESHOLDS, 0, IndexUtils.MAX);\n \n-                if (qualQuery.isExactQuery() && !partialFilesIndex) {\n-                    query.remove(QUAL.key());\n-                }\n-            }\n+        if (qualQuery.isExactQuery() && !partialFilesIndex) {\n+          query.remove(QUAL.key());\n         }\n+      }\n+    }\n \n-        boolean fileDataCovered = true;\n-        RangeQuery dpQuery = null;\n-        if (isValidParam(query, FILE_DATA)) {\n-            //ParsedQuery<KeyValues< FileId , KeyOpValue< INFO , Value >>>\n-            ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> parsedQuery = parseFileData(query);\n-            if (parsedQuery.getOperation() != QueryOperation.OR) {\n-                Map<String, KeyValues<String, KeyOpValue<String, String>>> fileDataMap =\n-                        parsedQuery.getValues().stream().collect(Collectors.toMap(KeyValues::getKey, i -> i));\n-                // Lazy get files from sample\n-                if (files == null) {\n-                    files = filesFromSample.apply(sample);\n-                }\n-                if (!files.containsAll(fileDataMap.keySet())) {\n-                    // Some of the files in FileData filter are not from this sample.\n-                    fileDataCovered = false;\n-                }\n-                for (String file : files) {\n-                    KeyValues<String, KeyOpValue<String, String>> keyValues = fileDataMap.get(file);\n-                    if (keyValues == null) {\n-                        continue;\n-                    }\n-                    for (KeyOpValue<String, String> keyOpValue : keyValues.getValues()) {\n-                        if (keyOpValue.getKey().equals(VCFConstants.DEPTH_KEY)) {\n-                            String op = keyOpValue.getOp();\n-                            double dpValue = Double.parseDouble(keyOpValue.getValue());\n-                            dpQuery = getRangeQuery(op, dpValue, SampleIndexConfiguration.DP_THRESHOLDS, 0, IndexUtils.MAX);\n-                            fileIndexMask |= VariantFileIndexConverter.DP_MASK;\n-                            if (!dpQuery.isExactQuery()) {\n-                                fileDataCovered = false;\n-                            }\n-                        } else if (keyOpValue.getKey().equals(StudyEntry.FILTER)) {\n-                            if (keyOpValue.getValue().equals(VCFConstants.PASSES_FILTERS_v4)) {\n-                                filterPass = true;\n-                                fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n-                            } else {\n-                                // Only covered when filtering by PASS\n-                                fileDataCovered = false;\n-                                Values<String> filterValues = splitValues(keyOpValue.getValue());\n-                                if (!filterValues.contains(VCFConstants.PASSES_FILTERS_v4)) {\n-                                    if (filterValues.getValues().stream().noneMatch(VariantQueryUtils::isNegated)) {\n-                                        // None negated filter, without PASS\n-                                        filterPass = false;\n-                                        fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n-                                    }\n-                                } // else --> Mix PASS and other filters. Can not use index\n-                            }\n-                        } else if (keyOpValue.getKey().equals(StudyEntry.QUAL)) {\n-                            fileIndexMask |= VariantFileIndexConverter.QUAL_MASK;\n-\n-                            double value = Double.parseDouble(keyOpValue.getValue());\n-                            qualQuery = getRangeQuery(keyOpValue.getOp(), value,\n-                                    SampleIndexConfiguration.QUAL_THRESHOLDS, 0, IndexUtils.MAX);\n-                            if (!qualQuery.isExactQuery()) {\n-                                fileDataCovered = false;\n-                            }\n-                        } else {\n-                            // Unknown key\n-                            fileDataCovered = false;\n-                        }\n-                    }\n-                }\n-            } else {\n+    boolean fileDataCovered = true;\n+    RangeQuery dpQuery = null;\n+    if (isValidParam(query, FILE_DATA)) {\n+      //ParsedQuery<KeyValues< FileId , KeyOpValue< INFO , Value >>>\n+      ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> parsedQuery = parseFileData(query);\n+      if (parsedQuery.getOperation() != QueryOperation.OR) {\n+        Map<String, KeyValues<String, KeyOpValue<String, String>>> fileDataMap =\n+            parsedQuery.getValues().stream().collect(Collectors.toMap(KeyValues::getKey, i -> i));\n+        // Lazy get files from sample\n+        if (files == null) {\n+          files = filesFromSample.apply(sample);\n+        }\n+        if (!files.containsAll(fileDataMap.keySet())) {\n+          // Some of the files in FileData filter are not from this sample.\n+          fileDataCovered = false;\n+        }\n+        for (String file : files) {\n+          KeyValues<String, KeyOpValue<String, String>> keyValues = fileDataMap.get(file);\n+          if (keyValues == null) {\n+            continue;\n+          }\n+          for (KeyOpValue<String, String> keyOpValue : keyValues.getValues()) {\n+            if (keyOpValue.getKey().equals(VCFConstants.DEPTH_KEY)) {\n+              String op = keyOpValue.getOp();\n+              double dpValue = Double.parseDouble(keyOpValue.getValue());\n+              dpQuery = getRangeQuery(op, dpValue, SampleIndexConfiguration.DP_THRESHOLDS, 0, IndexUtils.MAX);\n+              fileIndexMask |= VariantFileIndexConverter.DP_MASK;\n+              if (!dpQuery.isExactQuery()) {\n+                fileDataCovered = false;\n+              }\n+            } else if (keyOpValue.getKey().equals(StudyEntry.FILTER)) {\n+              if (keyOpValue.getValue().equals(VCFConstants.PASSES_FILTERS_v4)) {\n+                filterPass = true;\n+                fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n+              } else {\n+                // Only covered when filtering by PASS\n                 fileDataCovered = false;\n+                Values<String> filterValues = splitValues(keyOpValue.getValue());\n+                if (!filterValues.contains(VCFConstants.PASSES_FILTERS_v4)) {\n+                  if (filterValues.getValues().stream().noneMatch(VariantQueryUtils::isNegated)) {\n+                    // None negated filter, without PASS\n+                    filterPass = false;\n+                    fileIndexMask |= VariantFileIndexConverter.FILTER_PASS_MASK;\n+                  }\n+                } // else --> Mix PASS and other filters. Can not use index\n+              }\n+            } else if (keyOpValue.getKey().equals(StudyEntry.QUAL)) {\n+              fileIndexMask |= VariantFileIndexConverter.QUAL_MASK;\n+\n+              double value = Double.parseDouble(keyOpValue.getValue());\n+              qualQuery = getRangeQuery(keyOpValue.getOp(), value,\n+                  SampleIndexConfiguration.QUAL_THRESHOLDS, 0, IndexUtils.MAX);\n+              if (!qualQuery.isExactQuery()) {\n+                fileDataCovered = false;\n+              }\n+            } else {\n+              // Unknown key\n+              fileDataCovered = false;\n             }\n+          }\n         }\n-        if (fileDataCovered && !partialFilesIndex) {\n-            query.remove(FILE_DATA.key());\n-        }\n+      } else {\n+        fileDataCovered = false;\n+      }\n+    }\n+    if (fileDataCovered && !partialFilesIndex) {\n+      query.remove(FILE_DATA.key());\n+    }\n \n-        if (isValidParam(query, SAMPLE_DATA)) {\n-            ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> sampleDataQuery = parseSampleData(query);\n-            QueryOperation sampleDataOp = sampleDataQuery.getOperation();\n-            KeyValues<String, KeyOpValue<String, String>> sampleDataFilter = sampleDataQuery.getValue(kv -> kv.getKey().equals(sample));\n-\n-            if (!sampleDataFilter.isEmpty() && sampleDataOp != QueryOperation.OR) {\n-                for (KeyOpValue<String, String> keyOpValue : sampleDataFilter) {\n-                    if (keyOpValue.getKey().equals(VCFConstants.DEPTH_KEY)) {\n-                        String op = keyOpValue.getOp();\n-                        double dpValue = Double.parseDouble(keyOpValue.getValue());\n-                        dpQuery = getRangeQuery(op, dpValue, SampleIndexConfiguration.DP_THRESHOLDS, 0, IndexUtils.MAX);\n-                        fileIndexMask |= VariantFileIndexConverter.DP_MASK;\n-                        if (dpQuery.isExactQuery() && !partialFilesIndex) {\n-                            if (sampleDataFilter.size() == 1) {\n-                                sampleDataQuery.getValues().remove(sampleDataFilter);\n-                            }\n-                        }\n-                    }\n-                }\n-                if (!partialFilesIndex) {\n-                    if (sampleDataQuery.isEmpty()) {\n-                        query.remove(SAMPLE_DATA.key());\n-                    } else {\n-                        query.put(SAMPLE_DATA.key(), sampleDataQuery.toQuery());\n-                    }\n-                }\n+    if (isValidParam(query, SAMPLE_DATA)) {\n+      ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> sampleDataQuery = parseSampleData(query);\n+      QueryOperation sampleDataOp = sampleDataQuery.getOperation();\n+      KeyValues<String, KeyOpValue<String, String>> sampleDataFilter = sampleDataQuery.getValue(kv -> kv.getKey().equals(sample));\n+\n+      if (!sampleDataFilter.isEmpty() && sampleDataOp != QueryOperation.OR) {\n+        for (KeyOpValue<String, String> keyOpValue : sampleDataFilter) {\n+          if (keyOpValue.getKey().equals(VCFConstants.DEPTH_KEY)) {\n+            String op = keyOpValue.getOp();\n+            double dpValue = Double.parseDouble(keyOpValue.getValue());\n+            dpQuery = getRangeQuery(op, dpValue, SampleIndexConfiguration.DP_THRESHOLDS, 0, IndexUtils.MAX);\n+            fileIndexMask |= VariantFileIndexConverter.DP_MASK;\n+            if (dpQuery.isExactQuery() && !partialFilesIndex) {\n+              if (sampleDataFilter.size() == 1) {\n+                sampleDataQuery.getValues().remove(sampleDataFilter);\n+              }\n             }\n+          }\n+        }\n+        if (!partialFilesIndex) {\n+          if (sampleDataQuery.isEmpty()) {\n+            query.remove(SAMPLE_DATA.key());\n+          } else {\n+            query.put(SAMPLE_DATA.key(), sampleDataQuery.toQuery());\n+          }\n         }\n+      }\n+    }\n \n-        // Build validFileIndex array\n-        boolean[] validFileIndex1 = new boolean[1 << Byte.SIZE];\n-        boolean[] validFileIndex2 = new boolean[1 << Byte.SIZE];\n-\n-        if (fileIndexMask != IndexUtils.EMPTY_MASK) {\n-            boolean hasFileIndexMask1 = IndexUtils.getByte1(fileIndexMask) != IndexUtils.EMPTY_MASK;\n-            boolean hasFileIndexMask2 = IndexUtils.getByte2(fileIndexMask) != IndexUtils.EMPTY_MASK;\n-            int qualMin = qualQuery == null ? 0 : qualQuery.getMinCodeInclusive();\n-            int qualMax = qualQuery == null ? 1 : qualQuery.getMaxCodeExclusive();\n-            int dpMin = dpQuery == null ? 0 : dpQuery.getMinCodeInclusive();\n-            int dpMax = dpQuery == null ? 1 : dpQuery.getMaxCodeExclusive();\n-            if (typeCodes.isEmpty()) {\n-                typeCodes = Collections.singleton(0);\n-            }\n-            if (sampleFilesFilter.isEmpty()) {\n-                sampleFilesFilter = Collections.singletonList(null);\n-            }\n-            for (Integer typeCode : typeCodes) {\n-                for (Integer fileId : sampleFilesFilter) {\n-                    for (int q = qualMin; q < qualMax; q++) {\n-                        for (int dp = dpMin; dp < dpMax; dp++) {\n-\n-                            int validFile = 0;\n-                            if (filterPass) {\n-                                validFile |= VariantFileIndexConverter.FILTER_PASS_MASK;\n-                            }\n-\n-                            if (fileId != null) {\n-                                validFile |= fileId << VariantFileIndexConverter.FILE_POSITION_SHIFT;\n-                            }\n-                            validFile |= typeCode << VariantFileIndexConverter.TYPE_SHIFT;\n-                            validFile |= q << VariantFileIndexConverter.QUAL_SHIFT;\n-                            validFile |= dp << VariantFileIndexConverter.DP_SHIFT;\n-\n-                            if (hasFileIndexMask1) {\n-                                validFileIndex1[IndexUtils.getByte1(validFile)] = true;\n-                            }\n-                            if (hasFileIndexMask2) {\n-                                validFileIndex2[IndexUtils.getByte2(validFile)] = true;\n-                            }\n-                        }\n-                    }\n-                }\n+    // Build validFileIndex array\n+    boolean[] validFileIndex1 = new boolean[1 << Byte.SIZE];\n+    boolean[] validFileIndex2 = new boolean[1 << Byte.SIZE];\n+\n+    if (fileIndexMask != IndexUtils.EMPTY_MASK) {\n+      boolean hasFileIndexMask1 = IndexUtils.getByte1(fileIndexMask) != IndexUtils.EMPTY_MASK;\n+      boolean hasFileIndexMask2 = IndexUtils.getByte2(fileIndexMask) != IndexUtils.EMPTY_MASK;\n+      int qualMin = qualQuery == null ? 0 : qualQuery.getMinCodeInclusive();\n+      int qualMax = qualQuery == null ? 1 : qualQuery.getMaxCodeExclusive();\n+      int dpMin = dpQuery == null ? 0 : dpQuery.getMinCodeInclusive();\n+      int dpMax = dpQuery == null ? 1 : dpQuery.getMaxCodeExclusive();\n+      if (typeCodes.isEmpty()) {\n+        typeCodes = Collections.singleton(0);\n+      }\n+      if (sampleFilesFilter.isEmpty()) {\n+        sampleFilesFilter = Collections.singletonList(null);\n+      }\n+      for (Integer typeCode : typeCodes) {\n+        for (Integer fileId : sampleFilesFilter) {\n+          for (int q = qualMin; q < qualMax; q++) {\n+            for (int dp = dpMin; dp < dpMax; dp++) {\n+\n+              int validFile = 0;\n+              if (filterPass) {\n+                validFile |= VariantFileIndexConverter.FILTER_PASS_MASK;\n+              }\n+\n+              if (fileId != null) {\n+                validFile |= fileId << VariantFileIndexConverter.FILE_POSITION_SHIFT;\n+              }\n+              validFile |= typeCode << VariantFileIndexConverter.TYPE_SHIFT;\n+              validFile |= q << VariantFileIndexConverter.QUAL_SHIFT;\n+              validFile |= dp << VariantFileIndexConverter.DP_SHIFT;\n+\n+              if (hasFileIndexMask1) {\n+                validFileIndex1[IndexUtils.getByte1(validFile)] = true;\n+              }\n+              if (hasFileIndexMask2) {\n+                validFileIndex2[IndexUtils.getByte2(validFile)] = true;\n+              }\n             }\n+          }\n         }\n+      }\n+    }\n \n-        return new SampleFileIndexQuery(sample, fileIndexMask, qualQuery, dpQuery, validFileIndex1, validFileIndex2);\n+    return new SampleFileIndexQuery(sample, fileIndexMask, qualQuery, dpQuery, validFileIndex1, validFileIndex2);\n+  }\n+\n+  private boolean hasCopyNumberGainFilter(List<String> types) {\n+    return types.contains(VariantType.COPY_NUMBER_GAIN.name()) && !types.contains(VariantType.COPY_NUMBER.name());\n+  }\n+\n+  private boolean hasCopyNumberLossFilter(List<String> types) {\n+    return types.contains(VariantType.COPY_NUMBER_LOSS.name()) && !types.contains(VariantType.COPY_NUMBER.name());\n+  }\n+\n+  protected SampleAnnotationIndexQuery parseAnnotationIndexQuery(Query query) {\n+    return parseAnnotationIndexQuery(query, false);\n+  }\n+\n+  /**\n+   * Builds the SampleAnnotationIndexQuery given a VariantQuery.\n+   *\n+   * @param query         Input VariantQuery. If the index is complete, covered filters could be removed from here.\n+   * @param completeIndex Indicates if the annotation index is complete for the samples in the query.\n+   *                      Otherwise, the index can only be used as a hint, and should be completed with further filtering.\n+   * @return SampleAnnotationIndexQuery\n+   */\n+  protected SampleAnnotationIndexQuery parseAnnotationIndexQuery(Query query, boolean completeIndex) {\n+    byte annotationIndex = 0;\n+    byte biotypeMask = 0;\n+    short consequenceTypeMask = 0;\n+    byte clinicalMask = 0;\n+\n+    Boolean intergenic = null;\n+\n+    if (!isValidParam(query, REGION)) {\n+      ParsedVariantQuery.VariantQueryXref variantQueryXref = VariantQueryParser.parseXrefs(query);\n+      if (!variantQueryXref.getGenes().isEmpty()\n+          && variantQueryXref.getIds().isEmpty()\n+          && variantQueryXref.getOtherXrefs().isEmpty()\n+          && variantQueryXref.getVariants().isEmpty()) {\n+        // If only filtering by genes, is not intergenic.\n+        intergenic = false;\n+      }\n     }\n \n-    private boolean hasCopyNumberGainFilter(List<String> types) {\n-        return types.contains(VariantType.COPY_NUMBER_GAIN.name()) && !types.contains(VariantType.COPY_NUMBER.name());\n+    BiotypeConsquenceTypeFlagCombination combination = BiotypeConsquenceTypeFlagCombination.fromQuery(query);\n+    boolean btCovered = false;\n+    boolean ctCovered = false;\n+\n+    if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE)) {\n+      List<String> soNames = query.getAsStringList(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key());\n+      soNames = soNames.stream()\n+          .map(ct -> ConsequenceTypeMappings.accessionToTerm.get(VariantQueryUtils.parseConsequenceType(ct)))\n+          .collect(Collectors.toList());\n+      if (!soNames.contains(VariantAnnotationUtils.INTERGENIC_VARIANT)\n+          && !soNames.contains(VariantAnnotationUtils.REGULATORY_REGION_VARIANT)\n+          && !soNames.contains(VariantAnnotationUtils.TF_BINDING_SITE_VARIANT)) {\n+        // All ct values but \"intergenic_variant\" and \"regulatory_region_variant\" are in genes (i.e. non-intergenic)\n+        intergenic = false;\n+      } else if (soNames.size() == 1 && soNames.contains(VariantAnnotationUtils.INTERGENIC_VARIANT)) {\n+        intergenic = true;\n+      }\n+      boolean ctFilterCoveredBySummary = false;\n+      boolean ctBtCombinationCoveredBySummary = false;\n+      if (LOF_SET.containsAll(soNames)) {\n+        ctFilterCoveredBySummary = soNames.size() == LOF_SET.size();\n+        annotationIndex |= LOF_MASK;\n+        // If all present, remove consequenceType filter\n+        if (completeIndex && LOF_SET.size() == soNames.size()) {\n+          // Ensure not filtering by gene, and not combining with other params\n+          if (!isValidParam(query, GENE) && simpleCombination(combination)) {\n+            query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n+          }\n+        }\n+      }\n+      if (LOF_EXTENDED_SET.containsAll(soNames)) {\n+        boolean proteinCodingOnly = query.getString(ANNOT_BIOTYPE.key()).equals(VariantAnnotationUtils.PROTEIN_CODING);\n+        ctFilterCoveredBySummary = soNames.size() == LOF_EXTENDED_SET.size();\n+        annotationIndex |= LOF_EXTENDED_MASK;\n+        // If all present, remove consequenceType filter\n+        if (LOF_EXTENDED_SET.size() == soNames.size()) {\n+          // Ensure not filtering by gene, and not combining with other params\n+          if (completeIndex && !isValidParam(query, GENE)) {\n+            if (simpleCombination(combination)) {\n+              query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n+            } else if (proteinCodingOnly && combination.equals(BiotypeConsquenceTypeFlagCombination.BIOTYPE_CT)) {\n+              query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n+              query.remove(ANNOT_BIOTYPE.key());\n+              ctBtCombinationCoveredBySummary = true;\n+            }\n+          }\n+        }\n+        if (proteinCodingOnly) {\n+          annotationIndex |= LOFE_PROTEIN_CODING_MASK;\n+        }\n+      }\n+      if (soNames.size() == 1 && soNames.get(0).equals(VariantAnnotationUtils.MISSENSE_VARIANT)) {\n+        ctFilterCoveredBySummary = true;\n+        ctCovered = true;\n+        annotationIndex |= MISSENSE_VARIANT_MASK;\n+        // Ensure not filtering by gene, and not combining with other params\n+        if (completeIndex && !isValidParam(query, GENE)) {\n+          if (simpleCombination(combination)) {\n+            query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n+          }\n+        }\n+      }\n+\n+      // Do not use ctIndex if the CT filter is covered by the summary\n+      // Use the ctIndex if:\n+      // - The CtFilter is not covered by the summary\n+      // - The query has the combination CT+BT , and it is not covered by the summary\n+      boolean useCtIndexFilter = !ctFilterCoveredBySummary || (!ctBtCombinationCoveredBySummary && combination.isBiotype());\n+      if (useCtIndexFilter) {\n+        ctCovered = completeIndex;\n+        for (String soName : soNames) {\n+          short mask = getMaskFromSoName(soName);\n+          if (mask == IndexUtils.EMPTY_MASK) {\n+            // If any element is not in the index, do not use this filter\n+            consequenceTypeMask = IndexUtils.EMPTY_MASK;\n+            ctCovered = false;\n+            break;\n+          }\n+          consequenceTypeMask |= mask;\n+          // Some CT filter values are not precise, so the query is not covered.\n+          ctCovered &= !isImpreciseCtMask(mask);\n+        }\n+        // ConsequenceType filter is covered by index\n+        if (ctCovered) {\n+          if (!isValidParam(query, GENE) && simpleCombination(combination)) {\n+            query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n+          }\n+        }\n+      }\n     }\n \n-    private boolean hasCopyNumberLossFilter(List<String> types) {\n-        return types.contains(VariantType.COPY_NUMBER_LOSS.name()) && !types.contains(VariantType.COPY_NUMBER.name());\n+    if (isValidParam(query, ANNOT_BIOTYPE)) {\n+      // All biotype values are in genes (i.e. non-intergenic)\n+      intergenic = false;\n+      boolean biotypeFilterCoveredBySummary = false;\n+      List<String> biotypes = query.getAsStringList(VariantQueryParam.ANNOT_BIOTYPE.key());\n+      if (BIOTYPE_SET.containsAll(biotypes)) {\n+        biotypeFilterCoveredBySummary = BIOTYPE_SET.size() == biotypes.size();\n+        annotationIndex |= PROTEIN_CODING_MASK;\n+        // If all present, remove biotype filter\n+        if (completeIndex && BIOTYPE_SET.size() == biotypes.size()) {\n+          // Ensure not filtering by gene, and not combining with other params\n+          if (!isValidParam(query, GENE) && simpleCombination(combination)) {\n+            query.remove(ANNOT_BIOTYPE.key());\n+          }\n+        }\n+      }\n+\n+      boolean useBtIndexFilter = !biotypeFilterCoveredBySummary || combination.isConsequenceType();\n+      if (useBtIndexFilter) {\n+        btCovered = completeIndex;\n+        for (String biotype : biotypes) {\n+          byte mask = getMaskFromBiotype(biotype);\n+          if (mask == IndexUtils.EMPTY_MASK) {\n+            // If any element is not in the index, do not use this filter\n+            biotypeMask = IndexUtils.EMPTY_MASK;\n+            btCovered = false;\n+            break;\n+          }\n+          biotypeMask |= mask;\n+          // Some CT filter values are not precise, so the query is not covered.\n+          btCovered &= !isImpreciseBtMask(mask);\n+        }\n+        // Biotype filter is covered by index\n+        if (btCovered) {\n+          if (!isValidParam(query, GENE) && simpleCombination(combination)) {\n+            query.remove(ANNOT_BIOTYPE.key());\n+          }\n+        }\n+      }\n+    }\n+    if (completeIndex && btCovered && ctCovered && !isValidParam(query, GENE)\n+        && combination.equals(BiotypeConsquenceTypeFlagCombination.BIOTYPE_CT)) {\n+      query.remove(ANNOT_BIOTYPE.key());\n+      query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n     }\n \n-    protected SampleAnnotationIndexQuery parseAnnotationIndexQuery(Query query) {\n-        return parseAnnotationIndexQuery(query, false);\n+    // If filter by proteinSubstitution, without filter << or >>, add ProteinCodingMask\n+    String proteinSubstitution = query.getString(ANNOT_PROTEIN_SUBSTITUTION.key());\n+    if (StringUtils.isNotEmpty(proteinSubstitution)\n+        && !proteinSubstitution.contains(\"<<\")\n+        && !proteinSubstitution.contains(\">>\")) {\n+      annotationIndex |= LOF_EXTENDED_MASK;\n     }\n \n-    /**\n-     * Builds the SampleAnnotationIndexQuery given a VariantQuery.\n-     *\n-     * @param query Input VariantQuery. If the index is complete, covered filters could be removed from here.\n-     * @param completeIndex Indicates if the annotation index is complete for the samples in the query.\n-     *                      Otherwise, the index can only be used as a hint, and should be completed with further filtering.\n-     * @return SampleAnnotationIndexQuery\n-     */\n-    protected SampleAnnotationIndexQuery parseAnnotationIndexQuery(Query query, boolean completeIndex) {\n-        byte annotationIndex = 0;\n-        byte biotypeMask = 0;\n-        short consequenceTypeMask = 0;\n-        byte clinicalMask = 0;\n-\n-        Boolean intergenic = null;\n-\n-        if (!isValidParam(query, REGION)) {\n-            ParsedVariantQuery.VariantQueryXref variantQueryXref = VariantQueryParser.parseXrefs(query);\n-            if (!variantQueryXref.getGenes().isEmpty()\n-                    && variantQueryXref.getIds().isEmpty()\n-                    && variantQueryXref.getOtherXrefs().isEmpty()\n-                    && variantQueryXref.getVariants().isEmpty()) {\n-                // If only filtering by genes, is not intergenic.\n-                intergenic = false;\n-            }\n+    if (isValidParam(query, ANNOT_CLINICAL_SIGNIFICANCE)) {\n+      annotationIndex |= CLINICAL_MASK;\n+      boolean clinicalCovered = true;\n+      for (String clinical : query.getAsStringList(ANNOT_CLINICAL_SIGNIFICANCE.key())) {\n+        switch (ClinicalSignificance.valueOf(clinical)) {\n+          case likely_benign:\n+          case benign:\n+            // These two values are covered by the same bit, so, they are not covered.\n+            clinicalCovered = false;\n+            clinicalMask |= CLINICAL_BENIGN_LIKELY_BENIGN_MASK;\n+            break;\n+          case VUS:\n+          case uncertain_significance:\n+            // These two values are synonymous\n+            clinicalMask |= CLINICAL_UNCERTAIN_SIGNIFICANCE_MASK;\n+            break;\n+          case likely_pathogenic:\n+            clinicalMask |= CLINICAL_LIKELY_PATHOGENIC_MASK;\n+            break;\n+          case pathogenic:\n+            clinicalMask |= CLINICAL_PATHOGENIC_MASK;\n+            break;\n+          default:\n+            clinicalCovered = false;\n+            break;\n         }\n+      }\n+      if (completeIndex && clinicalCovered) {\n+        query.remove(ANNOT_CLINICAL_SIGNIFICANCE.key());\n+      }\n+      if (!clinicalCovered) {\n+        // Not all values are covered by the index. Unable to filter using this index, as it may return less values than required.\n+        clinicalMask = 0;\n+      }\n+    }\n \n-        BiotypeConsquenceTypeFlagCombination combination = BiotypeConsquenceTypeFlagCombination.fromQuery(query);\n-        boolean btCovered = false;\n-        boolean ctCovered = false;\n-\n-        if (isValidParam(query, ANNOT_CONSEQUENCE_TYPE)) {\n-            List<String> soNames = query.getAsStringList(VariantQueryParam.ANNOT_CONSEQUENCE_TYPE.key());\n-            soNames = soNames.stream()\n-                    .map(ct -> ConsequenceTypeMappings.accessionToTerm.get(VariantQueryUtils.parseConsequenceType(ct)))\n-                    .collect(Collectors.toList());\n-            if (!soNames.contains(VariantAnnotationUtils.INTERGENIC_VARIANT)\n-                    && !soNames.contains(VariantAnnotationUtils.REGULATORY_REGION_VARIANT)\n-                    && !soNames.contains(VariantAnnotationUtils.TF_BINDING_SITE_VARIANT)) {\n-                // All ct values but \"intergenic_variant\" and \"regulatory_region_variant\" are in genes (i.e. non-intergenic)\n-                intergenic = false;\n-            } else if (soNames.size() == 1 && soNames.contains(VariantAnnotationUtils.INTERGENIC_VARIANT)) {\n-                intergenic = true;\n-            }\n-            boolean ctFilterCoveredBySummary = false;\n-            boolean ctBtCombinationCoveredBySummary = false;\n-            if (LOF_SET.containsAll(soNames)) {\n-                ctFilterCoveredBySummary = soNames.size() == LOF_SET.size();\n-                annotationIndex |= LOF_MASK;\n-                // If all present, remove consequenceType filter\n-                if (completeIndex && LOF_SET.size() == soNames.size()) {\n-                    // Ensure not filtering by gene, and not combining with other params\n-                    if (!isValidParam(query, GENE) && simpleCombination(combination)) {\n-                        query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n-                    }\n-                }\n-            }\n-            if (LOF_EXTENDED_SET.containsAll(soNames)) {\n-                boolean proteinCodingOnly = query.getString(ANNOT_BIOTYPE.key()).equals(VariantAnnotationUtils.PROTEIN_CODING);\n-                ctFilterCoveredBySummary = soNames.size() == LOF_EXTENDED_SET.size();\n-                annotationIndex |= LOF_EXTENDED_MASK;\n-                // If all present, remove consequenceType filter\n-                if (LOF_EXTENDED_SET.size() == soNames.size()) {\n-                    // Ensure not filtering by gene, and not combining with other params\n-                    if (completeIndex && !isValidParam(query, GENE)) {\n-                        if (simpleCombination(combination)) {\n-                            query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n-                        } else if (proteinCodingOnly && combination.equals(BiotypeConsquenceTypeFlagCombination.BIOTYPE_CT)) {\n-                            query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n-                            query.remove(ANNOT_BIOTYPE.key());\n-                            ctBtCombinationCoveredBySummary = true;\n-                        }\n-                    }\n-                }\n-                if (proteinCodingOnly) {\n-                    annotationIndex |= LOFE_PROTEIN_CODING_MASK;\n-                }\n-            }\n-            if (soNames.size() == 1 && soNames.get(0).equals(VariantAnnotationUtils.MISSENSE_VARIANT)) {\n-                ctFilterCoveredBySummary = true;\n-                ctCovered = true;\n-                annotationIndex |= MISSENSE_VARIANT_MASK;\n-                // Ensure not filtering by gene, and not combining with other params\n-                if (completeIndex && !isValidParam(query, GENE)) {\n-                    if (simpleCombination(combination)) {\n-                        query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n-                    }\n-                }\n-            }\n-\n-            // Do not use ctIndex if the CT filter is covered by the summary\n-            // Use the ctIndex if:\n-            // - The CtFilter is not covered by the summary\n-            // - The query has the combination CT+BT , and it is not covered by the summary\n-            boolean useCtIndexFilter = !ctFilterCoveredBySummary || (!ctBtCombinationCoveredBySummary && combination.isBiotype());\n-            if (useCtIndexFilter) {\n-                ctCovered = completeIndex;\n-                for (String soName : soNames) {\n-                    short mask = getMaskFromSoName(soName);\n-                    if (mask == IndexUtils.EMPTY_MASK) {\n-                        // If any element is not in the index, do not use this filter\n-                        consequenceTypeMask = IndexUtils.EMPTY_MASK;\n-                        ctCovered = false;\n-                        break;\n-                    }\n-                    consequenceTypeMask |= mask;\n-                    // Some CT filter values are not precise, so the query is not covered.\n-                    ctCovered &= !isImpreciseCtMask(mask);\n-                }\n-                // ConsequenceType filter is covered by index\n-                if (ctCovered) {\n-                    if (!isValidParam(query, GENE) && simpleCombination(combination)) {\n-                        query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n-                    }\n-                }\n-            }\n+    List<PopulationFrequencyQuery> popFreqQuery = new ArrayList<>();\n+    QueryOperation popFreqOp = QueryOperation.AND;\n+    boolean popFreqPartial = false;\n+    // TODO: This will skip filters ANNOT_POPULATION_REFERENCE_FREQUENCY and ANNOT_POPULATION_MINNOR_ALLELE_FREQUENCY\n+    if (isValidParam(query, ANNOT_POPULATION_ALTERNATE_FREQUENCY)) {\n+      ParsedQuery<String> popFreqFilter = VariantQueryUtils.splitValue(query, VariantQueryParam.ANNOT_POPULATION_ALTERNATE_FREQUENCY);\n+      popFreqOp = popFreqFilter.getOperation();\n+\n+      Set<String> studyPops = new HashSet<>();\n+      Set<String> popFreqLessThan001 = new HashSet<>();\n+      List<String> filtersNotCoveredByPopFreqQuery = new ArrayList<>(popFreqFilter.getValues().size());\n+\n+      for (String popFreq : popFreqFilter) {\n+        KeyOpValue<String, String> keyOpValue = VariantQueryUtils.parseKeyOpValue(popFreq);\n+        String studyPop = keyOpValue.getKey();\n+        studyPops.add(studyPop);\n+        double freqFilter = Double.valueOf(keyOpValue.getValue());\n+        if (keyOpValue.getOp().equals(\"<\") || keyOpValue.getOp().equals(\"<<\")) {\n+          if (freqFilter <= POP_FREQ_THRESHOLD_001) {\n+            popFreqLessThan001.add(studyPop);\n+          }\n         }\n \n-        if (isValidParam(query, ANNOT_BIOTYPE)) {\n-            // All biotype values are in genes (i.e. non-intergenic)\n-            intergenic = false;\n-            boolean biotypeFilterCoveredBySummary = false;\n-            List<String> biotypes = query.getAsStringList(VariantQueryParam.ANNOT_BIOTYPE.key());\n-            if (BIOTYPE_SET.containsAll(biotypes)) {\n-                biotypeFilterCoveredBySummary = BIOTYPE_SET.size() == biotypes.size();\n-                annotationIndex |= PROTEIN_CODING_MASK;\n-                // If all present, remove biotype filter\n-                if (completeIndex && BIOTYPE_SET.size() == biotypes.size()) {\n-                    // Ensure not filtering by gene, and not combining with other params\n-                    if (!isValidParam(query, GENE) && simpleCombination(combination)) {\n-                        query.remove(ANNOT_BIOTYPE.key());\n-                    }\n-                }\n-            }\n-\n-            boolean useBtIndexFilter = !biotypeFilterCoveredBySummary || combination.isConsequenceType();\n-            if (useBtIndexFilter) {\n-                btCovered = completeIndex;\n-                for (String biotype : biotypes) {\n-                    byte mask = getMaskFromBiotype(biotype);\n-                    if (mask == IndexUtils.EMPTY_MASK) {\n-                        // If any element is not in the index, do not use this filter\n-                        biotypeMask = IndexUtils.EMPTY_MASK;\n-                        btCovered = false;\n-                        break;\n-                    }\n-                    biotypeMask |= mask;\n-                    // Some CT filter values are not precise, so the query is not covered.\n-                    btCovered &= !isImpreciseBtMask(mask);\n-                }\n-                // Biotype filter is covered by index\n-                if (btCovered) {\n-                    if (!isValidParam(query, GENE) && simpleCombination(combination)) {\n-                        query.remove(ANNOT_BIOTYPE.key());\n-                    }\n-                }\n-            }\n-        }\n-        if (completeIndex && btCovered && ctCovered && !isValidParam(query, GENE)\n-                && combination.equals(BiotypeConsquenceTypeFlagCombination.BIOTYPE_CT)) {\n-            query.remove(ANNOT_BIOTYPE.key());\n-            query.remove(ANNOT_CONSEQUENCE_TYPE.key());\n+        boolean populationInSampleIndex = false;\n+        boolean populationFilterFullyCovered = false;\n+        int popFreqIdx = 0;\n+        for (PopulationFrequencyRange populationRange : configuration.getPopulationRanges()) {\n+          if (populationRange.getStudyAndPopulation().equals(studyPop)) {\n+            populationInSampleIndex = true;\n+            RangeQuery rangeQuery = getRangeQuery(keyOpValue.getOp(), freqFilter, populationRange.getThresholds(),\n+                0, 1 + IndexUtils.DELTA);\n+\n+            popFreqQuery.add(new PopulationFrequencyQuery(rangeQuery,\n+                popFreqIdx, populationRange.getStudy(),\n+                populationRange.getPopulation()));\n+            populationFilterFullyCovered |= rangeQuery.isExactQuery();\n+          }\n+          popFreqIdx++;\n         }\n \n-        // If filter by proteinSubstitution, without filter << or >>, add ProteinCodingMask\n-        String proteinSubstitution = query.getString(ANNOT_PROTEIN_SUBSTITUTION.key());\n-        if (StringUtils.isNotEmpty(proteinSubstitution)\n-                && !proteinSubstitution.contains(\"<<\")\n-                && !proteinSubstitution.contains(\">>\")) {\n-            annotationIndex |= LOF_EXTENDED_MASK;\n+        if (!populationInSampleIndex) {\n+          // If there is any populationFrequency from the query not in the SampleIndex, mark as partial\n+          popFreqPartial = true;\n+          filtersNotCoveredByPopFreqQuery.add(popFreq);\n+        } else if (!populationFilterFullyCovered) {\n+          filtersNotCoveredByPopFreqQuery.add(popFreq);\n         }\n+      }\n+      if (QueryOperation.OR.equals(popFreqOp)) {\n+        // Should use summary popFreq mask?\n+        if (POP_FREQ_ANY_001_SET.containsAll(popFreqLessThan001) && studyPops.equals(popFreqLessThan001)) {\n \n-        if (isValidParam(query, ANNOT_CLINICAL_SIGNIFICANCE)) {\n-            annotationIndex |= CLINICAL_MASK;\n-            boolean clinicalCovered = true;\n-            for (String clinical : query.getAsStringList(ANNOT_CLINICAL_SIGNIFICANCE.key())) {\n-                switch (ClinicalSignificance.valueOf(clinical)) {\n-                    case likely_benign:\n-                    case benign:\n-                        // These two values are covered by the same bit, so, they are not covered.\n-                        clinicalCovered = false;\n-                        clinicalMask |= CLINICAL_BENIGN_LIKELY_BENIGN_MASK;\n-                        break;\n-                    case VUS:\n-                    case uncertain_significance:\n-                        // These two values are synonymous\n-                        clinicalMask |= CLINICAL_UNCERTAIN_SIGNIFICANCE_MASK;\n-                        break;\n-                    case likely_pathogenic:\n-                        clinicalMask |= CLINICAL_LIKELY_PATHOGENIC_MASK;\n-                        break;\n-                    case pathogenic:\n-                        clinicalMask |= CLINICAL_PATHOGENIC_MASK;\n-                        break;\n-                    default:\n-                        clinicalCovered = false;\n-                        break;\n-                }\n-            }\n-            if (completeIndex && clinicalCovered) {\n-                query.remove(ANNOT_CLINICAL_SIGNIFICANCE.key());\n-            }\n-            if (!clinicalCovered) {\n-                // Not all values are covered by the index. Unable to filter using this index, as it may return less values than required.\n-                clinicalMask = 0;\n-            }\n-        }\n+          annotationIndex |= POP_FREQ_ANY_001_MASK;\n \n-        List<PopulationFrequencyQuery> popFreqQuery = new ArrayList<>();\n-        QueryOperation popFreqOp = QueryOperation.AND;\n-        boolean popFreqPartial = false;\n-        // TODO: This will skip filters ANNOT_POPULATION_REFERENCE_FREQUENCY and ANNOT_POPULATION_MINNOR_ALLELE_FREQUENCY\n-        if (isValidParam(query, ANNOT_POPULATION_ALTERNATE_FREQUENCY)) {\n-            ParsedQuery<String> popFreqFilter = VariantQueryUtils.splitValue(query, VariantQueryParam.ANNOT_POPULATION_ALTERNATE_FREQUENCY);\n-            popFreqOp = popFreqFilter.getOperation();\n-\n-            Set<String> studyPops = new HashSet<>();\n-            Set<String> popFreqLessThan001 = new HashSet<>();\n-            List<String> filtersNotCoveredByPopFreqQuery = new ArrayList<>(popFreqFilter.getValues().size());\n-\n-            for (String popFreq : popFreqFilter) {\n-                KeyOpValue<String, String> keyOpValue = VariantQueryUtils.parseKeyOpValue(popFreq);\n-                String studyPop = keyOpValue.getKey();\n-                studyPops.add(studyPop);\n-                double freqFilter = Double.valueOf(keyOpValue.getValue());\n-                if (keyOpValue.getOp().equals(\"<\") || keyOpValue.getOp().equals(\"<<\")) {\n-                    if (freqFilter <= POP_FREQ_THRESHOLD_001) {\n-                        popFreqLessThan001.add(studyPop);\n-                    }\n-                }\n-\n-                boolean populationInSampleIndex = false;\n-                boolean populationFilterFullyCovered = false;\n-                int popFreqIdx = 0;\n-                for (PopulationFrequencyRange populationRange : configuration.getPopulationRanges()) {\n-                    if (populationRange.getStudyAndPopulation().equals(studyPop)) {\n-                        populationInSampleIndex = true;\n-                        RangeQuery rangeQuery = getRangeQuery(keyOpValue.getOp(), freqFilter, populationRange.getThresholds(),\n-                                0, 1 + IndexUtils.DELTA);\n-\n-                        popFreqQuery.add(new PopulationFrequencyQuery(rangeQuery,\n-                                popFreqIdx, populationRange.getStudy(),\n-                                populationRange.getPopulation()));\n-                        populationFilterFullyCovered |= rangeQuery.isExactQuery();\n-                    }\n-                    popFreqIdx++;\n-                }\n-\n-                if (!populationInSampleIndex) {\n-                    // If there is any populationFrequency from the query not in the SampleIndex, mark as partial\n-                    popFreqPartial = true;\n-                    filtersNotCoveredByPopFreqQuery.add(popFreq);\n-                } else if (!populationFilterFullyCovered) {\n-                    filtersNotCoveredByPopFreqQuery.add(popFreq);\n-                }\n-            }\n-            if (QueryOperation.OR.equals(popFreqOp)) {\n-                // Should use summary popFreq mask?\n-                if (POP_FREQ_ANY_001_SET.containsAll(popFreqLessThan001) && studyPops.equals(popFreqLessThan001)) {\n-\n-                    annotationIndex |= POP_FREQ_ANY_001_MASK;\n-\n-                    if (POP_FREQ_ANY_001_SET.size() == popFreqFilter.getValues().size()) {\n-                        // Do not filter using the PopFreq index, as the summary bit covers the filter\n-                        popFreqQuery.clear();\n-\n-                        // If the index is complete for all samples, remove the filter from main query\n-                        if (completeIndex) {\n-                            query.remove(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key());\n-                        }\n-                    }\n-                }\n-                if (popFreqPartial) {\n-                    // Can not use the index with partial OR queries.\n-                    popFreqQuery.clear();\n-                } else if (filtersNotCoveredByPopFreqQuery.isEmpty()) {\n-                    // If all filters are covered, remove filter form query.\n-                    if (completeIndex) {\n-                        query.remove(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key());\n-                    }\n-                }\n+          if (POP_FREQ_ANY_001_SET.size() == popFreqFilter.getValues().size()) {\n+            // Do not filter using the PopFreq index, as the summary bit covers the filter\n+            popFreqQuery.clear();\n \n-            } else {\n-                popFreqOp = QueryOperation.AND; // it could be null\n-                // With AND, the query MUST contain ANY popFreq\n-                for (String s : POP_FREQ_ANY_001_SET) {\n-                    if (popFreqLessThan001.contains(s)) {\n-                        annotationIndex |= POP_FREQ_ANY_001_MASK;\n-                        break;\n-                    }\n-                }\n-                if (completeIndex) {\n-                    if (filtersNotCoveredByPopFreqQuery.isEmpty()) {\n-                        query.remove(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key());\n-                    } else {\n-                        query.put(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key(),\n-                                String.join(popFreqOp.separator(), filtersNotCoveredByPopFreqQuery));\n-                    }\n-                }\n+            // If the index is complete for all samples, remove the filter from main query\n+            if (completeIndex) {\n+              query.remove(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key());\n             }\n+          }\n         }\n-\n-        byte annotationIndexMask = annotationIndex;\n-        if (intergenic != null) {\n-            annotationIndexMask |= INTERGENIC_MASK;\n-            if (intergenic) {\n-                annotationIndex |= INTERGENIC_MASK;\n-            }\n+        if (popFreqPartial) {\n+          // Can not use the index with partial OR queries.\n+          popFreqQuery.clear();\n+        } else if (filtersNotCoveredByPopFreqQuery.isEmpty()) {\n+          // If all filters are covered, remove filter form query.\n+          if (completeIndex) {\n+            query.remove(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key());\n+          }\n         }\n \n-        if (intergenic == null || intergenic) {\n-            // If intergenic is undefined, or true, CT and BT filters can not be used.\n-            consequenceTypeMask = IndexUtils.EMPTY_MASK;\n-            biotypeMask = IndexUtils.EMPTY_MASK;\n+      } else {\n+        popFreqOp = QueryOperation.AND; // it could be null\n+        // With AND, the query MUST contain ANY popFreq\n+        for (String s : POP_FREQ_ANY_001_SET) {\n+          if (popFreqLessThan001.contains(s)) {\n+            annotationIndex |= POP_FREQ_ANY_001_MASK;\n+            break;\n+          }\n         }\n-\n-\n-        return new SampleAnnotationIndexQuery(new byte[]{annotationIndexMask, annotationIndex}, consequenceTypeMask, biotypeMask,\n-                clinicalMask, popFreqOp, popFreqQuery, popFreqPartial);\n+        if (completeIndex) {\n+          if (filtersNotCoveredByPopFreqQuery.isEmpty()) {\n+            query.remove(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key());\n+          } else {\n+            query.put(ANNOT_POPULATION_ALTERNATE_FREQUENCY.key(),\n+                String.join(popFreqOp.separator(), filtersNotCoveredByPopFreqQuery));\n+          }\n+        }\n+      }\n     }\n \n-    private boolean simpleCombination(BiotypeConsquenceTypeFlagCombination combination) {\n-        return combination.equals(BiotypeConsquenceTypeFlagCombination.BIOTYPE)\n-                || combination.equals(BiotypeConsquenceTypeFlagCombination.CT);\n+    byte annotationIndexMask = annotationIndex;\n+    if (intergenic != null) {\n+      annotationIndexMask |= INTERGENIC_MASK;\n+      if (intergenic) {\n+        annotationIndex |= INTERGENIC_MASK;\n+      }\n     }\n \n-    protected RangeQuery getRangeQuery(String op, double value, double[] thresholds) {\n-        return getRangeQuery(op, value, thresholds, Double.MIN_VALUE, Double.MAX_VALUE);\n+    if (intergenic == null || intergenic) {\n+      // If intergenic is undefined, or true, CT and BT filters can not be used.\n+      consequenceTypeMask = IndexUtils.EMPTY_MASK;\n+      biotypeMask = IndexUtils.EMPTY_MASK;\n     }\n \n-    protected RangeQuery getRangeQuery(String op, double value, double[] thresholds, double min, double max) {\n-        double[] range = IndexUtils.queryRange(op, value, min, max);\n-        return getRangeQuery(range, thresholds, min, max);\n-    }\n \n-    private RangeQuery getRangeQuery(double[] range, double[] thresholds, double min, double max) {\n-        byte[] rangeCode = IndexUtils.getRangeCodes(range, thresholds);\n-        boolean exactQuery;\n-        if (rangeCode[0] == 0) {\n-            if (rangeCode[1] - 1 == thresholds.length) {\n-                exactQuery = IndexUtils.equalsTo(range[0], min) && IndexUtils.equalsTo(range[1], max);\n-            } else {\n-                exactQuery = IndexUtils.equalsTo(range[1], thresholds[rangeCode[1] - 1]) && IndexUtils.equalsTo(range[0], min);\n-            }\n-        } else if (rangeCode[1] - 1 == thresholds.length) {\n-            exactQuery = IndexUtils.equalsTo(range[0], thresholds[rangeCode[0] - 1]) && IndexUtils.equalsTo(range[1], max);\n-        } else {\n-            exactQuery = false;\n-        }\n-        return new RangeQuery(\n-                range[0],\n-                range[1],\n-                rangeCode[0],\n-                rangeCode[1],\n-                exactQuery\n-        );\n+    return new SampleAnnotationIndexQuery(new byte[] {annotationIndexMask, annotationIndex}, consequenceTypeMask, biotypeMask,\n+        clinicalMask, popFreqOp, popFreqQuery, popFreqPartial);\n+  }\n+\n+  private boolean simpleCombination(BiotypeConsquenceTypeFlagCombination combination) {\n+    return combination.equals(BiotypeConsquenceTypeFlagCombination.BIOTYPE)\n+        || combination.equals(BiotypeConsquenceTypeFlagCombination.CT);\n+  }\n+\n+  protected RangeQuery getRangeQuery(String op, double value, double[] thresholds) {\n+    return getRangeQuery(op, value, thresholds, Double.MIN_VALUE, Double.MAX_VALUE);\n+  }\n+\n+  protected RangeQuery getRangeQuery(String op, double value, double[] thresholds, double min, double max) {\n+    double[] range = IndexUtils.queryRange(op, value, min, max);\n+    return getRangeQuery(range, thresholds, min, max);\n+  }\n+\n+  private RangeQuery getRangeQuery(double[] range, double[] thresholds, double min, double max) {\n+    byte[] rangeCode = IndexUtils.getRangeCodes(range, thresholds);\n+    boolean exactQuery;\n+    if (rangeCode[0] == 0) {\n+      if (rangeCode[1] - 1 == thresholds.length) {\n+        exactQuery = IndexUtils.equalsTo(range[0], min) && IndexUtils.equalsTo(range[1], max);\n+      } else {\n+        exactQuery = IndexUtils.equalsTo(range[1], thresholds[rangeCode[1] - 1]) && IndexUtils.equalsTo(range[0], min);\n+      }\n+    } else if (rangeCode[1] - 1 == thresholds.length) {\n+      exactQuery = IndexUtils.equalsTo(range[0], thresholds[rangeCode[0] - 1]) && IndexUtils.equalsTo(range[1], max);\n+    } else {\n+      exactQuery = false;\n     }\n-\n-    private static List<String> getAllLoadedGenotypes(StudyMetadata studyMetadata) {\n-        List<String> allGts = studyMetadata\n-                .getAttributes()\n-                .getAsStringList(VariantStorageOptions.LOADED_GENOTYPES.key());\n-        if (allGts == null || allGts.isEmpty()) {\n-            allGts = DEFAULT_LOADED_GENOTYPES;\n-        }\n-        return allGts;\n+    return new RangeQuery(\n+        range[0],\n+        range[1],\n+        rangeCode[0],\n+        rangeCode[1],\n+        exactQuery\n+    );\n+  }\n+\n+  private static List<String> getAllLoadedGenotypes(StudyMetadata studyMetadata) {\n+    List<String> allGts = studyMetadata\n+        .getAttributes()\n+        .getAsStringList(VariantStorageOptions.LOADED_GENOTYPES.key());\n+    if (allGts == null || allGts.isEmpty()) {\n+      allGts = DEFAULT_LOADED_GENOTYPES;\n     }\n+    return allGts;\n+  }\n \n }\n",
            "diff_size": 1732
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "249",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 156).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "262",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 156).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "265",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 141).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/335/SampleIndexQueryParser.java\nindex 183d4bbcd79..604c1ec2c2c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/335/SampleIndexQueryParser.java\n@@ -229,8 +229,7 @@ public class SampleIndexQueryParser {\n \n                     // Remove from negatedSamples (if present)\n                     negatedSamples.remove(sampleName);\n-\n-                    continue;\n+continue;\n                 }\n                 if (hasNegatedGenotypeFilter(queryOperation, entry.getValue())) {\n                     // Discard samples with negated genotypes\n@@ -247,8 +246,7 @@ public class SampleIndexQueryParser {\n \n                         if (father != null) {\n                             Integer fatherId = metadataManager.getSampleId(studyId, father);\n-                            boolean includeDiscrepancies = VariantStorageEngine.SplitData.MULTI\n-                                    .equals(metadataManager.getLoadSplitData(studyId, fatherId));\n+                            boolean includeDiscrepancies = VariantStorageEngine.SplitData.MULTI.equals(metadataManager.getLoadSplitData(studyId, fatherId));\n                             List<Integer> fatherFiles = allSamples.get(father).getFiles();\n                             List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n                             boolean parentInSeparatedFile =\n@@ -261,13 +259,11 @@ public class SampleIndexQueryParser {\n                         }\n                         if (mother != null) {\n                             Integer motherId = metadataManager.getSampleId(studyId, mother);\n-                            boolean includeDiscrepancies = VariantStorageEngine.SplitData.MULTI\n-                                    .equals(metadataManager.getLoadSplitData(studyId, motherId));\n+                            boolean includeDiscrepancies = VariantStorageEngine.SplitData.MULTI.equals(metadataManager.getLoadSplitData(studyId, motherId));\n                             List<Integer> motherFiles = allSamples.get(mother).getFiles();\n                             List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n-                            boolean parentInSeparatedFile = \n-                                    motherFiles.size() == sampleFiles.size() && motherFiles.containsAll(sampleFiles);\n-                            boolean[] filter = buildParentGtFilter(gtMap.get(mother), includeDiscrepancies, parentInSeparatedFile);\n+                            boolean parentInSeparatedFile = motherFiles.size() == sampleFiles.size() && motherFiles.containsAll(sampleFiles);\n+boolean[] filter = buildParentGtFilter(gtMap.get(mother), includeDiscrepancies, parentInSeparatedFile);\n                             if (!isFullyCoveredParentFilter(filter)) {\n                                 partialGtIndex = true;\n                             }\n@@ -449,8 +445,7 @@ public class SampleIndexQueryParser {\n      */\n     public static List<List<Region>> groupRegions(List<Region> regions) {\n         regions = mergeRegions(regions);\n-        List<List<Region>> regionGroups = new ArrayList<>(regions\n-                .stream()\n+        List<List<Region>> regionGroups = new ArrayList<>(regions.stream()\n                 .collect(Collectors.groupingBy(r -> r.getChromosome() + \"_\" + SampleIndexSchema.getChunkStart(r.getStart())))\n                 .values());\n \n@@ -564,7 +559,7 @@ public class SampleIndexQueryParser {\n \n     protected Values<SampleFileIndexQuery> parseFilesQuery(Query query, int studyId, String sample,\n                                                          boolean multiFileSample, boolean partialFilesIndex) {\n-        return parseFilesQuery(query, sample, multiFileSample, partialFilesIndex, s -> {\n+    return parseFilesQuery(query, sample, multiFileSample, partialFilesIndex, s -> {\n             Integer sampleId = metadataManager.getSampleId(studyId, s);\n             List<Integer> fileIds = metadataManager.getFileIdsFromSampleId(studyId, sampleId);\n             List<String> fileNames = new ArrayList<>(fileIds.size());\n@@ -577,7 +572,7 @@ public class SampleIndexQueryParser {\n \n     protected Values<SampleFileIndexQuery> parseFilesQuery(Query query, String sample, boolean multiFileSample, boolean partialFilesIndex,\n                                                          Function<String, List<String>> filesFromSample) {\n-        ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> fileDataParsedQuery = parseFileData(query);\n+    ParsedQuery<KeyValues<String, KeyOpValue<String, String>>> fileDataParsedQuery = parseFileData(query);\n         List<String> filesFromFileData = fileDataParsedQuery.getValues(KeyValues::getKey);\n \n         boolean splitFileDataQuery = false;\n@@ -614,7 +609,7 @@ public class SampleIndexQueryParser {\n \n     protected SampleFileIndexQuery parseFileQuery(Query query, String sample, boolean multiFileSample, boolean partialFilesIndex,\n                                                   Function<String, List<String>> filesFromSample) {\n-        short fileIndexMask = 0;\n+    short fileIndexMask = 0;\n         List<String> files = null;\n \n         Set<Integer> typeCodes = Collections.emptySet();\n@@ -703,8 +698,7 @@ public class SampleIndexQueryParser {\n             String qualValue = query.getString(QUAL.key());\n             List<String> qualValues = VariantQueryUtils.splitValues(qualValue).getValues();\n             if (qualValues.size() == 1) {\n-\n-                fileIndexMask |= VariantFileIndexConverter.QUAL_MASK;\n+    fileIndexMask |= VariantFileIndexConverter.QUAL_MASK;\n \n                 OpValue<String> opValue = parseOpValue(qualValue);\n                 double value = Double.parseDouble(opValue.getValue());\n@@ -1134,8 +1128,7 @@ public class SampleIndexQueryParser {\n             if (QueryOperation.OR.equals(popFreqOp)) {\n                 // Should use summary popFreq mask?\n                 if (POP_FREQ_ANY_001_SET.containsAll(popFreqLessThan001) && studyPops.equals(popFreqLessThan001)) {\n-\n-                    annotationIndex |= POP_FREQ_ANY_001_MASK;\n+    annotationIndex |= POP_FREQ_ANY_001_MASK;\n \n                     if (POP_FREQ_ANY_001_SET.size() == popFreqFilter.getValues().size()) {\n                         // Do not filter using the PopFreq index, as the summary bit covers the filter\n@@ -1243,4 +1236,4 @@ public class SampleIndexQueryParser {\n         return allGts;\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 19
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/335/SampleIndexQueryParser.java\nindex 183d4bbcd79..d3d06cca3be 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/335/SampleIndexQueryParser.java\n@@ -265,7 +265,7 @@ public class SampleIndexQueryParser {\n                                     .equals(metadataManager.getLoadSplitData(studyId, motherId));\n                             List<Integer> motherFiles = allSamples.get(mother).getFiles();\n                             List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n-                            boolean parentInSeparatedFile = \n+                            boolean parentInSeparatedFile =\n                                     motherFiles.size() == sampleFiles.size() && motherFiles.containsAll(sampleFiles);\n                             boolean[] filter = buildParentGtFilter(gtMap.get(mother), includeDiscrepancies, parentInSeparatedFile);\n                             if (!isFullyCoveredParentFilter(filter)) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/335/SampleIndexQueryParser.java\nindex 183d4bbcd79..c05b86b5c51 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/335/SampleIndexQueryParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/335/SampleIndexQueryParser.java\n@@ -264,8 +264,7 @@ public class SampleIndexQueryParser {\n                             boolean includeDiscrepancies = VariantStorageEngine.SplitData.MULTI\n                                     .equals(metadataManager.getLoadSplitData(studyId, motherId));\n                             List<Integer> motherFiles = allSamples.get(mother).getFiles();\n-                            List<Integer> sampleFiles = allSamples.get(sampleName).getFiles();\n-                            boolean parentInSeparatedFile = \n+                            List<Integer> sampleFiles = allSamples.get(sampleName).getFiles(); boolean parentInSeparatedFile =\n                                     motherFiles.size() == sampleFiles.size() && motherFiles.containsAll(sampleFiles);\n                             boolean[] filter = buildParentGtFilter(gtMap.get(mother), includeDiscrepancies, parentInSeparatedFile);\n                             if (!isFullyCoveredParentFilter(filter)) {\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}