{
    "project_name": "IQSS-dataverse",
    "error_id": "67",
    "information": {
        "errors": [
            {
                "line": "159",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "                                    break;\n                                } else {\n\t\t\t            // We want to know what modules matched the\n                                    // signature, so we force the sigMatch\n                                    // property\n                                    // to be persistent.",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/67/JhoveFileType.java\nindex 8a4ed81bc5b..d762b985e55 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/67/JhoveFileType.java\n@@ -156,7 +156,7 @@ public class JhoveFileType implements java.io.Serializable  {\n                                     info.copy(infc);\n                                     break;\n                                 } else {\n-\t\t\t            // We want to know what modules matched the\n+                                    // We want to know what modules matched the\n                                     // signature, so we force the sigMatch\n                                     // property\n                                     // to be persistent.\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/67/JhoveFileType.java\nindex 8a4ed81bc5b..356363bf3a4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/67/JhoveFileType.java\n@@ -17,6 +17,7 @@\n    Developed at the Institute for Quantitative Social Science, Harvard University.\n    Version 3.0.\n */\n+\n package edu.harvard.iq.dataverse.util;\n \n import edu.harvard.hul.ois.jhove.App;\n@@ -32,174 +33,175 @@ import java.util.logging.Logger;\n /**\n  * This is based on Akio Sone's implementation from DVN v2-3:\n  * JhoveWrapper.java\n+ *\n  * @author Akio Sone\n- * \n+ * <p>\n  * Updated and integrated into 4.0 by\n  * @author landreev\n- *\n  */\n-public class JhoveFileType implements java.io.Serializable  {\n-    private static final Logger logger = Logger.getLogger(JhoveFileType.class.getCanonicalName());\n+public class JhoveFileType implements java.io.Serializable {\n+  private static final Logger logger = Logger.getLogger(JhoveFileType.class.getCanonicalName());\n+\n+\n+  public JhoveFileType() {\n \n-     \n-    public JhoveFileType() {\n-        \n+  }\n+\n+\n+  public static String getJhoveConfigFile() {\n+    Properties p = System.getProperties();\n+    String domainRoot = p.getProperty(\"com.sun.aas.instanceRoot\");\n+    if (domainRoot == null) {\n+      // When testing statically from JUnit, we expect domainRoot to be null.\n+      return null;\n     }\n-    \n-    \n-    public static String getJhoveConfigFile() {\n-        Properties p = System.getProperties();\n-        String domainRoot = p.getProperty(\"com.sun.aas.instanceRoot\");\n-        if (domainRoot == null) {\n-            // When testing statically from JUnit, we expect domainRoot to be null.\n-            return null;\n+    return domainRoot + File.separator + \"config\" + File.separator + \"jhove.conf\";\n+  }\n+\n+  private static final int[] ORIGINAL_RELEASE_DATE = {2013, 8, 30};\n+  private static final String ORIGINAL_COPR_RIGHTS = \"Copyright\"\n+    + \"2004-2007 by the President and Fellows of Harvard College. \"\n+    + \"Released under the GNU Lesser General Public License.\";\n+\n+  /**\n+   * A method that returns Jhove's RepInfo\n+   */\n+\n+  public RepInfo checkFileType(File file) {\n+    RepInfo info = null;\n+    boolean DEBUG = false;\n+\n+    try {\n+      // initialize the application spec object\n+      // name, release number, build date, usage, Copyright infor\n+      // TODO: Should the release number come from pom.xml as we upgrade from 1.11.0 to 1.20.1?\n+      App jhoveApp = new App(\"Jhove\", \"1.20.1\",\n+        ORIGINAL_RELEASE_DATE, \"Java JhoveFileType\",\n+        ORIGINAL_COPR_RIGHTS);\n+\n+      //String configFile = JhoveBase.getConfigFileFromProperties();\n+      String saxClass = JhoveBase.getSaxClassFromProperties();\n+\n+      String configFile = getJhoveConfigFile();\n+      logger.fine(\"config file: \" + configFile);\n+      if (configFile == null) {\n+        logger.info(\n+          \"Called getJhoveConfigFile but the result was null! Configuring JHOVE is highly recommended to determine file types.\");\n+      }\n+\n+      // create an instance of jhove engine\n+      JhoveBase jb = new JhoveBase();\n+      if (DEBUG) {\n+        jb.setLogLevel(\"INFO\");\n+      } else {\n+        jb.setLogLevel(\"SEVERE\");\n+      }\n+      jb.init(configFile, saxClass);\n+\n+      jb.setEncoding(\"utf-8\"); // encoding\n+      jb.setTempDirectory(\"/tmp\");\n+      jb.setBufferSize(131072); // bufferSize\n+\n+      jb.setChecksumFlag(false); // -s option\n+      jb.setShowRawFlag(false);  // -r option\n+      jb.setSignatureFlag(true); // -k option\n+\n+      // String moduleName = null;\n+      Module module = jb.getModule(null);\n+\n+      if (DEBUG) {\n+        if (module != null) {\n+          logger.fine(\"Module \" + module.getName());\n+        } else {\n+          logger.fine(\"module is null!\");\n         }\n-        return domainRoot+File.separator+\"config\"+File.separator+\"jhove.conf\";\n-    }\n-    \n-    private static final int[] ORIGINAL_RELEASE_DATE = { 2013, 8, 30 };\n-    private static final String ORIGINAL_COPR_RIGHTS = \"Copyright\"\n-        +\"2004-2007 by the President and Fellows of Harvard College. \"\n-        + \"Released under the GNU Lesser General Public License.\";\n-    \n-    /**\n-     * A method that returns Jhove's RepInfo\n-     */\n-    \n-    public RepInfo checkFileType(File file) {\n-        RepInfo info = null;\n-        boolean DEBUG = false;\n-        \n-        try {\n-            // initialize the application spec object\n-            // name, release number, build date, usage, Copyright infor\n-            // TODO: Should the release number come from pom.xml as we upgrade from 1.11.0 to 1.20.1?\n-            App jhoveApp = new App(\"Jhove\", \"1.20.1\",\n-                           ORIGINAL_RELEASE_DATE, \"Java JhoveFileType\", \n-                           ORIGINAL_COPR_RIGHTS);\n-\n-            //String configFile = JhoveBase.getConfigFileFromProperties();\n-            String saxClass = JhoveBase.getSaxClassFromProperties();\n-\n-            String configFile = getJhoveConfigFile();\n-            logger.fine(\"config file: \"+configFile);\n-            if (configFile == null) {\n-                logger.info(\"Called getJhoveConfigFile but the result was null! Configuring JHOVE is highly recommended to determine file types.\");\n-            }\n-        \n-            // create an instance of jhove engine\n-            JhoveBase jb = new JhoveBase();\n+      }\n+\n+      if (DEBUG) {\n+        logger.fine(\"file name=\" + file.getAbsolutePath());\n+      }\n+\n+      // get a RepInfo instance\n+      if (file.exists() && file.isFile() && (file.length() > 0L)) {\n+        //info = jb.processRepInfo(jhoveApp, module, file);\n+        info = new RepInfo(file.getAbsolutePath());\n+        info.setSize(file.length());\n+        if (module != null) {\n+          if (!jb.processFile(jhoveApp, module, false, file, info)) {\n+            info = null;\n+          } else {\n             if (DEBUG) {\n-                jb.setLogLevel(\"INFO\"); \n-            } else {\n-                jb.setLogLevel(\"SEVERE\");\n+              logger.fine(\"mime type (module specified above)=\" + info.getMimeType());\n             }\n-            jb.init(configFile, saxClass);\n-\n-            jb.setEncoding(\"utf-8\"); // encoding\n-            jb.setTempDirectory(\"/tmp\");\n-            jb.setBufferSize(131072); // bufferSize\n-\n-            jb.setChecksumFlag(false); // -s option\n-            jb.setShowRawFlag(false);  // -r option \n-            jb.setSignatureFlag(true); // -k option\n-            \n-            // String moduleName = null;\n-            Module module = jb.getModule(null);\n-            \n-            if (DEBUG) {\n-                if (module != null) {\n-                    logger.fine(\"Module \"+module.getName());\n-                } else {\n-                    logger.fine(\"module is null!\");\n+          }\n+        } else {\n+          /*\n+           * Invoke all modules until one returns well-formed. If a\n+           * module doesn't know how to validate, we don't want to\n+           * throw arbitrary files at it, so we'll skip it.\n+           */\n+          //Iterator iter = _moduleList.iterator();\n+          Iterator<Module> iter = jb.getModuleList().iterator();\n+          while (iter.hasNext()) {\n+            Module mod = iter.next();\n+            RepInfo infc = (RepInfo) info.clone();\n+\n+            if (mod.hasFeature(\"edu.harvard.hul.ois.jhove.canValidate\")) {\n+              if (DEBUG) {\n+                logger.fine(\"Trying to apply Jhove module \" + mod.getName());\n+              }\n+              try {\n+                if (!jb.processFile(jhoveApp, mod, false, file, infc)) {\n+                  continue;\n                 }\n-            }\n-            \n-            if (DEBUG){\n-                logger.fine(\"file name=\"+file.getAbsolutePath());\n-            }\n-            \n-            // get a RepInfo instance\n-            if (file.exists() &&  file.isFile() && (file.length() > 0L)){\n-                //info = jb.processRepInfo(jhoveApp, module, file);\n-                info = new RepInfo(file.getAbsolutePath());\n-                info.setSize(file.length());\n-                if (module != null) {\n-                    if (!jb.processFile(jhoveApp, module, false, file, info)) {\n-                        info = null; \n-                    } else {\n-                        if (DEBUG) {\n-                            logger.fine(\"mime type (module specified above)=\"+info.getMimeType()); \n-                        }\n-                    }\n+                if (infc.getWellFormed() == RepInfo.TRUE) {\n+                  info.copy(infc);\n+                  break;\n                 } else {\n-                    /*\n-                     * Invoke all modules until one returns well-formed. If a\n-                     * module doesn't know how to validate, we don't want to\n-                     * throw arbitrary files at it, so we'll skip it.\n-                     */\n-                    //Iterator iter = _moduleList.iterator();\n-                    Iterator<Module> iter = jb.getModuleList().iterator();\n-                    while (iter.hasNext()) {\n-                        Module mod = iter.next();\n-                        RepInfo infc = (RepInfo) info.clone();\n-\n-                        if (mod.hasFeature(\"edu.harvard.hul.ois.jhove.canValidate\")) {\n-                            if (DEBUG) {\n-                                logger.fine(\"Trying to apply Jhove module \"+mod.getName());\n-                            }\n-                            try {\n-                                if (!jb.processFile(jhoveApp, mod, false, file, infc)) {\n-                                    continue;\n-                                }\n-                                if (infc.getWellFormed() == RepInfo.TRUE) {\n-                                    info.copy(infc);\n-                                    break;\n-                                } else {\n-\t\t\t            // We want to know what modules matched the\n-                                    // signature, so we force the sigMatch\n-                                    // property\n-                                    // to be persistent.\n-                                    info.setSigMatch(infc.getSigMatch());\n-                                }\n-                            } catch (Exception e) {\n-                                /*\n-                                 * The assumption is that in trying to analyze\n-                                 * the wrong type of file, the module may go off\n-                                 * its track and throw an exception, so we just\n-                                 * continue on to the next module.\n-                                 */\n-                                continue;\n-                            }\n-                        }\n-                    } \n+                  // We want to know what modules matched the\n+                  // signature, so we force the sigMatch\n+                  // property\n+                  // to be persistent.\n+                  info.setSigMatch(infc.getSigMatch());\n                 }\n-            } else {\n-                logger.warning(\"Jhove: the specified file does not exist or not a file or empty\");\n+              } catch (Exception e) {\n+                /*\n+                 * The assumption is that in trying to analyze\n+                 * the wrong type of file, the module may go off\n+                 * its track and throw an exception, so we just\n+                 * continue on to the next module.\n+                 */\n+                continue;\n+              }\n             }\n-        } catch (IOException ex){\n-            ex.printStackTrace();\n-        }   catch (Exception e) {\n-            e.printStackTrace();\n+          }\n         }\n-        return info;\n+      } else {\n+        logger.warning(\"Jhove: the specified file does not exist or not a file or empty\");\n+      }\n+    } catch (IOException ex) {\n+      ex.printStackTrace();\n+    } catch (Exception e) {\n+      e.printStackTrace();\n     }\n-    \n-    /**\n-     * A convenience method that returns the value of the mime type tag only\n-     */\n-     \n-    public String getFileMimeType(File file) {\n-        String mimeType = null;\n-        boolean DEBUG = false;\n-        \n-        if (file.exists() &&  file.isFile() && (file.length() > 0L)){\n-            RepInfo info = checkFileType(file);\n-            if (info != null) {\n-                mimeType = info.getMimeType();\n-            }\n-        }\n-        \n-        return mimeType;\n+    return info;\n+  }\n+\n+  /**\n+   * A convenience method that returns the value of the mime type tag only\n+   */\n+\n+  public String getFileMimeType(File file) {\n+    String mimeType = null;\n+    boolean DEBUG = false;\n+\n+    if (file.exists() && file.isFile() && (file.length() > 0L)) {\n+      RepInfo info = checkFileType(file);\n+      if (info != null) {\n+        mimeType = info.getMimeType();\n+      }\n     }\n+\n+    return mimeType;\n+  }\n }\n",
            "diff_size": 234
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/67/JhoveFileType.java\nindex 8a4ed81bc5b..0d7e6d585e9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/67/JhoveFileType.java\n@@ -38,15 +38,14 @@ import java.util.logging.Logger;\n  * @author landreev\n  *\n  */\n-public class JhoveFileType implements java.io.Serializable  {\n+\n+\n+public class JhoveFileType implements java.io.Serializable {\n+\n     private static final Logger logger = Logger.getLogger(JhoveFileType.class.getCanonicalName());\n \n-     \n-    public JhoveFileType() {\n-        \n-    }\n-    \n-    \n+    public JhoveFileType() {}\n+\n     public static String getJhoveConfigFile() {\n         Properties p = System.getProperties();\n         String domainRoot = p.getProperty(\"com.sun.aas.instanceRoot\");\n@@ -54,82 +53,75 @@ public class JhoveFileType implements java.io.Serializable  {\n             // When testing statically from JUnit, we expect domainRoot to be null.\n             return null;\n         }\n-        return domainRoot+File.separator+\"config\"+File.separator+\"jhove.conf\";\n+        return domainRoot + File.separator + \"config\" + File.separator + \"jhove.conf\";\n     }\n-    \n-    private static final int[] ORIGINAL_RELEASE_DATE = { 2013, 8, 30 };\n-    private static final String ORIGINAL_COPR_RIGHTS = \"Copyright\"\n-        +\"2004-2007 by the President and Fellows of Harvard College. \"\n-        + \"Released under the GNU Lesser General Public License.\";\n+\n+    private static final int[] ORIGINAL_RELEASE_DATE = {2013, 8, 30};\n+    private static final String ORIGINAL_COPR_RIGHTS = \"Copyright\" + \"2004-2007 by the President and Fellows of Harvard College. \" + \"Released under the GNU Lesser General Public License.\";\n     \n     /**\n      * A method that returns Jhove's RepInfo\n      */\n-    \n+\n     public RepInfo checkFileType(File file) {\n         RepInfo info = null;\n         boolean DEBUG = false;\n-        \n         try {\n             // initialize the application spec object\n             // name, release number, build date, usage, Copyright infor\n             // TODO: Should the release number come from pom.xml as we upgrade from 1.11.0 to 1.20.1?\n-            App jhoveApp = new App(\"Jhove\", \"1.20.1\",\n-                           ORIGINAL_RELEASE_DATE, \"Java JhoveFileType\", \n-                           ORIGINAL_COPR_RIGHTS);\n+            App jhoveApp = new App(\"Jhove\", \"1.20.1\", ORIGINAL_RELEASE_DATE, \"Java JhoveFileType\", ORIGINAL_COPR_RIGHTS);\n \n             //String configFile = JhoveBase.getConfigFileFromProperties();\n             String saxClass = JhoveBase.getSaxClassFromProperties();\n-\n             String configFile = getJhoveConfigFile();\n-            logger.fine(\"config file: \"+configFile);\n+            logger.fine(\"config file: \" + configFile);\n             if (configFile == null) {\n                 logger.info(\"Called getJhoveConfigFile but the result was null! Configuring JHOVE is highly recommended to determine file types.\");\n             }\n         \n             // create an instance of jhove engine\n+\n             JhoveBase jb = new JhoveBase();\n             if (DEBUG) {\n-                jb.setLogLevel(\"INFO\"); \n+                jb.setLogLevel(\"INFO\");\n             } else {\n                 jb.setLogLevel(\"SEVERE\");\n             }\n             jb.init(configFile, saxClass);\n-\n             jb.setEncoding(\"utf-8\"); // encoding\n             jb.setTempDirectory(\"/tmp\");\n             jb.setBufferSize(131072); // bufferSize\n-\n             jb.setChecksumFlag(false); // -s option\n             jb.setShowRawFlag(false);  // -r option \n             jb.setSignatureFlag(true); // -k option\n             \n             // String moduleName = null;\n             Module module = jb.getModule(null);\n-            \n             if (DEBUG) {\n                 if (module != null) {\n-                    logger.fine(\"Module \"+module.getName());\n+                    logger.fine(\"Module \" + module.getName());\n                 } else {\n                     logger.fine(\"module is null!\");\n                 }\n             }\n-            \n-            if (DEBUG){\n-                logger.fine(\"file name=\"+file.getAbsolutePath());\n+\n+            if (DEBUG) {\n+                logger.fine(\"file name=\" + file.getAbsolutePath());\n             }\n             \n             // get a RepInfo instance\n-            if (file.exists() &&  file.isFile() && (file.length() > 0L)){\n+\n+            if (file.exists() && file.isFile() && (file.length() > 0L)) {\n                 //info = jb.processRepInfo(jhoveApp, module, file);\n                 info = new RepInfo(file.getAbsolutePath());\n                 info.setSize(file.length());\n                 if (module != null) {\n                     if (!jb.processFile(jhoveApp, module, false, file, info)) {\n-                        info = null; \n+                        info = null;\n                     } else {\n                         if (DEBUG) {\n-                            logger.fine(\"mime type (module specified above)=\"+info.getMimeType()); \n+                            logger.fine(\"mime type (module specified above)=\" + info.getMimeType());\n                         }\n                     }\n                 } else {\n@@ -143,20 +135,20 @@ public class JhoveFileType implements java.io.Serializable  {\n                     while (iter.hasNext()) {\n                         Module mod = iter.next();\n                         RepInfo infc = (RepInfo) info.clone();\n-\n                         if (mod.hasFeature(\"edu.harvard.hul.ois.jhove.canValidate\")) {\n                             if (DEBUG) {\n-                                logger.fine(\"Trying to apply Jhove module \"+mod.getName());\n+                                logger.fine(\"Trying to apply Jhove module \" + mod.getName());\n                             }\n                             try {\n                                 if (!jb.processFile(jhoveApp, mod, false, file, infc)) {\n                                     continue;\n                                 }\n+\n                                 if (infc.getWellFormed() == RepInfo.TRUE) {\n                                     info.copy(infc);\n                                     break;\n                                 } else {\n-\t\t\t            // We want to know what modules matched the\n+                        // We want to know what modules matched the\n                                     // signature, so we force the sigMatch\n                                     // property\n                                     // to be persistent.\n@@ -172,14 +164,14 @@ public class JhoveFileType implements java.io.Serializable  {\n                                 continue;\n                             }\n                         }\n-                    } \n+                    }\n                 }\n             } else {\n                 logger.warning(\"Jhove: the specified file does not exist or not a file or empty\");\n             }\n-        } catch (IOException ex){\n+        } catch (IOException ex) {\n             ex.printStackTrace();\n-        }   catch (Exception e) {\n+        } catch (Exception e) {\n             e.printStackTrace();\n         }\n         return info;\n@@ -188,18 +180,17 @@ public class JhoveFileType implements java.io.Serializable  {\n     /**\n      * A convenience method that returns the value of the mime type tag only\n      */\n-     \n+\n     public String getFileMimeType(File file) {\n         String mimeType = null;\n         boolean DEBUG = false;\n-        \n-        if (file.exists() &&  file.isFile() && (file.length() > 0L)){\n+        if (file.exists() && file.isFile() && (file.length() > 0L)) {\n             RepInfo info = checkFileType(file);\n             if (info != null) {\n                 mimeType = info.getMimeType();\n             }\n         }\n-        \n         return mimeType;\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 49
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/67/JhoveFileType.java\nindex 8a4ed81bc5b..6c7c7b13cd4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/67/JhoveFileType.java\n@@ -156,8 +156,8 @@ public class JhoveFileType implements java.io.Serializable  {\n                                     info.copy(infc);\n                                     break;\n                                 } else {\n-\t\t\t            // We want to know what modules matched the\n-                                    // signature, so we force the sigMatch\n+                                   // We want to know what modules matched the\n+                               // signature, so we force the sigMatch\n                                     // property\n                                     // to be persistent.\n                                     info.setSigMatch(infc.getSigMatch());\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/67/JhoveFileType.java\nindex 8a4ed81bc5b..d762b985e55 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/67/JhoveFileType.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/67/JhoveFileType.java\n@@ -156,7 +156,7 @@ public class JhoveFileType implements java.io.Serializable  {\n                                     info.copy(infc);\n                                     break;\n                                 } else {\n-\t\t\t            // We want to know what modules matched the\n+                                    // We want to know what modules matched the\n                                     // signature, so we force the sigMatch\n                                     // property\n                                     // to be persistent.\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}