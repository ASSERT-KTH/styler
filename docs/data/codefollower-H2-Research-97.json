{
    "project_name": "codefollower-H2-Research",
    "error_id": "97",
    "information": {
        "errors": [
            {
                "line": "226",
                "column": "44",
                "severity": "warning",
                "message": "')' is preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
            }
        ]
    },
    "source_code": "        if (x == 0) {\n            return 1;\n        } else if (x < 0 || x > 0x40000000 ) {\n            throw new IllegalArgumentException(\"Argument out of range\"\n                    + \" [0x0-0x40000000]. Argument was: \" + x);\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/97/MathUtils.java\nindex f8af3889549..43e5063b335 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/97/MathUtils.java\n@@ -223,7 +223,7 @@ public class MathUtils {\n     public static int nextPowerOf2(int x) throws IllegalArgumentException {\n         if (x == 0) {\n             return 1;\n-        } else if (x < 0 || x > 0x40000000 ) {\n+        } else if (x < 0 || x > 0x40000000) {\n             throw new IllegalArgumentException(\"Argument out of range\"\n                     + \" [0x0-0x40000000]. Argument was: \" + x);\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/97/MathUtils.java\nindex f8af3889549..29f8c16a229 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/97/MathUtils.java\n@@ -3,6 +3,7 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.util;\n \n import java.io.ByteArrayOutputStream;\n@@ -17,305 +18,305 @@ import java.util.concurrent.ThreadLocalRandom;\n  */\n public class MathUtils {\n \n-    /**\n-     * The secure random object.\n-     */\n-    static SecureRandom cachedSecureRandom;\n+  /**\n+   * The secure random object.\n+   */\n+  static SecureRandom cachedSecureRandom;\n \n-    /**\n-     * True if the secure random object is seeded.\n-     */\n-    static volatile boolean seeded;\n+  /**\n+   * True if the secure random object is seeded.\n+   */\n+  static volatile boolean seeded;\n \n-    private MathUtils() {\n-        // utility class\n-    }\n+  private MathUtils() {\n+    // utility class\n+  }\n \n \n-    /**\n-     * Round the value up to the next block size. The block size must be a power\n-     * of two. As an example, using the block size of 8, the following rounding\n-     * operations are done: 0 stays 0; values 1..8 results in 8, 9..16 results\n-     * in 16, and so on.\n-     *\n-     * @param x the value to be rounded\n-     * @param blockSizePowerOf2 the block size\n-     * @return the rounded value\n-     */\n-    public static int roundUpInt(int x, int blockSizePowerOf2) {\n-        return (x + blockSizePowerOf2 - 1) & (-blockSizePowerOf2);\n-    }\n+  /**\n+   * Round the value up to the next block size. The block size must be a power\n+   * of two. As an example, using the block size of 8, the following rounding\n+   * operations are done: 0 stays 0; values 1..8 results in 8, 9..16 results\n+   * in 16, and so on.\n+   *\n+   * @param x                 the value to be rounded\n+   * @param blockSizePowerOf2 the block size\n+   * @return the rounded value\n+   */\n+  public static int roundUpInt(int x, int blockSizePowerOf2) {\n+    return (x + blockSizePowerOf2 - 1) & (-blockSizePowerOf2);\n+  }\n \n-    /**\n-     * Round the value up to the next block size. The block size must be a power\n-     * of two. As an example, using the block size of 8, the following rounding\n-     * operations are done: 0 stays 0; values 1..8 results in 8, 9..16 results\n-     * in 16, and so on.\n-     *\n-     * @param x the value to be rounded\n-     * @param blockSizePowerOf2 the block size\n-     * @return the rounded value\n-     */\n-    public static long roundUpLong(long x, long blockSizePowerOf2) {\n-        return (x + blockSizePowerOf2 - 1) & (-blockSizePowerOf2);\n-    }\n-\n-    private static synchronized SecureRandom getSecureRandom() {\n-        if (cachedSecureRandom != null) {\n-            return cachedSecureRandom;\n-        }\n-        // Workaround for SecureRandom problem as described in\n-        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6202721\n-        // Can not do that in a static initializer block, because\n-        // threads are not started until after the initializer block exits\n-        try {\n-            cachedSecureRandom = SecureRandom.getInstance(\"SHA1PRNG\");\n-            // On some systems, secureRandom.generateSeed() is very slow.\n-            // In this case it is initialized using our own seed implementation\n-            // and afterwards (in the thread) using the regular algorithm.\n-            Runnable runnable = new Runnable() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n-                        byte[] seed = sr.generateSeed(20);\n-                        synchronized (cachedSecureRandom) {\n-                            cachedSecureRandom.setSeed(seed);\n-                            seeded = true;\n-                        }\n-                    } catch (Exception e) {\n-                        // NoSuchAlgorithmException\n-                        warn(\"SecureRandom\", e);\n-                    }\n-                }\n-            };\n+  /**\n+   * Round the value up to the next block size. The block size must be a power\n+   * of two. As an example, using the block size of 8, the following rounding\n+   * operations are done: 0 stays 0; values 1..8 results in 8, 9..16 results\n+   * in 16, and so on.\n+   *\n+   * @param x                 the value to be rounded\n+   * @param blockSizePowerOf2 the block size\n+   * @return the rounded value\n+   */\n+  public static long roundUpLong(long x, long blockSizePowerOf2) {\n+    return (x + blockSizePowerOf2 - 1) & (-blockSizePowerOf2);\n+  }\n \n-            try {\n-                Thread t = new Thread(runnable, \"Generate Seed\");\n-                // let the process terminate even if generating the seed is\n-                // really slow\n-                t.setDaemon(true);\n-                t.start();\n-                Thread.yield();\n-                try {\n-                    // normally, generateSeed takes less than 200 ms\n-                    t.join(400);\n-                } catch (InterruptedException e) {\n-                    warn(\"InterruptedException\", e);\n-                }\n-                if (!seeded) {\n-                    byte[] seed = generateAlternativeSeed();\n-                    // this never reduces randomness\n-                    synchronized (cachedSecureRandom) {\n-                        cachedSecureRandom.setSeed(seed);\n-                    }\n-                }\n-            } catch (SecurityException e) {\n-                // workaround for the Google App Engine: don't use a thread\n-                runnable.run();\n-                generateAlternativeSeed();\n+  private static synchronized SecureRandom getSecureRandom() {\n+    if (cachedSecureRandom != null) {\n+      return cachedSecureRandom;\n+    }\n+    // Workaround for SecureRandom problem as described in\n+    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6202721\n+    // Can not do that in a static initializer block, because\n+    // threads are not started until after the initializer block exits\n+    try {\n+      cachedSecureRandom = SecureRandom.getInstance(\"SHA1PRNG\");\n+      // On some systems, secureRandom.generateSeed() is very slow.\n+      // In this case it is initialized using our own seed implementation\n+      // and afterwards (in the thread) using the regular algorithm.\n+      Runnable runnable = new Runnable() {\n+        @Override\n+        public void run() {\n+          try {\n+            SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n+            byte[] seed = sr.generateSeed(20);\n+            synchronized (cachedSecureRandom) {\n+              cachedSecureRandom.setSeed(seed);\n+              seeded = true;\n             }\n-\n-        } catch (Exception e) {\n+          } catch (Exception e) {\n             // NoSuchAlgorithmException\n             warn(\"SecureRandom\", e);\n-            cachedSecureRandom = new SecureRandom();\n+          }\n         }\n-        return cachedSecureRandom;\n-    }\n+      };\n \n-    /**\n-     * Generate a seed value, using as much unpredictable data as possible.\n-     *\n-     * @return the seed\n-     */\n-    public static byte[] generateAlternativeSeed() {\n+      try {\n+        Thread t = new Thread(runnable, \"Generate Seed\");\n+        // let the process terminate even if generating the seed is\n+        // really slow\n+        t.setDaemon(true);\n+        t.start();\n+        Thread.yield();\n         try {\n-            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-            DataOutputStream out = new DataOutputStream(bout);\n+          // normally, generateSeed takes less than 200 ms\n+          t.join(400);\n+        } catch (InterruptedException e) {\n+          warn(\"InterruptedException\", e);\n+        }\n+        if (!seeded) {\n+          byte[] seed = generateAlternativeSeed();\n+          // this never reduces randomness\n+          synchronized (cachedSecureRandom) {\n+            cachedSecureRandom.setSeed(seed);\n+          }\n+        }\n+      } catch (SecurityException e) {\n+        // workaround for the Google App Engine: don't use a thread\n+        runnable.run();\n+        generateAlternativeSeed();\n+      }\n \n-            // milliseconds and nanoseconds\n-            out.writeLong(System.currentTimeMillis());\n-            out.writeLong(System.nanoTime());\n+    } catch (Exception e) {\n+      // NoSuchAlgorithmException\n+      warn(\"SecureRandom\", e);\n+      cachedSecureRandom = new SecureRandom();\n+    }\n+    return cachedSecureRandom;\n+  }\n \n-            // memory\n-            out.writeInt(new Object().hashCode());\n-            Runtime runtime = Runtime.getRuntime();\n-            out.writeLong(runtime.freeMemory());\n-            out.writeLong(runtime.maxMemory());\n-            out.writeLong(runtime.totalMemory());\n+  /**\n+   * Generate a seed value, using as much unpredictable data as possible.\n+   *\n+   * @return the seed\n+   */\n+  public static byte[] generateAlternativeSeed() {\n+    try {\n+      ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+      DataOutputStream out = new DataOutputStream(bout);\n \n-            // environment\n-            try {\n-                String s = System.getProperties().toString();\n-                // can't use writeUTF, as the string\n-                // might be larger than 64 KB\n-                out.writeInt(s.length());\n-                out.write(s.getBytes(\"UTF-8\"));\n-            } catch (Exception e) {\n-                warn(\"generateAlternativeSeed\", e);\n-            }\n+      // milliseconds and nanoseconds\n+      out.writeLong(System.currentTimeMillis());\n+      out.writeLong(System.nanoTime());\n \n-            // host name and ip addresses (if any)\n-            try {\n-                // workaround for the Google App Engine: don't use InetAddress\n-                Class<?> inetAddressClass = Class.forName(\n-                        \"java.net.InetAddress\");\n-                Object localHost = inetAddressClass.getMethod(\n-                        \"getLocalHost\").invoke(null);\n-                String hostName = inetAddressClass.getMethod(\n-                        \"getHostName\").invoke(localHost).toString();\n-                out.writeUTF(hostName);\n-                Object[] list = (Object[]) inetAddressClass.getMethod(\n-                        \"getAllByName\", String.class).invoke(null, hostName);\n-                Method getAddress = inetAddressClass.getMethod(\n-                        \"getAddress\");\n-                for (Object o : list) {\n-                    out.write((byte[]) getAddress.invoke(o));\n-                }\n-            } catch (Throwable e) {\n-                // on some system, InetAddress is not supported\n-                // on some system, InetAddress.getLocalHost() doesn't work\n-                // for some reason (incorrect configuration)\n-            }\n+      // memory\n+      out.writeInt(new Object().hashCode());\n+      Runtime runtime = Runtime.getRuntime();\n+      out.writeLong(runtime.freeMemory());\n+      out.writeLong(runtime.maxMemory());\n+      out.writeLong(runtime.totalMemory());\n \n-            // timing (a second thread is already running usually)\n-            for (int j = 0; j < 16; j++) {\n-                int i = 0;\n-                long end = System.currentTimeMillis();\n-                while (end == System.currentTimeMillis()) {\n-                    i++;\n-                }\n-                out.writeInt(i);\n-            }\n+      // environment\n+      try {\n+        String s = System.getProperties().toString();\n+        // can't use writeUTF, as the string\n+        // might be larger than 64 KB\n+        out.writeInt(s.length());\n+        out.write(s.getBytes(\"UTF-8\"));\n+      } catch (Exception e) {\n+        warn(\"generateAlternativeSeed\", e);\n+      }\n \n-            out.close();\n-            return bout.toByteArray();\n-        } catch (IOException e) {\n-            warn(\"generateAlternativeSeed\", e);\n-            return new byte[1];\n+      // host name and ip addresses (if any)\n+      try {\n+        // workaround for the Google App Engine: don't use InetAddress\n+        Class<?> inetAddressClass = Class.forName(\n+            \"java.net.InetAddress\");\n+        Object localHost = inetAddressClass.getMethod(\n+            \"getLocalHost\").invoke(null);\n+        String hostName = inetAddressClass.getMethod(\n+            \"getHostName\").invoke(localHost).toString();\n+        out.writeUTF(hostName);\n+        Object[] list = (Object[]) inetAddressClass.getMethod(\n+            \"getAllByName\", String.class).invoke(null, hostName);\n+        Method getAddress = inetAddressClass.getMethod(\n+            \"getAddress\");\n+        for (Object o : list) {\n+          out.write((byte[]) getAddress.invoke(o));\n         }\n-    }\n+      } catch (Throwable e) {\n+        // on some system, InetAddress is not supported\n+        // on some system, InetAddress.getLocalHost() doesn't work\n+        // for some reason (incorrect configuration)\n+      }\n \n-    /**\n-     * Print a message to system output if there was a problem initializing the\n-     * random number generator.\n-     *\n-     * @param s the message to print\n-     * @param t the stack trace\n-     */\n-    private static void warn(String s, Throwable t) {\n-        // not a fatal problem, but maybe reduced security\n-        System.out.println(\"Warning: \" + s);\n-        if (t != null) {\n-            t.printStackTrace();\n+      // timing (a second thread is already running usually)\n+      for (int j = 0; j < 16; j++) {\n+        int i = 0;\n+        long end = System.currentTimeMillis();\n+        while (end == System.currentTimeMillis()) {\n+          i++;\n         }\n-    }\n+        out.writeInt(i);\n+      }\n \n-    /**\n-     * Get the value that is equal to or higher than this value, and that is a\n-     * power of two.\n-     *\n-     * @param x the original value\n-     * @return the next power of two value\n-     * @throws IllegalArgumentException if x < 0 or x > 0x40000000\n-     */\n-    public static int nextPowerOf2(int x) throws IllegalArgumentException {\n-        if (x == 0) {\n-            return 1;\n-        } else if (x < 0 || x > 0x40000000 ) {\n-            throw new IllegalArgumentException(\"Argument out of range\"\n-                    + \" [0x0-0x40000000]. Argument was: \" + x);\n-        }\n-        x--;\n-        x |= x >> 1;\n-        x |= x >> 2;\n-        x |= x >> 4;\n-        x |= x >> 8;\n-        x |= x >> 16;\n-        return ++x;\n+      out.close();\n+      return bout.toByteArray();\n+    } catch (IOException e) {\n+      warn(\"generateAlternativeSeed\", e);\n+      return new byte[1];\n     }\n+  }\n \n-    /**\n-     * Convert a long value to an int value. Values larger than the biggest int\n-     * value is converted to the biggest int value, and values smaller than the\n-     * smallest int value are converted to the smallest int value.\n-     *\n-     * @param l the value to convert\n-     * @return the converted int value\n-     */\n-    public static int convertLongToInt(long l) {\n-        if (l <= Integer.MIN_VALUE) {\n-            return Integer.MIN_VALUE;\n-        } else if (l >= Integer.MAX_VALUE) {\n-            return Integer.MAX_VALUE;\n-        } else {\n-            return (int) l;\n-        }\n+  /**\n+   * Print a message to system output if there was a problem initializing the\n+   * random number generator.\n+   *\n+   * @param s the message to print\n+   * @param t the stack trace\n+   */\n+  private static void warn(String s, Throwable t) {\n+    // not a fatal problem, but maybe reduced security\n+    System.out.println(\"Warning: \" + s);\n+    if (t != null) {\n+      t.printStackTrace();\n     }\n+  }\n \n-    /**\n-     * Get a cryptographically secure pseudo random long value.\n-     *\n-     * @return the random long value\n-     */\n-    public static long secureRandomLong() {\n-        SecureRandom sr = getSecureRandom();\n-        synchronized (sr) {\n-            return sr.nextLong();\n-        }\n+  /**\n+   * Get the value that is equal to or higher than this value, and that is a\n+   * power of two.\n+   *\n+   * @param x the original value\n+   * @return the next power of two value\n+   * @throws IllegalArgumentException if x < 0 or x > 0x40000000\n+   */\n+  public static int nextPowerOf2(int x) throws IllegalArgumentException {\n+    if (x == 0) {\n+      return 1;\n+    } else if (x < 0 || x > 0x40000000) {\n+      throw new IllegalArgumentException(\"Argument out of range\"\n+          + \" [0x0-0x40000000]. Argument was: \" + x);\n     }\n+    x--;\n+    x |= x >> 1;\n+    x |= x >> 2;\n+    x |= x >> 4;\n+    x |= x >> 8;\n+    x |= x >> 16;\n+    return ++x;\n+  }\n \n-    /**\n-     * Get a number of pseudo random bytes.\n-     *\n-     * @param bytes the target array\n-     */\n-    public static void randomBytes(byte[] bytes) {\n-        ThreadLocalRandom.current().nextBytes(bytes);\n+  /**\n+   * Convert a long value to an int value. Values larger than the biggest int\n+   * value is converted to the biggest int value, and values smaller than the\n+   * smallest int value are converted to the smallest int value.\n+   *\n+   * @param l the value to convert\n+   * @return the converted int value\n+   */\n+  public static int convertLongToInt(long l) {\n+    if (l <= Integer.MIN_VALUE) {\n+      return Integer.MIN_VALUE;\n+    } else if (l >= Integer.MAX_VALUE) {\n+      return Integer.MAX_VALUE;\n+    } else {\n+      return (int) l;\n     }\n+  }\n \n-    /**\n-     * Get a number of cryptographically secure pseudo random bytes.\n-     *\n-     * @param len the number of bytes\n-     * @return the random bytes\n-     */\n-    public static byte[] secureRandomBytes(int len) {\n-        if (len <= 0) {\n-            len = 1;\n-        }\n-        byte[] buff = new byte[len];\n-        SecureRandom sr = getSecureRandom();\n-        synchronized (sr) {\n-            sr.nextBytes(buff);\n-        }\n-        return buff;\n+  /**\n+   * Get a cryptographically secure pseudo random long value.\n+   *\n+   * @return the random long value\n+   */\n+  public static long secureRandomLong() {\n+    SecureRandom sr = getSecureRandom();\n+    synchronized (sr) {\n+      return sr.nextLong();\n     }\n+  }\n+\n+  /**\n+   * Get a number of pseudo random bytes.\n+   *\n+   * @param bytes the target array\n+   */\n+  public static void randomBytes(byte[] bytes) {\n+    ThreadLocalRandom.current().nextBytes(bytes);\n+  }\n \n-    /**\n-     * Get a pseudo random int value between 0 (including and the given value\n-     * (excluding). The value is not cryptographically secure.\n-     *\n-     * @param lowerThan the value returned will be lower than this value\n-     * @return the random long value\n-     */\n-    public static int randomInt(int lowerThan) {\n-        return ThreadLocalRandom.current().nextInt(lowerThan);\n+  /**\n+   * Get a number of cryptographically secure pseudo random bytes.\n+   *\n+   * @param len the number of bytes\n+   * @return the random bytes\n+   */\n+  public static byte[] secureRandomBytes(int len) {\n+    if (len <= 0) {\n+      len = 1;\n     }\n+    byte[] buff = new byte[len];\n+    SecureRandom sr = getSecureRandom();\n+    synchronized (sr) {\n+      sr.nextBytes(buff);\n+    }\n+    return buff;\n+  }\n \n-    /**\n-     * Get a cryptographically secure pseudo random int value between 0\n-     * (including and the given value (excluding).\n-     *\n-     * @param lowerThan the value returned will be lower than this value\n-     * @return the random long value\n-     */\n-    public static int secureRandomInt(int lowerThan) {\n-        SecureRandom sr = getSecureRandom();\n-        synchronized (sr) {\n-            return sr.nextInt(lowerThan);\n-        }\n+  /**\n+   * Get a pseudo random int value between 0 (including and the given value\n+   * (excluding). The value is not cryptographically secure.\n+   *\n+   * @param lowerThan the value returned will be lower than this value\n+   * @return the random long value\n+   */\n+  public static int randomInt(int lowerThan) {\n+    return ThreadLocalRandom.current().nextInt(lowerThan);\n+  }\n+\n+  /**\n+   * Get a cryptographically secure pseudo random int value between 0\n+   * (including and the given value (excluding).\n+   *\n+   * @param lowerThan the value returned will be lower than this value\n+   * @return the random long value\n+   */\n+  public static int secureRandomInt(int lowerThan) {\n+    SecureRandom sr = getSecureRandom();\n+    synchronized (sr) {\n+      return sr.nextInt(lowerThan);\n     }\n+  }\n \n }\n",
            "diff_size": 357
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/97/MathUtils.java\nindex f8af3889549..f3dc6bb6bcc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/97/MathUtils.java\n@@ -223,7 +223,7 @@ public class MathUtils {\n     public static int nextPowerOf2(int x) throws IllegalArgumentException {\n         if (x == 0) {\n             return 1;\n-        } else if (x < 0 || x > 0x40000000 ) {\n+        } else if (x < 0 || x > 0x40000000) {\n             throw new IllegalArgumentException(\"Argument out of range\"\n                     + \" [0x0-0x40000000]. Argument was: \" + x);\n         }\n@@ -318,4 +318,4 @@ public class MathUtils {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 2
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/97/MathUtils.java\nindex f8af3889549..6a1a8c6af04 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/97/MathUtils.java\n@@ -15,20 +15,27 @@ import java.util.concurrent.ThreadLocalRandom;\n /**\n  * This is a utility class with mathematical helper functions.\n  */\n+\n+\n public class MathUtils {\n \n     /**\n      * The secure random object.\n      */\n+\n+\n     static SecureRandom cachedSecureRandom;\n \n     /**\n      * True if the secure random object is seeded.\n      */\n+\n+\n     static volatile boolean seeded;\n \n     private MathUtils() {\n         // utility class\n+\n     }\n \n \n@@ -42,6 +49,8 @@ public class MathUtils {\n      * @param blockSizePowerOf2 the block size\n      * @return the rounded value\n      */\n+\n+\n     public static int roundUpInt(int x, int blockSizePowerOf2) {\n         return (x + blockSizePowerOf2 - 1) & (-blockSizePowerOf2);\n     }\n@@ -56,6 +65,8 @@ public class MathUtils {\n      * @param blockSizePowerOf2 the block size\n      * @return the rounded value\n      */\n+\n+\n     public static long roundUpLong(long x, long blockSizePowerOf2) {\n         return (x + blockSizePowerOf2 - 1) & (-blockSizePowerOf2);\n     }\n@@ -74,22 +85,21 @@ public class MathUtils {\n             // In this case it is initialized using our own seed implementation\n             // and afterwards (in the thread) using the regular algorithm.\n             Runnable runnable = new Runnable() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n-                        byte[] seed = sr.generateSeed(20);\n-                        synchronized (cachedSecureRandom) {\n-                            cachedSecureRandom.setSeed(seed);\n-                            seeded = true;\n-                        }\n-                    } catch (Exception e) {\n+                         @Override\n+                         public void run() {\n+                             try {\n+                                 SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n+                                 byte[] seed = sr.generateSeed(20);\n+                                 synchronized (cachedSecureRandom) {\n+                                     cachedSecureRandom.setSeed(seed);\n+                                     seeded = true;\n+                                 }\n+                             } catch (Exception e) {\n                         // NoSuchAlgorithmException\n-                        warn(\"SecureRandom\", e);\n-                    }\n-                }\n-            };\n-\n+                                 warn(\"SecureRandom\", e);\n+                             }\n+                         }\n+                     };\n             try {\n                 Thread t = new Thread(runnable, \"Generate Seed\");\n                 // let the process terminate even if generating the seed is\n@@ -115,7 +125,6 @@ public class MathUtils {\n                 runnable.run();\n                 generateAlternativeSeed();\n             }\n-\n         } catch (Exception e) {\n             // NoSuchAlgorithmException\n             warn(\"SecureRandom\", e);\n@@ -129,6 +138,8 @@ public class MathUtils {\n      *\n      * @return the seed\n      */\n+\n+\n     public static byte[] generateAlternativeSeed() {\n         try {\n             ByteArrayOutputStream bout = new ByteArrayOutputStream();\n@@ -159,17 +170,12 @@ public class MathUtils {\n             // host name and ip addresses (if any)\n             try {\n                 // workaround for the Google App Engine: don't use InetAddress\n-                Class<?> inetAddressClass = Class.forName(\n-                        \"java.net.InetAddress\");\n-                Object localHost = inetAddressClass.getMethod(\n-                        \"getLocalHost\").invoke(null);\n-                String hostName = inetAddressClass.getMethod(\n-                        \"getHostName\").invoke(localHost).toString();\n+                Class<?> inetAddressClass = Class.forName(\"java.net.InetAddress\");\n+                Object localHost = inetAddressClass.getMethod(\"getLocalHost\").invoke(null);\n+                String hostName = inetAddressClass.getMethod(\"getHostName\").invoke(localHost).toString();\n                 out.writeUTF(hostName);\n-                Object[] list = (Object[]) inetAddressClass.getMethod(\n-                        \"getAllByName\", String.class).invoke(null, hostName);\n-                Method getAddress = inetAddressClass.getMethod(\n-                        \"getAddress\");\n+                Object[] list = (Object[]) inetAddressClass.getMethod(\"getAllByName\", String.class).invoke(null, hostName);\n+                Method getAddress = inetAddressClass.getMethod(\"getAddress\");\n                 for (Object o : list) {\n                     out.write((byte[]) getAddress.invoke(o));\n                 }\n@@ -177,6 +183,7 @@ public class MathUtils {\n                 // on some system, InetAddress is not supported\n                 // on some system, InetAddress.getLocalHost() doesn't work\n                 // for some reason (incorrect configuration)\n+\n             }\n \n             // timing (a second thread is already running usually)\n@@ -188,7 +195,6 @@ public class MathUtils {\n                 }\n                 out.writeInt(i);\n             }\n-\n             out.close();\n             return bout.toByteArray();\n         } catch (IOException e) {\n@@ -204,6 +210,7 @@ public class MathUtils {\n      * @param s the message to print\n      * @param t the stack trace\n      */\n+\n     private static void warn(String s, Throwable t) {\n         // not a fatal problem, but maybe reduced security\n         System.out.println(\"Warning: \" + s);\n@@ -220,12 +227,13 @@ public class MathUtils {\n      * @return the next power of two value\n      * @throws IllegalArgumentException if x < 0 or x > 0x40000000\n      */\n+\n+\n     public static int nextPowerOf2(int x) throws IllegalArgumentException {\n         if (x == 0) {\n             return 1;\n-        } else if (x < 0 || x > 0x40000000 ) {\n-            throw new IllegalArgumentException(\"Argument out of range\"\n-                    + \" [0x0-0x40000000]. Argument was: \" + x);\n+        } else if (x < 0 || x > 0x40000000) {\n+            throw new IllegalArgumentException(\"Argument out of range\" + \" [0x0-0x40000000]. Argument was: \" + x);\n         }\n         x--;\n         x |= x >> 1;\n@@ -244,12 +252,14 @@ public class MathUtils {\n      * @param l the value to convert\n      * @return the converted int value\n      */\n+\n+\n     public static int convertLongToInt(long l) {\n         if (l <= Integer.MIN_VALUE) {\n             return Integer.MIN_VALUE;\n         } else if (l >= Integer.MAX_VALUE) {\n             return Integer.MAX_VALUE;\n-        } else {\n+                                               } else {\n             return (int) l;\n         }\n     }\n@@ -259,6 +269,8 @@ public class MathUtils {\n      *\n      * @return the random long value\n      */\n+\n+\n     public static long secureRandomLong() {\n         SecureRandom sr = getSecureRandom();\n         synchronized (sr) {\n@@ -271,6 +283,8 @@ public class MathUtils {\n      *\n      * @param bytes the target array\n      */\n+\n+\n     public static void randomBytes(byte[] bytes) {\n         ThreadLocalRandom.current().nextBytes(bytes);\n     }\n@@ -281,6 +295,8 @@ public class MathUtils {\n      * @param len the number of bytes\n      * @return the random bytes\n      */\n+\n+\n     public static byte[] secureRandomBytes(int len) {\n         if (len <= 0) {\n             len = 1;\n@@ -300,6 +316,8 @@ public class MathUtils {\n      * @param lowerThan the value returned will be lower than this value\n      * @return the random long value\n      */\n+\n+\n     public static int randomInt(int lowerThan) {\n         return ThreadLocalRandom.current().nextInt(lowerThan);\n     }\n@@ -311,6 +329,8 @@ public class MathUtils {\n      * @param lowerThan the value returned will be lower than this value\n      * @return the random long value\n      */\n+\n+\n     public static int secureRandomInt(int lowerThan) {\n         SecureRandom sr = getSecureRandom();\n         synchronized (sr) {\n@@ -318,4 +338,4 @@ public class MathUtils {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 61
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/97/MathUtils.java\nindex f8af3889549..43e5063b335 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/97/MathUtils.java\n@@ -223,7 +223,7 @@ public class MathUtils {\n     public static int nextPowerOf2(int x) throws IllegalArgumentException {\n         if (x == 0) {\n             return 1;\n-        } else if (x < 0 || x > 0x40000000 ) {\n+        } else if (x < 0 || x > 0x40000000) {\n             throw new IllegalArgumentException(\"Argument out of range\"\n                     + \" [0x0-0x40000000]. Argument was: \" + x);\n         }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/97/MathUtils.java\nindex f8af3889549..43e5063b335 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/97/MathUtils.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/97/MathUtils.java\n@@ -223,7 +223,7 @@ public class MathUtils {\n     public static int nextPowerOf2(int x) throws IllegalArgumentException {\n         if (x == 0) {\n             return 1;\n-        } else if (x < 0 || x > 0x40000000 ) {\n+        } else if (x < 0 || x > 0x40000000) {\n             throw new IllegalArgumentException(\"Argument out of range\"\n                     + \" [0x0-0x40000000]. Argument was: \" + x);\n         }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}