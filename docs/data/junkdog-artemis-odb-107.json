{
    "project_name": "junkdog-artemis-odb",
    "error_id": "107",
    "information": {
        "errors": [
            {
                "line": "68",
                "severity": "error",
                "message": "Line is longer than 105 characters (found 120).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\t *\n\t * @return element that was removed from the Bag\n\t * @deprecated Call {@link #removeIndex(int)} instead. {@link #remove(int)} will be removed in 3.0 due to ambiguity.\n\t *\n\t * @throws ArrayIndexOutOfBoundsException\n\t */",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "68",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "68",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/107/IntBag.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/intellij/107/IntBag.java\nindex 761c496ab50..463e9a9630a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/107/IntBag.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/intellij/107/IntBag.java\n@@ -8,333 +8,321 @@ import static java.lang.Math.max;\n /**\n  * Collection type a bit like ArrayList but does not preserve the order of its\n  * entities, speedwise it is very good, especially suited for games.\n- * \n  *\n  * @author original Bag by Arni Arent\n  */\n public class IntBag implements ImmutableIntBag {\n \n-\t/** The backing array. */\n-\tprivate int[] data;\n-\t/** The number of values stored by this bag. */\n-\tprotected int size = 0;\n-\n-\t/**\n-\t * Constructs an empty Bag with an initial capacity of 64.\n-\t */\n-\tpublic IntBag() {\n-\t\tthis(64);\n-\t}\n-\n-\t/**\n-\t * Constructs an empty Bag with the specified initial capacity.\n-\t * \n-\t * @param capacity\n-\t *\t\t\tthe initial capacity of Bag\n-\t */\n-\tpublic IntBag(int capacity) {\n-\t\tdata = new int[capacity];\n-\t}\n-\n-\n-\t/**\n-\t * Removes the first occurrence of the value from this IntBag, if\n-\t * it is present.\n-\t *\n-\t * @param value\n-\t *\t\t\tthe value to be removed\n-\t *\n-\t * @return true, if value was removed\n-\t */\n-\tpublic boolean removeValue(int value) throws ArrayIndexOutOfBoundsException {\n-\t\tint index = indexOf(value);\n-\t\tif (index > -1)\n-\t\t\tremoveIndex(index);\n-\n-\t\treturn index > -1;\n-\t}\n-\n-\t/**\n-\t * Removes the element at the specified position in this Bag.\n-\t * <p>\n-\t * It does this by overwriting it was last element then removing last\n-\t * element\n-\t * </p>\n-\t *\n-\t * @param index\n-\t *\t\t\tthe index of element to be removed\n-\t *\n-\t * @return element that was removed from the Bag\n-\t * @deprecated Call {@link #removeIndex(int)} instead. {@link #remove(int)} will be removed in 3.0 due to ambiguity.\n-\t *\n-\t * @throws ArrayIndexOutOfBoundsException\n-\t */\n-\t@Deprecated\n-\tpublic int remove(int index) throws ArrayIndexOutOfBoundsException {\n-\t\tint e = data[index]; // make copy of element to remove so it can be returned\n-\t\tdata[index] = data[--size]; // overwrite item to remove with last element\n-\t\tdata[size] = 0; // null last element, so gc can do its work\n-\t\treturn e;\n-\t}\n-\n-\t/**\n-\t * Removes the element at the specified position in this Bag.\n-\t * <p>\n-\t * It does this by overwriting it was last element then removing last\n-\t * element\n-\t * </p>\n-\t *\n-\t * @param index\n-\t *\t\t\tthe index of element to be removed\n-\t *\n-\t * @return element that was removed from the Bag\n-\t *\n-\t * @throws ArrayIndexOutOfBoundsException\n-\t */\n-\tpublic int removeIndex(int index) throws ArrayIndexOutOfBoundsException {\n-\t\tint e = data[index]; // make copy of element to remove so it can be returned\n-\t\tdata[index] = data[--size]; // overwrite item to remove with last element\n-\t\tdata[size] = 0; // null last element, so gc can do its work\n-\t\treturn e;\n-\t}\n-\n-\t/**\n-\t * Find index of element.\n-\t *\n-\t * @param value\n-\t *\t\t\telement to check\n-\t *\n-\t * @return index of element, or {@code -1} if there is no such index.\n-\t */\n-\tpublic int indexOf(int value) {\n-\t\tfor(int i = 0; size > i; i++) {\n-\t\t\tif(value == data[i]) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\treturn -1;\n-\t}\n-\n-\t/**\n-\t * Check if bag contains this element.\n-\t *\n-\t * @param value\n-\t *\t\t\telement to check\n-\t *\n-\t * @return {@code true} if the bag contains this element\n-\t */\n-\tpublic boolean contains(int value) {\n-\t\tfor(int i = 0; size > i; i++) {\n-\t\t\tif(value == data[i]) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Returns the element at the specified position in Bag.\n-\t *\n-\t * @param index\n-\t *\t\t\tindex of the element to return\n-\t *\n-\t * @return the element at the specified position in bag\n-\t *\n-\t * @throws ArrayIndexOutOfBoundsException\n-\t */\n-\tpublic int get(int index) throws ArrayIndexOutOfBoundsException {\n-\t\tif (index >= size) {\n-\t\t\tString message = \"tried accessing element \" + index + \"/\" + size;\n-\t\t\tthrow new ArrayIndexOutOfBoundsException(message);\n-\t\t}\n-\n-\t\treturn data[index];\n-\t}\n-\n-\t/**\n-\t * Returns the number of elements in this bag.\n-\t * \n-\t * @return the number of elements in this bag\n-\t */\n-\tpublic int size() {\n-\t\treturn size;\n-\t}\n-\t\n-\t/**\n-\t * Returns the number of elements the bag can hold without growing.\n-\t * \n-\t * @return the number of elements the bag can hold without growing\n-\t */\n-\tpublic int getCapacity() {\n-\t\treturn data.length;\n-\t}\n-\t\n-\t/**\n-\t * Checks if the internal storage supports this index.\n-\t * \n-\t * @param index\n-\t *\t\t\tindex to check\n-\t *\n-\t * @return {@code true} if the index is within bounds\n-\t */\n-\tpublic boolean isIndexWithinBounds(int index) {\n-\t\treturn index < getCapacity();\n-\t}\n-\n-\t/**\n-\t * Returns true if this bag contains no elements.\n-\t * \n-\t * @return {@code true} if this bag contains no elements\n-\t */\n-\tpublic boolean isEmpty() {\n-\t\treturn size == 0;\n-\t}\n-\n-\t/**\n-\t * Adds the specified element to the end of this bag.\n-\t * <p>\n-\t * If required, it also increases the capacity of the bag.\n-\t * </p>\n-\t * \n-\t * @param value\n-\t *\t\t\telement to be added to this list\n-\t */\n-\tpublic void add(int value) {\n-\t\t// is size greater than capacity increase capacity\n-\t\tif (size == data.length)\n-\t\t\tgrow(2 * data.length);\n-\n-\t\tdata[size++] = value;\n-\t}\n-\n-\t/**\n-\t * Adds the specified elements to the end of this bag.\n-\t * <p>\n-\t * If required, it also increases the capacity of the bag.\n-\t * </p>\n-\t *\n-\t * @param other\n-\t *\t\t\telements to be added to this list\n-\t */\n-\tpublic void addAll(IntBag other) {\n-\t\tfor (int i = 0; i < other.size(); i++) {\n-\t\t\tadd(other.data[i]);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Set element at specified index in the bag.\n-\t * \n-\t * @param index\n-\t *\t\t\tposition of element\n-\t * @param value\n-\t *\t\t\tthe element\n-\t */\n-\tpublic void set(int index, int value) {\n-\t\tif(index >= data.length) {\n-\t\t\tgrow(max((2 * data.length), index + 1));\n-\t\t}\n-\n-\t\tsize = max(size, index + 1);\n-\t\tdata[index] = value;\n-\t}\n-\n-\tprivate void grow(int newCapacity) throws ArrayIndexOutOfBoundsException {\n-\t\tint[] oldData = data;\n-\t\tdata = new int[newCapacity];\n-\t\tSystem.arraycopy(oldData, 0, data, 0, oldData.length);\n-\t}\n-\n-\t/**\n-\t * Check if an item, if added at the given item will fit into the bag.\n-\t * <p>\n-\t * If not, the bag capacity will be increased to hold an item at the index.\n-\t * </p>\n-\t *\n-\t * @param index\n-\t *\t\t\tindex to check\n-\t */\n-\tpublic void ensureCapacity(int index) {\n-\t\tif(index >= data.length) {\n-\t\t\tgrow(index + 1);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Removes all of the elements from this bag.\n-\t * <p>\n-\t * The bag will be empty after this call returns.\n-\t * </p>\n-\t */\n-\tpublic void clear() {\n-\t\tArrays.fill(data, 0, size, 0);\n-\t\tsize = 0;\n-\t}\n-\t\n-\t/**\n-\t * Returns this bag's underlying array.\n-\t * <p>\n-\t * Use with care.\n-\t * </p>\n-\t * \n-\t * @return the underlying array\n-\t *\n-\t * @see IntBag#size()\n-\t */\n-\tpublic int[] getData() {\n-\t\treturn data;\n-\t}\n-\n-\t/**\n-\t * Set the size.\n-\t * <p>\n-\t * This will not resize the bag, nor will it clean up contents beyond the\n-\t * given size. Use with caution.\n-\t * </p>\n-\t *\n-\t * @param size\n-\t *\t\t\tthe size to set\n-\t */\n-\tpublic void setSize(int size) {\n-\t\tthis.size = size;\n-\t}\n-\n-\t@Override\n-\tpublic boolean equals(Object o) {\n-\t\tif (this == o) return true;\n-\t\tif (o == null || getClass() != o.getClass()) return false;\n-\n-\t\tIntBag intBag = (IntBag) o;\n-\t\tif (size != intBag.size())\n-\t\t\treturn false;\n-\n-\t\tfor (int i = 0; size > i; i++) {\n-\t\t\tif (data[i] != intBag.data[i])\n-\t\t\t\treturn false;\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic int hashCode() {\n-\t\tint hash = 0;\n-\t\tfor (int i = 0, s = size; s > i; i++) {\n-\t\t\thash = (127 * hash) + data[i];\n-\t\t}\n-\n-\t\treturn hash;\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\tsb.append(\"IntBag(\");\n-\t\tfor (int i = 0; size > i; i++) {\n-\t\t\tif (i > 0) sb.append(\", \");\n-\t\t\tsb.append(data[i]);\n-\t\t}\n-\t\tsb.append(')');\n-\t\treturn sb.toString();\n-\t}\n+    /**\n+     * The backing array.\n+     */\n+    private int[] data;\n+    /**\n+     * The number of values stored by this bag.\n+     */\n+    protected int size = 0;\n+\n+    /**\n+     * Constructs an empty Bag with an initial capacity of 64.\n+     */\n+    public IntBag() {\n+        this(64);\n+    }\n+\n+    /**\n+     * Constructs an empty Bag with the specified initial capacity.\n+     *\n+     * @param capacity the initial capacity of Bag\n+     */\n+    public IntBag(int capacity) {\n+        data = new int[capacity];\n+    }\n+\n+\n+    /**\n+     * Removes the first occurrence of the value from this IntBag, if\n+     * it is present.\n+     *\n+     * @param value the value to be removed\n+     * @return true, if value was removed\n+     */\n+    public boolean removeValue(int value) throws ArrayIndexOutOfBoundsException {\n+        int index = indexOf(value);\n+        if (index > -1) {\n+            removeIndex(index);\n+        }\n+\n+        return index > -1;\n+    }\n+\n+    /**\n+     * Removes the element at the specified position in this Bag.\n+     * <p>\n+     * It does this by overwriting it was last element then removing last\n+     * element\n+     * </p>\n+     *\n+     * @param index the index of element to be removed\n+     * @return element that was removed from the Bag\n+     * @throws ArrayIndexOutOfBoundsException\n+     * @deprecated Call {@link #removeIndex(int)} instead. {@link #remove(int)} will be removed in 3.0 due to ambiguity.\n+     */\n+    @Deprecated\n+    public int remove(int index) throws ArrayIndexOutOfBoundsException {\n+        int e = data[index]; // make copy of element to remove so it can be returned\n+        data[index] = data[--size]; // overwrite item to remove with last element\n+        data[size] = 0; // null last element, so gc can do its work\n+        return e;\n+    }\n+\n+    /**\n+     * Removes the element at the specified position in this Bag.\n+     * <p>\n+     * It does this by overwriting it was last element then removing last\n+     * element\n+     * </p>\n+     *\n+     * @param index the index of element to be removed\n+     * @return element that was removed from the Bag\n+     * @throws ArrayIndexOutOfBoundsException\n+     */\n+    public int removeIndex(int index) throws ArrayIndexOutOfBoundsException {\n+        int e = data[index]; // make copy of element to remove so it can be returned\n+        data[index] = data[--size]; // overwrite item to remove with last element\n+        data[size] = 0; // null last element, so gc can do its work\n+        return e;\n+    }\n+\n+    /**\n+     * Find index of element.\n+     *\n+     * @param value element to check\n+     * @return index of element, or {@code -1} if there is no such index.\n+     */\n+    public int indexOf(int value) {\n+        for (int i = 0; size > i; i++) {\n+            if (value == data[i]) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Check if bag contains this element.\n+     *\n+     * @param value element to check\n+     * @return {@code true} if the bag contains this element\n+     */\n+    public boolean contains(int value) {\n+        for (int i = 0; size > i; i++) {\n+            if (value == data[i]) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the element at the specified position in Bag.\n+     *\n+     * @param index index of the element to return\n+     * @return the element at the specified position in bag\n+     * @throws ArrayIndexOutOfBoundsException\n+     */\n+    public int get(int index) throws ArrayIndexOutOfBoundsException {\n+        if (index >= size) {\n+            String message = \"tried accessing element \" + index + \"/\" + size;\n+            throw new ArrayIndexOutOfBoundsException(message);\n+        }\n+\n+        return data[index];\n+    }\n+\n+    /**\n+     * Returns the number of elements in this bag.\n+     *\n+     * @return the number of elements in this bag\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Returns the number of elements the bag can hold without growing.\n+     *\n+     * @return the number of elements the bag can hold without growing\n+     */\n+    public int getCapacity() {\n+        return data.length;\n+    }\n+\n+    /**\n+     * Checks if the internal storage supports this index.\n+     *\n+     * @param index index to check\n+     * @return {@code true} if the index is within bounds\n+     */\n+    public boolean isIndexWithinBounds(int index) {\n+        return index < getCapacity();\n+    }\n+\n+    /**\n+     * Returns true if this bag contains no elements.\n+     *\n+     * @return {@code true} if this bag contains no elements\n+     */\n+    public boolean isEmpty() {\n+        return size == 0;\n+    }\n+\n+    /**\n+     * Adds the specified element to the end of this bag.\n+     * <p>\n+     * If required, it also increases the capacity of the bag.\n+     * </p>\n+     *\n+     * @param value element to be added to this list\n+     */\n+    public void add(int value) {\n+        // is size greater than capacity increase capacity\n+        if (size == data.length) {\n+            grow(2 * data.length);\n+        }\n+\n+        data[size++] = value;\n+    }\n+\n+    /**\n+     * Adds the specified elements to the end of this bag.\n+     * <p>\n+     * If required, it also increases the capacity of the bag.\n+     * </p>\n+     *\n+     * @param other elements to be added to this list\n+     */\n+    public void addAll(IntBag other) {\n+        for (int i = 0; i < other.size(); i++) {\n+            add(other.data[i]);\n+        }\n+    }\n+\n+    /**\n+     * Set element at specified index in the bag.\n+     *\n+     * @param index position of element\n+     * @param value the element\n+     */\n+    public void set(int index, int value) {\n+        if (index >= data.length) {\n+            grow(max((2 * data.length), index + 1));\n+        }\n+\n+        size = max(size, index + 1);\n+        data[index] = value;\n+    }\n+\n+    private void grow(int newCapacity) throws ArrayIndexOutOfBoundsException {\n+        int[] oldData = data;\n+        data = new int[newCapacity];\n+        System.arraycopy(oldData, 0, data, 0, oldData.length);\n+    }\n+\n+    /**\n+     * Check if an item, if added at the given item will fit into the bag.\n+     * <p>\n+     * If not, the bag capacity will be increased to hold an item at the index.\n+     * </p>\n+     *\n+     * @param index index to check\n+     */\n+    public void ensureCapacity(int index) {\n+        if (index >= data.length) {\n+            grow(index + 1);\n+        }\n+    }\n+\n+    /**\n+     * Removes all of the elements from this bag.\n+     * <p>\n+     * The bag will be empty after this call returns.\n+     * </p>\n+     */\n+    public void clear() {\n+        Arrays.fill(data, 0, size, 0);\n+        size = 0;\n+    }\n+\n+    /**\n+     * Returns this bag's underlying array.\n+     * <p>\n+     * Use with care.\n+     * </p>\n+     *\n+     * @return the underlying array\n+     * @see IntBag#size()\n+     */\n+    public int[] getData() {\n+        return data;\n+    }\n+\n+    /**\n+     * Set the size.\n+     * <p>\n+     * This will not resize the bag, nor will it clean up contents beyond the\n+     * given size. Use with caution.\n+     * </p>\n+     *\n+     * @param size the size to set\n+     */\n+    public void setSize(int size) {\n+        this.size = size;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        IntBag intBag = (IntBag) o;\n+        if (size != intBag.size()) {\n+            return false;\n+        }\n+\n+        for (int i = 0; size > i; i++) {\n+            if (data[i] != intBag.data[i]) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        for (int i = 0, s = size; s > i; i++) {\n+            hash = (127 * hash) + data[i];\n+        }\n+\n+        return hash;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"IntBag(\");\n+        for (int i = 0; size > i; i++) {\n+            if (i > 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append(data[i]);\n+        }\n+        sb.append(')');\n+        return sb.toString();\n+    }\n }\n",
            "diff_size": 324
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "68",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/107/IntBag.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/naturalize/107/IntBag.java\nindex 761c496ab50..87ab02affd1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/107/IntBag.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/naturalize/107/IntBag.java\n@@ -337,4 +337,4 @@ public class IntBag implements ImmutableIntBag {\n \t\tsb.append(')');\n \t\treturn sb.toString();\n \t}\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "74",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 117).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/107/IntBag.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/codebuff/107/IntBag.java\nindex 761c496ab50..25e91c61fb4 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/107/IntBag.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/codebuff/107/IntBag.java\n@@ -12,329 +12,370 @@ import static java.lang.Math.max;\n  *\n  * @author original Bag by Arni Arent\n  */\n+\n+\n+\n public class IntBag implements ImmutableIntBag {\n \n-\t/** The backing array. */\n-\tprivate int[] data;\n-\t/** The number of values stored by this bag. */\n-\tprotected int size = 0;\n-\n-\t/**\n-\t * Constructs an empty Bag with an initial capacity of 64.\n-\t */\n-\tpublic IntBag() {\n-\t\tthis(64);\n-\t}\n-\n-\t/**\n-\t * Constructs an empty Bag with the specified initial capacity.\n-\t * \n-\t * @param capacity\n-\t *\t\t\tthe initial capacity of Bag\n-\t */\n-\tpublic IntBag(int capacity) {\n-\t\tdata = new int[capacity];\n-\t}\n-\n-\n-\t/**\n-\t * Removes the first occurrence of the value from this IntBag, if\n-\t * it is present.\n-\t *\n-\t * @param value\n-\t *\t\t\tthe value to be removed\n-\t *\n-\t * @return true, if value was removed\n-\t */\n-\tpublic boolean removeValue(int value) throws ArrayIndexOutOfBoundsException {\n-\t\tint index = indexOf(value);\n-\t\tif (index > -1)\n-\t\t\tremoveIndex(index);\n-\n-\t\treturn index > -1;\n-\t}\n-\n-\t/**\n-\t * Removes the element at the specified position in this Bag.\n-\t * <p>\n-\t * It does this by overwriting it was last element then removing last\n-\t * element\n-\t * </p>\n-\t *\n-\t * @param index\n-\t *\t\t\tthe index of element to be removed\n-\t *\n-\t * @return element that was removed from the Bag\n-\t * @deprecated Call {@link #removeIndex(int)} instead. {@link #remove(int)} will be removed in 3.0 due to ambiguity.\n-\t *\n-\t * @throws ArrayIndexOutOfBoundsException\n-\t */\n-\t@Deprecated\n-\tpublic int remove(int index) throws ArrayIndexOutOfBoundsException {\n-\t\tint e = data[index]; // make copy of element to remove so it can be returned\n-\t\tdata[index] = data[--size]; // overwrite item to remove with last element\n-\t\tdata[size] = 0; // null last element, so gc can do its work\n-\t\treturn e;\n-\t}\n-\n-\t/**\n-\t * Removes the element at the specified position in this Bag.\n-\t * <p>\n-\t * It does this by overwriting it was last element then removing last\n-\t * element\n-\t * </p>\n-\t *\n-\t * @param index\n-\t *\t\t\tthe index of element to be removed\n-\t *\n-\t * @return element that was removed from the Bag\n-\t *\n-\t * @throws ArrayIndexOutOfBoundsException\n-\t */\n-\tpublic int removeIndex(int index) throws ArrayIndexOutOfBoundsException {\n-\t\tint e = data[index]; // make copy of element to remove so it can be returned\n-\t\tdata[index] = data[--size]; // overwrite item to remove with last element\n-\t\tdata[size] = 0; // null last element, so gc can do its work\n-\t\treturn e;\n-\t}\n-\n-\t/**\n-\t * Find index of element.\n-\t *\n-\t * @param value\n-\t *\t\t\telement to check\n-\t *\n-\t * @return index of element, or {@code -1} if there is no such index.\n-\t */\n-\tpublic int indexOf(int value) {\n-\t\tfor(int i = 0; size > i; i++) {\n-\t\t\tif(value == data[i]) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\treturn -1;\n-\t}\n-\n-\t/**\n-\t * Check if bag contains this element.\n-\t *\n-\t * @param value\n-\t *\t\t\telement to check\n-\t *\n-\t * @return {@code true} if the bag contains this element\n-\t */\n-\tpublic boolean contains(int value) {\n-\t\tfor(int i = 0; size > i; i++) {\n-\t\t\tif(value == data[i]) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Returns the element at the specified position in Bag.\n-\t *\n-\t * @param index\n-\t *\t\t\tindex of the element to return\n-\t *\n-\t * @return the element at the specified position in bag\n-\t *\n-\t * @throws ArrayIndexOutOfBoundsException\n-\t */\n-\tpublic int get(int index) throws ArrayIndexOutOfBoundsException {\n-\t\tif (index >= size) {\n-\t\t\tString message = \"tried accessing element \" + index + \"/\" + size;\n-\t\t\tthrow new ArrayIndexOutOfBoundsException(message);\n-\t\t}\n-\n-\t\treturn data[index];\n-\t}\n-\n-\t/**\n-\t * Returns the number of elements in this bag.\n-\t * \n-\t * @return the number of elements in this bag\n-\t */\n-\tpublic int size() {\n-\t\treturn size;\n-\t}\n-\t\n-\t/**\n-\t * Returns the number of elements the bag can hold without growing.\n-\t * \n-\t * @return the number of elements the bag can hold without growing\n-\t */\n-\tpublic int getCapacity() {\n-\t\treturn data.length;\n-\t}\n-\t\n-\t/**\n-\t * Checks if the internal storage supports this index.\n-\t * \n-\t * @param index\n-\t *\t\t\tindex to check\n-\t *\n-\t * @return {@code true} if the index is within bounds\n-\t */\n-\tpublic boolean isIndexWithinBounds(int index) {\n-\t\treturn index < getCapacity();\n-\t}\n-\n-\t/**\n-\t * Returns true if this bag contains no elements.\n-\t * \n-\t * @return {@code true} if this bag contains no elements\n-\t */\n-\tpublic boolean isEmpty() {\n-\t\treturn size == 0;\n-\t}\n-\n-\t/**\n-\t * Adds the specified element to the end of this bag.\n-\t * <p>\n-\t * If required, it also increases the capacity of the bag.\n-\t * </p>\n-\t * \n-\t * @param value\n-\t *\t\t\telement to be added to this list\n-\t */\n-\tpublic void add(int value) {\n-\t\t// is size greater than capacity increase capacity\n-\t\tif (size == data.length)\n-\t\t\tgrow(2 * data.length);\n-\n-\t\tdata[size++] = value;\n-\t}\n-\n-\t/**\n-\t * Adds the specified elements to the end of this bag.\n-\t * <p>\n-\t * If required, it also increases the capacity of the bag.\n-\t * </p>\n-\t *\n-\t * @param other\n-\t *\t\t\telements to be added to this list\n-\t */\n-\tpublic void addAll(IntBag other) {\n-\t\tfor (int i = 0; i < other.size(); i++) {\n-\t\t\tadd(other.data[i]);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Set element at specified index in the bag.\n-\t * \n-\t * @param index\n-\t *\t\t\tposition of element\n-\t * @param value\n-\t *\t\t\tthe element\n-\t */\n-\tpublic void set(int index, int value) {\n-\t\tif(index >= data.length) {\n-\t\t\tgrow(max((2 * data.length), index + 1));\n-\t\t}\n-\n-\t\tsize = max(size, index + 1);\n-\t\tdata[index] = value;\n-\t}\n-\n-\tprivate void grow(int newCapacity) throws ArrayIndexOutOfBoundsException {\n-\t\tint[] oldData = data;\n-\t\tdata = new int[newCapacity];\n-\t\tSystem.arraycopy(oldData, 0, data, 0, oldData.length);\n-\t}\n-\n-\t/**\n-\t * Check if an item, if added at the given item will fit into the bag.\n-\t * <p>\n-\t * If not, the bag capacity will be increased to hold an item at the index.\n-\t * </p>\n-\t *\n-\t * @param index\n-\t *\t\t\tindex to check\n-\t */\n-\tpublic void ensureCapacity(int index) {\n-\t\tif(index >= data.length) {\n-\t\t\tgrow(index + 1);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Removes all of the elements from this bag.\n-\t * <p>\n-\t * The bag will be empty after this call returns.\n-\t * </p>\n-\t */\n-\tpublic void clear() {\n-\t\tArrays.fill(data, 0, size, 0);\n-\t\tsize = 0;\n-\t}\n-\t\n-\t/**\n-\t * Returns this bag's underlying array.\n-\t * <p>\n-\t * Use with care.\n-\t * </p>\n-\t * \n-\t * @return the underlying array\n-\t *\n-\t * @see IntBag#size()\n-\t */\n-\tpublic int[] getData() {\n-\t\treturn data;\n-\t}\n-\n-\t/**\n-\t * Set the size.\n-\t * <p>\n-\t * This will not resize the bag, nor will it clean up contents beyond the\n-\t * given size. Use with caution.\n-\t * </p>\n-\t *\n-\t * @param size\n-\t *\t\t\tthe size to set\n-\t */\n-\tpublic void setSize(int size) {\n-\t\tthis.size = size;\n-\t}\n-\n-\t@Override\n-\tpublic boolean equals(Object o) {\n-\t\tif (this == o) return true;\n-\t\tif (o == null || getClass() != o.getClass()) return false;\n-\n-\t\tIntBag intBag = (IntBag) o;\n-\t\tif (size != intBag.size())\n-\t\t\treturn false;\n-\n-\t\tfor (int i = 0; size > i; i++) {\n-\t\t\tif (data[i] != intBag.data[i])\n-\t\t\t\treturn false;\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic int hashCode() {\n-\t\tint hash = 0;\n-\t\tfor (int i = 0, s = size; s > i; i++) {\n-\t\t\thash = (127 * hash) + data[i];\n-\t\t}\n-\n-\t\treturn hash;\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\tsb.append(\"IntBag(\");\n-\t\tfor (int i = 0; size > i; i++) {\n-\t\t\tif (i > 0) sb.append(\", \");\n-\t\t\tsb.append(data[i]);\n-\t\t}\n-\t\tsb.append(')');\n-\t\treturn sb.toString();\n-\t}\n-}\n+ /** The backing array. */\n+ private int[] data;\n+ /** The number of values stored by this bag. */\n+\n+ protected int size = 0;\n+\n+ /**\n+  * Constructs an empty Bag with an initial capacity of 64.\n+  */\n+\n+ public IntBag() {\n+  this(64);\n+ }\n+\n+ /**\n+  * Constructs an empty Bag with the specified initial capacity.\n+  * \n+  * @param capacity\n+  *   the initial capacity of Bag\n+  */\n+\n+ public IntBag(int capacity) {\n+  data = new int[capacity];\n+ }\n+\n+\n+ /**\n+  * Removes the first occurrence of the value from this IntBag, if\n+  * it is present.\n+  *\n+  * @param value\n+  *   the value to be removed\n+  *\n+  * @return true, if value was removed\n+  */\n+\n+ public boolean removeValue(int value) throws ArrayIndexOutOfBoundsException {\n+  int index = indexOf(value);\n+  if (index > -1)\n+   removeIndex(index);\n+  return index > -1;\n+ }\n+\n+ /**\n+  * Removes the element at the specified position in this Bag.\n+  * <p>\n+  * It does this by overwriting it was last element then removing last\n+  * element\n+  * </p>\n+  *\n+  * @param index\n+  *   the index of element to be removed\n+  *\n+  * @return element that was removed from the Bag\n+  * @deprecated Call {@link #removeIndex(int)} instead. {@link #remove(int)} will be removed in 3.0 due to ambiguity.\n+  *\n+  * @throws ArrayIndexOutOfBoundsException\n+  */\n+\n+ @Deprecated\n+ public int remove(int index) throws ArrayIndexOutOfBoundsException {\n+  int e = data[index]; // make copy of element to remove so it can be returned\n+  data[index] = data[--size]; // overwrite item to remove with last element\n+  data[size] = 0; // null last element, so gc can do its work\n+  return e;\n+ }\n+\n+ /**\n+  * Removes the element at the specified position in this Bag.\n+  * <p>\n+  * It does this by overwriting it was last element then removing last\n+  * element\n+  * </p>\n+  *\n+  * @param index\n+  *   the index of element to be removed\n+  *\n+  * @return element that was removed from the Bag\n+  *\n+  * @throws ArrayIndexOutOfBoundsException\n+  */\n+\n+\n+ public int removeIndex(int index) throws ArrayIndexOutOfBoundsException {\n+  int e = data[index]; // make copy of element to remove so it can be returned\n+  data[index] = data[--size]; // overwrite item to remove with last element\n+  data[size] = 0; // null last element, so gc can do its work\n+  return e;\n+ }\n+\n+ /**\n+  * Find index of element.\n+  *\n+  * @param value\n+  *   element to check\n+  *\n+  * @return index of element, or {@code -1} if there is no such index.\n+  */\n+\n+\n+ public int indexOf(int value) {\n+  for (int i = 0; size > i; i++) {\n+   if (value == data[i]) {\n+    return i;\n+   }\n+  }\n+\n+  return -1;\n+ }\n+\n+ /**\n+  * Check if bag contains this element.\n+  *\n+  * @param value\n+  *   element to check\n+  *\n+  * @return {@code true} if the bag contains this element\n+  */\n+\n+\n+ public boolean contains(int value) {\n+  for (int i = 0; size > i; i++) {\n+   if (value == data[i]) {\n+    return true;\n+   }\n+  }\n+\n+  return false;\n+ }\n+\n+ /**\n+  * Returns the element at the specified position in Bag.\n+  *\n+  * @param index\n+  *   index of the element to return\n+  *\n+  * @return the element at the specified position in bag\n+  *\n+  * @throws ArrayIndexOutOfBoundsException\n+  */\n+\n+\n+ public int get(int index) throws ArrayIndexOutOfBoundsException {\n+  if (index >= size) {\n+   String message = \"tried accessing element \" + index + \"/\" + size;\n+   throw new ArrayIndexOutOfBoundsException(message);\n+  }\n+\n+  return data[index];\n+ }\n+\n+ /**\n+  * Returns the number of elements in this bag.\n+  * \n+  * @return the number of elements in this bag\n+  */\n+\n+\n+ public int size() {\n+  return size;\n+ }\n+ \n+ /**\n+  * Returns the number of elements the bag can hold without growing.\n+  * \n+  * @return the number of elements the bag can hold without growing\n+  */\n+\n+\n+ public int getCapacity() {\n+  return data.length;\n+ }\n+ \n+ /**\n+  * Checks if the internal storage supports this index.\n+  * \n+  * @param index\n+  *   index to check\n+  *\n+  * @return {@code true} if the index is within bounds\n+  */\n+\n+\n+ public boolean isIndexWithinBounds(int index) {\n+  return index < getCapacity();\n+ }\n+\n+ /**\n+  * Returns true if this bag contains no elements.\n+  * \n+  * @return {@code true} if this bag contains no elements\n+  */\n+\n+\n+ public boolean isEmpty() {\n+  return size == 0;\n+ }\n+\n+ /**\n+  * Adds the specified element to the end of this bag.\n+  * <p>\n+  * If required, it also increases the capacity of the bag.\n+  * </p>\n+  * \n+  * @param value\n+  *   element to be added to this list\n+  */\n+\n+\n+ public void add(int value) {\n+  // is size greater than capacity increase capacity\n+  if (size == data.length)\n+   grow(2 * data.length);\n+  data[size++] = value;\n+ }\n+\n+ /**\n+  * Adds the specified elements to the end of this bag.\n+  * <p>\n+  * If required, it also increases the capacity of the bag.\n+  * </p>\n+  *\n+  * @param other\n+  *   elements to be added to this list\n+  */\n+\n+\n+ public void addAll(IntBag other) {\n+  for (int i = 0; i < other.size(); i++) {\n+   add(other.data[i]);\n+  }\n+ }\n+\n+ /**\n+  * Set element at specified index in the bag.\n+  * \n+  * @param index\n+  *   position of element\n+  * @param value\n+  *   the element\n+  */\n+\n+\n+ public void set(int index, int value) {\n+  if (index >= data.length) {\n+   grow(max((2 * data.length), index + 1));\n+  }\n+\n+  size = max(size, index + 1);\n+  data[index] = value;\n+ }\n+\n+ private void grow(int newCapacity) throws ArrayIndexOutOfBoundsException {\n+  int[] oldData = data;\n+  data = new int[newCapacity];\n+  System.arraycopy(oldData, 0, data, 0, oldData.length);\n+ }\n+\n+ /**\n+  * Check if an item, if added at the given item will fit into the bag.\n+  * <p>\n+  * If not, the bag capacity will be increased to hold an item at the index.\n+  * </p>\n+  *\n+  * @param index\n+  *   index to check\n+  */\n+\n+\n+ public void ensureCapacity(int index) {\n+  if (index >= data.length) {\n+   grow(index + 1);\n+  }\n+ }\n+\n+ /**\n+  * Removes all of the elements from this bag.\n+  * <p>\n+  * The bag will be empty after this call returns.\n+  * </p>\n+  */\n+\n+\n+ public void clear() {\n+  Arrays.fill(data, 0, size, 0);\n+  size = 0;\n+ }\n+ \n+ /**\n+  * Returns this bag's underlying array.\n+  * <p>\n+  * Use with care.\n+  * </p>\n+  * \n+  * @return the underlying array\n+  *\n+  * @see IntBag#size()\n+  */\n+\n+\n+ public int[] getData() {\n+  return data;\n+ }\n+\n+ /**\n+  * Set the size.\n+  * <p>\n+  * This will not resize the bag, nor will it clean up contents beyond the\n+  * given size. Use with caution.\n+  * </p>\n+  *\n+  * @param size\n+  *   the size to set\n+  */\n+\n+\n+ public void setSize(int size) {\n+  this.size = size;\n+ }\n+\n+ @Override\n+ public boolean equals(Object o) {\n+  if (this == o)\n+   return true;\n+  if (o == null || getClass() != o.getClass())\n+   return false;\n+\n+  IntBag intBag = (IntBag) o;\n+  if (size != intBag.size())\n+   return false;\n+  for (int i = 0; size > i; i++) {\n+   if (data[i] != intBag.data[i])\n+    return false;\n+  }\n+\n+  return true;\n+ }\n+\n+ @Override\n+ public int hashCode() {\n+  int hash = 0;\n+  for (int i = 0, s = size; s > i; i++) {\n+   hash = (127 * hash) + data[i];\n+  }\n+\n+  return hash;\n+ }\n+\n+ @Override\n+ public String toString() {\n+  StringBuilder sb = new StringBuilder();\n+  sb.append(\"IntBag(\");\n+  for (int i = 0; size > i; i++) {\n+   if (i > 0)\n+    sb.append(\", \");\n+   sb.append(data[i]);\n+  }\n+\n+  sb.append(')');\n+  return sb.toString();\n+ }\n+}\n\\ No newline at end of file\n",
            "diff_size": 365
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "68",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "68",
                    "severity": "error",
                    "message": "Line is longer than 105 characters (found 120).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/107/IntBag.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/styler_three_grams/107/IntBag.java\nindex 761c496ab50..8c7b1841335 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/errored/1/107/IntBag.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/junkdog-artemis-odb/styler_three_grams/107/IntBag.java\n@@ -68,8 +68,8 @@ public class IntBag implements ImmutableIntBag {\n \t * @deprecated Call {@link #removeIndex(int)} instead. {@link #remove(int)} will be removed in 3.0 due to ambiguity.\n \t *\n \t * @throws ArrayIndexOutOfBoundsException\n-\t */\n-\t@Deprecated\n+\t */ @Deprecated\n+@Deprecated\n \tpublic int remove(int index) throws ArrayIndexOutOfBoundsException {\n \t\tint e = data[index]; // make copy of element to remove so it can be returned\n \t\tdata[index] = data[--size]; // overwrite item to remove with last element\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}