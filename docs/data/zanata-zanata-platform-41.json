{
    "project_name": "zanata-zanata-platform",
    "error_id": "41",
    "information": {
        "errors": [
            {
                "line": "166",
                "column": "48",
                "severity": "error",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "                facesMessages.addToControl(\"username\",\n                        msgs.format(\"jsf.UsernameNotAvailable\", getUsername()));\n                setUsername(originalUsername); // reset the username field\n                return \"failure\";\n            }\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/41/UserAction.java\nindex 224918e6e8e..113d5a2a1ff 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler/41/UserAction.java\n@@ -163,8 +163,9 @@ public class UserAction implements Serializable {\n             } else {\n                 facesMessages.addToControl(\"username\",\n                         msgs.format(\"jsf.UsernameNotAvailable\", getUsername()));\n-                setUsername(originalUsername); // reset the username field\n-                return \"failure\";\n+                setUsername(originalUsername);\n+                // reset the username field\n+                 return \"failure\";\n             }\n         }\n         String saveResult;\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "168",
                    "column": "40",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/41/UserAction.java\nindex 224918e6e8e..a5119cf209b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/intellij/41/UserAction.java\n@@ -18,6 +18,7 @@\n  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA, or see the FSF\n  * site: http://www.fsf.org.\n  */\n+\n package org.zanata.action;\n \n import static javax.faces.application.FacesMessage.SEVERITY_WARN;\n@@ -52,10 +53,11 @@ import org.zanata.ui.faces.FacesMessages;\n \n /**\n  * Extension of Seam management's UserAction class' behaviour.\n- *\n+ * <p>\n  * see org.jboss.seam.security.management.action.UserAction\n+ *\n  * @author Carlos Munoz\n- *         <a href=\"mailto:camunoz@redhat.com\">camunoz@redhat.com</a>\n+ * <a href=\"mailto:camunoz@redhat.com\">camunoz@redhat.com</a>\n  */\n @Named(\"userAction\")\n @ViewScoped\n@@ -63,224 +65,224 @@ import org.zanata.ui.faces.FacesMessages;\n @Transactional\n public class UserAction implements Serializable {\n \n-    private static final long serialVersionUID = 1L;\n-    @Inject\n-    private IdentityManager identityManager;\n-    @Inject\n-    private FacesMessages facesMessages;\n-    @Inject\n-    private Messages msgs;\n-    @Inject\n-    private UserAccountService userAccountServiceImpl;\n-    @Inject\n-    private EmailService emailServiceImpl;\n-    @Inject\n-    private PersonDAO personDAO;\n-    @Inject\n-    private AccountDAO accountDAO;\n-    @Inject\n-    private AccountActivationKeyDAO accountActivationKeyDAO;\n-    private String originalUsername;\n-    private String originalName;\n-    private AbstractListFilter<String> userFilter =\n-            new AbstractListFilter<String>() {\n-\n-                private static final long serialVersionUID =\n-                        6774670019241510582L;\n-\n-                @Override\n-                protected List<String> fetchRecords(int start, int max,\n-                        String filter) {\n-                    return accountDAO.getUserNames(filter, start, max);\n-                }\n-\n-                @Override\n-                protected long fetchTotalRecords(String filter) {\n-                    return accountDAO.getUserCount(filter);\n-                }\n-            };\n-    private List<String> roles;\n-    private String name;\n-    private String username;\n-    private String password;\n-    private String confirm;\n-    private boolean enabled;\n-\n-    @Transactional\n-    public void deleteUser(String userName) {\n-        try {\n-            identityManager.deleteUser(userName);\n-            // NB: Need to call flush here to be able to catch the persistence\n-            // exception, otherwise it would be caught by Seam.\n-            accountDAO.flush();\n-            userFilter.reset();\n-        } catch (Exception e) {\n-            List<Throwable> causalChain = getThrowableList(e);\n-            boolean hasConstraintEx = causalChain.stream()\n-                    .anyMatch(t -> t instanceof ConstraintViolationException);\n-            if (hasConstraintEx) {\n-                throw new DeleteUserConstraintException();\n-            } else {\n-                throw e;\n-            }\n-\n-        }\n-    }\n-\n-    @Transactional\n-    public void eraseUser(String username) {\n-        HAccount account = accountDAO.getByUsername(username);\n-        if (account == null) {\n-            facesMessages.addGlobal(SEVERITY_WARN, \"can not find user with username \" + username);\n-            return;\n-        }\n-        userAccountServiceImpl.eraseUserData(account);\n-        userFilter.reset();\n-    }\n-\n-    public String getEmail(String username) {\n-        return personDAO.findEmail(username);\n-    }\n-\n-    public void loadUser() {\n-        roles = identityManager.getGrantedRoles(username);\n-        enabled = identityManager.isUserEnabled(username);\n-        originalUsername = username;\n-        originalName = personDAO.findByUsername(username).getName();\n-        setName(originalName);\n-    }\n-\n-    @Transactional\n-    public String save() {\n-        boolean usernameChanged = false;\n-        String newUsername = getUsername();\n-        // Allow user name changes when editing\n-        if (!originalUsername.equals(newUsername)) {\n-            if (isNewUsernameValid(newUsername)) {\n-                userAccountServiceImpl.editUsername(originalUsername,\n-                        newUsername);\n-                usernameChanged = true;\n-            } else {\n-                facesMessages.addToControl(\"username\",\n-                        msgs.format(\"jsf.UsernameNotAvailable\", getUsername()));\n-                setUsername(originalUsername); // reset the username field\n-                return \"failure\";\n-            }\n-        }\n-        String saveResult;\n-        saveResult = saveExistingUser();\n-        if (usernameChanged) {\n-            String email = getEmail(newUsername);\n-            String message = emailServiceImpl.sendUsernameChangedEmail(email,\n-                    newUsername);\n-            facesMessages.addGlobal(message);\n-        }\n-        return saveResult;\n-    }\n+  private static final long serialVersionUID = 1L;\n+  @Inject\n+  private IdentityManager identityManager;\n+  @Inject\n+  private FacesMessages facesMessages;\n+  @Inject\n+  private Messages msgs;\n+  @Inject\n+  private UserAccountService userAccountServiceImpl;\n+  @Inject\n+  private EmailService emailServiceImpl;\n+  @Inject\n+  private PersonDAO personDAO;\n+  @Inject\n+  private AccountDAO accountDAO;\n+  @Inject\n+  private AccountActivationKeyDAO accountActivationKeyDAO;\n+  private String originalUsername;\n+  private String originalName;\n+  private AbstractListFilter<String> userFilter =\n+    new AbstractListFilter<String>() {\n+\n+      private static final long serialVersionUID =\n+        6774670019241510582L;\n+\n+      @Override\n+      protected List<String> fetchRecords(int start, int max,\n+                                          String filter) {\n+        return accountDAO.getUserNames(filter, start, max);\n+      }\n+\n+      @Override\n+      protected long fetchTotalRecords(String filter) {\n+        return accountDAO.getUserCount(filter);\n+      }\n+    };\n+  private List<String> roles;\n+  private String name;\n+  private String username;\n+  private String password;\n+  private String confirm;\n+  private boolean enabled;\n+\n+  @Transactional\n+  public void deleteUser(String userName) {\n+    try {\n+      identityManager.deleteUser(userName);\n+      // NB: Need to call flush here to be able to catch the persistence\n+      // exception, otherwise it would be caught by Seam.\n+      accountDAO.flush();\n+      userFilter.reset();\n+    } catch (Exception e) {\n+      List<Throwable> causalChain = getThrowableList(e);\n+      boolean hasConstraintEx = causalChain.stream()\n+        .anyMatch(t -> t instanceof ConstraintViolationException);\n+      if (hasConstraintEx) {\n+        throw new DeleteUserConstraintException();\n+      } else {\n+        throw e;\n+      }\n \n-    private String saveExistingUser() {\n-        // Check if a new password has been entered\n-        if (password != null && !\"\".equals(password)) {\n-            if (!password.equals(confirm)) {\n-                facesMessages.addToControl(\"password\",\n-                        \"Passwords do not match\");\n-                return \"failure\";\n-            } else {\n-                identityManager.changePassword(username, password);\n-            }\n-        }\n-        String newName = name.trim();\n-        if (isNotBlank(newName) && !StringUtils.equals(originalName, newName)) {\n-            HPerson person = personDAO.findByUsername(username);\n-            person.setName(newName);\n-            personDAO.makePersistent(person);\n-        }\n-        identityManager.grantRoles(username, roles);\n-        if (enabled) {\n-            enableAccount(username);\n-        } else {\n-            identityManager.disableUser(username);\n-        }\n-        return \"success\";\n     }\n-\n-    private void enableAccount(String username) {\n-        identityManager.enableUser(username);\n-        identityManager.grantRole(username, \"user\");\n-        HAccount account = accountDAO.getByUsername(username);\n-        HAccountActivationKey key = account.getAccountActivationKey();\n-        if (key != null) {\n-            account.setAccountActivationKey(null);\n-            accountDAO.makePersistent(account);\n-            accountActivationKeyDAO.makeTransient(key);\n-        }\n-    }\n-\n-    /**\n-     * Validate that a user name is not already in the system, by another\n-     * account\n-     */\n-    private boolean isNewUsernameValid(String username) {\n-        return !userAccountServiceImpl.isUsernameUsed(username);\n+  }\n+\n+  @Transactional\n+  public void eraseUser(String username) {\n+    HAccount account = accountDAO.getByUsername(username);\n+    if (account == null) {\n+      facesMessages.addGlobal(SEVERITY_WARN, \"can not find user with username \" + username);\n+      return;\n     }\n-\n-    public String cancel() {\n-        return \"success\";\n+    userAccountServiceImpl.eraseUserData(account);\n+    userFilter.reset();\n+  }\n+\n+  public String getEmail(String username) {\n+    return personDAO.findEmail(username);\n+  }\n+\n+  public void loadUser() {\n+    roles = identityManager.getGrantedRoles(username);\n+    enabled = identityManager.isUserEnabled(username);\n+    originalUsername = username;\n+    originalName = personDAO.findByUsername(username).getName();\n+    setName(originalName);\n+  }\n+\n+  @Transactional\n+  public String save() {\n+    boolean usernameChanged = false;\n+    String newUsername = getUsername();\n+    // Allow user name changes when editing\n+    if (!originalUsername.equals(newUsername)) {\n+      if (isNewUsernameValid(newUsername)) {\n+        userAccountServiceImpl.editUsername(originalUsername,\n+          newUsername);\n+        usernameChanged = true;\n+      } else {\n+        facesMessages.addToControl(\"username\",\n+          msgs.format(\"jsf.UsernameNotAvailable\", getUsername()));\n+        setUsername(originalUsername); // reset the username field\n+        return \"failure\";\n+      }\n     }\n-\n-    public String getUsername() {\n-        return username;\n+    String saveResult;\n+    saveResult = saveExistingUser();\n+    if (usernameChanged) {\n+      String email = getEmail(newUsername);\n+      String message = emailServiceImpl.sendUsernameChangedEmail(email,\n+        newUsername);\n+      facesMessages.addGlobal(message);\n     }\n-\n-    public void setUsername(String username) {\n-        this.username = username;\n+    return saveResult;\n+  }\n+\n+  private String saveExistingUser() {\n+    // Check if a new password has been entered\n+    if (password != null && !\"\".equals(password)) {\n+      if (!password.equals(confirm)) {\n+        facesMessages.addToControl(\"password\",\n+          \"Passwords do not match\");\n+        return \"failure\";\n+      } else {\n+        identityManager.changePassword(username, password);\n+      }\n     }\n-\n-    public String getOriginalName() {\n-        return this.originalName;\n+    String newName = name.trim();\n+    if (isNotBlank(newName) && !StringUtils.equals(originalName, newName)) {\n+      HPerson person = personDAO.findByUsername(username);\n+      person.setName(newName);\n+      personDAO.makePersistent(person);\n     }\n-\n-    public String getName() {\n-        return this.name;\n+    identityManager.grantRoles(username, roles);\n+    if (enabled) {\n+      enableAccount(username);\n+    } else {\n+      identityManager.disableUser(username);\n     }\n-\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getPassword() {\n-        return password;\n-    }\n-\n-    public void setPassword(String password) {\n-        this.password = password;\n-    }\n-\n-    public String getConfirm() {\n-        return confirm;\n-    }\n-\n-    public void setConfirm(String confirm) {\n-        this.confirm = confirm;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void setEnabled(boolean enabled) {\n-        this.enabled = enabled;\n-    }\n-\n-    public List<String> getRoles() {\n-        return roles;\n-    }\n-\n-    public void setRoles(List<String> roles) {\n-        this.roles = roles;\n-    }\n-\n-    public AbstractListFilter<String> getUserFilter() {\n-        return this.userFilter;\n+    return \"success\";\n+  }\n+\n+  private void enableAccount(String username) {\n+    identityManager.enableUser(username);\n+    identityManager.grantRole(username, \"user\");\n+    HAccount account = accountDAO.getByUsername(username);\n+    HAccountActivationKey key = account.getAccountActivationKey();\n+    if (key != null) {\n+      account.setAccountActivationKey(null);\n+      accountDAO.makePersistent(account);\n+      accountActivationKeyDAO.makeTransient(key);\n     }\n+  }\n+\n+  /**\n+   * Validate that a user name is not already in the system, by another\n+   * account\n+   */\n+  private boolean isNewUsernameValid(String username) {\n+    return !userAccountServiceImpl.isUsernameUsed(username);\n+  }\n+\n+  public String cancel() {\n+    return \"success\";\n+  }\n+\n+  public String getUsername() {\n+    return username;\n+  }\n+\n+  public void setUsername(String username) {\n+    this.username = username;\n+  }\n+\n+  public String getOriginalName() {\n+    return this.originalName;\n+  }\n+\n+  public String getName() {\n+    return this.name;\n+  }\n+\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public String getPassword() {\n+    return password;\n+  }\n+\n+  public void setPassword(String password) {\n+    this.password = password;\n+  }\n+\n+  public String getConfirm() {\n+    return confirm;\n+  }\n+\n+  public void setConfirm(String confirm) {\n+    this.confirm = confirm;\n+  }\n+\n+  public boolean isEnabled() {\n+    return enabled;\n+  }\n+\n+  public void setEnabled(boolean enabled) {\n+    this.enabled = enabled;\n+  }\n+\n+  public List<String> getRoles() {\n+    return roles;\n+  }\n+\n+  public void setRoles(List<String> roles) {\n+    this.roles = roles;\n+  }\n+\n+  public AbstractListFilter<String> getUserFilter() {\n+    return this.userFilter;\n+  }\n }\n",
            "diff_size": 331
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/41/UserAction.java\nindex 224918e6e8e..5b2e4752745 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/naturalize/41/UserAction.java\n@@ -163,7 +163,8 @@ public class UserAction implements Serializable {\n             } else {\n                 facesMessages.addToControl(\"username\",\n                         msgs.format(\"jsf.UsernameNotAvailable\", getUsername()));\n-                setUsername(originalUsername); // reset the username field\n+                setUsername(originalUsername);\n+// reset the username field\n                 return \"failure\";\n             }\n         }\n@@ -283,4 +284,4 @@ public class UserAction implements Serializable {\n     public AbstractListFilter<String> getUserFilter() {\n         return this.userFilter;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "157",
                    "column": "48",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/41/UserAction.java\nindex 224918e6e8e..bcc896b7691 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/codebuff/41/UserAction.java\n@@ -26,13 +26,11 @@ import static org.apache.commons.lang3.exception.ExceptionUtils.getThrowableList\n \n import java.io.Serializable;\n import java.util.List;\n-\n import javax.enterprise.inject.Model;\n import javax.faces.application.FacesMessage;\n import javax.faces.bean.ViewScoped;\n import javax.inject.Inject;\n import javax.inject.Named;\n-\n import org.apache.commons.lang3.StringUtils;\n import org.apache.deltaspike.jpa.api.transaction.Transactional;\n import org.hibernate.exception.ConstraintViolationException;\n@@ -57,12 +55,13 @@ import org.zanata.ui.faces.FacesMessages;\n  * @author Carlos Munoz\n  *         <a href=\"mailto:camunoz@redhat.com\">camunoz@redhat.com</a>\n  */\n+\n+\n @Named(\"userAction\")\n @ViewScoped\n @Model\n @Transactional\n public class UserAction implements Serializable {\n-\n     private static final long serialVersionUID = 1L;\n     @Inject\n     private IdentityManager identityManager;\n@@ -82,30 +81,24 @@ public class UserAction implements Serializable {\n     private AccountActivationKeyDAO accountActivationKeyDAO;\n     private String originalUsername;\n     private String originalName;\n-    private AbstractListFilter<String> userFilter =\n-            new AbstractListFilter<String>() {\n-\n-                private static final long serialVersionUID =\n-                        6774670019241510582L;\n-\n-                @Override\n-                protected List<String> fetchRecords(int start, int max,\n-                        String filter) {\n-                    return accountDAO.getUserNames(filter, start, max);\n-                }\n-\n-                @Override\n-                protected long fetchTotalRecords(String filter) {\n-                    return accountDAO.getUserCount(filter);\n-                }\n-            };\n+    private AbstractListFilter<String> userFilter = new AbstractListFilter<String>() {\n+                                                        private static final long serialVersionUID = 6774670019241510582L;\n+                                                        @Override\n+                                                        protected List<String> fetchRecords(int start, int max, String filter) {\n+                                                            return accountDAO.getUserNames(filter, start, max);\n+                                                        }\n+\n+                                                        @Override\n+                                                        protected long fetchTotalRecords(String filter) {\n+                                                            return accountDAO.getUserCount(filter);\n+                                                        }\n+                                                    };\n     private List<String> roles;\n     private String name;\n     private String username;\n     private String password;\n     private String confirm;\n     private boolean enabled;\n-\n     @Transactional\n     public void deleteUser(String userName) {\n         try {\n@@ -116,14 +109,12 @@ public class UserAction implements Serializable {\n             userFilter.reset();\n         } catch (Exception e) {\n             List<Throwable> causalChain = getThrowableList(e);\n-            boolean hasConstraintEx = causalChain.stream()\n-                    .anyMatch(t -> t instanceof ConstraintViolationException);\n+            boolean hasConstraintEx = causalChain.stream().anyMatch(t -> t instanceof ConstraintViolationException);\n             if (hasConstraintEx) {\n                 throw new DeleteUserConstraintException();\n             } else {\n                 throw e;\n             }\n-\n         }\n     }\n \n@@ -131,7 +122,9 @@ public class UserAction implements Serializable {\n     public void eraseUser(String username) {\n         HAccount account = accountDAO.getByUsername(username);\n         if (account == null) {\n-            facesMessages.addGlobal(SEVERITY_WARN, \"can not find user with username \" + username);\n+            facesMessages.addGlobal(SEVERITY_WARN,\n+                \"can not find user with username \"\n+                    + username);\n             return;\n         }\n         userAccountServiceImpl.eraseUserData(account);\n@@ -157,12 +150,10 @@ public class UserAction implements Serializable {\n         // Allow user name changes when editing\n         if (!originalUsername.equals(newUsername)) {\n             if (isNewUsernameValid(newUsername)) {\n-                userAccountServiceImpl.editUsername(originalUsername,\n-                        newUsername);\n+                userAccountServiceImpl.editUsername(originalUsername, newUsername);\n                 usernameChanged = true;\n             } else {\n-                facesMessages.addToControl(\"username\",\n-                        msgs.format(\"jsf.UsernameNotAvailable\", getUsername()));\n+                facesMessages.addToControl(\"username\", msgs.format(\"jsf.UsernameNotAvailable\", getUsername()));\n                 setUsername(originalUsername); // reset the username field\n                 return \"failure\";\n             }\n@@ -171,8 +162,7 @@ public class UserAction implements Serializable {\n         saveResult = saveExistingUser();\n         if (usernameChanged) {\n             String email = getEmail(newUsername);\n-            String message = emailServiceImpl.sendUsernameChangedEmail(email,\n-                    newUsername);\n+            String message = emailServiceImpl.sendUsernameChangedEmail(email, newUsername);\n             facesMessages.addGlobal(message);\n         }\n         return saveResult;\n@@ -182,8 +172,7 @@ public class UserAction implements Serializable {\n         // Check if a new password has been entered\n         if (password != null && !\"\".equals(password)) {\n             if (!password.equals(confirm)) {\n-                facesMessages.addToControl(\"password\",\n-                        \"Passwords do not match\");\n+                facesMessages.addToControl(\"password\", \"Passwords do not match\");\n                 return \"failure\";\n             } else {\n                 identityManager.changePassword(username, password);\n@@ -220,6 +209,7 @@ public class UserAction implements Serializable {\n      * Validate that a user name is not already in the system, by another\n      * account\n      */\n+\n     private boolean isNewUsernameValid(String username) {\n         return !userAccountServiceImpl.isUsernameUsed(username);\n     }\n@@ -283,4 +273,4 @@ public class UserAction implements Serializable {\n     public AbstractListFilter<String> getUserFilter() {\n         return this.userFilter;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 39
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "166",
                    "column": "48",
                    "severity": "error",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/41/UserAction.java\nindex 224918e6e8e..113d5a2a1ff 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/errored/1/41/UserAction.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/zanata-zanata-platform/styler_three_grams/41/UserAction.java\n@@ -163,8 +163,9 @@ public class UserAction implements Serializable {\n             } else {\n                 facesMessages.addToControl(\"username\",\n                         msgs.format(\"jsf.UsernameNotAvailable\", getUsername()));\n-                setUsername(originalUsername); // reset the username field\n-                return \"failure\";\n+                setUsername(originalUsername);\n+                // reset the username field\n+                 return \"failure\";\n             }\n         }\n         String saveResult;\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff",
        "styler_random"
    ]
}