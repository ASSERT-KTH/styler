{
    "project_name": "codefollower-H2-Research",
    "error_id": "105",
    "information": {
        "errors": [
            {
                "line": "227",
                "column": "9",
                "severity": "warning",
                "message": "'if' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
            }
        ]
    },
    "source_code": "        int vType = v.getType();\n        int resType = Value.getHigherOrder(column.getType(), vType);\n        if(vType != resType) {\n            v = column.convert(v, session.getDatabase().getMode());\n        }\n        if (row == null) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/105/IndexCursor.java\nindex 46ace5f1664..575b30c51db 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/105/IndexCursor.java\n@@ -224,7 +224,7 @@ public class IndexCursor implements Cursor {\n                                 table.getColumn(columnId);\n         int vType = v.getType();\n         int resType = Value.getHigherOrder(column.getType(), vType);\n-        if(vType != resType) {\n+        if (vType != resType) {\n             v = column.convert(v, session.getDatabase().getMode());\n         }\n         if (row == null) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/105/IndexCursor.java\nindex 46ace5f1664..5040651249e 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/105/IndexCursor.java\n@@ -3,10 +3,12 @@\n  * and the EPL 1.0 (http://h2database.com/html/license.html).\n  * Initial Developer: H2 Group\n  */\n+\n package org.h2.index;\n \n import java.util.ArrayList;\n import java.util.HashSet;\n+\n import org.h2.engine.Session;\n import org.h2.expression.Comparison;\n import org.h2.message.DbException;\n@@ -32,332 +34,332 @@ import org.h2.value.ValueNull;\n  */\n public class IndexCursor implements Cursor {\n \n-    private Session session;\n-    private final TableFilter tableFilter;\n-    private Index index;\n-    private Table table;\n-    private IndexColumn[] indexColumns;\n-    private boolean alwaysFalse;\n+  private Session session;\n+  private final TableFilter tableFilter;\n+  private Index index;\n+  private Table table;\n+  private IndexColumn[] indexColumns;\n+  private boolean alwaysFalse;\n \n-    private SearchRow start, end, intersects;\n-    private Cursor cursor;\n-    private Column inColumn;\n-    private int inListIndex;\n-    private Value[] inList;\n-    private ResultInterface inResult;\n-    private HashSet<Value> inResultTested;\n+  private SearchRow start, end, intersects;\n+  private Cursor cursor;\n+  private Column inColumn;\n+  private int inListIndex;\n+  private Value[] inList;\n+  private ResultInterface inResult;\n+  private HashSet<Value> inResultTested;\n \n-    public IndexCursor(TableFilter filter) {\n-        this.tableFilter = filter;\n-    }\n+  public IndexCursor(TableFilter filter) {\n+    this.tableFilter = filter;\n+  }\n \n-    public void setIndex(Index index) {\n-        this.index = index;\n-        this.table = index.getTable();\n-        Column[] columns = table.getColumns();\n-        indexColumns = new IndexColumn[columns.length];\n-        IndexColumn[] idxCols = index.getIndexColumns();\n-        if (idxCols != null) {\n-            for (int i = 0, len = columns.length; i < len; i++) {\n-                int idx = index.getColumnIndex(columns[i]);\n-                if (idx >= 0) {\n-                    indexColumns[i] = idxCols[idx];\n-                }\n-            }\n+  public void setIndex(Index index) {\n+    this.index = index;\n+    this.table = index.getTable();\n+    Column[] columns = table.getColumns();\n+    indexColumns = new IndexColumn[columns.length];\n+    IndexColumn[] idxCols = index.getIndexColumns();\n+    if (idxCols != null) {\n+      for (int i = 0, len = columns.length; i < len; i++) {\n+        int idx = index.getColumnIndex(columns[i]);\n+        if (idx >= 0) {\n+          indexColumns[i] = idxCols[idx];\n         }\n+      }\n     }\n+  }\n \n-    /**\n-     * Prepare this index cursor to make a lookup in index.\n-     *\n-     * @param s Session.\n-     * @param indexConditions Index conditions.\n-     */\n-    public void prepare(Session s, ArrayList<IndexCondition> indexConditions) {\n-        this.session = s;\n-        alwaysFalse = false;\n-        start = end = null;\n-        inList = null;\n-        inColumn = null;\n-        inResult = null;\n-        inResultTested = null;\n-        intersects = null;\n-        for (IndexCondition condition : indexConditions) {\n-            if (condition.isAlwaysFalse()) {\n-                alwaysFalse = true;\n-                break;\n-            }\n-            // If index can perform only full table scan do not try to use it for regular\n-            // lookups, each such lookup will perform an own table scan.\n-            if (index.isFindUsingFullTableScan()) {\n-                continue;\n-            }\n-            Column column = condition.getColumn();\n-            if (condition.getCompareType() == Comparison.IN_LIST) {\n-                if (start == null && end == null) {\n-                    if (canUseIndexForIn(column)) {\n-                        this.inColumn = column;\n-                        inList = condition.getCurrentValueList(s);\n-                        inListIndex = 0;\n-                    }\n-                }\n-            } else if (condition.getCompareType() == Comparison.IN_QUERY) {\n-                if (start == null && end == null) {\n-                    if (canUseIndexForIn(column)) {\n-                        this.inColumn = column;\n-                        inResult = condition.getCurrentResult();\n-                    }\n-                }\n-            } else {\n-                Value v = condition.getCurrentValue(s);\n-                boolean isStart = condition.isStart();\n-                boolean isEnd = condition.isEnd();\n-                boolean isIntersects = condition.isSpatialIntersects();\n-                int columnId = column.getColumnId();\n-                if (columnId != SearchRow.ROWID_INDEX) {\n-                    IndexColumn idxCol = indexColumns[columnId];\n-                    if (idxCol != null && (idxCol.sortType & SortOrder.DESCENDING) != 0) {\n-                        // if the index column is sorted the other way, we swap\n-                        // end and start NULLS_FIRST / NULLS_LAST is not a\n-                        // problem, as nulls never match anyway\n-                        boolean temp = isStart;\n-                        isStart = isEnd;\n-                        isEnd = temp;\n-                    }\n-                }\n-                if (isStart) {\n-                    start = getSearchRow(start, columnId, v, true);\n-                }\n-                if (isEnd) {\n-                    end = getSearchRow(end, columnId, v, false);\n-                }\n-                if (isIntersects) {\n-                    intersects = getSpatialSearchRow(intersects, columnId, v);\n-                }\n-                // An X=? condition will produce less rows than\n-                // an X IN(..) condition, unless the X IN condition can use the index.\n-                if ((isStart || isEnd) && !canUseIndexFor(inColumn)) {\n-                    inColumn = null;\n-                    inList = null;\n-                    inResult = null;\n-                }\n-                if (!session.getDatabase().getSettings().optimizeIsNull) {\n-                    if (isStart && isEnd) {\n-                        if (v == ValueNull.INSTANCE) {\n-                            // join on a column=NULL is always false\n-                            alwaysFalse = true;\n-                        }\n-                    }\n-                }\n-            }\n+  /**\n+   * Prepare this index cursor to make a lookup in index.\n+   *\n+   * @param s               Session.\n+   * @param indexConditions Index conditions.\n+   */\n+  public void prepare(Session s, ArrayList<IndexCondition> indexConditions) {\n+    this.session = s;\n+    alwaysFalse = false;\n+    start = end = null;\n+    inList = null;\n+    inColumn = null;\n+    inResult = null;\n+    inResultTested = null;\n+    intersects = null;\n+    for (IndexCondition condition : indexConditions) {\n+      if (condition.isAlwaysFalse()) {\n+        alwaysFalse = true;\n+        break;\n+      }\n+      // If index can perform only full table scan do not try to use it for regular\n+      // lookups, each such lookup will perform an own table scan.\n+      if (index.isFindUsingFullTableScan()) {\n+        continue;\n+      }\n+      Column column = condition.getColumn();\n+      if (condition.getCompareType() == Comparison.IN_LIST) {\n+        if (start == null && end == null) {\n+          if (canUseIndexForIn(column)) {\n+            this.inColumn = column;\n+            inList = condition.getCurrentValueList(s);\n+            inListIndex = 0;\n+          }\n         }\n-        if (inColumn != null) {\n-            start = table.getTemplateRow();\n+      } else if (condition.getCompareType() == Comparison.IN_QUERY) {\n+        if (start == null && end == null) {\n+          if (canUseIndexForIn(column)) {\n+            this.inColumn = column;\n+            inResult = condition.getCurrentResult();\n+          }\n         }\n-    }\n-\n-    /**\n-     * Re-evaluate the start and end values of the index search for rows.\n-     *\n-     * @param s the session\n-     * @param indexConditions the index conditions\n-     */\n-    public void find(Session s, ArrayList<IndexCondition> indexConditions) {\n-        prepare(s, indexConditions);\n-        if (inColumn != null) {\n-            return;\n+      } else {\n+        Value v = condition.getCurrentValue(s);\n+        boolean isStart = condition.isStart();\n+        boolean isEnd = condition.isEnd();\n+        boolean isIntersects = condition.isSpatialIntersects();\n+        int columnId = column.getColumnId();\n+        if (columnId != SearchRow.ROWID_INDEX) {\n+          IndexColumn idxCol = indexColumns[columnId];\n+          if (idxCol != null && (idxCol.sortType & SortOrder.DESCENDING) != 0) {\n+            // if the index column is sorted the other way, we swap\n+            // end and start NULLS_FIRST / NULLS_LAST is not a\n+            // problem, as nulls never match anyway\n+            boolean temp = isStart;\n+            isStart = isEnd;\n+            isEnd = temp;\n+          }\n         }\n-        if (!alwaysFalse) {\n-            if (intersects != null && index instanceof SpatialIndex) {\n-                cursor = ((SpatialIndex) index).findByGeometry(tableFilter,\n-                        start, end, intersects);\n-            } else {\n-                cursor = index.find(tableFilter, start, end);\n-            }\n+        if (isStart) {\n+          start = getSearchRow(start, columnId, v, true);\n         }\n-    }\n-\n-    private boolean canUseIndexForIn(Column column) {\n-        if (inColumn != null) {\n-            // only one IN(..) condition can be used at the same time\n-            return false;\n+        if (isEnd) {\n+          end = getSearchRow(end, columnId, v, false);\n         }\n-        return canUseIndexFor(column);\n-    }\n-\n-    private boolean canUseIndexFor(Column column) {\n-        // The first column of the index must match this column,\n-        // or it must be a VIEW index (where the column is null).\n-        // Multiple IN conditions with views are not supported, see\n-        // IndexCondition.getMask.\n-        IndexColumn[] cols = index.getIndexColumns();\n-        if (cols == null) {\n-            return true;\n+        if (isIntersects) {\n+          intersects = getSpatialSearchRow(intersects, columnId, v);\n         }\n-        IndexColumn idxCol = cols[0];\n-        return idxCol == null || idxCol.column == column;\n-    }\n-\n-    private SearchRow getSpatialSearchRow(SearchRow row, int columnId, Value v) {\n-        if (row == null) {\n-            row = table.getTemplateRow();\n-        } else if (row.getValue(columnId) != null) {\n-            // if an object needs to overlap with both a and b,\n-            // then it needs to overlap with the the union of a and b\n-            // (not the intersection)\n-            ValueGeometry vg = (ValueGeometry) row.getValue(columnId).\n-                    convertTo(Value.GEOMETRY);\n-            v = ((ValueGeometry) v.convertTo(Value.GEOMETRY)).\n-                    getEnvelopeUnion(vg);\n+        // An X=? condition will produce less rows than\n+        // an X IN(..) condition, unless the X IN condition can use the index.\n+        if ((isStart || isEnd) && !canUseIndexFor(inColumn)) {\n+          inColumn = null;\n+          inList = null;\n+          inResult = null;\n         }\n-        if (columnId == SearchRow.ROWID_INDEX) {\n-            row.setKey(v.getLong());\n-        } else {\n-            row.setValue(columnId, v);\n+        if (!session.getDatabase().getSettings().optimizeIsNull) {\n+          if (isStart && isEnd) {\n+            if (v == ValueNull.INSTANCE) {\n+              // join on a column=NULL is always false\n+              alwaysFalse = true;\n+            }\n+          }\n         }\n-        return row;\n+      }\n+    }\n+    if (inColumn != null) {\n+      start = table.getTemplateRow();\n     }\n+  }\n \n-    private SearchRow getSearchRow(SearchRow row, int columnId, Value v, boolean max) {\n-        Column column = columnId == SearchRow.ROWID_INDEX ?\n-                                table.getRowIdColumn() :\n-                                table.getColumn(columnId);\n-        int vType = v.getType();\n-        int resType = Value.getHigherOrder(column.getType(), vType);\n-        if(vType != resType) {\n-            v = column.convert(v, session.getDatabase().getMode());\n-        }\n-        if (row == null) {\n-            row = table.getTemplateRow();\n-        } else {\n-            v = getMax(row.getValue(columnId), v, max);\n-        }\n-        if (columnId == SearchRow.ROWID_INDEX) {\n-            row.setKey(v.getLong());\n-        } else {\n-            row.setValue(columnId, v);\n-        }\n-        return row;\n+  /**\n+   * Re-evaluate the start and end values of the index search for rows.\n+   *\n+   * @param s               the session\n+   * @param indexConditions the index conditions\n+   */\n+  public void find(Session s, ArrayList<IndexCondition> indexConditions) {\n+    prepare(s, indexConditions);\n+    if (inColumn != null) {\n+      return;\n     }\n+    if (!alwaysFalse) {\n+      if (intersects != null && index instanceof SpatialIndex) {\n+        cursor = ((SpatialIndex) index).findByGeometry(tableFilter,\n+            start, end, intersects);\n+      } else {\n+        cursor = index.find(tableFilter, start, end);\n+      }\n+    }\n+  }\n \n-    private Value getMax(Value a, Value b, boolean bigger) {\n-        if (a == null) {\n-            return b;\n-        } else if (b == null) {\n-            return a;\n-        }\n-        if (session.getDatabase().getSettings().optimizeIsNull) {\n-            // IS NULL must be checked later\n-            if (a == ValueNull.INSTANCE) {\n-                return b;\n-            } else if (b == ValueNull.INSTANCE) {\n-                return a;\n-            }\n-        }\n-        int comp = a.compareTo(b, table.getDatabase().getCompareMode());\n-        if (comp == 0) {\n-            return a;\n-        }\n-        if (a == ValueNull.INSTANCE || b == ValueNull.INSTANCE) {\n-            if (session.getDatabase().getSettings().optimizeIsNull) {\n-                // column IS NULL AND column <op> <not null> is always false\n-                return null;\n-            }\n-        }\n-        return (comp > 0) == bigger ? a : b;\n+  private boolean canUseIndexForIn(Column column) {\n+    if (inColumn != null) {\n+      // only one IN(..) condition can be used at the same time\n+      return false;\n     }\n+    return canUseIndexFor(column);\n+  }\n \n-    /**\n-     * Check if the result is empty for sure.\n-     *\n-     * @return true if it is\n-     */\n-    public boolean isAlwaysFalse() {\n-        return alwaysFalse;\n+  private boolean canUseIndexFor(Column column) {\n+    // The first column of the index must match this column,\n+    // or it must be a VIEW index (where the column is null).\n+    // Multiple IN conditions with views are not supported, see\n+    // IndexCondition.getMask.\n+    IndexColumn[] cols = index.getIndexColumns();\n+    if (cols == null) {\n+      return true;\n     }\n+    IndexColumn idxCol = cols[0];\n+    return idxCol == null || idxCol.column == column;\n+  }\n \n-    /**\n-     * Get start search row.\n-     *\n-     * @return search row\n-     */\n-    public SearchRow getStart() {\n-        return start;\n+  private SearchRow getSpatialSearchRow(SearchRow row, int columnId, Value v) {\n+    if (row == null) {\n+      row = table.getTemplateRow();\n+    } else if (row.getValue(columnId) != null) {\n+      // if an object needs to overlap with both a and b,\n+      // then it needs to overlap with the the union of a and b\n+      // (not the intersection)\n+      ValueGeometry vg = (ValueGeometry) row.getValue(columnId).\n+          convertTo(Value.GEOMETRY);\n+      v = ((ValueGeometry) v.convertTo(Value.GEOMETRY)).\n+          getEnvelopeUnion(vg);\n+    }\n+    if (columnId == SearchRow.ROWID_INDEX) {\n+      row.setKey(v.getLong());\n+    } else {\n+      row.setValue(columnId, v);\n     }\n+    return row;\n+  }\n \n-    /**\n-     * Get end search row.\n-     *\n-     * @return search row\n-     */\n-    public SearchRow getEnd() {\n-        return end;\n+  private SearchRow getSearchRow(SearchRow row, int columnId, Value v, boolean max) {\n+    Column column = columnId == SearchRow.ROWID_INDEX ?\n+        table.getRowIdColumn() :\n+        table.getColumn(columnId);\n+    int vType = v.getType();\n+    int resType = Value.getHigherOrder(column.getType(), vType);\n+    if (vType != resType) {\n+      v = column.convert(v, session.getDatabase().getMode());\n+    }\n+    if (row == null) {\n+      row = table.getTemplateRow();\n+    } else {\n+      v = getMax(row.getValue(columnId), v, max);\n     }\n+    if (columnId == SearchRow.ROWID_INDEX) {\n+      row.setKey(v.getLong());\n+    } else {\n+      row.setValue(columnId, v);\n+    }\n+    return row;\n+  }\n \n-    @Override\n-    public Row get() {\n-        if (cursor == null) {\n-            return null;\n-        }\n-        return cursor.get();\n+  private Value getMax(Value a, Value b, boolean bigger) {\n+    if (a == null) {\n+      return b;\n+    } else if (b == null) {\n+      return a;\n+    }\n+    if (session.getDatabase().getSettings().optimizeIsNull) {\n+      // IS NULL must be checked later\n+      if (a == ValueNull.INSTANCE) {\n+        return b;\n+      } else if (b == ValueNull.INSTANCE) {\n+        return a;\n+      }\n+    }\n+    int comp = a.compareTo(b, table.getDatabase().getCompareMode());\n+    if (comp == 0) {\n+      return a;\n+    }\n+    if (a == ValueNull.INSTANCE || b == ValueNull.INSTANCE) {\n+      if (session.getDatabase().getSettings().optimizeIsNull) {\n+        // column IS NULL AND column <op> <not null> is always false\n+        return null;\n+      }\n     }\n+    return (comp > 0) == bigger ? a : b;\n+  }\n \n-    @Override\n-    public SearchRow getSearchRow() {\n-        return cursor.getSearchRow();\n+  /**\n+   * Check if the result is empty for sure.\n+   *\n+   * @return true if it is\n+   */\n+  public boolean isAlwaysFalse() {\n+    return alwaysFalse;\n+  }\n+\n+  /**\n+   * Get start search row.\n+   *\n+   * @return search row\n+   */\n+  public SearchRow getStart() {\n+    return start;\n+  }\n+\n+  /**\n+   * Get end search row.\n+   *\n+   * @return search row\n+   */\n+  public SearchRow getEnd() {\n+    return end;\n+  }\n+\n+  @Override\n+  public Row get() {\n+    if (cursor == null) {\n+      return null;\n     }\n+    return cursor.get();\n+  }\n \n-    @Override\n-    public boolean next() {\n-        while (true) {\n-            if (cursor == null) {\n-                nextCursor();\n-                if (cursor == null) {\n-                    return false;\n-                }\n-            }\n-            if (cursor.next()) {\n-                return true;\n-            }\n-            cursor = null;\n+  @Override\n+  public SearchRow getSearchRow() {\n+    return cursor.getSearchRow();\n+  }\n+\n+  @Override\n+  public boolean next() {\n+    while (true) {\n+      if (cursor == null) {\n+        nextCursor();\n+        if (cursor == null) {\n+          return false;\n         }\n+      }\n+      if (cursor.next()) {\n+        return true;\n+      }\n+      cursor = null;\n     }\n+  }\n \n-    private void nextCursor() {\n-        if (inList != null) {\n-            while (inListIndex < inList.length) {\n-                Value v = inList[inListIndex++];\n-                if (v != ValueNull.INSTANCE) {\n-                    find(v);\n-                    break;\n-                }\n-            }\n-        } else if (inResult != null) {\n-            while (inResult.next()) {\n-                Value v = inResult.currentRow()[0];\n-                if (v != ValueNull.INSTANCE) {\n-                    if (inResultTested == null) {\n-                        inResultTested = new HashSet<>();\n-                    }\n-                    if (inResultTested.add(v)) {\n-                        find(v);\n-                        break;\n-                    }\n-                }\n-            }\n+  private void nextCursor() {\n+    if (inList != null) {\n+      while (inListIndex < inList.length) {\n+        Value v = inList[inListIndex++];\n+        if (v != ValueNull.INSTANCE) {\n+          find(v);\n+          break;\n         }\n+      }\n+    } else if (inResult != null) {\n+      while (inResult.next()) {\n+        Value v = inResult.currentRow()[0];\n+        if (v != ValueNull.INSTANCE) {\n+          if (inResultTested == null) {\n+            inResultTested = new HashSet<>();\n+          }\n+          if (inResultTested.add(v)) {\n+            find(v);\n+            break;\n+          }\n+        }\n+      }\n     }\n+  }\n \n-    private void find(Value v) {\n-        v = inColumn.convert(v);\n-        int id = inColumn.getColumnId();\n-        start.setValue(id, v);\n-        cursor = index.find(tableFilter, start, start);\n-    }\n+  private void find(Value v) {\n+    v = inColumn.convert(v);\n+    int id = inColumn.getColumnId();\n+    start.setValue(id, v);\n+    cursor = index.find(tableFilter, start, start);\n+  }\n \n-    @Override\n-    public boolean previous() {\n-        throw DbException.throwInternalError(toString());\n-    }\n+  @Override\n+  public boolean previous() {\n+    throw DbException.throwInternalError(toString());\n+  }\n \n }\n",
            "diff_size": 418
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/105/IndexCursor.java\nindex 46ace5f1664..a8c7af3dfeb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/naturalize/105/IndexCursor.java\n@@ -219,12 +219,11 @@ public class IndexCursor implements Cursor {\n     }\n \n     private SearchRow getSearchRow(SearchRow row, int columnId, Value v, boolean max) {\n-        Column column = columnId == SearchRow.ROWID_INDEX ?\n-                                table.getRowIdColumn() :\n+        Column column = columnId == SearchRow.ROWID_INDEX ? table.getRowIdColumn() :\n                                 table.getColumn(columnId);\n-        int vType = v.getType();\n+int vType = v.getType();\n         int resType = Value.getHigherOrder(column.getType(), vType);\n-        if(vType != resType) {\n+        if (vType != resType) {\n             v = column.convert(v, session.getDatabase().getMode());\n         }\n         if (row == null) {\n@@ -360,4 +359,4 @@ public class IndexCursor implements Cursor {\n         throw DbException.throwInternalError(toString());\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 5
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/105/IndexCursor.java\nindex 46ace5f1664..bba4f2002a9 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/codebuff/105/IndexCursor.java\n@@ -30,6 +30,8 @@ import org.h2.value.ValueNull;\n  * @author Noel Grandin\n  * @author Nicolas Fortin, Atelier SIG, IRSTV FR CNRS 24888\n  */\n+\n+\n public class IndexCursor implements Cursor {\n \n     private Session session;\n@@ -38,7 +40,6 @@ public class IndexCursor implements Cursor {\n     private Table table;\n     private IndexColumn[] indexColumns;\n     private boolean alwaysFalse;\n-\n     private SearchRow start, end, intersects;\n     private Cursor cursor;\n     private Column inColumn;\n@@ -51,6 +52,7 @@ public class IndexCursor implements Cursor {\n         this.tableFilter = filter;\n     }\n \n+\n     public void setIndex(Index index) {\n         this.index = index;\n         this.table = index.getTable();\n@@ -73,6 +75,8 @@ public class IndexCursor implements Cursor {\n      * @param s Session.\n      * @param indexConditions Index conditions.\n      */\n+\n+\n     public void prepare(Session s, ArrayList<IndexCondition> indexConditions) {\n         this.session = s;\n         alwaysFalse = false;\n@@ -108,7 +112,7 @@ public class IndexCursor implements Cursor {\n                         inResult = condition.getCurrentResult();\n                     }\n                 }\n-            } else {\n+                                                         } else {\n                 Value v = condition.getCurrentValue(s);\n                 boolean isStart = condition.isStart();\n                 boolean isEnd = condition.isEnd();\n@@ -162,6 +166,8 @@ public class IndexCursor implements Cursor {\n      * @param s the session\n      * @param indexConditions the index conditions\n      */\n+\n+\n     public void find(Session s, ArrayList<IndexCondition> indexConditions) {\n         prepare(s, indexConditions);\n         if (inColumn != null) {\n@@ -169,8 +175,7 @@ public class IndexCursor implements Cursor {\n         }\n         if (!alwaysFalse) {\n             if (intersects != null && index instanceof SpatialIndex) {\n-                cursor = ((SpatialIndex) index).findByGeometry(tableFilter,\n-                        start, end, intersects);\n+                cursor = ((SpatialIndex) index).findByGeometry(tableFilter, start, end, intersects);\n             } else {\n                 cursor = index.find(tableFilter, start, end);\n             }\n@@ -205,10 +210,8 @@ public class IndexCursor implements Cursor {\n             // if an object needs to overlap with both a and b,\n             // then it needs to overlap with the the union of a and b\n             // (not the intersection)\n-            ValueGeometry vg = (ValueGeometry) row.getValue(columnId).\n-                    convertTo(Value.GEOMETRY);\n-            v = ((ValueGeometry) v.convertTo(Value.GEOMETRY)).\n-                    getEnvelopeUnion(vg);\n+            ValueGeometry vg = (ValueGeometry) row.getValue(columnId).convertTo(Value.GEOMETRY);\n+            v = ((ValueGeometry) v.convertTo(Value.GEOMETRY)).getEnvelopeUnion(vg);\n         }\n         if (columnId == SearchRow.ROWID_INDEX) {\n             row.setKey(v.getLong());\n@@ -219,12 +222,10 @@ public class IndexCursor implements Cursor {\n     }\n \n     private SearchRow getSearchRow(SearchRow row, int columnId, Value v, boolean max) {\n-        Column column = columnId == SearchRow.ROWID_INDEX ?\n-                                table.getRowIdColumn() :\n-                                table.getColumn(columnId);\n+        Column column = columnId == SearchRow.ROWID_INDEX ? table.getRowIdColumn() : table.getColumn(columnId);\n         int vType = v.getType();\n         int resType = Value.getHigherOrder(column.getType(), vType);\n-        if(vType != resType) {\n+        if (vType != resType) {\n             v = column.convert(v, session.getDatabase().getMode());\n         }\n         if (row == null) {\n@@ -272,6 +273,8 @@ public class IndexCursor implements Cursor {\n      *\n      * @return true if it is\n      */\n+\n+\n     public boolean isAlwaysFalse() {\n         return alwaysFalse;\n     }\n@@ -281,6 +284,8 @@ public class IndexCursor implements Cursor {\n      *\n      * @return search row\n      */\n+\n+\n     public SearchRow getStart() {\n         return start;\n     }\n@@ -290,6 +295,8 @@ public class IndexCursor implements Cursor {\n      *\n      * @return search row\n      */\n+\n+\n     public SearchRow getEnd() {\n         return end;\n     }\n@@ -337,7 +344,7 @@ public class IndexCursor implements Cursor {\n                 Value v = inResult.currentRow()[0];\n                 if (v != ValueNull.INSTANCE) {\n                     if (inResultTested == null) {\n-                        inResultTested = new HashSet<>();\n+                        inResultTested = new HashSet< >();\n                     }\n                     if (inResultTested.add(v)) {\n                         find(v);\n@@ -360,4 +367,4 @@ public class IndexCursor implements Cursor {\n         throw DbException.throwInternalError(toString());\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 27
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/105/IndexCursor.java\nindex 46ace5f1664..575b30c51db 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/105/IndexCursor.java\n@@ -224,7 +224,7 @@ public class IndexCursor implements Cursor {\n                                 table.getColumn(columnId);\n         int vType = v.getType();\n         int resType = Value.getHigherOrder(column.getType(), vType);\n-        if(vType != resType) {\n+        if (vType != resType) {\n             v = column.convert(v, session.getDatabase().getMode());\n         }\n         if (row == null) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/105/IndexCursor.java\nindex 46ace5f1664..575b30c51db 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/105/IndexCursor.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/105/IndexCursor.java\n@@ -224,7 +224,7 @@ public class IndexCursor implements Cursor {\n                                 table.getColumn(columnId);\n         int vType = v.getType();\n         int resType = Value.getHigherOrder(column.getType(), vType);\n-        if(vType != resType) {\n+        if (vType != resType) {\n             v = column.convert(v, session.getDatabase().getMode());\n         }\n         if (row == null) {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": []
}