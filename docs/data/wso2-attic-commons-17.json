{
    "project_name": "wso2-attic-commons",
    "error_id": "17",
    "information": {
        "errors": [
            {
                "line": "90",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 121).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "     * The standard URI for the default subject category value\n     */\n    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n\n    // helper array of strings\n    static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/17/AttributeDesignator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/17/AttributeDesignator.java\nindex 7078ab1beec..26089c3a129 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/17/AttributeDesignator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/17/AttributeDesignator.java\n@@ -87,10 +87,11 @@ public class AttributeDesignator extends AbstractDesignator {\n     /**\n      * The standard URI for the default subject category value\n      */\n-    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n+    public static final String SUBJECT_CATEGORY_DEFAULT =\n+\t\t\t\t\t\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n \n-    // helper array of strings\n-    static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};\n+     // helper array of strings\n+     static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};\n \n     // the type of designator we are\n     private int target;\n",
            "diff_size": 4
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/17/AttributeDesignator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/17/AttributeDesignator.java\nindex 7078ab1beec..f5d1b077375 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/17/AttributeDesignator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/17/AttributeDesignator.java\n@@ -8,7 +8,7 @@\n  *\n  *   1. Redistribution of source code must retain the above copyright notice,\n  *      this list of conditions and the following disclaimer.\n- * \n+ *\n  *   2. Redistribution in binary form must reproduce the above copyright\n  *      notice, this list of conditions and the following disclaimer in the\n  *      documentation and/or other materials provided with the distribution.\n@@ -16,7 +16,7 @@\n  * Neither the name of Sun Microsystems, Inc. or the names of contributors may\n  * be used to endorse or promote products derived from this software without\n  * specific prior written permission.\n- * \n+ *\n  * This software is provided \"AS IS,\" without a warranty of any kind. ALL\n  * EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING\n  * ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\n@@ -64,393 +64,401 @@ import org.w3c.dom.Node;\n  */\n public class AttributeDesignator extends AbstractDesignator {\n \n-    /**\n-     * Tells designator to search in the subject section of the request\n-     */\n-    public static final int SUBJECT_TARGET = 0;\n-\n-    /**\n-     * Tells designator to search in the resource section of the request\n-     */\n-    public static final int RESOURCE_TARGET = 1;\n-\n-    /**\n-     * Tells designator to search in the action section of the request\n-     */\n-    public static final int ACTION_TARGET = 2;\n-\n-    /**\n-     * Tells designator to search in the environment section of the request\n-     */\n-    public static final int ENVIRONMENT_TARGET = 3;\n-\n-    /**\n-     * The standard URI for the default subject category value\n-     */\n-    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n-\n-    // helper array of strings\n-    static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};\n-\n-    // the type of designator we are\n-    private int target;\n-\n-    // required attributes\n-    private URI type;\n-    private URI id;\n-\n-    // optional attribute\n-    private String issuer;\n-\n-    // must resolution find something\n-    private boolean mustBePresent;\n-\n-    // here we are defined a category\n-    // This is used only for Subject in XACML2.\n-    // but adding it for all designators\n-    private URI category;\n-\n-    // the logger we'll use for all messages\n-    private static Log logger = LogFactory.getLog(AttributeDesignator.class);\n-\n-    /**\n-     * Creates a new <code>AttributeDesignator</code> without the optional issuer.\n-     *\n-     * @param target        the type of designator as specified by the 4 member *_TARGET fields\n-     * @param type          the data type resolved by this designator\n-     * @param id            the attribute id looked for by this designator\n-     * @param mustBePresent whether resolution must find a value\n-     */\n-    public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent) {\n-        this(target, type, id, mustBePresent, null, null);\n+  /**\n+   * Tells designator to search in the subject section of the request\n+   */\n+  public static final int SUBJECT_TARGET = 0;\n+\n+  /**\n+   * Tells designator to search in the resource section of the request\n+   */\n+  public static final int RESOURCE_TARGET = 1;\n+\n+  /**\n+   * Tells designator to search in the action section of the request\n+   */\n+  public static final int ACTION_TARGET = 2;\n+\n+  /**\n+   * Tells designator to search in the environment section of the request\n+   */\n+  public static final int ENVIRONMENT_TARGET = 3;\n+\n+  /**\n+   * The standard URI for the default subject category value\n+   */\n+  public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n+\n+  // helper array of strings\n+  static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};\n+\n+  // the type of designator we are\n+  private int target;\n+\n+  // required attributes\n+  private URI type;\n+  private URI id;\n+\n+  // optional attribute\n+  private String issuer;\n+\n+  // must resolution find something\n+  private boolean mustBePresent;\n+\n+  // here we are defined a category\n+  // This is used only for Subject in XACML2.\n+  // but adding it for all designators\n+  private URI category;\n+\n+  // the logger we'll use for all messages\n+  private static Log logger = LogFactory.getLog(AttributeDesignator.class);\n+\n+  /**\n+   * Creates a new <code>AttributeDesignator</code> without the optional issuer.\n+   *\n+   * @param target        the type of designator as specified by the 4 member *_TARGET fields\n+   * @param type          the data type resolved by this designator\n+   * @param id            the attribute id looked for by this designator\n+   * @param mustBePresent whether resolution must find a value\n+   */\n+  public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent) {\n+    this(target, type, id, mustBePresent, null, null);\n+  }\n+\n+  /**\n+   * Creates a new <code>AttributeDesignator</code> with the optional issuer.\n+   *\n+   * @param target        the type of designator as specified by the 4 member *_TARGET fields\n+   * @param type          the data type resolved by this designator\n+   * @param id            the attribute id looked for by this designator\n+   * @param mustBePresent whether resolution must find a value\n+   * @param issuer        the issuer of the values to search for or null if no issuer is specified\n+   * @throws IllegalArgumentException if the input target isn't a valid value\n+   */\n+  public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, String issuer)\n+    throws IllegalArgumentException {\n+    this(target, type, id, mustBePresent, null, null);\n+\n+  }\n+\n+  /**\n+   * Creates a new <code>AttributeDesignator</code> with the optional issuer.\n+   *\n+   * @param target        the type of designator as specified by the 4 member *_TARGET fields\n+   * @param type          the data type resolved by this designator\n+   * @param id            the attribute id looked for by this designator\n+   * @param mustBePresent whether resolution must find a value\n+   * @param issuer        the issuer of the values to search for or null if no issuer is specified\n+   * @throws IllegalArgumentException if the input target isn't a valid value\n+   */\n+  public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, String issuer,\n+                             URI category) throws IllegalArgumentException {\n+\n+    // check if input target is a valid value\n+    if ((target != SUBJECT_TARGET) && (target != RESOURCE_TARGET) && (target != ACTION_TARGET)\n+      && (target != ENVIRONMENT_TARGET)) {\n+      throw new IllegalArgumentException(\"Input target is not a valid\" + \"value\");\n+    }\n+    this.target = target;\n+    this.type = type;\n+    this.id = id;\n+    this.mustBePresent = mustBePresent;\n+    this.issuer = issuer;\n+    this.category = category;\n+  }\n+\n+  /**\n+   * Creates a new <code>AttributeDesignator</code> based on the DOM root of the XML data.\n+   *\n+   * @param root the DOM root of the AttributeDesignatorType XML type\n+   * @return the designator\n+   * @throws ParsingException if the AttributeDesignatorType was invalid\n+   */\n+  public static AttributeDesignator getInstance(Node root) throws ParsingException {\n+\n+    URI type = null;\n+    URI id = null;\n+    String issuer = null;\n+    boolean mustBePresent = false;\n+    URI category = null;\n+    int target;\n+\n+    String tagName = root.getNodeName();\n+\n+    if (tagName.equals(\"SubjectAttributeDesignator\")) {\n+      target = SUBJECT_TARGET;\n+    } else if (tagName.equals(\"ResourceAttributeDesignator\")) {\n+      target = RESOURCE_TARGET;\n+    } else if (tagName.equals(\"ActionAttributeDesignator\")) {\n+      target = ACTION_TARGET;\n+    } else if (tagName.equals(\"EnvironmentAttributeDesignator\")) {\n+      target = ENVIRONMENT_TARGET;\n+    } else {\n+      throw new ParsingException(\"AttributeDesignator cannot be constructed using \" + \"type: \"\n+        + root.getNodeName());\n     }\n \n-    /**\n-     * Creates a new <code>AttributeDesignator</code> with the optional issuer.\n-     *\n-     * @param target        the type of designator as specified by the 4 member *_TARGET fields\n-     * @param type          the data type resolved by this designator\n-     * @param id            the attribute id looked for by this designator\n-     * @param mustBePresent whether resolution must find a value\n-     * @param issuer        the issuer of the values to search for or null if no issuer is specified\n-     * @throws IllegalArgumentException if the input target isn't a valid value\n-     */\n-    public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, String issuer)\n-                                    throws IllegalArgumentException {\n-        this(target, type, id, mustBePresent, null, null);\n+    NamedNodeMap attrs = root.getAttributes();\n \n+    try {\n+      // there's always an Id\n+      id = new URI(attrs.getNamedItem(\"AttributeId\").getNodeValue());\n+    } catch (Exception e) {\n+      throw new ParsingException(\"Required AttributeId missing in \" + \"AttributeDesignator\",\n+        e);\n     }\n \n-    /**\n-     * Creates a new <code>AttributeDesignator</code> with the optional issuer.\n-     *\n-     * @param target        the type of designator as specified by the 4 member *_TARGET fields\n-     * @param type          the data type resolved by this designator\n-     * @param id            the attribute id looked for by this designator\n-     * @param mustBePresent whether resolution must find a value\n-     * @param issuer        the issuer of the values to search for or null if no issuer is specified\n-     * @throws IllegalArgumentException if the input target isn't a valid value\n-     */\n-    public AttributeDesignator(int target, URI type, URI id, boolean mustBePresent, String issuer,\n-                               URI category) throws IllegalArgumentException {\n-\n-        // check if input target is a valid value\n-        if ((target != SUBJECT_TARGET) && (target != RESOURCE_TARGET) && (target != ACTION_TARGET)\n-                && (target != ENVIRONMENT_TARGET))\n-            throw new IllegalArgumentException(\"Input target is not a valid\" + \"value\");\n-        this.target = target;\n-        this.type = type;\n-        this.id = id;\n-        this.mustBePresent = mustBePresent;\n-        this.issuer = issuer;\n-        this.category = category;\n+    try {\n+      // there's always a data type\n+      type = new URI(attrs.getNamedItem(\"DataType\").getNodeValue());\n+    } catch (Exception e) {\n+      throw new ParsingException(\"Required DataType missing in \" + \"AttributeDesignator\", e);\n     }\n \n-    /**\n-     * Creates a new <code>AttributeDesignator</code> based on the DOM root of the XML data.\n-     *\n-     * @param root     the DOM root of the AttributeDesignatorType XML type\n-     * @return the designator\n-     * @throws ParsingException if the AttributeDesignatorType was invalid\n-     */\n-    public static AttributeDesignator getInstance(Node root) throws ParsingException {\n-\n-        URI type = null;\n-        URI id = null;\n-        String issuer = null;\n-        boolean mustBePresent = false;\n-        URI category = null;\n-        int target;\n-\n-        String tagName = root.getNodeName();\n-\n-        if (tagName.equals(\"SubjectAttributeDesignator\")) {\n-            target = SUBJECT_TARGET;\n-        } else if (tagName.equals(\"ResourceAttributeDesignator\")) {\n-            target = RESOURCE_TARGET;\n-        } else if (tagName.equals(\"ActionAttributeDesignator\")) {\n-            target = ACTION_TARGET;\n-        } else if (tagName.equals(\"EnvironmentAttributeDesignator\")) {\n-            target = ENVIRONMENT_TARGET;\n+    try {\n+      // there might be an issuer\n+      Node node = attrs.getNamedItem(\"Issuer\");\n+      if (node != null) {\n+        issuer = node.getNodeValue();\n+      }\n+\n+      // if it's for the Subject section, there's another attr\n+      if (target == SUBJECT_TARGET) {\n+        Node scnode = attrs.getNamedItem(\"SubjectCategory\");\n+        if (scnode != null) {\n+          category = new URI(scnode.getNodeValue());\n         } else {\n-            throw new ParsingException(\"AttributeDesignator cannot be constructed using \" + \"type: \"\n-                    + root.getNodeName());\n-        }\n-\n-        NamedNodeMap attrs = root.getAttributes();\n-\n-        try {\n-            // there's always an Id\n-            id = new URI(attrs.getNamedItem(\"AttributeId\").getNodeValue());\n-        } catch (Exception e) {\n-            throw new ParsingException(\"Required AttributeId missing in \" + \"AttributeDesignator\",\n-                    e);\n-        }\n-\n-        try {\n-            // there's always a data type\n-            type = new URI(attrs.getNamedItem(\"DataType\").getNodeValue());\n-        } catch (Exception e) {\n-            throw new ParsingException(\"Required DataType missing in \" + \"AttributeDesignator\", e);\n+          category = new URI(SUBJECT_CATEGORY_DEFAULT);\n         }\n-\n-        try {\n-            // there might be an issuer\n-            Node node = attrs.getNamedItem(\"Issuer\");\n-            if (node != null)\n-                issuer = node.getNodeValue();\n-\n-            // if it's for the Subject section, there's another attr\n-            if (target == SUBJECT_TARGET) {\n-                Node scnode = attrs.getNamedItem(\"SubjectCategory\");\n-                if (scnode != null){\n-                    category = new URI(scnode.getNodeValue());\n-                } else {\n-                    category = new URI(SUBJECT_CATEGORY_DEFAULT);\n-                }\n-            } else if (target == RESOURCE_TARGET){\n-                category = new URI(XACMLConstants.RESOURCE_CATEGORY);\n-            } else if (target == ACTION_TARGET){\n-                category = new URI(XACMLConstants.ACTION_CATEGORY);\n-            } else if (target == ENVIRONMENT_TARGET) {\n-                category = new URI(XACMLConstants.ENT_CATEGORY);\n-            }\n-\n-            // there might be a mustBePresent flag\n-            node = attrs.getNamedItem(\"MustBePresent\");\n-            if (node != null)\n-                if (node.getNodeValue().equals(\"true\"))\n-                    mustBePresent = true;\n-        } catch (Exception e) {\n-            // this shouldn't ever happen, but in theory something could go\n-            // wrong in the code in this try block\n-            throw new ParsingException(\n-                    \"Error parsing AttributeDesignator \" + \"optional attributes\", e);\n+      } else if (target == RESOURCE_TARGET) {\n+        category = new URI(XACMLConstants.RESOURCE_CATEGORY);\n+      } else if (target == ACTION_TARGET) {\n+        category = new URI(XACMLConstants.ACTION_CATEGORY);\n+      } else if (target == ENVIRONMENT_TARGET) {\n+        category = new URI(XACMLConstants.ENT_CATEGORY);\n+      }\n+\n+      // there might be a mustBePresent flag\n+      node = attrs.getNamedItem(\"MustBePresent\");\n+      if (node != null) {\n+        if (node.getNodeValue().equals(\"true\")) {\n+          mustBePresent = true;\n         }\n-\n-        return new AttributeDesignator(target, type, id, mustBePresent, issuer, category);\n+      }\n+    } catch (Exception e) {\n+      // this shouldn't ever happen, but in theory something could go\n+      // wrong in the code in this try block\n+      throw new ParsingException(\n+        \"Error parsing AttributeDesignator \" + \"optional attributes\", e);\n     }\n \n-    /**\n-     * Returns the type of this designator as specified by the *_TARGET fields.\n-     *\n-     * @return the designator type\n-     */\n-    public int getDesignatorType() {\n-        return target;\n+    return new AttributeDesignator(target, type, id, mustBePresent, issuer, category);\n+  }\n+\n+  /**\n+   * Returns the type of this designator as specified by the *_TARGET fields.\n+   *\n+   * @return the designator type\n+   */\n+  public int getDesignatorType() {\n+    return target;\n+  }\n+\n+  /**\n+   * Returns the type of attribute that is resolved by this designator. While an AD will always\n+   * return a bag, this method will always return the type that is stored in the bag.\n+   *\n+   * @return the attribute type\n+   */\n+  public URI getType() {\n+    return type;\n+  }\n+\n+  /**\n+   * Returns the AttributeId of the values resolved by this designator.\n+   *\n+   * @return identifier for the values to resolve\n+   */\n+  public URI getId() {\n+    return id;\n+  }\n+\n+  /**\n+   * Returns the subject category for this designator. If this is not a SubjectAttributeDesignator\n+   * then this will always return null.\n+   *\n+   * @return the subject category or null if this isn't a SubjectAttributeDesignator\n+   */\n+  public URI getCategory() {\n+    return category;\n+  }\n+\n+  /**\n+   * Returns the issuer of the values resolved by this designator if specified.\n+   *\n+   * @return the attribute issuer or null if unspecified\n+   */\n+  public String getIssuer() {\n+    return issuer;\n+  }\n+\n+  /**\n+   * Returns whether or not a value is required to be resolved by this designator.\n+   *\n+   * @return true if a value is required, false otherwise\n+   */\n+  public boolean mustBePresent() {\n+    return mustBePresent;\n+  }\n+\n+  /**\n+   * Always returns true, since a designator always returns a bag of attribute values.\n+   *\n+   * @return true\n+   */\n+  public boolean returnsBag() {\n+    return true;\n+  }\n+\n+  /**\n+   * Always returns true, since a designator always returns a bag of attribute values.\n+   *\n+   * @return true\n+   * @deprecated As of 2.0, you should use the <code>returnsBag</code> method from the\n+   * super-interface <code>Expression</code>.\n+   */\n+  public boolean evaluatesToBag() {\n+    return true;\n+  }\n+\n+  /**\n+   * Always returns an empty list since designators never have children.\n+   *\n+   * @return an empty <code>List</code>\n+   */\n+  public List getChildren() {\n+    return Collections.EMPTY_LIST;\n+  }\n+\n+  /**\n+   * Evaluates the pre-assigned meta-data against the given context, trying to find some matching\n+   * values.\n+   *\n+   * @param evaluationCtx the representation of the request\n+   * @return a result containing a bag either empty because no values were found or containing at\n+   * least one value, or status associated with an Indeterminate result\n+   */\n+  public EvaluationResult evaluate(EvaluationCtx evaluationCtx) {\n+\n+    EvaluationResult result = null;\n+\n+    // look in the right section for some attribute values\n+    switch (target) {\n+    case SUBJECT_TARGET:\n+      result = evaluationCtx.getAttribute(type, id, issuer, category);\n+      break;\n+    case RESOURCE_TARGET:\n+      result = evaluationCtx.getAttribute(type, id, issuer, category);\n+      break;\n+    case ACTION_TARGET:\n+      result = evaluationCtx.getAttribute(type, id, issuer, category);\n+      break;\n+    case ENVIRONMENT_TARGET:\n+      result = evaluationCtx.getAttribute(type, id, issuer, category);\n+      break;\n     }\n \n-    /**\n-     * Returns the type of attribute that is resolved by this designator. While an AD will always\n-     * return a bag, this method will always return the type that is stored in the bag.\n-     *\n-     * @return the attribute type\n-     */\n-    public URI getType() {\n-        return type;\n-    }\n+    // if the lookup was indeterminate, then we return immediately\n+    if (result != null) {\n+      if (result.indeterminate()) {\n+        return result;\n+      }\n \n-    /**\n-     * Returns the AttributeId of the values resolved by this designator.\n-     *\n-     * @return identifier for the values to resolve\n-     */\n-    public URI getId() {\n-        return id;\n-    }\n+      BagAttribute bag = (BagAttribute) (result.getAttributeValue());\n \n-    /**\n-     * Returns the subject category for this designator. If this is not a SubjectAttributeDesignator\n-     * then this will always return null.\n-     *\n-     * @return the subject category or null if this isn't a SubjectAttributeDesignator\n-     */\n-    public URI getCategory() {\n-        return category;\n-    }\n+      if (bag.isEmpty()) {\n+        // if it's empty, this may be an error\n+        if (mustBePresent) {\n+          if (logger.isDebugEnabled()) {\n+            logger.debug(\"AttributeDesignator failed to resolve a \"\n+              + \"value for a required attribute: \" + id.toString());\n+          }\n \n-    /**\n-     * Returns the issuer of the values resolved by this designator if specified.\n-     *\n-     * @return the attribute issuer or null if unspecified\n-     */\n-    public String getIssuer() {\n-        return issuer;\n-    }\n+          ArrayList<String> code = new ArrayList<String>();\n+          code.add(Status.STATUS_MISSING_ATTRIBUTE);\n \n-    /**\n-     * Returns whether or not a value is required to be resolved by this designator.\n-     *\n-     * @return true if a value is required, false otherwise\n-     */\n-    public boolean mustBePresent() {\n-        return mustBePresent;\n-    }\n+          String message = \"Couldn't find \" + targetTypes[target]\n+            + \"AttributeDesignator attribute\";\n \n-    /**\n-     * Always returns true, since a designator always returns a bag of attribute values.\n-     *\n-     * @return true\n-     */\n-    public boolean returnsBag() {\n-        return true;\n-    }\n-\n-    /**\n-     * Always returns true, since a designator always returns a bag of attribute values.\n-     *\n-     * @return true\n-     * @deprecated As of 2.0, you should use the <code>returnsBag</code> method from the\n-     *             super-interface <code>Expression</code>.\n-     */\n-    public boolean evaluatesToBag() {\n-        return true;\n-    }\n+          // Note that there is a bug in the XACML spec. You can't  //TODO\n+          // specify an identifier without specifying acceptable\n+          // values. Until this is fixed, this code will only\n+          // return the status code, and not any hints about what\n+          // was missing\n \n-    /**\n-     * Always returns an empty list since designators never have children.\n-     *\n-     * @return an empty <code>List</code>\n-     */\n-    public List getChildren() {\n-        return Collections.EMPTY_LIST;\n-    }\n+          /*\n+           * List attrs = new ArrayList(); attrs.add(new Attribute(id, ((issuer == null) ?\n+           * null : issuer.toString()), null, null)); StatusDetail detail = new\n+           * StatusDetail(attrs);\n+           */\n \n-    /**\n-     * Evaluates the pre-assigned meta-data against the given context, trying to find some matching\n-     * values.\n-     *\n-     * @param evaluationCtx the representation of the request\n-     * @return a result containing a bag either empty because no values were found or containing at\n-     *         least one value, or status associated with an Indeterminate result\n-     */\n-    public EvaluationResult evaluate(EvaluationCtx evaluationCtx) {\n-\n-        EvaluationResult result = null;\n-\n-        // look in the right section for some attribute values\n-        switch (target) {\n-            case SUBJECT_TARGET:\n-                result = evaluationCtx.getAttribute(type, id, issuer, category);\n-                break;\n-            case RESOURCE_TARGET:\n-                result = evaluationCtx.getAttribute(type, id, issuer, category);\n-                break;\n-            case ACTION_TARGET:\n-                result = evaluationCtx.getAttribute(type, id, issuer, category);\n-                break;\n-            case ENVIRONMENT_TARGET:\n-                result = evaluationCtx.getAttribute(type, id, issuer, category);\n-                break;\n+          return new EvaluationResult(new Status(code, message));\n         }\n-\n-        // if the lookup was indeterminate, then we return immediately\n-        if(result != null){\n-            if (result.indeterminate())\n-                return result;\n-\n-            BagAttribute bag = (BagAttribute) (result.getAttributeValue());\n-\n-            if (bag.isEmpty()) {\n-                // if it's empty, this may be an error\n-                if (mustBePresent) {\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"AttributeDesignator failed to resolve a \"\n-                                + \"value for a required attribute: \" + id.toString());\n-                    }\n-\n-                    ArrayList<String> code = new ArrayList<String>();\n-                    code.add(Status.STATUS_MISSING_ATTRIBUTE);\n-\n-                    String message = \"Couldn't find \" + targetTypes[target]\n-                            + \"AttributeDesignator attribute\";\n-\n-                    // Note that there is a bug in the XACML spec. You can't  //TODO\n-                    // specify an identifier without specifying acceptable\n-                    // values. Until this is fixed, this code will only\n-                    // return the status code, and not any hints about what\n-                    // was missing\n-\n-                    /*\n-                     * List attrs = new ArrayList(); attrs.add(new Attribute(id, ((issuer == null) ?\n-                     * null : issuer.toString()), null, null)); StatusDetail detail = new\n-                     * StatusDetail(attrs);\n-                     */\n-\n-                    return new EvaluationResult(new Status(code, message));\n-                }\n-            }\n-        } else {\n-            ArrayList<String> code = new ArrayList<String>();\n-            code.add(Status.STATUS_MISSING_ATTRIBUTE);\n-            String message = \"Couldn't find \" + targetTypes[target]\n-                    + \"AttributeDesignator attribute\";\n-            return new EvaluationResult(new Status(code, message));  //TODO\n+      }\n+    } else {\n+      ArrayList<String> code = new ArrayList<String>();\n+      code.add(Status.STATUS_MISSING_ATTRIBUTE);\n+      String message = \"Couldn't find \" + targetTypes[target]\n+        + \"AttributeDesignator attribute\";\n+      return new EvaluationResult(new Status(code, message));  //TODO\n     }\n \n-        // if we got here the bag wasn't empty, or mustBePresent was false,\n-        // so we just return the result\n-        return result;\n+    // if we got here the bag wasn't empty, or mustBePresent was false,\n+    // so we just return the result\n+    return result;\n+  }\n+\n+  /**\n+   * Encodes this designator into its XML representation and writes this encoding to the given\n+   * <code>OutputStream</code> with no indentation.\n+   *\n+   * @param output a stream into which the XML-encoded data is written\n+   */\n+  public void encode(OutputStream output) {\n+    encode(output, new Indenter(0));\n+  }\n+\n+  /**\n+   * Encodes this designator into its XML representation and writes this encoding to the given\n+   * <code>OutputStream</code> with indentation.\n+   *\n+   * @param output   a stream into which the XML-encoded data is written\n+   * @param indenter an object that creates indentation strings\n+   */\n+  public void encode(OutputStream output, Indenter indenter) {\n+    PrintStream out = new PrintStream(output);\n+    String indent = indenter.makeString();\n+\n+    String tag = \"<\" + targetTypes[target] + \"AttributeDesignator\";\n+\n+    if ((target == SUBJECT_TARGET) && (category != null)) {\n+      tag += \" SubjectCategory=\\\"\" + category.toString() + \"\\\"\";\n     }\n \n-    /**\n-     * Encodes this designator into its XML representation and writes this encoding to the given\n-     * <code>OutputStream</code> with no indentation.\n-     *\n-     * @param output a stream into which the XML-encoded data is written\n-     */\n-    public void encode(OutputStream output) {\n-        encode(output, new Indenter(0));\n-    }\n+    tag += \" AttributeId=\\\"\" + id.toString() + \"\\\"\";\n+    tag += \" DataType=\\\"\" + type.toString() + \"\\\"\";\n \n-    /**\n-     * Encodes this designator into its XML representation and writes this encoding to the given\n-     * <code>OutputStream</code> with indentation.\n-     *\n-     * @param output   a stream into which the XML-encoded data is written\n-     * @param indenter an object that creates indentation strings\n-     */\n-    public void encode(OutputStream output, Indenter indenter) {\n-        PrintStream out = new PrintStream(output);\n-        String indent = indenter.makeString();\n-\n-        String tag = \"<\" + targetTypes[target] + \"AttributeDesignator\";\n-\n-        if ((target == SUBJECT_TARGET) && (category != null))\n-            tag += \" SubjectCategory=\\\"\" + category.toString() + \"\\\"\";\n-\n-        tag += \" AttributeId=\\\"\" + id.toString() + \"\\\"\";\n-        tag += \" DataType=\\\"\" + type.toString() + \"\\\"\";\n-\n-        if (issuer != null)\n-            tag += \" Issuer=\\\"\" + issuer.toString() + \"\\\"\";\n+    if (issuer != null) {\n+      tag += \" Issuer=\\\"\" + issuer.toString() + \"\\\"\";\n+    }\n \n-        if (mustBePresent)\n-            tag += \" MustBePresent=\\\"true\\\"\";\n+    if (mustBePresent) {\n+      tag += \" MustBePresent=\\\"true\\\"\";\n+    }\n \n-        tag += \"/>\";\n+    tag += \"/>\";\n \n-        out.println(indent + tag);\n-    }\n+    out.println(indent + tag);\n+  }\n \n }\n",
            "diff_size": 578
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/17/AttributeDesignator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/17/AttributeDesignator.java\nindex 7078ab1beec..26089c3a129 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/17/AttributeDesignator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_random/17/AttributeDesignator.java\n@@ -87,10 +87,11 @@ public class AttributeDesignator extends AbstractDesignator {\n     /**\n      * The standard URI for the default subject category value\n      */\n-    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n+    public static final String SUBJECT_CATEGORY_DEFAULT =\n+\t\t\t\t\t\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n \n-    // helper array of strings\n-    static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};\n+     // helper array of strings\n+     static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};\n \n     // the type of designator we are\n     private int target;\n",
            "diff_size": 4
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/17/AttributeDesignator.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/17/AttributeDesignator.java\nindex 7078ab1beec..c5878813995 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/17/AttributeDesignator.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/17/AttributeDesignator.java\n@@ -87,10 +87,11 @@ public class AttributeDesignator extends AbstractDesignator {\n     /**\n      * The standard URI for the default subject category value\n      */\n-    public static final String SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n+    public static final String\n+        SUBJECT_CATEGORY_DEFAULT = \"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\";\n \n-    // helper array of strings\n-    static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};\n+     // helper array of strings\n+     static final private String[] targetTypes = {\"Subject\", \"Resource\", \"Action\", \"Environment\"};\n \n     // the type of designator we are\n     private int target;\n",
            "diff_size": 4
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff"
    ]
}