{
    "project_name": "IQSS-dataverse",
    "error_id": "105",
    "information": {
        "errors": [
            {
                "line": "199",
                "column": "5",
                "severity": "error",
                "message": "'{' at column 5 should be on the previous line.",
                "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
            }
        ]
    },
    "source_code": "    public static <T> Iterator<T> lookupProviders(Class<T> providerClass,\n                                                  ClassLoader loader)\n    {\n        if (providerClass == null) {\n            throw new IllegalArgumentException(\"providerClass == null!\");\n        }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/105/ServiceRegistry.java\nindex 1794adb5de2..d12932f4946 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/105/ServiceRegistry.java\n@@ -195,9 +195,8 @@ public class ServiceRegistry {\n      * <code>providerClass</code> is <code>null</code>.\n      */\n     public static <T> Iterator<T> lookupProviders(Class<T> providerClass,\n-                                                  ClassLoader loader)\n-    {\n-        if (providerClass == null) {\n+                                                  ClassLoader loader) {\n+                                                      if (providerClass == null) {\n             throw new IllegalArgumentException(\"providerClass == null!\");\n         }\n         return ServiceLoader.load(providerClass, loader).iterator();\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/105/ServiceRegistry.java\nindex 1794adb5de2..d59da1a6c57 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/105/ServiceRegistry.java\n@@ -17,8 +17,8 @@\n    Developed at the Institute for Quantitative Social Science, Harvard University.\n    Version 3.0.\n */\n-package edu.harvard.iq.dataverse.ingest.plugin.spi;\n \n+package edu.harvard.iq.dataverse.ingest.plugin.spi;\n \n \n // This file was Taken out from openjdk-6-src-b16-24_apr_2009.tar.gz\n@@ -100,7 +100,7 @@ import java.util.ServiceLoader;\n  * <code>javax.someapi.SomeService</code> interface, the JAR file\n  * would contain a file named: <pre>\n  * META-INF/services/javax.someapi.SomeService </pre>\n- *\n+ * <p>\n  * containing the line:\n  *\n  * <pre>\n@@ -122,587 +122,558 @@ import java.util.ServiceLoader;\n  * JAR File Specification</a>.\n  *\n  * @see RegisterableService\n- *\n  */\n public class ServiceRegistry {\n \n-    // Class -> Registry\n-    private Map<Class<?>, SubRegistry> categoryMap = new HashMap<>();\n-\n-    /**\n-     * Constructs a <code>ServiceRegistry</code> instance with a\n-     * set of categories taken from the <code>categories</code>\n-     * argument.\n-     *\n-     * @param categories an <code>Iterator</code> containing\n-     * <code>Class</code> objects to be used to define categories.\n-     *\n-     * @exception IllegalArgumentException if\n-     * <code>categories</code> is <code>null</code>.\n-     */\n-    public ServiceRegistry(Iterator<Class<?>> categories) {\n-        if (categories == null) {\n-            throw new IllegalArgumentException(\"categories == null!\");\n-        }\n-        while (categories.hasNext()) {\n-            Class<?> category = categories.next();\n-            SubRegistry reg = new SubRegistry(this, category);\n-            categoryMap.put(category, reg);\n-        }\n-    }\n-\n-    // The following two methods expose functionality from\n-    // sun.misc.Service.  If that class is made public, they may be\n-    // removed.\n-    //\n-    // The sun.misc.ServiceConfigurationError class may also be\n-    // exposed, in which case the references to 'an\n-    // <code>Error</code>' below should be changed to 'a\n-    // <code>ServiceConfigurationError</code>'.\n-\n-    /**\n-     * Searches for implementations of a particular service class\n-     * using the given class loader.\n-     *\n-     * <p> This method transforms the name of the given service class\n-     * into a provider-configuration filename as described in the\n-     * class comment and then uses the <code>getResources</code>\n-     * method of the given class loader to find all available files\n-     * with that name.  These files are then read and parsed to\n-     * produce a list of provider-class names.  The iterator that is\n-     * returned uses the given class loader to look up and then\n-     * instantiate each element of the list.\n-     *\n-     * <p> Because it is possible for extensions to be installed into\n-     * a running Java virtual machine, this method may return\n-     * different results each time it is invoked.\n-     *\n-     * @param providerClass a <code>Class</code>object indicating the\n-     * class or interface of the service providers being detected.\n-     *\n-     * @param loader the class loader to be used to load\n-     * provider-configuration files and instantiate provider classes,\n-     * or <code>null</code> if the system class loader (or, failing that\n-     * the bootstrap class loader) is to be used.\n-     *\n-     * @return An <code>Iterator</code> that yields provider objects\n-     * for the given service, in some arbitrary order.  The iterator\n-     * will throw an <code>Error</code> if a provider-configuration\n-     * file violates the specified format or if a provider class\n-     * cannot be found and instantiated.\n-     *\n-     * @exception IllegalArgumentException if\n-     * <code>providerClass</code> is <code>null</code>.\n-     */\n-    public static <T> Iterator<T> lookupProviders(Class<T> providerClass,\n-                                                  ClassLoader loader)\n-    {\n-        if (providerClass == null) {\n-            throw new IllegalArgumentException(\"providerClass == null!\");\n-        }\n-        return ServiceLoader.load(providerClass, loader).iterator();\n-    }\n-\n-    /**\n-     * Locates and incrementally instantiates the available providers\n-     * of a given service using the context class loader.  This\n-     * convenience method is equivalent to:\n-     *\n-     * <pre>\n-     *   ClassLoader cl = Thread.currentThread().getContextClassLoader();\n-     *   return Service.providers(service, cl);\n-     * </pre>\n-     *\n-     * @param providerClass a <code>Class</code>object indicating the\n-     * class or interface of the service providers being detected.\n-     *\n-     * @return An <code>Iterator</code> that yields provider objects\n-     * for the given service, in some arbitrary order.  The iterator\n-     * will throw an <code>Error</code> if a provider-configuration\n-     * file violates the specified format or if a provider class\n-     * cannot be found and instantiated.\n-     *\n-     * @exception IllegalArgumentException if\n-     * <code>providerClass</code> is <code>null</code>.\n-     */\n-    public static <T> Iterator<T> lookupProviders(Class<T> providerClass) {\n-        if (providerClass == null) {\n-            throw new IllegalArgumentException(\"providerClass == null!\");\n-        }\n-        return ServiceLoader.load(providerClass).iterator();\n-    }\n-\n-    /**\n-     * Returns an <code>Iterator</code> of <code>Class</code> objects\n-     * indicating the current set of categories.  The iterator will be\n-     * empty if no categories exist.\n-     *\n-     * @return an <code>Iterator</code> containing\n-     * <code>Class</code>objects.\n-     */\n-    public Iterator<Class<?>> getCategories() {\n-        Set<Class<?>> keySet = categoryMap.keySet();\n-        return keySet.iterator();\n-    }\n-\n-    /**\n-     * Returns an Iterator containing the subregistries to which the\n-     * provider belongs.\n-     */\n-    private Iterator<SubRegistry> getSubRegistries(Object provider) {\n-        List<SubRegistry> l = new ArrayList<>();\n-        Iterator<Class<?>> iter = categoryMap.keySet().iterator();\n-        while (iter.hasNext()) {\n-            Class<?> c = iter.next();\n-            if (c.isAssignableFrom(provider.getClass())) {\n-                l.add(categoryMap.get(c));\n-            }\n-        }\n-        return l.iterator();\n-    }\n-\n-    /**\n-     * Adds a service provider object to the registry.  The provider\n-     * is associated with the given category.\n-     *\n-     * <p> If <code>provider</code> implements the\n-     * <code>RegisterableService</code> interface, its\n-     * <code>onRegistration</code> method will be called.  Its\n-     * <code>onDeregistration</code> method will be called each time\n-     * it is deregistered from a category, for example if a\n-     * category is removed or the registry is garbage collected.\n-     *\n-     * @param provider the service provide object to be registered.\n-     * @param category the category under which to register the\n-     * provider.\n-     *\n-     * @return true if no provider of the same class was previously\n-     * registered in the same category category.\n-     *\n-     * @exception IllegalArgumentException if <code>provider</code> is\n-     * <code>null</code>.\n-     * @exception IllegalArgumentException if there is no category\n-     * corresponding to <code>category</code>.\n-     * @exception ClassCastException if provider does not implement\n-     * the <code>Class</code> defined by <code>category</code>.\n-     */\n-    public <T> boolean registerServiceProvider(T provider,\n+  // Class -> Registry\n+  private Map<Class<?>, SubRegistry> categoryMap = new HashMap<>();\n+\n+  /**\n+   * Constructs a <code>ServiceRegistry</code> instance with a\n+   * set of categories taken from the <code>categories</code>\n+   * argument.\n+   *\n+   * @param categories an <code>Iterator</code> containing\n+   *                   <code>Class</code> objects to be used to define categories.\n+   * @throws IllegalArgumentException if\n+   *                                  <code>categories</code> is <code>null</code>.\n+   */\n+  public ServiceRegistry(Iterator<Class<?>> categories) {\n+    if (categories == null) {\n+      throw new IllegalArgumentException(\"categories == null!\");\n+    }\n+    while (categories.hasNext()) {\n+      Class<?> category = categories.next();\n+      SubRegistry reg = new SubRegistry(this, category);\n+      categoryMap.put(category, reg);\n+    }\n+  }\n+\n+  // The following two methods expose functionality from\n+  // sun.misc.Service.  If that class is made public, they may be\n+  // removed.\n+  //\n+  // The sun.misc.ServiceConfigurationError class may also be\n+  // exposed, in which case the references to 'an\n+  // <code>Error</code>' below should be changed to 'a\n+  // <code>ServiceConfigurationError</code>'.\n+\n+  /**\n+   * Searches for implementations of a particular service class\n+   * using the given class loader.\n+   *\n+   * <p> This method transforms the name of the given service class\n+   * into a provider-configuration filename as described in the\n+   * class comment and then uses the <code>getResources</code>\n+   * method of the given class loader to find all available files\n+   * with that name.  These files are then read and parsed to\n+   * produce a list of provider-class names.  The iterator that is\n+   * returned uses the given class loader to look up and then\n+   * instantiate each element of the list.\n+   *\n+   * <p> Because it is possible for extensions to be installed into\n+   * a running Java virtual machine, this method may return\n+   * different results each time it is invoked.\n+   *\n+   * @param providerClass a <code>Class</code>object indicating the\n+   *                      class or interface of the service providers being detected.\n+   * @param loader        the class loader to be used to load\n+   *                      provider-configuration files and instantiate provider classes,\n+   *                      or <code>null</code> if the system class loader (or, failing that\n+   *                      the bootstrap class loader) is to be used.\n+   * @return An <code>Iterator</code> that yields provider objects\n+   * for the given service, in some arbitrary order.  The iterator\n+   * will throw an <code>Error</code> if a provider-configuration\n+   * file violates the specified format or if a provider class\n+   * cannot be found and instantiated.\n+   * @throws IllegalArgumentException if\n+   *                                  <code>providerClass</code> is <code>null</code>.\n+   */\n+  public static <T> Iterator<T> lookupProviders(Class<T> providerClass,\n+                                                ClassLoader loader) {\n+    if (providerClass == null) {\n+      throw new IllegalArgumentException(\"providerClass == null!\");\n+    }\n+    return ServiceLoader.load(providerClass, loader).iterator();\n+  }\n+\n+  /**\n+   * Locates and incrementally instantiates the available providers\n+   * of a given service using the context class loader.  This\n+   * convenience method is equivalent to:\n+   *\n+   * <pre>\n+   *   ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+   *   return Service.providers(service, cl);\n+   * </pre>\n+   *\n+   * @param providerClass a <code>Class</code>object indicating the\n+   *                      class or interface of the service providers being detected.\n+   * @return An <code>Iterator</code> that yields provider objects\n+   * for the given service, in some arbitrary order.  The iterator\n+   * will throw an <code>Error</code> if a provider-configuration\n+   * file violates the specified format or if a provider class\n+   * cannot be found and instantiated.\n+   * @throws IllegalArgumentException if\n+   *                                  <code>providerClass</code> is <code>null</code>.\n+   */\n+  public static <T> Iterator<T> lookupProviders(Class<T> providerClass) {\n+    if (providerClass == null) {\n+      throw new IllegalArgumentException(\"providerClass == null!\");\n+    }\n+    return ServiceLoader.load(providerClass).iterator();\n+  }\n+\n+  /**\n+   * Returns an <code>Iterator</code> of <code>Class</code> objects\n+   * indicating the current set of categories.  The iterator will be\n+   * empty if no categories exist.\n+   *\n+   * @return an <code>Iterator</code> containing\n+   * <code>Class</code>objects.\n+   */\n+  public Iterator<Class<?>> getCategories() {\n+    Set<Class<?>> keySet = categoryMap.keySet();\n+    return keySet.iterator();\n+  }\n+\n+  /**\n+   * Returns an Iterator containing the subregistries to which the\n+   * provider belongs.\n+   */\n+  private Iterator<SubRegistry> getSubRegistries(Object provider) {\n+    List<SubRegistry> l = new ArrayList<>();\n+    Iterator<Class<?>> iter = categoryMap.keySet().iterator();\n+    while (iter.hasNext()) {\n+      Class<?> c = iter.next();\n+      if (c.isAssignableFrom(provider.getClass())) {\n+        l.add(categoryMap.get(c));\n+      }\n+    }\n+    return l.iterator();\n+  }\n+\n+  /**\n+   * Adds a service provider object to the registry.  The provider\n+   * is associated with the given category.\n+   *\n+   * <p> If <code>provider</code> implements the\n+   * <code>RegisterableService</code> interface, its\n+   * <code>onRegistration</code> method will be called.  Its\n+   * <code>onDeregistration</code> method will be called each time\n+   * it is deregistered from a category, for example if a\n+   * category is removed or the registry is garbage collected.\n+   *\n+   * @param provider the service provide object to be registered.\n+   * @param category the category under which to register the\n+   *                 provider.\n+   * @return true if no provider of the same class was previously\n+   * registered in the same category category.\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   *                                  <code>null</code>.\n+   * @throws IllegalArgumentException if there is no category\n+   *                                  corresponding to <code>category</code>.\n+   * @throws ClassCastException       if provider does not implement\n+   *                                  the <code>Class</code> defined by <code>category</code>.\n+   */\n+  public <T> boolean registerServiceProvider(T provider,\n+                                             Class<T> category) {\n+    if (provider == null) {\n+      throw new IllegalArgumentException(\"provider == null!\");\n+    }\n+    SubRegistry reg = categoryMap.get(category);\n+    if (reg == null) {\n+      throw new IllegalArgumentException(\"category unknown!\");\n+    }\n+    if (!category.isAssignableFrom(provider.getClass())) {\n+      throw new ClassCastException();\n+    }\n+\n+    return reg.registerServiceProvider(provider);\n+  }\n+\n+  /**\n+   * Adds a service provider object to the registry.  The provider\n+   * is associated within each category present in the registry\n+   * whose <code>Class</code> it implements.\n+   *\n+   * <p> If <code>provider</code> implements the\n+   * <code>RegisterableService</code> interface, its\n+   * <code>onRegistration</code> method will be called once for each\n+   * category it is registered under.  Its\n+   * <code>onDeregistration</code> method will be called each time\n+   * it is deregistered from a category or when the registry is\n+   * finalized.\n+   *\n+   * @param provider the service provider object to be registered.\n+   * @throws IllegalArgumentException if\n+   *                                  <code>provider</code> is <code>null</code>.\n+   */\n+  public void registerServiceProvider(Object provider) {\n+    if (provider == null) {\n+      throw new IllegalArgumentException(\"provider == null!\");\n+    }\n+    Iterator<SubRegistry> regs = getSubRegistries(provider);\n+    while (regs.hasNext()) {\n+      SubRegistry reg = regs.next();\n+      reg.registerServiceProvider(provider);\n+    }\n+  }\n+\n+  /**\n+   * Adds a set of service provider objects, taken from an\n+   * <code>Iterator</code> to the registry.  Each provider is\n+   * associated within each category present in the registry whose\n+   * <code>Class</code> it implements.\n+   *\n+   * <p> For each entry of <code>providers</code> that implements\n+   * the <code>RegisterableService</code> interface, its\n+   * <code>onRegistration</code> method will be called once for each\n+   * category it is registered under.  Its\n+   * <code>onDeregistration</code> method will be called each time\n+   * it is deregistered from a category or when the registry is\n+   * finalized.\n+   *\n+   * @param providers an Iterator containing service provider\n+   *                  objects to be registered.\n+   * @throws IllegalArgumentException if <code>providers</code>\n+   *                                  is <code>null</code> or contains a <code>null</code> entry.\n+   */\n+  public void registerServiceProviders(Iterator<?> providers) {\n+    if (providers == null) {\n+      throw new IllegalArgumentException(\"provider == null!\");\n+    }\n+    while (providers.hasNext()) {\n+      registerServiceProvider(providers.next());\n+    }\n+  }\n+\n+  /**\n+   * Removes a service provider object from the given category.  If\n+   * the provider was not previously registered, nothing happens and\n+   * <code>false</code> is returned.  Otherwise, <code>true</code>\n+   * is returned.  If an object of the same class as\n+   * <code>provider</code> but not equal (using <code>==</code>) to\n+   * <code>provider</code> is registered, it will not be\n+   * deregistered.\n+   *\n+   * <p> If <code>provider</code> implements the\n+   * <code>RegisterableService</code> interface, its\n+   * <code>onDeregistration</code> method will be called.\n+   *\n+   * @param provider the service provider object to be deregistered.\n+   * @param category the category from which to deregister the\n+   *                 provider.\n+   * @return <code>true</code> if the provider was previously\n+   * registered in the same category category,\n+   * <code>false</code> otherwise.\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   *                                  <code>null</code>.\n+   * @throws IllegalArgumentException if there is no category\n+   *                                  corresponding to <code>category</code>.\n+   * @throws ClassCastException       if provider does not implement\n+   *                                  the class defined by <code>category</code>.\n+   */\n+  public <T> boolean deregisterServiceProvider(T provider,\n                                                Class<T> category) {\n-        if (provider == null) {\n-            throw new IllegalArgumentException(\"provider == null!\");\n-        }\n-        SubRegistry reg = categoryMap.get(category);\n-        if (reg == null) {\n-            throw new IllegalArgumentException(\"category unknown!\");\n-        }\n-        if (!category.isAssignableFrom(provider.getClass())) {\n-            throw new ClassCastException();\n-        }\n-\n-        return reg.registerServiceProvider(provider);\n-    }\n-\n-    /**\n-     * Adds a service provider object to the registry.  The provider\n-     * is associated within each category present in the registry\n-     * whose <code>Class</code> it implements.\n-     *\n-     * <p> If <code>provider</code> implements the\n-     * <code>RegisterableService</code> interface, its\n-     * <code>onRegistration</code> method will be called once for each\n-     * category it is registered under.  Its\n-     * <code>onDeregistration</code> method will be called each time\n-     * it is deregistered from a category or when the registry is\n-     * finalized.\n-     *\n-     * @param provider the service provider object to be registered.\n-     *\n-     * @exception IllegalArgumentException if\n-     * <code>provider</code> is <code>null</code>.\n-     */\n-    public void registerServiceProvider(Object provider) {\n-        if (provider == null) {\n-            throw new IllegalArgumentException(\"provider == null!\");\n-        }\n-        Iterator<SubRegistry> regs = getSubRegistries(provider);\n-        while (regs.hasNext()) {\n-            SubRegistry reg = regs.next();\n-            reg.registerServiceProvider(provider);\n-        }\n-    }\n-\n-    /**\n-     * Adds a set of service provider objects, taken from an\n-     * <code>Iterator</code> to the registry.  Each provider is\n-     * associated within each category present in the registry whose\n-     * <code>Class</code> it implements.\n-     *\n-     * <p> For each entry of <code>providers</code> that implements\n-     * the <code>RegisterableService</code> interface, its\n-     * <code>onRegistration</code> method will be called once for each\n-     * category it is registered under.  Its\n-     * <code>onDeregistration</code> method will be called each time\n-     * it is deregistered from a category or when the registry is\n-     * finalized.\n-     *\n-     * @param providers an Iterator containing service provider\n-     * objects to be registered.\n-     *\n-     * @exception IllegalArgumentException if <code>providers</code>\n-     * is <code>null</code> or contains a <code>null</code> entry.\n-     */\n-    public void registerServiceProviders(Iterator<?> providers) {\n-        if (providers == null) {\n-            throw new IllegalArgumentException(\"provider == null!\");\n-        }\n-        while (providers.hasNext()) {\n-            registerServiceProvider(providers.next());\n-        }\n-    }\n-\n-    /**\n-     * Removes a service provider object from the given category.  If\n-     * the provider was not previously registered, nothing happens and\n-     * <code>false</code> is returned.  Otherwise, <code>true</code>\n-     * is returned.  If an object of the same class as\n-     * <code>provider</code> but not equal (using <code>==</code>) to\n-     * <code>provider</code> is registered, it will not be\n-     * deregistered.\n-     *\n-     * <p> If <code>provider</code> implements the\n-     * <code>RegisterableService</code> interface, its\n-     * <code>onDeregistration</code> method will be called.\n-     *\n-     * @param provider the service provider object to be deregistered.\n-     * @param category the category from which to deregister the\n-     * provider.\n-     *\n-     * @return <code>true</code> if the provider was previously\n-     * registered in the same category category,\n-     * <code>false</code> otherwise.\n-     *\n-     * @exception IllegalArgumentException if <code>provider</code> is\n-     * <code>null</code>.\n-     * @exception IllegalArgumentException if there is no category\n-     * corresponding to <code>category</code>.\n-     * @exception ClassCastException if provider does not implement\n-     * the class defined by <code>category</code>.\n-     */\n-    public <T> boolean deregisterServiceProvider(T provider,\n-                                                 Class<T> category) {\n-        if (provider == null) {\n-            throw new IllegalArgumentException(\"provider == null!\");\n-        }\n-        SubRegistry reg = categoryMap.get(category);\n-        if (reg == null) {\n-            throw new IllegalArgumentException(\"category unknown!\");\n-        }\n-        if (!category.isAssignableFrom(provider.getClass())) {\n-            throw new ClassCastException();\n-        }\n-        return reg.deregisterServiceProvider(provider);\n-    }\n-\n-    /**\n-     * Removes a service provider object from all categories that\n-     * contain it.\n-     *\n-     * @param provider the service provider object to be deregistered.\n-     *\n-     * @exception IllegalArgumentException if <code>provider</code> is\n-     * <code>null</code>.\n-     */\n-    public void deregisterServiceProvider(Object provider) {\n-        if (provider == null) {\n-            throw new IllegalArgumentException(\"provider == null!\");\n-        }\n-        Iterator<SubRegistry> regs = getSubRegistries(provider);\n-        while (regs.hasNext()) {\n-            SubRegistry reg = regs.next();\n-            reg.deregisterServiceProvider(provider);\n-        }\n-    }\n-\n-    /**\n-     * Returns <code>true</code> if <code>provider</code> is currently\n-     * registered.\n-     *\n-     * @param provider the service provider object to be queried.\n-     *\n-     * @return <code>true</code> if the given provider has been\n-     * registered.\n-     *\n-     * @exception IllegalArgumentException if <code>provider</code> is\n-     * <code>null</code>.\n-     */\n-    public boolean contains(Object provider) {\n-        if (provider == null) {\n-            throw new IllegalArgumentException(\"provider == null!\");\n-        }\n-        Iterator<SubRegistry> regs = getSubRegistries(provider);\n-        while (regs.hasNext()) {\n-            SubRegistry reg = regs.next();\n-            if (reg.contains(provider)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    /**\n-     * Returns an <code>Iterator</code> containing all registered\n-     * service providers in the given category.  If\n-     * <code>useOrdering</code> is <code>false</code>, the iterator\n-     * will return all of the server provider objects in an arbitrary\n-     * order.  Otherwise, the ordering will respect any pairwise\n-     * orderings that have been set.  If the graph of pairwise\n-     * orderings contains cycles, any providers that belong to a cycle\n-     * will not be returned.\n-     *\n-     * @param category the category to be retrieved from.\n-     * @param useOrdering <code>true</code> if pairwise orderings\n-     * should be taken account in ordering the returned objects.\n-     *\n-     * @return an <code>Iterator</code> containing service provider\n-     * objects from the given category, possibly in order.\n-     *\n-     * @exception IllegalArgumentException if there is no category\n-     * corresponding to <code>category</code>.\n-     */\n-    public <T> Iterator<T> getServiceProviders(Class<T> category,\n-                                               boolean useOrdering) {\n-        SubRegistry reg = categoryMap.get(category);\n-        if (reg == null) {\n-            throw new IllegalArgumentException(\"category unknown!\");\n-        }\n-        return reg.getServiceProviders(useOrdering);\n-    }\n-\n-    /**\n-     * A simple filter interface used by\n-     * <code>ServiceRegistry.getServiceProviders</code> to select\n-     * providers matching an arbitrary criterion.  Classes that\n-     * implement this interface should be defined in order to make use\n-     * of the <code>getServiceProviders</code> method of\n-     * <code>ServiceRegistry</code> that takes a <code>Filter</code>.\n-     *\n-     * @see ServiceRegistry#getServiceProviders(Class, ServiceRegistry.Filter, boolean)\n-     */\n-    public interface Filter {\n-\n-        /**\n-         * Returns <code>true</code> if the given\n-         * <code>provider</code> object matches the criterion defined\n-         * by this <code>Filter</code>.\n-         *\n-         * @param provider a service provider <code>Object</code>.\n-         *\n-         * @return true if the provider matches the criterion.\n-         */\n-        boolean filter(Object provider);\n-    }\n-\n-    /**\n-     * Returns an <code>Iterator</code> containing service provider\n-     * objects within a given category that satisfy a criterion\n-     * imposed by the supplied <code>ServiceRegistry.Filter</code>\n-     * object's <code>filter</code> method.\n-     *\n-     * <p> The <code>useOrdering</code> argument controls the\n-     * ordering of the results using the same rules as\n-     * <code>getServiceProviders(Class, boolean)</code>.\n-     *\n-     * @param category the category to be retrieved from.\n-     * @param filter an instance of <code>ServiceRegistry.Filter</code>\n-     * whose <code>filter</code> method will be invoked.\n-     * @param useOrdering <code>true</code> if pairwise orderings\n-     * should be taken account in ordering the returned objects.\n-     *\n-     * @return an <code>Iterator</code> containing service provider\n-     * objects from the given category, possibly in order.\n-     *\n-     * @exception IllegalArgumentException if there is no category\n-     * corresponding to <code>category</code>.\n-     */\n-    public <T> Iterator<T> getServiceProviders(Class<T> category,\n-                                               Filter filter,\n-                                               boolean useOrdering) {\n-        SubRegistry reg = categoryMap.get(category);\n-        if (reg == null) {\n-            throw new IllegalArgumentException(\"category unknown!\");\n-        }\n-        Iterator iter = getServiceProviders(category, useOrdering);\n-        return new FilterIterator(iter, filter);\n-    }\n+    if (provider == null) {\n+      throw new IllegalArgumentException(\"provider == null!\");\n+    }\n+    SubRegistry reg = categoryMap.get(category);\n+    if (reg == null) {\n+      throw new IllegalArgumentException(\"category unknown!\");\n+    }\n+    if (!category.isAssignableFrom(provider.getClass())) {\n+      throw new ClassCastException();\n+    }\n+    return reg.deregisterServiceProvider(provider);\n+  }\n+\n+  /**\n+   * Removes a service provider object from all categories that\n+   * contain it.\n+   *\n+   * @param provider the service provider object to be deregistered.\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   *                                  <code>null</code>.\n+   */\n+  public void deregisterServiceProvider(Object provider) {\n+    if (provider == null) {\n+      throw new IllegalArgumentException(\"provider == null!\");\n+    }\n+    Iterator<SubRegistry> regs = getSubRegistries(provider);\n+    while (regs.hasNext()) {\n+      SubRegistry reg = regs.next();\n+      reg.deregisterServiceProvider(provider);\n+    }\n+  }\n+\n+  /**\n+   * Returns <code>true</code> if <code>provider</code> is currently\n+   * registered.\n+   *\n+   * @param provider the service provider object to be queried.\n+   * @return <code>true</code> if the given provider has been\n+   * registered.\n+   * @throws IllegalArgumentException if <code>provider</code> is\n+   *                                  <code>null</code>.\n+   */\n+  public boolean contains(Object provider) {\n+    if (provider == null) {\n+      throw new IllegalArgumentException(\"provider == null!\");\n+    }\n+    Iterator<SubRegistry> regs = getSubRegistries(provider);\n+    while (regs.hasNext()) {\n+      SubRegistry reg = regs.next();\n+      if (reg.contains(provider)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Returns an <code>Iterator</code> containing all registered\n+   * service providers in the given category.  If\n+   * <code>useOrdering</code> is <code>false</code>, the iterator\n+   * will return all of the server provider objects in an arbitrary\n+   * order.  Otherwise, the ordering will respect any pairwise\n+   * orderings that have been set.  If the graph of pairwise\n+   * orderings contains cycles, any providers that belong to a cycle\n+   * will not be returned.\n+   *\n+   * @param category    the category to be retrieved from.\n+   * @param useOrdering <code>true</code> if pairwise orderings\n+   *                    should be taken account in ordering the returned objects.\n+   * @return an <code>Iterator</code> containing service provider\n+   * objects from the given category, possibly in order.\n+   * @throws IllegalArgumentException if there is no category\n+   *                                  corresponding to <code>category</code>.\n+   */\n+  public <T> Iterator<T> getServiceProviders(Class<T> category,\n+                                             boolean useOrdering) {\n+    SubRegistry reg = categoryMap.get(category);\n+    if (reg == null) {\n+      throw new IllegalArgumentException(\"category unknown!\");\n+    }\n+    return reg.getServiceProviders(useOrdering);\n+  }\n+\n+  /**\n+   * A simple filter interface used by\n+   * <code>ServiceRegistry.getServiceProviders</code> to select\n+   * providers matching an arbitrary criterion.  Classes that\n+   * implement this interface should be defined in order to make use\n+   * of the <code>getServiceProviders</code> method of\n+   * <code>ServiceRegistry</code> that takes a <code>Filter</code>.\n+   *\n+   * @see ServiceRegistry#getServiceProviders(Class, ServiceRegistry.Filter, boolean)\n+   */\n+  public interface Filter {\n \n     /**\n-     * Returns the currently registered service provider object that\n-     * is of the given class type.  At most one object of a given\n-     * class is allowed to be registered at any given time.  If no\n-     * registered object has the desired class type, <code>null</code>\n-     * is returned.\n-     *\n-     * @param providerClass the <code>Class</code> of the desired\n-     * service provider object.\n-     *\n-     * @return a currently registered service provider object with the\n-     * desired <code>Class</code>type, or <code>null</code> is none is\n-     * present.\n-     *\n-     * @exception IllegalArgumentException if <code>providerClass</code> is\n-     * <code>null</code>.\n-     */\n-    public <T> T getServiceProviderByClass(Class<T> providerClass) {\n-        if (providerClass == null) {\n-            throw new IllegalArgumentException(\"providerClass == null!\");\n-        }\n-        for (Class c : categoryMap.keySet()) {\n-            if (c.isAssignableFrom(providerClass)) {\n-                SubRegistry reg = (SubRegistry)categoryMap.get(c);\n-                T provider = reg.getServiceProviderByClass(providerClass);\n-                if (provider != null) {\n-                    return provider;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Sets a pairwise ordering between two service provider objects\n-     * within a given category.  If one or both objects are not\n-     * currently registered within the given category, or if the\n-     * desired ordering is already set, nothing happens and\n-     * <code>false</code> is returned.  If the providers previously\n-     * were ordered in the reverse direction, that ordering is\n-     * removed.\n-     *\n-     * <p> The ordering will be used by the\n-     * <code>getServiceProviders</code> methods when their\n-     * <code>useOrdering</code> argument is <code>true</code>.\n-     *\n-     * @param category a <code>Class</code> object indicating the\n-     * category under which the preference is to be established.\n-     * @param firstProvider the preferred provider.\n-     * @param secondProvider the provider to which\n-     * <code>firstProvider</code> is preferred.\n-     *\n-     * @return <code>true</code> if a previously unset ordering\n-     * was established.\n+     * Returns <code>true</code> if the given\n+     * <code>provider</code> object matches the criterion defined\n+     * by this <code>Filter</code>.\n      *\n-     * @exception IllegalArgumentException if either provider is\n-     * <code>null</code> or they are the same object.\n-     * @exception IllegalArgumentException if there is no category\n-     * corresponding to <code>category</code>.\n+     * @param provider a service provider <code>Object</code>.\n+     * @return true if the provider matches the criterion.\n      */\n-    public <T> boolean setOrdering(Class<T> category,\n+    boolean filter(Object provider);\n+  }\n+\n+  /**\n+   * Returns an <code>Iterator</code> containing service provider\n+   * objects within a given category that satisfy a criterion\n+   * imposed by the supplied <code>ServiceRegistry.Filter</code>\n+   * object's <code>filter</code> method.\n+   *\n+   * <p> The <code>useOrdering</code> argument controls the\n+   * ordering of the results using the same rules as\n+   * <code>getServiceProviders(Class, boolean)</code>.\n+   *\n+   * @param category    the category to be retrieved from.\n+   * @param filter      an instance of <code>ServiceRegistry.Filter</code>\n+   *                    whose <code>filter</code> method will be invoked.\n+   * @param useOrdering <code>true</code> if pairwise orderings\n+   *                    should be taken account in ordering the returned objects.\n+   * @return an <code>Iterator</code> containing service provider\n+   * objects from the given category, possibly in order.\n+   * @throws IllegalArgumentException if there is no category\n+   *                                  corresponding to <code>category</code>.\n+   */\n+  public <T> Iterator<T> getServiceProviders(Class<T> category,\n+                                             Filter filter,\n+                                             boolean useOrdering) {\n+    SubRegistry reg = categoryMap.get(category);\n+    if (reg == null) {\n+      throw new IllegalArgumentException(\"category unknown!\");\n+    }\n+    Iterator iter = getServiceProviders(category, useOrdering);\n+    return new FilterIterator(iter, filter);\n+  }\n+\n+  /**\n+   * Returns the currently registered service provider object that\n+   * is of the given class type.  At most one object of a given\n+   * class is allowed to be registered at any given time.  If no\n+   * registered object has the desired class type, <code>null</code>\n+   * is returned.\n+   *\n+   * @param providerClass the <code>Class</code> of the desired\n+   *                      service provider object.\n+   * @return a currently registered service provider object with the\n+   * desired <code>Class</code>type, or <code>null</code> is none is\n+   * present.\n+   * @throws IllegalArgumentException if <code>providerClass</code> is\n+   *                                  <code>null</code>.\n+   */\n+  public <T> T getServiceProviderByClass(Class<T> providerClass) {\n+    if (providerClass == null) {\n+      throw new IllegalArgumentException(\"providerClass == null!\");\n+    }\n+    for (Class c : categoryMap.keySet()) {\n+      if (c.isAssignableFrom(providerClass)) {\n+        SubRegistry reg = (SubRegistry) categoryMap.get(c);\n+        T provider = reg.getServiceProviderByClass(providerClass);\n+        if (provider != null) {\n+          return provider;\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Sets a pairwise ordering between two service provider objects\n+   * within a given category.  If one or both objects are not\n+   * currently registered within the given category, or if the\n+   * desired ordering is already set, nothing happens and\n+   * <code>false</code> is returned.  If the providers previously\n+   * were ordered in the reverse direction, that ordering is\n+   * removed.\n+   *\n+   * <p> The ordering will be used by the\n+   * <code>getServiceProviders</code> methods when their\n+   * <code>useOrdering</code> argument is <code>true</code>.\n+   *\n+   * @param category       a <code>Class</code> object indicating the\n+   *                       category under which the preference is to be established.\n+   * @param firstProvider  the preferred provider.\n+   * @param secondProvider the provider to which\n+   *                       <code>firstProvider</code> is preferred.\n+   * @return <code>true</code> if a previously unset ordering\n+   * was established.\n+   * @throws IllegalArgumentException if either provider is\n+   *                                  <code>null</code> or they are the same object.\n+   * @throws IllegalArgumentException if there is no category\n+   *                                  corresponding to <code>category</code>.\n+   */\n+  public <T> boolean setOrdering(Class<T> category,\n+                                 T firstProvider,\n+                                 T secondProvider) {\n+    if (firstProvider == null || secondProvider == null) {\n+      throw new IllegalArgumentException(\"provider is null!\");\n+    }\n+    if (firstProvider == secondProvider) {\n+      throw new IllegalArgumentException(\"providers are the same!\");\n+    }\n+    SubRegistry reg = (SubRegistry) categoryMap.get(category);\n+    if (reg == null) {\n+      throw new IllegalArgumentException(\"category unknown!\");\n+    }\n+    if (reg.contains(firstProvider) &&\n+      reg.contains(secondProvider)) {\n+      return reg.setOrdering(firstProvider, secondProvider);\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Sets a pairwise ordering between two service provider objects\n+   * within a given category.  If one or both objects are not\n+   * currently registered within the given category, or if no\n+   * ordering is currently set between them, nothing happens\n+   * and <code>false</code> is returned.\n+   *\n+   * <p> The ordering will be used by the\n+   * <code>getServiceProviders</code> methods when their\n+   * <code>useOrdering</code> argument is <code>true</code>.\n+   *\n+   * @param category       a <code>Class</code> object indicating the\n+   *                       category under which the preference is to be disestablished.\n+   * @param firstProvider  the formerly preferred provider.\n+   * @param secondProvider the provider to which\n+   *                       <code>firstProvider</code> was formerly preferred.\n+   * @return <code>true</code> if a previously set ordering was\n+   * disestablished.\n+   * @throws IllegalArgumentException if either provider is\n+   *                                  <code>null</code> or they are the same object.\n+   * @throws IllegalArgumentException if there is no category\n+   *                                  corresponding to <code>category</code>.\n+   */\n+  public <T> boolean unsetOrdering(Class<T> category,\n                                    T firstProvider,\n                                    T secondProvider) {\n-        if (firstProvider == null || secondProvider == null) {\n-            throw new IllegalArgumentException(\"provider is null!\");\n-        }\n-        if (firstProvider == secondProvider) {\n-            throw new IllegalArgumentException(\"providers are the same!\");\n-        }\n-        SubRegistry reg = (SubRegistry)categoryMap.get(category);\n-        if (reg == null) {\n-            throw new IllegalArgumentException(\"category unknown!\");\n-        }\n-        if (reg.contains(firstProvider) &&\n-            reg.contains(secondProvider)) {\n-            return reg.setOrdering(firstProvider, secondProvider);\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Sets a pairwise ordering between two service provider objects\n-     * within a given category.  If one or both objects are not\n-     * currently registered within the given category, or if no\n-     * ordering is currently set between them, nothing happens\n-     * and <code>false</code> is returned.\n-     *\n-     * <p> The ordering will be used by the\n-     * <code>getServiceProviders</code> methods when their\n-     * <code>useOrdering</code> argument is <code>true</code>.\n-     *\n-     * @param category a <code>Class</code> object indicating the\n-     * category under which the preference is to be disestablished.\n-     * @param firstProvider the formerly preferred provider.\n-     * @param secondProvider the provider to which\n-     * <code>firstProvider</code> was formerly preferred.\n-     *\n-     * @return <code>true</code> if a previously set ordering was\n-     * disestablished.\n-     *\n-     * @exception IllegalArgumentException if either provider is\n-     * <code>null</code> or they are the same object.\n-     * @exception IllegalArgumentException if there is no category\n-     * corresponding to <code>category</code>.\n-     */\n-    public <T> boolean unsetOrdering(Class<T> category,\n-                                     T firstProvider,\n-                                     T secondProvider) {\n-        if (firstProvider == null || secondProvider == null) {\n-            throw new IllegalArgumentException(\"provider is null!\");\n-        }\n-        if (firstProvider == secondProvider) {\n-            throw new IllegalArgumentException(\"providers are the same!\");\n-        }\n-        SubRegistry reg = (SubRegistry)categoryMap.get(category);\n-        if (reg == null) {\n-            throw new IllegalArgumentException(\"category unknown!\");\n-        }\n-        if (reg.contains(firstProvider) &&\n-            reg.contains(secondProvider)) {\n-            return reg.unsetOrdering(firstProvider, secondProvider);\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Deregisters all service provider object currently registered\n-     * under the given category.\n-     *\n-     * @param category the category to be emptied.\n-     *\n-     * @exception IllegalArgumentException if there is no category\n-     * corresponding to <code>category</code>.\n-     */\n-    public void deregisterAll(Class<?> category) {\n-        SubRegistry reg = (SubRegistry)categoryMap.get(category);\n-        if (reg == null) {\n-            throw new IllegalArgumentException(\"category unknown!\");\n-        }\n-        reg.clear();\n-    }\n-\n-    /**\n-     * Deregisters all currently registered service providers from all\n-     * categories.\n-     */\n-    public void deregisterAll() {\n-        Iterator iter = categoryMap.values().iterator();\n-        while (iter.hasNext()) {\n-            SubRegistry reg = (SubRegistry)iter.next();\n-            reg.clear();\n-        }\n-    }\n-\n-    /**\n-     * Finalizes this object prior to garbage collection.  The\n-     * <code>deregisterAll</code> method is called to deregister all\n-     * currently registered service providers.  This method should not\n-     * be called from application code.\n-     *\n-     * @exception Throwable if an error occurs during superclass\n-     * finalization.\n-     */\n-    public void finalize() throws Throwable {\n-        deregisterAll();\n-        super.finalize();\n-    }\n+    if (firstProvider == null || secondProvider == null) {\n+      throw new IllegalArgumentException(\"provider is null!\");\n+    }\n+    if (firstProvider == secondProvider) {\n+      throw new IllegalArgumentException(\"providers are the same!\");\n+    }\n+    SubRegistry reg = (SubRegistry) categoryMap.get(category);\n+    if (reg == null) {\n+      throw new IllegalArgumentException(\"category unknown!\");\n+    }\n+    if (reg.contains(firstProvider) &&\n+      reg.contains(secondProvider)) {\n+      return reg.unsetOrdering(firstProvider, secondProvider);\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Deregisters all service provider object currently registered\n+   * under the given category.\n+   *\n+   * @param category the category to be emptied.\n+   * @throws IllegalArgumentException if there is no category\n+   *                                  corresponding to <code>category</code>.\n+   */\n+  public void deregisterAll(Class<?> category) {\n+    SubRegistry reg = (SubRegistry) categoryMap.get(category);\n+    if (reg == null) {\n+      throw new IllegalArgumentException(\"category unknown!\");\n+    }\n+    reg.clear();\n+  }\n+\n+  /**\n+   * Deregisters all currently registered service providers from all\n+   * categories.\n+   */\n+  public void deregisterAll() {\n+    Iterator iter = categoryMap.values().iterator();\n+    while (iter.hasNext()) {\n+      SubRegistry reg = (SubRegistry) iter.next();\n+      reg.clear();\n+    }\n+  }\n+\n+  /**\n+   * Finalizes this object prior to garbage collection.  The\n+   * <code>deregisterAll</code> method is called to deregister all\n+   * currently registered service providers.  This method should not\n+   * be called from application code.\n+   *\n+   * @throws Throwable if an error occurs during superclass\n+   *                   finalization.\n+   */\n+  public void finalize() throws Throwable {\n+    deregisterAll();\n+    super.finalize();\n+  }\n }\n \n \n@@ -712,103 +683,103 @@ public class ServiceRegistry {\n  */\n class SubRegistry {\n \n-    ServiceRegistry registry;\n+  ServiceRegistry registry;\n \n-    Class<?> category;\n+  Class<?> category;\n \n-    // Provider Objects organized by partial oridering\n-    PartiallyOrderedSet poset = new PartiallyOrderedSet();\n+  // Provider Objects organized by partial oridering\n+  PartiallyOrderedSet poset = new PartiallyOrderedSet();\n \n-    // Class -> Provider Object of that class\n-    Map<Class<?>,Object> map = new HashMap<>();\n+  // Class -> Provider Object of that class\n+  Map<Class<?>, Object> map = new HashMap<>();\n \n-    public SubRegistry(ServiceRegistry registry, Class<?> category) {\n-        this.registry = registry;\n-        this.category = category;\n-    }\n+  public SubRegistry(ServiceRegistry registry, Class<?> category) {\n+    this.registry = registry;\n+    this.category = category;\n+  }\n \n-    public boolean registerServiceProvider(Object provider) {\n-        Object oprovider = map.get(provider.getClass());\n-        boolean present =  oprovider != null;\n+  public boolean registerServiceProvider(Object provider) {\n+    Object oprovider = map.get(provider.getClass());\n+    boolean present = oprovider != null;\n \n-        if (present) {\n-            deregisterServiceProvider(oprovider);\n-        }\n-        map.put(provider.getClass(), provider);\n-        poset.add(provider);\n-        if (provider instanceof RegisterableService) {\n-            RegisterableService rs = (RegisterableService)provider;\n-            rs.onRegistration(registry, category);\n-        }\n-\n-        return !present;\n-    }\n-\n-    /**\n-     * If the provider was not previously registered, do nothing.\n-     *\n-     * @return true if the provider was previously registered.\n-     */\n-    public boolean deregisterServiceProvider(Object provider) {\n-        Object oprovider = map.get(provider.getClass());\n-\n-        if (provider == oprovider) {\n-            map.remove(provider.getClass());\n-            poset.remove(provider);\n-            if (provider instanceof RegisterableService) {\n-                RegisterableService rs = (RegisterableService)provider;\n-                rs.onDeregistration(registry, category);\n-            }\n-\n-            return true;\n-        }\n-        return false;\n+    if (present) {\n+      deregisterServiceProvider(oprovider);\n     }\n-\n-    public boolean contains(Object provider) {\n-        Object oprovider = map.get(provider.getClass());\n-        return oprovider == provider;\n+    map.put(provider.getClass(), provider);\n+    poset.add(provider);\n+    if (provider instanceof RegisterableService) {\n+      RegisterableService rs = (RegisterableService) provider;\n+      rs.onRegistration(registry, category);\n     }\n \n-    public boolean setOrdering(Object firstProvider,\n-                               Object secondProvider) {\n-        return poset.setOrdering(firstProvider, secondProvider);\n-    }\n+    return !present;\n+  }\n \n-    public boolean unsetOrdering(Object firstProvider,\n-                                 Object secondProvider) {\n-        return poset.unsetOrdering(firstProvider, secondProvider);\n-    }\n+  /**\n+   * If the provider was not previously registered, do nothing.\n+   *\n+   * @return true if the provider was previously registered.\n+   */\n+  public boolean deregisterServiceProvider(Object provider) {\n+    Object oprovider = map.get(provider.getClass());\n \n-    public Iterator getServiceProviders(boolean useOrdering) {\n-        if (useOrdering) {\n-            return poset.iterator();\n-        } else {\n-            return map.values().iterator();\n-        }\n-    }\n+    if (provider == oprovider) {\n+      map.remove(provider.getClass());\n+      poset.remove(provider);\n+      if (provider instanceof RegisterableService) {\n+        RegisterableService rs = (RegisterableService) provider;\n+        rs.onDeregistration(registry, category);\n+      }\n \n-    public <T> T getServiceProviderByClass(Class<T> providerClass) {\n-        return (T)map.get(providerClass);\n+      return true;\n     }\n+    return false;\n+  }\n \n-    public void clear() {\n-        Iterator iter = map.values().iterator();\n-        while (iter.hasNext()) {\n-            Object provider = iter.next();\n-            iter.remove();\n+  public boolean contains(Object provider) {\n+    Object oprovider = map.get(provider.getClass());\n+    return oprovider == provider;\n+  }\n \n-            if (provider instanceof RegisterableService) {\n-                RegisterableService rs = (RegisterableService)provider;\n-                rs.onDeregistration(registry, category);\n-            }\n-        }\n-        poset.clear();\n-    }\n+  public boolean setOrdering(Object firstProvider,\n+                             Object secondProvider) {\n+    return poset.setOrdering(firstProvider, secondProvider);\n+  }\n \n-    public void finalize() {\n-        clear();\n-    }\n+  public boolean unsetOrdering(Object firstProvider,\n+                               Object secondProvider) {\n+    return poset.unsetOrdering(firstProvider, secondProvider);\n+  }\n+\n+  public Iterator getServiceProviders(boolean useOrdering) {\n+    if (useOrdering) {\n+      return poset.iterator();\n+    } else {\n+      return map.values().iterator();\n+    }\n+  }\n+\n+  public <T> T getServiceProviderByClass(Class<T> providerClass) {\n+    return (T) map.get(providerClass);\n+  }\n+\n+  public void clear() {\n+    Iterator iter = map.values().iterator();\n+    while (iter.hasNext()) {\n+      Object provider = iter.next();\n+      iter.remove();\n+\n+      if (provider instanceof RegisterableService) {\n+        RegisterableService rs = (RegisterableService) provider;\n+        rs.onDeregistration(registry, category);\n+      }\n+    }\n+    poset.clear();\n+  }\n+\n+  public void finalize() {\n+    clear();\n+  }\n }\n \n \n@@ -818,44 +789,44 @@ class SubRegistry {\n  */\n class FilterIterator<T> implements Iterator<T> {\n \n-    private Iterator<T> iter;\n-    private ServiceRegistry.Filter filter;\n-\n-    private T next = null;\n+  private Iterator<T> iter;\n+  private ServiceRegistry.Filter filter;\n \n-    public FilterIterator(Iterator<T> iter,\n-                          ServiceRegistry.Filter filter) {\n-        this.iter = iter;\n-        this.filter = filter;\n-        advance();\n-    }\n+  private T next = null;\n \n-    private void advance() {\n-        while (iter.hasNext()) {\n-            T elt = iter.next();\n-            if (filter.filter(elt)) {\n-                next = elt;\n-                return;\n-            }\n-        }\n+  public FilterIterator(Iterator<T> iter,\n+                        ServiceRegistry.Filter filter) {\n+    this.iter = iter;\n+    this.filter = filter;\n+    advance();\n+  }\n \n-        next = null;\n+  private void advance() {\n+    while (iter.hasNext()) {\n+      T elt = iter.next();\n+      if (filter.filter(elt)) {\n+        next = elt;\n+        return;\n+      }\n     }\n \n-    public boolean hasNext() {\n-        return next != null;\n-    }\n+    next = null;\n+  }\n \n-    public T next() {\n-        if (next == null) {\n-            throw new NoSuchElementException();\n-        }\n-        T o = next;\n-        advance();\n-        return o;\n-    }\n+  public boolean hasNext() {\n+    return next != null;\n+  }\n \n-    public void remove() {\n-        throw new UnsupportedOperationException();\n+  public T next() {\n+    if (next == null) {\n+      throw new NoSuchElementException();\n     }\n+    T o = next;\n+    advance();\n+    return o;\n+  }\n+\n+  public void remove() {\n+    throw new UnsupportedOperationException();\n+  }\n }\n",
            "diff_size": 961
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/105/ServiceRegistry.java\nindex 1794adb5de2..86d0f2c169f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/105/ServiceRegistry.java\n@@ -124,9 +124,12 @@ import java.util.ServiceLoader;\n  * @see RegisterableService\n  *\n  */\n+\n+\n public class ServiceRegistry {\n \n     // Class -> Registry\n+\n     private Map<Class<?>, SubRegistry> categoryMap = new HashMap<>();\n \n     /**\n@@ -140,10 +143,12 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if\n      * <code>categories</code> is <code>null</code>.\n      */\n+\n     public ServiceRegistry(Iterator<Class<?>> categories) {\n         if (categories == null) {\n             throw new IllegalArgumentException(\"categories == null!\");\n         }\n+\n         while (categories.hasNext()) {\n             Class<?> category = categories.next();\n             SubRegistry reg = new SubRegistry(this, category);\n@@ -194,9 +199,8 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if\n      * <code>providerClass</code> is <code>null</code>.\n      */\n-    public static <T> Iterator<T> lookupProviders(Class<T> providerClass,\n-                                                  ClassLoader loader)\n-    {\n+\n+    public static <T> Iterator<T> lookupProviders(Class<T> providerClass, ClassLoader loader) {\n         if (providerClass == null) {\n             throw new IllegalArgumentException(\"providerClass == null!\");\n         }\n@@ -225,6 +229,7 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if\n      * <code>providerClass</code> is <code>null</code>.\n      */\n+\n     public static <T> Iterator<T> lookupProviders(Class<T> providerClass) {\n         if (providerClass == null) {\n             throw new IllegalArgumentException(\"providerClass == null!\");\n@@ -240,6 +245,7 @@ public class ServiceRegistry {\n      * @return an <code>Iterator</code> containing\n      * <code>Class</code>objects.\n      */\n+\n     public Iterator<Class<?>> getCategories() {\n         Set<Class<?>> keySet = categoryMap.keySet();\n         return keySet.iterator();\n@@ -249,6 +255,7 @@ public class ServiceRegistry {\n      * Returns an Iterator containing the subregistries to which the\n      * provider belongs.\n      */\n+\n     private Iterator<SubRegistry> getSubRegistries(Object provider) {\n         List<SubRegistry> l = new ArrayList<>();\n         Iterator<Class<?>> iter = categoryMap.keySet().iterator();\n@@ -286,19 +293,20 @@ public class ServiceRegistry {\n      * @exception ClassCastException if provider does not implement\n      * the <code>Class</code> defined by <code>category</code>.\n      */\n-    public <T> boolean registerServiceProvider(T provider,\n-                                               Class<T> category) {\n+\n+    public <T> boolean registerServiceProvider(T provider, Class<T> category) {\n         if (provider == null) {\n             throw new IllegalArgumentException(\"provider == null!\");\n         }\n+\n         SubRegistry reg = categoryMap.get(category);\n         if (reg == null) {\n             throw new IllegalArgumentException(\"category unknown!\");\n         }\n+\n         if (!category.isAssignableFrom(provider.getClass())) {\n             throw new ClassCastException();\n         }\n-\n         return reg.registerServiceProvider(provider);\n     }\n \n@@ -320,10 +328,12 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if\n      * <code>provider</code> is <code>null</code>.\n      */\n+\n     public void registerServiceProvider(Object provider) {\n         if (provider == null) {\n             throw new IllegalArgumentException(\"provider == null!\");\n         }\n+\n         Iterator<SubRegistry> regs = getSubRegistries(provider);\n         while (regs.hasNext()) {\n             SubRegistry reg = regs.next();\n@@ -351,10 +361,12 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if <code>providers</code>\n      * is <code>null</code> or contains a <code>null</code> entry.\n      */\n+\n     public void registerServiceProviders(Iterator<?> providers) {\n         if (providers == null) {\n             throw new IllegalArgumentException(\"provider == null!\");\n         }\n+\n         while (providers.hasNext()) {\n             registerServiceProvider(providers.next());\n         }\n@@ -388,15 +400,17 @@ public class ServiceRegistry {\n      * @exception ClassCastException if provider does not implement\n      * the class defined by <code>category</code>.\n      */\n-    public <T> boolean deregisterServiceProvider(T provider,\n-                                                 Class<T> category) {\n+\n+    public <T> boolean deregisterServiceProvider(T provider, Class<T> category) {\n         if (provider == null) {\n             throw new IllegalArgumentException(\"provider == null!\");\n         }\n+\n         SubRegistry reg = categoryMap.get(category);\n         if (reg == null) {\n             throw new IllegalArgumentException(\"category unknown!\");\n         }\n+\n         if (!category.isAssignableFrom(provider.getClass())) {\n             throw new ClassCastException();\n         }\n@@ -412,10 +426,12 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if <code>provider</code> is\n      * <code>null</code>.\n      */\n+\n     public void deregisterServiceProvider(Object provider) {\n         if (provider == null) {\n             throw new IllegalArgumentException(\"provider == null!\");\n         }\n+\n         Iterator<SubRegistry> regs = getSubRegistries(provider);\n         while (regs.hasNext()) {\n             SubRegistry reg = regs.next();\n@@ -435,10 +451,12 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if <code>provider</code> is\n      * <code>null</code>.\n      */\n+\n     public boolean contains(Object provider) {\n         if (provider == null) {\n             throw new IllegalArgumentException(\"provider == null!\");\n         }\n+\n         Iterator<SubRegistry> regs = getSubRegistries(provider);\n         while (regs.hasNext()) {\n             SubRegistry reg = regs.next();\n@@ -446,7 +464,6 @@ public class ServiceRegistry {\n                 return true;\n             }\n         }\n-\n         return false;\n     }\n \n@@ -470,8 +487,8 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if there is no category\n      * corresponding to <code>category</code>.\n      */\n-    public <T> Iterator<T> getServiceProviders(Class<T> category,\n-                                               boolean useOrdering) {\n+\n+    public <T> Iterator<T> getServiceProviders(Class<T> category, boolean useOrdering) {\n         SubRegistry reg = categoryMap.get(category);\n         if (reg == null) {\n             throw new IllegalArgumentException(\"category unknown!\");\n@@ -489,6 +506,7 @@ public class ServiceRegistry {\n      *\n      * @see ServiceRegistry#getServiceProviders(Class, ServiceRegistry.Filter, boolean)\n      */\n+\n     public interface Filter {\n \n         /**\n@@ -500,6 +518,8 @@ public class ServiceRegistry {\n          *\n          * @return true if the provider matches the criterion.\n          */\n+\n+\n         boolean filter(Object provider);\n     }\n \n@@ -525,13 +545,13 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if there is no category\n      * corresponding to <code>category</code>.\n      */\n-    public <T> Iterator<T> getServiceProviders(Class<T> category,\n-                                               Filter filter,\n-                                               boolean useOrdering) {\n+\n+    public <T> Iterator<T> getServiceProviders(Class<T> category, Filter filter, boolean useOrdering) {\n         SubRegistry reg = categoryMap.get(category);\n         if (reg == null) {\n             throw new IllegalArgumentException(\"category unknown!\");\n         }\n+\n         Iterator iter = getServiceProviders(category, useOrdering);\n         return new FilterIterator(iter, filter);\n     }\n@@ -553,13 +573,15 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if <code>providerClass</code> is\n      * <code>null</code>.\n      */\n+\n     public <T> T getServiceProviderByClass(Class<T> providerClass) {\n         if (providerClass == null) {\n             throw new IllegalArgumentException(\"providerClass == null!\");\n         }\n+\n         for (Class c : categoryMap.keySet()) {\n             if (c.isAssignableFrom(providerClass)) {\n-                SubRegistry reg = (SubRegistry)categoryMap.get(c);\n+                SubRegistry reg = (SubRegistry) categoryMap.get(c);\n                 T provider = reg.getServiceProviderByClass(providerClass);\n                 if (provider != null) {\n                     return provider;\n@@ -596,21 +618,22 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if there is no category\n      * corresponding to <code>category</code>.\n      */\n-    public <T> boolean setOrdering(Class<T> category,\n-                                   T firstProvider,\n-                                   T secondProvider) {\n+\n+    public <T> boolean setOrdering(Class<T> category, T firstProvider, T secondProvider) {\n         if (firstProvider == null || secondProvider == null) {\n             throw new IllegalArgumentException(\"provider is null!\");\n         }\n+\n         if (firstProvider == secondProvider) {\n             throw new IllegalArgumentException(\"providers are the same!\");\n         }\n-        SubRegistry reg = (SubRegistry)categoryMap.get(category);\n+\n+        SubRegistry reg = (SubRegistry) categoryMap.get(category);\n         if (reg == null) {\n             throw new IllegalArgumentException(\"category unknown!\");\n         }\n-        if (reg.contains(firstProvider) &&\n-            reg.contains(secondProvider)) {\n+\n+        if (reg.contains(firstProvider) && reg.contains(secondProvider)) {\n             return reg.setOrdering(firstProvider, secondProvider);\n         }\n         return false;\n@@ -641,21 +664,22 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if there is no category\n      * corresponding to <code>category</code>.\n      */\n-    public <T> boolean unsetOrdering(Class<T> category,\n-                                     T firstProvider,\n-                                     T secondProvider) {\n+\n+    public <T> boolean unsetOrdering(Class<T> category, T firstProvider, T secondProvider) {\n         if (firstProvider == null || secondProvider == null) {\n             throw new IllegalArgumentException(\"provider is null!\");\n         }\n+\n         if (firstProvider == secondProvider) {\n             throw new IllegalArgumentException(\"providers are the same!\");\n         }\n-        SubRegistry reg = (SubRegistry)categoryMap.get(category);\n+\n+        SubRegistry reg = (SubRegistry) categoryMap.get(category);\n         if (reg == null) {\n             throw new IllegalArgumentException(\"category unknown!\");\n         }\n-        if (reg.contains(firstProvider) &&\n-            reg.contains(secondProvider)) {\n+\n+        if (reg.contains(firstProvider) && reg.contains(secondProvider)) {\n             return reg.unsetOrdering(firstProvider, secondProvider);\n         }\n         return false;\n@@ -670,8 +694,9 @@ public class ServiceRegistry {\n      * @exception IllegalArgumentException if there is no category\n      * corresponding to <code>category</code>.\n      */\n+\n     public void deregisterAll(Class<?> category) {\n-        SubRegistry reg = (SubRegistry)categoryMap.get(category);\n+        SubRegistry reg = (SubRegistry) categoryMap.get(category);\n         if (reg == null) {\n             throw new IllegalArgumentException(\"category unknown!\");\n         }\n@@ -682,10 +707,11 @@ public class ServiceRegistry {\n      * Deregisters all currently registered service providers from all\n      * categories.\n      */\n+\n     public void deregisterAll() {\n         Iterator iter = categoryMap.values().iterator();\n         while (iter.hasNext()) {\n-            SubRegistry reg = (SubRegistry)iter.next();\n+            SubRegistry reg = (SubRegistry) iter.next();\n             reg.clear();\n         }\n     }\n@@ -699,10 +725,12 @@ public class ServiceRegistry {\n      * @exception Throwable if an error occurs during superclass\n      * finalization.\n      */\n+\n     public void finalize() throws Throwable {\n         deregisterAll();\n         super.finalize();\n     }\n+\n }\n \n \n@@ -710,17 +738,18 @@ public class ServiceRegistry {\n  * A portion of a registry dealing with a single superclass or\n  * interface.\n  */\n+\n class SubRegistry {\n \n-    ServiceRegistry registry;\n \n+    ServiceRegistry registry;\n     Class<?> category;\n \n     // Provider Objects organized by partial oridering\n     PartiallyOrderedSet poset = new PartiallyOrderedSet();\n \n     // Class -> Provider Object of that class\n-    Map<Class<?>,Object> map = new HashMap<>();\n+    Map<Class<?>, Object> map = new HashMap<>();\n \n     public SubRegistry(ServiceRegistry registry, Class<?> category) {\n         this.registry = registry;\n@@ -729,18 +758,16 @@ class SubRegistry {\n \n     public boolean registerServiceProvider(Object provider) {\n         Object oprovider = map.get(provider.getClass());\n-        boolean present =  oprovider != null;\n-\n+        boolean present = oprovider != null;\n         if (present) {\n             deregisterServiceProvider(oprovider);\n         }\n         map.put(provider.getClass(), provider);\n         poset.add(provider);\n         if (provider instanceof RegisterableService) {\n-            RegisterableService rs = (RegisterableService)provider;\n+            RegisterableService rs = (RegisterableService) provider;\n             rs.onRegistration(registry, category);\n         }\n-\n         return !present;\n     }\n \n@@ -749,17 +776,16 @@ class SubRegistry {\n      *\n      * @return true if the provider was previously registered.\n      */\n+\n     public boolean deregisterServiceProvider(Object provider) {\n         Object oprovider = map.get(provider.getClass());\n-\n         if (provider == oprovider) {\n             map.remove(provider.getClass());\n             poset.remove(provider);\n             if (provider instanceof RegisterableService) {\n-                RegisterableService rs = (RegisterableService)provider;\n+                RegisterableService rs = (RegisterableService) provider;\n                 rs.onDeregistration(registry, category);\n             }\n-\n             return true;\n         }\n         return false;\n@@ -770,13 +796,11 @@ class SubRegistry {\n         return oprovider == provider;\n     }\n \n-    public boolean setOrdering(Object firstProvider,\n-                               Object secondProvider) {\n+    public boolean setOrdering(Object firstProvider, Object secondProvider) {\n         return poset.setOrdering(firstProvider, secondProvider);\n     }\n \n-    public boolean unsetOrdering(Object firstProvider,\n-                                 Object secondProvider) {\n+    public boolean unsetOrdering(Object firstProvider, Object secondProvider) {\n         return poset.unsetOrdering(firstProvider, secondProvider);\n     }\n \n@@ -789,7 +813,7 @@ class SubRegistry {\n     }\n \n     public <T> T getServiceProviderByClass(Class<T> providerClass) {\n-        return (T)map.get(providerClass);\n+        return (T) map.get(providerClass);\n     }\n \n     public void clear() {\n@@ -797,9 +821,8 @@ class SubRegistry {\n         while (iter.hasNext()) {\n             Object provider = iter.next();\n             iter.remove();\n-\n             if (provider instanceof RegisterableService) {\n-                RegisterableService rs = (RegisterableService)provider;\n+                RegisterableService rs = (RegisterableService) provider;\n                 rs.onDeregistration(registry, category);\n             }\n         }\n@@ -809,6 +832,7 @@ class SubRegistry {\n     public void finalize() {\n         clear();\n     }\n+\n }\n \n \n@@ -816,15 +840,14 @@ class SubRegistry {\n  * A class for wrapping <code>Iterators</code> with a filter function.\n  * This provides an iterator for a subset without duplication.\n  */\n+\n class FilterIterator<T> implements Iterator<T> {\n \n     private Iterator<T> iter;\n     private ServiceRegistry.Filter filter;\n-\n     private T next = null;\n \n-    public FilterIterator(Iterator<T> iter,\n-                          ServiceRegistry.Filter filter) {\n+    public FilterIterator(Iterator<T> iter, ServiceRegistry.Filter filter) {\n         this.iter = iter;\n         this.filter = filter;\n         advance();\n@@ -838,7 +861,6 @@ class FilterIterator<T> implements Iterator<T> {\n                 return;\n             }\n         }\n-\n         next = null;\n     }\n \n@@ -850,6 +872,7 @@ class FilterIterator<T> implements Iterator<T> {\n         if (next == null) {\n             throw new NoSuchElementException();\n         }\n+\n         T o = next;\n         advance();\n         return o;\n@@ -858,4 +881,5 @@ class FilterIterator<T> implements Iterator<T> {\n     public void remove() {\n         throw new UnsupportedOperationException();\n     }\n-}\n+\n+}\n\\ No newline at end of file\n",
            "diff_size": 91
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/105/ServiceRegistry.java\nindex 1794adb5de2..d12932f4946 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/105/ServiceRegistry.java\n@@ -195,9 +195,8 @@ public class ServiceRegistry {\n      * <code>providerClass</code> is <code>null</code>.\n      */\n     public static <T> Iterator<T> lookupProviders(Class<T> providerClass,\n-                                                  ClassLoader loader)\n-    {\n-        if (providerClass == null) {\n+                                                  ClassLoader loader) {\n+                                                      if (providerClass == null) {\n             throw new IllegalArgumentException(\"providerClass == null!\");\n         }\n         return ServiceLoader.load(providerClass, loader).iterator();\n",
            "diff_size": 3
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/105/ServiceRegistry.java\nindex 1794adb5de2..0dd34ee6776 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/105/ServiceRegistry.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/105/ServiceRegistry.java\n@@ -195,9 +195,8 @@ public class ServiceRegistry {\n      * <code>providerClass</code> is <code>null</code>.\n      */\n     public static <T> Iterator<T> lookupProviders(Class<T> providerClass,\n-                                                  ClassLoader loader)\n-    {\n-        if (providerClass == null) {\n+                                                  ClassLoader loader){\n+                                                      if (providerClass == null) {\n             throw new IllegalArgumentException(\"providerClass == null!\");\n         }\n         return ServiceLoader.load(providerClass, loader).iterator();\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize"
    ]
}