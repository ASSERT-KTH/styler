{
    "project_name": "wso2-attic-commons",
    "error_id": "19",
    "information": {
        "errors": [
            {
                "line": "39",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 121).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\n/**\n * This is the new (XACML 3.0) is the standard Permit Overrides policy combining algorithm. It allows a single evaluation\n * of Permit to take precedence over any number of deny, not applicable or indeterminate results.\n * Note that since this implementation does an ordered evaluation, this class also supports the\n * Ordered Permit Overrides algorithm.",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "39",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "39",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/19/PermitOverridesPolicyAlg.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/19/PermitOverridesPolicyAlg.java\nindex 6e8db7f6c2b..bdbd0b173e1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/19/PermitOverridesPolicyAlg.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/19/PermitOverridesPolicyAlg.java\n@@ -1,20 +1,20 @@\n /*\n-*  Copyright (c) WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n-*\n-*  WSO2 Inc. licenses this file to you under the Apache License,\n-*  Version 2.0 (the \"License\"); you may not use this file except\n-*  in compliance with the License.\n-*  You may obtain a copy of the License at\n-*\n-*    http://www.apache.org/licenses/LICENSE-2.0\n-*\n-* Unless required by applicable law or agreed to in writing,\n-* software distributed under the License is distributed on an\n-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-* KIND, either express or implied.  See the License for the\n-* specific language governing permissions and limitations\n-* under the License.\n-*/\n+ *  Copyright (c) WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n \n package org.wso2.balana.combine.xacml3;\n \n@@ -41,155 +41,155 @@ import java.util.Set;\n  * Note that since this implementation does an ordered evaluation, this class also supports the\n  * Ordered Permit Overrides algorithm.\n  */\n-public class PermitOverridesPolicyAlg extends PolicyCombiningAlgorithm{\n-    /**\n-     * The standard URN used to identify this algorithm\n-     */\n-    public static final String algId = \"urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:\"\n-            + \"permit-overrides\";\n-\n-    // a URI form of the identifier\n-    private static URI identifierURI;\n-    // exception if the URI was invalid, which should never be a problem\n-    private static RuntimeException earlyException;\n-\n-    static {\n-        try {\n-            identifierURI = new URI(algId);\n-        } catch (URISyntaxException se) {\n-            earlyException = new IllegalArgumentException();\n-            earlyException.initCause(se);\n-        }\n+public class PermitOverridesPolicyAlg extends PolicyCombiningAlgorithm {\n+  /**\n+   * The standard URN used to identify this algorithm\n+   */\n+  public static final String algId = \"urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:\"\n+    + \"permit-overrides\";\n+\n+  // a URI form of the identifier\n+  private static URI identifierURI;\n+  // exception if the URI was invalid, which should never be a problem\n+  private static RuntimeException earlyException;\n+\n+  static {\n+    try {\n+      identifierURI = new URI(algId);\n+    } catch (URISyntaxException se) {\n+      earlyException = new IllegalArgumentException();\n+      earlyException.initCause(se);\n     }\n+  }\n \n-    /**\n-     * Standard constructor.\n-     */\n-    public PermitOverridesPolicyAlg() {\n-        super(identifierURI);\n-\n-        if (earlyException != null)\n-            throw earlyException;\n-    }\n+  /**\n+   * Standard constructor.\n+   */\n+  public PermitOverridesPolicyAlg() {\n+    super(identifierURI);\n \n-    /**\n-     * Protected constructor used by the ordered version of this algorithm.\n-     *\n-     * @param identifier the algorithm's identifier\n-     */\n-    protected PermitOverridesPolicyAlg(URI identifier) {\n-        super(identifier);\n+    if (earlyException != null) {\n+      throw earlyException;\n     }\n-\n-    /**\n-     * Applies the combining rule to the set of policies based on the evaluation context.\n-     *\n-     * @param context the context from the request\n-     * @param parameters a (possibly empty) non-null <code>List</code> of\n-     *            <code>CombinerParameter<code>s\n-     * @param policyElements the policies to combine\n-     *\n-     * @return the result of running the combining algorithm\n-     */\n-    public AbstractResult combine(EvaluationCtx context, List parameters, List policyElements) {\n-\n-        boolean atLeastOneErrorD = false;\n-        boolean atLeastOneErrorP = false;\n-        boolean atLeastOneErrorDP = false;\n-        boolean atLeastOneDeny = false;\n-        AbstractResult firstIndeterminateResultD = null;\n-        AbstractResult firstIndeterminateResultP = null;\n-        AbstractResult firstIndeterminateResultDP = null;        \n-        Set<ObligationResult> denyObligations = new HashSet<ObligationResult>();\n-        Set<Advice> denyAdvices = new HashSet<Advice>();\n-\n-        Iterator it = policyElements.iterator();\n-\n-        while (it.hasNext()) {\n-            AbstractPolicy policy = ((PolicyCombinerElement) (it.next())).getPolicy();\n-\n-            // make sure that the policy matches the context\n-            MatchResult match = policy.match(context);\n-\n-            if (match.getResult() == MatchResult.INDETERMINATE) {\n+  }\n+\n+  /**\n+   * Protected constructor used by the ordered version of this algorithm.\n+   *\n+   * @param identifier the algorithm's identifier\n+   */\n+  protected PermitOverridesPolicyAlg(URI identifier) {\n+    super(identifier);\n+  }\n+\n+  /**\n+   * Applies the combining rule to the set of policies based on the evaluation context.\n+   *\n+   * @param context        the context from the request\n+   * @param parameters     a (possibly empty) non-null <code>List</code> of\n+   *                       <code>CombinerParameter<code>s\n+   * @param policyElements the policies to combine\n+   * @return the result of running the combining algorithm\n+   */\n+  public AbstractResult combine(EvaluationCtx context, List parameters, List policyElements) {\n+\n+    boolean atLeastOneErrorD = false;\n+    boolean atLeastOneErrorP = false;\n+    boolean atLeastOneErrorDP = false;\n+    boolean atLeastOneDeny = false;\n+    AbstractResult firstIndeterminateResultD = null;\n+    AbstractResult firstIndeterminateResultP = null;\n+    AbstractResult firstIndeterminateResultDP = null;\n+    Set<ObligationResult> denyObligations = new HashSet<ObligationResult>();\n+    Set<Advice> denyAdvices = new HashSet<Advice>();\n+\n+    Iterator it = policyElements.iterator();\n+\n+    while (it.hasNext()) {\n+      AbstractPolicy policy = ((PolicyCombinerElement) (it.next())).getPolicy();\n+\n+      // make sure that the policy matches the context\n+      MatchResult match = policy.match(context);\n+\n+      if (match.getResult() == MatchResult.INDETERMINATE) {\n //                atLeastOneError = true;\n //                                                                      // TODO\n //                // keep track of the first error, regardless of cause\n //                if (firstIndeterminateStatus == null){\n //                    firstIndeterminateStatus = match.getStatus();\n //                }\n-            } else if (match.getResult() == MatchResult.MATCH) {\n-                // now we evaluate the policy\n-                AbstractResult result = policy.evaluate(context);\n-                int value = result.getDecision();\n-\n-                if (value == AbstractResult.DECISION_PERMIT){\n-                    return result;\n-                }\n-\n-                if(value == AbstractResult.DECISION_NOT_APPLICABLE){\n-                    continue;\n-                }\n-\n-                // keep track of whether we had at least one rule that\n-                // actually pertained to the request\n-                if (value == AbstractResult.DECISION_DENY){\n-\n-                    atLeastOneDeny = true;\n-                    denyAdvices.addAll(result.getAdvices());\n-                    denyObligations.addAll(result.getObligations());\n-\n-                } else {\n-\n-                    // if it was INDETERMINATE, check extended results\n-                    if (value == AbstractResult.DECISION_INDETERMINATE_DENY){\n-                        atLeastOneErrorD = true;\n-                        // there are no rules about what to do if multiple cases\n-                        // cause errors, so we'll just return the first one\n-                        if(firstIndeterminateResultD == null){\n-                            firstIndeterminateResultD = result;\n-                        }\n-                    } else if (value== AbstractResult.DECISION_INDETERMINATE_PERMIT){\n-                        atLeastOneErrorP = true;\n-                        // there are no rules about what to do if multiple cases\n-                        // cause errors, so we'll just return the first one\n-                        if(firstIndeterminateResultP == null){\n-                            firstIndeterminateResultP = result;\n-                        }\n-                    } else if(value == AbstractResult.DECISION_INDETERMINATE_DENY_OR_PERMIT){\n-                        atLeastOneErrorDP = true;\n-                        // there are no rules about what to do if multiple cases\n-                        // cause errors, so we'll just return the first one\n-                        if(firstIndeterminateResultDP == null){\n-                            firstIndeterminateResultDP = result;\n-                        }\n-                    }\n-                }\n-            }\n+      } else if (match.getResult() == MatchResult.MATCH) {\n+        // now we evaluate the policy\n+        AbstractResult result = policy.evaluate(context);\n+        int value = result.getDecision();\n+\n+        if (value == AbstractResult.DECISION_PERMIT) {\n+          return result;\n         }\n \n-        if(atLeastOneErrorDP){\n-            return firstIndeterminateResultDP;\n+        if (value == AbstractResult.DECISION_NOT_APPLICABLE) {\n+          continue;\n         }\n \n-        if (atLeastOneErrorP && (atLeastOneErrorD || atLeastOneDeny)){\n+        // keep track of whether we had at least one rule that\n+        // actually pertained to the request\n+        if (value == AbstractResult.DECISION_DENY) {\n \n-            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE_DENY_OR_PERMIT,\n-                                                   firstIndeterminateResultP.getStatus(), context);\n-        }\n+          atLeastOneDeny = true;\n+          denyAdvices.addAll(result.getAdvices());\n+          denyObligations.addAll(result.getObligations());\n \n-        if(atLeastOneErrorP){\n-            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE_PERMIT,\n-                                                   firstIndeterminateResultP.getStatus(), context);\n-        }\n+        } else {\n \n-        if (atLeastOneDeny) {\n-            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_DENY,\n-                                                        denyObligations, denyAdvices, context);\n+          // if it was INDETERMINATE, check extended results\n+          if (value == AbstractResult.DECISION_INDETERMINATE_DENY) {\n+            atLeastOneErrorD = true;\n+            // there are no rules about what to do if multiple cases\n+            // cause errors, so we'll just return the first one\n+            if (firstIndeterminateResultD == null) {\n+              firstIndeterminateResultD = result;\n+            }\n+          } else if (value == AbstractResult.DECISION_INDETERMINATE_PERMIT) {\n+            atLeastOneErrorP = true;\n+            // there are no rules about what to do if multiple cases\n+            // cause errors, so we'll just return the first one\n+            if (firstIndeterminateResultP == null) {\n+              firstIndeterminateResultP = result;\n+            }\n+          } else if (value == AbstractResult.DECISION_INDETERMINATE_DENY_OR_PERMIT) {\n+            atLeastOneErrorDP = true;\n+            // there are no rules about what to do if multiple cases\n+            // cause errors, so we'll just return the first one\n+            if (firstIndeterminateResultDP == null) {\n+              firstIndeterminateResultDP = result;\n+            }\n+          }\n         }\n-        // if we hit this point, then none of the rules actually applied\n-        // to us, so we return NOT_APPLICABLE\n-        return ResultFactory.getFactory().getResult(AbstractResult.DECISION_NOT_APPLICABLE, context);\n+      }\n+    }\n+\n+    if (atLeastOneErrorDP) {\n+      return firstIndeterminateResultDP;\n+    }\n+\n+    if (atLeastOneErrorP && (atLeastOneErrorD || atLeastOneDeny)) {\n+\n+      return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE_DENY_OR_PERMIT,\n+        firstIndeterminateResultP.getStatus(), context);\n+    }\n+\n+    if (atLeastOneErrorP) {\n+      return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE_PERMIT,\n+        firstIndeterminateResultP.getStatus(), context);\n+    }\n+\n+    if (atLeastOneDeny) {\n+      return ResultFactory.getFactory().getResult(AbstractResult.DECISION_DENY,\n+        denyObligations, denyAdvices, context);\n     }\n+    // if we hit this point, then none of the rules actually applied\n+    // to us, so we return NOT_APPLICABLE\n+    return ResultFactory.getFactory().getResult(AbstractResult.DECISION_NOT_APPLICABLE, context);\n+  }\n \n }\n",
            "diff_size": 201
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "39",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "172",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 158).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "176",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 150).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "180",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 125).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/19/PermitOverridesPolicyAlg.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/19/PermitOverridesPolicyAlg.java\nindex 6e8db7f6c2b..83402be9b6c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/19/PermitOverridesPolicyAlg.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/19/PermitOverridesPolicyAlg.java\n@@ -41,7 +41,7 @@ import java.util.Set;\n  * Note that since this implementation does an ordered evaluation, this class also supports the\n  * Ordered Permit Overrides algorithm.\n  */\n-public class PermitOverridesPolicyAlg extends PolicyCombiningAlgorithm{\n+public class PermitOverridesPolicyAlg extends PolicyCombiningAlgorithm {\n     /**\n      * The standard URN used to identify this algorithm\n      */\n@@ -99,8 +99,8 @@ public class PermitOverridesPolicyAlg extends PolicyCombiningAlgorithm{\n         boolean atLeastOneDeny = false;\n         AbstractResult firstIndeterminateResultD = null;\n         AbstractResult firstIndeterminateResultP = null;\n-        AbstractResult firstIndeterminateResultDP = null;        \n-        Set<ObligationResult> denyObligations = new HashSet<ObligationResult>();\n+        AbstractResult firstIndeterminateResultDP = null;\n+Set<ObligationResult> denyObligations = new HashSet<ObligationResult>();\n         Set<Advice> denyAdvices = new HashSet<Advice>();\n \n         Iterator it = policyElements.iterator();\n@@ -112,13 +112,8 @@ public class PermitOverridesPolicyAlg extends PolicyCombiningAlgorithm{\n             MatchResult match = policy.match(context);\n \n             if (match.getResult() == MatchResult.INDETERMINATE) {\n-//                atLeastOneError = true;\n-//                                                                      // TODO\n-//                // keep track of the first error, regardless of cause\n-//                if (firstIndeterminateStatus == null){\n-//                    firstIndeterminateStatus = match.getStatus();\n-//                }\n-            } else if (match.getResult() == MatchResult.MATCH) {\n+//         \n+    } else if (match.getResult() == MatchResult.MATCH) {\n                 // now we evaluate the policy\n                 AbstractResult result = policy.evaluate(context);\n                 int value = result.getDecision();\n@@ -149,7 +144,7 @@ public class PermitOverridesPolicyAlg extends PolicyCombiningAlgorithm{\n                         if(firstIndeterminateResultD == null){\n                             firstIndeterminateResultD = result;\n                         }\n-                    } else if (value== AbstractResult.DECISION_INDETERMINATE_PERMIT){\n+                    } else if (value == AbstractResult.DECISION_INDETERMINATE_PERMIT){\n                         atLeastOneErrorP = true;\n                         // there are no rules about what to do if multiple cases\n                         // cause errors, so we'll just return the first one\n@@ -174,22 +169,19 @@ public class PermitOverridesPolicyAlg extends PolicyCombiningAlgorithm{\n \n         if (atLeastOneErrorP && (atLeastOneErrorD || atLeastOneDeny)){\n \n-            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE_DENY_OR_PERMIT,\n-                                                   firstIndeterminateResultP.getStatus(), context);\n-        }\n+            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE_DENY_OR_PERMIT, firstIndeterminateResultP.getStatus(), context);\n+    }\n \n         if(atLeastOneErrorP){\n-            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE_PERMIT,\n-                                                   firstIndeterminateResultP.getStatus(), context);\n-        }\n+            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_INDETERMINATE_PERMIT, firstIndeterminateResultP.getStatus(), context);\n+    }\n \n         if (atLeastOneDeny) {\n-            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_DENY,\n-                                                        denyObligations, denyAdvices, context);\n-        }\n+            return ResultFactory.getFactory().getResult(AbstractResult.DECISION_DENY, denyObligations, denyAdvices, context);\n+    }\n         // if we hit this point, then none of the rules actually applied\n         // to us, so we return NOT_APPLICABLE\n         return ResultFactory.getFactory().getResult(AbstractResult.DECISION_NOT_APPLICABLE, context);\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 21
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "39",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "39",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}