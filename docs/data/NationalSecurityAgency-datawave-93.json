{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "93",
    "information": {
        "errors": [
            {
                "line": "38",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import org.apache.accumulo.core.data.Value;\nimport org.apache.accumulo.core.security.Authorizations;\nimport org.apache.accumulo.core.util.PeekingIterator;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;\nimport org.apache.hadoop.io.Text;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "38",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "38",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/93/RangeStreamScanner.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/93/RangeStreamScanner.java\nindex 24b8fa9ae3f..9126d743b46 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/93/RangeStreamScanner.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/93/RangeStreamScanner.java\n@@ -48,602 +48,625 @@ import com.google.common.util.concurrent.MoreExecutors;\n /**\n  * Purpose: Extends Scanner session so that we can modify how we build our subsequent ranges. Breaking this out cleans up the code. May require implementation\n  * specific details if you are using custom iterators, as we are reinitializing a seek\n- * \n+ * <p>\n  * Design: Extends Scanner session and only overrides the buildNextRange.\n- * \n- * \n  */\n public class RangeStreamScanner extends ScannerSession implements Callable<RangeStreamScanner> {\n-    \n-    private static final int MAX_MEDIAN = 20;\n-    private static final Logger log = Logger.getLogger(RangeStreamScanner.class);\n-    private int shardsPerDayThreshold = Integer.MAX_VALUE;\n-    // simply compare the strings. no need for a date formatter\n-    protected static final int dateCfLength = 8;\n-    protected boolean seenUnexpectedKey = false;\n-    protected Queue<Entry<Key,Value>> currentQueue;\n-    \n-    protected Entry<Key,Value> prevDay = null;\n-    \n-    protected ReentrantReadWriteLock queueLock = new ReentrantReadWriteLock(true);\n-    \n-    protected Lock readLock;\n-    protected Lock writeLock;\n-    \n-    volatile boolean finished = false;\n-    \n-    ExecutorService myExecutor;\n-    \n-    protected ScannerFactory scannerFactory;\n-    \n-    @Override\n-    protected String serviceName() {\n-        String id = \"NoQueryId\";\n-        if (null != settings && null != settings.getId()) {\n-            id = settings.getId().toString();\n-        }\n-        return \"RangeStreamScanner (\" + id + \")\";\n-    }\n-    \n-    /**\n-     * @param tableName\n-     * @param auths\n-     * @param delegator\n-     * @param maxResults\n-     */\n-    public RangeStreamScanner(String tableName, Set<Authorizations> auths, ResourceQueue delegator, int maxResults, Query settings) {\n-        super(tableName, auths, delegator, maxResults, settings);\n-        delegatedResourceInitializer = BatchResource.class;\n-        currentQueue = Queues.newArrayDeque();\n-        readLock = queueLock.readLock();\n-        writeLock = queueLock.writeLock();\n-        myExecutor = MoreExecutors.sameThreadExecutor();\n-        if (null != stats)\n-            initializeTimers();\n-    }\n-    \n-    /**\n-     * @param tableName\n-     * @param auths\n-     * @param delegator\n-     * @param maxResults\n-     */\n-    public RangeStreamScanner(String tableName, Set<Authorizations> auths, ResourceQueue delegator, int maxResults, Query settings, SessionOptions options,\n-                    Collection<Range> ranges) {\n-        super(tableName, auths, delegator, maxResults, settings, options, ranges);\n-        delegatedResourceInitializer = BatchResource.class;\n-        currentQueue = Queues.newArrayDeque();\n-        readLock = queueLock.readLock();\n-        writeLock = queueLock.writeLock();\n-        myExecutor = MoreExecutors.sameThreadExecutor();\n-        if (null != stats)\n-            initializeTimers();\n-    }\n-    \n-    public RangeStreamScanner(ScannerSession other) {\n-        this(other.tableName, other.auths, other.sessionDelegator, other.maxResults, other.settings, other.options, other.ranges);\n+\n+  private static final int MAX_MEDIAN = 20;\n+  private static final Logger log = Logger.getLogger(RangeStreamScanner.class);\n+  private int shardsPerDayThreshold = Integer.MAX_VALUE;\n+  // simply compare the strings. no need for a date formatter\n+  protected static final int dateCfLength = 8;\n+  protected boolean seenUnexpectedKey = false;\n+  protected Queue<Entry<Key, Value>> currentQueue;\n+\n+  protected Entry<Key, Value> prevDay = null;\n+\n+  protected ReentrantReadWriteLock queueLock = new ReentrantReadWriteLock(true);\n+\n+  protected Lock readLock;\n+  protected Lock writeLock;\n+\n+  volatile boolean finished = false;\n+\n+  ExecutorService myExecutor;\n+\n+  protected ScannerFactory scannerFactory;\n+\n+  @Override\n+  protected String serviceName() {\n+    String id = \"NoQueryId\";\n+    if (null != settings && null != settings.getId()) {\n+      id = settings.getId().toString();\n     }\n-    \n-    public void setExecutor(ExecutorService service) {\n-        myExecutor = service;\n+    return \"RangeStreamScanner (\" + id + \")\";\n+  }\n+\n+  /**\n+   * @param tableName\n+   * @param auths\n+   * @param delegator\n+   * @param maxResults\n+   */\n+  public RangeStreamScanner(String tableName, Set<Authorizations> auths, ResourceQueue delegator, int maxResults,\n+                            Query settings) {\n+    super(tableName, auths, delegator, maxResults, settings);\n+    delegatedResourceInitializer = BatchResource.class;\n+    currentQueue = Queues.newArrayDeque();\n+    readLock = queueLock.readLock();\n+    writeLock = queueLock.writeLock();\n+    myExecutor = MoreExecutors.sameThreadExecutor();\n+    if (null != stats) {\n+      initializeTimers();\n     }\n-    \n-    public RangeStreamScanner setScannerFactory(ScannerFactory factory) {\n-        this.scannerFactory = factory;\n-        return this;\n+  }\n+\n+  /**\n+   * @param tableName\n+   * @param auths\n+   * @param delegator\n+   * @param maxResults\n+   */\n+  public RangeStreamScanner(String tableName, Set<Authorizations> auths, ResourceQueue delegator, int maxResults,\n+                            Query settings, SessionOptions options,\n+                            Collection<Range> ranges) {\n+    super(tableName, auths, delegator, maxResults, settings, options, ranges);\n+    delegatedResourceInitializer = BatchResource.class;\n+    currentQueue = Queues.newArrayDeque();\n+    readLock = queueLock.readLock();\n+    writeLock = queueLock.writeLock();\n+    myExecutor = MoreExecutors.sameThreadExecutor();\n+    if (null != stats) {\n+      initializeTimers();\n     }\n-    \n-    /**\n-     * Override this for your specific implementation.\n-     * \n-     * In this specific implementation our row key will be the term, the column family will be the field name, and the column family will be the shard,so we\n-     * should have the following as our last key\n-     * \n-     * bar FOO:20130101_0\n-     * \n-     * so we should append a null so that we we don't skip shards. similarly, an assumption is made of the key structure within this class.\n-     * \n-     * @param lastKey\n-     * @param previousRange\n+  }\n+\n+  public RangeStreamScanner(ScannerSession other) {\n+    this(other.tableName, other.auths, other.sessionDelegator, other.maxResults, other.settings, other.options,\n+        other.ranges);\n+  }\n+\n+  public void setExecutor(ExecutorService service) {\n+    myExecutor = service;\n+  }\n+\n+  public RangeStreamScanner setScannerFactory(ScannerFactory factory) {\n+    this.scannerFactory = factory;\n+    return this;\n+  }\n+\n+  /**\n+   * Override this for your specific implementation.\n+   * <p>\n+   * In this specific implementation our row key will be the term, the column family will be the field name, and the column family will be the shard,so we\n+   * should have the following as our last key\n+   * <p>\n+   * bar FOO:20130101_0\n+   * <p>\n+   * so we should append a null so that we we don't skip shards. similarly, an assumption is made of the key structure within this class.\n+   *\n+   * @param lastKey\n+   * @param previousRange\n+   */\n+  @Override\n+  public Range buildNextRange(final Key lastKey, final Range previousRange) {\n+\n+    /*\n+     * This path includes the following key from the shard_id onward. The reason we also append the hex 255 value is because we receive a key not unlike\n+     * foo:20130101_0. If our next search space is foo:20130101_0\\x00 we will hit all data types within that range...again..and again...and again. To\n+     * account for this, we put \\uffff after the null byte so that we start key is technically the last value within the provided shard, moving us to the\n+     * exact next key within our RangeStream\n      */\n-    @Override\n-    public Range buildNextRange(final Key lastKey, final Range previousRange) {\n-        \n-        /*\n-         * This path includes the following key from the shard_id onward. The reason we also append the hex 255 value is because we receive a key not unlike\n-         * foo:20130101_0. If our next search space is foo:20130101_0\\x00 we will hit all data types within that range...again..and again...and again. To\n-         * account for this, we put \\uffff after the null byte so that we start key is technically the last value within the provided shard, moving us to the\n-         * exact next key within our RangeStream\n-         */\n-        return new Range(new Key(lastKey.getRow(), lastKey.getColumnFamily(), new Text(lastKey.getColumnQualifier() + \"\\uffff\")), true,\n-                        previousRange.getEndKey(), previousRange.isEndKeyInclusive());\n-    }\n-    \n+    return new Range(\n+        new Key(lastKey.getRow(), lastKey.getColumnFamily(), new Text(lastKey.getColumnQualifier() + \"\\uffff\")), true,\n+        previousRange.getEndKey(), previousRange.isEndKeyInclusive());\n+  }\n+\n+  /*\n+   * (non-Javadoc)\n+   *\n+   * @see java.util.Iterator#hasNext()\n+   */\n+  @Override\n+  public boolean hasNext() {\n     /*\n-     * (non-Javadoc)\n-     * \n-     * @see java.util.Iterator#hasNext()\n+     * Let's take a moment to look through all states S\n      */\n-    @Override\n-    public boolean hasNext() {\n-        /*\n-         * Let's take a moment to look through all states S\n-         */\n+    try {\n+      if (null != stats) {\n+        stats.getTimer(TIMERS.HASNEXT).resume();\n+      }\n+\n+      while (null == currentEntry && (!finished || !resultQueue.isEmpty() || flushNeeded())) {\n+\n         try {\n-            if (null != stats)\n-                stats.getTimer(TIMERS.HASNEXT).resume();\n-            \n-            while (null == currentEntry && (!finished || !resultQueue.isEmpty() || flushNeeded())) {\n-                \n-                try {\n-                    /*\n-                     * Poll for one second. We're in a do/while loop that will break iff we are no longer running or there is a current entry available.\n-                     */\n-                    currentEntry = resultQueue.poll(getPollTime(), TimeUnit.MILLISECONDS);\n-                    \n-                } catch (InterruptedException e) {\n-                    log.error(e);\n-                    throw new RuntimeException(e);\n-                }\n-                // if we pulled no data and we are not running, and there is no data in the queue\n-                // we can flush if needed and retry\n-                if (currentEntry == null && (!finished && resultQueue.isEmpty())) {\n-                    submitTask();\n-                } else if (flushNeeded()) {\n-                    flush();\n-                }\n-            }\n-        } finally {\n-            if (null != stats) {\n-                try {\n-                    stats.getTimer(TIMERS.HASNEXT).suspend();\n-                } catch (Exception e) {\n-                    log.error(e);\n-                }\n-            }\n-            if (uncaughtExceptionHandler.getThrowable() != null) {\n-                log.error(\"Exception discovered on hasNext call\", uncaughtExceptionHandler.getThrowable());\n-                Throwables.propagate(uncaughtExceptionHandler.getThrowable());\n-            }\n+          /*\n+           * Poll for one second. We're in a do/while loop that will break iff we are no longer running or there is a current entry available.\n+           */\n+          currentEntry = resultQueue.poll(getPollTime(), TimeUnit.MILLISECONDS);\n+\n+        } catch (InterruptedException e) {\n+          log.error(e);\n+          throw new RuntimeException(e);\n         }\n-        return (null != currentEntry);\n-    }\n-    \n-    private void submitTask() {\n-        // wait on results. submit the task if we can\n-        Future<RangeStreamScanner> future = myExecutor.submit(this);\n-        try {\n-            future.get();\n-        } catch (InterruptedException | ExecutionException e) {\n-            throw new RuntimeException(e);\n+        // if we pulled no data and we are not running, and there is no data in the queue\n+        // we can flush if needed and retry\n+        if (currentEntry == null && (!finished && resultQueue.isEmpty())) {\n+          submitTask();\n+        } else if (flushNeeded()) {\n+          flush();\n         }\n-    }\n-    \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see com.google.common.util.concurrent.AbstractExecutionThreadService#run()\n-     */\n-    @Override\n-    protected void run() {\n+      }\n+    } finally {\n+      if (null != stats) {\n         try {\n-            findTop();\n-            flush();\n+          stats.getTimer(TIMERS.HASNEXT).suspend();\n         } catch (Exception e) {\n-            uncaughtExceptionHandler.uncaughtException(Thread.currentThread(), e);\n-            Throwables.propagate(e);\n+          log.error(e);\n         }\n+      }\n+      if (uncaughtExceptionHandler.getThrowable() != null) {\n+        log.error(\"Exception discovered on hasNext call\", uncaughtExceptionHandler.getThrowable());\n+        Throwables.propagate(uncaughtExceptionHandler.getThrowable());\n+      }\n     }\n-    \n-    protected int scannerInvariant(final Iterator<Entry<Key,Value>> iter) {\n-        PeekingIterator<Entry<Key,Value>> kvIter = new PeekingIterator<>(iter);\n-        \n-        int retrievalCount = 0;\n-        \n-        Entry<Key,Value> myEntry;\n-        \n-        String currentDay = null;\n-        \n-        if (null != prevDay) {\n-            try {\n-                if (log.isTraceEnabled())\n-                    log.trace(\"Attempting to insert \" + prevDay);\n-                if (!resultQueue.offer(prevDay, 1, TimeUnit.SECONDS)) {\n-                    return 0;\n-                }\n-                prevDay = null;\n-            } catch (InterruptedException e) {\n-                return 0;\n-            }\n+    return (null != currentEntry);\n+  }\n+\n+  private void submitTask() {\n+    // wait on results. submit the task if we can\n+    Future<RangeStreamScanner> future = myExecutor.submit(this);\n+    try {\n+      future.get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /*\n+   * (non-Javadoc)\n+   *\n+   * @see com.google.common.util.concurrent.AbstractExecutionThreadService#run()\n+   */\n+  @Override\n+  protected void run() {\n+    try {\n+      findTop();\n+      flush();\n+    } catch (Exception e) {\n+      uncaughtExceptionHandler.uncaughtException(Thread.currentThread(), e);\n+      Throwables.propagate(e);\n+    }\n+  }\n+\n+  protected int scannerInvariant(final Iterator<Entry<Key, Value>> iter) {\n+    PeekingIterator<Entry<Key, Value>> kvIter = new PeekingIterator<>(iter);\n+\n+    int retrievalCount = 0;\n+\n+    Entry<Key, Value> myEntry;\n+\n+    String currentDay = null;\n+\n+    if (null != prevDay) {\n+      try {\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"Attempting to insert \" + prevDay);\n         }\n-        // produces stats for us, so we don't have to!\n-        DescriptiveStatistics stats = new DescriptiveStatistics();\n-        \n-        writeLock.lock();\n+        if (!resultQueue.offer(prevDay, 1, TimeUnit.SECONDS)) {\n+          return 0;\n+        }\n+        prevDay = null;\n+      } catch (InterruptedException e) {\n+        return 0;\n+      }\n+    }\n+    // produces stats for us, so we don't have to!\n+    DescriptiveStatistics stats = new DescriptiveStatistics();\n+\n+    writeLock.lock();\n+    try {\n+      while (kvIter.hasNext()) {\n+        Entry<Key, Value> currentKeyValue = kvIter.peek();\n+\n+        IndexInfo infos = new IndexInfo();\n         try {\n-            while (kvIter.hasNext()) {\n-                Entry<Key,Value> currentKeyValue = kvIter.peek();\n-                \n-                IndexInfo infos = new IndexInfo();\n-                try {\n-                    infos.readFields(new DataInputStream(new ByteArrayInputStream(currentKeyValue.getValue().get())));\n-                    if (log.isTraceEnabled()) {\n-                        for (IndexMatch match : infos.uids()) {\n-                            log.trace(\"match is \" + StringUtils.split(match.getUid(), '\\u0000')[1]);\n-                        }\n-                    }\n-                } catch (IOException e) {\n-                    log.error(e);\n-                }\n-                \n-                // become a pass-through if we've seen an unexpected key.\n-                if (seenUnexpectedKey) {\n-                    currentQueue.add(currentKeyValue);\n-                    break;\n-                }\n-                \n-                if (null == currentDay) {\n-                    if (log.isTraceEnabled()) {\n-                        log.trace(\"it's a new day!\");\n-                        log.trace(\"adding \" + currentKeyValue.getKey() + \" to queue because it matches\" + currentDay);\n-                    }\n-                    \n-                    currentDay = getDay(currentKeyValue.getKey());\n-                    \n-                    currentQueue.add(currentKeyValue);\n-                    \n-                    lastSeenKey = kvIter.next().getKey();\n-                } else {\n-                    String nextKeysDay = getDay(currentKeyValue.getKey());\n-                    if (currentDay.equals(nextKeysDay)) {\n-                        if (log.isTraceEnabled()) {\n-                            log.trace(\"adding \" + currentKeyValue.getKey() + \" to queue because it matches\" + currentDay);\n-                        }\n-                        \n-                        IndexInfo info = new IndexInfo();\n-                        try {\n-                            info.readFields(new DataInputStream(new ByteArrayInputStream(currentKeyValue.getValue().get())));\n-                        } catch (IOException e) {\n-                            throw new DatawaveFatalQueryException(e);\n-                        }\n-                        \n-                        if (log.isTraceEnabled()) {\n-                            log.trace(\"adding count of \" + info.count());\n-                        }\n-                        \n-                        stats.addValue(info.count());\n-                        \n-                        if (currentQueue.size() <= shardsPerDayThreshold\n-                                        || (currentQueue.size() >= shardsPerDayThreshold && stats.getPercentile(50) < MAX_MEDIAN)) {\n-                            \n-                            if (log.isTraceEnabled()) {\n-                                log.trace(\"adding our stats are \" + stats.getPercentile(50) + \" on \" + currentQueue.size());\n-                            }\n-                            \n-                            currentQueue.add(currentKeyValue);\n-                            \n-                        } else {\n-                            if (log.isTraceEnabled()) {\n-                                log.trace(\"breaking because our stats are \" + stats.getPercentile(50) + \" on \" + currentQueue.size());\n-                            }\n-                            break;\n-                        }\n-                        lastSeenKey = kvIter.next().getKey();\n-                    } else {\n-                        \n-                        int dequeueCount = dequeue();\n-                        retrievalCount += dequeueCount;\n-                        int queueSize = currentQueue.size();\n-                        dequeue(true);\n-                        currentDay = null;\n-                        \n-                        if (dequeueCount != queueSize || retrievalCount <= Math.ceil(maxResults * 1.5)) {\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            \n-            if (currentQueue.size() >= shardsPerDayThreshold && stats.getPercentile(50) > MAX_MEDIAN) {\n-                \n-                Entry<Key,Value> top = currentQueue.poll();\n-                \n-                Key topKey = top.getKey();\n-                if (log.isTraceEnabled())\n-                    log.trace(topKey + \" for \" + currentDay + \" exceeds limit of \" + shardsPerDayThreshold + \" with \" + currentQueue.size());\n-                Key newKey = new Key(topKey.getRow(), topKey.getColumnFamily(), new Text(currentDay), topKey.getColumnVisibility(), topKey.getTimestamp());\n-                \n-                IndexInfo info = new IndexInfo(-1);\n-                \n-                Value newValue;\n-                try {\n-                    ByteArrayOutputStream outByteStream = new ByteArrayOutputStream();\n-                    DataOutputStream outDataStream = new DataOutputStream(outByteStream);\n-                    info.write(outDataStream);\n-                    \n-                    outDataStream.close();\n-                    outByteStream.close();\n-                    \n-                    newValue = new Value(outByteStream.toByteArray());\n-                } catch (IOException e) {\n-                    throw new DatawaveFatalQueryException(e);\n-                }\n-                \n-                myEntry = Maps.immutableEntry(newKey, newValue);\n-                lastSeenKey = newKey;\n-                \n-                try {\n-                    if (!resultQueue.offer(myEntry, 1, TimeUnit.SECONDS)) {\n-                        if (log.isTraceEnabled()) {\n-                            log.trace(\"could not add day! converting \" + myEntry + \" to \" + prevDay);\n-                        }\n-                        prevDay = myEntry;\n-                    }\n-                } catch (InterruptedException exception) {\n-                    prevDay = myEntry;\n-                }\n-                \n-                currentQueue.clear();\n-                \n-            } else {\n-                retrievalCount += dequeue();\n+          infos.readFields(new DataInputStream(new ByteArrayInputStream(currentKeyValue.getValue().get())));\n+          if (log.isTraceEnabled()) {\n+            for (IndexMatch match : infos.uids()) {\n+              log.trace(\"match is \" + StringUtils.split(match.getUid(), '\\u0000')[1]);\n             }\n-        } finally {\n-            writeLock.unlock();\n+          }\n+        } catch (IOException e) {\n+          log.error(e);\n         }\n-        return retrievalCount;\n-    }\n-    \n-    private int dequeue() {\n-        return dequeue(false);\n-    }\n-    \n-    private int dequeue(boolean forceAll) {\n-        int count = 0;\n-        \n-        Queue<Entry<Key,Value>> kvIter = Queues.newArrayDeque(currentQueue);\n-        \n-        currentQueue.clear();\n-        boolean result = true;\n-        for (Entry<Key,Value> top : kvIter) {\n-            \n-            if (result) {\n-                do {\n-                    result = resultQueue.offer(top);\n-                    \n-                    if (!result) {\n-                        if (log.isTraceEnabled())\n-                            log.trace(\"Failed adding \" + resultQueue.size() + \" \" + forceAll);\n-                        if (forceAll)\n-                            continue;\n-                    }\n-                    \n-                    break;\n-                } while (!finished && forceAll);\n+\n+        // become a pass-through if we've seen an unexpected key.\n+        if (seenUnexpectedKey) {\n+          currentQueue.add(currentKeyValue);\n+          break;\n+        }\n+\n+        if (null == currentDay) {\n+          if (log.isTraceEnabled()) {\n+            log.trace(\"it's a new day!\");\n+            log.trace(\"adding \" + currentKeyValue.getKey() + \" to queue because it matches\" + currentDay);\n+          }\n+\n+          currentDay = getDay(currentKeyValue.getKey());\n+\n+          currentQueue.add(currentKeyValue);\n+\n+          lastSeenKey = kvIter.next().getKey();\n+        } else {\n+          String nextKeysDay = getDay(currentKeyValue.getKey());\n+          if (currentDay.equals(nextKeysDay)) {\n+            if (log.isTraceEnabled()) {\n+              log.trace(\"adding \" + currentKeyValue.getKey() + \" to queue because it matches\" + currentDay);\n+            }\n+\n+            IndexInfo info = new IndexInfo();\n+            try {\n+              info.readFields(new DataInputStream(new ByteArrayInputStream(currentKeyValue.getValue().get())));\n+            } catch (IOException e) {\n+              throw new DatawaveFatalQueryException(e);\n+            }\n+\n+            if (log.isTraceEnabled()) {\n+              log.trace(\"adding count of \" + info.count());\n             }\n-            \n-            if (!result && !(!finished && forceAll)) {\n-                if (log.isTraceEnabled())\n-                    log.trace(\"Adding \" + top.getKey() + \" back \");\n-                currentQueue.add(top);\n+\n+            stats.addValue(info.count());\n+\n+            if (currentQueue.size() <= shardsPerDayThreshold\n+                || (currentQueue.size() >= shardsPerDayThreshold && stats.getPercentile(50) < MAX_MEDIAN)) {\n+\n+              if (log.isTraceEnabled()) {\n+                log.trace(\"adding our stats are \" + stats.getPercentile(50) + \" on \" + currentQueue.size());\n+              }\n+\n+              currentQueue.add(currentKeyValue);\n+\n             } else {\n-                if (log.isTraceEnabled())\n-                    log.trace(\"missing \" + top.getKey() + \" true? \" + result);\n+              if (log.isTraceEnabled()) {\n+                log.trace(\"breaking because our stats are \" + stats.getPercentile(50) + \" on \" + currentQueue.size());\n+              }\n+              break;\n+            }\n+            lastSeenKey = kvIter.next().getKey();\n+          } else {\n+\n+            int dequeueCount = dequeue();\n+            retrievalCount += dequeueCount;\n+            int queueSize = currentQueue.size();\n+            dequeue(true);\n+            currentDay = null;\n+\n+            if (dequeueCount != queueSize || retrievalCount <= Math.ceil(maxResults * 1.5)) {\n+              break;\n             }\n-            \n-            if (log.isTraceEnabled())\n-                log.trace(\"Last key is \" + lastSeenKey);\n-            \n-            count++;\n+          }\n         }\n-        \n+      }\n+\n+      if (currentQueue.size() >= shardsPerDayThreshold && stats.getPercentile(50) > MAX_MEDIAN) {\n+\n+        Entry<Key, Value> top = currentQueue.poll();\n+\n+        Key topKey = top.getKey();\n         if (log.isTraceEnabled()) {\n-            log.trace(\"we have \" + currentQueue.size() + \" \" + kvIter.size());\n+          log.trace(topKey + \" for \" + currentDay + \" exceeds limit of \" + shardsPerDayThreshold + \" with \" +\n+              currentQueue.size());\n         }\n-        \n-        return count;\n-    }\n-    \n-    @Override\n-    protected void flush() {\n-        writeLock.lock();\n+        Key newKey =\n+            new Key(topKey.getRow(), topKey.getColumnFamily(), new Text(currentDay), topKey.getColumnVisibility(),\n+                topKey.getTimestamp());\n+\n+        IndexInfo info = new IndexInfo(-1);\n+\n+        Value newValue;\n         try {\n-            dequeue(false);\n-        } finally {\n-            writeLock.unlock();\n+          ByteArrayOutputStream outByteStream = new ByteArrayOutputStream();\n+          DataOutputStream outDataStream = new DataOutputStream(outByteStream);\n+          info.write(outDataStream);\n+\n+          outDataStream.close();\n+          outByteStream.close();\n+\n+          newValue = new Value(outByteStream.toByteArray());\n+        } catch (IOException e) {\n+          throw new DatawaveFatalQueryException(e);\n         }\n-    }\n-    \n-    protected boolean flushNeeded() {\n-        readLock.lock();\n+\n+        myEntry = Maps.immutableEntry(newKey, newValue);\n+        lastSeenKey = newKey;\n+\n         try {\n-            return !currentQueue.isEmpty();\n-        } finally {\n-            readLock.unlock();\n-        }\n-    }\n-    \n-    /**\n-     * Get the day from the key\n-     * \n-     * @param key\n-     * @return\n-     */\n-    protected String getDay(final Key key) {\n-        String myDay = null;\n-        byte[] cq = key.getColumnQualifierData().getBackingArray();\n-        if (cq.length >= dateCfLength) {\n-            myDay = new String(cq, 0, dateCfLength);\n+          if (!resultQueue.offer(myEntry, 1, TimeUnit.SECONDS)) {\n             if (log.isTraceEnabled()) {\n-                log.trace(\"Day is \" + myDay + \" for \" + key);\n+              log.trace(\"could not add day! converting \" + myEntry + \" to \" + prevDay);\n             }\n+            prevDay = myEntry;\n+          }\n+        } catch (InterruptedException exception) {\n+          prevDay = myEntry;\n         }\n-        return myDay;\n-    }\n-    \n-    public RangeStreamScanner setShardsPerDayThreshold(int shardsPerDayThreshold) {\n-        this.shardsPerDayThreshold = shardsPerDayThreshold;\n-        return this;\n-    }\n-    \n-    @Override\n-    public RangeStreamScanner call() throws Exception {\n-        findTop();\n-        return this;\n+\n+        currentQueue.clear();\n+\n+      } else {\n+        retrievalCount += dequeue();\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n-    \n-    /**\n-     * FindTop -- Follows the logic outlined in the comments, below. Effectively, we continue\n-     * \n-     * @throws Exception\n-     * \n-     */\n-    protected void findTop() throws Exception {\n-        if (ranges.isEmpty() && lastSeenKey == null) {\n+    return retrievalCount;\n+  }\n+\n+  private int dequeue() {\n+    return dequeue(false);\n+  }\n+\n+  private int dequeue(boolean forceAll) {\n+    int count = 0;\n+\n+    Queue<Entry<Key, Value>> kvIter = Queues.newArrayDeque(currentQueue);\n+\n+    currentQueue.clear();\n+    boolean result = true;\n+    for (Entry<Key, Value> top : kvIter) {\n+\n+      if (result) {\n+        do {\n+          result = resultQueue.offer(top);\n+\n+          if (!result) {\n             if (log.isTraceEnabled()) {\n-                log.trace(\"Finished\");\n+              log.trace(\"Failed adding \" + resultQueue.size() + \" \" + forceAll);\n             }\n-            finished = true;\n-            if (flushNeeded()) {\n-                if (log.isTraceEnabled())\n-                    log.trace(\"flush needed\");\n-                flush();\n-                return;\n+            if (forceAll) {\n+              continue;\n             }\n-            return;\n+          }\n+\n+          break;\n+        } while (!finished && forceAll);\n+      }\n+\n+      if (!result && !(!finished && forceAll)) {\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"Adding \" + top.getKey() + \" back \");\n         }\n-        \n-        ScannerBase baseScanner = null;\n-        try {\n-            if (resultQueue.remainingCapacity() == 0) {\n-                return;\n-            }\n-            \n-            /*\n-             * Even though we were delegated a resource, we have not actually been provided the plumbing to run it. Note, below, that we initialize the resource\n-             * through the resource factory from a running resource.\n-             */\n-            if (null != stats)\n-                stats.getTimer(TIMERS.SCANNER_START).resume();\n-            \n-            baseScanner = scannerFactory.newSingleScanner(tableName, auths, settings);\n-            \n-            if (baseScanner instanceof Scanner)\n-                ((Scanner) baseScanner).setReadaheadThreshold(Long.MAX_VALUE);\n-            \n-            for (Column family : options.getFetchedColumns()) {\n-                if (family.columnQualifier != null)\n-                    baseScanner.fetchColumn(new Text(family.columnFamily), new Text(family.columnQualifier));\n-                else {\n-                    if (log.isTraceEnabled())\n-                        log.trace(\"Setting column family \" + new Text(family.columnFamily));\n-                    baseScanner.fetchColumnFamily(new Text(family.columnFamily));\n-                }\n-            }\n-            for (IteratorSetting setting : options.getIterators()) {\n-                if (log.isTraceEnabled())\n-                    log.trace(\"Adding setting, \" + setting);\n-                baseScanner.addScanIterator(setting);\n-            }\n-            \n-            // if we have just started or we are at the end of the current range. pop the next range\n-            if (lastSeenKey == null || (currentRange != null && currentRange.getEndKey() != null && isBeyondRange(lastSeenKey, currentRange.getEndKey()))) {\n-                currentRange = ranges.poll();\n-                // short circuit and exit\n-                if (null == currentRange) {\n-                    lastSeenKey = null;\n-                    return;\n-                }\n-            } else {\n-                // adjust the end key range.\n-                currentRange = buildNextRange(lastSeenKey, currentRange);\n-                \n-                if (log.isTraceEnabled())\n-                    log.trace(\"Building \" + currentRange + \" from \" + lastSeenKey);\n-            }\n-            \n-            if (log.isTraceEnabled()) {\n-                log.trace(lastSeenKey + \", using current range of \" + lastRange);\n-                log.trace(lastSeenKey + \", using current range of \" + currentRange);\n-            }\n-            if (baseScanner instanceof Scanner)\n-                ((Scanner) baseScanner).setRange(currentRange);\n-            else if (baseScanner instanceof RfileScanner) {\n-                ((RfileScanner) baseScanner).setRanges(Collections.singleton(currentRange));\n-            }\n-            \n-            Iterator<Entry<Key,Value>> iter = baseScanner.iterator();\n-            \n-            // do not continue if we've reached the end of the corpus\n-            \n-            if (!iter.hasNext()) {\n-                if (log.isTraceEnabled()) {\n-                    log.trace(\"We've started, but we have nothing to do on \" + tableName + \" \" + auths + \" \" + currentRange);\n-                }\n-                lastSeenKey = null;\n-                return;\n-            }\n-            \n-            int retrievalCount = 0;\n-            try {\n-                if (null != stats) {\n-                    stats.getTimer(TIMERS.SCANNER_ITERATE).resume();\n-                }\n-                retrievalCount = scannerInvariant(iter);\n-            } finally {\n-                if (null != stats) {\n-                    stats.incrementKeysSeen(retrievalCount);\n-                    stats.getTimer(TIMERS.SCANNER_ITERATE).suspend();\n-                }\n-            }\n-        } catch (IllegalArgumentException e) {\n-            /*\n-             * If we get an illegal argument exception, we know that the ScannerSession extending class created a start key after our end key, which means that\n-             * we've finished with this range. As a result, we set lastSeenKey to null, so that on our next pass through, we pop the next range from the queue\n-             * and continue or finish. We're going to timeslice and come back as know this range is likely finished.\n-             */\n-            if (log.isTraceEnabled())\n-                log.trace(lastSeenKey + \" is lastSeenKey, previous range is \" + currentRange, e);\n-            \n-            lastSeenKey = null;\n-            \n-        } catch (Exception e) {\n-            \n-            log.error(e);\n-            throw e;\n-            \n-        } finally {\n-            \n-            if (null != stats)\n-                stats.getTimer(TIMERS.SCANNER_START).suspend();\n-            \n-            scannerFactory.close(baseScanner);\n-            // no point in running again\n-            if (ranges.isEmpty() && lastSeenKey == null) {\n-                finished = true;\n-            }\n+        currentQueue.add(top);\n+      } else {\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"missing \" + top.getKey() + \" true? \" + result);\n         }\n+      }\n+\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Last key is \" + lastSeenKey);\n+      }\n+\n+      count++;\n     }\n-    \n-    private boolean isBeyondRange(Key lastSeenKey, Key endKey) {\n-        if (lastSeenKey.compareTo(endKey) >= 0) {\n-            return true;\n+\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"we have \" + currentQueue.size() + \" \" + kvIter.size());\n+    }\n+\n+    return count;\n+  }\n+\n+  @Override\n+  protected void flush() {\n+    writeLock.lock();\n+    try {\n+      dequeue(false);\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n+\n+  protected boolean flushNeeded() {\n+    readLock.lock();\n+    try {\n+      return !currentQueue.isEmpty();\n+    } finally {\n+      readLock.unlock();\n+    }\n+  }\n+\n+  /**\n+   * Get the day from the key\n+   *\n+   * @param key\n+   * @return\n+   */\n+  protected String getDay(final Key key) {\n+    String myDay = null;\n+    byte[] cq = key.getColumnQualifierData().getBackingArray();\n+    if (cq.length >= dateCfLength) {\n+      myDay = new String(cq, 0, dateCfLength);\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Day is \" + myDay + \" for \" + key);\n+      }\n+    }\n+    return myDay;\n+  }\n+\n+  public RangeStreamScanner setShardsPerDayThreshold(int shardsPerDayThreshold) {\n+    this.shardsPerDayThreshold = shardsPerDayThreshold;\n+    return this;\n+  }\n+\n+  @Override\n+  public RangeStreamScanner call() throws Exception {\n+    findTop();\n+    return this;\n+  }\n+\n+  /**\n+   * FindTop -- Follows the logic outlined in the comments, below. Effectively, we continue\n+   *\n+   * @throws Exception\n+   */\n+  protected void findTop() throws Exception {\n+    if (ranges.isEmpty() && lastSeenKey == null) {\n+      if (log.isTraceEnabled()) {\n+        log.trace(\"Finished\");\n+      }\n+      finished = true;\n+      if (flushNeeded()) {\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"flush needed\");\n+        }\n+        flush();\n+        return;\n+      }\n+      return;\n+    }\n+\n+    ScannerBase baseScanner = null;\n+    try {\n+      if (resultQueue.remainingCapacity() == 0) {\n+        return;\n+      }\n+\n+      /*\n+       * Even though we were delegated a resource, we have not actually been provided the plumbing to run it. Note, below, that we initialize the resource\n+       * through the resource factory from a running resource.\n+       */\n+      if (null != stats) {\n+        stats.getTimer(TIMERS.SCANNER_START).resume();\n+      }\n+\n+      baseScanner = scannerFactory.newSingleScanner(tableName, auths, settings);\n+\n+      if (baseScanner instanceof Scanner) {\n+        ((Scanner) baseScanner).setReadaheadThreshold(Long.MAX_VALUE);\n+      }\n+\n+      for (Column family : options.getFetchedColumns()) {\n+        if (family.columnQualifier != null) {\n+          baseScanner.fetchColumn(new Text(family.columnFamily), new Text(family.columnQualifier));\n         } else {\n-            \n-            String cf = lastSeenKey.getColumnQualifier().toString();\n-            String endCf = endKey.getColumnQualifier().toString();\n-            \n-            if (log.isTraceEnabled()) {\n-                log.trace(cf + \" \" + endCf);\n-            }\n-            \n-            if (dateCfLength == cf.length()) {\n-                endCf = endCf.substring(0, dateCfLength);\n-                if (cf.compareTo(endCf) >= 0) {\n-                    return true;\n-                }\n-            }\n-            return false;\n+          if (log.isTraceEnabled()) {\n+            log.trace(\"Setting column family \" + new Text(family.columnFamily));\n+          }\n+          baseScanner.fetchColumnFamily(new Text(family.columnFamily));\n+        }\n+      }\n+      for (IteratorSetting setting : options.getIterators()) {\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"Adding setting, \" + setting);\n+        }\n+        baseScanner.addScanIterator(setting);\n+      }\n+\n+      // if we have just started or we are at the end of the current range. pop the next range\n+      if (lastSeenKey == null || (currentRange != null && currentRange.getEndKey() != null &&\n+          isBeyondRange(lastSeenKey, currentRange.getEndKey()))) {\n+        currentRange = ranges.poll();\n+        // short circuit and exit\n+        if (null == currentRange) {\n+          lastSeenKey = null;\n+          return;\n+        }\n+      } else {\n+        // adjust the end key range.\n+        currentRange = buildNextRange(lastSeenKey, currentRange);\n+\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"Building \" + currentRange + \" from \" + lastSeenKey);\n+        }\n+      }\n+\n+      if (log.isTraceEnabled()) {\n+        log.trace(lastSeenKey + \", using current range of \" + lastRange);\n+        log.trace(lastSeenKey + \", using current range of \" + currentRange);\n+      }\n+      if (baseScanner instanceof Scanner) {\n+        ((Scanner) baseScanner).setRange(currentRange);\n+      } else if (baseScanner instanceof RfileScanner) {\n+        ((RfileScanner) baseScanner).setRanges(Collections.singleton(currentRange));\n+      }\n+\n+      Iterator<Entry<Key, Value>> iter = baseScanner.iterator();\n+\n+      // do not continue if we've reached the end of the corpus\n+\n+      if (!iter.hasNext()) {\n+        if (log.isTraceEnabled()) {\n+          log.trace(\"We've started, but we have nothing to do on \" + tableName + \" \" + auths + \" \" + currentRange);\n+        }\n+        lastSeenKey = null;\n+        return;\n+      }\n+\n+      int retrievalCount = 0;\n+      try {\n+        if (null != stats) {\n+          stats.getTimer(TIMERS.SCANNER_ITERATE).resume();\n+        }\n+        retrievalCount = scannerInvariant(iter);\n+      } finally {\n+        if (null != stats) {\n+          stats.incrementKeysSeen(retrievalCount);\n+          stats.getTimer(TIMERS.SCANNER_ITERATE).suspend();\n+        }\n+      }\n+    } catch (IllegalArgumentException e) {\n+      /*\n+       * If we get an illegal argument exception, we know that the ScannerSession extending class created a start key after our end key, which means that\n+       * we've finished with this range. As a result, we set lastSeenKey to null, so that on our next pass through, we pop the next range from the queue\n+       * and continue or finish. We're going to timeslice and come back as know this range is likely finished.\n+       */\n+      if (log.isTraceEnabled()) {\n+        log.trace(lastSeenKey + \" is lastSeenKey, previous range is \" + currentRange, e);\n+      }\n+\n+      lastSeenKey = null;\n+\n+    } catch (Exception e) {\n+\n+      log.error(e);\n+      throw e;\n+\n+    } finally {\n+\n+      if (null != stats) {\n+        stats.getTimer(TIMERS.SCANNER_START).suspend();\n+      }\n+\n+      scannerFactory.close(baseScanner);\n+      // no point in running again\n+      if (ranges.isEmpty() && lastSeenKey == null) {\n+        finished = true;\n+      }\n+    }\n+  }\n+\n+  private boolean isBeyondRange(Key lastSeenKey, Key endKey) {\n+    if (lastSeenKey.compareTo(endKey) >= 0) {\n+      return true;\n+    } else {\n+\n+      String cf = lastSeenKey.getColumnQualifier().toString();\n+      String endCf = endKey.getColumnQualifier().toString();\n+\n+      if (log.isTraceEnabled()) {\n+        log.trace(cf + \" \" + endCf);\n+      }\n+\n+      if (dateCfLength == cf.length()) {\n+        endCf = endCf.substring(0, dateCfLength);\n+        if (cf.compareTo(endCf) >= 0) {\n+          return true;\n         }\n+      }\n+      return false;\n     }\n+  }\n }\n",
            "diff_size": 920
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "38",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/93/RangeStreamScanner.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/93/RangeStreamScanner.java\nindex 24b8fa9ae3f..2151799d060 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/93/RangeStreamScanner.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/93/RangeStreamScanner.java\n@@ -176,7 +176,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             while (null == currentEntry && (!finished || !resultQueue.isEmpty() || flushNeeded())) {\n                 \n                 try {\n-                    /*\n+    /*\n                      * Poll for one second. We're in a do/while loop that will break iff we are no longer running or there is a current entry available.\n                      */\n                     currentEntry = resultQueue.poll(getPollTime(), TimeUnit.MILLISECONDS);\n@@ -301,7 +301,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                         }\n                         \n                         IndexInfo info = new IndexInfo();\n-                        try {\n+try {\n                             info.readFields(new DataInputStream(new ByteArrayInputStream(currentKeyValue.getValue().get())));\n                         } catch (IOException e) {\n                             throw new DatawaveFatalQueryException(e);\n@@ -313,8 +313,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                         \n                         stats.addValue(info.count());\n                         \n-                        if (currentQueue.size() <= shardsPerDayThreshold\n-                                        || (currentQueue.size() >= shardsPerDayThreshold && stats.getPercentile(50) < MAX_MEDIAN)) {\n+                        if (currentQueue.size() <= shardsPerDayThreshold || (currentQueue.size() >= shardsPerDayThreshold && stats.getPercentile(50) < MAX_MEDIAN)) {\n                             \n                             if (log.isTraceEnabled()) {\n                                 log.trace(\"adding our stats are \" + stats.getPercentile(50) + \" on \" + currentQueue.size());\n@@ -330,15 +329,13 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                         }\n                         lastSeenKey = kvIter.next().getKey();\n                     } else {\n-                        \n-                        int dequeueCount = dequeue();\n+    int dequeueCount = dequeue();\n                         retrievalCount += dequeueCount;\n                         int queueSize = currentQueue.size();\n                         dequeue(true);\n                         currentDay = null;\n-                        \n-                        if (dequeueCount != queueSize || retrievalCount <= Math.ceil(maxResults * 1.5)) {\n-                            break;\n+if (dequeueCount != queueSize || retrievalCount <= Math.ceil(maxResults * 1.5)) {\n+    break;\n                         }\n                     }\n                 }\n@@ -386,7 +383,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                 currentQueue.clear();\n                 \n             } else {\n-                retrievalCount += dequeue();\n+    retrievalCount += dequeue();\n             }\n         } finally {\n             writeLock.unlock();\n@@ -408,7 +405,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n         for (Entry<Key,Value> top : kvIter) {\n             \n             if (result) {\n-                do {\n+do {\n                     result = resultQueue.offer(top);\n                     \n                     if (!result) {\n@@ -417,9 +414,8 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                         if (forceAll)\n                             continue;\n                     }\n-                    \n-                    break;\n-                } while (!finished && forceAll);\n+break;\n+        } while (!finished && forceAll);\n             }\n             \n             if (!result && !(!finished && forceAll)) {\n@@ -528,8 +524,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             \n             baseScanner = scannerFactory.newSingleScanner(tableName, auths, settings);\n             \n-            if (baseScanner instanceof Scanner)\n-                ((Scanner) baseScanner).setReadaheadThreshold(Long.MAX_VALUE);\n+            if (baseScanner instanceof Scanner) ((Scanner) baseScanner).setReadaheadThreshold(Long.MAX_VALUE);\n             \n             for (Column family : options.getFetchedColumns()) {\n                 if (family.columnQualifier != null)\n@@ -608,9 +603,8 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             lastSeenKey = null;\n             \n         } catch (Exception e) {\n-            \n-            log.error(e);\n-            throw e;\n+    log.error(e);\n+throw e;\n             \n         } finally {\n             \n@@ -646,4 +640,4 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             return false;\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 20
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "36",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/93/RangeStreamScanner.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/93/RangeStreamScanner.java\nindex 24b8fa9ae3f..90a89f696e0 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/93/RangeStreamScanner.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/93/RangeStreamScanner.java\n@@ -18,7 +18,6 @@ import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n-\n import com.google.common.base.Throwables;\n import datawave.mr.bulk.RfileScanner;\n import datawave.query.index.lookup.IndexInfo;\n@@ -26,7 +25,6 @@ import datawave.query.index.lookup.IndexMatch;\n import datawave.query.exceptions.DatawaveFatalQueryException;\n import datawave.query.tables.stats.ScanSessionStats.TIMERS;\n import datawave.webservice.query.Query;\n-\n import org.apache.accumulo.core.client.IteratorSetting;\n import org.apache.accumulo.core.client.Scanner;\n import org.apache.accumulo.core.client.ScannerBase;\n@@ -40,7 +38,6 @@ import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;\n import org.apache.hadoop.io.Text;\n import org.apache.log4j.Logger;\n-\n import com.google.common.collect.Maps;\n import com.google.common.collect.Queues;\n import com.google.common.util.concurrent.MoreExecutors;\n@@ -53,8 +50,9 @@ import com.google.common.util.concurrent.MoreExecutors;\n  * \n  * \n  */\n+\n+\n public class RangeStreamScanner extends ScannerSession implements Callable<RangeStreamScanner> {\n-    \n     private static final int MAX_MEDIAN = 20;\n     private static final Logger log = Logger.getLogger(RangeStreamScanner.class);\n     private int shardsPerDayThreshold = Integer.MAX_VALUE;\n@@ -62,20 +60,14 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n     protected static final int dateCfLength = 8;\n     protected boolean seenUnexpectedKey = false;\n     protected Queue<Entry<Key,Value>> currentQueue;\n-    \n     protected Entry<Key,Value> prevDay = null;\n-    \n     protected ReentrantReadWriteLock queueLock = new ReentrantReadWriteLock(true);\n-    \n     protected Lock readLock;\n     protected Lock writeLock;\n-    \n     volatile boolean finished = false;\n-    \n     ExecutorService myExecutor;\n-    \n     protected ScannerFactory scannerFactory;\n-    \n+\n     @Override\n     protected String serviceName() {\n         String id = \"NoQueryId\";\n@@ -91,6 +83,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n      * @param delegator\n      * @param maxResults\n      */\n+\n     public RangeStreamScanner(String tableName, Set<Authorizations> auths, ResourceQueue delegator, int maxResults, Query settings) {\n         super(tableName, auths, delegator, maxResults, settings);\n         delegatedResourceInitializer = BatchResource.class;\n@@ -108,8 +101,8 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n      * @param delegator\n      * @param maxResults\n      */\n-    public RangeStreamScanner(String tableName, Set<Authorizations> auths, ResourceQueue delegator, int maxResults, Query settings, SessionOptions options,\n-                    Collection<Range> ranges) {\n+\n+    public RangeStreamScanner(String tableName, Set<Authorizations> auths, ResourceQueue delegator, int maxResults, Query settings, SessionOptions options, Collection<Range> ranges) {\n         super(tableName, auths, delegator, maxResults, settings, options, ranges);\n         delegatedResourceInitializer = BatchResource.class;\n         currentQueue = Queues.newArrayDeque();\n@@ -119,15 +112,15 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n         if (null != stats)\n             initializeTimers();\n     }\n-    \n+\n     public RangeStreamScanner(ScannerSession other) {\n         this(other.tableName, other.auths, other.sessionDelegator, other.maxResults, other.settings, other.options, other.ranges);\n     }\n-    \n+\n     public void setExecutor(ExecutorService service) {\n         myExecutor = service;\n     }\n-    \n+\n     public RangeStreamScanner setScannerFactory(ScannerFactory factory) {\n         this.scannerFactory = factory;\n         return this;\n@@ -146,6 +139,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n      * @param lastKey\n      * @param previousRange\n      */\n+\n     @Override\n     public Range buildNextRange(final Key lastKey, final Range previousRange) {\n         \n@@ -155,8 +149,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n          * account for this, we put \\uffff after the null byte so that we start key is technically the last value within the provided shard, moving us to the\n          * exact next key within our RangeStream\n          */\n-        return new Range(new Key(lastKey.getRow(), lastKey.getColumnFamily(), new Text(lastKey.getColumnQualifier() + \"\\uffff\")), true,\n-                        previousRange.getEndKey(), previousRange.isEndKeyInclusive());\n+        return new Range(new Key(lastKey.getRow(), lastKey.getColumnFamily(), new Text(lastKey.getColumnQualifier() + \"\\uffff\")), true, previousRange.getEndKey(), previousRange.isEndKeyInclusive());\n     }\n     \n     /*\n@@ -164,6 +157,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n      * \n      * @see java.util.Iterator#hasNext()\n      */\n+\n     @Override\n     public boolean hasNext() {\n         /*\n@@ -172,21 +166,20 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n         try {\n             if (null != stats)\n                 stats.getTimer(TIMERS.HASNEXT).resume();\n-            \n             while (null == currentEntry && (!finished || !resultQueue.isEmpty() || flushNeeded())) {\n-                \n                 try {\n                     /*\n                      * Poll for one second. We're in a do/while loop that will break iff we are no longer running or there is a current entry available.\n                      */\n                     currentEntry = resultQueue.poll(getPollTime(), TimeUnit.MILLISECONDS);\n-                    \n                 } catch (InterruptedException e) {\n                     log.error(e);\n                     throw new RuntimeException(e);\n                 }\n                 // if we pulled no data and we are not running, and there is no data in the queue\n                 // we can flush if needed and retry\n+\n+\n                 if (currentEntry == null && (!finished && resultQueue.isEmpty())) {\n                     submitTask();\n                 } else if (flushNeeded()) {\n@@ -201,6 +194,8 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                     log.error(e);\n                 }\n             }\n+\n+\n             if (uncaughtExceptionHandler.getThrowable() != null) {\n                 log.error(\"Exception discovered on hasNext call\", uncaughtExceptionHandler.getThrowable());\n                 Throwables.propagate(uncaughtExceptionHandler.getThrowable());\n@@ -208,7 +203,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n         }\n         return (null != currentEntry);\n     }\n-    \n+\n     private void submitTask() {\n         // wait on results. submit the task if we can\n         Future<RangeStreamScanner> future = myExecutor.submit(this);\n@@ -224,6 +219,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n      * \n      * @see com.google.common.util.concurrent.AbstractExecutionThreadService#run()\n      */\n+\n     @Override\n     protected void run() {\n         try {\n@@ -234,16 +230,12 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             Throwables.propagate(e);\n         }\n     }\n-    \n+\n     protected int scannerInvariant(final Iterator<Entry<Key,Value>> iter) {\n         PeekingIterator<Entry<Key,Value>> kvIter = new PeekingIterator<>(iter);\n-        \n         int retrievalCount = 0;\n-        \n         Entry<Key,Value> myEntry;\n-        \n         String currentDay = null;\n-        \n         if (null != prevDay) {\n             try {\n                 if (log.isTraceEnabled())\n@@ -257,13 +249,12 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             }\n         }\n         // produces stats for us, so we don't have to!\n+\n         DescriptiveStatistics stats = new DescriptiveStatistics();\n-        \n         writeLock.lock();\n         try {\n             while (kvIter.hasNext()) {\n                 Entry<Key,Value> currentKeyValue = kvIter.peek();\n-                \n                 IndexInfo infos = new IndexInfo();\n                 try {\n                     infos.readFields(new DataInputStream(new ByteArrayInputStream(currentKeyValue.getValue().get())));\n@@ -277,21 +268,21 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                 }\n                 \n                 // become a pass-through if we've seen an unexpected key.\n+\n+\n                 if (seenUnexpectedKey) {\n                     currentQueue.add(currentKeyValue);\n                     break;\n                 }\n-                \n+\n+\n                 if (null == currentDay) {\n                     if (log.isTraceEnabled()) {\n                         log.trace(\"it's a new day!\");\n                         log.trace(\"adding \" + currentKeyValue.getKey() + \" to queue because it matches\" + currentDay);\n                     }\n-                    \n                     currentDay = getDay(currentKeyValue.getKey());\n-                    \n                     currentQueue.add(currentKeyValue);\n-                    \n                     lastSeenKey = kvIter.next().getKey();\n                 } else {\n                     String nextKeysDay = getDay(currentKeyValue.getKey());\n@@ -299,29 +290,24 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                         if (log.isTraceEnabled()) {\n                             log.trace(\"adding \" + currentKeyValue.getKey() + \" to queue because it matches\" + currentDay);\n                         }\n-                        \n+\n                         IndexInfo info = new IndexInfo();\n                         try {\n                             info.readFields(new DataInputStream(new ByteArrayInputStream(currentKeyValue.getValue().get())));\n                         } catch (IOException e) {\n                             throw new DatawaveFatalQueryException(e);\n                         }\n-                        \n+\n+\n                         if (log.isTraceEnabled()) {\n                             log.trace(\"adding count of \" + info.count());\n                         }\n-                        \n                         stats.addValue(info.count());\n-                        \n-                        if (currentQueue.size() <= shardsPerDayThreshold\n-                                        || (currentQueue.size() >= shardsPerDayThreshold && stats.getPercentile(50) < MAX_MEDIAN)) {\n-                            \n+                        if (currentQueue.size() <= shardsPerDayThreshold || (currentQueue.size() >= shardsPerDayThreshold && stats.getPercentile(50) < MAX_MEDIAN)) {\n                             if (log.isTraceEnabled()) {\n                                 log.trace(\"adding our stats are \" + stats.getPercentile(50) + \" on \" + currentQueue.size());\n                             }\n-                            \n                             currentQueue.add(currentKeyValue);\n-                            \n                         } else {\n                             if (log.isTraceEnabled()) {\n                                 log.trace(\"breaking because our stats are \" + stats.getPercentile(50) + \" on \" + currentQueue.size());\n@@ -330,48 +316,41 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                         }\n                         lastSeenKey = kvIter.next().getKey();\n                     } else {\n-                        \n                         int dequeueCount = dequeue();\n                         retrievalCount += dequeueCount;\n+\n                         int queueSize = currentQueue.size();\n                         dequeue(true);\n                         currentDay = null;\n-                        \n                         if (dequeueCount != queueSize || retrievalCount <= Math.ceil(maxResults * 1.5)) {\n                             break;\n                         }\n                     }\n                 }\n             }\n-            \n+\n+\n             if (currentQueue.size() >= shardsPerDayThreshold && stats.getPercentile(50) > MAX_MEDIAN) {\n-                \n                 Entry<Key,Value> top = currentQueue.poll();\n-                \n                 Key topKey = top.getKey();\n                 if (log.isTraceEnabled())\n                     log.trace(topKey + \" for \" + currentDay + \" exceeds limit of \" + shardsPerDayThreshold + \" with \" + currentQueue.size());\n+\n                 Key newKey = new Key(topKey.getRow(), topKey.getColumnFamily(), new Text(currentDay), topKey.getColumnVisibility(), topKey.getTimestamp());\n-                \n                 IndexInfo info = new IndexInfo(-1);\n-                \n                 Value newValue;\n                 try {\n                     ByteArrayOutputStream outByteStream = new ByteArrayOutputStream();\n                     DataOutputStream outDataStream = new DataOutputStream(outByteStream);\n                     info.write(outDataStream);\n-                    \n                     outDataStream.close();\n                     outByteStream.close();\n-                    \n                     newValue = new Value(outByteStream.toByteArray());\n                 } catch (IOException e) {\n                     throw new DatawaveFatalQueryException(e);\n                 }\n-                \n                 myEntry = Maps.immutableEntry(newKey, newValue);\n                 lastSeenKey = newKey;\n-                \n                 try {\n                     if (!resultQueue.offer(myEntry, 1, TimeUnit.SECONDS)) {\n                         if (log.isTraceEnabled()) {\n@@ -382,9 +361,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                 } catch (InterruptedException exception) {\n                     prevDay = myEntry;\n                 }\n-                \n                 currentQueue.clear();\n-                \n             } else {\n                 retrievalCount += dequeue();\n             }\n@@ -393,35 +370,31 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n         }\n         return retrievalCount;\n     }\n-    \n+\n     private int dequeue() {\n         return dequeue(false);\n     }\n-    \n+\n     private int dequeue(boolean forceAll) {\n         int count = 0;\n-        \n         Queue<Entry<Key,Value>> kvIter = Queues.newArrayDeque(currentQueue);\n-        \n         currentQueue.clear();\n         boolean result = true;\n         for (Entry<Key,Value> top : kvIter) {\n-            \n             if (result) {\n                 do {\n                     result = resultQueue.offer(top);\n-                    \n                     if (!result) {\n                         if (log.isTraceEnabled())\n                             log.trace(\"Failed adding \" + resultQueue.size() + \" \" + forceAll);\n                         if (forceAll)\n                             continue;\n                     }\n-                    \n                     break;\n                 } while (!finished && forceAll);\n             }\n-            \n+\n+\n             if (!result && !(!finished && forceAll)) {\n                 if (log.isTraceEnabled())\n                     log.trace(\"Adding \" + top.getKey() + \" back \");\n@@ -430,20 +403,20 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                 if (log.isTraceEnabled())\n                     log.trace(\"missing \" + top.getKey() + \" true? \" + result);\n             }\n-            \n+\n+\n             if (log.isTraceEnabled())\n                 log.trace(\"Last key is \" + lastSeenKey);\n-            \n             count++;\n         }\n-        \n+\n+\n         if (log.isTraceEnabled()) {\n             log.trace(\"we have \" + currentQueue.size() + \" \" + kvIter.size());\n         }\n-        \n         return count;\n     }\n-    \n+\n     @Override\n     protected void flush() {\n         writeLock.lock();\n@@ -453,7 +426,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             writeLock.unlock();\n         }\n     }\n-    \n+\n     protected boolean flushNeeded() {\n         readLock.lock();\n         try {\n@@ -469,6 +442,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n      * @param key\n      * @return\n      */\n+\n     protected String getDay(final Key key) {\n         String myDay = null;\n         byte[] cq = key.getColumnQualifierData().getBackingArray();\n@@ -480,12 +454,12 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n         }\n         return myDay;\n     }\n-    \n+\n     public RangeStreamScanner setShardsPerDayThreshold(int shardsPerDayThreshold) {\n         this.shardsPerDayThreshold = shardsPerDayThreshold;\n         return this;\n     }\n-    \n+\n     @Override\n     public RangeStreamScanner call() throws Exception {\n         findTop();\n@@ -498,6 +472,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n      * @throws Exception\n      * \n      */\n+\n     protected void findTop() throws Exception {\n         if (ranges.isEmpty() && lastSeenKey == null) {\n             if (log.isTraceEnabled()) {\n@@ -512,7 +487,7 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             }\n             return;\n         }\n-        \n+\n         ScannerBase baseScanner = null;\n         try {\n             if (resultQueue.remainingCapacity() == 0) {\n@@ -523,14 +498,14 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n              * Even though we were delegated a resource, we have not actually been provided the plumbing to run it. Note, below, that we initialize the resource\n              * through the resource factory from a running resource.\n              */\n+\n+\n             if (null != stats)\n                 stats.getTimer(TIMERS.SCANNER_START).resume();\n-            \n             baseScanner = scannerFactory.newSingleScanner(tableName, auths, settings);\n-            \n             if (baseScanner instanceof Scanner)\n                 ((Scanner) baseScanner).setReadaheadThreshold(Long.MAX_VALUE);\n-            \n+\n             for (Column family : options.getFetchedColumns()) {\n                 if (family.columnQualifier != null)\n                     baseScanner.fetchColumn(new Text(family.columnFamily), new Text(family.columnQualifier));\n@@ -547,6 +522,8 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             }\n             \n             // if we have just started or we are at the end of the current range. pop the next range\n+\n+\n             if (lastSeenKey == null || (currentRange != null && currentRange.getEndKey() != null && isBeyondRange(lastSeenKey, currentRange.getEndKey()))) {\n                 currentRange = ranges.poll();\n                 // short circuit and exit\n@@ -557,25 +534,25 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             } else {\n                 // adjust the end key range.\n                 currentRange = buildNextRange(lastSeenKey, currentRange);\n-                \n                 if (log.isTraceEnabled())\n                     log.trace(\"Building \" + currentRange + \" from \" + lastSeenKey);\n             }\n-            \n+\n+\n             if (log.isTraceEnabled()) {\n                 log.trace(lastSeenKey + \", using current range of \" + lastRange);\n                 log.trace(lastSeenKey + \", using current range of \" + currentRange);\n             }\n-            if (baseScanner instanceof Scanner)\n-                ((Scanner) baseScanner).setRange(currentRange);\n+\n+\n+            if (baseScanner instanceof Scanner) ((Scanner) baseScanner).setRange(currentRange);\n             else if (baseScanner instanceof RfileScanner) {\n                 ((RfileScanner) baseScanner).setRanges(Collections.singleton(currentRange));\n             }\n-            \n+\n             Iterator<Entry<Key,Value>> iter = baseScanner.iterator();\n             \n             // do not continue if we've reached the end of the corpus\n-            \n             if (!iter.hasNext()) {\n                 if (log.isTraceEnabled()) {\n                     log.trace(\"We've started, but we have nothing to do on \" + tableName + \" \" + auths + \" \" + currentRange);\n@@ -583,7 +560,6 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n                 lastSeenKey = null;\n                 return;\n             }\n-            \n             int retrievalCount = 0;\n             try {\n                 if (null != stats) {\n@@ -604,19 +580,13 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n              */\n             if (log.isTraceEnabled())\n                 log.trace(lastSeenKey + \" is lastSeenKey, previous range is \" + currentRange, e);\n-            \n             lastSeenKey = null;\n-            \n         } catch (Exception e) {\n-            \n             log.error(e);\n             throw e;\n-            \n         } finally {\n-            \n             if (null != stats)\n                 stats.getTimer(TIMERS.SCANNER_START).suspend();\n-            \n             scannerFactory.close(baseScanner);\n             // no point in running again\n             if (ranges.isEmpty() && lastSeenKey == null) {\n@@ -624,19 +594,18 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             }\n         }\n     }\n-    \n+\n     private boolean isBeyondRange(Key lastSeenKey, Key endKey) {\n         if (lastSeenKey.compareTo(endKey) >= 0) {\n             return true;\n         } else {\n-            \n             String cf = lastSeenKey.getColumnQualifier().toString();\n             String endCf = endKey.getColumnQualifier().toString();\n-            \n             if (log.isTraceEnabled()) {\n                 log.trace(cf + \" \" + endCf);\n             }\n-            \n+\n+\n             if (dateCfLength == cf.length()) {\n                 endCf = endCf.substring(0, dateCfLength);\n                 if (cf.compareTo(endCf) >= 0) {\n@@ -646,4 +615,4 @@ public class RangeStreamScanner extends ScannerSession implements Callable<Range\n             return false;\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 123
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "38",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "38",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}