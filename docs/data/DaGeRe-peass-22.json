{
    "project_name": "DaGeRe-peass",
    "error_id": "22",
    "information": {
        "errors": [
            {
                "line": "172",
                "severity": "error",
                "message": "Line is longer than 200 characters (found 202).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "\t}\n\n\tprivate static boolean analysePotentialChange(final PerformanceChange change, final ConfidenceInterval previous, final Map.Entry<String, List<Result>> entry, final ConfidenceInterval interval) {\n\t\tLOG.trace(\"Vergleiche: {} {} Version: {}\", change.getTestClass(), change.getTestMethod(), change.getRevisionOld());\n\t\tboolean isChange = false;\n\t\tfinal double diff = change.getDifference();",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "172",
                    "severity": "error",
                    "message": "Line is longer than 200 characters (found 334).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "172",
                    "column": "55",
                    "severity": "error",
                    "message": "'(' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "172",
                    "column": "55",
                    "severity": "error",
                    "message": "'(' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.MethodParamPadCheck"
                },
                {
                    "line": "172",
                    "column": "88",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "172",
                    "column": "124",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "172",
                    "column": "136",
                    "severity": "error",
                    "message": "'.' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceAfterCheck"
                },
                {
                    "line": "172",
                    "column": "144",
                    "severity": "error",
                    "message": "'<' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "144",
                    "severity": "error",
                    "message": "'<' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "153",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "172",
                    "column": "160",
                    "severity": "error",
                    "message": "'<' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "160",
                    "severity": "error",
                    "message": "'<' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "169",
                    "severity": "error",
                    "message": "'>' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "169",
                    "severity": "error",
                    "message": "'>' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "171",
                    "severity": "error",
                    "message": "'>' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "179",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "172",
                    "column": "215",
                    "severity": "error",
                    "message": "')' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "172",
                    "column": "217",
                    "severity": "error",
                    "message": "'{' at column 210 should have line break after.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/22/MeasurementAnalysationUtil.java\nindex 7f865782d1a..360961b3db5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler/22/MeasurementAnalysationUtil.java\n@@ -169,8 +169,7 @@ public final class MeasurementAnalysationUtil {\n \t\treturn data.getTestcases().getTestcase().get(0).getDatacollector().get(0).getResult();\n \t}\n \n-\tprivate static boolean analysePotentialChange(final PerformanceChange change, final ConfidenceInterval previous, final Map.Entry<String, List<Result>> entry, final ConfidenceInterval interval) {\n-\t\tLOG.trace(\"Vergleiche: {} {} Version: {}\", change.getTestClass(), change.getTestMethod(), change.getRevisionOld());\n+\tprivate static boolean analysePotentialChange ( final PerformanceChange change , final ConfidenceInterval previous , final Map . Entry < String , List < Result > > entry , final ConfidenceInterval interval ) { LOG .trace(\"Vergleiche: {} {} Version: {}\", change.getTestClass(), change.getTestMethod(), change.getRevisionOld());\n \t\tboolean isChange = false;\n \t\tfinal double diff = change.getDifference();\n \t\tLOG.debug(\"Teste: {}:{} - {} vs. vorher {}\", change.getRevision(), change.getRevisionOld(), interval, previous);\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/22/MeasurementAnalysationUtil.java\nindex 7f865782d1a..96ba2490fcb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/intellij/22/MeasurementAnalysationUtil.java\n@@ -32,194 +32,194 @@ import de.peran.statistics.PerformanceChange;\n \n public final class MeasurementAnalysationUtil {\n \n-\tprivate MeasurementAnalysationUtil() {\n-\n-\t}\n-\n-\tprivate static final Logger LOG = LogManager.getLogger(MeasurementAnalysationUtil.class);\n-\n-\tstatic long earliestVersion = Long.MAX_VALUE;\n-\tstatic long lastVersion = Long.MIN_VALUE;\n-\n-\tpublic static final double MIN_NORMED_DISTANCE = 0.5;\n-\tpublic static final double MIN_ABSOLUTE_PERCENTAGE_DISTANCE = 0.2;\n-\n-\tprivate static final Random RANDOM = new Random();\n-\n-\tpublic static Map<File, Kopemedata> getData(final File file) throws JAXBException {\n-\t\tfinal Map<File, Kopemedata> data = new HashMap<>();\n-\t\tLOG.debug(\"Analysiere: {}\", file);\n-\t\tif (file.isDirectory()) {\n-\t\t\tfinal Collection<File> fileList = FileUtils.listFiles(file, new WildcardFileFilter(\"*.xml\"), FalseFileFilter.INSTANCE);\n-\t\t\tfor (final File xmlFile : fileList) {\n-\t\t\t\tLOG.trace(\"Datei: {}\", xmlFile);\n-\t\t\t\tfinal XMLDataLoader xdl = new XMLDataLoader(xmlFile);\n-\t\t\t\tdata.put(xmlFile, xdl.getFullData());\n-\t\t\t}\n-\t\t}\n-\t\treturn data;\n-\t}\n-\n-\tpublic static ChangeData getChanges(final File[] files) throws JAXBException {\n-\t\tfinal ChangeData revisionChangeMap = new ChangeData();\n-\n-\t\tint fileCount = 0;\n-\t\tfor (int i = 0; i < files.length; i++) {\n-\t\t\tfinal LinkedHashMap<PerformanceChange, File> allChanges = new LinkedHashMap<>();\n-\t\t\tfinal File file = files[i];\n-\t\t\t// allChanges.put(file, new LinkedList<>());\n-\t\t\tLOG.debug(\"Analysiere: {}\", file);\n-\t\t\tif (file.isDirectory()) {\n-\t\t\t\tfinal Map<File, Kopemedata> dataList = getData(file);\n-\t\t\t\tfileCount += dataList.size();\n-\t\t\t\tint finishedFiles = 0;\n-\t\t\t\tfor (final Map.Entry<File, Kopemedata> data : dataList.entrySet()) {\n-\t\t\t\t\t// if (data.getKey().getName().contains(\"testMakeDirectoryOnly\")){\n-\t\t\t\t\tLOG.debug(\"Analysiere {} / {} {} \", finishedFiles, dataList.size(), data.getKey());\n-\t\t\t\t\tfinal List<PerformanceChange> currentChanges = analyzeKopemeData(data.getValue());\n-\t\t\t\t\tcurrentChanges.forEach(change -> allChanges.put(change, file));\n-\t\t\t\t\tfinishedFiles++;\n-\t\t\t\t\t// }\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tLOG.error(\"{} ist kein Verzeichnis.\", file);\n-\t\t\t}\n-\t\t\tLOG.info(\"\u00c4nderungen: {}  / {} (Versionen {} bis {})\", allChanges.size(), fileCount, earliestVersion, lastVersion);\n-\n-\t\t\tfor (final Map.Entry<PerformanceChange, File> entry : allChanges.entrySet()) {\n-\t\t\t\trevisionChangeMap.addChange(entry.getKey(), entry.getValue());\n-\t\t\t}\n-\n-\t\t\tLOG.debug(\"\u00c4nderungen in Versionen: {}\", revisionChangeMap.getAllChanges().size());\n-\t\t}\n-\n-\t\treturn revisionChangeMap;\n-\t}\n-\n-\tpublic static List<PerformanceChange> analyzeKopemeData(final Kopemedata data) {\n-\t\tfinal Map<String, List<Result>> results = new LinkedHashMap<>();\n-\t\tint maxResultSize = 0;\n-\t\tfinal TestcaseType currentTestcase = data.getTestcases().getTestcase().get(0);\n-\t\tfinal String clazz = data.getTestcases().getClazz();\n-\t\tfinal String method = currentTestcase.getName();\n-\t\tfinal List<Datacollector> datacollectors = currentTestcase.getDatacollector();\n-\t\tif (datacollectors.size() != 1) {\n-\t\t\tLOG.warn(\"Mehr als ein DataCollector bei: {}\", method);\n-\t\t}\n-\t\tfor (final Result result : datacollectors.get(0).getResult()) {\n-\t\t\tfinal String gitversion = result.getVersion().getGitversion();\n-\t\t\tif (!results.containsKey(gitversion)) {\n-\t\t\t\tresults.put(gitversion, new LinkedList<>());\n-\t\t\t}\n-\t\t\tresults.get(gitversion).add(result);\n-\t\t\tif (results.get(gitversion).size() > maxResultSize) {\n-\t\t\t\tmaxResultSize = results.get(gitversion).size();\n-\t\t\t}\n-\t\t}\n-\n-\t\tConfidenceInterval previous = null;\n-\t\tString previousVersion = null;\n-\t\tfinal List<PerformanceChange> changes = new LinkedList<>();\n-\n-\t\tfinal ExecutorService service = Executors.newFixedThreadPool(4);\n-\n-\t\tfor (final Map.Entry<String, List<Result>> entry : results.entrySet()) {\n-\t\t\tfinal double[] values = getAveragesArrayFromResults(entry.getValue());\n-\t\t\tfinal ConfidenceInterval interval = getBootstrapConfidenceInterval(values, 20, 1000, 96);\n-\t\t\tLOG.trace(\"{}-Konfidenzintervall: {} - {}\", interval.getPercentage(), interval.getMin(), interval.getMax());\n-\t\t\tif (previous != null) {\n-\t\t\t\tfinal ConfidenceInterval previousConfidenceInterval = previous;\n-\t\t\t\tfinal String previousVersion2 = previousVersion;\n-\t\t\t\tLOG.trace(\"Start \" + previousVersion2);\n-\t\t\t\tservice.execute(new Runnable() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\tfinal String currentVersion = entry.getValue().get(0).getVersion().getGitversion();\n-\t\t\t\t\t\tfinal PerformanceChange change = new PerformanceChange(previousConfidenceInterval, interval, clazz, method, previousVersion2, currentVersion);\n-\t\t\t\t\t\tfinal boolean isChange = analysePotentialChange(change, previousConfidenceInterval, entry, interval);\n-\t\t\t\t\t\tif (isChange) {\n-\t\t\t\t\t\t\tchanges.add(change);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n-\t\t\tprevious = interval;\n-\t\t\tpreviousVersion = entry.getKey();\n-\t\t}\n-\t\ttry {\n-\t\t\tservice.shutdown();\n-\t\t\tservice.awaitTermination(1, TimeUnit.DAYS);\n-\t\t} catch (final InterruptedException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t\treturn changes;\n-\t}\n-\n-\tpublic static double[] getAveragesArrayFromResults(final List<Result> results) {\n-\t\tfinal double[] values = new double[results.size()];\n-\t\tint i = 0;\n-\t\tfor (final Result result : results) {\n-\t\t\tfinal double value = result.getValue();\n-\t\t\tvalues[i++] = value;\n-\t\t}\n-\t\treturn values;\n-\t}\n-\n-\tpublic static List<Result> getResult(final Kopemedata data) {\n-\t\treturn data.getTestcases().getTestcase().get(0).getDatacollector().get(0).getResult();\n-\t}\n-\n-\tprivate static boolean analysePotentialChange(final PerformanceChange change, final ConfidenceInterval previous, final Map.Entry<String, List<Result>> entry, final ConfidenceInterval interval) {\n-\t\tLOG.trace(\"Vergleiche: {} {} Version: {}\", change.getTestClass(), change.getTestMethod(), change.getRevisionOld());\n-\t\tboolean isChange = false;\n-\t\tfinal double diff = change.getDifference();\n-\t\tLOG.debug(\"Teste: {}:{} - {} vs. vorher {}\", change.getRevision(), change.getRevisionOld(), interval, previous);\n-\t\tif (interval.getMax() < previous.getMin()) {\n-\t\t\tif (change.getNormedDifference() > MIN_NORMED_DISTANCE && diff > MIN_ABSOLUTE_PERCENTAGE_DISTANCE * previous.getMax()) {\n-\t\t\t\tLOG.debug(\"\u00c4nderung: {} {} Diff: {}\", change.getRevisionOld(), change.getTestMethod(), diff);\n-\t\t\t\tLOG.debug(\"Ist kleiner geworden: {} vs. vorher {}\", interval, previous);\n-\t\t\t\tLOG.trace(\"Abstand: {} Versionen: {}:{}\", diff, change.getRevisionOld(), entry.getKey());\n-\t\t\t\tisChange = true;\n-\t\t\t}\n-\t\t}\n-\t\tif (interval.getMin() > previous.getMax()) {\n-\t\t\tif (change.getNormedDifference() > MIN_NORMED_DISTANCE && diff > MIN_ABSOLUTE_PERCENTAGE_DISTANCE * previous.getMax()) {\n-\t\t\t\tLOG.debug(\"\u00c4nderung: {} {} Diff: {}\", change.getRevisionOld(), change.getTestMethod(), diff);\n-\t\t\t\tLOG.debug(\"Ist gr\u00f6\u00dfer geworden: {} vs. vorher {}\", interval, previous);\n-\t\t\t\tLOG.trace(\"Abstand: {} Versionen: {}:{}\", diff, change.getRevisionOld(), entry.getKey());\n-\t\t\t\tisChange = true;\n-\t\t\t}\n-\t\t}\n-\t\treturn isChange;\n-\t}\n-\n-\tpublic static ConfidenceInterval getBootstrapConfidenceInterval(final double[] values, final int count, final int repetitions, final int intervalPercentage) {\n-\t\tLOG.trace(\"Werte: {}\", values);\n-\t\tfinal DescriptiveStatistics statistics = new DescriptiveStatistics();\n-\t\tfor (int i = 0; i < repetitions; i++) {\n-\t\t\tfinal double[] tempValues = getBootstrapValues(values, count);\n-\t\t\tfinal SummaryStatistics st = new SummaryStatistics();\n-\t\t\tfor (final double value : tempValues) {\n-\t\t\t\tst.addValue(value);\n-\t\t\t}\n-\t\t\tfinal double bootstrapMean = st.getMean();\n-\t\t\tstatistics.addValue(bootstrapMean);\n-\t\t}\n-\n-\t\tLOG.trace(\"Mittelwert: {}\", statistics.getMean());\n-\n-\t\tfinal double upperBound = statistics.getPercentile(intervalPercentage);\n-\t\tfinal double lowerBound = statistics.getPercentile(100 - intervalPercentage);\n-\t\treturn new ConfidenceInterval(lowerBound, upperBound, intervalPercentage);\n-\t}\n-\n-\tpublic static double[] getBootstrapValues(final double[] values, final int count) {\n-\t\tfinal double[] result = new double[count];\n-\t\tfor (int i = 0; i < count; i++) {\n-\t\t\tfinal int nextInt = RANDOM.nextInt(values.length);\n-\t\t\t// System.out.println(nextInt);\n-\t\t\tresult[i] = values[nextInt];\n-\t\t}\n-\t\treturn result;\n-\t}\n+  private MeasurementAnalysationUtil() {\n+\n+  }\n+\n+  private static final Logger LOG = LogManager.getLogger(MeasurementAnalysationUtil.class);\n+\n+  static long earliestVersion = Long.MAX_VALUE;\n+  static long lastVersion = Long.MIN_VALUE;\n+\n+  public static final double MIN_NORMED_DISTANCE = 0.5;\n+  public static final double MIN_ABSOLUTE_PERCENTAGE_DISTANCE = 0.2;\n+\n+  private static final Random RANDOM = new Random();\n+\n+  public static Map<File, Kopemedata> getData(final File file) throws JAXBException {\n+    final Map<File, Kopemedata> data = new HashMap<>();\n+    LOG.debug(\"Analysiere: {}\", file);\n+    if (file.isDirectory()) {\n+      final Collection<File> fileList = FileUtils.listFiles(file, new WildcardFileFilter(\"*.xml\"), FalseFileFilter.INSTANCE);\n+      for (final File xmlFile : fileList) {\n+        LOG.trace(\"Datei: {}\", xmlFile);\n+        final XMLDataLoader xdl = new XMLDataLoader(xmlFile);\n+        data.put(xmlFile, xdl.getFullData());\n+      }\n+    }\n+    return data;\n+  }\n+\n+  public static ChangeData getChanges(final File[] files) throws JAXBException {\n+    final ChangeData revisionChangeMap = new ChangeData();\n+\n+    int fileCount = 0;\n+    for (int i = 0; i < files.length; i++) {\n+      final LinkedHashMap<PerformanceChange, File> allChanges = new LinkedHashMap<>();\n+      final File file = files[i];\n+      // allChanges.put(file, new LinkedList<>());\n+      LOG.debug(\"Analysiere: {}\", file);\n+      if (file.isDirectory()) {\n+        final Map<File, Kopemedata> dataList = getData(file);\n+        fileCount += dataList.size();\n+        int finishedFiles = 0;\n+        for (final Map.Entry<File, Kopemedata> data : dataList.entrySet()) {\n+          // if (data.getKey().getName().contains(\"testMakeDirectoryOnly\")){\n+          LOG.debug(\"Analysiere {} / {} {} \", finishedFiles, dataList.size(), data.getKey());\n+          final List<PerformanceChange> currentChanges = analyzeKopemeData(data.getValue());\n+          currentChanges.forEach(change -> allChanges.put(change, file));\n+          finishedFiles++;\n+          // }\n+        }\n+      } else {\n+        LOG.error(\"{} ist kein Verzeichnis.\", file);\n+      }\n+      LOG.info(\"\u00c4nderungen: {}  / {} (Versionen {} bis {})\", allChanges.size(), fileCount, earliestVersion, lastVersion);\n+\n+      for (final Map.Entry<PerformanceChange, File> entry : allChanges.entrySet()) {\n+        revisionChangeMap.addChange(entry.getKey(), entry.getValue());\n+      }\n+\n+      LOG.debug(\"\u00c4nderungen in Versionen: {}\", revisionChangeMap.getAllChanges().size());\n+    }\n+\n+    return revisionChangeMap;\n+  }\n+\n+  public static List<PerformanceChange> analyzeKopemeData(final Kopemedata data) {\n+    final Map<String, List<Result>> results = new LinkedHashMap<>();\n+    int maxResultSize = 0;\n+    final TestcaseType currentTestcase = data.getTestcases().getTestcase().get(0);\n+    final String clazz = data.getTestcases().getClazz();\n+    final String method = currentTestcase.getName();\n+    final List<Datacollector> datacollectors = currentTestcase.getDatacollector();\n+    if (datacollectors.size() != 1) {\n+      LOG.warn(\"Mehr als ein DataCollector bei: {}\", method);\n+    }\n+    for (final Result result : datacollectors.get(0).getResult()) {\n+      final String gitversion = result.getVersion().getGitversion();\n+      if (!results.containsKey(gitversion)) {\n+        results.put(gitversion, new LinkedList<>());\n+      }\n+      results.get(gitversion).add(result);\n+      if (results.get(gitversion).size() > maxResultSize) {\n+        maxResultSize = results.get(gitversion).size();\n+      }\n+    }\n+\n+    ConfidenceInterval previous = null;\n+    String previousVersion = null;\n+    final List<PerformanceChange> changes = new LinkedList<>();\n+\n+    final ExecutorService service = Executors.newFixedThreadPool(4);\n+\n+    for (final Map.Entry<String, List<Result>> entry : results.entrySet()) {\n+      final double[] values = getAveragesArrayFromResults(entry.getValue());\n+      final ConfidenceInterval interval = getBootstrapConfidenceInterval(values, 20, 1000, 96);\n+      LOG.trace(\"{}-Konfidenzintervall: {} - {}\", interval.getPercentage(), interval.getMin(), interval.getMax());\n+      if (previous != null) {\n+        final ConfidenceInterval previousConfidenceInterval = previous;\n+        final String previousVersion2 = previousVersion;\n+        LOG.trace(\"Start \" + previousVersion2);\n+        service.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            final String currentVersion = entry.getValue().get(0).getVersion().getGitversion();\n+            final PerformanceChange change = new PerformanceChange(previousConfidenceInterval, interval, clazz, method, previousVersion2, currentVersion);\n+            final boolean isChange = analysePotentialChange(change, previousConfidenceInterval, entry, interval);\n+            if (isChange) {\n+              changes.add(change);\n+            }\n+          }\n+        });\n+      }\n+      previous = interval;\n+      previousVersion = entry.getKey();\n+    }\n+    try {\n+      service.shutdown();\n+      service.awaitTermination(1, TimeUnit.DAYS);\n+    } catch (final InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+    return changes;\n+  }\n+\n+  public static double[] getAveragesArrayFromResults(final List<Result> results) {\n+    final double[] values = new double[results.size()];\n+    int i = 0;\n+    for (final Result result : results) {\n+      final double value = result.getValue();\n+      values[i++] = value;\n+    }\n+    return values;\n+  }\n+\n+  public static List<Result> getResult(final Kopemedata data) {\n+    return data.getTestcases().getTestcase().get(0).getDatacollector().get(0).getResult();\n+  }\n+\n+  private static boolean analysePotentialChange(final PerformanceChange change, final ConfidenceInterval previous, final Map.Entry<String, List<Result>> entry, final ConfidenceInterval interval) {\n+    LOG.trace(\"Vergleiche: {} {} Version: {}\", change.getTestClass(), change.getTestMethod(), change.getRevisionOld());\n+    boolean isChange = false;\n+    final double diff = change.getDifference();\n+    LOG.debug(\"Teste: {}:{} - {} vs. vorher {}\", change.getRevision(), change.getRevisionOld(), interval, previous);\n+    if (interval.getMax() < previous.getMin()) {\n+      if (change.getNormedDifference() > MIN_NORMED_DISTANCE && diff > MIN_ABSOLUTE_PERCENTAGE_DISTANCE * previous.getMax()) {\n+        LOG.debug(\"\u00c4nderung: {} {} Diff: {}\", change.getRevisionOld(), change.getTestMethod(), diff);\n+        LOG.debug(\"Ist kleiner geworden: {} vs. vorher {}\", interval, previous);\n+        LOG.trace(\"Abstand: {} Versionen: {}:{}\", diff, change.getRevisionOld(), entry.getKey());\n+        isChange = true;\n+      }\n+    }\n+    if (interval.getMin() > previous.getMax()) {\n+      if (change.getNormedDifference() > MIN_NORMED_DISTANCE && diff > MIN_ABSOLUTE_PERCENTAGE_DISTANCE * previous.getMax()) {\n+        LOG.debug(\"\u00c4nderung: {} {} Diff: {}\", change.getRevisionOld(), change.getTestMethod(), diff);\n+        LOG.debug(\"Ist gr\u00f6\u00dfer geworden: {} vs. vorher {}\", interval, previous);\n+        LOG.trace(\"Abstand: {} Versionen: {}:{}\", diff, change.getRevisionOld(), entry.getKey());\n+        isChange = true;\n+      }\n+    }\n+    return isChange;\n+  }\n+\n+  public static ConfidenceInterval getBootstrapConfidenceInterval(final double[] values, final int count, final int repetitions, final int intervalPercentage) {\n+    LOG.trace(\"Werte: {}\", values);\n+    final DescriptiveStatistics statistics = new DescriptiveStatistics();\n+    for (int i = 0; i < repetitions; i++) {\n+      final double[] tempValues = getBootstrapValues(values, count);\n+      final SummaryStatistics st = new SummaryStatistics();\n+      for (final double value : tempValues) {\n+        st.addValue(value);\n+      }\n+      final double bootstrapMean = st.getMean();\n+      statistics.addValue(bootstrapMean);\n+    }\n+\n+    LOG.trace(\"Mittelwert: {}\", statistics.getMean());\n+\n+    final double upperBound = statistics.getPercentile(intervalPercentage);\n+    final double lowerBound = statistics.getPercentile(100 - intervalPercentage);\n+    return new ConfidenceInterval(lowerBound, upperBound, intervalPercentage);\n+  }\n+\n+  public static double[] getBootstrapValues(final double[] values, final int count) {\n+    final double[] result = new double[count];\n+    for (int i = 0; i < count; i++) {\n+      final int nextInt = RANDOM.nextInt(values.length);\n+      // System.out.println(nextInt);\n+      result[i] = values[nextInt];\n+    }\n+    return result;\n+  }\n }\n",
            "diff_size": 190
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "172",
                    "severity": "error",
                    "message": "Line is longer than 200 characters (found 202).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/naturalize/22/MeasurementAnalysationUtil.java\nindex 7f865782d1a..ba80b4217c3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/naturalize/22/MeasurementAnalysationUtil.java\n@@ -222,4 +222,4 @@ public final class MeasurementAnalysationUtil {\n \t\t}\n \t\treturn result;\n \t}\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/22/MeasurementAnalysationUtil.java\nindex 7f865782d1a..8bbaffe074b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/codebuff/22/MeasurementAnalysationUtil.java\n@@ -11,9 +11,7 @@ import java.util.Random;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n-\n import javax.xml.bind.JAXBException;\n-\n import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.filefilter.FalseFileFilter;\n import org.apache.commons.io.filefilter.WildcardFileFilter;\n@@ -21,7 +19,6 @@ import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-\n import de.dagere.kopeme.datastorage.XMLDataLoader;\n import de.dagere.kopeme.generated.Kopemedata;\n import de.dagere.kopeme.generated.TestcaseType;\n@@ -30,196 +27,193 @@ import de.dagere.kopeme.generated.TestcaseType.Datacollector.Result;\n import de.peran.statistics.ConfidenceInterval;\n import de.peran.statistics.PerformanceChange;\n \n+\n public final class MeasurementAnalysationUtil {\n \n-\tprivate MeasurementAnalysationUtil() {\n-\n-\t}\n-\n-\tprivate static final Logger LOG = LogManager.getLogger(MeasurementAnalysationUtil.class);\n-\n-\tstatic long earliestVersion = Long.MAX_VALUE;\n-\tstatic long lastVersion = Long.MIN_VALUE;\n-\n-\tpublic static final double MIN_NORMED_DISTANCE = 0.5;\n-\tpublic static final double MIN_ABSOLUTE_PERCENTAGE_DISTANCE = 0.2;\n-\n-\tprivate static final Random RANDOM = new Random();\n-\n-\tpublic static Map<File, Kopemedata> getData(final File file) throws JAXBException {\n-\t\tfinal Map<File, Kopemedata> data = new HashMap<>();\n-\t\tLOG.debug(\"Analysiere: {}\", file);\n-\t\tif (file.isDirectory()) {\n-\t\t\tfinal Collection<File> fileList = FileUtils.listFiles(file, new WildcardFileFilter(\"*.xml\"), FalseFileFilter.INSTANCE);\n-\t\t\tfor (final File xmlFile : fileList) {\n-\t\t\t\tLOG.trace(\"Datei: {}\", xmlFile);\n-\t\t\t\tfinal XMLDataLoader xdl = new XMLDataLoader(xmlFile);\n-\t\t\t\tdata.put(xmlFile, xdl.getFullData());\n-\t\t\t}\n-\t\t}\n-\t\treturn data;\n-\t}\n-\n-\tpublic static ChangeData getChanges(final File[] files) throws JAXBException {\n-\t\tfinal ChangeData revisionChangeMap = new ChangeData();\n-\n-\t\tint fileCount = 0;\n-\t\tfor (int i = 0; i < files.length; i++) {\n-\t\t\tfinal LinkedHashMap<PerformanceChange, File> allChanges = new LinkedHashMap<>();\n-\t\t\tfinal File file = files[i];\n-\t\t\t// allChanges.put(file, new LinkedList<>());\n-\t\t\tLOG.debug(\"Analysiere: {}\", file);\n-\t\t\tif (file.isDirectory()) {\n-\t\t\t\tfinal Map<File, Kopemedata> dataList = getData(file);\n-\t\t\t\tfileCount += dataList.size();\n-\t\t\t\tint finishedFiles = 0;\n-\t\t\t\tfor (final Map.Entry<File, Kopemedata> data : dataList.entrySet()) {\n-\t\t\t\t\t// if (data.getKey().getName().contains(\"testMakeDirectoryOnly\")){\n-\t\t\t\t\tLOG.debug(\"Analysiere {} / {} {} \", finishedFiles, dataList.size(), data.getKey());\n-\t\t\t\t\tfinal List<PerformanceChange> currentChanges = analyzeKopemeData(data.getValue());\n-\t\t\t\t\tcurrentChanges.forEach(change -> allChanges.put(change, file));\n-\t\t\t\t\tfinishedFiles++;\n-\t\t\t\t\t// }\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tLOG.error(\"{} ist kein Verzeichnis.\", file);\n-\t\t\t}\n-\t\t\tLOG.info(\"\u00c4nderungen: {}  / {} (Versionen {} bis {})\", allChanges.size(), fileCount, earliestVersion, lastVersion);\n-\n-\t\t\tfor (final Map.Entry<PerformanceChange, File> entry : allChanges.entrySet()) {\n-\t\t\t\trevisionChangeMap.addChange(entry.getKey(), entry.getValue());\n-\t\t\t}\n-\n-\t\t\tLOG.debug(\"\u00c4nderungen in Versionen: {}\", revisionChangeMap.getAllChanges().size());\n-\t\t}\n-\n-\t\treturn revisionChangeMap;\n-\t}\n-\n-\tpublic static List<PerformanceChange> analyzeKopemeData(final Kopemedata data) {\n-\t\tfinal Map<String, List<Result>> results = new LinkedHashMap<>();\n-\t\tint maxResultSize = 0;\n-\t\tfinal TestcaseType currentTestcase = data.getTestcases().getTestcase().get(0);\n-\t\tfinal String clazz = data.getTestcases().getClazz();\n-\t\tfinal String method = currentTestcase.getName();\n-\t\tfinal List<Datacollector> datacollectors = currentTestcase.getDatacollector();\n-\t\tif (datacollectors.size() != 1) {\n-\t\t\tLOG.warn(\"Mehr als ein DataCollector bei: {}\", method);\n-\t\t}\n-\t\tfor (final Result result : datacollectors.get(0).getResult()) {\n-\t\t\tfinal String gitversion = result.getVersion().getGitversion();\n-\t\t\tif (!results.containsKey(gitversion)) {\n-\t\t\t\tresults.put(gitversion, new LinkedList<>());\n-\t\t\t}\n-\t\t\tresults.get(gitversion).add(result);\n-\t\t\tif (results.get(gitversion).size() > maxResultSize) {\n-\t\t\t\tmaxResultSize = results.get(gitversion).size();\n-\t\t\t}\n-\t\t}\n-\n-\t\tConfidenceInterval previous = null;\n-\t\tString previousVersion = null;\n-\t\tfinal List<PerformanceChange> changes = new LinkedList<>();\n-\n-\t\tfinal ExecutorService service = Executors.newFixedThreadPool(4);\n-\n-\t\tfor (final Map.Entry<String, List<Result>> entry : results.entrySet()) {\n-\t\t\tfinal double[] values = getAveragesArrayFromResults(entry.getValue());\n-\t\t\tfinal ConfidenceInterval interval = getBootstrapConfidenceInterval(values, 20, 1000, 96);\n-\t\t\tLOG.trace(\"{}-Konfidenzintervall: {} - {}\", interval.getPercentage(), interval.getMin(), interval.getMax());\n-\t\t\tif (previous != null) {\n-\t\t\t\tfinal ConfidenceInterval previousConfidenceInterval = previous;\n-\t\t\t\tfinal String previousVersion2 = previousVersion;\n-\t\t\t\tLOG.trace(\"Start \" + previousVersion2);\n-\t\t\t\tservice.execute(new Runnable() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\tfinal String currentVersion = entry.getValue().get(0).getVersion().getGitversion();\n-\t\t\t\t\t\tfinal PerformanceChange change = new PerformanceChange(previousConfidenceInterval, interval, clazz, method, previousVersion2, currentVersion);\n-\t\t\t\t\t\tfinal boolean isChange = analysePotentialChange(change, previousConfidenceInterval, entry, interval);\n-\t\t\t\t\t\tif (isChange) {\n-\t\t\t\t\t\t\tchanges.add(change);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n-\t\t\tprevious = interval;\n-\t\t\tpreviousVersion = entry.getKey();\n-\t\t}\n-\t\ttry {\n-\t\t\tservice.shutdown();\n-\t\t\tservice.awaitTermination(1, TimeUnit.DAYS);\n-\t\t} catch (final InterruptedException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t\treturn changes;\n-\t}\n-\n-\tpublic static double[] getAveragesArrayFromResults(final List<Result> results) {\n-\t\tfinal double[] values = new double[results.size()];\n-\t\tint i = 0;\n-\t\tfor (final Result result : results) {\n-\t\t\tfinal double value = result.getValue();\n-\t\t\tvalues[i++] = value;\n-\t\t}\n-\t\treturn values;\n-\t}\n-\n-\tpublic static List<Result> getResult(final Kopemedata data) {\n-\t\treturn data.getTestcases().getTestcase().get(0).getDatacollector().get(0).getResult();\n-\t}\n-\n-\tprivate static boolean analysePotentialChange(final PerformanceChange change, final ConfidenceInterval previous, final Map.Entry<String, List<Result>> entry, final ConfidenceInterval interval) {\n-\t\tLOG.trace(\"Vergleiche: {} {} Version: {}\", change.getTestClass(), change.getTestMethod(), change.getRevisionOld());\n-\t\tboolean isChange = false;\n-\t\tfinal double diff = change.getDifference();\n-\t\tLOG.debug(\"Teste: {}:{} - {} vs. vorher {}\", change.getRevision(), change.getRevisionOld(), interval, previous);\n-\t\tif (interval.getMax() < previous.getMin()) {\n-\t\t\tif (change.getNormedDifference() > MIN_NORMED_DISTANCE && diff > MIN_ABSOLUTE_PERCENTAGE_DISTANCE * previous.getMax()) {\n-\t\t\t\tLOG.debug(\"\u00c4nderung: {} {} Diff: {}\", change.getRevisionOld(), change.getTestMethod(), diff);\n-\t\t\t\tLOG.debug(\"Ist kleiner geworden: {} vs. vorher {}\", interval, previous);\n-\t\t\t\tLOG.trace(\"Abstand: {} Versionen: {}:{}\", diff, change.getRevisionOld(), entry.getKey());\n-\t\t\t\tisChange = true;\n-\t\t\t}\n-\t\t}\n-\t\tif (interval.getMin() > previous.getMax()) {\n-\t\t\tif (change.getNormedDifference() > MIN_NORMED_DISTANCE && diff > MIN_ABSOLUTE_PERCENTAGE_DISTANCE * previous.getMax()) {\n-\t\t\t\tLOG.debug(\"\u00c4nderung: {} {} Diff: {}\", change.getRevisionOld(), change.getTestMethod(), diff);\n-\t\t\t\tLOG.debug(\"Ist gr\u00f6\u00dfer geworden: {} vs. vorher {}\", interval, previous);\n-\t\t\t\tLOG.trace(\"Abstand: {} Versionen: {}:{}\", diff, change.getRevisionOld(), entry.getKey());\n-\t\t\t\tisChange = true;\n-\t\t\t}\n-\t\t}\n-\t\treturn isChange;\n-\t}\n-\n-\tpublic static ConfidenceInterval getBootstrapConfidenceInterval(final double[] values, final int count, final int repetitions, final int intervalPercentage) {\n-\t\tLOG.trace(\"Werte: {}\", values);\n-\t\tfinal DescriptiveStatistics statistics = new DescriptiveStatistics();\n-\t\tfor (int i = 0; i < repetitions; i++) {\n-\t\t\tfinal double[] tempValues = getBootstrapValues(values, count);\n-\t\t\tfinal SummaryStatistics st = new SummaryStatistics();\n-\t\t\tfor (final double value : tempValues) {\n-\t\t\t\tst.addValue(value);\n-\t\t\t}\n-\t\t\tfinal double bootstrapMean = st.getMean();\n-\t\t\tstatistics.addValue(bootstrapMean);\n-\t\t}\n-\n-\t\tLOG.trace(\"Mittelwert: {}\", statistics.getMean());\n-\n-\t\tfinal double upperBound = statistics.getPercentile(intervalPercentage);\n-\t\tfinal double lowerBound = statistics.getPercentile(100 - intervalPercentage);\n-\t\treturn new ConfidenceInterval(lowerBound, upperBound, intervalPercentage);\n-\t}\n-\n-\tpublic static double[] getBootstrapValues(final double[] values, final int count) {\n-\t\tfinal double[] result = new double[count];\n-\t\tfor (int i = 0; i < count; i++) {\n-\t\t\tfinal int nextInt = RANDOM.nextInt(values.length);\n-\t\t\t// System.out.println(nextInt);\n-\t\t\tresult[i] = values[nextInt];\n-\t\t}\n-\t\treturn result;\n-\t}\n-}\n+ private MeasurementAnalysationUtil() {\n+\n+ }\n+\n+ private static final Logger LOG = LogManager.getLogger(MeasurementAnalysationUtil.class);\n+ static long earliestVersion = Long.MAX_VALUE;\n+ static long lastVersion = Long.MIN_VALUE;\n+\n+ public static final double MIN_NORMED_DISTANCE = 0.5;\n+\n+ public static final double MIN_ABSOLUTE_PERCENTAGE_DISTANCE = 0.2;\n+ private static final Random RANDOM = new Random();\n+\n+ public static Map<File, Kopemedata> getData(final File file) throws JAXBException {\n+  final Map<File, Kopemedata> data = new HashMap<>();\n+  LOG.debug(\"Analysiere: {}\", file);\n+  if (file.isDirectory()) {\n+   final Collection<File> fileList = FileUtils.listFiles(file, new WildcardFileFilter(\"*.xml\"), FalseFileFilter.INSTANCE);\n+   for (final File xmlFile : fileList) {\n+    LOG.trace(\"Datei: {}\", xmlFile);\n+\n+    final XMLDataLoader xdl = new XMLDataLoader(xmlFile);\n+    data.put(xmlFile, xdl.getFullData());\n+   }\n+  }\n+  return data;\n+ }\n+\n+ public static ChangeData getChanges(final File[] files) throws JAXBException {\n+  final ChangeData revisionChangeMap = new ChangeData();\n+  int fileCount = 0;\n+  for (int i = 0; i < files.length; i++) {\n+   final LinkedHashMap<PerformanceChange, File> allChanges = new LinkedHashMap<>();\n+   final File file = files[i];\n+   // allChanges.put(file, new LinkedList<>());\n+   LOG.debug(\"Analysiere: {}\", file);\n+   if (file.isDirectory()) {\n+    final Map<File, Kopemedata> dataList = getData(file);\n+    fileCount += dataList.size();\n+    int finishedFiles = 0;\n+    for (final Map.Entry<File, Kopemedata> data : dataList.entrySet()) {\n+     // if (data.getKey().getName().contains(\"testMakeDirectoryOnly\")){\n+     LOG.debug(\"Analysiere {} / {} {} \", finishedFiles, dataList.size(), data.getKey());\n+\n+     final List<PerformanceChange> currentChanges = analyzeKopemeData(data.getValue());\n+     currentChanges.forEach(change -> allChanges.put(change, file));\n+     finishedFiles++;\n+     // }\n+    }\n+   } else {\n+    LOG.error(\"{} ist kein Verzeichnis.\", file);\n+   }\n+   LOG.info(\"\u00c4nderungen: {}  / {} (Versionen {} bis {})\", allChanges.size(), fileCount, earliestVersion, lastVersion);\n+   for (final Map.Entry<PerformanceChange, File> entry : allChanges.entrySet()) {\n+    revisionChangeMap.addChange(entry.getKey(), entry.getValue());\n+   }\n+   LOG.debug(\"\u00c4nderungen in Versionen: {}\", revisionChangeMap.getAllChanges().size());\n+  }\n+  return revisionChangeMap;\n+ }\n+\n+ public static List<PerformanceChange> analyzeKopemeData(final Kopemedata data) {\n+  final Map<String, List<Result>> results = new LinkedHashMap<>();\n+  int maxResultSize = 0;\n+  final TestcaseType currentTestcase = data.getTestcases().getTestcase().get(0);\n+  final String clazz = data.getTestcases().getClazz();\n+  final String method = currentTestcase.getName();\n+  final List<Datacollector> datacollectors = currentTestcase.getDatacollector();\n+  if (datacollectors.size() != 1) {\n+   LOG.warn(\"Mehr als ein DataCollector bei: {}\", method);\n+  }\n+\n+  for (final Result result : datacollectors.get(0).getResult()) {\n+   final String gitversion = result.getVersion().getGitversion();\n+   if (!results.containsKey(gitversion)) {\n+    results.put(gitversion, new LinkedList<>());\n+   }\n+   results.get(gitversion).add(result);\n+   if (results.get(gitversion).size() > maxResultSize) {\n+    maxResultSize = results.get(gitversion).size();\n+   }\n+  }\n+  ConfidenceInterval previous = null;\n+  String previousVersion = null;\n+  final List<PerformanceChange> changes = new LinkedList<>();\n+  final ExecutorService service = Executors.newFixedThreadPool(4);\n+  for (final Map.Entry<String, List<Result>> entry : results.entrySet()) {\n+   final double[] values = getAveragesArrayFromResults(entry.getValue());\n+   final ConfidenceInterval interval = getBootstrapConfidenceInterval(values, 20, 1000, 96);\n+   LOG.trace(\"{}-Konfidenzintervall: {} - {}\", interval.getPercentage(), interval.getMin(), interval.getMax());\n+   if (previous != null) {\n+    final ConfidenceInterval previousConfidenceInterval = previous;\n+    final String previousVersion2 = previousVersion;\n+    LOG.trace(\"Start \" + previousVersion2);\n+    service.execute(new Runnable() {\n+                     @Override\n+                     public void run() {\n+                      final String currentVersion = entry.getValue().get(0).getVersion().getGitversion();\n+                      final PerformanceChange change = new PerformanceChange(previousConfidenceInterval, interval, clazz, method, previousVersion2, currentVersion);\n+                      final boolean isChange = analysePotentialChange(change, previousConfidenceInterval, entry, interval);\n+                      if (isChange) {\n+                       changes.add(change);\n+                      }\n+                     }\n+                    });\n+   }\n+   previous = interval;\n+   previousVersion = entry.getKey();\n+  }\n+  try {\n+   service.shutdown();\n+   service.awaitTermination(1, TimeUnit.DAYS);\n+  } catch (final InterruptedException e) {\n+   e.printStackTrace();\n+  }\n+  return changes;\n+ }\n+\n+ public static double[] getAveragesArrayFromResults(final List<Result> results) {\n+  final double[] values = new double[results.size()];\n+  int i = 0;\n+  for (final Result result : results) {\n+   final double value = result.getValue();\n+   values[i++] = value;\n+  }\n+  return values;\n+ }\n+\n+ public static List<Result> getResult(final Kopemedata data) {\n+  return data.getTestcases().getTestcase().get(0).getDatacollector().get(0).getResult();\n+ }\n+\n+ private static boolean analysePotentialChange(final PerformanceChange change, final ConfidenceInterval previous, final Map.Entry<String, List<Result>> entry, final ConfidenceInterval interval) {\n+  LOG.trace(\"Vergleiche: {} {} Version: {}\", change.getTestClass(), change.getTestMethod(), change.getRevisionOld());\n+  boolean isChange = false;\n+  final double diff = change.getDifference();\n+  LOG.debug(\"Teste: {}:{} - {} vs. vorher {}\", change.getRevision(), change.getRevisionOld(), interval, previous);\n+  if (interval.getMax() < previous.getMin()) {\n+   if (change.getNormedDifference() > MIN_NORMED_DISTANCE && diff > MIN_ABSOLUTE_PERCENTAGE_DISTANCE * previous.getMax()) {\n+    LOG.debug(\"\u00c4nderung: {} {} Diff: {}\", change.getRevisionOld(), change.getTestMethod(), diff);\n+    LOG.debug(\"Ist kleiner geworden: {} vs. vorher {}\", interval, previous);\n+    LOG.trace(\"Abstand: {} Versionen: {}:{}\", diff, change.getRevisionOld(), entry.getKey());\n+    isChange = true;\n+   }\n+  }\n+  if (interval.getMin() > previous.getMax()) {\n+   if (change.getNormedDifference() > MIN_NORMED_DISTANCE && diff > MIN_ABSOLUTE_PERCENTAGE_DISTANCE * previous.getMax()) {\n+    LOG.debug(\"\u00c4nderung: {} {} Diff: {}\", change.getRevisionOld(), change.getTestMethod(), diff);\n+    LOG.debug(\"Ist gr\u00f6\u00dfer geworden: {} vs. vorher {}\", interval, previous);\n+    LOG.trace(\"Abstand: {} Versionen: {}:{}\", diff, change.getRevisionOld(), entry.getKey());\n+    isChange = true;\n+   }\n+  }\n+  return isChange;\n+ }\n+\n+ public static ConfidenceInterval getBootstrapConfidenceInterval(final double[] values, final int count, final int repetitions, final int intervalPercentage) {\n+  LOG.trace(\"Werte: {}\", values);\n+\n+  final DescriptiveStatistics statistics = new DescriptiveStatistics();\n+  for (int i = 0; i < repetitions; i++) {\n+   final double[] tempValues = getBootstrapValues(values, count);\n+   final SummaryStatistics st = new SummaryStatistics();\n+   for (final double value : tempValues) {\n+    st.addValue(value);\n+   }\n+\n+   final double bootstrapMean = st.getMean();\n+   statistics.addValue(bootstrapMean);\n+  }\n+  LOG.trace(\"Mittelwert: {}\", statistics.getMean());\n+\n+  final double upperBound = statistics.getPercentile(intervalPercentage);\n+  final double lowerBound = statistics.getPercentile(100 - intervalPercentage);\n+  return new ConfidenceInterval(lowerBound, upperBound, intervalPercentage);\n+ }\n+\n+ public static double[] getBootstrapValues(final double[] values, final int count) {\n+  final double[] result = new double[count];\n+  for (int i = 0; i < count; i++) {\n+   final int nextInt = RANDOM.nextInt(values.length);\n+   // System.out.println(nextInt);\n+   result[i] = values[nextInt];\n+  }\n+  return result;\n+ }\n+}\n\\ No newline at end of file\n",
            "diff_size": 195
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "172",
                    "severity": "error",
                    "message": "Line is longer than 200 characters (found 334).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "172",
                    "column": "55",
                    "severity": "error",
                    "message": "'(' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "172",
                    "column": "55",
                    "severity": "error",
                    "message": "'(' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.MethodParamPadCheck"
                },
                {
                    "line": "172",
                    "column": "88",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "172",
                    "column": "124",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "172",
                    "column": "136",
                    "severity": "error",
                    "message": "'.' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceAfterCheck"
                },
                {
                    "line": "172",
                    "column": "144",
                    "severity": "error",
                    "message": "'<' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "144",
                    "severity": "error",
                    "message": "'<' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "153",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "172",
                    "column": "160",
                    "severity": "error",
                    "message": "'<' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "160",
                    "severity": "error",
                    "message": "'<' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "169",
                    "severity": "error",
                    "message": "'>' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "169",
                    "severity": "error",
                    "message": "'>' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "171",
                    "severity": "error",
                    "message": "'>' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "172",
                    "column": "179",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                },
                {
                    "line": "172",
                    "column": "215",
                    "severity": "error",
                    "message": "')' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "172",
                    "column": "217",
                    "severity": "error",
                    "message": "'{' at column 210 should have line break after.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/22/MeasurementAnalysationUtil.java\nindex 7f865782d1a..360961b3db5 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/errored/1/22/MeasurementAnalysationUtil.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/DaGeRe-peass/styler_random/22/MeasurementAnalysationUtil.java\n@@ -169,8 +169,7 @@ public final class MeasurementAnalysationUtil {\n \t\treturn data.getTestcases().getTestcase().get(0).getDatacollector().get(0).getResult();\n \t}\n \n-\tprivate static boolean analysePotentialChange(final PerformanceChange change, final ConfidenceInterval previous, final Map.Entry<String, List<Result>> entry, final ConfidenceInterval interval) {\n-\t\tLOG.trace(\"Vergleiche: {} {} Version: {}\", change.getTestClass(), change.getTestMethod(), change.getRevisionOld());\n+\tprivate static boolean analysePotentialChange ( final PerformanceChange change , final ConfidenceInterval previous , final Map . Entry < String , List < Result > > entry , final ConfidenceInterval interval ) { LOG .trace(\"Vergleiche: {} {} Version: {}\", change.getTestClass(), change.getTestMethod(), change.getRevisionOld());\n \t\tboolean isChange = false;\n \t\tfinal double diff = change.getDifference();\n \t\tLOG.debug(\"Teste: {}:{} - {} vs. vorher {}\", change.getRevision(), change.getRevisionOld(), interval, previous);\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}