{
    "project_name": "graphfoundation-ongdb",
    "error_id": "1207",
    "information": {
        "errors": [
            {
                "line": "1",
                "severity": "error",
                "message": "Missing, wrong or duplicated license header",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "/*\n * Copyright (c) 2002-2020 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "95",
                    "column": "33",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "95",
                    "column": "68",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "97",
                    "column": "41",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "97",
                    "column": "76",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "99",
                    "column": "30",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "99",
                    "column": "73",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "101",
                    "column": "26",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "101",
                    "column": "69",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "103",
                    "column": "37",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "103",
                    "column": "112",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "109",
                    "column": "48",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "109",
                    "column": "83",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "114",
                    "column": "40",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "114",
                    "column": "75",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "124",
                    "column": "37",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "124",
                    "column": "80",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "129",
                    "column": "33",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "129",
                    "column": "76",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "134",
                    "column": "44",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "134",
                    "column": "119",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "180",
                    "column": "21",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "182",
                    "column": "66",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "195",
                    "column": "25",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "195",
                    "column": "37",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "199",
                    "column": "32",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "199",
                    "column": "94",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "206",
                    "column": "54",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "206",
                    "column": "102",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "210",
                    "column": "32",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "210",
                    "column": "55",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "211",
                    "column": "30",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "211",
                    "column": "38",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "217",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "217",
                    "column": "72",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "233",
                    "column": "24",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "233",
                    "column": "38",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "245",
                    "column": "27",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "245",
                    "column": "35",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "273",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "273",
                    "column": "36",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "275",
                    "column": "79",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "275",
                    "column": "98",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "276",
                    "column": "73",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "276",
                    "column": "110",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "277",
                    "column": "48",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "277",
                    "column": "112",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "279",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "279",
                    "column": "37",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "281",
                    "column": "51",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "281",
                    "column": "106",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "317",
                    "column": "77",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "317",
                    "column": "109",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "318",
                    "column": "68",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "319",
                    "column": "81",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "355",
                    "column": "31",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "355",
                    "column": "52",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "361",
                    "column": "77",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "361",
                    "column": "109",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "392",
                    "column": "85",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "394",
                    "column": "60",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "398",
                    "column": "44",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "399",
                    "column": "77",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "400",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "400",
                    "column": "28",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "403",
                    "column": "56",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "404",
                    "column": "32",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "409",
                    "column": "47",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "411",
                    "column": "60",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "415",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "415",
                    "column": "80",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "437",
                    "column": "11",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "437",
                    "column": "22",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "443",
                    "column": "30",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "443",
                    "column": "40",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "451",
                    "column": "43",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "452",
                    "column": "101",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "459",
                    "column": "44",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "467",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "468",
                    "column": "51",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "485",
                    "column": "38",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "485",
                    "column": "128",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "495",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "496",
                    "column": "50",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "499",
                    "column": "44",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "499",
                    "column": "106",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "500",
                    "column": "79",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "500",
                    "column": "105",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "501",
                    "column": "57",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "503",
                    "column": "57",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "505",
                    "column": "47",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "508",
                    "column": "91",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "535",
                    "column": "55",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "537",
                    "column": "137",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "539",
                    "column": "8",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "539",
                    "column": "34",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "549",
                    "column": "41",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "549",
                    "column": "79",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "552",
                    "column": "9",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "552",
                    "column": "51",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "554",
                    "column": "10",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "554",
                    "column": "23",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "562",
                    "column": "70",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "562",
                    "column": "113",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "567",
                    "column": "28",
                    "severity": "error",
                    "message": "'(' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                },
                {
                    "line": "567",
                    "column": "40",
                    "severity": "error",
                    "message": "')' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.ParenPadCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1207/ImportLogic.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1207/ImportLogic.java\nindex 9bfb8a06383..cb31472b467 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1207/ImportLogic.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/intellij/1207/ImportLogic.java\n@@ -17,6 +17,7 @@\n  * You should have received a copy of the GNU General Public License\n  * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n  */\n+\n package org.neo4j.unsafe.impl.batchimport;\n \n import java.io.Closeable;\n@@ -81,490 +82,490 @@ import static org.neo4j.unsafe.impl.batchimport.staging.ExecutionSupervisors.sup\n  * Contains all algorithms and logic for doing an import. It exposes all stages as methods so that\n  * it's possible to implement a {@link BatchImporter} which calls those.\n  * This class has state which typically gets modified in each invocation of an import method.\n- *\n+ * <p>\n  * To begin with the methods are fairly coarse-grained, but can and probably will be split up into smaller parts\n  * to allow external implementors have greater control over the flow.\n  */\n public class ImportLogic implements Closeable\n {\n-    public interface Monitor\n-    {\n-        void doubleRelationshipRecordUnitsEnabled();\n+  public interface Monitor\n+  {\n+    void doubleRelationshipRecordUnitsEnabled();\n \n-        void mayExceedNodeIdCapacity( long capacity, long estimatedCount );\n+    void mayExceedNodeIdCapacity(long capacity, long estimatedCount);\n \n-        void mayExceedRelationshipIdCapacity( long capacity, long estimatedCount );\n+    void mayExceedRelationshipIdCapacity(long capacity, long estimatedCount);\n \n-        void insufficientHeapSize( long optimalMinimalHeapSize, long heapSize );\n+    void insufficientHeapSize(long optimalMinimalHeapSize, long heapSize);\n \n-        void abundantHeapSize( long optimalMinimalHeapSize, long heapSize );\n-\n-        void insufficientAvailableMemory( long estimatedCacheSize, long optimalMinimalHeapSize, long availableMemory );\n-    }\n+    void abundantHeapSize(long optimalMinimalHeapSize, long heapSize);\n \n-    public static final Monitor NO_MONITOR = new Monitor()\n-    {\n-        @Override\n-        public void mayExceedRelationshipIdCapacity( long capacity, long estimatedCount )\n-        {   // no-op\n-        }\n-\n-        @Override\n-        public void mayExceedNodeIdCapacity( long capacity, long estimatedCount )\n-        {   // no-op\n-        }\n-\n-        @Override\n-        public void doubleRelationshipRecordUnitsEnabled()\n-        {   // no-op\n-        }\n-\n-        @Override\n-        public void insufficientHeapSize( long optimalMinimalHeapSize, long heapSize )\n-        {   // no-op\n-        }\n-\n-        @Override\n-        public void abundantHeapSize( long optimalMinimalHeapSize, long heapSize )\n-        {   // no-op\n-        }\n-\n-        @Override\n-        public void insufficientAvailableMemory( long estimatedCacheSize, long optimalMinimalHeapSize, long availableMemory )\n-        {   // no-op\n-        }\n-    };\n-\n-    private final File storeDir;\n-    private final FileSystemAbstraction fileSystem;\n-    private final BatchingNeoStores neoStore;\n-    private final Configuration config;\n-    private final Log log;\n-    private final ExecutionMonitor executionMonitor;\n-    private final RecordFormats recordFormats;\n-    private final DataImporter.Monitor storeUpdateMonitor = new DataImporter.Monitor();\n-    private final long maxMemory;\n-    private final Dependencies dependencies = new Dependencies();\n-    private final Monitor monitor;\n-    private Input input;\n-    private boolean successful;\n-\n-    // This map contains additional state that gets populated, created and used throughout the stages.\n-    // The reason that this is a map is to allow for a uniform way of accessing and loading this stage\n-    // from the outside. Currently these things live here:\n-    //   - RelationshipTypeDistribution\n-    private final Map<Class<?>,Object> accessibleState = new HashMap<>();\n-\n-    // components which may get assigned and unassigned in some methods\n-    private NodeRelationshipCache nodeRelationshipCache;\n-    private NodeLabelsCache nodeLabelsCache;\n-    private long startTime;\n-    private InputCache inputCache;\n-    private NumberArrayFactory numberArrayFactory;\n-    private Collector badCollector;\n-    private IdMapper idMapper;\n-    private long peakMemoryUsage;\n-    private long availableMemoryForLinking;\n-\n-    /**\n-     * @param storeDir directory which the db will be created in.\n-     * @param fileSystem {@link FileSystemAbstraction} that the {@code storeDir} lives in.\n-     * @param neoStore {@link BatchingNeoStores} to import into.\n-     * @param config import-specific {@link Configuration}.\n-     * @param logService {@link LogService} to use.\n-     * @param executionMonitor {@link ExecutionMonitor} to follow progress as the import proceeds.\n-     * @param recordFormats which {@link RecordFormats record format} to use for the created db.\n-     * @param monitor {@link Monitor} for some events.\n-     */\n-    public ImportLogic( File storeDir, FileSystemAbstraction fileSystem, BatchingNeoStores neoStore,\n-            Configuration config, LogService logService, ExecutionMonitor executionMonitor,\n-            RecordFormats recordFormats, Monitor monitor )\n-    {\n-        this.storeDir = storeDir;\n-        this.fileSystem = fileSystem;\n-        this.neoStore = neoStore;\n-        this.config = config;\n-        this.recordFormats = recordFormats;\n-        this.monitor = monitor;\n-        this.log = logService.getInternalLogProvider().getLog( getClass() );\n-        this.executionMonitor = ExecutionSupervisors.withDynamicProcessorAssignment( executionMonitor, config );\n-        this.maxMemory = config.maxMemoryUsage();\n-    }\n+    void insufficientAvailableMemory(long estimatedCacheSize, long optimalMinimalHeapSize, long availableMemory);\n+  }\n \n-    public void initialize( Input input ) throws IOException\n-    {\n-        log.info( \"Import starting\" );\n-        startTime = currentTimeMillis();\n-        inputCache = new InputCache( fileSystem, storeDir, recordFormats, toIntExact( mebiBytes( 1 ) ) );\n-        this.input = CachedInput.cacheAsNecessary( input, inputCache );\n-        PageCacheArrayFactoryMonitor numberArrayFactoryMonitor = new PageCacheArrayFactoryMonitor();\n-        numberArrayFactory = auto( neoStore.getPageCache(), storeDir, config.allowCacheAllocationOnHeap(), numberArrayFactoryMonitor );\n-        badCollector = input.badCollector();\n-        // Some temporary caches and indexes in the import\n-        idMapper = input.idMapper( numberArrayFactory );\n-        nodeRelationshipCache = new NodeRelationshipCache( numberArrayFactory, config.denseNodeThreshold() );\n-        Estimates inputEstimates = input.calculateEstimates( neoStore.getPropertyStore().newValueEncodedSizeCalculator() );\n-\n-        // Sanity checking against estimates\n-        new EstimationSanityChecker( recordFormats, monitor ).sanityCheck( inputEstimates );\n-        new HeapSizeSanityChecker( monitor ).sanityCheck( inputEstimates, recordFormats, neoStore,\n-                nodeRelationshipCache.memoryEstimation( inputEstimates.numberOfNodes() ),\n-                idMapper.memoryEstimation( inputEstimates.numberOfNodes() ) );\n-\n-        dependencies.satisfyDependencies( inputEstimates, idMapper, neoStore, nodeRelationshipCache, numberArrayFactoryMonitor );\n-\n-        if ( neoStore.determineDoubleRelationshipRecordUnits( inputEstimates ) )\n-        {\n-            monitor.doubleRelationshipRecordUnitsEnabled();\n-        }\n-\n-        executionMonitor.initialize( dependencies );\n-    }\n-\n-    /**\n-     * Accesses state of a certain {@code type}. This is state that may be long- or short-lived and perhaps\n-     * created in one part of the import to be used in another.\n-     *\n-     * @param type {@link Class} of the state to get.\n-     * @return the state of the given type.\n-     * @throws IllegalStateException if the state of the given {@code type} isn't available.\n-     */\n-    public <T> T getState( Class<T> type )\n-    {\n-        return type.cast( accessibleState.get( type ) );\n-    }\n-\n-    /**\n-     * Puts state of a certain type.\n-     *\n-     * @param state state instance to set.\n-     * @see #getState(Class)\n-     * @throws IllegalStateException if state of this type has already been defined.\n-     */\n-    public <T> void putState( T state )\n-    {\n-        accessibleState.put( state.getClass(), state );\n-        dependencies.satisfyDependency( state );\n+  public static final Monitor NO_MONITOR = new Monitor()\n+  {\n+    @Override\n+    public void mayExceedRelationshipIdCapacity(long capacity, long estimatedCount)\n+    {   // no-op\n     }\n \n-    /**\n-     * Imports nodes w/ their properties and labels from {@link Input#nodes()}. This will as a side-effect populate the {@link IdMapper},\n-     * to later be used for looking up ID --> nodeId in {@link #importRelationships()}. After a completed node import,\n-     * {@link #prepareIdMapper()} must be called.\n-     *\n-     * @throws IOException on I/O error.\n-     */\n-    public void importNodes() throws IOException\n-    {\n-        // Import nodes, properties, labels\n-        neoStore.startFlushingPageCache();\n-        DataImporter.importNodes( config.maxNumberOfProcessors(), input, neoStore, idMapper,\n-              executionMonitor, storeUpdateMonitor );\n-        neoStore.stopFlushingPageCache();\n-        updatePeakMemoryUsage();\n+    @Override\n+    public void mayExceedNodeIdCapacity(long capacity, long estimatedCount)\n+    {   // no-op\n     }\n \n-    /**\n-     * Prepares {@link IdMapper} to be queried for ID --> nodeId lookups. This is required for running {@link #importRelationships()}.\n-     */\n-    public void prepareIdMapper()\n-    {\n-        if ( idMapper.needsPreparation() )\n-        {\n-            MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider( neoStore, idMapper );\n-            LongFunction<Object> inputIdLookup = new NodeInputIdPropertyLookup( neoStore.getTemporaryPropertyStore() );\n-            executeStage( new IdMapperPreparationStage( config, idMapper, inputIdLookup, badCollector, memoryUsageStats ) );\n-            PrimitiveLongIterator duplicateNodeIds = idMapper.leftOverDuplicateNodesIds();\n-            if ( duplicateNodeIds.hasNext() )\n-            {\n-                executeStage( new DeleteDuplicateNodesStage( config, duplicateNodeIds, neoStore, storeUpdateMonitor ) );\n-            }\n-            updatePeakMemoryUsage();\n-        }\n+    @Override\n+    public void doubleRelationshipRecordUnitsEnabled()\n+    {   // no-op\n     }\n \n-    /**\n-     * Uses {@link IdMapper} as lookup for ID --> nodeId and imports all relationships from {@link Input#relationships()}\n-     * and writes them into the {@link RelationshipStore}. No linking between relationships is done in this method,\n-     * it's done later in {@link #linkRelationships(int)}.\n-     *\n-     * @throws IOException on I/O error.\n-     */\n-    public void importRelationships() throws IOException\n-    {\n-        // Import relationships (unlinked), properties\n-        neoStore.startFlushingPageCache();\n-        DataStatistics typeDistribution = DataImporter.importRelationships(\n-                config.maxNumberOfProcessors(), input, neoStore, idMapper, badCollector, executionMonitor, storeUpdateMonitor,\n-                !badCollector.isCollectingBadRelationships() );\n-        neoStore.stopFlushingPageCache();\n-        updatePeakMemoryUsage();\n-        idMapper.close();\n-        idMapper = null;\n-        putState( typeDistribution );\n+    @Override\n+    public void insufficientHeapSize(long optimalMinimalHeapSize, long heapSize)\n+    {   // no-op\n     }\n \n-    /**\n-     * Populates {@link NodeRelationshipCache} with node degrees, which is required to know how to physically layout each\n-     * relationship chain. This is required before running {@link #linkRelationships(int)}.\n-     */\n-    public void calculateNodeDegrees()\n-    {\n-        Configuration relationshipConfig =\n-                configWithRecordsPerPageBasedBatchSize( config, neoStore.getRelationshipStore() );\n-        nodeRelationshipCache.setNodeCount( neoStore.getNodeStore().getHighId() );\n-        MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider( neoStore, nodeRelationshipCache );\n-        NodeDegreeCountStage nodeDegreeStage = new NodeDegreeCountStage( relationshipConfig,\n-                neoStore.getRelationshipStore(), nodeRelationshipCache, memoryUsageStats );\n-        executeStage( nodeDegreeStage );\n-        nodeRelationshipCache.countingCompleted();\n-        availableMemoryForLinking = maxMemory - totalMemoryUsageOf( nodeRelationshipCache, neoStore );\n+    @Override\n+    public void abundantHeapSize(long optimalMinimalHeapSize, long heapSize)\n+    {   // no-op\n     }\n \n-    /**\n-     * Performs one round of linking together relationships with each other. Number of rounds required\n-     * is dictated by available memory. The more dense nodes and relationship types, the more memory required.\n-     * Every round all relationships of one or more types are linked.\n-     *\n-     * Links together:\n-     * <ul>\n-     * <li>\n-     * Relationship <--> Relationship. Two sequential passes are made over the relationship store.\n-     * The forward pass links next pointers, each next pointer pointing \"backwards\" to lower id.\n-     * The backward pass links prev pointers, each prev pointer pointing \"forwards\" to higher id.\n-     * </li>\n-     * Sparse Node --> Relationship. Sparse nodes are updated with relationship heads of completed chains.\n-     * This is done in the first round only, if there are multiple rounds.\n-     * </li>\n-     * </ul>\n-     *\n-     * A linking loop (from external caller POV) typically looks like:\n-     * <pre>\n-     * int type = 0;\n-     * do\n-     * {\n-     *    type = logic.linkRelationships( type );\n-     * }\n-     * while ( type != -1 );\n-     * </pre>\n-     *\n-     * @param startingFromType relationship type to start from.\n-     * @return the next relationship type to start linking and, if != -1, should be passed into next call to this method.\n-     */\n-    public int linkRelationships( int startingFromType )\n-    {\n-        assert startingFromType >= 0 : startingFromType;\n-\n-        // Link relationships together with each other, their nodes and their relationship groups\n-        DataStatistics relationshipTypeDistribution = getState( DataStatistics.class );\n-        MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider( neoStore, nodeRelationshipCache );\n-\n-        // Figure out which types we can fit in node-->relationship cache memory.\n-        // Types go from biggest to smallest group and so towards the end there will be\n-        // smaller and more groups per round in this loop\n-        int upToType = nextSetOfTypesThatFitInMemory(\n-                relationshipTypeDistribution, startingFromType, availableMemoryForLinking, nodeRelationshipCache.getNumberOfDenseNodes() );\n-\n-        PrimitiveIntSet typesToLinkThisRound = relationshipTypeDistribution.types( startingFromType, upToType );\n-        int typesImported = typesToLinkThisRound.size();\n-        boolean thisIsTheFirstRound = startingFromType == 0;\n-        boolean thisIsTheOnlyRound = thisIsTheFirstRound && upToType == relationshipTypeDistribution.getNumberOfRelationshipTypes();\n-\n-        Configuration relationshipConfig = configWithRecordsPerPageBasedBatchSize( config, neoStore.getRelationshipStore() );\n-        Configuration nodeConfig = configWithRecordsPerPageBasedBatchSize( config, neoStore.getNodeStore() );\n-        Configuration groupConfig = configWithRecordsPerPageBasedBatchSize( config, neoStore.getRelationshipGroupStore() );\n-\n-        nodeRelationshipCache.setForwardScan( true, true/*dense*/ );\n-        String range = typesToLinkThisRound.size() == 1\n-                ? String.valueOf( oneBased( startingFromType ) )\n-                : oneBased( startingFromType ) + \"-\" + (startingFromType + typesImported);\n-        String topic = \" \" + range + \"/\" + relationshipTypeDistribution.getNumberOfRelationshipTypes();\n-        int nodeTypes = thisIsTheFirstRound ? NodeType.NODE_TYPE_ALL : NodeType.NODE_TYPE_DENSE;\n-        Predicate<RelationshipRecord> readFilter = thisIsTheFirstRound\n-                ? alwaysTrue() // optimization when all rels are imported in this round\n-                : record -> typesToLinkThisRound.contains( record.getType() );\n-        Predicate<RelationshipRecord> denseChangeFilter = thisIsTheOnlyRound\n-                ? alwaysTrue() // optimization when all rels are imported in this round\n-                : record -> typesToLinkThisRound.contains( record.getType() );\n-\n-        // LINK Forward\n-        RelationshipLinkforwardStage linkForwardStage = new RelationshipLinkforwardStage( topic, relationshipConfig,\n-                neoStore, nodeRelationshipCache, readFilter, denseChangeFilter, nodeTypes,\n-                new RelationshipLinkingProgress(), memoryUsageStats );\n-        executeStage( linkForwardStage );\n-\n-        // Write relationship groups cached from the relationship import above\n-        executeStage( new RelationshipGroupStage( topic, groupConfig,\n-                neoStore.getTemporaryRelationshipGroupStore(), nodeRelationshipCache ) );\n-        if ( thisIsTheFirstRound )\n-        {\n-            // Set node nextRel fields for sparse nodes\n-            executeStage( new SparseNodeFirstRelationshipStage( nodeConfig, neoStore.getNodeStore(),\n-                    nodeRelationshipCache ) );\n-        }\n-\n-        // LINK backward\n-        nodeRelationshipCache.setForwardScan( false, true/*dense*/ );\n-        executeStage( new RelationshipLinkbackStage( topic, relationshipConfig, neoStore,\n-                nodeRelationshipCache, readFilter, denseChangeFilter, nodeTypes,\n-                new RelationshipLinkingProgress(), memoryUsageStats ) );\n-\n-        updatePeakMemoryUsage();\n-\n-        if ( upToType == relationshipTypeDistribution.getNumberOfRelationshipTypes() )\n-        {\n-            // This means that we've linked all the types\n-            nodeRelationshipCache.close();\n-            nodeRelationshipCache = null;\n-            return -1;\n-        }\n-\n-        return upToType;\n+    @Override\n+    public void insufficientAvailableMemory(long estimatedCacheSize, long optimalMinimalHeapSize, long availableMemory)\n+    {   // no-op\n     }\n-\n-    /**\n-     * Links relationships of all types, potentially doing multiple passes, each pass calling {@link #linkRelationships(int)}\n-     * with a type range.\n-     */\n-    public void linkRelationshipsOfAllTypes()\n+  };\n+\n+  private final File storeDir;\n+  private final FileSystemAbstraction fileSystem;\n+  private final BatchingNeoStores neoStore;\n+  private final Configuration config;\n+  private final Log log;\n+  private final ExecutionMonitor executionMonitor;\n+  private final RecordFormats recordFormats;\n+  private final DataImporter.Monitor storeUpdateMonitor = new DataImporter.Monitor();\n+  private final long maxMemory;\n+  private final Dependencies dependencies = new Dependencies();\n+  private final Monitor monitor;\n+  private Input input;\n+  private boolean successful;\n+\n+  // This map contains additional state that gets populated, created and used throughout the stages.\n+  // The reason that this is a map is to allow for a uniform way of accessing and loading this stage\n+  // from the outside. Currently these things live here:\n+  //   - RelationshipTypeDistribution\n+  private final Map<Class<?>, Object> accessibleState = new HashMap<>();\n+\n+  // components which may get assigned and unassigned in some methods\n+  private NodeRelationshipCache nodeRelationshipCache;\n+  private NodeLabelsCache nodeLabelsCache;\n+  private long startTime;\n+  private InputCache inputCache;\n+  private NumberArrayFactory numberArrayFactory;\n+  private Collector badCollector;\n+  private IdMapper idMapper;\n+  private long peakMemoryUsage;\n+  private long availableMemoryForLinking;\n+\n+  /**\n+   * @param storeDir         directory which the db will be created in.\n+   * @param fileSystem       {@link FileSystemAbstraction} that the {@code storeDir} lives in.\n+   * @param neoStore         {@link BatchingNeoStores} to import into.\n+   * @param config           import-specific {@link Configuration}.\n+   * @param logService       {@link LogService} to use.\n+   * @param executionMonitor {@link ExecutionMonitor} to follow progress as the import proceeds.\n+   * @param recordFormats    which {@link RecordFormats record format} to use for the created db.\n+   * @param monitor          {@link Monitor} for some events.\n+   */\n+  public ImportLogic(File storeDir, FileSystemAbstraction fileSystem, BatchingNeoStores neoStore,\n+                     Configuration config, LogService logService, ExecutionMonitor executionMonitor,\n+                     RecordFormats recordFormats, Monitor monitor)\n+  {\n+    this.storeDir = storeDir;\n+    this.fileSystem = fileSystem;\n+    this.neoStore = neoStore;\n+    this.config = config;\n+    this.recordFormats = recordFormats;\n+    this.monitor = monitor;\n+    this.log = logService.getInternalLogProvider().getLog(getClass());\n+    this.executionMonitor = ExecutionSupervisors.withDynamicProcessorAssignment(executionMonitor, config);\n+    this.maxMemory = config.maxMemoryUsage();\n+  }\n+\n+  public void initialize(Input input) throws IOException\n+  {\n+    log.info(\"Import starting\");\n+    startTime = currentTimeMillis();\n+    inputCache = new InputCache(fileSystem, storeDir, recordFormats, toIntExact(mebiBytes(1)));\n+    this.input = CachedInput.cacheAsNecessary(input, inputCache);\n+    PageCacheArrayFactoryMonitor numberArrayFactoryMonitor = new PageCacheArrayFactoryMonitor();\n+    numberArrayFactory = auto(neoStore.getPageCache(), storeDir, config.allowCacheAllocationOnHeap(), numberArrayFactoryMonitor);\n+    badCollector = input.badCollector();\n+    // Some temporary caches and indexes in the import\n+    idMapper = input.idMapper(numberArrayFactory);\n+    nodeRelationshipCache = new NodeRelationshipCache(numberArrayFactory, config.denseNodeThreshold());\n+    Estimates inputEstimates = input.calculateEstimates(neoStore.getPropertyStore().newValueEncodedSizeCalculator());\n+\n+    // Sanity checking against estimates\n+    new EstimationSanityChecker(recordFormats, monitor).sanityCheck(inputEstimates);\n+    new HeapSizeSanityChecker(monitor).sanityCheck(inputEstimates, recordFormats, neoStore,\n+        nodeRelationshipCache.memoryEstimation(inputEstimates.numberOfNodes()),\n+        idMapper.memoryEstimation(inputEstimates.numberOfNodes()));\n+\n+    dependencies.satisfyDependencies(inputEstimates, idMapper, neoStore, nodeRelationshipCache, numberArrayFactoryMonitor);\n+\n+    if (neoStore.determineDoubleRelationshipRecordUnits(inputEstimates))\n     {\n-        int type = 0;\n-        do\n-        {\n-            type = linkRelationships( type );\n-        }\n-        while ( type != -1 );\n+      monitor.doubleRelationshipRecordUnitsEnabled();\n     }\n \n-    /**\n-     * Convenience method (for code reading) to have a zero-based value become one based (for printing/logging).\n-     */\n-    private static int oneBased( int value )\n+    executionMonitor.initialize(dependencies);\n+  }\n+\n+  /**\n+   * Accesses state of a certain {@code type}. This is state that may be long- or short-lived and perhaps\n+   * created in one part of the import to be used in another.\n+   *\n+   * @param type {@link Class} of the state to get.\n+   * @return the state of the given type.\n+   * @throws IllegalStateException if the state of the given {@code type} isn't available.\n+   */\n+  public <T> T getState(Class<T> type)\n+  {\n+    return type.cast(accessibleState.get(type));\n+  }\n+\n+  /**\n+   * Puts state of a certain type.\n+   *\n+   * @param state state instance to set.\n+   * @throws IllegalStateException if state of this type has already been defined.\n+   * @see #getState(Class)\n+   */\n+  public <T> void putState(T state)\n+  {\n+    accessibleState.put(state.getClass(), state);\n+    dependencies.satisfyDependency(state);\n+  }\n+\n+  /**\n+   * Imports nodes w/ their properties and labels from {@link Input#nodes()}. This will as a side-effect populate the {@link IdMapper},\n+   * to later be used for looking up ID --> nodeId in {@link #importRelationships()}. After a completed node import,\n+   * {@link #prepareIdMapper()} must be called.\n+   *\n+   * @throws IOException on I/O error.\n+   */\n+  public void importNodes() throws IOException\n+  {\n+    // Import nodes, properties, labels\n+    neoStore.startFlushingPageCache();\n+    DataImporter.importNodes(config.maxNumberOfProcessors(), input, neoStore, idMapper,\n+        executionMonitor, storeUpdateMonitor);\n+    neoStore.stopFlushingPageCache();\n+    updatePeakMemoryUsage();\n+  }\n+\n+  /**\n+   * Prepares {@link IdMapper} to be queried for ID --> nodeId lookups. This is required for running {@link #importRelationships()}.\n+   */\n+  public void prepareIdMapper()\n+  {\n+    if (idMapper.needsPreparation())\n     {\n-        return value + 1;\n+      MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider(neoStore, idMapper);\n+      LongFunction<Object> inputIdLookup = new NodeInputIdPropertyLookup(neoStore.getTemporaryPropertyStore());\n+      executeStage(new IdMapperPreparationStage(config, idMapper, inputIdLookup, badCollector, memoryUsageStats));\n+      PrimitiveLongIterator duplicateNodeIds = idMapper.leftOverDuplicateNodesIds();\n+      if (duplicateNodeIds.hasNext())\n+      {\n+        executeStage(new DeleteDuplicateNodesStage(config, duplicateNodeIds, neoStore, storeUpdateMonitor));\n+      }\n+      updatePeakMemoryUsage();\n     }\n-\n-    /**\n-     * @return index (into {@link DataStatistics}) of last relationship type that fit in memory this round.\n-     */\n-    static int nextSetOfTypesThatFitInMemory( DataStatistics typeDistribution, int startingFromType,\n-            long freeMemoryForDenseNodeCache, long numberOfDenseNodes )\n+  }\n+\n+  /**\n+   * Uses {@link IdMapper} as lookup for ID --> nodeId and imports all relationships from {@link Input#relationships()}\n+   * and writes them into the {@link RelationshipStore}. No linking between relationships is done in this method,\n+   * it's done later in {@link #linkRelationships(int)}.\n+   *\n+   * @throws IOException on I/O error.\n+   */\n+  public void importRelationships() throws IOException\n+  {\n+    // Import relationships (unlinked), properties\n+    neoStore.startFlushingPageCache();\n+    DataStatistics typeDistribution = DataImporter.importRelationships(\n+        config.maxNumberOfProcessors(), input, neoStore, idMapper, badCollector, executionMonitor, storeUpdateMonitor,\n+        !badCollector.isCollectingBadRelationships());\n+    neoStore.stopFlushingPageCache();\n+    updatePeakMemoryUsage();\n+    idMapper.close();\n+    idMapper = null;\n+    putState(typeDistribution);\n+  }\n+\n+  /**\n+   * Populates {@link NodeRelationshipCache} with node degrees, which is required to know how to physically layout each\n+   * relationship chain. This is required before running {@link #linkRelationships(int)}.\n+   */\n+  public void calculateNodeDegrees()\n+  {\n+    Configuration relationshipConfig =\n+        configWithRecordsPerPageBasedBatchSize(config, neoStore.getRelationshipStore());\n+    nodeRelationshipCache.setNodeCount(neoStore.getNodeStore().getHighId());\n+    MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider(neoStore, nodeRelationshipCache);\n+    NodeDegreeCountStage nodeDegreeStage = new NodeDegreeCountStage(relationshipConfig,\n+        neoStore.getRelationshipStore(), nodeRelationshipCache, memoryUsageStats);\n+    executeStage(nodeDegreeStage);\n+    nodeRelationshipCache.countingCompleted();\n+    availableMemoryForLinking = maxMemory - totalMemoryUsageOf(nodeRelationshipCache, neoStore);\n+  }\n+\n+  /**\n+   * Performs one round of linking together relationships with each other. Number of rounds required\n+   * is dictated by available memory. The more dense nodes and relationship types, the more memory required.\n+   * Every round all relationships of one or more types are linked.\n+   * <p>\n+   * Links together:\n+   * <ul>\n+   * <li>\n+   * Relationship <--> Relationship. Two sequential passes are made over the relationship store.\n+   * The forward pass links next pointers, each next pointer pointing \"backwards\" to lower id.\n+   * The backward pass links prev pointers, each prev pointer pointing \"forwards\" to higher id.\n+   * </li>\n+   * Sparse Node --> Relationship. Sparse nodes are updated with relationship heads of completed chains.\n+   * This is done in the first round only, if there are multiple rounds.\n+   * </li>\n+   * </ul>\n+   * <p>\n+   * A linking loop (from external caller POV) typically looks like:\n+   * <pre>\n+   * int type = 0;\n+   * do\n+   * {\n+   *    type = logic.linkRelationships( type );\n+   * }\n+   * while ( type != -1 );\n+   * </pre>\n+   *\n+   * @param startingFromType relationship type to start from.\n+   * @return the next relationship type to start linking and, if != -1, should be passed into next call to this method.\n+   */\n+  public int linkRelationships(int startingFromType)\n+  {\n+    assert startingFromType >= 0 : startingFromType;\n+\n+    // Link relationships together with each other, their nodes and their relationship groups\n+    DataStatistics relationshipTypeDistribution = getState(DataStatistics.class);\n+    MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider(neoStore, nodeRelationshipCache);\n+\n+    // Figure out which types we can fit in node-->relationship cache memory.\n+    // Types go from biggest to smallest group and so towards the end there will be\n+    // smaller and more groups per round in this loop\n+    int upToType = nextSetOfTypesThatFitInMemory(\n+        relationshipTypeDistribution, startingFromType, availableMemoryForLinking, nodeRelationshipCache.getNumberOfDenseNodes());\n+\n+    PrimitiveIntSet typesToLinkThisRound = relationshipTypeDistribution.types(startingFromType, upToType);\n+    int typesImported = typesToLinkThisRound.size();\n+    boolean thisIsTheFirstRound = startingFromType == 0;\n+    boolean thisIsTheOnlyRound = thisIsTheFirstRound && upToType == relationshipTypeDistribution.getNumberOfRelationshipTypes();\n+\n+    Configuration relationshipConfig = configWithRecordsPerPageBasedBatchSize(config, neoStore.getRelationshipStore());\n+    Configuration nodeConfig = configWithRecordsPerPageBasedBatchSize(config, neoStore.getNodeStore());\n+    Configuration groupConfig = configWithRecordsPerPageBasedBatchSize(config, neoStore.getRelationshipGroupStore());\n+\n+    nodeRelationshipCache.setForwardScan(true, true/*dense*/);\n+    String range = typesToLinkThisRound.size() == 1\n+        ? String.valueOf(oneBased(startingFromType))\n+        : oneBased(startingFromType) + \"-\" + (startingFromType + typesImported);\n+    String topic = \" \" + range + \"/\" + relationshipTypeDistribution.getNumberOfRelationshipTypes();\n+    int nodeTypes = thisIsTheFirstRound ? NodeType.NODE_TYPE_ALL : NodeType.NODE_TYPE_DENSE;\n+    Predicate<RelationshipRecord> readFilter = thisIsTheFirstRound\n+        ? alwaysTrue() // optimization when all rels are imported in this round\n+        : record -> typesToLinkThisRound.contains(record.getType());\n+    Predicate<RelationshipRecord> denseChangeFilter = thisIsTheOnlyRound\n+        ? alwaysTrue() // optimization when all rels are imported in this round\n+        : record -> typesToLinkThisRound.contains(record.getType());\n+\n+    // LINK Forward\n+    RelationshipLinkforwardStage linkForwardStage = new RelationshipLinkforwardStage(topic, relationshipConfig,\n+        neoStore, nodeRelationshipCache, readFilter, denseChangeFilter, nodeTypes,\n+        new RelationshipLinkingProgress(), memoryUsageStats);\n+    executeStage(linkForwardStage);\n+\n+    // Write relationship groups cached from the relationship import above\n+    executeStage(new RelationshipGroupStage(topic, groupConfig,\n+        neoStore.getTemporaryRelationshipGroupStore(), nodeRelationshipCache));\n+    if (thisIsTheFirstRound)\n     {\n-        assert startingFromType >= 0 : startingFromType;\n-\n-        long currentSetOfRelationshipsMemoryUsage = 0;\n-        int numberOfTypes = typeDistribution.getNumberOfRelationshipTypes();\n-        int toType = startingFromType;\n-        for ( ; toType < numberOfTypes; toType++ )\n-        {\n-            // Calculate worst-case scenario\n-            RelationshipTypeCount type = typeDistribution.get( toType );\n-            long relationshipCountForThisType = type.getCount();\n-            long memoryUsageForThisType = calculateMaxMemoryUsage( numberOfDenseNodes, relationshipCountForThisType );\n-            long memoryUsageUpToAndIncludingThisType =\n-                    currentSetOfRelationshipsMemoryUsage + memoryUsageForThisType;\n-            if ( memoryUsageUpToAndIncludingThisType > freeMemoryForDenseNodeCache &&\n-                    currentSetOfRelationshipsMemoryUsage > 0 )\n-            {\n-                // OK the current set of types is enough to fill the cache\n-                break;\n-            }\n-\n-            currentSetOfRelationshipsMemoryUsage += memoryUsageForThisType;\n-        }\n-        return toType;\n+      // Set node nextRel fields for sparse nodes\n+      executeStage(new SparseNodeFirstRelationshipStage(nodeConfig, neoStore.getNodeStore(),\n+          nodeRelationshipCache));\n     }\n \n-    /**\n-     * Optimizes the relationship groups store by physically locating groups for each node together.\n-     */\n-    public void defragmentRelationshipGroups()\n-    {\n-        // Defragment relationships groups for better performance\n-        new RelationshipGroupDefragmenter( config, executionMonitor, RelationshipGroupDefragmenter.Monitor.EMPTY, numberArrayFactory )\n-                .run( max( maxMemory, peakMemoryUsage ), neoStore, neoStore.getNodeStore().getHighId() );\n-    }\n+    // LINK backward\n+    nodeRelationshipCache.setForwardScan(false, true/*dense*/);\n+    executeStage(new RelationshipLinkbackStage(topic, relationshipConfig, neoStore,\n+        nodeRelationshipCache, readFilter, denseChangeFilter, nodeTypes,\n+        new RelationshipLinkingProgress(), memoryUsageStats));\n \n-    /**\n-     * Builds the counts store. Requires that {@link #importNodes()} and {@link #importRelationships()} has run.\n-     */\n-    public void buildCountsStore()\n-    {\n-        // Count nodes per label and labels per node\n-        try ( CountsAccessor.Updater countsUpdater = neoStore.getCountsStore().reset(\n-                neoStore.getLastCommittedTransactionId() ) )\n-        {\n-            MigrationProgressMonitor progressMonitor = new SilentMigrationProgressMonitor();\n-            nodeLabelsCache = new NodeLabelsCache( numberArrayFactory, neoStore.getLabelRepository().getHighId() );\n-            MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider( neoStore, nodeLabelsCache );\n-            executeStage( new NodeCountsAndLabelIndexBuildStage( config, nodeLabelsCache, neoStore.getNodeStore(),\n-                    neoStore.getLabelRepository().getHighId(), countsUpdater, progressMonitor.startSection( \"Nodes\" ),\n-                    neoStore.getLabelScanStore(), memoryUsageStats ) );\n-            // Count label-[type]->label\n-            executeStage( new RelationshipCountsStage( config, nodeLabelsCache, neoStore.getRelationshipStore(),\n-                    neoStore.getLabelRepository().getHighId(),\n-                    neoStore.getRelationshipTypeRepository().getHighId(),\n-                    countsUpdater, numberArrayFactory, progressMonitor.startSection( \"Relationships\" ) ) );\n-        }\n-    }\n+    updatePeakMemoryUsage();\n \n-    public void success()\n+    if (upToType == relationshipTypeDistribution.getNumberOfRelationshipTypes())\n     {\n-        neoStore.success();\n-        successful = true;\n+      // This means that we've linked all the types\n+      nodeRelationshipCache.close();\n+      nodeRelationshipCache = null;\n+      return -1;\n     }\n \n-    @Override\n-    public void close() throws IOException\n+    return upToType;\n+  }\n+\n+  /**\n+   * Links relationships of all types, potentially doing multiple passes, each pass calling {@link #linkRelationships(int)}\n+   * with a type range.\n+   */\n+  public void linkRelationshipsOfAllTypes()\n+  {\n+    int type = 0;\n+    do\n     {\n-        // We're done, do some final logging about it\n-        long totalTimeMillis = currentTimeMillis() - startTime;\n-        DataStatistics state = getState( DataStatistics.class );\n-        String additionalInformation = Objects.toString( state, \"Data statistics is not available.\" );\n-        executionMonitor.done( successful, totalTimeMillis, format( \"%n%s%nPeak memory usage: %s\", additionalInformation, bytes( peakMemoryUsage ) ) );\n-        log.info( \"Import completed successfully, took \" + duration( totalTimeMillis ) + \". \" + additionalInformation );\n-        closeAll( nodeRelationshipCache, nodeLabelsCache, idMapper, inputCache );\n+      type = linkRelationships(type);\n     }\n-\n-    private void updatePeakMemoryUsage()\n+    while (type != -1);\n+  }\n+\n+  /**\n+   * Convenience method (for code reading) to have a zero-based value become one based (for printing/logging).\n+   */\n+  private static int oneBased(int value)\n+  {\n+    return value + 1;\n+  }\n+\n+  /**\n+   * @return index (into {@link DataStatistics}) of last relationship type that fit in memory this round.\n+   */\n+  static int nextSetOfTypesThatFitInMemory(DataStatistics typeDistribution, int startingFromType,\n+                                           long freeMemoryForDenseNodeCache, long numberOfDenseNodes)\n+  {\n+    assert startingFromType >= 0 : startingFromType;\n+\n+    long currentSetOfRelationshipsMemoryUsage = 0;\n+    int numberOfTypes = typeDistribution.getNumberOfRelationshipTypes();\n+    int toType = startingFromType;\n+    for (; toType < numberOfTypes; toType++)\n     {\n-        peakMemoryUsage = max( peakMemoryUsage, totalMemoryUsageOf( nodeRelationshipCache, idMapper, neoStore ) );\n+      // Calculate worst-case scenario\n+      RelationshipTypeCount type = typeDistribution.get(toType);\n+      long relationshipCountForThisType = type.getCount();\n+      long memoryUsageForThisType = calculateMaxMemoryUsage(numberOfDenseNodes, relationshipCountForThisType);\n+      long memoryUsageUpToAndIncludingThisType =\n+          currentSetOfRelationshipsMemoryUsage + memoryUsageForThisType;\n+      if (memoryUsageUpToAndIncludingThisType > freeMemoryForDenseNodeCache &&\n+          currentSetOfRelationshipsMemoryUsage > 0)\n+      {\n+        // OK the current set of types is enough to fill the cache\n+        break;\n+      }\n+\n+      currentSetOfRelationshipsMemoryUsage += memoryUsageForThisType;\n     }\n-\n-    public static BatchingNeoStores instantiateNeoStores( FileSystemAbstraction fileSystem, File storeDir,\n-            PageCache externalPageCache, RecordFormats recordFormats, Configuration config,\n-            LogService logService, AdditionalInitialIds additionalInitialIds, Config dbConfig )\n+    return toType;\n+  }\n+\n+  /**\n+   * Optimizes the relationship groups store by physically locating groups for each node together.\n+   */\n+  public void defragmentRelationshipGroups()\n+  {\n+    // Defragment relationships groups for better performance\n+    new RelationshipGroupDefragmenter(config, executionMonitor, RelationshipGroupDefragmenter.Monitor.EMPTY, numberArrayFactory)\n+        .run(max(maxMemory, peakMemoryUsage), neoStore, neoStore.getNodeStore().getHighId());\n+  }\n+\n+  /**\n+   * Builds the counts store. Requires that {@link #importNodes()} and {@link #importRelationships()} has run.\n+   */\n+  public void buildCountsStore()\n+  {\n+    // Count nodes per label and labels per node\n+    try (CountsAccessor.Updater countsUpdater = neoStore.getCountsStore().reset(\n+        neoStore.getLastCommittedTransactionId()))\n     {\n-        if ( externalPageCache == null )\n-        {\n-            return BatchingNeoStores.batchingNeoStores( fileSystem, storeDir, recordFormats, config, logService,\n-                    additionalInitialIds, dbConfig );\n-        }\n-\n-        return BatchingNeoStores.batchingNeoStoresWithExternalPageCache( fileSystem, externalPageCache,\n-                PageCacheTracer.NULL, storeDir, recordFormats, config, logService, additionalInitialIds, dbConfig );\n+      MigrationProgressMonitor progressMonitor = new SilentMigrationProgressMonitor();\n+      nodeLabelsCache = new NodeLabelsCache(numberArrayFactory, neoStore.getLabelRepository().getHighId());\n+      MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider(neoStore, nodeLabelsCache);\n+      executeStage(new NodeCountsAndLabelIndexBuildStage(config, nodeLabelsCache, neoStore.getNodeStore(),\n+          neoStore.getLabelRepository().getHighId(), countsUpdater, progressMonitor.startSection(\"Nodes\"),\n+          neoStore.getLabelScanStore(), memoryUsageStats));\n+      // Count label-[type]->label\n+      executeStage(new RelationshipCountsStage(config, nodeLabelsCache, neoStore.getRelationshipStore(),\n+          neoStore.getLabelRepository().getHighId(),\n+          neoStore.getRelationshipTypeRepository().getHighId(),\n+          countsUpdater, numberArrayFactory, progressMonitor.startSection(\"Relationships\")));\n     }\n-\n-    private static long totalMemoryUsageOf( MemoryStatsVisitor.Visitable... users )\n+  }\n+\n+  public void success()\n+  {\n+    neoStore.success();\n+    successful = true;\n+  }\n+\n+  @Override\n+  public void close() throws IOException\n+  {\n+    // We're done, do some final logging about it\n+    long totalTimeMillis = currentTimeMillis() - startTime;\n+    DataStatistics state = getState(DataStatistics.class);\n+    String additionalInformation = Objects.toString(state, \"Data statistics is not available.\");\n+    executionMonitor.done(successful, totalTimeMillis, format(\"%n%s%nPeak memory usage: %s\", additionalInformation, bytes(peakMemoryUsage)));\n+    log.info(\"Import completed successfully, took \" + duration(totalTimeMillis) + \". \" + additionalInformation);\n+    closeAll(nodeRelationshipCache, nodeLabelsCache, idMapper, inputCache);\n+  }\n+\n+  private void updatePeakMemoryUsage()\n+  {\n+    peakMemoryUsage = max(peakMemoryUsage, totalMemoryUsageOf(nodeRelationshipCache, idMapper, neoStore));\n+  }\n+\n+  public static BatchingNeoStores instantiateNeoStores(FileSystemAbstraction fileSystem, File storeDir,\n+                                                       PageCache externalPageCache, RecordFormats recordFormats, Configuration config,\n+                                                       LogService logService, AdditionalInitialIds additionalInitialIds, Config dbConfig)\n+  {\n+    if (externalPageCache == null)\n     {\n-        GatheringMemoryStatsVisitor total = new GatheringMemoryStatsVisitor();\n-        for ( MemoryStatsVisitor.Visitable user : users )\n-        {\n-            if ( user != null )\n-            {\n-                user.acceptMemoryStatsVisitor( total );\n-            }\n-        }\n-        return total.getHeapUsage() + total.getOffHeapUsage();\n+      return BatchingNeoStores.batchingNeoStores(fileSystem, storeDir, recordFormats, config, logService,\n+          additionalInitialIds, dbConfig);\n     }\n \n-    private static Configuration configWithRecordsPerPageBasedBatchSize( Configuration source, RecordStore<?> store )\n-    {\n-        return Configuration.withBatchSize( source, store.getRecordsPerPage() * 10 );\n-    }\n+    return BatchingNeoStores.batchingNeoStoresWithExternalPageCache(fileSystem, externalPageCache,\n+        PageCacheTracer.NULL, storeDir, recordFormats, config, logService, additionalInitialIds, dbConfig);\n+  }\n \n-    private void executeStage( Stage stage )\n+  private static long totalMemoryUsageOf(MemoryStatsVisitor.Visitable... users)\n+  {\n+    GatheringMemoryStatsVisitor total = new GatheringMemoryStatsVisitor();\n+    for (MemoryStatsVisitor.Visitable user : users)\n     {\n-        superviseExecution( executionMonitor, config, stage );\n+      if (user != null)\n+      {\n+        user.acceptMemoryStatsVisitor(total);\n+      }\n     }\n+    return total.getHeapUsage() + total.getOffHeapUsage();\n+  }\n+\n+  private static Configuration configWithRecordsPerPageBasedBatchSize(Configuration source, RecordStore<?> store)\n+  {\n+    return Configuration.withBatchSize(source, store.getRecordsPerPage() * 10);\n+  }\n+\n+  private void executeStage(Stage stage)\n+  {\n+    superviseExecution(executionMonitor, config, stage);\n+  }\n }\n",
            "diff_size": 792
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                },
                {
                    "line": "300",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 186).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "366",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 177).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "375",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "453",
                    "column": "41",
                    "severity": "error",
                    "message": "'>' is not preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                },
                {
                    "line": "472",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 223).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "486",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 265).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "488",
                    "severity": "error",
                    "message": "Line is longer than 160 characters (found 297).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1207/ImportLogic.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/1207/ImportLogic.java\nindex 9bfb8a06383..e6bcc1dc068 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/errored/1/1207/ImportLogic.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/graphfoundation-ongdb/naturalize/1207/ImportLogic.java\n@@ -106,32 +106,38 @@ public class ImportLogic implements Closeable\n     {\n         @Override\n         public void mayExceedRelationshipIdCapacity( long capacity, long estimatedCount )\n-        {   // no-op\n+        {\n+    // no-op\n         }\n \n         @Override\n         public void mayExceedNodeIdCapacity( long capacity, long estimatedCount )\n-        {   // no-op\n+        {\n+    // no-op\n         }\n \n         @Override\n         public void doubleRelationshipRecordUnitsEnabled()\n-        {   // no-op\n+        {\n+    // no-op\n         }\n \n         @Override\n         public void insufficientHeapSize( long optimalMinimalHeapSize, long heapSize )\n-        {   // no-op\n+        {\n+    // no-op\n         }\n \n         @Override\n         public void abundantHeapSize( long optimalMinimalHeapSize, long heapSize )\n-        {   // no-op\n+        {\n+    // no-op\n         }\n \n         @Override\n         public void insufficientAvailableMemory( long estimatedCacheSize, long optimalMinimalHeapSize, long availableMemory )\n-        {   // no-op\n+        {\n+    // no-op\n         }\n     };\n \n@@ -208,12 +214,9 @@ public class ImportLogic implements Closeable\n         // Sanity checking against estimates\n         new EstimationSanityChecker( recordFormats, monitor ).sanityCheck( inputEstimates );\n         new HeapSizeSanityChecker( monitor ).sanityCheck( inputEstimates, recordFormats, neoStore,\n-                nodeRelationshipCache.memoryEstimation( inputEstimates.numberOfNodes() ),\n-                idMapper.memoryEstimation( inputEstimates.numberOfNodes() ) );\n-\n-        dependencies.satisfyDependencies( inputEstimates, idMapper, neoStore, nodeRelationshipCache, numberArrayFactoryMonitor );\n-\n-        if ( neoStore.determineDoubleRelationshipRecordUnits( inputEstimates ) )\n+                nodeRelationshipCache.memoryEstimation( inputEstimates.numberOfNodes() ), idMapper.memoryEstimation( inputEstimates.numberOfNodes() ) );\n+dependencies.satisfyDependencies( inputEstimates, idMapper, neoStore, nodeRelationshipCache, numberArrayFactoryMonitor );\n+if ( neoStore.determineDoubleRelationshipRecordUnits( inputEstimates ) )\n         {\n             monitor.doubleRelationshipRecordUnitsEnabled();\n         }\n@@ -258,9 +261,8 @@ public class ImportLogic implements Closeable\n     {\n         // Import nodes, properties, labels\n         neoStore.startFlushingPageCache();\n-        DataImporter.importNodes( config.maxNumberOfProcessors(), input, neoStore, idMapper,\n-              executionMonitor, storeUpdateMonitor );\n-        neoStore.stopFlushingPageCache();\n+        DataImporter.importNodes( config.maxNumberOfProcessors(), input, neoStore, idMapper, executionMonitor, storeUpdateMonitor );\n+neoStore.stopFlushingPageCache();\n         updatePeakMemoryUsage();\n     }\n \n@@ -279,7 +281,8 @@ public class ImportLogic implements Closeable\n             {\n                 executeStage( new DeleteDuplicateNodesStage( config, duplicateNodeIds, neoStore, storeUpdateMonitor ) );\n             }\n-            updatePeakMemoryUsage();\n+\n+updatePeakMemoryUsage();\n         }\n     }\n \n@@ -294,10 +297,9 @@ public class ImportLogic implements Closeable\n     {\n         // Import relationships (unlinked), properties\n         neoStore.startFlushingPageCache();\n-        DataStatistics typeDistribution = DataImporter.importRelationships(\n-                config.maxNumberOfProcessors(), input, neoStore, idMapper, badCollector, executionMonitor, storeUpdateMonitor,\n+        DataStatistics typeDistribution = DataImporter.importRelationships( config.maxNumberOfProcessors(), input, neoStore, idMapper, badCollector, executionMonitor, storeUpdateMonitor,\n                 !badCollector.isCollectingBadRelationships() );\n-        neoStore.stopFlushingPageCache();\n+neoStore.stopFlushingPageCache();\n         updatePeakMemoryUsage();\n         idMapper.close();\n         idMapper = null;\n@@ -310,13 +312,12 @@ public class ImportLogic implements Closeable\n      */\n     public void calculateNodeDegrees()\n     {\n-        Configuration relationshipConfig =\n-                configWithRecordsPerPageBasedBatchSize( config, neoStore.getRelationshipStore() );\n-        nodeRelationshipCache.setNodeCount( neoStore.getNodeStore().getHighId() );\n+        Configuration relationshipConfig = configWithRecordsPerPageBasedBatchSize( config, neoStore.getRelationshipStore() );\n+nodeRelationshipCache.setNodeCount( neoStore.getNodeStore().getHighId() );\n         MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider( neoStore, nodeRelationshipCache );\n         NodeDegreeCountStage nodeDegreeStage = new NodeDegreeCountStage( relationshipConfig,\n                 neoStore.getRelationshipStore(), nodeRelationshipCache, memoryUsageStats );\n-        executeStage( nodeDegreeStage );\n+executeStage( nodeDegreeStage );\n         nodeRelationshipCache.countingCompleted();\n         availableMemoryForLinking = maxMemory - totalMemoryUsageOf( nodeRelationshipCache, neoStore );\n     }\n@@ -362,56 +363,42 @@ public class ImportLogic implements Closeable\n         // Figure out which types we can fit in node-->relationship cache memory.\n         // Types go from biggest to smallest group and so towards the end there will be\n         // smaller and more groups per round in this loop\n-        int upToType = nextSetOfTypesThatFitInMemory(\n-                relationshipTypeDistribution, startingFromType, availableMemoryForLinking, nodeRelationshipCache.getNumberOfDenseNodes() );\n-\n-        PrimitiveIntSet typesToLinkThisRound = relationshipTypeDistribution.types( startingFromType, upToType );\n+        int upToType = nextSetOfTypesThatFitInMemory( relationshipTypeDistribution, startingFromType, availableMemoryForLinking, nodeRelationshipCache.getNumberOfDenseNodes() );\n+PrimitiveIntSet typesToLinkThisRound = relationshipTypeDistribution.types( startingFromType, upToType );\n         int typesImported = typesToLinkThisRound.size();\n         boolean thisIsTheFirstRound = startingFromType == 0;\n         boolean thisIsTheOnlyRound = thisIsTheFirstRound && upToType == relationshipTypeDistribution.getNumberOfRelationshipTypes();\n-\n-        Configuration relationshipConfig = configWithRecordsPerPageBasedBatchSize( config, neoStore.getRelationshipStore() );\n+Configuration relationshipConfig = configWithRecordsPerPageBasedBatchSize( config, neoStore.getRelationshipStore() );\n         Configuration nodeConfig = configWithRecordsPerPageBasedBatchSize( config, neoStore.getNodeStore() );\n         Configuration groupConfig = configWithRecordsPerPageBasedBatchSize( config, neoStore.getRelationshipGroupStore() );\n-\n-        nodeRelationshipCache.setForwardScan( true, true/*dense*/ );\n-        String range = typesToLinkThisRound.size() == 1\n-                ? String.valueOf( oneBased( startingFromType ) )\n-                : oneBased( startingFromType ) + \"-\" + (startingFromType + typesImported);\n-        String topic = \" \" + range + \"/\" + relationshipTypeDistribution.getNumberOfRelationshipTypes();\n+nodeRelationshipCache.setForwardScan( true, true/*dense*/ );\n+        String range = typesToLinkThisRound.size() == 1 ? String.valueOf( oneBased( startingFromType ) ) : oneBased( startingFromType ) + \"-\" + (startingFromType + typesImported);\n+String topic = \" \" + range + \"/\" + relationshipTypeDistribution.getNumberOfRelationshipTypes();\n         int nodeTypes = thisIsTheFirstRound ? NodeType.NODE_TYPE_ALL : NodeType.NODE_TYPE_DENSE;\n-        Predicate<RelationshipRecord> readFilter = thisIsTheFirstRound\n-                ? alwaysTrue() // optimization when all rels are imported in this round\n+        Predicate<RelationshipRecord> readFilter = thisIsTheFirstRound ? alwaysTrue() // optimization when all rels are imported in this round\n                 : record -> typesToLinkThisRound.contains( record.getType() );\n-        Predicate<RelationshipRecord> denseChangeFilter = thisIsTheOnlyRound\n-                ? alwaysTrue() // optimization when all rels are imported in this round\n+Predicate<RelationshipRecord> denseChangeFilter = thisIsTheOnlyRound ? alwaysTrue() // optimization when all rels are imported in this round\n                 : record -> typesToLinkThisRound.contains( record.getType() );\n-\n-        // LINK Forward\n+    // LINK Forward\n         RelationshipLinkforwardStage linkForwardStage = new RelationshipLinkforwardStage( topic, relationshipConfig,\n-                neoStore, nodeRelationshipCache, readFilter, denseChangeFilter, nodeTypes,\n-                new RelationshipLinkingProgress(), memoryUsageStats );\n-        executeStage( linkForwardStage );\n+                neoStore, nodeRelationshipCache, readFilter, denseChangeFilter, nodeTypes, new RelationshipLinkingProgress(), memoryUsageStats );\n+executeStage( linkForwardStage );\n \n         // Write relationship groups cached from the relationship import above\n         executeStage( new RelationshipGroupStage( topic, groupConfig,\n                 neoStore.getTemporaryRelationshipGroupStore(), nodeRelationshipCache ) );\n-        if ( thisIsTheFirstRound )\n+if ( thisIsTheFirstRound )\n         {\n             // Set node nextRel fields for sparse nodes\n-            executeStage( new SparseNodeFirstRelationshipStage( nodeConfig, neoStore.getNodeStore(),\n-                    nodeRelationshipCache ) );\n+            executeStage( new SparseNodeFirstRelationshipStage( nodeConfig, neoStore.getNodeStore(), nodeRelationshipCache ) );\n         }\n \n         // LINK backward\n         nodeRelationshipCache.setForwardScan( false, true/*dense*/ );\n         executeStage( new RelationshipLinkbackStage( topic, relationshipConfig, neoStore,\n-                nodeRelationshipCache, readFilter, denseChangeFilter, nodeTypes,\n-                new RelationshipLinkingProgress(), memoryUsageStats ) );\n-\n-        updatePeakMemoryUsage();\n-\n-        if ( upToType == relationshipTypeDistribution.getNumberOfRelationshipTypes() )\n+                nodeRelationshipCache, readFilter, denseChangeFilter, nodeTypes, new RelationshipLinkingProgress(), memoryUsageStats ) );\n+updatePeakMemoryUsage();\n+if ( upToType == relationshipTypeDistribution.getNumberOfRelationshipTypes() )\n         {\n             // This means that we've linked all the types\n             nodeRelationshipCache.close();\n@@ -463,7 +450,7 @@ public class ImportLogic implements Closeable\n             long memoryUsageForThisType = calculateMaxMemoryUsage( numberOfDenseNodes, relationshipCountForThisType );\n             long memoryUsageUpToAndIncludingThisType =\n                     currentSetOfRelationshipsMemoryUsage + memoryUsageForThisType;\n-            if ( memoryUsageUpToAndIncludingThisType > freeMemoryForDenseNodeCache &&\n+if ( memoryUsageUpToAndIncludingThisType> freeMemoryForDenseNodeCache &&\n                     currentSetOfRelationshipsMemoryUsage > 0 )\n             {\n                 // OK the current set of types is enough to fill the cache\n@@ -472,7 +459,8 @@ public class ImportLogic implements Closeable\n \n             currentSetOfRelationshipsMemoryUsage += memoryUsageForThisType;\n         }\n-        return toType;\n+\n+return toType;\n     }\n \n     /**\n@@ -481,8 +469,7 @@ public class ImportLogic implements Closeable\n     public void defragmentRelationshipGroups()\n     {\n         // Defragment relationships groups for better performance\n-        new RelationshipGroupDefragmenter( config, executionMonitor, RelationshipGroupDefragmenter.Monitor.EMPTY, numberArrayFactory )\n-                .run( max( maxMemory, peakMemoryUsage ), neoStore, neoStore.getNodeStore().getHighId() );\n+        new RelationshipGroupDefragmenter( config, executionMonitor, RelationshipGroupDefragmenter.Monitor.EMPTY, numberArrayFactory ).run( max( maxMemory, peakMemoryUsage ), neoStore, neoStore.getNodeStore().getHighId() );\n     }\n \n     /**\n@@ -491,21 +478,15 @@ public class ImportLogic implements Closeable\n     public void buildCountsStore()\n     {\n         // Count nodes per label and labels per node\n-        try ( CountsAccessor.Updater countsUpdater = neoStore.getCountsStore().reset(\n-                neoStore.getLastCommittedTransactionId() ) )\n+        try ( CountsAccessor.Updater countsUpdater = neoStore.getCountsStore().reset( neoStore.getLastCommittedTransactionId() ) )\n         {\n             MigrationProgressMonitor progressMonitor = new SilentMigrationProgressMonitor();\n             nodeLabelsCache = new NodeLabelsCache( numberArrayFactory, neoStore.getLabelRepository().getHighId() );\n             MemoryUsageStatsProvider memoryUsageStats = new MemoryUsageStatsProvider( neoStore, nodeLabelsCache );\n-            executeStage( new NodeCountsAndLabelIndexBuildStage( config, nodeLabelsCache, neoStore.getNodeStore(),\n-                    neoStore.getLabelRepository().getHighId(), countsUpdater, progressMonitor.startSection( \"Nodes\" ),\n-                    neoStore.getLabelScanStore(), memoryUsageStats ) );\n-            // Count label-[type]->label\n-            executeStage( new RelationshipCountsStage( config, nodeLabelsCache, neoStore.getRelationshipStore(),\n-                    neoStore.getLabelRepository().getHighId(),\n-                    neoStore.getRelationshipTypeRepository().getHighId(),\n-                    countsUpdater, numberArrayFactory, progressMonitor.startSection( \"Relationships\" ) ) );\n-        }\n+            executeStage( new NodeCountsAndLabelIndexBuildStage( config, nodeLabelsCache, neoStore.getNodeStore(), neoStore.getLabelRepository().getHighId(), countsUpdater, progressMonitor.startSection( \"Nodes\" ), neoStore.getLabelScanStore(), memoryUsageStats ) );\n+    // Count label-[type]->label\n+            executeStage( new RelationshipCountsStage( config, nodeLabelsCache, neoStore.getRelationshipStore(), neoStore.getLabelRepository().getHighId(), neoStore.getRelationshipTypeRepository().getHighId(), countsUpdater, numberArrayFactory, progressMonitor.startSection( \"Relationships\" ) ) );\n+    }\n     }\n \n     public void success()\n@@ -567,4 +548,4 @@ public class ImportLogic implements Closeable\n     {\n         superviseExecution( executionMonitor, config, stage );\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 77
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "1",
                    "severity": "error",
                    "message": "Missing, wrong or duplicated license header",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}