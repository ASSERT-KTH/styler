{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "258",
    "information": {
        "errors": [
            {
                "line": "45",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "final class IdentityField\n{\n\t/**\n\t * The index of the element that is the context for the xs:field evaluation.\n\t */\n\tprivate final int m_contextIndex;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "46",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/258/IdentityField.java\nindex 2908d50c3b8..792b49e11eb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/258/IdentityField.java\n@@ -42,10 +42,10 @@ import org.genxdm.xs.types.Type;\n  */\n final class IdentityField\n {\n-\t/**\n+/**\n \t * The index of the element that is the context for the xs:field evaluation.\n \t */\n-\tprivate final int m_contextIndex;\n+ private final int m_contextIndex;\n \tprivate final IdentityScope m_scope;\n \tprivate final SchemaExceptionHandler m_errorHandler;\n \n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "55",
                    "column": "3",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/258/IdentityField.java\nindex 2908d50c3b8..7b31acb4fbd 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/258/IdentityField.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.validation.impl;\n \n import java.lang.reflect.Array;\n@@ -40,406 +41,346 @@ import org.genxdm.xs.types.Type;\n  * Provides a streaming evaluation of a restricted XPath expression. <br/>\n  * When certain conditions are met, a match handler is called. The matched fields gets reported back to its scope.\n  */\n-final class IdentityField\n-{\n-\t/**\n-\t * The index of the element that is the context for the xs:field evaluation.\n-\t */\n-\tprivate final int m_contextIndex;\n-\tprivate final IdentityScope m_scope;\n-\tprivate final SchemaExceptionHandler m_errorHandler;\n-\n-\t// TODO: temporary\n+final class IdentityField {\n+    /**\n+     * The index of the element that is the context for the xs:field evaluation.\n+     */\n+    private final int m_contextIndex;\n+\n+    private final IdentityScope m_scope;\n+\n+    private final SchemaExceptionHandler m_errorHandler;\n+\n+    // TODO: temporary\n //\tprivate List<? extends A> m_value = null;\n-\tString m_value;\n-\tprivate int m_nodeIndex = -1;\n-\tprivate LocationInSchema m_location = null;\n-\n-\t// a List of branches, representing a parsed identity (selector or field)\n-\t// XPath expression\n-\tprivate RestrictedXPath m_branches[];\n-\n-\tprivate final ArrayList<LinkedList<IdentityXPathStatus>> m_active;\n-\n-\t// true if that branch started with \".//\"\n-\tprivate boolean[] m_relocatable;\n-\n-\tprivate int m_depth = -1;\n-\n-\t/**\n-\t * @param xpath\n-\t *            representing the parsed attribute xpath\n-\t */\n-\tpublic IdentityField(final RestrictedXPath xpath, final int contextIndex, final IdentityScope scope, final SchemaExceptionHandler errorHandler)\n-\t{\n-\t\tm_contextIndex = contextIndex;\n-\t\tm_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n-\t\tm_errorHandler = PreCondition.assertArgumentNotNull(errorHandler, \"errorHandler\");\n-\n-\t\t// Count the number of branches, that is, the number of XPath\n-\t\t// expressions separated by \"|\".\n-\t\tint size = 0;\n-\t\tfor (RestrictedXPath branch = xpath; branch != null; branch = branch.getAlternate())\n-\t\t{\n-\t\t\t// System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n-\t\t\t// branch);\n-\t\t\tsize++;\n-\t\t}\n-\n-\t\tm_relocatable = new boolean[size];\n-\t\tm_branches = (RestrictedXPath[])Array.newInstance(RestrictedXPath.class, size);\n-\t\tm_active = new ArrayList<LinkedList<IdentityXPathStatus>>(size);\n-\t\tRestrictedXPath branch = xpath;\n-\t\tfor (int i = size - 1; i >= 0; i--)\n-\t\t{\n-\t\t\t// put them backwards\n-\t\t\tif (null == branch)\n-\t\t\t{\n-\t\t\t\tthrow new RuntimeException();\n-\t\t\t}\n-\t\t\tm_branches[i] = branch;\n-\t\t\tm_relocatable[i] = branch.isRelocatable();\n-\t\t\tbranch = branch.getAlternate();\n-\t\t}\n-\t\tfor (int i = 0; i < size; i++)\n-\t\t{\n-\t\t\t// The XPath expression is already running for each branch.\n-\t\t\tfinal LinkedList<IdentityXPathStatus> e = new LinkedList<IdentityXPathStatus>();\n-\t\t\tfinal IdentityXPathStatus xps = new IdentityXPathStatus(false);\n-\t\t\txps.currentStep = -1;\n-\t\t\te.add(xps);\n-\t\t\tm_active.add(e);\n-\t\t}\n-\t}\n-\n-\tpublic <A> List<? extends A> getTypedValue(AtomBridge<A> bridge)\n-\t{\n-\t    // TODO: so, now fix it.\n-\t    return null;\n+    String m_value;\n+\n+    private int m_nodeIndex = -1;\n+\n+    private LocationInSchema m_location = null;\n+\n+    // a List of branches, representing a parsed identity (selector or field)\n+    // XPath expression\n+    private RestrictedXPath m_branches[];\n+\n+    private final ArrayList<LinkedList<IdentityXPathStatus>> m_active;\n+\n+    // true if that branch started with \".//\"\n+    private boolean[] m_relocatable;\n+\n+    private int m_depth = -1;\n+\n+    /**\n+     * @param xpath\n+     *            representing the parsed attribute xpath\n+     */\n+    public IdentityField(final RestrictedXPath xpath, final int contextIndex,\n+                         final IdentityScope scope, final SchemaExceptionHandler errorHandler) {\n+        m_contextIndex = contextIndex;\n+        m_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n+        m_errorHandler = PreCondition.assertArgumentNotNull(errorHandler, \"errorHandler\");\n+\n+        // Count the number of branches, that is, the number of XPath\n+        // expressions separated by \"|\".\n+        int size = 0;\n+        for (RestrictedXPath branch = xpath; branch != null; branch = branch.getAlternate()) {\n+            // System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n+            // branch);\n+            size++;\n+        }\n+\n+        m_relocatable = new boolean[size];\n+        m_branches = (RestrictedXPath[]) Array.newInstance(RestrictedXPath.class, size);\n+        m_active = new ArrayList<LinkedList<IdentityXPathStatus>>(size);\n+        RestrictedXPath branch = xpath;\n+        for (int i = size - 1; i >= 0; i--) {\n+            // put them backwards\n+            if (null == branch) {\n+                throw new RuntimeException();\n+            }\n+            m_branches[i] = branch;\n+            m_relocatable[i] = branch.isRelocatable();\n+            branch = branch.getAlternate();\n+        }\n+        for (int i = 0; i < size; i++) {\n+            // The XPath expression is already running for each branch.\n+            final LinkedList<IdentityXPathStatus> e = new LinkedList<IdentityXPathStatus>();\n+            final IdentityXPathStatus xps = new IdentityXPathStatus(false);\n+            xps.currentStep = -1;\n+            e.add(xps);\n+            m_active.add(e);\n+        }\n+    }\n+\n+    public <A> List<? extends A> getTypedValue(AtomBridge<A> bridge) {\n+        // TODO: so, now fix it.\n+        return null;\n //\t\treturn m_value;\n-\t}\n-\n-\tpublic LocationInSchema getLocation()\n-\t{\n-\t\treturn m_location;\n-\t}\n-\n-\tprivate int getMaximumStep(final int branchIdx)\n-\t{\n-\t\treturn m_branches[branchIdx].getStepLength() - 1;\n-\t}\n-\n-\tpublic void startElement(final QName elementName, final int elementIndex, final Type elementType, final Locatable locatable) throws AbortException\n-\t{\n-\t\tm_depth++;\n-\n-\t\tfor (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without\n-\t\t\t// getting a concurrent modification exception (would happen through\n-\t\t\t// the list).\n-\t\t\tfinal Iterator<IdentityXPathStatus> active = m_active.get(branchIdx).iterator();\n-\t\t\twhile (active.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentityXPathStatus xps = active.next();\n-\t\t\t\txps.currentStep += 1;\n-\t\t\t\tif (xps.currentStep <= getMaximumStep(branchIdx))\n-\t\t\t\t{\n-\t\t\t\t\tif (matches(m_branches[branchIdx], xps.currentStep, elementName))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.currentStep == getMaximumStep(branchIdx))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t// TODO: Should this take place at design time?\n-\t\t\t\t\t\t\tif (isSimpleTypeOrSimpleContent(elementType))\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\txps.isSimple = true;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_errorHandler.error(new CvcIdentityConstraintFieldNodeNotSimpleTypeException(m_scope.getConstraint().getName(), locatable.getLocation()));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tactive.remove();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (m_depth > 0 && m_relocatable[branchIdx])\n-\t\t\t{\n-\t\t\t\tif (matches(m_branches[branchIdx], 0, elementName))\n-\t\t\t\t{\n-\t\t\t\t\tfinal IdentityXPathStatus xps = new IdentityXPathStatus(true);\n-\t\t\t\t\tif (xps.currentStep == getMaximumStep(branchIdx))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (isSimpleTypeOrSimpleContent(elementType))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\txps.isSimple = true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_errorHandler.error(new CvcIdentityConstraintFieldNodeNotSimpleTypeException(m_scope.getConstraint().getName(), locatable.getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tm_active.get(branchIdx).add(xps);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void endElement(final QName elementName, final int elementIndex, final Locatable location)\n-\t{\n-\t\t// System.out.println(StripQualifiers.strip(getClass().getName()) +\n-\t\t// \".endElement(elementName=\" + elementName + \", elementIndex=\" +\n-\t\t// elementIndex + \")\");\n-\n-\t\tm_depth--;\n-\t\tfor (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without\n-\t\t\t// getting a concurrent modification exception (would happen through\n-\t\t\t// the list).\n-\t\t\tfinal Iterator<IdentityXPathStatus> it = m_active.get(branchIdx).iterator();\n-\t\t\twhile (it.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentityXPathStatus xps = it.next();\n-\t\t\t\tif (xps.currentStep == getMaximumStep(branchIdx))\n-\t\t\t\t{\n-\t\t\t\t\txps.isSimple = false;\n-\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\txps.currentStep -= 1;\n-\t\t\t}\n-\n-\t\t\t// if (m_depth == 0)\n-\t\t\t// {\n-\t\t\t// PreCondition.assertTrue(m_active.get(branchIdx).isEmpty());\n-\t\t\t// }\n-\t\t}\n-\t}\n-\n-\tpublic <A> void attribute(final QName name, final List<? extends A> actualValue, final int attributeIndex, final SimpleType attributeType, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\t// System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n-\t\t// + hashCode() + \"].attribute(name=\" + name + \", value=\" +\n-\t\t// GxSupport.atomsToString(actualValue) + \")\");\n-\n-\t\tfor (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without\n-\t\t\t// getting a concurrent modification exception (would happen through\n-\t\t\t// the list).\n-\t\t\tfinal Iterator<IdentityXPathStatus> active = m_active.get(branchIdx).iterator();\n-\t\t\twhile (active.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentityXPathStatus xps = active.next();\n-\t\t\t\tfinal int currentStep = xps.currentStep + 1;\n-\t\t\t\tfinal int maximumStep = getMaximumStep(branchIdx);\n-\t\t\t\tif (currentStep <= maximumStep)\n-\t\t\t\t{\n-\t\t\t\t\tif (matchesAttribute(m_branches[branchIdx], currentStep, name))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (currentStep == getMaximumStep(branchIdx))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tattributeMatched(name, actualValue, attributeIndex, locatable, atomBridge);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tactive.remove();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final int textIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfor (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n-\t\t{\n-\t\t\tfinal Iterator<IdentityXPathStatus> it = m_active.get(branchIdx).iterator();\n-\t\t\twhile (it.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentityXPathStatus xps = it.next();\n-\t\t\t\tif (xps.isSimple)\n-\t\t\t\t{\n-\t\t\t\t\ttextMatched(actualValue, textIndex, locatable, atomBridge);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tfinal int currentStep = xps.currentStep + 1;\n-\t\t\t\t\tfinal int maximumStep = getMaximumStep(branchIdx);\n-\t\t\t\t\tif (currentStep <= maximumStep)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (matchesText(m_branches[branchIdx], currentStep))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (currentStep == maximumStep)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\ttextMatched(actualValue, textIndex, locatable, atomBridge);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether the (QName,isAttribute) combination matches the XPath expression at the specified step index.\n-\t */\n-\tprivate boolean matches(final RestrictedXPath xpath, final int idxStep, final QName name)\n-\t{\n-\t\tif (xpath.isAttribute())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (xpath.isContextNode(idxStep))\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal String stepLN = xpath.getStepLocalName(idxStep);\n-\t\t\tfinal String stepNS = xpath.getStepNamespace(idxStep);\n-\n-\t\t\tif (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(name.getNamespaceURI())))\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn name.getLocalPart().equals(stepLN) && name.getNamespaceURI().equals(stepNS);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate boolean matchesText(final RestrictedXPath xpath, final int idxStep)\n-\t{\n-\t\t// System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n-\t\t// + hashCode() + \"].matchesText(idxStep=\" + idxStep + \")\");\n-\t\tif (xpath.isAttribute())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\treturn xpath.isContextNode(idxStep);\n-\t}\n-\n-\t/**\n-\t * Determine whether the (QName,isAttribute) combination matches the XPath expression at the specified step index.\n-\t */\n-\tprivate boolean matchesAttribute(final RestrictedXPath xpath, final int idxStep, final QName name)\n-\t{\n-\t\t// System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n-\t\t// + hashCode() + \"].matchesAttribute(\" + xpath + \", idxStep=\" + idxStep\n-\t\t// + \", name=\" + name + \")\");\n-\t\tif (!xpath.isAttribute())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (xpath.isContextNode(idxStep))\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal String stepNS = xpath.getStepNamespace(idxStep);\n-\n-\t\t\tif (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(name.getNamespaceURI())))\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tfinal String stepLN = xpath.getStepLocalName(idxStep);\n-\t\t\t\treturn name.getLocalPart().equals(stepLN) && name.getNamespaceURI().equals(stepNS);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate <A> void attributeMatched(final QName name, final List<? extends A> actualValue, final int attributeIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tif (m_value == null)\n-\t\t{\n-\t\t\tm_value = atomBridge.getC14NString(actualValue);\n-\t\t\tm_nodeIndex = attributeIndex;\n-\t\t\tm_location = locatable.getLocation();\n-\t\t\tm_scope.onFieldValueSet(this, m_contextIndex, atomBridge);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (m_nodeIndex != attributeIndex)\n-\t\t\t{\n-\t\t\t\tm_errorHandler.error(new SmDuplicateKeyFieldException(m_scope.getConstraint().getName(), locatable.getLocation()));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate <A> void textMatched(final List<? extends A> actualValue, final int textIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tif (m_value == null)\n-\t\t{\n-\t\t\tm_value = atomBridge.getC14NString(actualValue);\n-\t\t\tm_nodeIndex = textIndex;\n-\t\t\tm_location = locatable.getLocation();\n-\t\t\tm_scope.onFieldValueSet(this, m_contextIndex, atomBridge);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (m_nodeIndex != textIndex)\n-\t\t\t{\n-\t\t\t\tm_errorHandler.error(new SmDuplicateKeyFieldException(m_scope.getConstraint().getName(), locatable.getLocation()));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * A safe test of whether a type is simple or complex with simple content that is resilient to null.\n-\t */\n-\tprivate static <A> boolean isSimpleTypeOrSimpleContent(final Type type)\n-\t{\n-\t\tif (null != type)\n-\t\t{\n-\t\t\tif (type instanceof SimpleType)\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse if (type instanceof ComplexType)\n-\t\t\t{\n-\t\t\t\tfinal ComplexType complexType = (ComplexType)type;\n-\t\t\t\treturn complexType.getContentType().isSimple();\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError();\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\t}\n+    }\n+\n+    public LocationInSchema getLocation() {\n+        return m_location;\n+    }\n+\n+    private int getMaximumStep(final int branchIdx) {\n+        return m_branches[branchIdx].getStepLength() - 1;\n+    }\n+\n+    public void startElement(final QName elementName, final int elementIndex,\n+                             final Type elementType, final Locatable locatable)\n+        throws AbortException {\n+        m_depth++;\n+\n+        for (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--) {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without\n+            // getting a concurrent modification exception (would happen through\n+            // the list).\n+            final Iterator<IdentityXPathStatus> active = m_active.get(branchIdx).iterator();\n+            while (active.hasNext()) {\n+                final IdentityXPathStatus xps = active.next();\n+                xps.currentStep += 1;\n+                if (xps.currentStep <= getMaximumStep(branchIdx)) {\n+                    if (matches(m_branches[branchIdx], xps.currentStep, elementName)) {\n+                        if (xps.currentStep == getMaximumStep(branchIdx)) {\n+                            // TODO: Should this take place at design time?\n+                            if (isSimpleTypeOrSimpleContent(elementType)) {\n+                                xps.isSimple = true;\n+                            } else {\n+                                m_errorHandler.error(\n+                                    new CvcIdentityConstraintFieldNodeNotSimpleTypeException(\n+                                        m_scope.getConstraint().getName(),\n+                                        locatable.getLocation()));\n+                            }\n+                        }\n+                    } else {\n+                        if (xps.removable) {\n+                            active.remove();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (m_depth > 0 && m_relocatable[branchIdx]) {\n+                if (matches(m_branches[branchIdx], 0, elementName)) {\n+                    final IdentityXPathStatus xps = new IdentityXPathStatus(true);\n+                    if (xps.currentStep == getMaximumStep(branchIdx)) {\n+                        if (isSimpleTypeOrSimpleContent(elementType)) {\n+                            xps.isSimple = true;\n+                        } else {\n+                            m_errorHandler.error(\n+                                new CvcIdentityConstraintFieldNodeNotSimpleTypeException(\n+                                    m_scope.getConstraint().getName(), locatable.getLocation()));\n+                        }\n+                    }\n+                    m_active.get(branchIdx).add(xps);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void endElement(final QName elementName, final int elementIndex,\n+                           final Locatable location) {\n+        // System.out.println(StripQualifiers.strip(getClass().getName()) +\n+        // \".endElement(elementName=\" + elementName + \", elementIndex=\" +\n+        // elementIndex + \")\");\n+\n+        m_depth--;\n+        for (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--) {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without\n+            // getting a concurrent modification exception (would happen through\n+            // the list).\n+            final Iterator<IdentityXPathStatus> it = m_active.get(branchIdx).iterator();\n+            while (it.hasNext()) {\n+                final IdentityXPathStatus xps = it.next();\n+                if (xps.currentStep == getMaximumStep(branchIdx)) {\n+                    xps.isSimple = false;\n+                    if (xps.removable) {\n+                        it.remove();\n+                    }\n+                }\n+                xps.currentStep -= 1;\n+            }\n+\n+            // if (m_depth == 0)\n+            // {\n+            // PreCondition.assertTrue(m_active.get(branchIdx).isEmpty());\n+            // }\n+        }\n+    }\n+\n+    public <A> void attribute(final QName name, final List<? extends A> actualValue,\n+                              final int attributeIndex, final SimpleType attributeType,\n+                              final Locatable locatable, final AtomBridge<A> atomBridge)\n+        throws AbortException {\n+        // System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n+        // + hashCode() + \"].attribute(name=\" + name + \", value=\" +\n+        // GxSupport.atomsToString(actualValue) + \")\");\n+\n+        for (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--) {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without\n+            // getting a concurrent modification exception (would happen through\n+            // the list).\n+            final Iterator<IdentityXPathStatus> active = m_active.get(branchIdx).iterator();\n+            while (active.hasNext()) {\n+                final IdentityXPathStatus xps = active.next();\n+                final int currentStep = xps.currentStep + 1;\n+                final int maximumStep = getMaximumStep(branchIdx);\n+                if (currentStep <= maximumStep) {\n+                    if (matchesAttribute(m_branches[branchIdx], currentStep, name)) {\n+                        if (currentStep == getMaximumStep(branchIdx)) {\n+                            attributeMatched(name, actualValue, attributeIndex, locatable,\n+                                atomBridge);\n+                        }\n+                    } else {\n+                        if (xps.removable) {\n+                            active.remove();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public <A> void text(final List<? extends A> actualValue, final SimpleType actualType,\n+                         final int textIndex, final Locatable locatable,\n+                         final AtomBridge<A> atomBridge) throws AbortException {\n+        for (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--) {\n+            final Iterator<IdentityXPathStatus> it = m_active.get(branchIdx).iterator();\n+            while (it.hasNext()) {\n+                final IdentityXPathStatus xps = it.next();\n+                if (xps.isSimple) {\n+                    textMatched(actualValue, textIndex, locatable, atomBridge);\n+                } else {\n+                    final int currentStep = xps.currentStep + 1;\n+                    final int maximumStep = getMaximumStep(branchIdx);\n+                    if (currentStep <= maximumStep) {\n+                        if (matchesText(m_branches[branchIdx], currentStep)) {\n+                            if (currentStep == maximumStep) {\n+                                textMatched(actualValue, textIndex, locatable, atomBridge);\n+                            }\n+                        } else {\n+                            if (xps.removable) {\n+                                it.remove();\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Determine whether the (QName,isAttribute) combination matches the XPath expression at the specified step index.\n+     */\n+    private boolean matches(final RestrictedXPath xpath, final int idxStep, final QName name) {\n+        if (xpath.isAttribute()) {\n+            return false;\n+        }\n+\n+        if (xpath.isContextNode(idxStep)) {\n+            return true;\n+        } else {\n+            final String stepLN = xpath.getStepLocalName(idxStep);\n+            final String stepNS = xpath.getStepNamespace(idxStep);\n+\n+            if (xpath.isWildcardLocalName(idxStep) &&\n+                (xpath.isWildcardNamespace(idxStep) || stepNS.equals(name.getNamespaceURI()))) {\n+                return true;\n+            } else {\n+                return name.getLocalPart().equals(stepLN) && name.getNamespaceURI().equals(stepNS);\n+            }\n+        }\n+    }\n+\n+    private boolean matchesText(final RestrictedXPath xpath, final int idxStep) {\n+        // System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n+        // + hashCode() + \"].matchesText(idxStep=\" + idxStep + \")\");\n+        if (xpath.isAttribute()) {\n+            return false;\n+        }\n+\n+        return xpath.isContextNode(idxStep);\n+    }\n+\n+    /**\n+     * Determine whether the (QName,isAttribute) combination matches the XPath expression at the specified step index.\n+     */\n+    private boolean matchesAttribute(final RestrictedXPath xpath, final int idxStep,\n+                                     final QName name) {\n+        // System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n+        // + hashCode() + \"].matchesAttribute(\" + xpath + \", idxStep=\" + idxStep\n+        // + \", name=\" + name + \")\");\n+        if (!xpath.isAttribute()) {\n+            return false;\n+        }\n+\n+        if (xpath.isContextNode(idxStep)) {\n+            return true;\n+        } else {\n+            final String stepNS = xpath.getStepNamespace(idxStep);\n+\n+            if (xpath.isWildcardLocalName(idxStep) &&\n+                (xpath.isWildcardNamespace(idxStep) || stepNS.equals(name.getNamespaceURI()))) {\n+                return true;\n+            } else {\n+                final String stepLN = xpath.getStepLocalName(idxStep);\n+                return name.getLocalPart().equals(stepLN) && name.getNamespaceURI().equals(stepNS);\n+            }\n+        }\n+    }\n+\n+    private <A> void attributeMatched(final QName name, final List<? extends A> actualValue,\n+                                      final int attributeIndex, final Locatable locatable,\n+                                      final AtomBridge<A> atomBridge) throws AbortException {\n+        if (m_value == null) {\n+            m_value = atomBridge.getC14NString(actualValue);\n+            m_nodeIndex = attributeIndex;\n+            m_location = locatable.getLocation();\n+            m_scope.onFieldValueSet(this, m_contextIndex, atomBridge);\n+        } else {\n+            if (m_nodeIndex != attributeIndex) {\n+                m_errorHandler.error(\n+                    new SmDuplicateKeyFieldException(m_scope.getConstraint().getName(),\n+                        locatable.getLocation()));\n+            }\n+        }\n+    }\n+\n+    private <A> void textMatched(final List<? extends A> actualValue, final int textIndex,\n+                                 final Locatable locatable, final AtomBridge<A> atomBridge)\n+        throws AbortException {\n+        if (m_value == null) {\n+            m_value = atomBridge.getC14NString(actualValue);\n+            m_nodeIndex = textIndex;\n+            m_location = locatable.getLocation();\n+            m_scope.onFieldValueSet(this, m_contextIndex, atomBridge);\n+        } else {\n+            if (m_nodeIndex != textIndex) {\n+                m_errorHandler.error(\n+                    new SmDuplicateKeyFieldException(m_scope.getConstraint().getName(),\n+                        locatable.getLocation()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A safe test of whether a type is simple or complex with simple content that is resilient to null.\n+     */\n+    private static <A> boolean isSimpleTypeOrSimpleContent(final Type type) {\n+        if (null != type) {\n+            if (type instanceof SimpleType) {\n+                return true;\n+            } else if (type instanceof ComplexType) {\n+                final ComplexType complexType = (ComplexType) type;\n+                return complexType.getContentType().isSimple();\n+            } else {\n+                throw new AssertionError();\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n }\n",
            "diff_size": 406
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/258/IdentityField.java\nindex 2908d50c3b8..c66335701f3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/258/IdentityField.java\n@@ -20,9 +20,7 @@ import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n-\n import javax.xml.namespace.QName;\n-\n import org.genxdm.exceptions.PreCondition;\n import org.genxdm.processor.w3c.xs.exception.cvc.CvcIdentityConstraintFieldNodeNotSimpleTypeException;\n import org.genxdm.processor.w3c.xs.exception.sm.SmDuplicateKeyFieldException;\n@@ -40,406 +38,401 @@ import org.genxdm.xs.types.Type;\n  * Provides a streaming evaluation of a restricted XPath expression. <br/>\n  * When certain conditions are met, a match handler is called. The matched fields gets reported back to its scope.\n  */\n+\n final class IdentityField\n {\n-\t/**\n-\t * The index of the element that is the context for the xs:field evaluation.\n-\t */\n-\tprivate final int m_contextIndex;\n-\tprivate final IdentityScope m_scope;\n-\tprivate final SchemaExceptionHandler m_errorHandler;\n-\n-\t// TODO: temporary\n-//\tprivate List<? extends A> m_value = null;\n-\tString m_value;\n-\tprivate int m_nodeIndex = -1;\n-\tprivate LocationInSchema m_location = null;\n-\n-\t// a List of branches, representing a parsed identity (selector or field)\n-\t// XPath expression\n-\tprivate RestrictedXPath m_branches[];\n-\n-\tprivate final ArrayList<LinkedList<IdentityXPathStatus>> m_active;\n-\n-\t// true if that branch started with \".//\"\n-\tprivate boolean[] m_relocatable;\n-\n-\tprivate int m_depth = -1;\n-\n-\t/**\n-\t * @param xpath\n-\t *            representing the parsed attribute xpath\n-\t */\n-\tpublic IdentityField(final RestrictedXPath xpath, final int contextIndex, final IdentityScope scope, final SchemaExceptionHandler errorHandler)\n-\t{\n-\t\tm_contextIndex = contextIndex;\n-\t\tm_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n-\t\tm_errorHandler = PreCondition.assertArgumentNotNull(errorHandler, \"errorHandler\");\n-\n-\t\t// Count the number of branches, that is, the number of XPath\n-\t\t// expressions separated by \"|\".\n-\t\tint size = 0;\n-\t\tfor (RestrictedXPath branch = xpath; branch != null; branch = branch.getAlternate())\n-\t\t{\n-\t\t\t// System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n-\t\t\t// branch);\n-\t\t\tsize++;\n-\t\t}\n-\n-\t\tm_relocatable = new boolean[size];\n-\t\tm_branches = (RestrictedXPath[])Array.newInstance(RestrictedXPath.class, size);\n-\t\tm_active = new ArrayList<LinkedList<IdentityXPathStatus>>(size);\n-\t\tRestrictedXPath branch = xpath;\n-\t\tfor (int i = size - 1; i >= 0; i--)\n-\t\t{\n-\t\t\t// put them backwards\n-\t\t\tif (null == branch)\n-\t\t\t{\n-\t\t\t\tthrow new RuntimeException();\n-\t\t\t}\n-\t\t\tm_branches[i] = branch;\n-\t\t\tm_relocatable[i] = branch.isRelocatable();\n-\t\t\tbranch = branch.getAlternate();\n-\t\t}\n-\t\tfor (int i = 0; i < size; i++)\n-\t\t{\n-\t\t\t// The XPath expression is already running for each branch.\n-\t\t\tfinal LinkedList<IdentityXPathStatus> e = new LinkedList<IdentityXPathStatus>();\n-\t\t\tfinal IdentityXPathStatus xps = new IdentityXPathStatus(false);\n-\t\t\txps.currentStep = -1;\n-\t\t\te.add(xps);\n-\t\t\tm_active.add(e);\n-\t\t}\n-\t}\n-\n-\tpublic <A> List<? extends A> getTypedValue(AtomBridge<A> bridge)\n-\t{\n-\t    // TODO: so, now fix it.\n-\t    return null;\n-//\t\treturn m_value;\n-\t}\n-\n-\tpublic LocationInSchema getLocation()\n-\t{\n-\t\treturn m_location;\n-\t}\n-\n-\tprivate int getMaximumStep(final int branchIdx)\n-\t{\n-\t\treturn m_branches[branchIdx].getStepLength() - 1;\n-\t}\n-\n-\tpublic void startElement(final QName elementName, final int elementIndex, final Type elementType, final Locatable locatable) throws AbortException\n-\t{\n-\t\tm_depth++;\n-\n-\t\tfor (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without\n-\t\t\t// getting a concurrent modification exception (would happen through\n-\t\t\t// the list).\n-\t\t\tfinal Iterator<IdentityXPathStatus> active = m_active.get(branchIdx).iterator();\n-\t\t\twhile (active.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentityXPathStatus xps = active.next();\n-\t\t\t\txps.currentStep += 1;\n-\t\t\t\tif (xps.currentStep <= getMaximumStep(branchIdx))\n-\t\t\t\t{\n-\t\t\t\t\tif (matches(m_branches[branchIdx], xps.currentStep, elementName))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.currentStep == getMaximumStep(branchIdx))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t// TODO: Should this take place at design time?\n-\t\t\t\t\t\t\tif (isSimpleTypeOrSimpleContent(elementType))\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\txps.isSimple = true;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tm_errorHandler.error(new CvcIdentityConstraintFieldNodeNotSimpleTypeException(m_scope.getConstraint().getName(), locatable.getLocation()));\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tactive.remove();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (m_depth > 0 && m_relocatable[branchIdx])\n-\t\t\t{\n-\t\t\t\tif (matches(m_branches[branchIdx], 0, elementName))\n-\t\t\t\t{\n-\t\t\t\t\tfinal IdentityXPathStatus xps = new IdentityXPathStatus(true);\n-\t\t\t\t\tif (xps.currentStep == getMaximumStep(branchIdx))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (isSimpleTypeOrSimpleContent(elementType))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\txps.isSimple = true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tm_errorHandler.error(new CvcIdentityConstraintFieldNodeNotSimpleTypeException(m_scope.getConstraint().getName(), locatable.getLocation()));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tm_active.get(branchIdx).add(xps);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic void endElement(final QName elementName, final int elementIndex, final Locatable location)\n-\t{\n-\t\t// System.out.println(StripQualifiers.strip(getClass().getName()) +\n-\t\t// \".endElement(elementName=\" + elementName + \", elementIndex=\" +\n-\t\t// elementIndex + \")\");\n-\n-\t\tm_depth--;\n-\t\tfor (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without\n-\t\t\t// getting a concurrent modification exception (would happen through\n-\t\t\t// the list).\n-\t\t\tfinal Iterator<IdentityXPathStatus> it = m_active.get(branchIdx).iterator();\n-\t\t\twhile (it.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentityXPathStatus xps = it.next();\n-\t\t\t\tif (xps.currentStep == getMaximumStep(branchIdx))\n-\t\t\t\t{\n-\t\t\t\t\txps.isSimple = false;\n-\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\txps.currentStep -= 1;\n-\t\t\t}\n-\n-\t\t\t// if (m_depth == 0)\n-\t\t\t// {\n-\t\t\t// PreCondition.assertTrue(m_active.get(branchIdx).isEmpty());\n-\t\t\t// }\n-\t\t}\n-\t}\n-\n-\tpublic <A> void attribute(final QName name, final List<? extends A> actualValue, final int attributeIndex, final SimpleType attributeType, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\t// System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n-\t\t// + hashCode() + \"].attribute(name=\" + name + \", value=\" +\n-\t\t// GxSupport.atomsToString(actualValue) + \")\");\n-\n-\t\tfor (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n-\t\t{\n-\t\t\t// Note: Use an Iterator here so that we can remove (through the\n-\t\t\t// iterator) without\n-\t\t\t// getting a concurrent modification exception (would happen through\n-\t\t\t// the list).\n-\t\t\tfinal Iterator<IdentityXPathStatus> active = m_active.get(branchIdx).iterator();\n-\t\t\twhile (active.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentityXPathStatus xps = active.next();\n-\t\t\t\tfinal int currentStep = xps.currentStep + 1;\n-\t\t\t\tfinal int maximumStep = getMaximumStep(branchIdx);\n-\t\t\t\tif (currentStep <= maximumStep)\n-\t\t\t\t{\n-\t\t\t\t\tif (matchesAttribute(m_branches[branchIdx], currentStep, name))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (currentStep == getMaximumStep(branchIdx))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tattributeMatched(name, actualValue, attributeIndex, locatable, atomBridge);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tactive.remove();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tpublic <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final int textIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tfor (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n-\t\t{\n-\t\t\tfinal Iterator<IdentityXPathStatus> it = m_active.get(branchIdx).iterator();\n-\t\t\twhile (it.hasNext())\n-\t\t\t{\n-\t\t\t\tfinal IdentityXPathStatus xps = it.next();\n-\t\t\t\tif (xps.isSimple)\n-\t\t\t\t{\n-\t\t\t\t\ttextMatched(actualValue, textIndex, locatable, atomBridge);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tfinal int currentStep = xps.currentStep + 1;\n-\t\t\t\t\tfinal int maximumStep = getMaximumStep(branchIdx);\n-\t\t\t\t\tif (currentStep <= maximumStep)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (matchesText(m_branches[branchIdx], currentStep))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (currentStep == maximumStep)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\ttextMatched(actualValue, textIndex, locatable, atomBridge);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tif (xps.removable)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tit.remove();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Determine whether the (QName,isAttribute) combination matches the XPath expression at the specified step index.\n-\t */\n-\tprivate boolean matches(final RestrictedXPath xpath, final int idxStep, final QName name)\n-\t{\n-\t\tif (xpath.isAttribute())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (xpath.isContextNode(idxStep))\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal String stepLN = xpath.getStepLocalName(idxStep);\n-\t\t\tfinal String stepNS = xpath.getStepNamespace(idxStep);\n-\n-\t\t\tif (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(name.getNamespaceURI())))\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\treturn name.getLocalPart().equals(stepLN) && name.getNamespaceURI().equals(stepNS);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate boolean matchesText(final RestrictedXPath xpath, final int idxStep)\n-\t{\n-\t\t// System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n-\t\t// + hashCode() + \"].matchesText(idxStep=\" + idxStep + \")\");\n-\t\tif (xpath.isAttribute())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\treturn xpath.isContextNode(idxStep);\n-\t}\n-\n-\t/**\n-\t * Determine whether the (QName,isAttribute) combination matches the XPath expression at the specified step index.\n-\t */\n-\tprivate boolean matchesAttribute(final RestrictedXPath xpath, final int idxStep, final QName name)\n-\t{\n-\t\t// System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n-\t\t// + hashCode() + \"].matchesAttribute(\" + xpath + \", idxStep=\" + idxStep\n-\t\t// + \", name=\" + name + \")\");\n-\t\tif (!xpath.isAttribute())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (xpath.isContextNode(idxStep))\n-\t\t{\n-\t\t\treturn true;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tfinal String stepNS = xpath.getStepNamespace(idxStep);\n-\n-\t\t\tif (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(name.getNamespaceURI())))\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tfinal String stepLN = xpath.getStepLocalName(idxStep);\n-\t\t\t\treturn name.getLocalPart().equals(stepLN) && name.getNamespaceURI().equals(stepNS);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate <A> void attributeMatched(final QName name, final List<? extends A> actualValue, final int attributeIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tif (m_value == null)\n-\t\t{\n-\t\t\tm_value = atomBridge.getC14NString(actualValue);\n-\t\t\tm_nodeIndex = attributeIndex;\n-\t\t\tm_location = locatable.getLocation();\n-\t\t\tm_scope.onFieldValueSet(this, m_contextIndex, atomBridge);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (m_nodeIndex != attributeIndex)\n-\t\t\t{\n-\t\t\t\tm_errorHandler.error(new SmDuplicateKeyFieldException(m_scope.getConstraint().getName(), locatable.getLocation()));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate <A> void textMatched(final List<? extends A> actualValue, final int textIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n-\t{\n-\t\tif (m_value == null)\n-\t\t{\n-\t\t\tm_value = atomBridge.getC14NString(actualValue);\n-\t\t\tm_nodeIndex = textIndex;\n-\t\t\tm_location = locatable.getLocation();\n-\t\t\tm_scope.onFieldValueSet(this, m_contextIndex, atomBridge);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tif (m_nodeIndex != textIndex)\n-\t\t\t{\n-\t\t\t\tm_errorHandler.error(new SmDuplicateKeyFieldException(m_scope.getConstraint().getName(), locatable.getLocation()));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * A safe test of whether a type is simple or complex with simple content that is resilient to null.\n-\t */\n-\tprivate static <A> boolean isSimpleTypeOrSimpleContent(final Type type)\n-\t{\n-\t\tif (null != type)\n-\t\t{\n-\t\t\tif (type instanceof SimpleType)\n-\t\t\t{\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\telse if (type instanceof ComplexType)\n-\t\t\t{\n-\t\t\t\tfinal ComplexType complexType = (ComplexType)type;\n-\t\t\t\treturn complexType.getContentType().isSimple();\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new AssertionError();\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-}\n+    /**\n+     * The index of the element that is the context for the xs:field evaluation.\n+     */\n+    private final int m_contextIndex;\n+    private final IdentityScope m_scope;\n+    private final SchemaExceptionHandler m_errorHandler;\n+\n+    // TODO: temporary\n+//  private List<? extends A> m_value = null;\n+    String m_value;\n+    private int m_nodeIndex = -1;\n+    private LocationInSchema m_location = null;\n+\n+    // a List of branches, representing a parsed identity (selector or field)\n+    // XPath expression\n+    private RestrictedXPath m_branches[];\n+    private final ArrayList<LinkedList<IdentityXPathStatus>> m_active;\n+\n+    // true if that branch started with \".//\"\n+    private boolean[] m_relocatable;\n+    private int m_depth = -1;\n+\n+    /**\n+     * @param xpath\n+     *            representing the parsed attribute xpath\n+     */\n+\n+    public IdentityField(final RestrictedXPath xpath, final int contextIndex, final IdentityScope scope, final SchemaExceptionHandler errorHandler)\n+    {\n+        m_contextIndex = contextIndex;\n+        m_scope = PreCondition.assertArgumentNotNull(scope, \"scope\");\n+        m_errorHandler = PreCondition.assertArgumentNotNull(errorHandler, \"errorHandler\");\n+\n+        // Count the number of branches, that is, the number of XPath\n+        // expressions separated by \"|\".\n+\n+        int size = 0;\n+        for (RestrictedXPath branch = xpath; branch != null; branch = branch.getAlternate())\n+        {\n+            // System.out.println(\"IdentityPathEvaluation.<init> Branch = \" +\n+            // branch);\n+            size++;\n+        }\n+        m_relocatable = new boolean[size];\n+        m_branches = (RestrictedXPath[])Array.newInstance(RestrictedXPath.class, size);\n+        m_active = new ArrayList<LinkedList<IdentityXPathStatus>>(size);\n+        RestrictedXPath branch = xpath;\n+        for (int i = size - 1; i >= 0; i--)\n+        {\n+            // put them backwards\n+            if (null == branch)\n+            {\n+                throw new RuntimeException();\n+            }\n+            m_branches[i] = branch;\n+            m_relocatable[i] = branch.isRelocatable();\n+            branch = branch.getAlternate();\n+        }\n+        for (int i = 0; i < size; i++)\n+        {\n+            // The XPath expression is already running for each branch.\n+            final LinkedList<IdentityXPathStatus> e = new LinkedList<IdentityXPathStatus>();\n+            final IdentityXPathStatus xps = new IdentityXPathStatus(false);\n+            xps.currentStep = -1;\n+            e.add(xps);\n+            m_active.add(e);\n+        }\n+    }\n+\n+    public <A> List<? extends A> getTypedValue(AtomBridge<A> bridge)\n+    {\n+        // TODO: so, now fix it.\n+        return null;\n+//      return m_value;\n+    }\n+\n+    public LocationInSchema getLocation()\n+    {\n+        return m_location;\n+    }\n+\n+    private int getMaximumStep(final int branchIdx)\n+    {\n+        return m_branches[branchIdx].getStepLength() - 1;\n+    }\n+\n+    public void startElement(final QName elementName, final int elementIndex, final Type elementType, final Locatable locatable)\n+        throws AbortException\n+    {\n+        m_depth++;\n+        for (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n+        {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without\n+            // getting a concurrent modification exception (would happen through\n+            // the list).\n+            final Iterator<IdentityXPathStatus> active = m_active.get(branchIdx).iterator();\n+            while (active.hasNext())\n+            {\n+                final IdentityXPathStatus xps = active.next();\n+                xps.currentStep += 1;\n+                if (xps.currentStep <= getMaximumStep(branchIdx))\n+                {\n+                    if (matches(m_branches[branchIdx], xps.currentStep, elementName))\n+                    {\n+                        if (xps.currentStep == getMaximumStep(branchIdx))\n+                        {\n+                            // TODO: Should this take place at design time?\n+                            if (isSimpleTypeOrSimpleContent(elementType))\n+                            {\n+                                xps.isSimple = true;\n+                            }\n+                            else\n+                            {\n+                                m_errorHandler.error(new CvcIdentityConstraintFieldNodeNotSimpleTypeException(m_scope.getConstraint().getName(), locatable.getLocation()));\n+                            }\n+                        }\n+                    }\n+                    else\n+                    {\n+                        if (xps.removable)\n+                        {\n+                            active.remove();\n+                        }\n+                    }\n+                }\n+            }\n+            if (m_depth > 0 && m_relocatable[branchIdx])\n+            {\n+                if (matches(m_branches[branchIdx], 0, elementName))\n+                {\n+                    final IdentityXPathStatus xps = new IdentityXPathStatus(true);\n+                    if (xps.currentStep == getMaximumStep(branchIdx))\n+                    {\n+                        if (isSimpleTypeOrSimpleContent(elementType))\n+                        {\n+                            xps.isSimple = true;\n+                        }\n+                        else\n+                        {\n+                            m_errorHandler.error(new CvcIdentityConstraintFieldNodeNotSimpleTypeException(m_scope.getConstraint().getName(), locatable.getLocation()));\n+                        }\n+                    }\n+                    m_active.get(branchIdx).add(xps);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void endElement(final QName elementName, final int elementIndex, final Locatable location)\n+    {\n+        // System.out.println(StripQualifiers.strip(getClass().getName()) +\n+        // \".endElement(elementName=\" + elementName + \", elementIndex=\" +\n+        // elementIndex + \")\");\n+        m_depth--;\n+        for (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n+        {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without\n+            // getting a concurrent modification exception (would happen through\n+            // the list).\n+            final Iterator<IdentityXPathStatus> it = m_active.get(branchIdx).iterator();\n+            while (it.hasNext())\n+            {\n+                final IdentityXPathStatus xps = it.next();\n+                if (xps.currentStep == getMaximumStep(branchIdx))\n+                {\n+                    xps.isSimple = false;\n+                    if (xps.removable)\n+                    {\n+                        it.remove();\n+                    }\n+                }\n+                xps.currentStep -= 1;\n+            }\n+\n+            // if (m_depth == 0)\n+            // {\n+            // PreCondition.assertTrue(m_active.get(branchIdx).isEmpty());\n+            // }\n+        }\n+    }\n+\n+    public <A> void attribute(final QName name, final List<? extends A> actualValue, final int attributeIndex, final SimpleType attributeType, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        // System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n+        // + hashCode() + \"].attribute(name=\" + name + \", value=\" +\n+        // GxSupport.atomsToString(actualValue) + \")\");\n+        for (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n+        {\n+            // Note: Use an Iterator here so that we can remove (through the\n+            // iterator) without\n+            // getting a concurrent modification exception (would happen through\n+            // the list).\n+            final Iterator<IdentityXPathStatus> active = m_active.get(branchIdx).iterator();\n+            while (active.hasNext())\n+            {\n+                final IdentityXPathStatus xps = active.next();\n+                final int currentStep = xps.currentStep + 1;\n+                final int maximumStep = getMaximumStep(branchIdx);\n+                if (currentStep <= maximumStep)\n+                {\n+                    if (matchesAttribute(m_branches[branchIdx], currentStep, name))\n+                    {\n+                        if (currentStep == getMaximumStep(branchIdx))\n+                        {\n+                            attributeMatched(name, actualValue, attributeIndex, locatable, atomBridge);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        if (xps.removable)\n+                        {\n+                            active.remove();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public <A> void text(final List<? extends A> actualValue, final SimpleType actualType, final int textIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        for (int branchIdx = m_branches.length - 1; branchIdx >= 0; branchIdx--)\n+        {\n+            final Iterator<IdentityXPathStatus> it = m_active.get(branchIdx).iterator();\n+            while (it.hasNext())\n+            {\n+                final IdentityXPathStatus xps = it.next();\n+                if (xps.isSimple)\n+                {\n+                    textMatched(actualValue, textIndex, locatable, atomBridge);\n+                }\n+                else\n+                {\n+                    final int currentStep = xps.currentStep + 1;\n+                    final int maximumStep = getMaximumStep(branchIdx);\n+                    if (currentStep <= maximumStep)\n+                    {\n+                        if (matchesText(m_branches[branchIdx], currentStep))\n+                        {\n+                            if (currentStep == maximumStep)\n+                            {\n+                                textMatched(actualValue, textIndex, locatable, atomBridge);\n+                            }\n+                        }\n+                        else\n+                        {\n+                            if (xps.removable)\n+                            {\n+                                it.remove();\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Determine whether the (QName,isAttribute) combination matches the XPath expression at the specified step index.\n+     */\n+\n+    private boolean matches(final RestrictedXPath xpath, final int idxStep, final QName name)\n+    {\n+        if (xpath.isAttribute())\n+        {\n+            return false;\n+        }\n+        if (xpath.isContextNode(idxStep))\n+        {\n+            return true;\n+        }\n+        else\n+        {\n+            final String stepLN = xpath.getStepLocalName(idxStep);\n+            final String stepNS = xpath.getStepNamespace(idxStep);\n+            if (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(name.getNamespaceURI())))\n+            {\n+                return true;\n+            }\n+            else\n+            {\n+                return name.getLocalPart().equals(stepLN) && name.getNamespaceURI().equals(stepNS);\n+            }\n+        }\n+    }\n+\n+    private boolean matchesText(final RestrictedXPath xpath, final int idxStep)\n+    {\n+        // System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n+        // + hashCode() + \"].matchesText(idxStep=\" + idxStep + \")\");\n+        if (xpath.isAttribute())\n+        {\n+            return false;\n+        }\n+        return xpath.isContextNode(idxStep);\n+    }\n+\n+    /**\n+     * Determine whether the (QName,isAttribute) combination matches the XPath expression at the specified step index.\n+     */\n+\n+    private boolean matchesAttribute(final RestrictedXPath xpath, final int idxStep, final QName name)\n+    {\n+        // System.out.println(StripQualifiers.strip(getClass().getName()) + \"[\"\n+        // + hashCode() + \"].matchesAttribute(\" + xpath + \", idxStep=\" + idxStep\n+        // + \", name=\" + name + \")\");\n+        if (!xpath.isAttribute())\n+        {\n+            return false;\n+        }\n+        if (xpath.isContextNode(idxStep))\n+        {\n+            return true;\n+        }\n+        else\n+        {\n+            final String stepNS = xpath.getStepNamespace(idxStep);\n+            if (xpath.isWildcardLocalName(idxStep) && (xpath.isWildcardNamespace(idxStep) || stepNS.equals(name.getNamespaceURI())))\n+            {\n+                return true;\n+            }\n+            else\n+            {\n+                final String stepLN = xpath.getStepLocalName(idxStep);\n+                return name.getLocalPart().equals(stepLN) && name.getNamespaceURI().equals(stepNS);\n+            }\n+        }\n+    }\n+\n+    private <A> void attributeMatched(final QName name, final List<? extends A> actualValue, final int attributeIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        if (m_value == null)\n+        {\n+            m_value = atomBridge.getC14NString(actualValue);\n+            m_nodeIndex = attributeIndex;\n+            m_location = locatable.getLocation();\n+            m_scope.onFieldValueSet(this, m_contextIndex, atomBridge);\n+        }\n+        else\n+        {\n+            if (m_nodeIndex != attributeIndex)\n+            {\n+                m_errorHandler.error(new SmDuplicateKeyFieldException(m_scope.getConstraint().getName(), locatable.getLocation()));\n+            }\n+        }\n+    }\n+\n+    private <A> void textMatched(final List<? extends A> actualValue, final int textIndex, final Locatable locatable, final AtomBridge<A> atomBridge) throws AbortException\n+    {\n+        if (m_value == null)\n+        {\n+            m_value = atomBridge.getC14NString(actualValue);\n+            m_nodeIndex = textIndex;\n+            m_location = locatable.getLocation();\n+            m_scope.onFieldValueSet(this, m_contextIndex, atomBridge);\n+        }\n+        else\n+        {\n+            if (m_nodeIndex != textIndex)\n+            {\n+                m_errorHandler.error(new SmDuplicateKeyFieldException(m_scope.getConstraint().getName(), locatable.getLocation()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A safe test of whether a type is simple or complex with simple content that is resilient to null.\n+     */\n+\n+    private static <A> boolean isSimpleTypeOrSimpleContent(final Type type)\n+    {\n+        if (null != type)\n+        {\n+            if (type instanceof SimpleType)\n+            {\n+                return true;\n+            }\n+            else if (type instanceof ComplexType)\n+            {\n+                final ComplexType complexType = (ComplexType)type;\n+                return complexType.getContentType().isSimple();\n+            }\n+            else\n+            {\n+                throw new AssertionError();\n+            }\n+        }\n+        else\n+        {\n+            return false;\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
            "diff_size": 404
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "46",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/258/IdentityField.java\nindex 2908d50c3b8..792b49e11eb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/258/IdentityField.java\n@@ -42,10 +42,10 @@ import org.genxdm.xs.types.Type;\n  */\n final class IdentityField\n {\n-\t/**\n+/**\n \t * The index of the element that is the context for the xs:field evaluation.\n \t */\n-\tprivate final int m_contextIndex;\n+ private final int m_contextIndex;\n \tprivate final IdentityScope m_scope;\n \tprivate final SchemaExceptionHandler m_errorHandler;\n \n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "46",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/258/IdentityField.java\nindex 2908d50c3b8..0ac4b7ede6c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/258/IdentityField.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/258/IdentityField.java\n@@ -42,10 +42,10 @@ import org.genxdm.xs.types.Type;\n  */\n final class IdentityField\n {\n-\t/**\n+    /**\n \t * The index of the element that is the context for the xs:field evaluation.\n \t */\n-\tprivate final int m_contextIndex;\n+ private final int m_contextIndex;\n \tprivate final IdentityScope m_scope;\n \tprivate final SchemaExceptionHandler m_errorHandler;\n \n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}