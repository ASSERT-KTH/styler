{
    "project_name": "findbugsproject-findbugs",
    "error_id": "58",
    "information": {
        "errors": [
            {
                "line": "364",
                "column": "9",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "            return true;\n        if (superDesc.getClassName().equals(\"java/lang/Object\"))\n        \treturn true;\n\n        if (true) {\n        XClass xclass = AnalysisContext.currentXFactory().getXClass(subDesc);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/58/Subtypes2.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/58/Subtypes2.java\nindex 7c4aa3e0690..e1483a44440 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/58/Subtypes2.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler/58/Subtypes2.java\n@@ -361,7 +361,7 @@ public class Subtypes2 {\n         if (subDesc.equals(superDesc))\n             return true;\n         if (superDesc.getClassName().equals(\"java/lang/Object\"))\n-        \treturn true;\n+        return true;\n \n         if (true) {\n         XClass xclass = AnalysisContext.currentXFactory().getXClass(subDesc);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/58/Subtypes2.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/58/Subtypes2.java\nindex 7c4aa3e0690..d771e8def9c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/58/Subtypes2.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/intellij/58/Subtypes2.java\n@@ -158,10 +158,12 @@ public class Subtypes2 {\n     }\n \n     public static boolean instanceOf(JavaClass subtype, @DottedClassName String dottedSupertype) {\n-        if (subtype.getClassName().equals(dottedSupertype) || subtype.getSuperclassName().equals(dottedSupertype))\n+        if (subtype.getClassName().equals(dottedSupertype) || subtype.getSuperclassName().equals(dottedSupertype)) {\n             return true;\n-        if (subtype.getSuperclassName().equals(\"java.lang.Object\") && subtype.getInterfaceIndices().length == 0)\n+        }\n+        if (subtype.getSuperclassName().equals(\"java.lang.Object\") && subtype.getInterfaceIndices().length == 0) {\n             return false;\n+        }\n         Subtypes2 subtypes2 = AnalysisContext.currentAnalysisContext().getSubtypes2();\n         ClassDescriptor subDescriptor = DescriptorFactory.createClassDescriptor(subtype);\n         ClassDescriptor superDescriptor = DescriptorFactory.createClassDescriptorFromDottedClassName(dottedSupertype);\n@@ -177,13 +179,13 @@ public class Subtypes2 {\n      * Add an application class, and its transitive supertypes, to the\n      * inheritance graph.\n      *\n-     * @param appXClass\n-     *            application XClass to add to the inheritance graph\n+     * @param appXClass application XClass to add to the inheritance graph\n      */\n     public void addApplicationClass(XClass appXClass) {\n         for (XMethod m : appXClass.getXMethods()) {\n-            if (m.isStub())\n+            if (m.isStub()) {\n                 return;\n+            }\n         }\n         ClassVertex vertex = addClassAndGetClassVertex(appXClass);\n         vertex.markAsApplicationClass();\n@@ -204,8 +206,7 @@ public class Subtypes2 {\n      * Add a class or interface, and its transitive supertypes, to the\n      * inheritance graph.\n      *\n-     * @param xclass\n-     *            XClass to add to the inheritance graph\n+     * @param xclass XClass to add to the inheritance graph\n      */\n     public void addClass(XClass xclass) {\n         addClassAndGetClassVertex(xclass);\n@@ -214,8 +215,7 @@ public class Subtypes2 {\n     /**\n      * Add an XClass and all of its supertypes to the InheritanceGraph.\n      *\n-     * @param xclass\n-     *            an XClass\n+     * @param xclass an XClass\n      * @return the ClassVertex representing the class in the InheritanceGraph\n      */\n     private ClassVertex addClassAndGetClassVertex(XClass xclass) {\n@@ -273,14 +273,11 @@ public class Subtypes2 {\n      * Throws ClassNotFoundException if the question cannot be answered\n      * definitively due to a missing class.\n      *\n-     * @param type\n-     *            a ReferenceType\n-     * @param possibleSupertype\n-     *            another Reference type\n+     * @param type              a ReferenceType\n+     * @param possibleSupertype another Reference type\n      * @return true if <code>type</code> is a subtype of\n-     *         <code>possibleSupertype</code>, false if not\n-     * @throws ClassNotFoundException\n-     *             if a missing class prevents a definitive answer\n+     * <code>possibleSupertype</code>, false if not\n+     * @throws ClassNotFoundException if a missing class prevents a definitive answer\n      */\n     public boolean isSubtype(ReferenceType type, ReferenceType possibleSupertype) throws ClassNotFoundException {\n \n@@ -288,10 +285,12 @@ public class Subtypes2 {\n         if (type.equals(possibleSupertype)) {\n             return true;\n         }\n-        if (possibleSupertype.equals(Type.OBJECT))\n+        if (possibleSupertype.equals(Type.OBJECT)) {\n             return true;\n-        if (type.equals(Type.OBJECT))\n+        }\n+        if (type.equals(Type.OBJECT)) {\n             return false;\n+        }\n \n         boolean typeIsObjectType = (type instanceof ObjectType);\n         boolean possibleSupertypeIsObjectType = (possibleSupertype instanceof ObjectType);\n@@ -335,8 +334,8 @@ public class Subtypes2 {\n             // If dimensions differ, see if element types are compatible.\n             if (typeAsArrayType.getDimensions() > possibleSupertypeAsArrayType.getDimensions()) {\n                 return isSubtype(\n-                        new ArrayType(typeBasicType, typeAsArrayType.getDimensions()\n-                                - possibleSupertypeAsArrayType.getDimensions()), (ObjectType) possibleSupertypeBasicType);\n+                    new ArrayType(typeBasicType, typeAsArrayType.getDimensions()\n+                        - possibleSupertypeAsArrayType.getDimensions()), (ObjectType) possibleSupertypeBasicType);\n             }\n \n             // type's base type must be a subtype of possibleSupertype's base\n@@ -358,24 +357,30 @@ public class Subtypes2 {\n     public boolean isSubtype(ClassDescriptor subDesc, ClassDescriptor superDesc) throws ClassNotFoundException {\n         assert subDesc != null;\n         assert superDesc != null;\n-        if (subDesc.equals(superDesc))\n+        if (subDesc.equals(superDesc)) {\n+            return true;\n+        }\n+        if (superDesc.getClassName().equals(\"java/lang/Object\")) {\n             return true;\n-        if (superDesc.getClassName().equals(\"java/lang/Object\"))\n-        \treturn true;\n+        }\n \n         if (true) {\n-        XClass xclass = AnalysisContext.currentXFactory().getXClass(subDesc);\n-        if (xclass != null) {\n-            ClassDescriptor xSuper = xclass.getSuperclassDescriptor();\n-            if (superDesc.equals(xSuper))\n-                return true;\n-            ClassDescriptor[] interfaces = xclass.getInterfaceDescriptorList();\n-            for (ClassDescriptor i : interfaces)\n-                if (superDesc.equals(i))\n+            XClass xclass = AnalysisContext.currentXFactory().getXClass(subDesc);\n+            if (xclass != null) {\n+                ClassDescriptor xSuper = xclass.getSuperclassDescriptor();\n+                if (superDesc.equals(xSuper)) {\n                     return true;\n-            if (xSuper == null && interfaces.length == 0)\n-                return false;\n-        }\n+                }\n+                ClassDescriptor[] interfaces = xclass.getInterfaceDescriptorList();\n+                for (ClassDescriptor i : interfaces) {\n+                    if (superDesc.equals(i)) {\n+                        return true;\n+                    }\n+                }\n+                if (xSuper == null && interfaces.length == 0) {\n+                    return false;\n+                }\n+            }\n         }\n \n         SupertypeQueryResults supertypeQueryResults = getSupertypeQueryResults(subDesc);\n@@ -388,14 +393,11 @@ public class Subtypes2 {\n      * Throws ClassNotFoundException if the question cannot be answered\n      * definitively due to a missing class.\n      *\n-     * @param type\n-     *            a ReferenceType\n-     * @param possibleSupertype\n-     *            another Reference type\n+     * @param type              a ReferenceType\n+     * @param possibleSupertype another Reference type\n      * @return true if <code>type</code> is a subtype of\n-     *         <code>possibleSupertype</code>, false if not\n-     * @throws ClassNotFoundException\n-     *             if a missing class prevents a definitive answer\n+     * <code>possibleSupertype</code>, false if not\n+     * @throws ClassNotFoundException if a missing class prevents a definitive answer\n      */\n     public boolean isSubtype(ObjectType type, ObjectType possibleSupertype) throws ClassNotFoundException {\n         if (DEBUG_QUERIES) {\n@@ -461,10 +463,8 @@ public class Subtypes2 {\n      * getFirstCommonSuperclass() method in {@link ReferenceType}.\n      * </p>\n      *\n-     * @param a\n-     *            a ReferenceType\n-     * @param b\n-     *            another ReferenceType\n+     * @param a a ReferenceType\n+     * @param b another ReferenceType\n      * @return the first common superclass of <code>a</code> and <code>b</code>\n      * @throws ClassNotFoundException\n      */\n@@ -483,7 +483,7 @@ public class Subtypes2 {\n     }\n \n     private ReferenceType computeFirstCommonSuperclassOfReferenceTypes(ReferenceType a, ReferenceType b)\n-            throws ClassNotFoundException {\n+        throws ClassNotFoundException {\n         boolean aIsArrayType = (a instanceof ArrayType);\n         boolean bIsArrayType = (b instanceof ArrayType);\n \n@@ -514,15 +514,13 @@ public class Subtypes2 {\n     /**\n      * Get first common supertype of arrays with the same number of dimensions.\n      *\n-     * @param aArrType\n-     *            an ArrayType\n-     * @param bArrType\n-     *            another ArrayType with the same number of dimensions\n+     * @param aArrType an ArrayType\n+     * @param bArrType another ArrayType with the same number of dimensions\n      * @return first common supertype\n      * @throws ClassNotFoundException\n      */\n     private ReferenceType computeFirstCommonSuperclassOfSameDimensionArrays(ArrayType aArrType, ArrayType bArrType)\n-            throws ClassNotFoundException {\n+        throws ClassNotFoundException {\n         assert aArrType.getDimensions() == bArrType.getDimensions();\n \n         Type aBaseType = aArrType.getBasicType();\n@@ -560,10 +558,8 @@ public class Subtypes2 {\n      * Get the first common superclass of arrays with different numbers of\n      * dimensions.\n      *\n-     * @param aArrType\n-     *            an ArrayType\n-     * @param bArrType\n-     *            another ArrayType\n+     * @param aArrType an ArrayType\n+     * @param bArrType another ArrayType\n      * @return ReferenceType representing first common superclass\n      */\n     private ReferenceType computeFirstCommonSuperclassOfDifferentDimensionArrays(ArrayType aArrType, ArrayType bArrType) {\n@@ -618,10 +614,8 @@ public class Subtypes2 {\n      * getFirstCommonSuperclass() method in {@link ReferenceType}.\n      * </p>\n      *\n-     * @param a\n-     *            an ObjectType\n-     * @param b\n-     *            another ObjectType\n+     * @param a an ObjectType\n+     * @param b another ObjectType\n      * @return the first common superclass of <code>a</code> and <code>b</code>\n      * @throws ClassNotFoundException\n      */\n@@ -650,10 +644,12 @@ public class Subtypes2 {\n \n         Set<ClassDescriptor> aSuperTypes = computeKnownSupertypes(aDesc);\n         Set<ClassDescriptor> bSuperTypes = computeKnownSupertypes(bDesc);\n-        if (bSuperTypes.contains(aDesc))\n+        if (bSuperTypes.contains(aDesc)) {\n             return a;\n-        if (aSuperTypes.contains(bDesc))\n+        }\n+        if (aSuperTypes.contains(bDesc)) {\n             return b;\n+        }\n         ArrayList<ClassVertex> aSuperList = getAllSuperclassVertices(aVertex);\n         ArrayList<ClassVertex> bSuperList = getAllSuperclassVertices(bVertex);\n \n@@ -672,22 +668,26 @@ public class Subtypes2 {\n             aIndex--;\n             bIndex--;\n         }\n-        if (lastCommonInBackwardsSearch == null)\n+        if (lastCommonInBackwardsSearch == null) {\n             firstCommonSupertype = Type.OBJECT;\n-        else\n+        } else {\n             firstCommonSupertype = ObjectTypeFactory.getInstance(lastCommonInBackwardsSearch.getClassDescriptor()\n-                    .toDottedClassName());\n+                .toDottedClassName());\n+        }\n         if (firstCommonSupertype.equals(Type.OBJECT)) {\n             // see if we can't do better\n             ClassDescriptor objDesc = DescriptorFactory.getClassDescriptor(Type.OBJECT);\n             aSuperTypes.retainAll(bSuperTypes);\n             aSuperTypes.remove(objDesc);\n-            for (ClassDescriptor c : aSuperTypes)\n-                if (c.getPackageName().equals(aDesc.getPackageName()) || c.getPackageName().equals(bDesc.getPackageName()))\n+            for (ClassDescriptor c : aSuperTypes) {\n+                if (c.getPackageName().equals(aDesc.getPackageName()) || c.getPackageName().equals(bDesc.getPackageName())) {\n                     return ObjectTypeFactory.getInstance(c.toDottedClassName());\n+                }\n+            }\n \n-            for (ClassDescriptor c : aSuperTypes)\n+            for (ClassDescriptor c : aSuperTypes) {\n                 return ObjectTypeFactory.getInstance(c.toDottedClassName());\n+            }\n         }\n \n         return firstCommonSupertype;\n@@ -716,8 +716,7 @@ public class Subtypes2 {\n      * in order, including the class itself (which is trivially its own\n      * superclass as far as \"first common superclass\" queries are concerned.)\n      *\n-     * @param vertex\n-     *            a ClassVertex\n+     * @param vertex a ClassVertex\n      * @return list of all superclass vertices in order\n      */\n     private ArrayList<ClassVertex> getAllSuperclassVertices(ClassVertex vertex) throws ClassNotFoundException {\n@@ -737,8 +736,7 @@ public class Subtypes2 {\n      * Get known subtypes of given class. The set returned <em>DOES</em> include\n      * the class itself.\n      *\n-     * @param classDescriptor\n-     *            ClassDescriptor naming a class\n+     * @param classDescriptor ClassDescriptor naming a class\n      * @return Set of ClassDescriptors which are the known subtypes of the class\n      * @throws ClassNotFoundException\n      */\n@@ -754,8 +752,7 @@ public class Subtypes2 {\n     /**\n      * Determine whether or not the given class has any known subtypes.\n      *\n-     * @param classDescriptor\n-     *            ClassDescriptor naming a class\n+     * @param classDescriptor ClassDescriptor naming a class\n      * @return true if the class has subtypes, false if it has no subtypes\n      * @throws ClassNotFoundException\n      */\n@@ -770,8 +767,7 @@ public class Subtypes2 {\n     /**\n      * Get known subtypes of given class.\n      *\n-     * @param classDescriptor\n-     *            ClassDescriptor naming a class\n+     * @param classDescriptor ClassDescriptor naming a class\n      * @return Set of ClassDescriptors which are the known subtypes of the class\n      * @throws ClassNotFoundException\n      */\n@@ -792,15 +788,13 @@ public class Subtypes2 {\n     /**\n      * Get the set of common subtypes of the two given classes.\n      *\n-     * @param classDescriptor1\n-     *            a ClassDescriptor naming a class\n-     * @param classDescriptor2\n-     *            a ClassDescriptor naming another class\n+     * @param classDescriptor1 a ClassDescriptor naming a class\n+     * @param classDescriptor2 a ClassDescriptor naming another class\n      * @return Set containing all common transitive subtypes of the two classes\n      * @throws ClassNotFoundException\n      */\n     public Set<ClassDescriptor> getTransitiveCommonSubtypes(ClassDescriptor classDescriptor1, ClassDescriptor classDescriptor2)\n-            throws ClassNotFoundException {\n+        throws ClassNotFoundException {\n         Set<ClassDescriptor> subtypes1 = getSubtypes(classDescriptor1);\n         Set<ClassDescriptor> result = new HashSet<ClassDescriptor>(subtypes1);\n         Set<ClassDescriptor> subtypes2 = getSubtypes(classDescriptor2);\n@@ -814,7 +808,7 @@ public class Subtypes2 {\n      * @return Collection of all XClass objects\n      */\n     public Collection<XClass> getXClassCollection() {\n-        return Collections.<XClass> unmodifiableCollection(xclassSet);\n+        return Collections.<XClass>unmodifiableCollection(xclassSet);\n     }\n \n     /**\n@@ -867,13 +861,10 @@ public class Subtypes2 {\n      * traverse the inheritance graph, exploring all paths from the class or\n      * interface to java.lang.Object.\n      *\n-     * @param start\n-     *            ClassDescriptor naming the class where the traversal should\n-     *            start\n-     * @param visitor\n-     *            an InheritanceGraphVisitor\n-     * @throws ClassNotFoundException\n-     *             if the start vertex cannot be resolved\n+     * @param start   ClassDescriptor naming the class where the traversal should\n+     *                start\n+     * @param visitor an InheritanceGraphVisitor\n+     * @throws ClassNotFoundException if the start vertex cannot be resolved\n      */\n     public void traverseSupertypes(ClassDescriptor start, InheritanceGraphVisitor visitor) throws ClassNotFoundException {\n         LinkedList<SupertypeTraversalPath> workList = new LinkedList<SupertypeTraversalPath>();\n@@ -914,7 +905,7 @@ public class Subtypes2 {\n     }\n \n     private void addToWorkList(LinkedList<SupertypeTraversalPath> workList, SupertypeTraversalPath curPath,\n-            ClassDescriptor supertypeDescriptor) {\n+                               ClassDescriptor supertypeDescriptor) {\n         ClassVertex vertex = classDescriptorToVertexMap.get(supertypeDescriptor);\n \n         // The vertex should already have been added to the graph\n@@ -930,7 +921,7 @@ public class Subtypes2 {\n     }\n \n     private boolean traverseEdge(ClassVertex vertex, @CheckForNull ClassDescriptor supertypeDescriptor, boolean isInterfaceEdge,\n-            InheritanceGraphVisitor visitor) {\n+                                 InheritanceGraphVisitor visitor) {\n         if (supertypeDescriptor == null) {\n             // We reached java.lang.Object\n             return false;\n@@ -947,14 +938,13 @@ public class Subtypes2 {\n         assert supertypeVertex != null;\n \n         return visitor.visitEdge(vertex.getClassDescriptor(), vertex.getXClass(), supertypeDescriptor,\n-                supertypeVertex.getXClass());\n+            supertypeVertex.getXClass());\n     }\n \n     /**\n      * Compute set of known subtypes of class named by given ClassDescriptor.\n      *\n-     * @param classDescriptor\n-     *            a ClassDescriptor\n+     * @param classDescriptor a ClassDescriptor\n      * @throws ClassNotFoundException\n      */\n     private Set<ClassDescriptor> computeKnownSubtypes(ClassDescriptor classDescriptor) throws ClassNotFoundException {\n@@ -1021,8 +1011,7 @@ public class Subtypes2 {\n      * Look up or compute the SupertypeQueryResults for class named by given\n      * ClassDescriptor.\n      *\n-     * @param classDescriptor\n-     *            a ClassDescriptor\n+     * @param classDescriptor a ClassDescriptor\n      * @return SupertypeQueryResults for the class named by the ClassDescriptor\n      * @throws ClassNotFoundException\n      */\n@@ -1038,14 +1027,12 @@ public class Subtypes2 {\n     /**\n      * Compute supertypes for class named by given ClassDescriptor.\n      *\n-     * @param classDescriptor\n-     *            a ClassDescriptor\n+     * @param classDescriptor a ClassDescriptor\n      * @return SupertypeQueryResults containing known supertypes of the class\n-     * @throws ClassNotFoundException\n-     *             if the class can't be found\n+     * @throws ClassNotFoundException if the class can't be found\n      */\n     private SupertypeQueryResults computeSupertypes(ClassDescriptor classDescriptor) // throws\n-                                                                                     // ClassNotFoundException\n+    // ClassNotFoundException\n     {\n         if (DEBUG_QUERIES) {\n             System.out.println(\"Computing supertypes for \" + classDescriptor.toDottedClassName());\n@@ -1072,7 +1059,7 @@ public class Subtypes2 {\n             } else {\n                 if (DEBUG_QUERIES) {\n                     System.out.println(\"  Encountered unresolved class \" + vertex.getClassDescriptor().toDottedClassName()\n-                            + \" in supertype query\");\n+                        + \" in supertype query\");\n                 }\n                 supertypeSet.setEncounteredMissingClasses(true);\n             }\n@@ -1091,12 +1078,10 @@ public class Subtypes2 {\n      * Resolve a class named by given ClassDescriptor and return its resolved\n      * ClassVertex.\n      *\n-     * @param classDescriptor\n-     *            a ClassDescriptor\n+     * @param classDescriptor a ClassDescriptor\n      * @return resolved ClassVertex representing the class in the\n-     *         InheritanceGraph\n-     * @throws ClassNotFoundException\n-     *             if the class named by the ClassDescriptor does not exist\n+     * InheritanceGraph\n+     * @throws ClassNotFoundException if the class named by the ClassDescriptor does not exist\n      */\n     private ClassVertex resolveClassVertex(ClassDescriptor classDescriptor) throws ClassNotFoundException {\n         ClassVertex typeVertex = optionallyResolveClassVertex(classDescriptor);\n@@ -1138,19 +1123,18 @@ public class Subtypes2 {\n      * Add supertype edges to the InheritanceGraph for given ClassVertex. If any\n      * direct supertypes have not been processed, add them to the worklist.\n      *\n-     * @param vertex\n-     *            a ClassVertex whose supertype edges need to be added\n-     * @param workList\n-     *            work list of ClassVertexes that need to have their supertype\n-     *            edges added\n+     * @param vertex   a ClassVertex whose supertype edges need to be added\n+     * @param workList work list of ClassVertexes that need to have their supertype\n+     *                 edges added\n      */\n     private void addSupertypeEdges(ClassVertex vertex, LinkedList<XClass> workList) {\n         XClass xclass = vertex.getXClass();\n \n         // Direct superclass\n         ClassDescriptor superclassDescriptor = xclass.getSuperclassDescriptor();\n-        if (superclassDescriptor != null)\n+        if (superclassDescriptor != null) {\n             addInheritanceEdge(vertex, superclassDescriptor, false, workList);\n+        }\n \n         // Directly implemented interfaces\n         for (ClassDescriptor ifaceDesc : xclass.getInterfaceDescriptorList()) {\n@@ -1161,18 +1145,14 @@ public class Subtypes2 {\n     /**\n      * Add supertype edge to the InheritanceGraph.\n      *\n-     * @param vertex\n-     *            source ClassVertex (subtype)\n-     * @param superclassDescriptor\n-     *            ClassDescriptor of a direct supertype\n-     * @param isInterfaceEdge\n-     *            true if supertype is (as far as we know) an interface\n-     * @param workList\n-     *            work list of ClassVertexes that need to have their supertype\n-     *            edges added (null if no further work will be generated)\n+     * @param vertex               source ClassVertex (subtype)\n+     * @param superclassDescriptor ClassDescriptor of a direct supertype\n+     * @param isInterfaceEdge      true if supertype is (as far as we know) an interface\n+     * @param workList             work list of ClassVertexes that need to have their supertype\n+     *                             edges added (null if no further work will be generated)\n      */\n     private void addInheritanceEdge(ClassVertex vertex, ClassDescriptor superclassDescriptor, boolean isInterfaceEdge,\n-            @CheckForNull LinkedList<XClass> workList) {\n+                                    @CheckForNull LinkedList<XClass> workList) {\n         if (superclassDescriptor == null) {\n             return;\n         }\n@@ -1203,7 +1183,7 @@ public class Subtypes2 {\n         if (graph.lookupEdge(vertex, superclassVertex) == null) {\n             if (DEBUG) {\n                 System.out.println(\"  Add edge \" + vertex.getClassDescriptor().toDottedClassName() + \" -> \"\n-                        + superclassDescriptor.toDottedClassName());\n+                    + superclassDescriptor.toDottedClassName());\n             }\n             graph.createEdge(vertex, superclassVertex);\n         }\n@@ -1212,8 +1192,7 @@ public class Subtypes2 {\n     /**\n      * Add a ClassVertex representing a missing class.\n      *\n-     * @param missingClassDescriptor\n-     *            ClassDescriptor naming a missing class\n+     * @param missingClassDescriptor ClassDescriptor naming a missing class\n      * @param isInterfaceEdge\n      * @return the ClassVertex representing the missing class\n      */\n",
            "diff_size": 148
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/58/Subtypes2.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/58/Subtypes2.java\nindex 7c4aa3e0690..e1483a44440 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/errored/1/58/Subtypes2.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/findbugsproject-findbugs/styler_random/58/Subtypes2.java\n@@ -361,7 +361,7 @@ public class Subtypes2 {\n         if (subDesc.equals(superDesc))\n             return true;\n         if (superDesc.getClassName().equals(\"java/lang/Object\"))\n-        \treturn true;\n+        return true;\n \n         if (true) {\n         XClass xclass = AnalysisContext.currentXFactory().getXClass(subDesc);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_three_grams"
    ]
}