{
    "project_name": "IQSS-dataverse",
    "error_id": "23",
    "information": {
        "errors": [
            {
                "line": "58",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": " */\n@NamedQueries({\n\t@NamedQuery( name=\"DataFile.removeFromDatasetVersion\",\n\t\tquery=\"DELETE FROM FileMetadata f WHERE f.datasetVersion.id=:versionId and f.dataFile.id=:fileId\"),\n        @NamedQuery(name = \"DataFile.findByCreatorId\",\n                query = \"SELECT o FROM DataFile o WHERE o.creator.id=:creatorId\"),",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "59",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/23/DataFile.java\nindex 4cb2abfb12f..ad1b163b7f6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/23/DataFile.java\n@@ -55,7 +55,7 @@ import org.hibernate.validator.constraints.NotBlank;\n  * @author gdurand\n  */\n @NamedQueries({\n-\t@NamedQuery( name=\"DataFile.removeFromDatasetVersion\",\n+@NamedQuery( name=\"DataFile.removeFromDatasetVersion\",\n \t\tquery=\"DELETE FROM FileMetadata f WHERE f.datasetVersion.id=:versionId and f.dataFile.id=:fileId\"),\n         @NamedQuery(name = \"DataFile.findByCreatorId\",\n                 query = \"SELECT o FROM DataFile o WHERE o.creator.id=:creatorId\"),\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/23/DataFile.java\nindex 4cb2abfb12f..5c8f068afaa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/23/DataFile.java\n@@ -51,138 +51,137 @@ import javax.validation.constraints.Pattern;\n import org.hibernate.validator.constraints.NotBlank;\n \n /**\n- *\n  * @author gdurand\n  */\n @NamedQueries({\n-\t@NamedQuery( name=\"DataFile.removeFromDatasetVersion\",\n-\t\tquery=\"DELETE FROM FileMetadata f WHERE f.datasetVersion.id=:versionId and f.dataFile.id=:fileId\"),\n-        @NamedQuery(name = \"DataFile.findByCreatorId\",\n-                query = \"SELECT o FROM DataFile o WHERE o.creator.id=:creatorId\"),\n-        @NamedQuery(name = \"DataFile.findByReleaseUserId\",\n-                query = \"SELECT o FROM DataFile o WHERE o.releaseUser.id=:releaseUserId\"),\n-        @NamedQuery(name=\"DataFile.findDataFileByIdProtocolAuth\", \n-                query=\"SELECT s FROM DataFile s WHERE s.identifier=:identifier AND s.protocol=:protocol AND s.authority=:authority\"),\n-        @NamedQuery(name=\"DataFile.findDataFileThatReplacedId\", \n-                query=\"SELECT s.id FROM DataFile s WHERE s.previousDataFileId=:identifier\")\n+  @NamedQuery(name = \"DataFile.removeFromDatasetVersion\",\n+    query = \"DELETE FROM FileMetadata f WHERE f.datasetVersion.id=:versionId and f.dataFile.id=:fileId\"),\n+  @NamedQuery(name = \"DataFile.findByCreatorId\",\n+    query = \"SELECT o FROM DataFile o WHERE o.creator.id=:creatorId\"),\n+  @NamedQuery(name = \"DataFile.findByReleaseUserId\",\n+    query = \"SELECT o FROM DataFile o WHERE o.releaseUser.id=:releaseUserId\"),\n+  @NamedQuery(name = \"DataFile.findDataFileByIdProtocolAuth\",\n+    query = \"SELECT s FROM DataFile s WHERE s.identifier=:identifier AND s.protocol=:protocol AND s.authority=:authority\"),\n+  @NamedQuery(name = \"DataFile.findDataFileThatReplacedId\",\n+    query = \"SELECT s.id FROM DataFile s WHERE s.previousDataFileId=:identifier\")\n })\n @Entity\n-@Table(indexes = {@Index(columnList=\"ingeststatus\")\n-\t\t, @Index(columnList=\"checksumvalue\")\n-\t\t, @Index(columnList=\"contenttype\")\n-\t\t, @Index(columnList=\"restricted\")})\n+@Table(indexes = {@Index(columnList = \"ingeststatus\")\n+  , @Index(columnList = \"checksumvalue\")\n+  , @Index(columnList = \"contenttype\")\n+  , @Index(columnList = \"restricted\")})\n public class DataFile extends DvObject implements Comparable {\n-    private static final Logger logger = Logger.getLogger(DatasetPage.class.getCanonicalName());\n-    private static final long serialVersionUID = 1L;\n-    public static final String TARGET_URL = \"/file.xhtml?persistentId=\";\n-    public static final char INGEST_STATUS_NONE = 65;\n-    public static final char INGEST_STATUS_SCHEDULED = 66;\n-    public static final char INGEST_STATUS_INPROGRESS = 67;\n-    public static final char INGEST_STATUS_ERROR = 68; \n-    \n-    public static final Long ROOT_DATAFILE_ID_DEFAULT = (long) -1;\n-    \n-    @Expose\n-    @NotBlank\n-    @Column( nullable = false )\n-    @Pattern(regexp = \"^.*/.*$\", message = \"{contenttype.slash}\")\n-    private String contentType;\n-    \n+  private static final Logger logger = Logger.getLogger(DatasetPage.class.getCanonicalName());\n+  private static final long serialVersionUID = 1L;\n+  public static final String TARGET_URL = \"/file.xhtml?persistentId=\";\n+  public static final char INGEST_STATUS_NONE = 65;\n+  public static final char INGEST_STATUS_SCHEDULED = 66;\n+  public static final char INGEST_STATUS_INPROGRESS = 67;\n+  public static final char INGEST_STATUS_ERROR = 68;\n+\n+  public static final Long ROOT_DATAFILE_ID_DEFAULT = (long) -1;\n+\n+  @Expose\n+  @NotBlank\n+  @Column(nullable = false)\n+  @Pattern(regexp = \"^.*/.*$\", message = \"{contenttype.slash}\")\n+  private String contentType;\n+\n \n //    @Expose    \n //    @SerializedName(\"storageIdentifier\")\n //    @Column( nullable = false )\n //    private String fileSystemName;\n \n-    /**\n-     * End users will see \"SHA-1\" (with a hyphen) rather than \"SHA1\" in the GUI\n-     * and API but in the \"datafile\" table we persist \"SHA1\" (no hyphen) for\n-     * type safety (using keys of the enum). In the \"setting\" table, we persist\n-     * \"SHA-1\" (with a hyphen) to match the GUI and the \"Algorithm Name\" list at\n-     * https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest\n-     *\n-     * The list of types should be limited to the list above in the technote\n-     * because the string gets passed into MessageDigest.getInstance() and you\n-     * can't just pass in any old string.\n-     */\n-    public enum ChecksumType {\n-\n-        MD5(\"MD5\"),\n-        SHA1(\"SHA-1\"),\n-        SHA256(\"SHA-256\"),\n-        SHA512(\"SHA-512\");\n-\n-        private final String text;\n-\n-        private ChecksumType(final String text) {\n-            this.text = text;\n-        }\n-\n-        public static ChecksumType fromString(String text) {\n-            if (text != null) {\n-                for (ChecksumType checksumType : ChecksumType.values()) {\n-                    if (text.equals(checksumType.text)) {\n-                        return checksumType;\n-                    }\n-                }\n-            }\n-            throw new IllegalArgumentException(\"ChecksumType must be one of these values: \" + Arrays.asList(ChecksumType.values()) + \".\");\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return text;\n+  /**\n+   * End users will see \"SHA-1\" (with a hyphen) rather than \"SHA1\" in the GUI\n+   * and API but in the \"datafile\" table we persist \"SHA1\" (no hyphen) for\n+   * type safety (using keys of the enum). In the \"setting\" table, we persist\n+   * \"SHA-1\" (with a hyphen) to match the GUI and the \"Algorithm Name\" list at\n+   * https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest\n+   * <p>\n+   * The list of types should be limited to the list above in the technote\n+   * because the string gets passed into MessageDigest.getInstance() and you\n+   * can't just pass in any old string.\n+   */\n+  public enum ChecksumType {\n+\n+    MD5(\"MD5\"),\n+    SHA1(\"SHA-1\"),\n+    SHA256(\"SHA-256\"),\n+    SHA512(\"SHA-512\");\n+\n+    private final String text;\n+\n+    private ChecksumType(final String text) {\n+      this.text = text;\n+    }\n+\n+    public static ChecksumType fromString(String text) {\n+      if (text != null) {\n+        for (ChecksumType checksumType : ChecksumType.values()) {\n+          if (text.equals(checksumType.text)) {\n+            return checksumType;\n+          }\n         }\n+      }\n+      throw new IllegalArgumentException(\n+        \"ChecksumType must be one of these values: \" + Arrays.asList(ChecksumType.values()) + \".\");\n     }\n \n-    //@Expose\n-    @Column(nullable = false)\n-    @Enumerated(EnumType.STRING)\n-    private ChecksumType checksumType;\n-\n-    /**\n-     * Examples include \"f622da34d54bdc8ee541d6916ac1c16f\" as an MD5 value or\n-     * \"3a484dfdb1b429c2e15eb2a735f1f5e4d5b04ec6\" as a SHA-1 value\"\n-     */\n-    //@Expose\n-    @Column(nullable = false)\n-    private String checksumValue;\n-\n-    \n-    /* start: FILE REPLACE ATTRIBUTES */\n-    \n-    // For the initial version of a file, this will be equivalent to the ID\n-    // Default is -1 until the intial id is generated\n-    @Expose\n-    @Column(nullable=false)\n-    private Long rootDataFileId;\n-\n-    /**\n-     * @todo We should have consistency between \"Id\" vs \"ID\" for rootDataFileId\n-     * vs. previousDataFileId.\n-     */\n-    // null for initial version; subsequent versions will point to the previous file\n-    //\n-    @Expose\n-    @Column(nullable=true)\n-    private Long previousDataFileId;\n-    /* endt: FILE REPLACE ATTRIBUTES */\n-    \n-    \n-    \n-    @Expose\n-    @Column(nullable=true)\n-    private Long filesize;      // Number of bytes in file.  Allows 0 and null, negative numbers not permitted\n-\n-    @Expose\n-    private boolean restricted;\n-    \n-    @Expose\n-    @Column(columnDefinition = \"TEXT\", nullable = true, name=\"prov_entityname\")\n-    private String provEntityName;\n-    \n-    /*Add when we integrate with provCPL*/\n-    //The id given for the datafile by CPL.\n+    @Override\n+    public String toString() {\n+      return text;\n+    }\n+  }\n+\n+  //@Expose\n+  @Column(nullable = false)\n+  @Enumerated(EnumType.STRING)\n+  private ChecksumType checksumType;\n+\n+  /**\n+   * Examples include \"f622da34d54bdc8ee541d6916ac1c16f\" as an MD5 value or\n+   * \"3a484dfdb1b429c2e15eb2a735f1f5e4d5b04ec6\" as a SHA-1 value\"\n+   */\n+  //@Expose\n+  @Column(nullable = false)\n+  private String checksumValue;\n+\n+\n+  /* start: FILE REPLACE ATTRIBUTES */\n+\n+  // For the initial version of a file, this will be equivalent to the ID\n+  // Default is -1 until the intial id is generated\n+  @Expose\n+  @Column(nullable = false)\n+  private Long rootDataFileId;\n+\n+  /**\n+   * @todo We should have consistency between \"Id\" vs \"ID\" for rootDataFileId\n+   * vs. previousDataFileId.\n+   */\n+  // null for initial version; subsequent versions will point to the previous file\n+  //\n+  @Expose\n+  @Column(nullable = true)\n+  private Long previousDataFileId;\n+  /* endt: FILE REPLACE ATTRIBUTES */\n+\n+\n+  @Expose\n+  @Column(nullable = true)\n+  private Long filesize;      // Number of bytes in file.  Allows 0 and null, negative numbers not permitted\n+\n+  @Expose\n+  private boolean restricted;\n+\n+  @Expose\n+  @Column(columnDefinition = \"TEXT\", nullable = true, name = \"prov_entityname\")\n+  private String provEntityName;\n+\n+  /*Add when we integrate with provCPL*/\n+  //The id given for the datafile by CPL.\n //    @Column(name=\"prov_cplid\") //( nullable=false )\n //    private int provCplId;\n     \n@@ -190,691 +189,704 @@ public class DataFile extends DvObject implements Comparable {\n         Tabular (formerly \"subsettable\") data files have DataTable objects\n         associated with them:\n     */\n-    \n-    @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    private List<DataTable> dataTables;\n-    \n-    @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    private List<AuxiliaryFile> auxiliaryFiles;\n-   \n-    @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    private List<IngestReport> ingestReports;\n-    \n-    @OneToOne(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    private IngestRequest ingestRequest;\n-    \n-    @OneToMany(mappedBy = \"dataFile\", orphanRemoval = true, cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    private List<DataFileTag> dataFileTags;\n-    \n-    @OneToMany(mappedBy=\"dataFile\", cascade={CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    private List<FileMetadata> fileMetadatas;\n-    \n-    @OneToMany(mappedBy=\"dataFile\", cascade={CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n-    private List<GuestbookResponse> guestbookResponses;\n \n-    public List<GuestbookResponse> getGuestbookResponses() {\n-        return guestbookResponses;\n-    }\n+  @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private List<DataTable> dataTables;\n \n-    public void setGuestbookResponses(List<GuestbookResponse> guestbookResponses) {\n-        this.guestbookResponses = guestbookResponses;\n-    }\n+  @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private List<AuxiliaryFile> auxiliaryFiles;\n \n-    private char ingestStatus = INGEST_STATUS_NONE; \n-    \n-    @OneToOne(mappedBy = \"thumbnailFile\")\n-    private Dataset thumbnailForDataset;\n-\n-    public DataFile() {\n-        this.fileMetadatas = new ArrayList<>();\n-        initFileReplaceAttributes();\n-    }    \n-\n-    public DataFile(String contentType) {\n-        this.contentType = contentType;\n-        this.fileMetadatas = new ArrayList<>();\n-        initFileReplaceAttributes();\n-    }\n+  @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private List<IngestReport> ingestReports;\n+\n+  @OneToOne(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private IngestRequest ingestRequest;\n+\n+  @OneToMany(mappedBy = \"dataFile\", orphanRemoval = true, cascade = {CascadeType.REMOVE, CascadeType.MERGE,\n+    CascadeType.PERSIST})\n+  private List<DataFileTag> dataFileTags;\n+\n+  @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private List<FileMetadata> fileMetadatas;\n+\n+  @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+  private List<GuestbookResponse> guestbookResponses;\n+\n+  public List<GuestbookResponse> getGuestbookResponses() {\n+    return guestbookResponses;\n+  }\n+\n+  public void setGuestbookResponses(List<GuestbookResponse> guestbookResponses) {\n+    this.guestbookResponses = guestbookResponses;\n+  }\n+\n+  private char ingestStatus = INGEST_STATUS_NONE;\n+\n+  @OneToOne(mappedBy = \"thumbnailFile\")\n+  private Dataset thumbnailForDataset;\n+\n+  public DataFile() {\n+    this.fileMetadatas = new ArrayList<>();\n+    initFileReplaceAttributes();\n+  }\n+\n+  public DataFile(String contentType) {\n+    this.contentType = contentType;\n+    this.fileMetadatas = new ArrayList<>();\n+    initFileReplaceAttributes();\n+  }\n \n     /*\n     Used in manage file permissions UI \n     to easily display those files that have been deleted in the current draft \n     or previous version which may have roles assigned or pending requests for access\n     */\n-   \n-    @Transient\n-    private Boolean deleted;\n \n-    public Boolean getDeleted() {\n-        return deleted;\n-    }\n+  @Transient\n+  private Boolean deleted;\n \n-    public void setDeleted(Boolean deleted) {\n-        this.deleted = deleted;\n-    }\n+  public Boolean getDeleted() {\n+    return deleted;\n+  }\n+\n+  public void setDeleted(Boolean deleted) {\n+    this.deleted = deleted;\n+  }\n     \n     /*\n     For use during file upload so that the user may delete \n     files that have already been uploaded to the current dataset version\n     */\n-    \n-    @Transient\n-    private boolean markedAsDuplicate;\n \n-    public boolean isMarkedAsDuplicate() {\n-        return markedAsDuplicate;\n-    }\n+  @Transient\n+  private boolean markedAsDuplicate;\n \n-    public void setMarkedAsDuplicate(boolean markedAsDuplicate) {\n-        this.markedAsDuplicate = markedAsDuplicate;\n-    }\n-    \n-    @Transient\n-    private String duplicateFilename;\n+  public boolean isMarkedAsDuplicate() {\n+    return markedAsDuplicate;\n+  }\n \n-    public String getDuplicateFilename() {\n-        return duplicateFilename;\n-    }\n+  public void setMarkedAsDuplicate(boolean markedAsDuplicate) {\n+    this.markedAsDuplicate = markedAsDuplicate;\n+  }\n \n-    public void setDuplicateFilename(String duplicateFilename) {\n-        this.duplicateFilename = duplicateFilename;\n-    }\n+  @Transient\n+  private String duplicateFilename;\n \n-    public List<AuxiliaryFile> getAuxiliaryFiles() {\n-        return auxiliaryFiles;\n-    }\n+  public String getDuplicateFilename() {\n+    return duplicateFilename;\n+  }\n \n-    public void setAuxiliaryFiles(List<AuxiliaryFile> auxiliaryFiles) {\n-        this.auxiliaryFiles = auxiliaryFiles;\n-    }\n-    \n-    \n-    \n-    \n-       \n-    /**\n-     * All constructors should use this method\n-     * to initialize this file replace attributes\n-     */\n-    private void initFileReplaceAttributes(){\n-        this.rootDataFileId = ROOT_DATAFILE_ID_DEFAULT;\n-        this.previousDataFileId = null;\n-    }\n-    \n-    @Override\n-    public boolean isEffectivelyPermissionRoot() {\n-        return false;\n-    }\n-    \n-    public List<DataTable> getDataTables() {\n-        return dataTables;\n-    }\n+  public void setDuplicateFilename(String duplicateFilename) {\n+    this.duplicateFilename = duplicateFilename;\n+  }\n \n-    public void setDataTables(List<DataTable> dataTables) {\n-        this.dataTables = dataTables;\n-    }\n-    \n-    public DataTable getDataTable() {\n-        if ( getDataTables() != null && getDataTables().size() > 0 ) {\n-            return getDataTables().get(0);\n-        } else {\n-            return null;\n-        }\n-    }\n+  public List<AuxiliaryFile> getAuxiliaryFiles() {\n+    return auxiliaryFiles;\n+  }\n \n-    public void setDataTable(DataTable dt) {\n-        if (this.getDataTables() == null) {\n-            this.setDataTables(new ArrayList<>());\n-        } else {\n-            this.getDataTables().clear();\n-        }\n+  public void setAuxiliaryFiles(List<AuxiliaryFile> auxiliaryFiles) {\n+    this.auxiliaryFiles = auxiliaryFiles;\n+  }\n \n-        this.getDataTables().add(dt);\n-    }\n-    \n-    public List<DataFileTag> getTags() {\n-        return dataFileTags;\n-    }\n-    \n-    public List<String> getTagLabels(){\n-        \n-        List<DataFileTag> currentDataTags = this.getTags();\n-        List<String> tagStrings = new ArrayList<>();\n-        \n-        if (( currentDataTags != null)&&(!currentDataTags.isEmpty())){\n-                       \n-            for (DataFileTag element : currentDataTags) {\n-                tagStrings.add(element.getTypeLabel());\n-            }\n-        }\n-        return tagStrings;\n-    }\n \n-    public JsonArrayBuilder getTagLabelsAsJsonArrayBuilder(){\n-        \n-        List<DataFileTag> currentDataTags = this.getTags();\n+  /**\n+   * All constructors should use this method\n+   * to initialize this file replace attributes\n+   */\n+  private void initFileReplaceAttributes() {\n+    this.rootDataFileId = ROOT_DATAFILE_ID_DEFAULT;\n+    this.previousDataFileId = null;\n+  }\n \n-        JsonArrayBuilder builder = Json.createArrayBuilder();\n-        \n-        if ( (currentDataTags == null)||(currentDataTags.isEmpty())){\n-            return builder;\n-        }\n-        \n-        \n-        for (DataFileTag element : currentDataTags) {\n-            builder.add(element.getTypeLabel());            \n-        }\n-        return builder;\n-    }\n-    public void setTags(List<DataFileTag> dataFileTags) {\n-        this.dataFileTags = dataFileTags;\n-    }\n-    \n-    public void addTag(DataFileTag tag) {\n-        if (dataFileTags == null) {\n-            dataFileTags = new ArrayList<>();\n-        } \n+  @Override\n+  public boolean isEffectivelyPermissionRoot() {\n+    return false;\n+  }\n \n-        dataFileTags.add(tag);\n-    }\n-    \n-    public List<FileMetadata> getFileMetadatas() {\n-        return fileMetadatas;\n-    }\n+  public List<DataTable> getDataTables() {\n+    return dataTables;\n+  }\n+\n+  public void setDataTables(List<DataTable> dataTables) {\n+    this.dataTables = dataTables;\n+  }\n \n-    public void setFileMetadatas(List<FileMetadata> fileMetadatas) {\n-        this.fileMetadatas = fileMetadatas;\n+  public DataTable getDataTable() {\n+    if (getDataTables() != null && getDataTables().size() > 0) {\n+      return getDataTables().get(0);\n+    } else {\n+      return null;\n     }\n-    \n-    public IngestReport getIngestReport() {\n-        if ( ingestReports != null && ingestReports.size() > 0 ) {\n-            return ingestReports.get(0);\n-        } else {\n-            return null;\n-        }\n+  }\n+\n+  public void setDataTable(DataTable dt) {\n+    if (this.getDataTables() == null) {\n+      this.setDataTables(new ArrayList<>());\n+    } else {\n+      this.getDataTables().clear();\n     }\n \n-    public void setIngestReport(IngestReport report) {\n-        if (ingestReports == null) {\n-            ingestReports = new ArrayList<>();\n-        } else {\n-            ingestReports.clear();\n-        }\n+    this.getDataTables().add(dt);\n+  }\n \n-        ingestReports.add(report);\n-    }\n-    \n-    public IngestRequest getIngestRequest() {\n-        return ingestRequest;\n-    }\n-    \n-    public void setIngestRequest(IngestRequest ingestRequest) {\n-        this.ingestRequest = ingestRequest;\n-    }\n-    \n-    public String getIngestReportMessage() {\n-        if ( ingestReports != null && ingestReports.size() > 0 ) {\n-            if (ingestReports.get(0).getReport() != null && !\"\".equals(ingestReports.get(0).getReport())) {\n-                return ingestReports.get(0).getReport();\n-            }\n-        }\n-        return \"Ingest failed. No further information is available.\";\n-    }\n-    \n-    public boolean isTabularData() {\n-        return getDataTables() != null && getDataTables().size() > 0; \n-    }\n-    \n-    public String getOriginalFileFormat() {\n-        if (isTabularData()) {\n-            DataTable dataTable = getDataTable();\n-            if (dataTable != null) {\n-                return dataTable.getOriginalFileFormat();\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    public Long getOriginalFileSize() {\n-        if (isTabularData()) {\n-            DataTable dataTable = getDataTable();\n-            if (dataTable != null) {\n-                return dataTable.getOriginalFileSize();\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    public String getOriginalFileName() {\n-        if (isTabularData()) {\n-            DataTable dataTable = getDataTable();\n-            if (dataTable != null) {\n-                return dataTable.getOriginalFileName() != null ? dataTable.getOriginalFileName()\n-                        : getDerivedOriginalFileName();\n-            }\n-        }\n-        return null;\n-    }\n+  public List<DataFileTag> getTags() {\n+    return dataFileTags;\n+  }\n \n-    \n-    private String getDerivedOriginalFileName() {\n-        FileMetadata fm = getFileMetadata();\n-        String filename = fm.getLabel();\n-        String originalExtension = FileUtil.generateOriginalExtension(getOriginalFileFormat());\n-        String extensionToRemove = StringUtil.substringIncludingLast(filename, \".\");\n-        if (StringUtil.nonEmpty(extensionToRemove)) {\n-            return filename.replaceAll(extensionToRemove + \"$\", originalExtension);\n-        } else{\n-            return filename + originalExtension ;\n-        }        \n-    }\n+  public List<String> getTagLabels() {\n \n-    @Override\n-    public boolean isAncestorOf( DvObject other ) {\n-        return equals(other);\n-    }\n-    \n-    /*\n-     * A user-friendly version of the \"original format\":\n-     */\n-    public String getOriginalFormatLabel() {\n-        return FileUtil.getUserFriendlyOriginalType(this);\n-    }\n+    List<DataFileTag> currentDataTags = this.getTags();\n+    List<String> tagStrings = new ArrayList<>();\n \n-    public String getContentType() {\n-        return contentType;\n-    }\n+    if ((currentDataTags != null) && (!currentDataTags.isEmpty())) {\n \n-    public void setContentType(String contentType) {\n-        this.contentType = contentType;\n+      for (DataFileTag element : currentDataTags) {\n+        tagStrings.add(element.getTypeLabel());\n+      }\n     }\n+    return tagStrings;\n+  }\n \n-    public String getFriendlyType() {\n-        return FileUtil.getUserFriendlyFileType(this);\n-    }\n-    \n-    @Override\n-    public Dataset getOwner() {\n-        return (Dataset) super.getOwner();\n-    }\n+  public JsonArrayBuilder getTagLabelsAsJsonArrayBuilder() {\n \n-    public void setOwner(Dataset dataset) {\n-        super.setOwner(dataset);\n-    }\n-    \n-    public String getDescription() {\n-        FileMetadata fmd = getLatestFileMetadata();\n-        \n-        if (fmd == null) {\n-            return null;\n-        }\n-        return fmd.getDescription();\n-    }\n+    List<DataFileTag> currentDataTags = this.getTags();\n \n-    public void setDescription(String description) {\n-        FileMetadata fmd = getLatestFileMetadata();\n-        \n-        if (fmd != null) {\n-            fmd.setDescription(description);\n-        }\n-    }\n-    \n-    public FileMetadata getFileMetadata() {\n-        return getLatestFileMetadata();\n-    }\n-    \n-    public FileMetadata getLatestFileMetadata() {\n-        FileMetadata fmd = null;\n+    JsonArrayBuilder builder = Json.createArrayBuilder();\n \n-        // for newly added or harvested, just return the one fmd\n-        if (fileMetadatas.size() == 1) {\n-            return fileMetadatas.get(0);\n-        }\n-        \n-        for (FileMetadata fileMetadata : fileMetadatas) {\n-            // if it finds a draft, return it\n-            if (fileMetadata.getDatasetVersion().getVersionState().equals(VersionState.DRAFT)) {\n-                return fileMetadata;\n-            }            \n-            \n-            // otherwise return the one with the latest version number\n-            // duplicate logic in getLatestPublishedFileMetadata()\n-            if (fmd == null || fileMetadata.getDatasetVersion().getVersionNumber().compareTo( fmd.getDatasetVersion().getVersionNumber() ) > 0 ) {\n-                fmd = fileMetadata;\n-            } else if ((fileMetadata.getDatasetVersion().getVersionNumber().compareTo( fmd.getDatasetVersion().getVersionNumber())==0 )&& \n-                   ( fileMetadata.getDatasetVersion().getMinorVersionNumber().compareTo( fmd.getDatasetVersion().getMinorVersionNumber()) > 0 )   ) {\n-                fmd = fileMetadata;\n-            }\n-        }\n-        return fmd;\n-    }\n-    \n-//    //Returns null if no published version\n-    public FileMetadata getLatestPublishedFileMetadata() throws UnsupportedOperationException {\n-        FileMetadata fmd = null;\n-        \n-        for (FileMetadata fileMetadata : fileMetadatas) {\n-            // if it finds a draft, skip\n-            if (fileMetadata.getDatasetVersion().getVersionState().equals(VersionState.DRAFT)) {\n-                continue;\n-            }            \n-            \n-            // otherwise return the one with the latest version number\n-            // duplicate logic in getLatestFileMetadata()\n-            if (fmd == null || fileMetadata.getDatasetVersion().getVersionNumber().compareTo( fmd.getDatasetVersion().getVersionNumber() ) > 0 ) {\n-                fmd = fileMetadata;\n-            } else if ((fileMetadata.getDatasetVersion().getVersionNumber().compareTo( fmd.getDatasetVersion().getVersionNumber())==0 )&& \n-                   ( fileMetadata.getDatasetVersion().getMinorVersionNumber().compareTo( fmd.getDatasetVersion().getMinorVersionNumber()) > 0 )   ) {\n-                fmd = fileMetadata;\n-            }\n-        }\n-        if(fmd == null) {\n-            throw new UnsupportedOperationException(\"No published metadata version for DataFile \" + this.getId());\n-        }\n-        \n-        return fmd;\n+    if ((currentDataTags == null) || (currentDataTags.isEmpty())) {\n+      return builder;\n     }\n \n-    /**\n-     * Get property filesize, number of bytes\n-     * @return value of property filesize.\n-     */\n-    public long getFilesize() {\n-        if (this.filesize == null) {\n-            // -1 means \"unknown\"\n-            return -1;\n-        } \n-        return this.filesize;\n-    }\n \n-    /**\n-     * Set property filesize in bytes\n-     * \n-     * Allow nulls, but not negative numbers.\n-     * \n-     * @param filesize new value of property filesize.\n-     */\n-    public void setFilesize(long filesize) {\n-        if (filesize < 0){\n-            return;\n-        }\n-       this.filesize = filesize;\n+    for (DataFileTag element : currentDataTags) {\n+      builder.add(element.getTypeLabel());\n     }\n+    return builder;\n+  }\n \n-    /**\n-     * Converts the stored size of the file in bytes to \n-     * a user-friendly value in KB, MB or GB.\n-     * @return \n-     */\n-    public String getFriendlySize() {\n-        return FileSizeChecker.bytesToHumanReadable(filesize);\n-    }\n+  public void setTags(List<DataFileTag> dataFileTags) {\n+    this.dataFileTags = dataFileTags;\n+  }\n \n-    public boolean isRestricted() {\n-        return restricted;\n+  public void addTag(DataFileTag tag) {\n+    if (dataFileTags == null) {\n+      dataFileTags = new ArrayList<>();\n     }\n \n-    \n-    public void setRestricted(boolean restricted) {\n-        this.restricted = restricted;\n-    }\n+    dataFileTags.add(tag);\n+  }\n \n-    public ChecksumType getChecksumType() {\n-        return checksumType;\n-    }\n+  public List<FileMetadata> getFileMetadatas() {\n+    return fileMetadatas;\n+  }\n \n-    public void setChecksumType(ChecksumType checksumType) {\n-        this.checksumType = checksumType;\n-    }\n+  public void setFileMetadatas(List<FileMetadata> fileMetadatas) {\n+    this.fileMetadatas = fileMetadatas;\n+  }\n \n-    public String getChecksumValue() {\n-        return this.checksumValue;\n+  public IngestReport getIngestReport() {\n+    if (ingestReports != null && ingestReports.size() > 0) {\n+      return ingestReports.get(0);\n+    } else {\n+      return null;\n     }\n+  }\n \n-    public void setChecksumValue(String checksumValue) {\n-        this.checksumValue = checksumValue;\n+  public void setIngestReport(IngestReport report) {\n+    if (ingestReports == null) {\n+      ingestReports = new ArrayList<>();\n+    } else {\n+      ingestReports.clear();\n     }\n \n-    public String getOriginalChecksumType() {\n-        return BundleUtil.getStringFromBundle(\"file.originalChecksumType\", Arrays.asList(this.checksumType.toString()) );\n-    }\n+    ingestReports.add(report);\n+  }\n \n-    public StorageIO<DataFile> getStorageIO() throws IOException {\n-        StorageIO<DataFile> storageIO = DataAccess.getStorageIO(this);\n-        \n-        if (storageIO == null) {\n-            throw new IOException(\"Failed to create storageIO for datafile.\");\n-        }\n-        \n-        return storageIO; \n-    }\n-    \n-    /*\n-        Does the contentType indicate a shapefile?\n-    */\n-    public boolean isShapefileType(){\n-        if (this.contentType==null){\n-            return false;\n-        }\n-        return ShapefileHandler.SHAPEFILE_FILE_TYPE.equalsIgnoreCase(this.contentType);\n-    }\n-    \n-    public boolean isImage() {\n-        // Some browsers (Chrome?) seem to identify FITS files as mime\n-        // type \"image/fits\" on upload; this is both incorrect (the official\n-        // mime type for FITS is \"application/fits\", and problematic: then\n-        // the file is identified as an image, and the page will attempt to \n-        // generate a preview - which of course is going to fail...\n-        if (\"image/fits\".equalsIgnoreCase(contentType)) {\n-            return false;\n-        }\n-        // a pdf file is an \"image\" for practical purposes (we will attempt to \n-        // generate thumbnails and previews for them)\n-        return (contentType != null && (contentType.startsWith(\"image/\") || contentType.equalsIgnoreCase(\"application/pdf\")));\n-    }\n-    \n-    public boolean isFilePackage() {\n-        return DataFileServiceBean.MIME_TYPE_PACKAGE_FILE.equalsIgnoreCase(contentType);\n-    }\n+  public IngestRequest getIngestRequest() {\n+    return ingestRequest;\n+  }\n \n-    public void setIngestStatus(char ingestStatus) {\n-        this.ingestStatus = ingestStatus; \n-    }    \n-   \n-    public boolean isIngestScheduled() {\n-        return (ingestStatus == INGEST_STATUS_SCHEDULED);\n-    }\n-    \n-    public boolean isIngestInProgress() {\n-        return ((ingestStatus == INGEST_STATUS_SCHEDULED) || (ingestStatus == INGEST_STATUS_INPROGRESS));\n-    }\n-    \n-    public boolean isIngestProblem() {\n-        return (ingestStatus == INGEST_STATUS_ERROR);\n-    }\n-    \n-    public void SetIngestScheduled() {\n-        ingestStatus = INGEST_STATUS_SCHEDULED;\n-    }\n-    \n-    public void SetIngestInProgress() {\n-        ingestStatus = INGEST_STATUS_INPROGRESS;\n-    }\n-    \n-    public void SetIngestProblem() {\n-        ingestStatus = INGEST_STATUS_ERROR;\n-    }\n-    \n-    public void setIngestDone() {\n-        ingestStatus = INGEST_STATUS_NONE;\n-    }\n-    \n-    public int getIngestStatus() {\n-        return ingestStatus; \n-    }\n-    \n-    public Dataset getThumbnailForDataset() {\n-        return thumbnailForDataset;\n+  public void setIngestRequest(IngestRequest ingestRequest) {\n+    this.ingestRequest = ingestRequest;\n+  }\n+\n+  public String getIngestReportMessage() {\n+    if (ingestReports != null && ingestReports.size() > 0) {\n+      if (ingestReports.get(0).getReport() != null && !\"\".equals(ingestReports.get(0).getReport())) {\n+        return ingestReports.get(0).getReport();\n+      }\n     }\n-    \n-    public void setAsThumbnailForDataset(Dataset dataset) {\n-        thumbnailForDataset = dataset;\n+    return \"Ingest failed. No further information is available.\";\n+  }\n+\n+  public boolean isTabularData() {\n+    return getDataTables() != null && getDataTables().size() > 0;\n+  }\n+\n+  public String getOriginalFileFormat() {\n+    if (isTabularData()) {\n+      DataTable dataTable = getDataTable();\n+      if (dataTable != null) {\n+        return dataTable.getOriginalFileFormat();\n+      }\n     }\n+    return null;\n+  }\n \n-    /*\n-        8/10/2014 - Using the current \"open access\" url\n-    */\n-    public String getMapItFileDownloadURL(String serverName){\n-        if ((this.getId() == null)||(serverName == null)){\n-            return null;\n-        }\n-        return serverName + \"/api/access/datafile/\" + this.getId();\n+  public Long getOriginalFileSize() {\n+    if (isTabularData()) {\n+      DataTable dataTable = getDataTable();\n+      if (dataTable != null) {\n+        return dataTable.getOriginalFileSize();\n+      }\n     }\n-    \n-    /* \n-     * If this is tabular data, the corresponding dataTable may have a UNF -\n-     * \"numeric fingerprint\" signature - generated:\n-     */\n-    \n-    public String getUnf() {\n-        if (this.isTabularData()) {\n-            // (isTabularData() method above verifies that that this file \n-            // has a datDatable associated with it, so the line below is \n-            // safe, in terms of a NullPointerException: \n-            return this.getDataTable().getUnf();\n-        }\n-        return null; \n+    return null;\n+  }\n+\n+  public String getOriginalFileName() {\n+    if (isTabularData()) {\n+      DataTable dataTable = getDataTable();\n+      if (dataTable != null) {\n+        return dataTable.getOriginalFileName() != null ? dataTable.getOriginalFileName()\n+          : getDerivedOriginalFileName();\n+      }\n     }\n-    \n+    return null;\n+  }\n+\n+\n+  private String getDerivedOriginalFileName() {\n+    FileMetadata fm = getFileMetadata();\n+    String filename = fm.getLabel();\n+    String originalExtension = FileUtil.generateOriginalExtension(getOriginalFileFormat());\n+    String extensionToRemove = StringUtil.substringIncludingLast(filename, \".\");\n+    if (StringUtil.nonEmpty(extensionToRemove)) {\n+      return filename.replaceAll(extensionToRemove + \"$\", originalExtension);\n+    } else {\n+      return filename + originalExtension;\n+    }\n+  }\n+\n+  @Override\n+  public boolean isAncestorOf(DvObject other) {\n+    return equals(other);\n+  }\n+\n+  /*\n+   * A user-friendly version of the \"original format\":\n+   */\n+  public String getOriginalFormatLabel() {\n+    return FileUtil.getUserFriendlyOriginalType(this);\n+  }\n+\n+  public String getContentType() {\n+    return contentType;\n+  }\n+\n+  public void setContentType(String contentType) {\n+    this.contentType = contentType;\n+  }\n+\n+  public String getFriendlyType() {\n+    return FileUtil.getUserFriendlyFileType(this);\n+  }\n+\n+  @Override\n+  public Dataset getOwner() {\n+    return (Dataset) super.getOwner();\n+  }\n+\n+  public void setOwner(Dataset dataset) {\n+    super.setOwner(dataset);\n+  }\n+\n+  public String getDescription() {\n+    FileMetadata fmd = getLatestFileMetadata();\n+\n+    if (fmd == null) {\n+      return null;\n+    }\n+    return fmd.getDescription();\n+  }\n+\n+  public void setDescription(String description) {\n+    FileMetadata fmd = getLatestFileMetadata();\n+\n+    if (fmd != null) {\n+      fmd.setDescription(description);\n+    }\n+  }\n+\n+  public FileMetadata getFileMetadata() {\n+    return getLatestFileMetadata();\n+  }\n+\n+  public FileMetadata getLatestFileMetadata() {\n+    FileMetadata fmd = null;\n+\n+    // for newly added or harvested, just return the one fmd\n+    if (fileMetadatas.size() == 1) {\n+      return fileMetadatas.get(0);\n+    }\n+\n+    for (FileMetadata fileMetadata : fileMetadatas) {\n+      // if it finds a draft, return it\n+      if (fileMetadata.getDatasetVersion().getVersionState().equals(VersionState.DRAFT)) {\n+        return fileMetadata;\n+      }\n+\n+      // otherwise return the one with the latest version number\n+      // duplicate logic in getLatestPublishedFileMetadata()\n+      if (fmd == null ||\n+        fileMetadata.getDatasetVersion().getVersionNumber().compareTo(fmd.getDatasetVersion().getVersionNumber()) > 0) {\n+        fmd = fileMetadata;\n+      } else if (\n+        (fileMetadata.getDatasetVersion().getVersionNumber().compareTo(fmd.getDatasetVersion().getVersionNumber()) ==\n+          0) &&\n+          (fileMetadata.getDatasetVersion().getMinorVersionNumber()\n+            .compareTo(fmd.getDatasetVersion().getMinorVersionNumber()) > 0)) {\n+        fmd = fileMetadata;\n+      }\n+    }\n+    return fmd;\n+  }\n+\n+  //    //Returns null if no published version\n+  public FileMetadata getLatestPublishedFileMetadata() throws UnsupportedOperationException {\n+    FileMetadata fmd = null;\n+\n+    for (FileMetadata fileMetadata : fileMetadatas) {\n+      // if it finds a draft, skip\n+      if (fileMetadata.getDatasetVersion().getVersionState().equals(VersionState.DRAFT)) {\n+        continue;\n+      }\n+\n+      // otherwise return the one with the latest version number\n+      // duplicate logic in getLatestFileMetadata()\n+      if (fmd == null ||\n+        fileMetadata.getDatasetVersion().getVersionNumber().compareTo(fmd.getDatasetVersion().getVersionNumber()) > 0) {\n+        fmd = fileMetadata;\n+      } else if (\n+        (fileMetadata.getDatasetVersion().getVersionNumber().compareTo(fmd.getDatasetVersion().getVersionNumber()) ==\n+          0) &&\n+          (fileMetadata.getDatasetVersion().getMinorVersionNumber()\n+            .compareTo(fmd.getDatasetVersion().getMinorVersionNumber()) > 0)) {\n+        fmd = fileMetadata;\n+      }\n+    }\n+    if (fmd == null) {\n+      throw new UnsupportedOperationException(\"No published metadata version for DataFile \" + this.getId());\n+    }\n+\n+    return fmd;\n+  }\n+\n+  /**\n+   * Get property filesize, number of bytes\n+   *\n+   * @return value of property filesize.\n+   */\n+  public long getFilesize() {\n+    if (this.filesize == null) {\n+      // -1 means \"unknown\"\n+      return -1;\n+    }\n+    return this.filesize;\n+  }\n+\n+  /**\n+   * Set property filesize in bytes\n+   * <p>\n+   * Allow nulls, but not negative numbers.\n+   *\n+   * @param filesize new value of property filesize.\n+   */\n+  public void setFilesize(long filesize) {\n+    if (filesize < 0) {\n+      return;\n+    }\n+    this.filesize = filesize;\n+  }\n+\n+  /**\n+   * Converts the stored size of the file in bytes to\n+   * a user-friendly value in KB, MB or GB.\n+   *\n+   * @return\n+   */\n+  public String getFriendlySize() {\n+    return FileSizeChecker.bytesToHumanReadable(filesize);\n+  }\n+\n+  public boolean isRestricted() {\n+    return restricted;\n+  }\n+\n+\n+  public void setRestricted(boolean restricted) {\n+    this.restricted = restricted;\n+  }\n+\n+  public ChecksumType getChecksumType() {\n+    return checksumType;\n+  }\n+\n+  public void setChecksumType(ChecksumType checksumType) {\n+    this.checksumType = checksumType;\n+  }\n+\n+  public String getChecksumValue() {\n+    return this.checksumValue;\n+  }\n+\n+  public void setChecksumValue(String checksumValue) {\n+    this.checksumValue = checksumValue;\n+  }\n+\n+  public String getOriginalChecksumType() {\n+    return BundleUtil.getStringFromBundle(\"file.originalChecksumType\", Arrays.asList(this.checksumType.toString()));\n+  }\n+\n+  public StorageIO<DataFile> getStorageIO() throws IOException {\n+    StorageIO<DataFile> storageIO = DataAccess.getStorageIO(this);\n+\n+    if (storageIO == null) {\n+      throw new IOException(\"Failed to create storageIO for datafile.\");\n+    }\n+\n+    return storageIO;\n+  }\n+\n+  /*\n+      Does the contentType indicate a shapefile?\n+  */\n+  public boolean isShapefileType() {\n+    if (this.contentType == null) {\n+      return false;\n+    }\n+    return ShapefileHandler.SHAPEFILE_FILE_TYPE.equalsIgnoreCase(this.contentType);\n+  }\n+\n+  public boolean isImage() {\n+    // Some browsers (Chrome?) seem to identify FITS files as mime\n+    // type \"image/fits\" on upload; this is both incorrect (the official\n+    // mime type for FITS is \"application/fits\", and problematic: then\n+    // the file is identified as an image, and the page will attempt to\n+    // generate a preview - which of course is going to fail...\n+    if (\"image/fits\".equalsIgnoreCase(contentType)) {\n+      return false;\n+    }\n+    // a pdf file is an \"image\" for practical purposes (we will attempt to\n+    // generate thumbnails and previews for them)\n+    return (contentType != null &&\n+      (contentType.startsWith(\"image/\") || contentType.equalsIgnoreCase(\"application/pdf\")));\n+  }\n+\n+  public boolean isFilePackage() {\n+    return DataFileServiceBean.MIME_TYPE_PACKAGE_FILE.equalsIgnoreCase(contentType);\n+  }\n+\n+  public void setIngestStatus(char ingestStatus) {\n+    this.ingestStatus = ingestStatus;\n+  }\n+\n+  public boolean isIngestScheduled() {\n+    return (ingestStatus == INGEST_STATUS_SCHEDULED);\n+  }\n+\n+  public boolean isIngestInProgress() {\n+    return ((ingestStatus == INGEST_STATUS_SCHEDULED) || (ingestStatus == INGEST_STATUS_INPROGRESS));\n+  }\n+\n+  public boolean isIngestProblem() {\n+    return (ingestStatus == INGEST_STATUS_ERROR);\n+  }\n+\n+  public void SetIngestScheduled() {\n+    ingestStatus = INGEST_STATUS_SCHEDULED;\n+  }\n+\n+  public void SetIngestInProgress() {\n+    ingestStatus = INGEST_STATUS_INPROGRESS;\n+  }\n+\n+  public void SetIngestProblem() {\n+    ingestStatus = INGEST_STATUS_ERROR;\n+  }\n+\n+  public void setIngestDone() {\n+    ingestStatus = INGEST_STATUS_NONE;\n+  }\n \n-    @ManyToMany\n-    @JoinTable(name = \"fileaccessrequests\",\n+  public int getIngestStatus() {\n+    return ingestStatus;\n+  }\n+\n+  public Dataset getThumbnailForDataset() {\n+    return thumbnailForDataset;\n+  }\n+\n+  public void setAsThumbnailForDataset(Dataset dataset) {\n+    thumbnailForDataset = dataset;\n+  }\n+\n+  /*\n+      8/10/2014 - Using the current \"open access\" url\n+  */\n+  public String getMapItFileDownloadURL(String serverName) {\n+    if ((this.getId() == null) || (serverName == null)) {\n+      return null;\n+    }\n+    return serverName + \"/api/access/datafile/\" + this.getId();\n+  }\n+\n+  /*\n+   * If this is tabular data, the corresponding dataTable may have a UNF -\n+   * \"numeric fingerprint\" signature - generated:\n+   */\n+\n+  public String getUnf() {\n+    if (this.isTabularData()) {\n+      // (isTabularData() method above verifies that that this file\n+      // has a datDatable associated with it, so the line below is\n+      // safe, in terms of a NullPointerException:\n+      return this.getDataTable().getUnf();\n+    }\n+    return null;\n+  }\n+\n+\n+  @ManyToMany\n+  @JoinTable(name = \"fileaccessrequests\",\n     joinColumns = @JoinColumn(name = \"datafile_id\"),\n     inverseJoinColumns = @JoinColumn(name = \"authenticated_user_id\"))\n-    private List<AuthenticatedUser> fileAccessRequesters;\n+  private List<AuthenticatedUser> fileAccessRequesters;\n \n-    public List<AuthenticatedUser> getFileAccessRequesters() {\n-        return fileAccessRequesters;\n-    }\n+  public List<AuthenticatedUser> getFileAccessRequesters() {\n+    return fileAccessRequesters;\n+  }\n \n-    public void setFileAccessRequesters(List<AuthenticatedUser> fileAccessRequesters) {\n-        this.fileAccessRequesters = fileAccessRequesters;\n-    }\n-    \n-    public boolean isHarvested() {\n-        \n-        Dataset ownerDataset = this.getOwner();\n-        if (ownerDataset != null) {\n-            return ownerDataset.isHarvested(); \n-        }\n-        return false; \n-    }\n-    \n-    public String getRemoteArchiveURL() {\n-        if (isHarvested()) {\n-            Dataset ownerDataset = this.getOwner();\n-            return ownerDataset.getRemoteArchiveURL();\n-        }\n-        \n-        return null; \n-    }\n-    \n-    public String getHarvestingDescription() {\n-        if (isHarvested()) {\n-            Dataset ownerDataset = this.getOwner();\n-            return ownerDataset.getHarvestingDescription();\n-        }\n-        \n-        return null;\n-    }\n-    \n-    @Override\n-    public boolean equals(Object object) {\n-        if (!(object instanceof DataFile)) {\n-            return false;\n-        }\n-        DataFile other = (DataFile) object;\n-        return Objects.equals(getId(), other.getId());\n-    }\n+  public void setFileAccessRequesters(List<AuthenticatedUser> fileAccessRequesters) {\n+    this.fileAccessRequesters = fileAccessRequesters;\n+  }\n \n-    @Override\n-    public int hashCode() {\n-        return super.hashCode();\n-    }\n+  public boolean isHarvested() {\n \n-    @Override\n-    protected String toStringExtras() {\n-        FileMetadata fmd = getLatestFileMetadata();\n-        return \"label:\" + (fmd!=null? fmd.getLabel() : \"[no metadata]\");\n-    }\n-\t\n-\t@Override\n-\tpublic <T> T accept( Visitor<T> v ) {\n-\t\treturn v.visit(this);\n-\t}\n-        \n-    @Override\n-    public String getDisplayName() {\n-       return getLatestFileMetadata().getLabel(); \n-    }\n-    \n-    public String getDirectoryLabel() {\n-       return getLatestFileMetadata().getDirectoryLabel();\n-    }\n-    \n-    @Override \n-    public String getCurrentName(){\n-        return getLatestFileMetadata().getLabel();\n+    Dataset ownerDataset = this.getOwner();\n+    if (ownerDataset != null) {\n+      return ownerDataset.isHarvested();\n     }\n-    \n-    @Override\n-    public int compareTo(Object o) {\n-        /*\n-         * The primary intent here is to provide ordering by displayName. However, the\n-         * secondary comparison by id is needed to insure that two DataFiles with the\n-         * same displayName aren't considered equal, e.g. in structures that require\n-         * unique keys. See Issues #4287 and #6401.\n-         */\n-        DataFile other = (DataFile) o;\n-        int comparison = this.getDisplayName().toUpperCase().compareTo(other.getDisplayName().toUpperCase());\n-        if (comparison == 0) {\n-            comparison = this.getId().compareTo(other.getId());\n-        }\n-        return comparison;\n+    return false;\n+  }\n+\n+  public String getRemoteArchiveURL() {\n+    if (isHarvested()) {\n+      Dataset ownerDataset = this.getOwner();\n+      return ownerDataset.getRemoteArchiveURL();\n     }\n-    \n-    /**\n-     * Check if the Geospatial Tag has been assigned to this file\n-     * @return \n-     */\n-    public boolean hasGeospatialTag(){\n-        if (this.dataFileTags == null){\n-            return false;\n-        }\n-        for (DataFileTag tag : this.dataFileTags){\n-            if (tag.isGeospatialTag()){\n-                return true;\n-            }\n-        }\n-        return false;\n+\n+    return null;\n+  }\n+\n+  public String getHarvestingDescription() {\n+    if (isHarvested()) {\n+      Dataset ownerDataset = this.getOwner();\n+      return ownerDataset.getHarvestingDescription();\n     }\n \n-    \n-    /**\n-     *  Set rootDataFileId\n-     *  @param rootDataFileId\n-     */\n-    public void setRootDataFileId(Long rootDataFileId){\n-        this.rootDataFileId = rootDataFileId;\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean equals(Object object) {\n+    if (!(object instanceof DataFile)) {\n+      return false;\n     }\n+    DataFile other = (DataFile) object;\n+    return Objects.equals(getId(), other.getId());\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return super.hashCode();\n+  }\n \n-    /**\n-     *  Get for rootDataFileId\n-     *  @return Long\n+  @Override\n+  protected String toStringExtras() {\n+    FileMetadata fmd = getLatestFileMetadata();\n+    return \"label:\" + (fmd != null ? fmd.getLabel() : \"[no metadata]\");\n+  }\n+\n+  @Override\n+  public <T> T accept(Visitor<T> v) {\n+    return v.visit(this);\n+  }\n+\n+  @Override\n+  public String getDisplayName() {\n+    return getLatestFileMetadata().getLabel();\n+  }\n+\n+  public String getDirectoryLabel() {\n+    return getLatestFileMetadata().getDirectoryLabel();\n+  }\n+\n+  @Override\n+  public String getCurrentName() {\n+    return getLatestFileMetadata().getLabel();\n+  }\n+\n+  @Override\n+  public int compareTo(Object o) {\n+    /*\n+     * The primary intent here is to provide ordering by displayName. However, the\n+     * secondary comparison by id is needed to insure that two DataFiles with the\n+     * same displayName aren't considered equal, e.g. in structures that require\n+     * unique keys. See Issues #4287 and #6401.\n      */\n-    public Long getRootDataFileId(){\n-        return this.rootDataFileId;\n-    }\n+    DataFile other = (DataFile) o;\n+    int comparison = this.getDisplayName().toUpperCase().compareTo(other.getDisplayName().toUpperCase());\n+    if (comparison == 0) {\n+      comparison = this.getId().compareTo(other.getId());\n+    }\n+    return comparison;\n+  }\n+\n+  /**\n+   * Check if the Geospatial Tag has been assigned to this file\n+   *\n+   * @return\n+   */\n+  public boolean hasGeospatialTag() {\n+    if (this.dataFileTags == null) {\n+      return false;\n+    }\n+    for (DataFileTag tag : this.dataFileTags) {\n+      if (tag.isGeospatialTag()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+\n+  /**\n+   * Set rootDataFileId\n+   *\n+   * @param rootDataFileId\n+   */\n+  public void setRootDataFileId(Long rootDataFileId) {\n+    this.rootDataFileId = rootDataFileId;\n+  }\n+\n+  /**\n+   * Get for rootDataFileId\n+   *\n+   * @return Long\n+   */\n+  public Long getRootDataFileId() {\n+    return this.rootDataFileId;\n+  }\n \n //    public int getProvCplId() {\n //        return provCplId;\n@@ -883,155 +895,155 @@ public class DataFile extends DvObject implements Comparable {\n //    public void setProvCplId(int cplId) {\n //        this.provCplId = cplId;\n //    }\n-    \n-    public String getProvEntityName() {\n-        return provEntityName;\n-    }\n-    \n-    public void setProvEntityName(String name) {\n-        this.provEntityName = name;\n-    }\n-    \n-    /**\n-     *  Set previousDataFileId\n-     *  @param previousDataFileId\n-     */\n-    public void setPreviousDataFileId(Long previousDataFileId){\n-        this.previousDataFileId = previousDataFileId;\n-    }\n \n-    /**\n-     *  Get for previousDataFileId\n-     *  @return Long\n-     */\n-    public Long getPreviousDataFileId(){\n-        return this.previousDataFileId;\n-    }\n+  public String getProvEntityName() {\n+    return provEntityName;\n+  }\n \n-    public String toPrettyJSON(){\n-        \n-        return serializeAsJSON(true);\n-    }\n+  public void setProvEntityName(String name) {\n+    this.provEntityName = name;\n+  }\n \n-    public String toJSON(){\n-        \n-        return serializeAsJSON(false);\n-    }\n-    \n-    \n-    \n-    public JsonObject asGsonObject(boolean prettyPrint){\n-        \n-        String overarchingKey = \"data\";\n-        \n-        GsonBuilder builder;\n-        if (prettyPrint){  // Add pretty printing\n-            builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setPrettyPrinting();\n-        }else{\n-            builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation();                        \n-        }\n-        \n-        builder.serializeNulls();   // correctly capture nulls\n-        Gson gson = builder.create();\n-\n-        // ----------------------------------\n-        // serialize this object + add the id\n-        // ----------------------------------\n-        JsonElement jsonObj = gson.toJsonTree(this);\n-        jsonObj.getAsJsonObject().addProperty(\"id\", this.getId());\n-\n-        // ----------------------------------\n-        //  get the FileMetadata object\n-        // ----------------------------------\n-        FileMetadata thisFileMetadata = this.getFileMetadata();\n-\n-        // ----------------------------------\n-        //  Add dataset info\n-        // ----------------------------------\n-\n-        Map<String, Object> datasetMap = new HashMap<>();\n-        // expensive call.......bleh!!! \n-        // https://github.com/IQSS/dataverse/issues/761, https://github.com/IQSS/dataverse/issues/2110, https://github.com/IQSS/dataverse/issues/3191\n-        //\n-        datasetMap.put(\"title\", thisFileMetadata.getDatasetVersion().getTitle());\n-        datasetMap.put(\"persistentId\", getOwner().getGlobalIdString());\n-        datasetMap.put(\"url\", getOwner().getPersistentURL());\n-        datasetMap.put(\"version\", thisFileMetadata.getDatasetVersion().getSemanticVersion());\n-        datasetMap.put(\"id\", getOwner().getId());\n-        datasetMap.put(\"isPublished\", thisFileMetadata.getDatasetVersion().isReleased());\n-        \n-        jsonObj.getAsJsonObject().add(\"dataset\",  gson.toJsonTree(datasetMap));\n-       \n-        // ----------------------------------\n-        //  Add dataverse info\n-        // ----------------------------------\n-        Map<String, Object> dataverseMap = new HashMap<>();\n-        Dataverse dv = this.getOwner().getOwner();\n-        \n-        dataverseMap.put(\"name\", dv.getName());\n-        dataverseMap.put(\"alias\", dv.getAlias());\n-        dataverseMap.put(\"id\", dv.getId()); \n-\n-        jsonObj.getAsJsonObject().add(\"dataverse\",  gson.toJsonTree(dataverseMap));\n-        \n-        // ----------------------------------\n-        //  Add label (filename), description, and categories from the FileMetadata object\n-        // ----------------------------------\n-\n-        jsonObj.getAsJsonObject().addProperty(\"filename\", thisFileMetadata.getLabel());\n-        jsonObj.getAsJsonObject().addProperty(\"description\", thisFileMetadata.getDescription());\n-        jsonObj.getAsJsonObject().add(\"categories\", \n-                            gson.toJsonTree(thisFileMetadata.getCategoriesByName())\n-                    );\n-\n-        // ----------------------------------        \n-        // Tags\n-        // ----------------------------------               \n-        jsonObj.getAsJsonObject().add(\"tags\", gson.toJsonTree(getTagLabels()));\n-\n-        // ----------------------------------        \n-        // Checksum\n-        // ----------------------------------\n-        Map<String, String> checkSumMap = new HashMap<>();\n-        checkSumMap.put(\"type\", getChecksumType().toString());\n-        checkSumMap.put(\"value\", getChecksumValue());\n-        \n-        JsonElement checkSumJSONMap = gson.toJsonTree(checkSumMap);\n-        \n-        jsonObj.getAsJsonObject().add(\"checksum\", checkSumJSONMap);\n-        \n-        return jsonObj.getAsJsonObject();\n-        \n-    }\n-    \n-    /**\n-     * \n-     * @param prettyPrint\n-     * @return \n-     */\n-    private String serializeAsJSON(boolean prettyPrint){\n-        \n-        JsonObject fullFileJSON = asGsonObject(prettyPrint);\n-              \n-        //return fullFileJSON.\n-        return fullFileJSON.toString();\n-        \n+  /**\n+   * Set previousDataFileId\n+   *\n+   * @param previousDataFileId\n+   */\n+  public void setPreviousDataFileId(Long previousDataFileId) {\n+    this.previousDataFileId = previousDataFileId;\n+  }\n+\n+  /**\n+   * Get for previousDataFileId\n+   *\n+   * @return Long\n+   */\n+  public Long getPreviousDataFileId() {\n+    return this.previousDataFileId;\n+  }\n+\n+  public String toPrettyJSON() {\n+\n+    return serializeAsJSON(true);\n+  }\n+\n+  public String toJSON() {\n+\n+    return serializeAsJSON(false);\n+  }\n+\n+\n+  public JsonObject asGsonObject(boolean prettyPrint) {\n+\n+    String overarchingKey = \"data\";\n+\n+    GsonBuilder builder;\n+    if (prettyPrint) {  // Add pretty printing\n+      builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setPrettyPrinting();\n+    } else {\n+      builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation();\n     }\n-    \n-    public String getPublicationDateFormattedYYYYMMDD() {\n-        if (getPublicationDate() != null){\n-                   return new SimpleDateFormat(\"yyyy-MM-dd\").format(getPublicationDate()); \n-        }\n-        return null;\n+\n+    builder.serializeNulls();   // correctly capture nulls\n+    Gson gson = builder.create();\n+\n+    // ----------------------------------\n+    // serialize this object + add the id\n+    // ----------------------------------\n+    JsonElement jsonObj = gson.toJsonTree(this);\n+    jsonObj.getAsJsonObject().addProperty(\"id\", this.getId());\n+\n+    // ----------------------------------\n+    //  get the FileMetadata object\n+    // ----------------------------------\n+    FileMetadata thisFileMetadata = this.getFileMetadata();\n+\n+    // ----------------------------------\n+    //  Add dataset info\n+    // ----------------------------------\n+\n+    Map<String, Object> datasetMap = new HashMap<>();\n+    // expensive call.......bleh!!!\n+    // https://github.com/IQSS/dataverse/issues/761, https://github.com/IQSS/dataverse/issues/2110, https://github.com/IQSS/dataverse/issues/3191\n+    //\n+    datasetMap.put(\"title\", thisFileMetadata.getDatasetVersion().getTitle());\n+    datasetMap.put(\"persistentId\", getOwner().getGlobalIdString());\n+    datasetMap.put(\"url\", getOwner().getPersistentURL());\n+    datasetMap.put(\"version\", thisFileMetadata.getDatasetVersion().getSemanticVersion());\n+    datasetMap.put(\"id\", getOwner().getId());\n+    datasetMap.put(\"isPublished\", thisFileMetadata.getDatasetVersion().isReleased());\n+\n+    jsonObj.getAsJsonObject().add(\"dataset\", gson.toJsonTree(datasetMap));\n+\n+    // ----------------------------------\n+    //  Add dataverse info\n+    // ----------------------------------\n+    Map<String, Object> dataverseMap = new HashMap<>();\n+    Dataverse dv = this.getOwner().getOwner();\n+\n+    dataverseMap.put(\"name\", dv.getName());\n+    dataverseMap.put(\"alias\", dv.getAlias());\n+    dataverseMap.put(\"id\", dv.getId());\n+\n+    jsonObj.getAsJsonObject().add(\"dataverse\", gson.toJsonTree(dataverseMap));\n+\n+    // ----------------------------------\n+    //  Add label (filename), description, and categories from the FileMetadata object\n+    // ----------------------------------\n+\n+    jsonObj.getAsJsonObject().addProperty(\"filename\", thisFileMetadata.getLabel());\n+    jsonObj.getAsJsonObject().addProperty(\"description\", thisFileMetadata.getDescription());\n+    jsonObj.getAsJsonObject().add(\"categories\",\n+      gson.toJsonTree(thisFileMetadata.getCategoriesByName())\n+    );\n+\n+    // ----------------------------------\n+    // Tags\n+    // ----------------------------------\n+    jsonObj.getAsJsonObject().add(\"tags\", gson.toJsonTree(getTagLabels()));\n+\n+    // ----------------------------------\n+    // Checksum\n+    // ----------------------------------\n+    Map<String, String> checkSumMap = new HashMap<>();\n+    checkSumMap.put(\"type\", getChecksumType().toString());\n+    checkSumMap.put(\"value\", getChecksumValue());\n+\n+    JsonElement checkSumJSONMap = gson.toJsonTree(checkSumMap);\n+\n+    jsonObj.getAsJsonObject().add(\"checksum\", checkSumJSONMap);\n+\n+    return jsonObj.getAsJsonObject();\n+\n+  }\n+\n+  /**\n+   * @param prettyPrint\n+   * @return\n+   */\n+  private String serializeAsJSON(boolean prettyPrint) {\n+\n+    JsonObject fullFileJSON = asGsonObject(prettyPrint);\n+\n+    //return fullFileJSON.\n+    return fullFileJSON.toString();\n+\n+  }\n+\n+  public String getPublicationDateFormattedYYYYMMDD() {\n+    if (getPublicationDate() != null) {\n+      return new SimpleDateFormat(\"yyyy-MM-dd\").format(getPublicationDate());\n     }\n-    \n-    public String getCreateDateFormattedYYYYMMDD() {\n-        if (getCreateDate() != null){\n-                   return new SimpleDateFormat(\"yyyy-MM-dd\").format(getCreateDate()); \n-        }\n-        return null;\n+    return null;\n+  }\n+\n+  public String getCreateDateFormattedYYYYMMDD() {\n+    if (getCreateDate() != null) {\n+      return new SimpleDateFormat(\"yyyy-MM-dd\").format(getCreateDate());\n     }\n-    \n+    return null;\n+  }\n+\n \n } // end of class\n     \n",
            "diff_size": 1403
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/23/DataFile.java\nindex 4cb2abfb12f..0142adb0665 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/23/DataFile.java\n@@ -54,37 +54,41 @@ import org.hibernate.validator.constraints.NotBlank;\n  *\n  * @author gdurand\n  */\n+\n+\n @NamedQueries({\n-\t@NamedQuery( name=\"DataFile.removeFromDatasetVersion\",\n-\t\tquery=\"DELETE FROM FileMetadata f WHERE f.datasetVersion.id=:versionId and f.dataFile.id=:fileId\"),\n-        @NamedQuery(name = \"DataFile.findByCreatorId\",\n-                query = \"SELECT o FROM DataFile o WHERE o.creator.id=:creatorId\"),\n-        @NamedQuery(name = \"DataFile.findByReleaseUserId\",\n-                query = \"SELECT o FROM DataFile o WHERE o.releaseUser.id=:releaseUserId\"),\n-        @NamedQuery(name=\"DataFile.findDataFileByIdProtocolAuth\", \n-                query=\"SELECT s FROM DataFile s WHERE s.identifier=:identifier AND s.protocol=:protocol AND s.authority=:authority\"),\n-        @NamedQuery(name=\"DataFile.findDataFileThatReplacedId\", \n-                query=\"SELECT s.id FROM DataFile s WHERE s.previousDataFileId=:identifier\")\n+    @NamedQuery(name = \"DataFile.removeFromDatasetVersion\",\n+        query = \"DELETE FROM FileMetadata f WHERE f.datasetVersion.id=:versionId and f.dataFile.id=:fileId\"),\n+    @NamedQuery(name = \"DataFile.findByCreatorId\", query = \"SELECT o FROM DataFile o WHERE o.creator.id=:creatorId\"),\n+    @NamedQuery(name = \"DataFile.findByReleaseUserId\",\n+        query = \"SELECT o FROM DataFile o WHERE o.releaseUser.id=:releaseUserId\"),\n+    @NamedQuery(name = \"DataFile.findDataFileByIdProtocolAuth\",\n+        query = \"SELECT s FROM DataFile s WHERE s.identifier=:identifier AND s.protocol=:protocol AND s.authority=:authority\"),\n+    @NamedQuery(name = \"DataFile.findDataFileThatReplacedId\",\n+        query = \"SELECT s.id FROM DataFile s WHERE s.previousDataFileId=:identifier\")\n })\n @Entity\n-@Table(indexes = {@Index(columnList=\"ingeststatus\")\n-\t\t, @Index(columnList=\"checksumvalue\")\n-\t\t, @Index(columnList=\"contenttype\")\n-\t\t, @Index(columnList=\"restricted\")})\n+@Table(indexes = {@Index(columnList = \"ingeststatus\"), @Index(columnList = \"checksumvalue\"), @Index(columnList = \"contenttype\"), @Index(columnList = \"restricted\")})\n public class DataFile extends DvObject implements Comparable {\n+\n     private static final Logger logger = Logger.getLogger(DatasetPage.class.getCanonicalName());\n     private static final long serialVersionUID = 1L;\n+\n     public static final String TARGET_URL = \"/file.xhtml?persistentId=\";\n+\n     public static final char INGEST_STATUS_NONE = 65;\n+\n     public static final char INGEST_STATUS_SCHEDULED = 66;\n+\n     public static final char INGEST_STATUS_INPROGRESS = 67;\n-    public static final char INGEST_STATUS_ERROR = 68; \n-    \n-    public static final Long ROOT_DATAFILE_ID_DEFAULT = (long) -1;\n-    \n+\n+    public static final char INGEST_STATUS_ERROR = 68;\n+\n+    public static final Long ROOT_DATAFILE_ID_DEFAULT = (long)-1;\n+\n     @Expose\n     @NotBlank\n-    @Column( nullable = false )\n+    @Column(nullable = false)\n     @Pattern(regexp = \"^.*/.*$\", message = \"{contenttype.slash}\")\n     private String contentType;\n     \n@@ -105,12 +109,9 @@ public class DataFile extends DvObject implements Comparable {\n      * because the string gets passed into MessageDigest.getInstance() and you\n      * can't just pass in any old string.\n      */\n-    public enum ChecksumType {\n \n-        MD5(\"MD5\"),\n-        SHA1(\"SHA-1\"),\n-        SHA256(\"SHA-256\"),\n-        SHA512(\"SHA-512\");\n+    public enum ChecksumType {\n+        MD5(\"MD5\"), SHA1(\"SHA-1\"), SHA256(\"SHA-256\"), SHA512(\"SHA-512\");\n \n         private final String text;\n \n@@ -133,9 +134,11 @@ public class DataFile extends DvObject implements Comparable {\n         public String toString() {\n             return text;\n         }\n+\n     }\n \n     //@Expose\n+\n     @Column(nullable = false)\n     @Enumerated(EnumType.STRING)\n     private ChecksumType checksumType;\n@@ -145,6 +148,7 @@ public class DataFile extends DvObject implements Comparable {\n      * \"3a484dfdb1b429c2e15eb2a735f1f5e4d5b04ec6\" as a SHA-1 value\"\n      */\n     //@Expose\n+\n     @Column(nullable = false)\n     private String checksumValue;\n \n@@ -153,8 +157,9 @@ public class DataFile extends DvObject implements Comparable {\n     \n     // For the initial version of a file, this will be equivalent to the ID\n     // Default is -1 until the intial id is generated\n+\n     @Expose\n-    @Column(nullable=false)\n+    @Column(nullable = false)\n     private Long rootDataFileId;\n \n     /**\n@@ -163,22 +168,21 @@ public class DataFile extends DvObject implements Comparable {\n      */\n     // null for initial version; subsequent versions will point to the previous file\n     //\n+\n     @Expose\n-    @Column(nullable=true)\n+    @Column(nullable = true)\n     private Long previousDataFileId;\n     /* endt: FILE REPLACE ATTRIBUTES */\n-    \n-    \n-    \n+\n     @Expose\n-    @Column(nullable=true)\n+    @Column(nullable = true)\n     private Long filesize;      // Number of bytes in file.  Allows 0 and null, negative numbers not permitted\n \n     @Expose\n     private boolean restricted;\n-    \n+\n     @Expose\n-    @Column(columnDefinition = \"TEXT\", nullable = true, name=\"prov_entityname\")\n+    @Column(columnDefinition = \"TEXT\", nullable = true, name = \"prov_entityname\")\n     private String provEntityName;\n     \n     /*Add when we integrate with provCPL*/\n@@ -190,26 +194,26 @@ public class DataFile extends DvObject implements Comparable {\n         Tabular (formerly \"subsettable\") data files have DataTable objects\n         associated with them:\n     */\n-    \n+\n     @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n     private List<DataTable> dataTables;\n-    \n+\n     @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n     private List<AuxiliaryFile> auxiliaryFiles;\n-   \n+\n     @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n     private List<IngestReport> ingestReports;\n-    \n+\n     @OneToOne(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n     private IngestRequest ingestRequest;\n-    \n+\n     @OneToMany(mappedBy = \"dataFile\", orphanRemoval = true, cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n     private List<DataFileTag> dataFileTags;\n-    \n-    @OneToMany(mappedBy=\"dataFile\", cascade={CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+\n+    @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n     private List<FileMetadata> fileMetadatas;\n-    \n-    @OneToMany(mappedBy=\"dataFile\", cascade={CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n+\n+    @OneToMany(mappedBy = \"dataFile\", cascade = {CascadeType.REMOVE, CascadeType.MERGE, CascadeType.PERSIST})\n     private List<GuestbookResponse> guestbookResponses;\n \n     public List<GuestbookResponse> getGuestbookResponses() {\n@@ -220,15 +224,15 @@ public class DataFile extends DvObject implements Comparable {\n         this.guestbookResponses = guestbookResponses;\n     }\n \n-    private char ingestStatus = INGEST_STATUS_NONE; \n-    \n+    private char ingestStatus = INGEST_STATUS_NONE;\n+\n     @OneToOne(mappedBy = \"thumbnailFile\")\n     private Dataset thumbnailForDataset;\n \n     public DataFile() {\n         this.fileMetadatas = new ArrayList<>();\n         initFileReplaceAttributes();\n-    }    \n+    }\n \n     public DataFile(String contentType) {\n         this.contentType = contentType;\n@@ -241,7 +245,7 @@ public class DataFile extends DvObject implements Comparable {\n     to easily display those files that have been deleted in the current draft \n     or previous version which may have roles assigned or pending requests for access\n     */\n-   \n+\n     @Transient\n     private Boolean deleted;\n \n@@ -257,7 +261,7 @@ public class DataFile extends DvObject implements Comparable {\n     For use during file upload so that the user may delete \n     files that have already been uploaded to the current dataset version\n     */\n-    \n+\n     @Transient\n     private boolean markedAsDuplicate;\n \n@@ -268,7 +272,7 @@ public class DataFile extends DvObject implements Comparable {\n     public void setMarkedAsDuplicate(boolean markedAsDuplicate) {\n         this.markedAsDuplicate = markedAsDuplicate;\n     }\n-    \n+\n     @Transient\n     private String duplicateFilename;\n \n@@ -296,16 +300,17 @@ public class DataFile extends DvObject implements Comparable {\n      * All constructors should use this method\n      * to initialize this file replace attributes\n      */\n-    private void initFileReplaceAttributes(){\n+\n+    private void initFileReplaceAttributes() {\n         this.rootDataFileId = ROOT_DATAFILE_ID_DEFAULT;\n         this.previousDataFileId = null;\n     }\n-    \n+\n     @Override\n     public boolean isEffectivelyPermissionRoot() {\n         return false;\n     }\n-    \n+\n     public List<DataTable> getDataTables() {\n         return dataTables;\n     }\n@@ -313,9 +318,9 @@ public class DataFile extends DvObject implements Comparable {\n     public void setDataTables(List<DataTable> dataTables) {\n         this.dataTables = dataTables;\n     }\n-    \n+\n     public DataTable getDataTable() {\n-        if ( getDataTables() != null && getDataTables().size() > 0 ) {\n+        if (getDataTables() != null && getDataTables().size() > 0) {\n             return getDataTables().get(0);\n         } else {\n             return null;\n@@ -328,21 +333,17 @@ public class DataFile extends DvObject implements Comparable {\n         } else {\n             this.getDataTables().clear();\n         }\n-\n         this.getDataTables().add(dt);\n     }\n-    \n+\n     public List<DataFileTag> getTags() {\n         return dataFileTags;\n     }\n-    \n-    public List<String> getTagLabels(){\n-        \n+\n+    public List<String> getTagLabels() {\n         List<DataFileTag> currentDataTags = this.getTags();\n         List<String> tagStrings = new ArrayList<>();\n-        \n-        if (( currentDataTags != null)&&(!currentDataTags.isEmpty())){\n-                       \n+        if ((currentDataTags != null) && (!currentDataTags.isEmpty())) {\n             for (DataFileTag element : currentDataTags) {\n                 tagStrings.add(element.getTypeLabel());\n             }\n@@ -350,34 +351,30 @@ public class DataFile extends DvObject implements Comparable {\n         return tagStrings;\n     }\n \n-    public JsonArrayBuilder getTagLabelsAsJsonArrayBuilder(){\n-        \n+    public JsonArrayBuilder getTagLabelsAsJsonArrayBuilder() {\n         List<DataFileTag> currentDataTags = this.getTags();\n-\n         JsonArrayBuilder builder = Json.createArrayBuilder();\n-        \n-        if ( (currentDataTags == null)||(currentDataTags.isEmpty())){\n+        if ((currentDataTags == null) || (currentDataTags.isEmpty())) {\n             return builder;\n         }\n-        \n-        \n+\n         for (DataFileTag element : currentDataTags) {\n-            builder.add(element.getTypeLabel());            \n+            builder.add(element.getTypeLabel());\n         }\n         return builder;\n     }\n+\n     public void setTags(List<DataFileTag> dataFileTags) {\n         this.dataFileTags = dataFileTags;\n     }\n-    \n+\n     public void addTag(DataFileTag tag) {\n         if (dataFileTags == null) {\n             dataFileTags = new ArrayList<>();\n-        } \n-\n+        }\n         dataFileTags.add(tag);\n     }\n-    \n+\n     public List<FileMetadata> getFileMetadatas() {\n         return fileMetadatas;\n     }\n@@ -385,9 +382,9 @@ public class DataFile extends DvObject implements Comparable {\n     public void setFileMetadatas(List<FileMetadata> fileMetadatas) {\n         this.fileMetadatas = fileMetadatas;\n     }\n-    \n+\n     public IngestReport getIngestReport() {\n-        if ( ingestReports != null && ingestReports.size() > 0 ) {\n+        if (ingestReports != null && ingestReports.size() > 0) {\n             return ingestReports.get(0);\n         } else {\n             return null;\n@@ -400,31 +397,30 @@ public class DataFile extends DvObject implements Comparable {\n         } else {\n             ingestReports.clear();\n         }\n-\n         ingestReports.add(report);\n     }\n-    \n+\n     public IngestRequest getIngestRequest() {\n         return ingestRequest;\n     }\n-    \n+\n     public void setIngestRequest(IngestRequest ingestRequest) {\n         this.ingestRequest = ingestRequest;\n     }\n-    \n+\n     public String getIngestReportMessage() {\n-        if ( ingestReports != null && ingestReports.size() > 0 ) {\n+        if (ingestReports != null && ingestReports.size() > 0) {\n             if (ingestReports.get(0).getReport() != null && !\"\".equals(ingestReports.get(0).getReport())) {\n                 return ingestReports.get(0).getReport();\n             }\n         }\n         return \"Ingest failed. No further information is available.\";\n     }\n-    \n+\n     public boolean isTabularData() {\n-        return getDataTables() != null && getDataTables().size() > 0; \n+        return getDataTables() != null && getDataTables().size() > 0;\n     }\n-    \n+\n     public String getOriginalFileFormat() {\n         if (isTabularData()) {\n             DataTable dataTable = getDataTable();\n@@ -434,7 +430,7 @@ public class DataFile extends DvObject implements Comparable {\n         }\n         return null;\n     }\n-    \n+\n     public Long getOriginalFileSize() {\n         if (isTabularData()) {\n             DataTable dataTable = getDataTable();\n@@ -444,19 +440,17 @@ public class DataFile extends DvObject implements Comparable {\n         }\n         return null;\n     }\n-    \n+\n     public String getOriginalFileName() {\n         if (isTabularData()) {\n             DataTable dataTable = getDataTable();\n             if (dataTable != null) {\n-                return dataTable.getOriginalFileName() != null ? dataTable.getOriginalFileName()\n-                        : getDerivedOriginalFileName();\n+                return dataTable.getOriginalFileName() != null ? dataTable.getOriginalFileName() : getDerivedOriginalFileName();\n             }\n         }\n         return null;\n     }\n \n-    \n     private String getDerivedOriginalFileName() {\n         FileMetadata fm = getFileMetadata();\n         String filename = fm.getLabel();\n@@ -464,19 +458,20 @@ public class DataFile extends DvObject implements Comparable {\n         String extensionToRemove = StringUtil.substringIncludingLast(filename, \".\");\n         if (StringUtil.nonEmpty(extensionToRemove)) {\n             return filename.replaceAll(extensionToRemove + \"$\", originalExtension);\n-        } else{\n-            return filename + originalExtension ;\n-        }        \n+        } else {\n+            return filename + originalExtension;\n+        }\n     }\n \n     @Override\n-    public boolean isAncestorOf( DvObject other ) {\n+    public boolean isAncestorOf(DvObject other) {\n         return equals(other);\n     }\n     \n     /*\n      * A user-friendly version of the \"original format\":\n      */\n+\n     public String getOriginalFormatLabel() {\n         return FileUtil.getUserFriendlyOriginalType(this);\n     }\n@@ -492,7 +487,7 @@ public class DataFile extends DvObject implements Comparable {\n     public String getFriendlyType() {\n         return FileUtil.getUserFriendlyFileType(this);\n     }\n-    \n+\n     @Override\n     public Dataset getOwner() {\n         return (Dataset) super.getOwner();\n@@ -501,10 +496,9 @@ public class DataFile extends DvObject implements Comparable {\n     public void setOwner(Dataset dataset) {\n         super.setOwner(dataset);\n     }\n-    \n+\n     public String getDescription() {\n         FileMetadata fmd = getLatestFileMetadata();\n-        \n         if (fmd == null) {\n             return null;\n         }\n@@ -513,16 +507,15 @@ public class DataFile extends DvObject implements Comparable {\n \n     public void setDescription(String description) {\n         FileMetadata fmd = getLatestFileMetadata();\n-        \n         if (fmd != null) {\n             fmd.setDescription(description);\n         }\n     }\n-    \n+\n     public FileMetadata getFileMetadata() {\n         return getLatestFileMetadata();\n     }\n-    \n+\n     public FileMetadata getLatestFileMetadata() {\n         FileMetadata fmd = null;\n \n@@ -530,7 +523,7 @@ public class DataFile extends DvObject implements Comparable {\n         if (fileMetadatas.size() == 1) {\n             return fileMetadatas.get(0);\n         }\n-        \n+\n         for (FileMetadata fileMetadata : fileMetadatas) {\n             // if it finds a draft, return it\n             if (fileMetadata.getDatasetVersion().getVersionState().equals(VersionState.DRAFT)) {\n@@ -539,10 +532,10 @@ public class DataFile extends DvObject implements Comparable {\n             \n             // otherwise return the one with the latest version number\n             // duplicate logic in getLatestPublishedFileMetadata()\n-            if (fmd == null || fileMetadata.getDatasetVersion().getVersionNumber().compareTo( fmd.getDatasetVersion().getVersionNumber() ) > 0 ) {\n+\n+            if (fmd == null || fileMetadata.getDatasetVersion().getVersionNumber().compareTo(fmd.getDatasetVersion().getVersionNumber()) > 0) {\n                 fmd = fileMetadata;\n-            } else if ((fileMetadata.getDatasetVersion().getVersionNumber().compareTo( fmd.getDatasetVersion().getVersionNumber())==0 )&& \n-                   ( fileMetadata.getDatasetVersion().getMinorVersionNumber().compareTo( fmd.getDatasetVersion().getMinorVersionNumber()) > 0 )   ) {\n+            } else if ((fileMetadata.getDatasetVersion().getVersionNumber().compareTo(fmd.getDatasetVersion().getVersionNumber()) == 0) && (fileMetadata.getDatasetVersion().getMinorVersionNumber().compareTo(fmd.getDatasetVersion().getMinorVersionNumber()) > 0)) {\n                 fmd = fileMetadata;\n             }\n         }\n@@ -550,9 +543,9 @@ public class DataFile extends DvObject implements Comparable {\n     }\n     \n //    //Returns null if no published version\n+\n     public FileMetadata getLatestPublishedFileMetadata() throws UnsupportedOperationException {\n         FileMetadata fmd = null;\n-        \n         for (FileMetadata fileMetadata : fileMetadatas) {\n             // if it finds a draft, skip\n             if (fileMetadata.getDatasetVersion().getVersionState().equals(VersionState.DRAFT)) {\n@@ -561,17 +554,17 @@ public class DataFile extends DvObject implements Comparable {\n             \n             // otherwise return the one with the latest version number\n             // duplicate logic in getLatestFileMetadata()\n-            if (fmd == null || fileMetadata.getDatasetVersion().getVersionNumber().compareTo( fmd.getDatasetVersion().getVersionNumber() ) > 0 ) {\n+\n+            if (fmd == null || fileMetadata.getDatasetVersion().getVersionNumber().compareTo(fmd.getDatasetVersion().getVersionNumber()) > 0) {\n                 fmd = fileMetadata;\n-            } else if ((fileMetadata.getDatasetVersion().getVersionNumber().compareTo( fmd.getDatasetVersion().getVersionNumber())==0 )&& \n-                   ( fileMetadata.getDatasetVersion().getMinorVersionNumber().compareTo( fmd.getDatasetVersion().getMinorVersionNumber()) > 0 )   ) {\n+            } else if ((fileMetadata.getDatasetVersion().getVersionNumber().compareTo(fmd.getDatasetVersion().getVersionNumber()) == 0) && (fileMetadata.getDatasetVersion().getMinorVersionNumber().compareTo(fmd.getDatasetVersion().getMinorVersionNumber()) > 0)) {\n                 fmd = fileMetadata;\n             }\n         }\n-        if(fmd == null) {\n+\n+        if (fmd == null) {\n             throw new UnsupportedOperationException(\"No published metadata version for DataFile \" + this.getId());\n         }\n-        \n         return fmd;\n     }\n \n@@ -579,11 +572,12 @@ public class DataFile extends DvObject implements Comparable {\n      * Get property filesize, number of bytes\n      * @return value of property filesize.\n      */\n+\n     public long getFilesize() {\n         if (this.filesize == null) {\n             // -1 means \"unknown\"\n             return -1;\n-        } \n+        }\n         return this.filesize;\n     }\n \n@@ -594,11 +588,12 @@ public class DataFile extends DvObject implements Comparable {\n      * \n      * @param filesize new value of property filesize.\n      */\n+\n     public void setFilesize(long filesize) {\n-        if (filesize < 0){\n+        if (filesize < 0) {\n             return;\n         }\n-       this.filesize = filesize;\n+        this.filesize = filesize;\n     }\n \n     /**\n@@ -606,6 +601,7 @@ public class DataFile extends DvObject implements Comparable {\n      * a user-friendly value in KB, MB or GB.\n      * @return \n      */\n+\n     public String getFriendlySize() {\n         return FileSizeChecker.bytesToHumanReadable(filesize);\n     }\n@@ -614,7 +610,6 @@ public class DataFile extends DvObject implements Comparable {\n         return restricted;\n     }\n \n-    \n     public void setRestricted(boolean restricted) {\n         this.restricted = restricted;\n     }\n@@ -636,29 +631,28 @@ public class DataFile extends DvObject implements Comparable {\n     }\n \n     public String getOriginalChecksumType() {\n-        return BundleUtil.getStringFromBundle(\"file.originalChecksumType\", Arrays.asList(this.checksumType.toString()) );\n+        return BundleUtil.getStringFromBundle(\"file.originalChecksumType\", Arrays.asList(this.checksumType.toString()));\n     }\n \n     public StorageIO<DataFile> getStorageIO() throws IOException {\n         StorageIO<DataFile> storageIO = DataAccess.getStorageIO(this);\n-        \n         if (storageIO == null) {\n             throw new IOException(\"Failed to create storageIO for datafile.\");\n         }\n-        \n-        return storageIO; \n+        return storageIO;\n     }\n     \n     /*\n         Does the contentType indicate a shapefile?\n     */\n-    public boolean isShapefileType(){\n-        if (this.contentType==null){\n+\n+    public boolean isShapefileType() {\n+        if (this.contentType == null) {\n             return false;\n         }\n         return ShapefileHandler.SHAPEFILE_FILE_TYPE.equalsIgnoreCase(this.contentType);\n     }\n-    \n+\n     public boolean isImage() {\n         // Some browsers (Chrome?) seem to identify FITS files as mime\n         // type \"image/fits\" on upload; this is both incorrect (the official\n@@ -672,51 +666,51 @@ public class DataFile extends DvObject implements Comparable {\n         // generate thumbnails and previews for them)\n         return (contentType != null && (contentType.startsWith(\"image/\") || contentType.equalsIgnoreCase(\"application/pdf\")));\n     }\n-    \n+\n     public boolean isFilePackage() {\n         return DataFileServiceBean.MIME_TYPE_PACKAGE_FILE.equalsIgnoreCase(contentType);\n     }\n \n     public void setIngestStatus(char ingestStatus) {\n-        this.ingestStatus = ingestStatus; \n-    }    \n-   \n+        this.ingestStatus = ingestStatus;\n+    }\n+\n     public boolean isIngestScheduled() {\n         return (ingestStatus == INGEST_STATUS_SCHEDULED);\n     }\n-    \n+\n     public boolean isIngestInProgress() {\n         return ((ingestStatus == INGEST_STATUS_SCHEDULED) || (ingestStatus == INGEST_STATUS_INPROGRESS));\n     }\n-    \n+\n     public boolean isIngestProblem() {\n         return (ingestStatus == INGEST_STATUS_ERROR);\n     }\n-    \n+\n     public void SetIngestScheduled() {\n         ingestStatus = INGEST_STATUS_SCHEDULED;\n     }\n-    \n+\n     public void SetIngestInProgress() {\n         ingestStatus = INGEST_STATUS_INPROGRESS;\n     }\n-    \n+\n     public void SetIngestProblem() {\n         ingestStatus = INGEST_STATUS_ERROR;\n     }\n-    \n+\n     public void setIngestDone() {\n         ingestStatus = INGEST_STATUS_NONE;\n     }\n-    \n+\n     public int getIngestStatus() {\n-        return ingestStatus; \n+        return ingestStatus;\n     }\n-    \n+\n     public Dataset getThumbnailForDataset() {\n         return thumbnailForDataset;\n     }\n-    \n+\n     public void setAsThumbnailForDataset(Dataset dataset) {\n         thumbnailForDataset = dataset;\n     }\n@@ -724,8 +718,9 @@ public class DataFile extends DvObject implements Comparable {\n     /*\n         8/10/2014 - Using the current \"open access\" url\n     */\n-    public String getMapItFileDownloadURL(String serverName){\n-        if ((this.getId() == null)||(serverName == null)){\n+\n+    public String getMapItFileDownloadURL(String serverName) {\n+        if ((this.getId() == null) || (serverName == null)) {\n             return null;\n         }\n         return serverName + \"/api/access/datafile/\" + this.getId();\n@@ -735,7 +730,7 @@ public class DataFile extends DvObject implements Comparable {\n      * If this is tabular data, the corresponding dataTable may have a UNF -\n      * \"numeric fingerprint\" signature - generated:\n      */\n-    \n+\n     public String getUnf() {\n         if (this.isTabularData()) {\n             // (isTabularData() method above verifies that that this file \n@@ -743,14 +738,13 @@ public class DataFile extends DvObject implements Comparable {\n             // safe, in terms of a NullPointerException: \n             return this.getDataTable().getUnf();\n         }\n-        return null; \n+        return null;\n     }\n-    \n \n     @ManyToMany\n     @JoinTable(name = \"fileaccessrequests\",\n-    joinColumns = @JoinColumn(name = \"datafile_id\"),\n-    inverseJoinColumns = @JoinColumn(name = \"authenticated_user_id\"))\n+               joinColumns = @JoinColumn(name = \"datafile_id\"),\n+               inverseJoinColumns = @JoinColumn(name = \"authenticated_user_id\"))\n     private List<AuthenticatedUser> fileAccessRequesters;\n \n     public List<AuthenticatedUser> getFileAccessRequesters() {\n@@ -760,39 +754,37 @@ public class DataFile extends DvObject implements Comparable {\n     public void setFileAccessRequesters(List<AuthenticatedUser> fileAccessRequesters) {\n         this.fileAccessRequesters = fileAccessRequesters;\n     }\n-    \n+\n     public boolean isHarvested() {\n-        \n         Dataset ownerDataset = this.getOwner();\n         if (ownerDataset != null) {\n-            return ownerDataset.isHarvested(); \n+            return ownerDataset.isHarvested();\n         }\n-        return false; \n+        return false;\n     }\n-    \n+\n     public String getRemoteArchiveURL() {\n         if (isHarvested()) {\n             Dataset ownerDataset = this.getOwner();\n             return ownerDataset.getRemoteArchiveURL();\n         }\n-        \n-        return null; \n+        return null;\n     }\n-    \n+\n     public String getHarvestingDescription() {\n         if (isHarvested()) {\n             Dataset ownerDataset = this.getOwner();\n             return ownerDataset.getHarvestingDescription();\n         }\n-        \n         return null;\n     }\n-    \n+\n     @Override\n     public boolean equals(Object object) {\n         if (!(object instanceof DataFile)) {\n             return false;\n         }\n+\n         DataFile other = (DataFile) object;\n         return Objects.equals(getId(), other.getId());\n     }\n@@ -805,28 +797,28 @@ public class DataFile extends DvObject implements Comparable {\n     @Override\n     protected String toStringExtras() {\n         FileMetadata fmd = getLatestFileMetadata();\n-        return \"label:\" + (fmd!=null? fmd.getLabel() : \"[no metadata]\");\n+        return \"label:\" + (fmd != null ? fmd.getLabel() : \"[no metadata]\");\n     }\n-\t\n-\t@Override\n-\tpublic <T> T accept( Visitor<T> v ) {\n-\t\treturn v.visit(this);\n-\t}\n-        \n+\n+    @Override\n+    public <T> T accept(Visitor<T> v) {\n+        return v.visit(this);\n+    }\n+\n     @Override\n     public String getDisplayName() {\n-       return getLatestFileMetadata().getLabel(); \n+        return getLatestFileMetadata().getLabel();\n     }\n-    \n+\n     public String getDirectoryLabel() {\n-       return getLatestFileMetadata().getDirectoryLabel();\n+        return getLatestFileMetadata().getDirectoryLabel();\n     }\n-    \n-    @Override \n-    public String getCurrentName(){\n+\n+    @Override\n+    public String getCurrentName() {\n         return getLatestFileMetadata().getLabel();\n     }\n-    \n+\n     @Override\n     public int compareTo(Object o) {\n         /*\n@@ -847,12 +839,14 @@ public class DataFile extends DvObject implements Comparable {\n      * Check if the Geospatial Tag has been assigned to this file\n      * @return \n      */\n-    public boolean hasGeospatialTag(){\n-        if (this.dataFileTags == null){\n+\n+    public boolean hasGeospatialTag() {\n+        if (this.dataFileTags == null) {\n             return false;\n         }\n-        for (DataFileTag tag : this.dataFileTags){\n-            if (tag.isGeospatialTag()){\n+\n+        for (DataFileTag tag : this.dataFileTags) {\n+            if (tag.isGeospatialTag()) {\n                 return true;\n             }\n         }\n@@ -864,7 +858,8 @@ public class DataFile extends DvObject implements Comparable {\n      *  Set rootDataFileId\n      *  @param rootDataFileId\n      */\n-    public void setRootDataFileId(Long rootDataFileId){\n+\n+    public void setRootDataFileId(Long rootDataFileId) {\n         this.rootDataFileId = rootDataFileId;\n     }\n \n@@ -872,7 +867,8 @@ public class DataFile extends DvObject implements Comparable {\n      *  Get for rootDataFileId\n      *  @return Long\n      */\n-    public Long getRootDataFileId(){\n+\n+    public Long getRootDataFileId() {\n         return this.rootDataFileId;\n     }\n \n@@ -883,11 +879,11 @@ public class DataFile extends DvObject implements Comparable {\n //    public void setProvCplId(int cplId) {\n //        this.provCplId = cplId;\n //    }\n-    \n+\n     public String getProvEntityName() {\n         return provEntityName;\n     }\n-    \n+\n     public void setProvEntityName(String name) {\n         this.provEntityName = name;\n     }\n@@ -896,7 +892,8 @@ public class DataFile extends DvObject implements Comparable {\n      *  Set previousDataFileId\n      *  @param previousDataFileId\n      */\n-    public void setPreviousDataFileId(Long previousDataFileId){\n+\n+    public void setPreviousDataFileId(Long previousDataFileId) {\n         this.previousDataFileId = previousDataFileId;\n     }\n \n@@ -904,33 +901,27 @@ public class DataFile extends DvObject implements Comparable {\n      *  Get for previousDataFileId\n      *  @return Long\n      */\n-    public Long getPreviousDataFileId(){\n+\n+    public Long getPreviousDataFileId() {\n         return this.previousDataFileId;\n     }\n \n-    public String toPrettyJSON(){\n-        \n+    public String toPrettyJSON() {\n         return serializeAsJSON(true);\n     }\n \n-    public String toJSON(){\n-        \n+    public String toJSON() {\n         return serializeAsJSON(false);\n     }\n-    \n-    \n-    \n-    public JsonObject asGsonObject(boolean prettyPrint){\n-        \n+\n+    public JsonObject asGsonObject(boolean prettyPrint) {\n         String overarchingKey = \"data\";\n-        \n         GsonBuilder builder;\n-        if (prettyPrint){  // Add pretty printing\n+        if (prettyPrint) {  // Add pretty printing\n             builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setPrettyPrinting();\n-        }else{\n-            builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation();                        \n+        } else {\n+            builder = new GsonBuilder().excludeFieldsWithoutExposeAnnotation();\n         }\n-        \n         builder.serializeNulls();   // correctly capture nulls\n         Gson gson = builder.create();\n \n@@ -948,7 +939,6 @@ public class DataFile extends DvObject implements Comparable {\n         // ----------------------------------\n         //  Add dataset info\n         // ----------------------------------\n-\n         Map<String, Object> datasetMap = new HashMap<>();\n         // expensive call.......bleh!!! \n         // https://github.com/IQSS/dataverse/issues/761, https://github.com/IQSS/dataverse/issues/2110, https://github.com/IQSS/dataverse/issues/3191\n@@ -959,30 +949,24 @@ public class DataFile extends DvObject implements Comparable {\n         datasetMap.put(\"version\", thisFileMetadata.getDatasetVersion().getSemanticVersion());\n         datasetMap.put(\"id\", getOwner().getId());\n         datasetMap.put(\"isPublished\", thisFileMetadata.getDatasetVersion().isReleased());\n-        \n-        jsonObj.getAsJsonObject().add(\"dataset\",  gson.toJsonTree(datasetMap));\n+        jsonObj.getAsJsonObject().add(\"dataset\", gson.toJsonTree(datasetMap));\n        \n         // ----------------------------------\n         //  Add dataverse info\n         // ----------------------------------\n         Map<String, Object> dataverseMap = new HashMap<>();\n         Dataverse dv = this.getOwner().getOwner();\n-        \n         dataverseMap.put(\"name\", dv.getName());\n         dataverseMap.put(\"alias\", dv.getAlias());\n-        dataverseMap.put(\"id\", dv.getId()); \n-\n-        jsonObj.getAsJsonObject().add(\"dataverse\",  gson.toJsonTree(dataverseMap));\n+        dataverseMap.put(\"id\", dv.getId());\n+        jsonObj.getAsJsonObject().add(\"dataverse\", gson.toJsonTree(dataverseMap));\n         \n         // ----------------------------------\n         //  Add label (filename), description, and categories from the FileMetadata object\n         // ----------------------------------\n-\n         jsonObj.getAsJsonObject().addProperty(\"filename\", thisFileMetadata.getLabel());\n         jsonObj.getAsJsonObject().addProperty(\"description\", thisFileMetadata.getDescription());\n-        jsonObj.getAsJsonObject().add(\"categories\", \n-                            gson.toJsonTree(thisFileMetadata.getCategoriesByName())\n-                    );\n+        jsonObj.getAsJsonObject().add(\"categories\", gson.toJsonTree(thisFileMetadata.getCategoriesByName()));\n \n         // ----------------------------------        \n         // Tags\n@@ -995,13 +979,9 @@ public class DataFile extends DvObject implements Comparable {\n         Map<String, String> checkSumMap = new HashMap<>();\n         checkSumMap.put(\"type\", getChecksumType().toString());\n         checkSumMap.put(\"value\", getChecksumValue());\n-        \n         JsonElement checkSumJSONMap = gson.toJsonTree(checkSumMap);\n-        \n         jsonObj.getAsJsonObject().add(\"checksum\", checkSumJSONMap);\n-        \n         return jsonObj.getAsJsonObject();\n-        \n     }\n     \n     /**\n@@ -1009,32 +989,26 @@ public class DataFile extends DvObject implements Comparable {\n      * @param prettyPrint\n      * @return \n      */\n-    private String serializeAsJSON(boolean prettyPrint){\n-        \n+\n+    private String serializeAsJSON(boolean prettyPrint) {\n         JsonObject fullFileJSON = asGsonObject(prettyPrint);\n               \n         //return fullFileJSON.\n         return fullFileJSON.toString();\n-        \n     }\n-    \n+\n     public String getPublicationDateFormattedYYYYMMDD() {\n-        if (getPublicationDate() != null){\n-                   return new SimpleDateFormat(\"yyyy-MM-dd\").format(getPublicationDate()); \n+        if (getPublicationDate() != null) {\n+            return new SimpleDateFormat(\"yyyy-MM-dd\").format(getPublicationDate());\n         }\n         return null;\n     }\n-    \n+\n     public String getCreateDateFormattedYYYYMMDD() {\n-        if (getCreateDate() != null){\n-                   return new SimpleDateFormat(\"yyyy-MM-dd\").format(getCreateDate()); \n+        if (getCreateDate() != null) {\n+            return new SimpleDateFormat(\"yyyy-MM-dd\").format(getCreateDate());\n         }\n         return null;\n     }\n-    \n-\n-} // end of class\n-    \n-\n-    \n \n+}\n\\ No newline at end of file\n",
            "diff_size": 250
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "59",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/23/DataFile.java\nindex 4cb2abfb12f..ad1b163b7f6 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/23/DataFile.java\n@@ -55,7 +55,7 @@ import org.hibernate.validator.constraints.NotBlank;\n  * @author gdurand\n  */\n @NamedQueries({\n-\t@NamedQuery( name=\"DataFile.removeFromDatasetVersion\",\n+@NamedQuery( name=\"DataFile.removeFromDatasetVersion\",\n \t\tquery=\"DELETE FROM FileMetadata f WHERE f.datasetVersion.id=:versionId and f.dataFile.id=:fileId\"),\n         @NamedQuery(name = \"DataFile.findByCreatorId\",\n                 query = \"SELECT o FROM DataFile o WHERE o.creator.id=:creatorId\"),\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "59",
                    "column": "1",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/23/DataFile.java\nindex 4cb2abfb12f..806b119f242 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/23/DataFile.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/23/DataFile.java\n@@ -55,7 +55,7 @@ import org.hibernate.validator.constraints.NotBlank;\n  * @author gdurand\n  */\n @NamedQueries({\n-\t@NamedQuery( name=\"DataFile.removeFromDatasetVersion\",\n+    @NamedQuery( name=\"DataFile.removeFromDatasetVersion\",\n \t\tquery=\"DELETE FROM FileMetadata f WHERE f.datasetVersion.id=:versionId and f.dataFile.id=:fileId\"),\n         @NamedQuery(name = \"DataFile.findByCreatorId\",\n                 query = \"SELECT o FROM DataFile o WHERE o.creator.id=:creatorId\"),\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}