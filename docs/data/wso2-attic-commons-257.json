{
    "project_name": "wso2-attic-commons",
    "error_id": "257",
    "information": {
        "errors": [
            {
                "line": "363",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 179).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "            iids.add(dao.getInstanceId());\n        }\n        Collection<CorrelationSetDAOImpl> csets = _em.createNamedQuery(CorrelationSetDAOImpl.SELECT_CORRELATION_SETS_BY_INSTANCES).setParameter(\"instances\", iids).getResultList();\n        Map<Long, Collection<CorrelationSetDAO>> map = new HashMap<Long, Collection<CorrelationSetDAO>>();\n        for (CorrelationSetDAOImpl cset: csets) {\n            Long id = cset.getScope().getProcessInstance().getInstanceId();",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/257/BPELDAOConnectionImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/257/BPELDAOConnectionImpl.java\nindex 96234eee547..0159077328a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/257/BPELDAOConnectionImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/257/BPELDAOConnectionImpl.java\n@@ -360,7 +360,8 @@ public class BPELDAOConnectionImpl implements BpelDAOConnection {\n         for (ProcessInstanceDAO dao: instances) {\n             iids.add(dao.getInstanceId());\n         }\n-        Collection<CorrelationSetDAOImpl> csets = _em.createNamedQuery(CorrelationSetDAOImpl.SELECT_CORRELATION_SETS_BY_INSTANCES).setParameter(\"instances\", iids).getResultList();\n+        Collection<CorrelationSetDAOImpl> csets = _em.createNamedQuery(CorrelationSetDAOImpl\n+                   .SELECT_CORRELATION_SETS_BY_INSTANCES).setParameter(\"instances\", iids).getResultList();\n         Map<Long, Collection<CorrelationSetDAO>> map = new HashMap<Long, Collection<CorrelationSetDAO>>();\n         for (CorrelationSetDAOImpl cset: csets) {\n             Long id = cset.getScope().getProcessInstance().getInstanceId();\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/257/BPELDAOConnectionImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/257/BPELDAOConnectionImpl.java\nindex 96234eee547..de4dd5c04d3 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/257/BPELDAOConnectionImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/257/BPELDAOConnectionImpl.java\n@@ -43,338 +43,359 @@ import java.util.*;\n  * @author Matthieu Riou <mriou at apache dot org>\n  */\n public class BPELDAOConnectionImpl implements BpelDAOConnection {\n-\tstatic final Log __log = LogFactory.getLog(BPELDAOConnectionImpl.class);\n-\n-\tprotected EntityManager _em;\n-\n-    public BPELDAOConnectionImpl(EntityManager em) {\n-        _em = em;\n+  static final Log __log = LogFactory.getLog(BPELDAOConnectionImpl.class);\n+\n+  protected EntityManager _em;\n+\n+  public BPELDAOConnectionImpl(EntityManager em) {\n+    _em = em;\n+  }\n+\n+  public List<BpelEvent> bpelEventQuery(InstanceFilter ifilter,\n+                                        BpelEventFilter efilter) {\n+    // TODO\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public List<Date> bpelEventTimelineQuery(InstanceFilter ifilter,\n+                                           BpelEventFilter efilter) {\n+    // TODO\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ProcessInstanceDAO getInstance(Long iid) {\n+    return _em.find(ProcessInstanceDAOImpl.class, iid);\n+  }\n+\n+  public void close() {\n+    _em = null;\n+  }\n+\n+  public MessageExchangeDAO createMessageExchange(String mexId, char dir) {\n+    MessageExchangeDAOImpl ret = new MessageExchangeDAOImpl(mexId, dir);\n+\n+    _em.persist(ret);\n+    return ret;\n+  }\n+\n+  public MessageDAO createMessage(QName type) {\n+    MessageDAOImpl ret = new MessageDAOImpl(type, null);\n+    _em.persist(ret);\n+    return ret;\n+  }\n+\n+  public void releaseMessageExchange(String mexid) {\n+    MessageExchangeDAO dao = getMessageExchange(mexid);\n+    dao.release(true);\n+  }\n+\n+  public ProcessDAO createProcess(QName pid, QName type, String guid, long version) {\n+    ProcessDAOImpl ret = new ProcessDAOImpl(pid, type, guid, version);\n+    _em.persist(ret);\n+    return ret;\n+  }\n+\n+  public ProcessDAO getProcess(QName processId) {\n+    List l = _em.createQuery(\"select x from ProcessDAOImpl x where x._processId = ?1\")\n+      .setParameter(1, processId.toString()).getResultList();\n+    if (l.size() == 0) {\n+      return null;\n     }\n-\n-    public List<BpelEvent> bpelEventQuery(InstanceFilter ifilter,\n-                                          BpelEventFilter efilter) {\n-        // TODO\n-        throw new UnsupportedOperationException();\n+    return (ProcessDAOImpl) l.get(0);\n+  }\n+\n+  public ScopeDAO getScope(Long siidl) {\n+    return _em.find(ScopeDAOImpl.class, siidl);\n+  }\n+\n+  public void insertBpelEvent(BpelEvent event, ProcessDAO process, ProcessInstanceDAO instance) {\n+    EventDAOImpl eventDao = new EventDAOImpl();\n+    eventDao.setTstamp(new Timestamp(System.currentTimeMillis()));\n+    eventDao.setType(BpelEvent.eventName(event));\n+    String evtStr = event.toString();\n+    eventDao.setDetail(evtStr.substring(0, Math.min(254, evtStr.length())));\n+    if (process != null) {\n+      eventDao.setProcess((ProcessDAOImpl) process);\n     }\n-\n-    public List<Date> bpelEventTimelineQuery(InstanceFilter ifilter,\n-                                             BpelEventFilter efilter) {\n-        // TODO\n-        throw new UnsupportedOperationException();\n+    if (instance != null) {\n+      eventDao.setInstance((ProcessInstanceDAOImpl) instance);\n     }\n-\n-\tpublic ProcessInstanceDAO getInstance(Long iid) {\n-        return _em.find(ProcessInstanceDAOImpl.class, iid);\n+    if (event instanceof ScopeEvent) {\n+      eventDao.setScopeId(((ScopeEvent) event).getScopeId());\n     }\n-\n-    public void close() {\n-        _em = null;\n+    eventDao.setEvent(event);\n+    _em.persist(eventDao);\n+  }\n+\n+  private static String dateFilter(String filter) {\n+    String date = Filter.getDateWithoutOp(filter);\n+    String op = filter.substring(0, filter.indexOf(date));\n+    Date dt;\n+    try {\n+      dt = ISO8601DateParser.parse(date);\n+    } catch (ParseException e) {\n+      __log.error(\"Error parsing date.\", e);\n+      return \"\";\n     }\n-\n-    public MessageExchangeDAO createMessageExchange(String mexId, char dir) {\n-        MessageExchangeDAOImpl ret = new MessageExchangeDAOImpl(mexId, dir);\n-\n-        _em.persist(ret);\n-        return ret;\n+    Timestamp ts = new Timestamp(dt.getTime());\n+    return op + \" '\" + ts.toString() + \"'\";\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public Collection<ProcessInstanceDAO> instanceQuery(InstanceFilter criteria) {\n+    StringBuffer query = new StringBuffer();\n+    query.append(\"select pi from ProcessInstanceDAOImpl as pi\");\n+    query.append(genSQL(criteria));\n+\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(query.toString());\n     }\n \n-    public MessageDAO createMessage(QName type) {\n-        MessageDAOImpl ret = new MessageDAOImpl(type, null);\n-        _em.persist(ret);\n-        return ret;  \n+    // criteria limit\n+    Query pq = _em.createQuery(query.toString());\n+    OpenJPAQuery kq = OpenJPAPersistence.cast(pq);\n+    kq.getFetchPlan().setFetchBatchSize(0);      // set to 0 inorder to use the default value by JDBC driver\n+    List<ProcessInstanceDAO> ql = kq.getResultList();\n+\n+    Collection<ProcessInstanceDAO> list = new ArrayList<ProcessInstanceDAO>();\n+    int num = 0;\n+    for (Object piDAO : ql) {\n+      if (num++ > criteria.getLimit()) {\n+        break;\n+      }\n+      ProcessInstanceDAO processInstanceDAO = (ProcessInstanceDAO) piDAO;\n+      list.add(processInstanceDAO);\n     }\n \n-    public void releaseMessageExchange(String mexid) {\n-        MessageExchangeDAO dao = getMessageExchange(mexid);\n-        dao.release(true);\n- \t}\n+    return list;\n+  }\n \n-    public ProcessDAO createProcess(QName pid, QName type, String guid, long version) {\n-        ProcessDAOImpl ret = new ProcessDAOImpl(pid,type,guid,version);\n-        _em.persist(ret);\n-        return ret;\n-    }\n-\n-    public ProcessDAO getProcess(QName processId) {\n-        List l = _em.createQuery(\"select x from ProcessDAOImpl x where x._processId = ?1\")\n-                .setParameter(1, processId.toString()).getResultList();\n-        if (l.size() == 0) return null;\n-        return (ProcessDAOImpl) l.get(0);\n-    }\n+  @SuppressWarnings(\"unchecked\")\n+  public int instanceQueryCount(InstanceFilter criteria) {\n+    StringBuffer query = new StringBuffer();\n+    query.append(\"select count(pi) from ProcessInstanceDAOImpl as pi\");\n+    query.append(genSQL(criteria));\n \n-    public ScopeDAO getScope(Long siidl) {\n-        return _em.find(ScopeDAOImpl.class, siidl);\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(query.toString());\n     }\n \n-    public void insertBpelEvent(BpelEvent event, ProcessDAO process, ProcessInstanceDAO instance) {\n-        EventDAOImpl eventDao = new EventDAOImpl();\n-        eventDao.setTstamp(new Timestamp(System.currentTimeMillis()));\n-        eventDao.setType(BpelEvent.eventName(event));\n-        String evtStr = event.toString();\n-        eventDao.setDetail(evtStr.substring(0, Math.min(254, evtStr.length())));\n-        if (process != null)\n-            eventDao.setProcess((ProcessDAOImpl) process);\n-        if (instance != null)\n-            eventDao.setInstance((ProcessInstanceDAOImpl) instance);\n-        if (event instanceof ScopeEvent)\n-            eventDao.setScopeId(((ScopeEvent) event).getScopeId());\n-        eventDao.setEvent(event);\n-        _em.persist(eventDao);\n-\t}\n-\n-    private static String dateFilter(String filter) {\n-        String date = Filter.getDateWithoutOp(filter);\n-        String op = filter.substring(0,filter.indexOf(date));\n-        Date dt;\n-        try {\n-            dt = ISO8601DateParser.parse(date);\n-        } catch (ParseException e) {\n-            __log.error(\"Error parsing date.\", e);\n-            return \"\";\n+    // criteria limit\n+    Query pq = _em.createQuery(query.toString());\n+    OpenJPAQuery kq = OpenJPAPersistence.cast(pq);\n+    kq.getFetchPlan().setFetchBatchSize(50);     // set to 0 inorder to use the default value by JDBC driver\n+    Number count = (Number) kq.getSingleResult();\n+    return count.intValue();\n+  }\n+\n+  private String genSQL(InstanceFilter criteria) {\n+    StringBuffer query = new StringBuffer();\n+\n+    if (criteria != null) {\n+      // Building each clause\n+      ArrayList<String> clauses = new ArrayList<String>();\n+\n+      // iid filter\n+      if (criteria.getIidFilter() != null) {\n+        StringBuffer filters = new StringBuffer();\n+        List<String> iids = criteria.getIidFilter();\n+        for (int m = 0; m < iids.size(); m++) {\n+          filters.append(\" pi._instanceId = \").append(iids.get(m));\n+          if (m < iids.size() - 1) {\n+            filters.append(\" or\");\n+          }\n         }\n-        Timestamp ts = new Timestamp(dt.getTime());\n-        return op + \" '\" + ts.toString() + \"'\";\n-    }\n-\n-\t@SuppressWarnings(\"unchecked\")\n-    public Collection<ProcessInstanceDAO> instanceQuery(InstanceFilter criteria) {\n-        StringBuffer query = new StringBuffer();\n-        query.append(\"select pi from ProcessInstanceDAOImpl as pi\");\n-        query.append(genSQL(criteria));\n-\n-        if (__log.isDebugEnabled()) {\n-        \t__log.debug(query.toString());\n+        clauses.add(\" (\" + filters + \")\");\n+      }\n+\n+      // pid filter\n+      if (criteria.getPidFilter() != null) {\n+        StringBuffer filters = new StringBuffer();\n+        List<String> pids = criteria.getPidFilter();\n+        for (int m = 0; m < pids.size(); m++) {\n+          filters.append(\" pi._process._processId = '\").append(pids.get(m)).append(\"'\");\n+          if (m < pids.size() - 1) {\n+            filters.append(\" or\");\n+          }\n         }\n-\n-        // criteria limit\n-        Query pq = _em.createQuery(query.toString());\n-        OpenJPAQuery kq = OpenJPAPersistence.cast(pq);\n-        kq.getFetchPlan().setFetchBatchSize(0);      // set to 0 inorder to use the default value by JDBC driver\n-        List<ProcessInstanceDAO> ql = kq.getResultList();\n-\n-        Collection<ProcessInstanceDAO> list = new ArrayList<ProcessInstanceDAO>();\n-        int num = 0;\n-        for (Object piDAO : ql) {\n-            if (num++ > criteria.getLimit()) break;\n-            ProcessInstanceDAO processInstanceDAO = (ProcessInstanceDAO) piDAO;\n-            list.add(processInstanceDAO);\n+        clauses.add(\" (\" + filters + \")\");\n+      }\n+\n+      // name filter\n+      if (criteria.getNameFilter() != null) {\n+        String val = criteria.getNameFilter().replace(\"%\", \"\\\\%\");\n+        //name filter is updated to use \"*\" wildcard inside the name as well\n+        if (val.endsWith(\"*\")) {\n+          val = (val.substring(0, val.length() - 1).equals(\"*\") ? \"\" : val.substring(0, val.length() - 1)) + \"%\";\n         }\n+        //process type string begins with name space\n+        clauses.add(\" pi._process._processType like '%}\" + val.replace(\"*\", \"%\") + \"' ESCAPE '\\\\'\");\n+      }\n+\n+      // name space filter\n+      if (criteria.getNamespaceFilter() != null) {\n+        String val = criteria.getNamespaceFilter().replace(\"%\", \"\\\\%\");\n+        //name filter is updated to use \"*\" wildcard inside the name as well\n+        if (val.endsWith(\"*\")) {\n+          val = (val.substring(0, val.length() - 1).equals(\"*\") ? \"\" : val.substring(0, val.length() - 1)) + \"%\";\n+        }\n+        //process type string begins with name space\n+        //Since we only search among {} only name space part is searched.\n+        //namespace filter is updated to use \"*\" wildcard inside the namespace as well\n+        clauses.add(\" pi._process._processType like '{\" + val.replace(\"*\", \"%\") + \"}%' ESCAPE '\\\\'\");\n+      }\n+\n+      // version filter\n+      if (criteria.getVersionFilter() > 0) {\n+        clauses.add(\" pi._process._version=\" + criteria.getVersionFilter());\n+      }\n+\n+      // started filter\n+      if (criteria.getStartedDateFilter() != null) {\n+        for (String ds : criteria.getStartedDateFilter()) {\n+          clauses.add(\" pi._dateCreated \" + dateFilter(ds));\n+        }\n+      }\n \n-        return list;\n-\t}\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public int instanceQueryCount(InstanceFilter criteria) {\n-        StringBuffer query = new StringBuffer();\n-        query.append(\"select count(pi) from ProcessInstanceDAOImpl as pi\");\n-        query.append(genSQL(criteria));\n-\n-        if (__log.isDebugEnabled()) {\n-        \t__log.debug(query.toString());\n+      // last-active filter\n+      if (criteria.getLastActiveDateFilter() != null) {\n+        for (String ds : criteria.getLastActiveDateFilter()) {\n+          clauses.add(\" pi._lastActive \" + dateFilter(ds));\n+        }\n+      }\n+\n+      // status filter\n+      if (criteria.getStatusFilter() != null) {\n+        StringBuffer filters = new StringBuffer();\n+        List<Short> states = criteria.convertFilterState();\n+        for (int m = 0; m < states.size(); m++) {\n+          filters.append(\" pi._state = \").append(states.get(m));\n+          if (m < states.size() - 1) {\n+            filters.append(\" or\");\n+          }\n+        }\n+        clauses.add(\" (\" + filters.toString() + \")\");\n+      }\n+\n+      // $property filter\n+      if (criteria.getPropertyValuesFilter() != null) {\n+        Map<String, String> props = criteria.getPropertyValuesFilter();\n+        // join to correlation sets\n+        query.append(\" inner join pi._rootScope._correlationSets as cs\");\n+        int i = 0;\n+        for (String propKey : props.keySet()) {\n+          i++;\n+          // join to props for each prop\n+          query.append(\" inner join cs._props as csp\" + i);\n+          // add clause for prop key and value\n+          clauses.add(\" csp\" + i + \".propertyKey = '\" + propKey +\n+            \"' and csp\" + i + \".propertyValue = '\" +\n+            // spaces have to be escaped, might be better handled in InstanceFilter\n+            props.get(propKey).replaceAll(\"&#32;\", \" \") + \"'\");\n+        }\n+      }\n+\n+      // order by\n+      StringBuffer orderby = new StringBuffer(\"\");\n+      if (criteria.getOrders() != null) {\n+        orderby.append(\" order by\");\n+        List<String> orders = criteria.getOrders();\n+        for (int m = 0; m < orders.size(); m++) {\n+          String field = orders.get(m);\n+          String ord = \" asc\";\n+          if (field.startsWith(\"-\")) {\n+            ord = \" desc\";\n+          }\n+          String fieldName = \" pi._instanceId\";\n+          if (field.endsWith(\"name\") || field.endsWith(\"namespace\")) {\n+            fieldName = \" pi._process._processType\";\n+          }\n+          if (field.endsWith(\"version\")) {\n+            fieldName = \" pi._process._version\";\n+          }\n+          if (field.endsWith(\"status\")) {\n+            fieldName = \" pi._state\";\n+          }\n+          if (field.endsWith(\"started\")) {\n+            fieldName = \" pi._dateCreated\";\n+          }\n+          if (field.endsWith(\"last-active\")) {\n+            fieldName = \" pi._lastActive\";\n+          }\n+          orderby.append(fieldName + ord);\n+          if (m < orders.size() - 1) {\n+            orderby.append(\", \");\n+          }\n         }\n \n-        // criteria limit\n-        Query pq = _em.createQuery(query.toString());\n-        OpenJPAQuery kq = OpenJPAPersistence.cast(pq);\n-        kq.getFetchPlan().setFetchBatchSize(50);     // set to 0 inorder to use the default value by JDBC driver\n-        Number count = (Number)kq.getSingleResult();\n-        return count.intValue();\n-\t}\n-\n-    private String genSQL(InstanceFilter criteria) {\n-        StringBuffer query = new StringBuffer();\n-\n-        if (criteria != null) {\n-            // Building each clause\n-            ArrayList<String> clauses = new ArrayList<String>();\n-\n-            // iid filter\n-            if ( criteria.getIidFilter() != null ) {\n-                StringBuffer filters = new StringBuffer();\n-                List<String> iids = criteria.getIidFilter();\n-                for (int m = 0; m < iids.size(); m++) {\n-                    filters.append(\" pi._instanceId = \").append(iids.get(m));\n-                    if (m < iids.size() - 1) filters.append(\" or\");\n-                }\n-                clauses.add(\" (\" + filters + \")\");\n-            }\n-\n-            // pid filter\n-            if (criteria.getPidFilter() != null) {\n-                StringBuffer filters = new StringBuffer();\n-                List<String> pids = criteria.getPidFilter();\n-                for (int m = 0; m < pids.size(); m++) {\n-                    filters.append(\" pi._process._processId = '\").append(pids.get(m)).append(\"'\");\n-                    if (m < pids.size() - 1) filters.append(\" or\");\n-                }\n-                clauses.add(\" (\" + filters + \")\");\n-            }\n-\n-            // name filter\n-            if (criteria.getNameFilter() != null) {                                   \n-                String val = criteria.getNameFilter().replace(\"%\", \"\\\\%\");\n-\t\t        //name filter is updated to use \"*\" wildcard inside the name as well\n-                if (val.endsWith(\"*\")) {\n-                    val = (val.substring(0, val.length()-1).equals(\"*\") ? \"\" : val.substring(0, val.length()-1)) + \"%\";\n-                }\n-                //process type string begins with name space\n-                clauses.add(\" pi._process._processType like '%}\" + val.replace(\"*\", \"%\") + \"' ESCAPE '\\\\'\");\n-            }\n-\n-            // name space filter\n-            if (criteria.getNamespaceFilter() != null) {\n-                String val = criteria.getNamespaceFilter().replace(\"%\", \"\\\\%\");\n-\t\t        //name filter is updated to use \"*\" wildcard inside the name as well\n-                if (val.endsWith(\"*\")) {\n-                    val = (val.substring(0, val.length()-1).equals(\"*\") ? \"\" : val.substring(0, val.length()-1)) + \"%\";\n-                }\n-                //process type string begins with name space\n-                //Since we only search among {} only name space part is searched.\n-\t\t        //namespace filter is updated to use \"*\" wildcard inside the namespace as well\n-                clauses.add(\" pi._process._processType like '{\" + val.replace(\"*\", \"%\") + \"}%' ESCAPE '\\\\'\");\n-            }\n-\n-            // version filter\n-            if (criteria.getVersionFilter() > 0) {\n-                clauses.add(\" pi._process._version=\" + criteria.getVersionFilter());\n-            }\n-\n-            // started filter\n-            if (criteria.getStartedDateFilter() != null) {\n-                for ( String ds : criteria.getStartedDateFilter() ) {\n-                    clauses.add(\" pi._dateCreated \" + dateFilter(ds));\n-                }\n-            }\n-\n-            // last-active filter\n-            if (criteria.getLastActiveDateFilter() != null) {\n-                for ( String ds : criteria.getLastActiveDateFilter() ) {\n-                    clauses.add(\" pi._lastActive \" + dateFilter(ds));\n-                }\n-            }\n-\n-            // status filter\n-            if (criteria.getStatusFilter() != null) {\n-                StringBuffer filters = new StringBuffer();\n-                List<Short> states = criteria.convertFilterState();\n-                for (int m = 0; m < states.size(); m++) {\n-                    filters.append(\" pi._state = \").append(states.get(m));\n-                    if (m < states.size() - 1) filters.append(\" or\");\n-                }\n-                clauses.add(\" (\" + filters.toString() + \")\");\n-            }\n-\n-            // $property filter\n-            if (criteria.getPropertyValuesFilter() != null) {\n-                Map<String,String> props = criteria.getPropertyValuesFilter();\n-                // join to correlation sets\n-                query.append(\" inner join pi._rootScope._correlationSets as cs\");\n-                int i = 0;\n-                for (String propKey : props.keySet()) {\n-                    i++;\n-                    // join to props for each prop\n-                    query.append(\" inner join cs._props as csp\"+i);\n-                    // add clause for prop key and value\n-                    clauses.add(\" csp\"+i+\".propertyKey = '\"+propKey+\n-                            \"' and csp\"+i+\".propertyValue = '\"+\n-                            // spaces have to be escaped, might be better handled in InstanceFilter\n-                            props.get(propKey).replaceAll(\"&#32;\", \" \")+\"'\");\n-                }\n-            }\n-\n-            // order by\n-            StringBuffer orderby = new StringBuffer(\"\");\n-            if (criteria.getOrders() != null) {\n-                orderby.append(\" order by\");\n-                List<String> orders = criteria.getOrders();\n-                for (int m = 0; m < orders.size(); m++) {\n-                    String field = orders.get(m);\n-                    String ord = \" asc\";\n-                    if (field.startsWith(\"-\")) {\n-                        ord = \" desc\";\n-                    }\n-                    String fieldName = \" pi._instanceId\";\n-                    if ( field.endsWith(\"name\") || field.endsWith(\"namespace\")) {\n-                        fieldName = \" pi._process._processType\";\n-                    }\n-                    if ( field.endsWith(\"version\")) {\n-                        fieldName = \" pi._process._version\";\n-                    }\n-                    if ( field.endsWith(\"status\")) {\n-                        fieldName = \" pi._state\";\n-                    }\n-                    if ( field.endsWith(\"started\")) {\n-                        fieldName = \" pi._dateCreated\";\n-                    }\n-                    if ( field.endsWith(\"last-active\")) {\n-                        fieldName = \" pi._lastActive\";\n-                    }\n-                    orderby.append(fieldName + ord);\n-                    if (m < orders.size() - 1) orderby.append(\", \");\n-                }\n-\n-            }\n-\n-            // Preparing the statement\n-            if (clauses.size() > 0) {\n-                query.append(\" where\");\n-                for (int m = 0; m < clauses.size(); m++) {\n-                    query.append(clauses.get(m));\n-                    if (m < clauses.size() - 1) query.append(\" and\");\n-                }\n-            }\n-\n-            query.append(orderby);\n+      }\n+\n+      // Preparing the statement\n+      if (clauses.size() > 0) {\n+        query.append(\" where\");\n+        for (int m = 0; m < clauses.size(); m++) {\n+          query.append(clauses.get(m));\n+          if (m < clauses.size() - 1) {\n+            query.append(\" and\");\n+          }\n         }\n+      }\n \n-        return query.toString();\n+      query.append(orderby);\n     }\n \n+    return query.toString();\n+  }\n \n-\tpublic Collection<ProcessInstanceDAO> instanceQuery(String expression) {\n-\t    return instanceQuery(new InstanceFilter(expression));\n-\t}\n \n-\tpublic void setEntityManger(EntityManager em) {\n-\t\t_em = em;\n-\t}\n+  public Collection<ProcessInstanceDAO> instanceQuery(String expression) {\n+    return instanceQuery(new InstanceFilter(expression));\n+  }\n \n-    public MessageExchangeDAO getMessageExchange(String mexid) {\n-        List l = _em.createQuery(\"select x from MessageExchangeDAOImpl x where x._id = ?1\")\n-        .setParameter(1, mexid).getResultList();\n-        if (l.size() == 0) return null;\n+  public void setEntityManger(EntityManager em) {\n+    _em = em;\n+  }\n \n-        return (MessageExchangeDAOImpl) l.get(0);\n+  public MessageExchangeDAO getMessageExchange(String mexid) {\n+    List l = _em.createQuery(\"select x from MessageExchangeDAOImpl x where x._id = ?1\")\n+      .setParameter(1, mexid).getResultList();\n+    if (l.size() == 0) {\n+      return null;\n     }\n \n-    public EntityManager getEntityManager() {\n-        return _em;\n-    }\n+    return (MessageExchangeDAOImpl) l.get(0);\n+  }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public Map<Long, Collection<CorrelationSetDAO>> getCorrelationSets(Collection<ProcessInstanceDAO> instances) {\n-        if (instances.size() == 0) {\n-            return new HashMap<Long, Collection<CorrelationSetDAO>>();\n-        }\n-        ArrayList<Long> iids = new ArrayList<Long>(instances.size());\n-        for (ProcessInstanceDAO dao: instances) {\n-            iids.add(dao.getInstanceId());\n-        }\n-        Collection<CorrelationSetDAOImpl> csets = _em.createNamedQuery(CorrelationSetDAOImpl.SELECT_CORRELATION_SETS_BY_INSTANCES).setParameter(\"instances\", iids).getResultList();\n-        Map<Long, Collection<CorrelationSetDAO>> map = new HashMap<Long, Collection<CorrelationSetDAO>>();\n-        for (CorrelationSetDAOImpl cset: csets) {\n-            Long id = cset.getScope().getProcessInstance().getInstanceId();\n-            Collection<CorrelationSetDAO> existing = map.get(id);\n-            if (existing == null) {\n-                existing = new ArrayList<CorrelationSetDAO>();\n-                map.put(id, existing);\n-            }\n-            existing.add(cset);\n-        }\n-        return map;\n-    }\n+  public EntityManager getEntityManager() {\n+    return _em;\n+  }\n \n-    public ProcessManagementDAO getProcessManagement() {\n-        return new ProcessManagementDAOImpl(_em);\n+  @SuppressWarnings(\"unchecked\")\n+  public Map<Long, Collection<CorrelationSetDAO>> getCorrelationSets(Collection<ProcessInstanceDAO> instances) {\n+    if (instances.size() == 0) {\n+      return new HashMap<Long, Collection<CorrelationSetDAO>>();\n     }\n+    ArrayList<Long> iids = new ArrayList<Long>(instances.size());\n+    for (ProcessInstanceDAO dao : instances) {\n+      iids.add(dao.getInstanceId());\n+    }\n+    Collection<CorrelationSetDAOImpl> csets =\n+      _em.createNamedQuery(CorrelationSetDAOImpl.SELECT_CORRELATION_SETS_BY_INSTANCES).setParameter(\"instances\", iids)\n+        .getResultList();\n+    Map<Long, Collection<CorrelationSetDAO>> map = new HashMap<Long, Collection<CorrelationSetDAO>>();\n+    for (CorrelationSetDAOImpl cset : csets) {\n+      Long id = cset.getScope().getProcessInstance().getInstanceId();\n+      Collection<CorrelationSetDAO> existing = map.get(id);\n+      if (existing == null) {\n+        existing = new ArrayList<CorrelationSetDAO>();\n+        map.put(id, existing);\n+      }\n+      existing.add(cset);\n+    }\n+    return map;\n+  }\n+\n+  public ProcessManagementDAO getProcessManagement() {\n+    return new ProcessManagementDAOImpl(_em);\n+  }\n }\n",
            "diff_size": 507
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "363",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 179).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/257/BPELDAOConnectionImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/257/BPELDAOConnectionImpl.java\nindex 96234eee547..0159077328a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/257/BPELDAOConnectionImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/257/BPELDAOConnectionImpl.java\n@@ -360,7 +360,8 @@ public class BPELDAOConnectionImpl implements BpelDAOConnection {\n         for (ProcessInstanceDAO dao: instances) {\n             iids.add(dao.getInstanceId());\n         }\n-        Collection<CorrelationSetDAOImpl> csets = _em.createNamedQuery(CorrelationSetDAOImpl.SELECT_CORRELATION_SETS_BY_INSTANCES).setParameter(\"instances\", iids).getResultList();\n+        Collection<CorrelationSetDAOImpl> csets = _em.createNamedQuery(CorrelationSetDAOImpl\n+                   .SELECT_CORRELATION_SETS_BY_INSTANCES).setParameter(\"instances\", iids).getResultList();\n         Map<Long, Collection<CorrelationSetDAO>> map = new HashMap<Long, Collection<CorrelationSetDAO>>();\n         for (CorrelationSetDAOImpl cset: csets) {\n             Long id = cset.getScope().getProcessInstance().getInstanceId();\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}