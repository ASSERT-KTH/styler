{
    "project_name": "vostok-hercules",
    "error_id": "81",
    "information": {
        "errors": [
            {
                "line": "264",
                "column": "44",
                "severity": "warning",
                "message": "'{' is not preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "                return;\n            } catch (HttpProtocolException | UnavailableHostException e) {\n                if (!whiteList.remove(url)){\n                    continue;\n                }\n                if (!greyList.offer(new GreyListTopologyElement(url))) {",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/81/GateClient.java\nindex e78b02e1fdc..021f8b26d3a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/81/GateClient.java\n@@ -261,7 +261,7 @@ public class GateClient implements Closeable {\n                 sender.send(url);\n                 return;\n             } catch (HttpProtocolException | UnavailableHostException e) {\n-                if (!whiteList.remove(url)){\n+                if (!whiteList.remove(url)) {\n                     continue;\n                 }\n                 if (!greyList.offer(new GreyListTopologyElement(url))) {\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/81/GateClient.java\nindex e78b02e1fdc..d0285874c6c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/81/GateClient.java\n@@ -39,355 +39,357 @@ import java.util.concurrent.TimeUnit;\n  * @author Daniil Zhenikhov\n  */\n public class GateClient implements Closeable {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(GateClient.class);\n-    private static final Random RANDOM = new Random();\n-\n-    private static final String PING = \"/ping\";\n-    private static final String SEND_ACK = \"/stream/send\";\n-    private static final String SEND_ASYNC = \"/stream/sendAsync\";\n-\n-    private final CloseableHttpClient client;\n-\n-    private final BlockingQueue<GreyListTopologyElement> greyList;\n-    private final Topology<String> whiteList;\n-    private final int greyListElementsRecoveryTimeMs;\n-    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n-\n-    public GateClient(Properties properties, CloseableHttpClient client, Topology<String> whiteList) {\n-\n-        this.greyListElementsRecoveryTimeMs = Props.GREY_LIST_ELEMENTS_RECOVERY_TIME_MS.extract(properties);\n-        this.client = client;\n-        this.whiteList = whiteList;\n-        this.greyList = new ArrayBlockingQueue<>(whiteList.size());\n-\n-        scheduler.scheduleWithFixedDelay(this::updateTopology,\n-                greyListElementsRecoveryTimeMs,\n-                greyListElementsRecoveryTimeMs,\n-                TimeUnit.MILLISECONDS);\n-\n-    }\n-\n-    public GateClient(Properties properties, Topology<String> whiteList) {\n-        final int requestTimeout = Props.REQUEST_TIMEOUT.extract(properties);\n-        final int connectionTimeout = Props.CONNECTION_TIMEOUT.extract(properties);\n-        final int connectionCount = Props.CONNECTION_COUNT.extract(properties);\n-\n-        this.greyListElementsRecoveryTimeMs = Props.GREY_LIST_ELEMENTS_RECOVERY_TIME_MS.extract(properties);\n-        this.whiteList = whiteList;\n-        this.greyList = new ArrayBlockingQueue<>(whiteList.size());\n-\n-        this.client = createHttpClient(requestTimeout, connectionTimeout, connectionCount);\n-\n-        scheduler.scheduleWithFixedDelay(this::updateTopology,\n-                greyListElementsRecoveryTimeMs,\n-                greyListElementsRecoveryTimeMs,\n-                TimeUnit.MILLISECONDS);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GateClient.class);\n+  private static final Random RANDOM = new Random();\n+\n+  private static final String PING = \"/ping\";\n+  private static final String SEND_ACK = \"/stream/send\";\n+  private static final String SEND_ASYNC = \"/stream/sendAsync\";\n+\n+  private final CloseableHttpClient client;\n+\n+  private final BlockingQueue<GreyListTopologyElement> greyList;\n+  private final Topology<String> whiteList;\n+  private final int greyListElementsRecoveryTimeMs;\n+  private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n+\n+  public GateClient(Properties properties, CloseableHttpClient client, Topology<String> whiteList) {\n+\n+    this.greyListElementsRecoveryTimeMs = Props.GREY_LIST_ELEMENTS_RECOVERY_TIME_MS.extract(properties);\n+    this.client = client;\n+    this.whiteList = whiteList;\n+    this.greyList = new ArrayBlockingQueue<>(whiteList.size());\n+\n+    scheduler.scheduleWithFixedDelay(this::updateTopology,\n+      greyListElementsRecoveryTimeMs,\n+      greyListElementsRecoveryTimeMs,\n+      TimeUnit.MILLISECONDS);\n+\n+  }\n+\n+  public GateClient(Properties properties, Topology<String> whiteList) {\n+    final int requestTimeout = Props.REQUEST_TIMEOUT.extract(properties);\n+    final int connectionTimeout = Props.CONNECTION_TIMEOUT.extract(properties);\n+    final int connectionCount = Props.CONNECTION_COUNT.extract(properties);\n+\n+    this.greyListElementsRecoveryTimeMs = Props.GREY_LIST_ELEMENTS_RECOVERY_TIME_MS.extract(properties);\n+    this.whiteList = whiteList;\n+    this.greyList = new ArrayBlockingQueue<>(whiteList.size());\n+\n+    this.client = createHttpClient(requestTimeout, connectionTimeout, connectionCount);\n+\n+    scheduler.scheduleWithFixedDelay(this::updateTopology,\n+      greyListElementsRecoveryTimeMs,\n+      greyListElementsRecoveryTimeMs,\n+      TimeUnit.MILLISECONDS);\n+  }\n+\n+  /**\n+   * Request to {@value #PING}\n+   *\n+   * @param url Gate Url\n+   * @throws BadRequestException      throws if was error on client side: 4xx errors or http protocol errors\n+   * @throws UnavailableHostException throws if was error on server side: 5xx errors or connection errors\n+   */\n+  public void ping(String url) throws BadRequestException, UnavailableHostException, HttpProtocolException {\n+    sendToHost(url, urlParam -> {\n+      HttpGet httpGet = new HttpGet(urlParam + PING);\n+      return sendRequest(httpGet);\n+    });\n+  }\n+\n+  /**\n+   * Request to {@value #SEND_ASYNC}\n+   *\n+   * @param url    Gate url\n+   * @param apiKey key for sending\n+   * @param stream topic name in kafka\n+   * @param data   payload\n+   * @throws BadRequestException      throws if was error on client side: 4xx errors or http protocol errors\n+   * @throws UnavailableHostException throws if was error on server side: 5xx errors or connection errors\n+   */\n+  public void sendAsync(String url, String apiKey, String stream, final byte[] data)\n+    throws BadRequestException, UnavailableHostException, HttpProtocolException {\n+    sendToHost(url, urlParam -> {\n+      HttpPost httpPost = buildRequest(url, apiKey, SEND_ASYNC, stream, data);\n+      return sendRequest(httpPost);\n+    });\n+  }\n+\n+  /**\n+   * Request to {@value #SEND_ACK}\n+   *\n+   * @param url    Gate url\n+   * @param apiKey key for sending\n+   * @param stream topic name in kafka\n+   * @param data   payload\n+   * @throws BadRequestException      throws if was error on client side: 4xx errors or http protocol errors\n+   * @throws UnavailableHostException throws if was error on server side: 5xx errors or connection errors\n+   */\n+  public void send(String url, String apiKey, String stream, final byte[] data)\n+    throws BadRequestException, UnavailableHostException, HttpProtocolException {\n+    sendToHost(url, urlParam -> {\n+      HttpPost httpPost = buildRequest(url, apiKey, SEND_ACK, stream, data);\n+      return sendRequest(httpPost);\n+    });\n+  }\n+\n+  /**\n+   * Request to {@value #PING}\n+   *\n+   * @param retryLimit count of attempt to send data to one of the <code>urls</code>' hosts\n+   * @throws BadRequestException         throws if was error on client side: 4xx errors or http protocol errors\n+   * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n+   */\n+  public void ping(int retryLimit)\n+    throws BadRequestException, UnavailableClusterException {\n+    sendToPool(retryLimit, this::ping);\n+  }\n+\n+  /**\n+   * Request to {@value #SEND_ASYNC}\n+   *\n+   * @param retryLimit count of attempt to send data to one of the <code>urls</code>' hosts\n+   * @param apiKey     key for sending\n+   * @param stream     topic name in kafka\n+   * @param data       payload\n+   * @throws BadRequestException         throws if was error on client side: 4xx errors or http protocol errors\n+   * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n+   */\n+  public void sendAsync(int retryLimit, String apiKey, String stream, final byte[] data)\n+    throws BadRequestException, UnavailableClusterException {\n+    sendToPool(retryLimit, url -> sendAsync(url, apiKey, stream, data));\n+  }\n+\n+  /**\n+   * Request to {@value #SEND_ACK}\n+   *\n+   * @param retryLimit count of attempt to send data to one of the <code>urls</code>' hosts\n+   * @param apiKey     key for sending\n+   * @param stream     topic name in kafka\n+   * @param data       payload\n+   * @throws BadRequestException         throws if was error on client side: 4xx errors or http protocol errors\n+   * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n+   */\n+  public void send(int retryLimit, String apiKey, String stream, final byte[] data)\n+    throws BadRequestException, UnavailableClusterException {\n+    sendToPool(retryLimit, url -> send(url, apiKey, stream, data));\n+  }\n+\n+  /**\n+   * Request to {@value #PING}. Count of retry is <code>whitelist.size() + 1</code>\n+   *\n+   * @throws BadRequestException         throws if was error on client side: 4xx errors or http protocol errors\n+   * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n+   */\n+  public void ping()\n+    throws BadRequestException, UnavailableClusterException {\n+    ping(whiteList.size() + 1);\n+  }\n+\n+  /**\n+   * Request to {@value #SEND_ASYNC}. Count of retry is <code>whitelist.size() + 1</code>\n+   *\n+   * @param apiKey key for sending\n+   * @param stream topic name in kafka\n+   * @param data   payload\n+   * @throws BadRequestException         throws if was error on client side: 4xx errors or http protocol errors\n+   * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n+   */\n+  public void sendAsync(String apiKey, String stream, final byte[] data)\n+    throws BadRequestException, UnavailableClusterException {\n+    sendAsync(whiteList.size() + 1, apiKey, stream, data);\n+  }\n+\n+  /**\n+   * Request to {@value #SEND_ACK}. Count of retry is <code>whitelist.size() + 1</code>\n+   *\n+   * @param apiKey key for sending\n+   * @param stream topic name in kafka\n+   * @param data   payload\n+   * @throws BadRequestException         throws if was error on client side: 4xx errors or http protocol errors\n+   * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n+   */\n+  public void send(String apiKey, String stream, final byte[] data)\n+    throws BadRequestException, UnavailableClusterException {\n+    send(whiteList.size() + 1, apiKey, stream, data);\n+  }\n+\n+  public void close() {\n+    try {\n+      client.close();\n+    } catch (IOException e) {\n+      LOGGER.error(\"Error while closing http client: \" + e.getLocalizedMessage());\n     }\n-\n-    /**\n-     * Request to {@value #PING}\n-     *\n-     * @param url Gate Url\n-     * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n-     * @throws UnavailableHostException throws if was error on server side: 5xx errors or connection errors\n-     */\n-    public void ping(String url) throws BadRequestException, UnavailableHostException, HttpProtocolException {\n-        sendToHost(url, urlParam -> {\n-            HttpGet httpGet = new HttpGet(urlParam + PING);\n-            return sendRequest(httpGet);\n-        });\n-    }\n-\n-    /**\n-     * Request to {@value #SEND_ASYNC}\n-     *\n-     * @param url Gate url\n-     * @param apiKey key for sending\n-     * @param stream topic name in kafka\n-     * @param data payload\n-     * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n-     * @throws UnavailableHostException throws if was error on server side: 5xx errors or connection errors\n-     */\n-    public void sendAsync(String url, String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableHostException, HttpProtocolException {\n-        sendToHost(url, urlParam -> {\n-            HttpPost httpPost = buildRequest(url, apiKey, SEND_ASYNC, stream, data);\n-            return sendRequest(httpPost);\n-        });\n-    }\n-\n-    /**\n-     * Request to {@value #SEND_ACK}\n-     *\n-     * @param url Gate url\n-     * @param apiKey key for sending\n-     * @param stream topic name in kafka\n-     * @param data payload\n-     * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n-     * @throws UnavailableHostException throws if was error on server side: 5xx errors or connection errors\n-     */\n-    public void send(String url, String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableHostException, HttpProtocolException {\n-        sendToHost(url, urlParam -> {\n-            HttpPost httpPost = buildRequest(url, apiKey, SEND_ACK, stream, data);\n-            return sendRequest(httpPost);\n-        });\n-    }\n-\n-    /**\n-     * Request to {@value #PING}\n-     *\n-     * @param retryLimit count of attempt to send data to one of the <code>urls</code>' hosts\n-     * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n-     * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n-     */\n-    public void ping(int retryLimit)\n-            throws BadRequestException, UnavailableClusterException {\n-        sendToPool(retryLimit, this::ping);\n-    }\n-\n-    /**\n-     * Request to {@value #SEND_ASYNC}\n-     *\n-     * @param retryLimit count of attempt to send data to one of the <code>urls</code>' hosts\n-     * @param apiKey key for sending\n-     * @param stream topic name in kafka\n-     * @param data payload\n-     * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n-     * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n-     */\n-    public void sendAsync(int retryLimit, String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableClusterException {\n-        sendToPool(retryLimit, url -> sendAsync(url, apiKey, stream, data));\n-    }\n-\n-    /**\n-     * Request to {@value #SEND_ACK}\n-     *\n-     * @param retryLimit count of attempt to send data to one of the <code>urls</code>' hosts\n-     * @param apiKey key for sending\n-     * @param stream topic name in kafka\n-     * @param data payload\n-     * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n-     * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n-     */\n-    public void send(int retryLimit, String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableClusterException {\n-        sendToPool(retryLimit, url -> send(url, apiKey, stream, data));\n+  }\n+\n+  /**\n+   * Strategy of updating urls in topology\n+   */\n+  private void updateTopology() {\n+    if (greyList.isEmpty()) {\n+      return;\n     }\n \n-    /**\n-     * Request to {@value #PING}. Count of retry is <code>whitelist.size() + 1</code>\n-     *\n-     * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n-     * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n-     */\n-    public void ping()\n-            throws BadRequestException, UnavailableClusterException {\n-        ping(whiteList.size() + 1);\n+    for (int i = 0; i < greyList.size(); i++) {\n+      GreyListTopologyElement element = greyList.peek();\n+      if (System.currentTimeMillis() - element.getEntryTime() >= greyListElementsRecoveryTimeMs) {\n+        GreyListTopologyElement pollElement = greyList.poll();\n+        whiteList.add(pollElement.getUrl());\n+      } else {\n+        return;\n+      }\n     }\n+  }\n \n-    /**\n-     * Request to {@value #SEND_ASYNC}. Count of retry is <code>whitelist.size() + 1</code>\n-     *\n-     * @param apiKey key for sending\n-     * @param stream topic name in kafka\n-     * @param data payload\n-     * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n-     * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n-     */\n-    public void sendAsync(String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableClusterException {\n-        sendAsync(whiteList.size() + 1, apiKey, stream, data);\n-    }\n+  //TODO: metrics\n \n-    /**\n-     * Request to {@value #SEND_ACK}. Count of retry is <code>whitelist.size() + 1</code>\n-     *\n-     * @param apiKey key for sending\n-     * @param stream topic name in kafka\n-     * @param data payload\n-     * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n-     * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n-     */\n-    public void send(String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableClusterException {\n-        send(whiteList.size() + 1, apiKey, stream, data);\n-    }\n+  /**\n+   * Strategy of sending data to addresses pool\n+   */\n+  private void sendToPool(int retryLimit, HerculesRequestSender sender)\n+    throws BadRequestException, UnavailableClusterException {\n \n-    public void close() {\n-        try {\n-            client.close();\n-        } catch (IOException e) {\n-            LOGGER.error(\"Error while closing http client: \" + e.getLocalizedMessage());\n-        }\n-    }\n+    for (int count = 0; count < retryLimit; count++) {\n \n-    /**\n-     * Strategy of updating urls in topology\n-     */\n-    private void updateTopology() {\n-        if (greyList.isEmpty()) {\n-            return;\n-        }\n+      if (whiteList.isEmpty()) {\n+        throw new UnavailableClusterException();\n+      }\n \n-        for (int i = 0; i < greyList.size(); i++) {\n-            GreyListTopologyElement element = greyList.peek();\n-            if (System.currentTimeMillis() - element.getEntryTime() >= greyListElementsRecoveryTimeMs) {\n-                GreyListTopologyElement pollElement = greyList.poll();\n-                whiteList.add(pollElement.getUrl());\n-            } else {\n-                return;\n-            }\n-        }\n-    }\n+      String url = whiteList.next();\n \n-    //TODO: metrics\n-    /**\n-     * Strategy of sending data to addresses pool\n-     */\n-    private void sendToPool(int retryLimit, HerculesRequestSender sender)\n-            throws BadRequestException, UnavailableClusterException {\n-\n-        for (int count = 0; count < retryLimit; count++) {\n-\n-            if (whiteList.isEmpty()) {\n-                throw new UnavailableClusterException();\n-            }\n-\n-            String url = whiteList.next();\n-\n-            try {\n-                sender.send(url);\n-                return;\n-            } catch (HttpProtocolException | UnavailableHostException e) {\n-                if (!whiteList.remove(url)){\n-                    continue;\n-                }\n-                if (!greyList.offer(new GreyListTopologyElement(url))) {\n-                    if (LOGGER.isDebugEnabled()) {\n-                        LOGGER.debug(\"Send fails\", e);\n-                    }\n-                    whiteList.add(url);\n-                }\n-            }\n+      try {\n+        sender.send(url);\n+        return;\n+      } catch (HttpProtocolException | UnavailableHostException e) {\n+        if (!whiteList.remove(url)) {\n+          continue;\n         }\n-\n-        throw new UnavailableClusterException();\n-    }\n-\n-    //TODO: metrics\n-    /**\n-     * Strategy of sending data to single host\n-     */\n-    private void sendToHost(String url, ApacheRequestSender sender)\n-            throws BadRequestException, UnavailableHostException, HttpProtocolException {\n-        try {\n-            int statusCode = sender.send(url);\n-\n-            if (statusCode >= 400 && statusCode < 500) {\n-                throw new BadRequestException(statusCode);\n-            } else if (statusCode >= 500) {\n-                throw new UnavailableHostException(url);\n-            }\n-        } catch (ClientProtocolException e) {\n-            throw new HttpProtocolException(e);\n-        } catch (IOException e) {\n-            throw new UnavailableHostException(url, e);\n+        if (!greyList.offer(new GreyListTopologyElement(url))) {\n+          if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"Send fails\", e);\n+          }\n+          whiteList.add(url);\n         }\n+      }\n     }\n \n-    private int sendRequest(HttpUriRequest request) throws IOException {\n-        CloseableHttpResponse response = client.execute(request);\n-        int statusCode = response.getStatusLine().getStatusCode();\n-        response.close();\n-        return statusCode;\n-    }\n-\n-    /**\n-     * Build http post request\n-     *\n-     * @param url    gateway url\n-     * @param apiKey key for sending\n-     * @param action Command in Hercules Gateway\n-     * @param stream topic name in kafka\n-     * @param data   payload\n-     * @return formatted http post request\n-     */\n-    private HttpPost buildRequest(String url, String apiKey, String action, String stream, byte[] data) {\n-        HttpPost httpPost = new HttpPost(url + action + \"?stream=\" + stream);\n-\n-        httpPost.addHeader(\"apiKey\", apiKey);\n-\n-        HttpEntity entity = new ByteArrayEntity(data, ContentType.APPLICATION_OCTET_STREAM);\n-        httpPost.setEntity(entity);\n-\n-        return httpPost;\n-    }\n-\n-    /**\n-     * Tuning of {@link CloseableHttpClient}\n-     *\n-     * @param requestTimeout request timeout aka socket timeout (in millis)\n-     * @param connectionTimeout connection timeout (in millis)\n-     * @param connectionCount maximum client connections\n-     * @return Customized http client\n-     */\n-    private static CloseableHttpClient createHttpClient(int requestTimeout, int connectionTimeout, int connectionCount) {\n-        RequestConfig requestConfig = RequestConfig\n-                .custom()\n-                .setSocketTimeout(requestTimeout)\n-                .setConnectTimeout(connectionTimeout)\n-                .setConnectionRequestTimeout(connectionTimeout)\n-                .build();\n-\n-        return HttpClientBuilder\n-                .create()\n-                .setDefaultRequestConfig(requestConfig)\n-                .setMaxConnPerRoute(connectionCount)\n-                .setMaxConnTotal(connectionCount)\n-                .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false))\n-                .build();\n-    }\n-\n-    @FunctionalInterface\n-    private interface ApacheRequestSender {\n-        int send(String url) throws IOException;\n-    }\n-\n-    @FunctionalInterface\n-    private interface HerculesRequestSender {\n-        void send(String url) throws BadRequestException, UnavailableHostException, HttpProtocolException;\n-    }\n-\n-    private static class Props {\n-        static final PropertyDescription<Integer> REQUEST_TIMEOUT =\n-                PropertyDescriptions\n-                        .integerProperty(\"requestTimeout\")\n-                        .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n-                        .withValidator(IntegerValidators.positive())\n-                        .build();\n-\n-        static final PropertyDescription<Integer> CONNECTION_TIMEOUT =\n-                PropertyDescriptions\n-                        .integerProperty(\"connectionTimeout\")\n-                        .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n-                        .withValidator(IntegerValidators.positive())\n-                        .build();\n-\n-        static final PropertyDescription<Integer> CONNECTION_COUNT =\n-                PropertyDescriptions\n-                        .integerProperty(\"connectionCount\")\n-                        .withDefaultValue(GateClientDefaults.DEFAULT_CONNECTION_COUNT)\n-                        .withValidator(IntegerValidators.positive())\n-                        .build();\n-\n-        static final PropertyDescription<Integer> GREY_LIST_ELEMENTS_RECOVERY_TIME_MS =\n-                PropertyDescriptions\n-                        .integerProperty(\"greyListElementsRecoveryTimeMs\")\n-                        .withDefaultValue(GateClientDefaults.DEFAULT_RECOVERY_TIME)\n-                        .withValidator(IntegerValidators.positive())\n-                        .build();\n-\n+    throw new UnavailableClusterException();\n+  }\n+\n+  //TODO: metrics\n+\n+  /**\n+   * Strategy of sending data to single host\n+   */\n+  private void sendToHost(String url, ApacheRequestSender sender)\n+    throws BadRequestException, UnavailableHostException, HttpProtocolException {\n+    try {\n+      int statusCode = sender.send(url);\n+\n+      if (statusCode >= 400 && statusCode < 500) {\n+        throw new BadRequestException(statusCode);\n+      } else if (statusCode >= 500) {\n+        throw new UnavailableHostException(url);\n+      }\n+    } catch (ClientProtocolException e) {\n+      throw new HttpProtocolException(e);\n+    } catch (IOException e) {\n+      throw new UnavailableHostException(url, e);\n     }\n+  }\n+\n+  private int sendRequest(HttpUriRequest request) throws IOException {\n+    CloseableHttpResponse response = client.execute(request);\n+    int statusCode = response.getStatusLine().getStatusCode();\n+    response.close();\n+    return statusCode;\n+  }\n+\n+  /**\n+   * Build http post request\n+   *\n+   * @param url    gateway url\n+   * @param apiKey key for sending\n+   * @param action Command in Hercules Gateway\n+   * @param stream topic name in kafka\n+   * @param data   payload\n+   * @return formatted http post request\n+   */\n+  private HttpPost buildRequest(String url, String apiKey, String action, String stream, byte[] data) {\n+    HttpPost httpPost = new HttpPost(url + action + \"?stream=\" + stream);\n+\n+    httpPost.addHeader(\"apiKey\", apiKey);\n+\n+    HttpEntity entity = new ByteArrayEntity(data, ContentType.APPLICATION_OCTET_STREAM);\n+    httpPost.setEntity(entity);\n+\n+    return httpPost;\n+  }\n+\n+  /**\n+   * Tuning of {@link CloseableHttpClient}\n+   *\n+   * @param requestTimeout    request timeout aka socket timeout (in millis)\n+   * @param connectionTimeout connection timeout (in millis)\n+   * @param connectionCount   maximum client connections\n+   * @return Customized http client\n+   */\n+  private static CloseableHttpClient createHttpClient(int requestTimeout, int connectionTimeout, int connectionCount) {\n+    RequestConfig requestConfig = RequestConfig\n+      .custom()\n+      .setSocketTimeout(requestTimeout)\n+      .setConnectTimeout(connectionTimeout)\n+      .setConnectionRequestTimeout(connectionTimeout)\n+      .build();\n+\n+    return HttpClientBuilder\n+      .create()\n+      .setDefaultRequestConfig(requestConfig)\n+      .setMaxConnPerRoute(connectionCount)\n+      .setMaxConnTotal(connectionCount)\n+      .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false))\n+      .build();\n+  }\n+\n+  @FunctionalInterface\n+  private interface ApacheRequestSender {\n+    int send(String url) throws IOException;\n+  }\n+\n+  @FunctionalInterface\n+  private interface HerculesRequestSender {\n+    void send(String url) throws BadRequestException, UnavailableHostException, HttpProtocolException;\n+  }\n+\n+  private static class Props {\n+    static final PropertyDescription<Integer> REQUEST_TIMEOUT =\n+      PropertyDescriptions\n+        .integerProperty(\"requestTimeout\")\n+        .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n+        .withValidator(IntegerValidators.positive())\n+        .build();\n+\n+    static final PropertyDescription<Integer> CONNECTION_TIMEOUT =\n+      PropertyDescriptions\n+        .integerProperty(\"connectionTimeout\")\n+        .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n+        .withValidator(IntegerValidators.positive())\n+        .build();\n+\n+    static final PropertyDescription<Integer> CONNECTION_COUNT =\n+      PropertyDescriptions\n+        .integerProperty(\"connectionCount\")\n+        .withDefaultValue(GateClientDefaults.DEFAULT_CONNECTION_COUNT)\n+        .withValidator(IntegerValidators.positive())\n+        .build();\n+\n+    static final PropertyDescription<Integer> GREY_LIST_ELEMENTS_RECOVERY_TIME_MS =\n+      PropertyDescriptions\n+        .integerProperty(\"greyListElementsRecoveryTimeMs\")\n+        .withDefaultValue(GateClientDefaults.DEFAULT_RECOVERY_TIME)\n+        .withValidator(IntegerValidators.positive())\n+        .build();\n+\n+  }\n }\n",
            "diff_size": 571
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/81/GateClient.java\nindex e78b02e1fdc..733791b1b41 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/81/GateClient.java\n@@ -64,7 +64,6 @@ public class GateClient implements Closeable {\n                 greyListElementsRecoveryTimeMs,\n                 greyListElementsRecoveryTimeMs,\n                 TimeUnit.MILLISECONDS);\n-\n     }\n \n     public GateClient(Properties properties, Topology<String> whiteList) {\n@@ -248,10 +247,8 @@ public class GateClient implements Closeable {\n      */\n     private void sendToPool(int retryLimit, HerculesRequestSender sender)\n             throws BadRequestException, UnavailableClusterException {\n-\n-        for (int count = 0; count < retryLimit; count++) {\n-\n-            if (whiteList.isEmpty()) {\n+    for (int count = 0; count < retryLimit; count++) {\n+    if (whiteList.isEmpty()) {\n                 throw new UnavailableClusterException();\n             }\n \n@@ -261,7 +258,7 @@ public class GateClient implements Closeable {\n                 sender.send(url);\n                 return;\n             } catch (HttpProtocolException | UnavailableHostException e) {\n-                if (!whiteList.remove(url)){\n+                if (!whiteList.remove(url)) {\n                     continue;\n                 }\n                 if (!greyList.offer(new GreyListTopologyElement(url))) {\n@@ -361,33 +358,24 @@ public class GateClient implements Closeable {\n     }\n \n     private static class Props {\n-        static final PropertyDescription<Integer> REQUEST_TIMEOUT =\n-                PropertyDescriptions\n-                        .integerProperty(\"requestTimeout\")\n+        static final PropertyDescription<Integer> REQUEST_TIMEOUT = PropertyDescriptions.integerProperty(\"requestTimeout\")\n                         .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n                         .withValidator(IntegerValidators.positive())\n                         .build();\n \n-        static final PropertyDescription<Integer> CONNECTION_TIMEOUT =\n-                PropertyDescriptions\n-                        .integerProperty(\"connectionTimeout\")\n+        static final PropertyDescription<Integer> CONNECTION_TIMEOUT = PropertyDescriptions.integerProperty(\"connectionTimeout\")\n                         .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n                         .withValidator(IntegerValidators.positive())\n                         .build();\n \n-        static final PropertyDescription<Integer> CONNECTION_COUNT =\n-                PropertyDescriptions\n-                        .integerProperty(\"connectionCount\")\n+        static final PropertyDescription<Integer> CONNECTION_COUNT = PropertyDescriptions.integerProperty(\"connectionCount\")\n                         .withDefaultValue(GateClientDefaults.DEFAULT_CONNECTION_COUNT)\n                         .withValidator(IntegerValidators.positive())\n                         .build();\n \n-        static final PropertyDescription<Integer> GREY_LIST_ELEMENTS_RECOVERY_TIME_MS =\n-                PropertyDescriptions\n-                        .integerProperty(\"greyListElementsRecoveryTimeMs\")\n+        static final PropertyDescription<Integer> GREY_LIST_ELEMENTS_RECOVERY_TIME_MS = PropertyDescriptions.integerProperty(\"greyListElementsRecoveryTimeMs\")\n                         .withDefaultValue(GateClientDefaults.DEFAULT_RECOVERY_TIME)\n                         .withValidator(IntegerValidators.positive())\n                         .build();\n-\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 20
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "103",
                    "severity": "warning",
                    "message": "Line is longer than 160 characters (found 164).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/81/GateClient.java\nindex e78b02e1fdc..7cba23b1b17 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/81/GateClient.java\n@@ -22,7 +22,6 @@ import ru.kontur.vostok.hercules.util.concurrent.Topology;\n import ru.kontur.vostok.hercules.util.properties.PropertyDescription;\n import ru.kontur.vostok.hercules.util.properties.PropertyDescriptions;\n import ru.kontur.vostok.hercules.util.validation.IntegerValidators;\n-\n import java.io.Closeable;\n import java.io.IOException;\n import java.util.Properties;\n@@ -38,50 +37,38 @@ import java.util.concurrent.TimeUnit;\n  *\n  * @author Daniil Zhenikhov\n  */\n+\n+\n public class GateClient implements Closeable {\n+\n     private static final Logger LOGGER = LoggerFactory.getLogger(GateClient.class);\n     private static final Random RANDOM = new Random();\n-\n     private static final String PING = \"/ping\";\n     private static final String SEND_ACK = \"/stream/send\";\n     private static final String SEND_ASYNC = \"/stream/sendAsync\";\n-\n     private final CloseableHttpClient client;\n-\n     private final BlockingQueue<GreyListTopologyElement> greyList;\n     private final Topology<String> whiteList;\n     private final int greyListElementsRecoveryTimeMs;\n     private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n \n     public GateClient(Properties properties, CloseableHttpClient client, Topology<String> whiteList) {\n-\n         this.greyListElementsRecoveryTimeMs = Props.GREY_LIST_ELEMENTS_RECOVERY_TIME_MS.extract(properties);\n         this.client = client;\n         this.whiteList = whiteList;\n         this.greyList = new ArrayBlockingQueue<>(whiteList.size());\n-\n-        scheduler.scheduleWithFixedDelay(this::updateTopology,\n-                greyListElementsRecoveryTimeMs,\n-                greyListElementsRecoveryTimeMs,\n-                TimeUnit.MILLISECONDS);\n-\n+        scheduler.scheduleWithFixedDelay(this::updateTopology, greyListElementsRecoveryTimeMs, greyListElementsRecoveryTimeMs, TimeUnit.MILLISECONDS);\n     }\n \n     public GateClient(Properties properties, Topology<String> whiteList) {\n         final int requestTimeout = Props.REQUEST_TIMEOUT.extract(properties);\n         final int connectionTimeout = Props.CONNECTION_TIMEOUT.extract(properties);\n         final int connectionCount = Props.CONNECTION_COUNT.extract(properties);\n-\n         this.greyListElementsRecoveryTimeMs = Props.GREY_LIST_ELEMENTS_RECOVERY_TIME_MS.extract(properties);\n         this.whiteList = whiteList;\n         this.greyList = new ArrayBlockingQueue<>(whiteList.size());\n-\n         this.client = createHttpClient(requestTimeout, connectionTimeout, connectionCount);\n-\n-        scheduler.scheduleWithFixedDelay(this::updateTopology,\n-                greyListElementsRecoveryTimeMs,\n-                greyListElementsRecoveryTimeMs,\n-                TimeUnit.MILLISECONDS);\n+        scheduler.scheduleWithFixedDelay(this::updateTopology, greyListElementsRecoveryTimeMs, greyListElementsRecoveryTimeMs, TimeUnit.MILLISECONDS);\n     }\n \n     /**\n@@ -91,11 +78,15 @@ public class GateClient implements Closeable {\n      * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n      * @throws UnavailableHostException throws if was error on server side: 5xx errors or connection errors\n      */\n+\n     public void ping(String url) throws BadRequestException, UnavailableHostException, HttpProtocolException {\n-        sendToHost(url, urlParam -> {\n+        sendToHost(\n+            url,\n+            urlParam -> {\n             HttpGet httpGet = new HttpGet(urlParam + PING);\n             return sendRequest(httpGet);\n-        });\n+        }\n+        );\n     }\n \n     /**\n@@ -108,8 +99,8 @@ public class GateClient implements Closeable {\n      * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n      * @throws UnavailableHostException throws if was error on server side: 5xx errors or connection errors\n      */\n-    public void sendAsync(String url, String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableHostException, HttpProtocolException {\n+\n+    public void sendAsync(String url, String apiKey, String stream, final byte[] data) throws BadRequestException, UnavailableHostException, HttpProtocolException {\n         sendToHost(url, urlParam -> {\n             HttpPost httpPost = buildRequest(url, apiKey, SEND_ASYNC, stream, data);\n             return sendRequest(httpPost);\n@@ -126,8 +117,8 @@ public class GateClient implements Closeable {\n      * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n      * @throws UnavailableHostException throws if was error on server side: 5xx errors or connection errors\n      */\n-    public void send(String url, String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableHostException, HttpProtocolException {\n+\n+    public void send(String url, String apiKey, String stream, final byte[] data) throws BadRequestException, UnavailableHostException, HttpProtocolException {\n         sendToHost(url, urlParam -> {\n             HttpPost httpPost = buildRequest(url, apiKey, SEND_ACK, stream, data);\n             return sendRequest(httpPost);\n@@ -141,8 +132,8 @@ public class GateClient implements Closeable {\n      * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n      * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n      */\n-    public void ping(int retryLimit)\n-            throws BadRequestException, UnavailableClusterException {\n+\n+    public void ping(int retryLimit) throws BadRequestException, UnavailableClusterException {\n         sendToPool(retryLimit, this::ping);\n     }\n \n@@ -156,8 +147,8 @@ public class GateClient implements Closeable {\n      * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n      * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n      */\n-    public void sendAsync(int retryLimit, String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableClusterException {\n+\n+    public void sendAsync(int retryLimit, String apiKey, String stream, final byte[] data) throws BadRequestException, UnavailableClusterException {\n         sendToPool(retryLimit, url -> sendAsync(url, apiKey, stream, data));\n     }\n \n@@ -171,8 +162,8 @@ public class GateClient implements Closeable {\n      * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n      * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n      */\n-    public void send(int retryLimit, String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableClusterException {\n+\n+    public void send(int retryLimit, String apiKey, String stream, final byte[] data) throws BadRequestException, UnavailableClusterException {\n         sendToPool(retryLimit, url -> send(url, apiKey, stream, data));\n     }\n \n@@ -182,8 +173,8 @@ public class GateClient implements Closeable {\n      * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n      * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n      */\n-    public void ping()\n-            throws BadRequestException, UnavailableClusterException {\n+\n+    public void ping() throws BadRequestException, UnavailableClusterException {\n         ping(whiteList.size() + 1);\n     }\n \n@@ -196,8 +187,8 @@ public class GateClient implements Closeable {\n      * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n      * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n      */\n-    public void sendAsync(String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableClusterException {\n+\n+    public void sendAsync(String apiKey, String stream, final byte[] data) throws BadRequestException, UnavailableClusterException {\n         sendAsync(whiteList.size() + 1, apiKey, stream, data);\n     }\n \n@@ -210,8 +201,8 @@ public class GateClient implements Closeable {\n      * @throws BadRequestException throws if was error on client side: 4xx errors or http protocol errors\n      * @throws UnavailableClusterException throws if was error on addresses pool side: no one of address is unavailable\n      */\n-    public void send(String apiKey, String stream, final byte[] data)\n-            throws BadRequestException, UnavailableClusterException {\n+\n+    public void send(String apiKey, String stream, final byte[] data) throws BadRequestException, UnavailableClusterException {\n         send(whiteList.size() + 1, apiKey, stream, data);\n     }\n \n@@ -226,6 +217,7 @@ public class GateClient implements Closeable {\n     /**\n      * Strategy of updating urls in topology\n      */\n+\n     private void updateTopology() {\n         if (greyList.isEmpty()) {\n             return;\n@@ -246,28 +238,26 @@ public class GateClient implements Closeable {\n     /**\n      * Strategy of sending data to addresses pool\n      */\n-    private void sendToPool(int retryLimit, HerculesRequestSender sender)\n-            throws BadRequestException, UnavailableClusterException {\n \n+    private void sendToPool(int retryLimit, HerculesRequestSender sender) throws BadRequestException, UnavailableClusterException {\n         for (int count = 0; count < retryLimit; count++) {\n-\n             if (whiteList.isEmpty()) {\n                 throw new UnavailableClusterException();\n             }\n \n             String url = whiteList.next();\n-\n             try {\n                 sender.send(url);\n                 return;\n             } catch (HttpProtocolException | UnavailableHostException e) {\n-                if (!whiteList.remove(url)){\n+                if (!whiteList.remove(url)) {\n                     continue;\n                 }\n                 if (!greyList.offer(new GreyListTopologyElement(url))) {\n                     if (LOGGER.isDebugEnabled()) {\n                         LOGGER.debug(\"Send fails\", e);\n                     }\n+\n                     whiteList.add(url);\n                 }\n             }\n@@ -280,16 +270,15 @@ public class GateClient implements Closeable {\n     /**\n      * Strategy of sending data to single host\n      */\n-    private void sendToHost(String url, ApacheRequestSender sender)\n-            throws BadRequestException, UnavailableHostException, HttpProtocolException {\n+\n+    private void sendToHost(String url, ApacheRequestSender sender) throws BadRequestException, UnavailableHostException, HttpProtocolException {\n         try {\n             int statusCode = sender.send(url);\n-\n             if (statusCode >= 400 && statusCode < 500) {\n                 throw new BadRequestException(statusCode);\n             } else if (statusCode >= 500) {\n-                throw new UnavailableHostException(url);\n-            }\n+                       throw new UnavailableHostException(url);\n+                   }\n         } catch (ClientProtocolException e) {\n             throw new HttpProtocolException(e);\n         } catch (IOException e) {\n@@ -299,7 +288,8 @@ public class GateClient implements Closeable {\n \n     private int sendRequest(HttpUriRequest request) throws IOException {\n         CloseableHttpResponse response = client.execute(request);\n-        int statusCode = response.getStatusLine().getStatusCode();\n+        int statusCode = response.getStatusLine()\n+        .getStatusCode();\n         response.close();\n         return statusCode;\n     }\n@@ -314,14 +304,13 @@ public class GateClient implements Closeable {\n      * @param data   payload\n      * @return formatted http post request\n      */\n+\n     private HttpPost buildRequest(String url, String apiKey, String action, String stream, byte[] data) {\n         HttpPost httpPost = new HttpPost(url + action + \"?stream=\" + stream);\n-\n         httpPost.addHeader(\"apiKey\", apiKey);\n \n         HttpEntity entity = new ByteArrayEntity(data, ContentType.APPLICATION_OCTET_STREAM);\n         httpPost.setEntity(entity);\n-\n         return httpPost;\n     }\n \n@@ -333,21 +322,19 @@ public class GateClient implements Closeable {\n      * @param connectionCount maximum client connections\n      * @return Customized http client\n      */\n+\n     private static CloseableHttpClient createHttpClient(int requestTimeout, int connectionTimeout, int connectionCount) {\n-        RequestConfig requestConfig = RequestConfig\n-                .custom()\n-                .setSocketTimeout(requestTimeout)\n-                .setConnectTimeout(connectionTimeout)\n-                .setConnectionRequestTimeout(connectionTimeout)\n-                .build();\n-\n-        return HttpClientBuilder\n-                .create()\n-                .setDefaultRequestConfig(requestConfig)\n-                .setMaxConnPerRoute(connectionCount)\n-                .setMaxConnTotal(connectionCount)\n-                .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false))\n-                .build();\n+        RequestConfig requestConfig = RequestConfig.custom()\n+        .setSocketTimeout(requestTimeout)\n+        .setConnectTimeout(connectionTimeout)\n+        .setConnectionRequestTimeout(connectionTimeout)\n+        .build();\n+        return HttpClientBuilder.create()\n+        .setDefaultRequestConfig(requestConfig)\n+        .setMaxConnPerRoute(connectionCount)\n+        .setMaxConnTotal(connectionCount)\n+        .setRetryHandler(new DefaultHttpRequestRetryHandler(0, false))\n+        .build();\n     }\n \n     @FunctionalInterface\n@@ -361,33 +348,24 @@ public class GateClient implements Closeable {\n     }\n \n     private static class Props {\n-        static final PropertyDescription<Integer> REQUEST_TIMEOUT =\n-                PropertyDescriptions\n-                        .integerProperty(\"requestTimeout\")\n-                        .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n-                        .withValidator(IntegerValidators.positive())\n-                        .build();\n-\n-        static final PropertyDescription<Integer> CONNECTION_TIMEOUT =\n-                PropertyDescriptions\n-                        .integerProperty(\"connectionTimeout\")\n-                        .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n-                        .withValidator(IntegerValidators.positive())\n-                        .build();\n-\n-        static final PropertyDescription<Integer> CONNECTION_COUNT =\n-                PropertyDescriptions\n-                        .integerProperty(\"connectionCount\")\n-                        .withDefaultValue(GateClientDefaults.DEFAULT_CONNECTION_COUNT)\n-                        .withValidator(IntegerValidators.positive())\n-                        .build();\n-\n-        static final PropertyDescription<Integer> GREY_LIST_ELEMENTS_RECOVERY_TIME_MS =\n-                PropertyDescriptions\n-                        .integerProperty(\"greyListElementsRecoveryTimeMs\")\n-                        .withDefaultValue(GateClientDefaults.DEFAULT_RECOVERY_TIME)\n-                        .withValidator(IntegerValidators.positive())\n-                        .build();\n-\n+        static final PropertyDescription<Integer> REQUEST_TIMEOUT = PropertyDescriptions.integerProperty(\"requestTimeout\")\n+        .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n+        .withValidator(IntegerValidators.positive())\n+        .build();\n+\n+        static final PropertyDescription<Integer> CONNECTION_TIMEOUT = PropertyDescriptions.integerProperty(\"connectionTimeout\")\n+        .withDefaultValue(GateClientDefaults.DEFAULT_TIMEOUT)\n+        .withValidator(IntegerValidators.positive())\n+        .build();\n+\n+        static final PropertyDescription<Integer> CONNECTION_COUNT = PropertyDescriptions.integerProperty(\"connectionCount\")\n+        .withDefaultValue(GateClientDefaults.DEFAULT_CONNECTION_COUNT)\n+        .withValidator(IntegerValidators.positive())\n+        .build();\n+\n+        static final PropertyDescription<Integer> GREY_LIST_ELEMENTS_RECOVERY_TIME_MS = PropertyDescriptions.integerProperty(\"greyListElementsRecoveryTimeMs\")\n+        .withDefaultValue(GateClientDefaults.DEFAULT_RECOVERY_TIME)\n+        .withValidator(IntegerValidators.positive())\n+        .build();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 105
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/81/GateClient.java\nindex e78b02e1fdc..021f8b26d3a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/81/GateClient.java\n@@ -261,7 +261,7 @@ public class GateClient implements Closeable {\n                 sender.send(url);\n                 return;\n             } catch (HttpProtocolException | UnavailableHostException e) {\n-                if (!whiteList.remove(url)){\n+                if (!whiteList.remove(url)) {\n                     continue;\n                 }\n                 if (!greyList.offer(new GreyListTopologyElement(url))) {\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/81/GateClient.java\nindex e78b02e1fdc..021f8b26d3a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/81/GateClient.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/81/GateClient.java\n@@ -261,7 +261,7 @@ public class GateClient implements Closeable {\n                 sender.send(url);\n                 return;\n             } catch (HttpProtocolException | UnavailableHostException e) {\n-                if (!whiteList.remove(url)){\n+                if (!whiteList.remove(url)) {\n                     continue;\n                 }\n                 if (!greyList.offer(new GreyListTopologyElement(url))) {\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "codebuff"
    ]
}