{
    "project_name": "wso2-attic-commons",
    "error_id": "256",
    "information": {
        "errors": [
            {
                "line": "255",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 128).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "    }\n\n    <T extends RowSubset> Element renderXmlRow(Locator locator, QName varType, T value) throws ExternalVariableModuleException {\n        Document doc = DOMUtils.newDocument();\n        Element el = doc.createElementNS(varType.getNamespaceURI(), varType.getLocalPart());\n        doc.appendChild(el);",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/256/DbExternalVariable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/256/DbExternalVariable.java\nindex 8f14f872cf8..4ea0fc9a96d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/256/DbExternalVariable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler/256/DbExternalVariable.java\n@@ -252,8 +252,9 @@ class DbExternalVariable {\n \n     }\n \n-    <T extends RowSubset> Element renderXmlRow(Locator locator, QName varType, T value) throws ExternalVariableModuleException {\n-        Document doc = DOMUtils.newDocument();\n+    <T extends RowSubset> Element renderXmlRow(Locator locator, QName varType,\n+            T value) throws ExternalVariableModuleException {\n+         Document doc = DOMUtils.newDocument();\n         Element el = doc.createElementNS(varType.getNamespaceURI(), varType.getLocalPart());\n         doc.appendChild(el);\n         if (value != null) {\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/256/DbExternalVariable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/256/DbExternalVariable.java\nindex 8f14f872cf8..3797a150638 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/256/DbExternalVariable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/256/DbExternalVariable.java\n@@ -48,498 +48,541 @@ import org.w3c.dom.NodeList;\n  * @author Maciej Szefler <mszefler at gmail dot com>\n  */\n class DbExternalVariable {\n-    private static final Log __log = LogFactory.getLog(DbExternalVariable.class);\n+  private static final Log __log = LogFactory.getLog(DbExternalVariable.class);\n \n-    private static final String XSI_NS = \"http://www.w3.org/2001/XMLSchema-instance\";\n+  private static final String XSI_NS = \"http://www.w3.org/2001/XMLSchema-instance\";\n \n-    EVarId evarId;\n+  EVarId evarId;\n \n-    DataSource dataSource;\n+  DataSource dataSource;\n \n-    final ArrayList<Column> _columns = new ArrayList<Column>();\n+  final ArrayList<Column> _columns = new ArrayList<Column>();\n \n-    private final HashMap<String, Column> _colmap = new HashMap<String, Column>();\n+  private final HashMap<String, Column> _colmap = new HashMap<String, Column>();\n \n-    final ArrayList<Column> _keycolumns = new ArrayList<Column>();\n+  final ArrayList<Column> _keycolumns = new ArrayList<Column>();\n \n-    final ArrayList<Column> _inscolumns = new ArrayList<Column>();\n+  final ArrayList<Column> _inscolumns = new ArrayList<Column>();\n \n-    final ArrayList<Column> _updcolumns = new ArrayList<Column>();\n+  final ArrayList<Column> _updcolumns = new ArrayList<Column>();\n \n-    InitType _initType = InitType.update_insert;\n+  InitType _initType = InitType.update_insert;\n \n-    public String[] _autoColNames;\n+  public String[] _autoColNames;\n \n-    String select;\n+  String select;\n \n-    String insert;\n+  String insert;\n \n-    String update;\n+  String update;\n \n-    String table;\n+  String table;\n \n-    String schema; // table schema\n+  String schema; // table schema\n \n-    /** Does the database support retrieval of generated keys? */\n-    boolean generatedKeys;\n+  /**\n+   * Does the database support retrieval of generated keys?\n+   */\n+  boolean generatedKeys;\n \n-    DbExternalVariable(EVarId evar, DataSource ds) {\n-        this.evarId = evar;\n-        this.dataSource = ds;\n-    }\n+  DbExternalVariable(EVarId evar, DataSource ds) {\n+    this.evarId = evar;\n+    this.dataSource = ds;\n+  }\n \n-    Column getColumn(String key) {\n-        return _colmap.get(key);\n-    }\n+  Column getColumn(String key) {\n+    return _colmap.get(key);\n+  }\n \n-    void addColumn(Column c) {\n-        c.idx = _columns.size();\n-        _colmap.put(c.name, c);\n-        _columns.add(c);\n-        if (c.key) {\n-            _keycolumns.add(c);\n-            _autoColNames = new String[_keycolumns.size()];\n-            for (int i = 0; i < _autoColNames.length; ++i)\n-                _autoColNames[i] = _keycolumns.get(i).colname;\n-        }\n-        createSelect();\n-        createInsert();\n-        createUpdate();\n+  void addColumn(Column c) {\n+    c.idx = _columns.size();\n+    _colmap.put(c.name, c);\n+    _columns.add(c);\n+    if (c.key) {\n+      _keycolumns.add(c);\n+      _autoColNames = new String[_keycolumns.size()];\n+      for (int i = 0; i < _autoColNames.length; ++i) {\n+        _autoColNames[i] = _keycolumns.get(i).colname;\n+      }\n     }\n-\n-    public int numColumns() {\n-        return _columns.size();\n+    createSelect();\n+    createInsert();\n+    createUpdate();\n+  }\n+\n+  public int numColumns() {\n+    return _columns.size();\n+  }\n+\n+  /**\n+   * Create a key from a locator.\n+   */\n+  RowKey keyFromLocator(Locator locator) throws ExternalVariableModuleException {\n+    RowKey rc = new RowKey();\n+    parseXmlRow(rc, locator.reference);\n+\n+    // Put in the static goodies such as pid/iid\n+    for (Column c : rc._columns) {\n+      switch (c.genType) {\n+      case iid:\n+      case pid:\n+        rc.put(c.name, c.getValue(c.name, null, null, locator.iid));\n+        break;\n+      }\n     }\n \n-    /**\n-     * Create a key from a locator.\n-     */\n-    RowKey keyFromLocator(Locator locator) throws ExternalVariableModuleException {\n-        RowKey rc = new RowKey();\n-        parseXmlRow(rc, locator.reference);\n-\n-        // Put in the static goodies such as pid/iid\n-        for (Column c : rc._columns) {\n-            switch (c.genType) {\n-            case iid:\n-            case pid:\n-                rc.put(c.name, c.getValue(c.name, null, null, locator.iid));\n-                break;\n-            }\n-        }\n-\n-        return rc;\n-    }\n+    return rc;\n+  }\n \n-    private void createSelect() {\n-        StringBuilder sb = new StringBuilder(\"select \");\n-        boolean first = true;\n-        for (Column c : _columns) {\n-            if (!first) {\n-                sb.append(',');\n-            }\n-            first = false;\n-\n-            sb.append(c.colname);\n-        }\n-        sb.append(\" from \");\n-        sb.append(schema + \".\" + table);\n-        if (_keycolumns.size() > 0) {\n-            sb.append(\" where \");\n-            first = true;\n-\n-            for (Column kc : _keycolumns) {\n-                if (!first) {\n-                    sb.append(\" and \");\n-                }\n-                first = false;\n-\n-                sb.append(kc.colname);\n-                sb.append(\" = ?\");\n-            }\n-            select = sb.toString();\n+  private void createSelect() {\n+    StringBuilder sb = new StringBuilder(\"select \");\n+    boolean first = true;\n+    for (Column c : _columns) {\n+      if (!first) {\n+        sb.append(',');\n+      }\n+      first = false;\n \n-        } else {\n-            select = null;\n-        }\n+      sb.append(c.colname);\n     }\n-\n-    private void createUpdate() {\n-        _updcolumns.clear();\n-        StringBuilder sb = new StringBuilder(\"update \");\n-        sb.append(schema + \".\" + table);\n-        sb.append(\" set \");\n-        boolean first = true;\n-        for (Column c : _columns) {\n-            // Don't ever update keys or sequences or create time stamps\n-            if (c.genType == GenType.sequence || c.key || c.genType == GenType.ctimestamp)\n-                continue;\n-\n-            if (!first)\n-                sb.append(\", \");\n-            first = false;\n-\n-            sb.append(c.colname);\n-            sb.append(\" = \");\n-            if (c.genType == GenType.expression)\n-                sb.append(c.expression);\n-            else {\n-                sb.append(\" ?\");\n-                _updcolumns.add(c);\n-            }\n+    sb.append(\" from \");\n+    sb.append(schema + \".\" + table);\n+    if (_keycolumns.size() > 0) {\n+      sb.append(\" where \");\n+      first = true;\n+\n+      for (Column kc : _keycolumns) {\n+        if (!first) {\n+          sb.append(\" and \");\n         }\n+        first = false;\n \n-        if (_keycolumns.size() > 0) {\n-            sb.append(\" where \");\n-            first = true;\n-\n-            for (Column kc : _keycolumns) {\n-                if (!first) {\n-                    sb.append(\" and \");\n-                }\n-                first = false;\n-\n-                sb.append(kc.colname);\n-                sb.append(\" = ?\");\n-            }\n-        }\n+        sb.append(kc.colname);\n+        sb.append(\" = ?\");\n+      }\n+      select = sb.toString();\n \n-        // If we have no key columns, we cannot do an update\n-        if (_keycolumns.size() == 0)\n-            update = null;\n-        else\n-            update = sb.toString();\n+    } else {\n+      select = null;\n+    }\n+  }\n+\n+  private void createUpdate() {\n+    _updcolumns.clear();\n+    StringBuilder sb = new StringBuilder(\"update \");\n+    sb.append(schema + \".\" + table);\n+    sb.append(\" set \");\n+    boolean first = true;\n+    for (Column c : _columns) {\n+      // Don't ever update keys or sequences or create time stamps\n+      if (c.genType == GenType.sequence || c.key || c.genType == GenType.ctimestamp) {\n+        continue;\n+      }\n+\n+      if (!first) {\n+        sb.append(\", \");\n+      }\n+      first = false;\n+\n+      sb.append(c.colname);\n+      sb.append(\" = \");\n+      if (c.genType == GenType.expression) {\n+        sb.append(c.expression);\n+      } else {\n+        sb.append(\" ?\");\n+        _updcolumns.add(c);\n+      }\n     }\n \n-    private void createInsert() {\n-        _inscolumns.clear();\n-        StringBuilder sb = new StringBuilder(\"insert into \");\n-        sb.append(schema + \".\" + table);\n-        sb.append(\" ( \");\n-        boolean first = true;\n-        for (Column c : _columns) {\n-            if (c.genType == GenType.sequence)\n-                continue;\n-\n-            if (!first)\n-                sb.append(',');\n+    if (_keycolumns.size() > 0) {\n+      sb.append(\" where \");\n+      first = true;\n \n-            first = false;\n-            sb.append(c.colname);\n-        }\n-        sb.append(\" ) \");\n-\n-        sb.append(\" values ( \");\n-\n-        first = true;\n-        for (Column c : _columns) {\n-            if (c.genType == GenType.sequence)\n-                continue;\n-            if (!first)\n-                sb.append(',');\n-            first = false;\n-\n-            if (c.genType == GenType.expression)\n-                sb.append(c.expression);\n-            else {\n-                sb.append(\" ? \");\n-                _inscolumns.add(c);\n-            }\n+      for (Column kc : _keycolumns) {\n+        if (!first) {\n+          sb.append(\" and \");\n         }\n-        sb.append(\" ) \");\n+        first = false;\n \n-        insert = sb.toString();\n+        sb.append(kc.colname);\n+        sb.append(\" = ?\");\n+      }\n+    }\n \n+    // If we have no key columns, we cannot do an update\n+    if (_keycolumns.size() == 0) {\n+      update = null;\n+    } else {\n+      update = sb.toString();\n+    }\n+  }\n+\n+  private void createInsert() {\n+    _inscolumns.clear();\n+    StringBuilder sb = new StringBuilder(\"insert into \");\n+    sb.append(schema + \".\" + table);\n+    sb.append(\" ( \");\n+    boolean first = true;\n+    for (Column c : _columns) {\n+      if (c.genType == GenType.sequence) {\n+        continue;\n+      }\n+\n+      if (!first) {\n+        sb.append(',');\n+      }\n+\n+      first = false;\n+      sb.append(c.colname);\n     }\n+    sb.append(\" ) \");\n+\n+    sb.append(\" values ( \");\n+\n+    first = true;\n+    for (Column c : _columns) {\n+      if (c.genType == GenType.sequence) {\n+        continue;\n+      }\n+      if (!first) {\n+        sb.append(',');\n+      }\n+      first = false;\n+\n+      if (c.genType == GenType.expression) {\n+        sb.append(c.expression);\n+      } else {\n+        sb.append(\" ? \");\n+        _inscolumns.add(c);\n+      }\n+    }\n+    sb.append(\" ) \");\n+\n+    insert = sb.toString();\n+\n+  }\n+\n+  <T extends RowSubset> Element renderXmlRow(Locator locator, QName varType, T value)\n+    throws ExternalVariableModuleException {\n+    Document doc = DOMUtils.newDocument();\n+    Element el = doc.createElementNS(varType.getNamespaceURI(), varType.getLocalPart());\n+    doc.appendChild(el);\n+    if (value != null) {\n+      for (Column c : value._columns) {\n+        Object data = value.get(c.idx);\n+        addElement(el, varType, c, data);\n+      }\n+    } else {\n+      // initialize variable with default/generated values\n+      RowKey keys = keyFromLocator(locator);\n+      for (Column c : _columns) {\n+        Object data = c.getValue(c.name, keys, new RowVal(), locator.iid);\n+        addElement(el, varType, c, data);\n+      }\n+    }\n+    return el;\n+  }\n+\n+  private void addElement(Element parent, QName varType, Column c, Object data) {\n+    Document doc = parent.getOwnerDocument();\n+    Element cel = doc.createElementNS(varType.getNamespaceURI(), c.name);\n+    String strdat = c.toText(data);\n+    if (strdat != null) {\n+      cel.appendChild(doc.createTextNode(strdat));\n+    } else if (c.nullok || c.isGenerated()) {\n+      cel.setAttributeNS(XSI_NS, \"xsi:nil\", \"true\");\n+    }\n+    parent.appendChild(cel);\n+  }\n \n-    <T extends RowSubset> Element renderXmlRow(Locator locator, QName varType, T value) throws ExternalVariableModuleException {\n-        Document doc = DOMUtils.newDocument();\n-        Element el = doc.createElementNS(varType.getNamespaceURI(), varType.getLocalPart());\n-        doc.appendChild(el);\n-        if (value != null) {\n-            for (Column c : value._columns) {\n-                Object data = value.get(c.idx);\n-                addElement(el, varType, c, data);\n-            }\n-        } else {\n-            // initialize variable with default/generated values\n-            RowKey keys = keyFromLocator(locator);\n-            for (Column c : _columns) {\n-                Object data = c.getValue(c.name, keys, new RowVal(), locator.iid);\n-                addElement(el, varType, c, data);\n-            }\n-        }\n-        return el;\n+  <T extends RowSubset> T parseXmlRow(T ret, Node rowel)\n+    throws ExternalVariableModuleException {\n+    if (rowel == null) {\n+      return ret;\n     }\n \n-    private void addElement(Element parent, QName varType, Column c, Object data) {\n-        Document doc = parent.getOwnerDocument();\n-        Element cel = doc.createElementNS(varType.getNamespaceURI(), c.name);\n-        String strdat = c.toText(data);\n-        if (strdat != null) {\n-            cel.appendChild(doc.createTextNode(strdat));\n-        } else if (c.nullok || c.isGenerated()) {\n-            cel.setAttributeNS(XSI_NS, \"xsi:nil\", \"true\");\n+    NodeList nl = rowel.getChildNodes();\n+    if (__log.isDebugEnabled()) {\n+      __log.debug(\"parseXmlRow: element=\" + rowel.getLocalName());\n+    }\n+    for (int i = 0; i < nl.getLength(); ++i) {\n+      Node n = nl.item(i);\n+      if (n.getNodeType() != Node.ELEMENT_NODE) {\n+        continue;\n+      }\n+      String key = n.getLocalName();\n+      String val = n.getTextContent();\n+      if (__log.isDebugEnabled()) {\n+        __log.debug(\"Extvar key: \" + key + \" value: \" + val);\n+      }\n+\n+      Column column = ret.getColumn(key);\n+      if (column == null) {\n+        if (__log.isDebugEnabled()) {\n+          __log.debug(\"No matching column for key '\" + key + \"'\");\n         }\n-        parent.appendChild(cel);\n-    }\n-\n-    <T extends RowSubset> T parseXmlRow(T ret, Node rowel)\n-            throws ExternalVariableModuleException {\n-        if (rowel == null)\n-            return ret;\n-\n-        NodeList nl = rowel.getChildNodes();\n-        if (__log.isDebugEnabled()) __log.debug(\"parseXmlRow: element=\"+rowel.getLocalName());\n-        for (int i = 0; i < nl.getLength(); ++i) {\n-            Node n = nl.item(i);\n-            if (n.getNodeType() != Node.ELEMENT_NODE)\n-                continue;\n-            String key = n.getLocalName();\n-            String val = n.getTextContent();\n-            if (__log.isDebugEnabled()) __log.debug(\"Extvar key: \"+key+\" value: \"+val);\n-\n-            Column column = ret.getColumn(key);\n-            if (column == null) {\n-                if (__log.isDebugEnabled()) __log.debug(\"No matching column for key '\"+key+\"'\");\n-                continue;\n-            }\n-\n-            String nil = ((Element) n).getAttributeNS(XSI_NS, \"nil\");\n-            if (nil != null && \"true\".equalsIgnoreCase(nil) && (val == null || val.trim().length() == 0)) {\n-                if (__log.isDebugEnabled()) __log.debug(\"Extvar key: \"+key+\" is null (xsi:nil)\");\n-                ret.put(key, null);\n-            } else {\n-                ret.put(key, column.fromText(val));\n-            }\n+        continue;\n+      }\n+\n+      String nil = ((Element) n).getAttributeNS(XSI_NS, \"nil\");\n+      if (nil != null && \"true\".equalsIgnoreCase(nil) && (val == null || val.trim().length() == 0)) {\n+        if (__log.isDebugEnabled()) {\n+          __log.debug(\"Extvar key: \" + key + \" is null (xsi:nil)\");\n         }\n-        return ret;\n+        ret.put(key, null);\n+      } else {\n+        ret.put(key, column.fromText(val));\n+      }\n     }\n+    return ret;\n+  }\n \n-    class Column {\n+  class Column {\n \n-        int idx;\n+    int idx;\n \n-        /** name of the column */\n-        final String name;\n+    /**\n+     * name of the column\n+     */\n+    final String name;\n \n-        /** database name of the column (in case we need to override */\n-        final String colname;\n+    /**\n+     * database name of the column (in case we need to override\n+     */\n+    final String colname;\n \n-        /** Is this a key column? */\n-        final boolean key;\n+    /**\n+     * Is this a key column?\n+     */\n+    final boolean key;\n \n-        /** Type of value generator to use for creating values for this column. */\n-        final GenType genType;\n+    /**\n+     * Type of value generator to use for creating values for this column.\n+     */\n+    final GenType genType;\n \n-        /** The (SQL) expression used to populate the column. */\n-        final String expression;\n+    /**\n+     * The (SQL) expression used to populate the column.\n+     */\n+    final String expression;\n \n-        /** The SQL data type of this column, one of java.sql.Types */\n-        int dataType;\n+    /**\n+     * The SQL data type of this column, one of java.sql.Types\n+     */\n+    int dataType;\n \n-        /** Indicates NULL values are OK */\n-        boolean nullok;\n+    /**\n+     * Indicates NULL values are OK\n+     */\n+    boolean nullok;\n+\n+    Column(String name, String colname, boolean key, GenType genType, String expression) {\n+      this.name = name;\n+      this.colname = colname == null ? name : colname;\n+      this.key = key;\n+      this.genType = genType;\n+      this.expression = expression;\n+    }\n \n-        Column(String name, String colname, boolean key, GenType genType, String expression) {\n-            this.name = name;\n-            this.colname = colname == null ? name : colname;\n-            this.key = key;\n-            this.genType = genType;\n-            this.expression = expression;\n+    public Object getValue(String name, RowKey keys, RowVal values, Long iid) {\n+      switch (genType) {\n+      case ctimestamp:\n+      case utimestamp:\n+        return isTimeStamp() ? new Timestamp(new Date().getTime())\n+          : new Date();\n+      case uuid:\n+        return new GUID().toString();\n+      case pid:\n+        return evarId.pid.toString();\n+      case iid:\n+        return iid;\n+      case none:\n+      default:\n+        if (key && keys.get(name) != null) {\n+          return keys.get(name);\n+        } else {\n+          return values.get(name);\n         }\n+      }\n+    }\n \n-        public Object getValue(String name, RowKey keys, RowVal values, Long iid) {\n-            switch (genType) {\n-            case ctimestamp:\n-            case utimestamp:\n-                return isTimeStamp() ? new Timestamp(new Date().getTime())\n-                        : new Date();\n-            case uuid:\n-                return new GUID().toString();\n-            case pid:\n-                return evarId.pid.toString();\n-            case iid:\n-                return iid;\n-            case none:\n-            default:\n-                if (key && keys.get(name) != null)\n-                    return keys.get(name);\n-                else\n-                    return values.get(name);\n-            }\n-        }\n+    boolean supportsEmptyValue() {\n+      return (dataType == Types.VARCHAR || dataType == Types.LONGVARCHAR || dataType == Types.CLOB);\n+    }\n \n-        boolean supportsEmptyValue() {\n-            return (dataType == Types.VARCHAR || dataType == Types.LONGVARCHAR || dataType == Types.CLOB);\n-        }\n+    /**\n+     * Return <code>true</code> if column is a date-like type.\n+     */\n+    boolean isDate() {\n+      return dataType == Types.DATE;\n+    }\n \n-        /**\n-         * Return <code>true</code> if column is a date-like type.\n-         */\n-        boolean isDate() {\n-            return dataType == Types.DATE;\n-        }\n+    boolean isTimeStamp() {\n+      return dataType == Types.TIMESTAMP;\n+    }\n \n-        boolean isTimeStamp() {\n-            return dataType == Types.TIMESTAMP;\n-        }\n+    boolean isTime() {\n+      return dataType == Types.TIME;\n+    }\n \n-        boolean isTime() {\n-            return dataType == Types.TIME;\n-        }\n+    /**\n+     * Is this column best represented as an integer?\n+     */\n+    boolean isInteger() {\n+      switch (dataType) {\n+      case Types.BIGINT:\n+      case Types.INTEGER:\n+      case Types.SMALLINT:\n+      case Types.TINYINT:\n+        return true;\n+      default:\n+        return false;\n+      }\n+    }\n \n-        /**\n-         * Is this column best represented as an integer?\n-         */\n-        boolean isInteger() {\n-            switch (dataType) {\n-            case Types.BIGINT:\n-            case Types.INTEGER:\n-            case Types.SMALLINT:\n-            case Types.TINYINT:\n-                return true;\n-            default:\n-                return false;\n-            }\n-        }\n+    /**\n+     * Is this column best represented as a real number?\n+     */\n+    boolean isReal() {\n+      switch (dataType) {\n+      case Types.DECIMAL:\n+      case Types.REAL:\n+      case Types.NUMERIC:\n+        return true;\n+      default:\n+        return false;\n+      }\n+\n+    }\n \n-        /**\n-         * Is this column best represented as a real number?\n-         */\n-        boolean isReal() {\n-            switch (dataType) {\n-            case Types.DECIMAL:\n-            case Types.REAL:\n-            case Types.NUMERIC:\n-                return true;\n-            default:\n-                return false;\n-            }\n+    boolean isBoolean() {\n+      switch (dataType) {\n+      case Types.BIT:\n+        return true;\n+      default:\n+        return false;\n+      }\n+    }\n \n-        }\n+    String toText(Object val) {\n+      if (val == null) {\n+        return null;\n+      }\n+\n+      Date date = null;\n+      if (val instanceof java.util.Date) {\n+        // also applies to java.sql.Time, java.sql.Timestamp\n+        date = (Date) val;\n+        return ISO8601DateParser.format((Date) val);\n+      }\n+      return val.toString();\n+    }\n \n-        boolean isBoolean() {\n-            switch (dataType) {\n-            case Types.BIT:\n-                return true;\n-            default:\n-                return false;\n-            }\n+    Object fromText(String val) throws ExternalVariableModuleException {\n+      try {\n+        if (val == null) {\n+          return null;\n         }\n \n-        String toText(Object val) {\n-            if (val == null)\n-                return null;\n-\n-            Date date = null;\n-            if (val instanceof java.util.Date) {\n-                // also applies to java.sql.Time, java.sql.Timestamp\n-                date = (Date) val;\n-                return ISO8601DateParser.format((Date) val);\n-            }\n-            return val.toString();\n+        if (!supportsEmptyValue() && val.trim().length() == 0) {\n+          return null;\n         }\n \n-        Object fromText(String val) throws ExternalVariableModuleException {\n-            try {\n-                if (val == null)\n-                    return null;\n-\n-                if (!supportsEmptyValue() && val.trim().length() == 0) {\n-                    return null;\n-                }\n-\n-                // TODO: use xsd:date and xsd:time conversions\n-                if (isDate())\n-                    return new java.sql.Date(ISO8601DateParser.parse(val).getTime());\n-                else if (isTime())\n-                    return new java.sql.Time(ISO8601DateParser.parse(val).getTime());\n-                else if (isTimeStamp())\n-                    return new java.sql.Timestamp(ISO8601DateParser.parse(val).getTime());\n-                else if (isInteger()) {\n-                    String v = val.trim().toLowerCase();\n-                    if (v.equals(\"true\"))\n-                        return 1;\n-                    if (v.equals(\"false\"))\n-                        return 0;\n-                    return new java.math.BigDecimal(val).longValue();\n-                } else if (isReal())\n-                    return Double.valueOf(val);\n-                else if (isBoolean()) {\n-                    String v = val.trim();\n-                    if (v.equals(\"1\"))\n-                        return true;\n-                    if (v.equals(\"0\"))\n-                        return false;\n-                    return Boolean.valueOf(val);\n-                }\n-\n-                return val;\n-            } catch (Exception ex) {\n-                throw new ExternalVariableModuleException(\n-                        \"Unable to convert value \\\"\" + val + \"\\\" for column \\\"\"\n-                                + name + \"\\\" !\", ex);\n-            }\n+        // TODO: use xsd:date and xsd:time conversions\n+        if (isDate()) {\n+          return new java.sql.Date(ISO8601DateParser.parse(val).getTime());\n+        } else if (isTime()) {\n+          return new java.sql.Time(ISO8601DateParser.parse(val).getTime());\n+        } else if (isTimeStamp()) {\n+          return new java.sql.Timestamp(ISO8601DateParser.parse(val).getTime());\n+        } else if (isInteger()) {\n+          String v = val.trim().toLowerCase();\n+          if (v.equals(\"true\")) {\n+            return 1;\n+          }\n+          if (v.equals(\"false\")) {\n+            return 0;\n+          }\n+          return new java.math.BigDecimal(val).longValue();\n+        } else if (isReal()) {\n+          return Double.valueOf(val);\n+        } else if (isBoolean()) {\n+          String v = val.trim();\n+          if (v.equals(\"1\")) {\n+            return true;\n+          }\n+          if (v.equals(\"0\")) {\n+            return false;\n+          }\n+          return Boolean.valueOf(val);\n         }\n \n-        public boolean isGenerated() {\n-            return (genType != null && !genType.equals(GenType.none));\n-        }\n+        return val;\n+      } catch (Exception ex) {\n+        throw new ExternalVariableModuleException(\n+          \"Unable to convert value \\\"\" + val + \"\\\" for column \\\"\"\n+            + name + \"\\\" !\", ex);\n+      }\n+    }\n \n-        public boolean isDatabaseGenerated() {\n-            return isGenerated() && (genType.equals(GenType.sequence) || genType.equals(GenType.expression));\n-        }\n+    public boolean isGenerated() {\n+      return (genType != null && !genType.equals(GenType.none));\n+    }\n \n-        public String toString() {\n-            return \"Column {idx=\"+idx\n-                +\",name=\"+name\n-                +\",colname=\"+colname\n-                +\",key=\"+key\n-                +\",genType=\"+genType\n-                +\")\";\n-        }\n+    public boolean isDatabaseGenerated() {\n+      return isGenerated() && (genType.equals(GenType.sequence) || genType.equals(GenType.expression));\n     }\n \n-    /**\n-     * Key used to identify a row.\n-     */\n-    class RowKey extends RowSubset {\n-        private static final long serialVersionUID = 1L;\n-\n-        /**\n-         * Create empty row key.\n-         */\n-        RowKey() {\n-            super(_keycolumns);\n-        }\n+    public String toString() {\n+      return \"Column {idx=\" + idx\n+        + \",name=\" + name\n+        + \",colname=\" + colname\n+        + \",key=\" + key\n+        + \",genType=\" + genType\n+        + \")\";\n+    }\n+  }\n \n-        /**\n-         * Write the key to a locator.\n-         */\n-        void write(QName varType, Locator locator) throws ExternalVariableModuleException {\n-            locator.reference = renderXmlRow(locator, varType, this);\n-        }\n+  /**\n+   * Key used to identify a row.\n+   */\n+  class RowKey extends RowSubset {\n+    private static final long serialVersionUID = 1L;\n \n-        public Set<String> getMissing() {\n-            HashSet<String> missing = new HashSet<String>();\n-            for (Column c : _keycolumns) {\n-                if (get(c.idx) == null)\n-                    missing.add(c.name);\n-            }\n-            return missing;\n-        }\n+    /**\n+     * Create empty row key.\n+     */\n+    RowKey() {\n+      super(_keycolumns);\n     }\n \n     /**\n-     * Row values.\n+     * Write the key to a locator.\n      */\n-    class RowVal extends RowSubset {\n-        private static final long serialVersionUID = 1L;\n+    void write(QName varType, Locator locator) throws ExternalVariableModuleException {\n+      locator.reference = renderXmlRow(locator, varType, this);\n+    }\n \n-        RowVal() {\n-            super(DbExternalVariable.this._columns);\n+    public Set<String> getMissing() {\n+      HashSet<String> missing = new HashSet<String>();\n+      for (Column c : _keycolumns) {\n+        if (get(c.idx) == null) {\n+          missing.add(c.name);\n         }\n+      }\n+      return missing;\n+    }\n+  }\n+\n+  /**\n+   * Row values.\n+   */\n+  class RowVal extends RowSubset {\n+    private static final long serialVersionUID = 1L;\n+\n+    RowVal() {\n+      super(DbExternalVariable.this._columns);\n     }\n+  }\n \n }\n",
            "diff_size": 649
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "255",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/256/DbExternalVariable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/256/DbExternalVariable.java\nindex 8f14f872cf8..0799abf1cf8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/256/DbExternalVariable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/256/DbExternalVariable.java\n@@ -353,8 +353,7 @@ class DbExternalVariable {\n             switch (genType) {\n             case ctimestamp:\n             case utimestamp:\n-                return isTimeStamp() ? new Timestamp(new Date().getTime())\n-                        : new Date();\n+                return isTimeStamp() ? new Timestamp(new Date().getTime()) : new Date();\n             case uuid:\n                 return new GUID().toString();\n             case pid:\n@@ -480,7 +479,7 @@ class DbExternalVariable {\n                 throw new ExternalVariableModuleException(\n                         \"Unable to convert value \\\"\" + val + \"\\\" for column \\\"\"\n                                 + name + \"\\\" !\", ex);\n-            }\n+    }\n         }\n \n         public boolean isGenerated() {\n@@ -492,12 +491,7 @@ class DbExternalVariable {\n         }\n \n         public String toString() {\n-            return \"Column {idx=\"+idx\n-                +\",name=\"+name\n-                +\",colname=\"+colname\n-                +\",key=\"+key\n-                +\",genType=\"+genType\n-                +\")\";\n+            return \"Column {idx=\"+idx+\",name=\"+name+\",colname=\"+colname+\",key=\"+key+\",genType=\"+genType+\")\";\n         }\n     }\n \n@@ -542,4 +536,4 @@ class DbExternalVariable {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 10
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "255",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/256/DbExternalVariable.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/256/DbExternalVariable.java\nindex 8f14f872cf8..4ea0fc9a96d 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/256/DbExternalVariable.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/styler_three_grams/256/DbExternalVariable.java\n@@ -252,8 +252,9 @@ class DbExternalVariable {\n \n     }\n \n-    <T extends RowSubset> Element renderXmlRow(Locator locator, QName varType, T value) throws ExternalVariableModuleException {\n-        Document doc = DOMUtils.newDocument();\n+    <T extends RowSubset> Element renderXmlRow(Locator locator, QName varType,\n+            T value) throws ExternalVariableModuleException {\n+         Document doc = DOMUtils.newDocument();\n         Element el = doc.createElementNS(varType.getNamespaceURI(), varType.getLocalPart());\n         doc.appendChild(el);\n         if (value != null) {\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}