{
    "project_name": "vostok-hercules",
    "error_id": "38",
    "information": {
        "errors": [
            {
                "line": "178",
                "column": "52",
                "severity": "warning",
                "message": "'{' is not followed by whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
            }
        ]
    },
    "source_code": "                            for (ConsumerRecord<UUID, Event> record : records) {\n                                Event event = record.value();\n                                if (event == null) {// Received non-deserializable data, should be ignored\n                                    droppedEvents++;\n                                    continue;\n                                }",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/38/Sink.java\nindex 7e1865e28f4..c50afdf054b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler/38/Sink.java\n@@ -175,7 +175,7 @@ public class Sink {\n                             List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                             for (ConsumerRecord<UUID, Event> record : records) {\n                                 Event event = record.value();\n-                                if (event == null) {// Received non-deserializable data, should be ignored\n+                                if (event == null) { // Received non-deserializable data, should be ignored\n                                     droppedEvents++;\n                                     continue;\n                                 }\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "178",
                    "column": "36",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/38/Sink.java\nindex 7e1865e28f4..fbb4270d2fa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/intellij/38/Sink.java\n@@ -37,240 +37,240 @@ import java.util.regex.Pattern;\n  * @author Gregory Koshelev\n  */\n public class Sink {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(Sink.class);\n-\n-    private volatile boolean running = false;\n-\n-    private final ExecutorService executor;\n-    private final String applicationId;\n-    private final Properties properties;\n-    private final Processor processor;\n-    private final List<PatternMatcher> patternMatchers;\n-\n-    private final Duration pollTimeout;\n-    private final int batchSize;\n-    private final long availabilityTimeoutMs;\n-\n-    private final Pattern pattern;\n-    private final KafkaConsumer<UUID, Event> consumer;\n-\n-    private final Meter droppedEventsMeter;\n-    private final Meter processedEventsMeter;\n-    private final Meter rejectedEventsMeter;\n-    private final Meter totalEventsMeter;\n-\n-    public Sink(\n-            ExecutorService executor,\n-            String applicationId,\n-            Properties properties,\n-            Processor processor,\n-            List<PatternMatcher> patternMatchers,\n-            EventDeserializer deserializer,\n-            MetricsCollector metricsCollector) {\n-        this.executor = executor;\n-        this.applicationId = applicationId;\n-        this.properties = properties;\n-        this.processor = processor;\n-        this.patternMatchers = patternMatchers;\n-\n-        this.pollTimeout = Duration.ofMillis(Props.POLL_TIMEOUT_MS.extract(properties));\n-        this.batchSize = Props.BATCH_SIZE.extract(properties);\n-        this.availabilityTimeoutMs = Props.AVAILABILITY_TIMEOUT_MS.extract(properties);\n-\n-        String consumerGroupId = Props.GROUP_ID.extract(properties);\n-        if (StringUtil.isNullOrEmpty(consumerGroupId)) {\n-            consumerGroupId = ConsumerUtil.toGroupId(applicationId, patternMatchers);\n-        }\n-\n-        this.pattern = PatternMatcher.matcherListToRegexp(patternMatchers);\n+  private static final Logger LOGGER = LoggerFactory.getLogger(Sink.class);\n+\n+  private volatile boolean running = false;\n+\n+  private final ExecutorService executor;\n+  private final String applicationId;\n+  private final Properties properties;\n+  private final Processor processor;\n+  private final List<PatternMatcher> patternMatchers;\n+\n+  private final Duration pollTimeout;\n+  private final int batchSize;\n+  private final long availabilityTimeoutMs;\n+\n+  private final Pattern pattern;\n+  private final KafkaConsumer<UUID, Event> consumer;\n+\n+  private final Meter droppedEventsMeter;\n+  private final Meter processedEventsMeter;\n+  private final Meter rejectedEventsMeter;\n+  private final Meter totalEventsMeter;\n+\n+  public Sink(\n+    ExecutorService executor,\n+    String applicationId,\n+    Properties properties,\n+    Processor processor,\n+    List<PatternMatcher> patternMatchers,\n+    EventDeserializer deserializer,\n+    MetricsCollector metricsCollector) {\n+    this.executor = executor;\n+    this.applicationId = applicationId;\n+    this.properties = properties;\n+    this.processor = processor;\n+    this.patternMatchers = patternMatchers;\n+\n+    this.pollTimeout = Duration.ofMillis(Props.POLL_TIMEOUT_MS.extract(properties));\n+    this.batchSize = Props.BATCH_SIZE.extract(properties);\n+    this.availabilityTimeoutMs = Props.AVAILABILITY_TIMEOUT_MS.extract(properties);\n+\n+    String consumerGroupId = Props.GROUP_ID.extract(properties);\n+    if (StringUtil.isNullOrEmpty(consumerGroupId)) {\n+      consumerGroupId = ConsumerUtil.toGroupId(applicationId, patternMatchers);\n+    }\n \n-        Properties consumerProperties = PropertiesUtil.ofScope(properties, Scopes.CONSUMER);\n-        consumerProperties.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId);\n-        consumerProperties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);\n-        consumerProperties.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, batchSize);\n-        consumerProperties.put(KafkaConfigs.METRICS_COLLECTOR_INSTANCE_CONFIG, metricsCollector);\n+    this.pattern = PatternMatcher.matcherListToRegexp(patternMatchers);\n \n-        UuidDeserializer keyDeserializer = new UuidDeserializer();\n-        EventDeserializer valueDeserializer = deserializer;\n+    Properties consumerProperties = PropertiesUtil.ofScope(properties, Scopes.CONSUMER);\n+    consumerProperties.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId);\n+    consumerProperties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);\n+    consumerProperties.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, batchSize);\n+    consumerProperties.put(KafkaConfigs.METRICS_COLLECTOR_INSTANCE_CONFIG, metricsCollector);\n \n-        this.consumer = new KafkaConsumer<>(consumerProperties, keyDeserializer, valueDeserializer);\n+    UuidDeserializer keyDeserializer = new UuidDeserializer();\n+    EventDeserializer valueDeserializer = deserializer;\n \n-        droppedEventsMeter = metricsCollector.meter(\"droppedEvents\");\n-        processedEventsMeter = metricsCollector.meter(\"processedEvents\");\n-        rejectedEventsMeter = metricsCollector.meter(\"rejectedEvents\");\n-        totalEventsMeter = metricsCollector.meter(\"totalEvents\");\n-    }\n+    this.consumer = new KafkaConsumer<>(consumerProperties, keyDeserializer, valueDeserializer);\n \n-    /**\n-     * Start sink.\n-     */\n-    public final void start() {\n-        running = true;\n+    droppedEventsMeter = metricsCollector.meter(\"droppedEvents\");\n+    processedEventsMeter = metricsCollector.meter(\"processedEvents\");\n+    rejectedEventsMeter = metricsCollector.meter(\"rejectedEvents\");\n+    totalEventsMeter = metricsCollector.meter(\"totalEvents\");\n+  }\n \n-        executor.execute(this::run);\n-    }\n+  /**\n+   * Start sink.\n+   */\n+  public final void start() {\n+    running = true;\n \n-    /**\n-     * Stop Sink.\n-     */\n-    public final void stop() {\n-        running = false;\n+    executor.execute(this::run);\n+  }\n \n-        try {\n-            consumer.wakeup();\n-        } catch (Exception ex) {\n-            /* ignore */\n-        }\n+  /**\n+   * Stop Sink.\n+   */\n+  public final void stop() {\n+    running = false;\n \n-        try {\n-            consumer.close();\n-        } catch (Exception ex) {\n-            /* ignore */\n-        }\n-\n-        postStop();\n+    try {\n+      consumer.wakeup();\n+    } catch (Exception ex) {\n+      /* ignore */\n     }\n \n-    /**\n-     * Check Sink running status.\n-     *\n-     * @return {@code true} if Sink is running and {@code false} if Sink is stopping\n-     */\n-    public final boolean isRunning() {\n-        return running;\n+    try {\n+      consumer.close();\n+    } catch (Exception ex) {\n+      /* ignore */\n     }\n \n-    /**\n-     * Main Sink logic. Sink poll events from Kafka and processes them using {@link Processor} if possible.\n-     * <p>\n-     * Sink awaits availability of {@link Processor}. Also, it controls {@link #isRunning()} during operations.\n-     */\n-    public final void run() {\n-        while (isRunning()) {\n-            if (processor.isAvailable()) {\n-                try {\n-\n-                    subscribe();\n-\n-                    while (processor.isAvailable()) {\n-                        ConsumerRecords<UUID, Event> pollResult;\n-                        try {\n-                            pollResult = poll();\n-                        } catch (WakeupException ex) {\n-                            /*\n-                             * WakeupException is used to terminate polling\n-                             */\n-                            return;\n-                        }\n-\n-                        Set<TopicPartition> partitions = pollResult.partitions();\n-\n-                        // ConsumerRecords::count works for O(n), where n is partition count\n-                        int eventCount = pollResult.count();\n-                        List<Event> events = new ArrayList<>(eventCount);\n-\n-                        int droppedEvents = 0;\n-\n-                        for (TopicPartition partition : partitions) {\n-                            List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n-                            for (ConsumerRecord<UUID, Event> record : records) {\n-                                Event event = record.value();\n-                                if (event == null) {// Received non-deserializable data, should be ignored\n-                                    droppedEvents++;\n-                                    continue;\n-                                }\n-                                events.add(event);\n-                            }\n-                        }\n-\n-                        ProcessorResult result = processor.process(events);\n-                        if (result.isSuccess()) {\n-                            try {\n-                                commit();\n-                                droppedEventsMeter.mark(droppedEvents);\n-                                processedEventsMeter.mark(result.getProcessedEvents());\n-                                rejectedEventsMeter.mark(result.getRejectedEvents());\n-                                totalEventsMeter.mark(events.size());\n-                            } catch (CommitFailedException ex) {\n-                                LOGGER.warn(\"Commit failed due to rebalancing\", ex);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                } catch (Exception ex) {\n-                    LOGGER.error(\"Unspecified exception has been acquired\", ex);\n-                } finally {\n-                    unsubscribe();\n-                }\n+    postStop();\n+  }\n+\n+  /**\n+   * Check Sink running status.\n+   *\n+   * @return {@code true} if Sink is running and {@code false} if Sink is stopping\n+   */\n+  public final boolean isRunning() {\n+    return running;\n+  }\n+\n+  /**\n+   * Main Sink logic. Sink poll events from Kafka and processes them using {@link Processor} if possible.\n+   * <p>\n+   * Sink awaits availability of {@link Processor}. Also, it controls {@link #isRunning()} during operations.\n+   */\n+  public final void run() {\n+    while (isRunning()) {\n+      if (processor.isAvailable()) {\n+        try {\n+\n+          subscribe();\n+\n+          while (processor.isAvailable()) {\n+            ConsumerRecords<UUID, Event> pollResult;\n+            try {\n+              pollResult = poll();\n+            } catch (WakeupException ex) {\n+              /*\n+               * WakeupException is used to terminate polling\n+               */\n+              return;\n             }\n \n-            processor.awaitAvailability(availabilityTimeoutMs);\n-        }\n-    }\n+            Set<TopicPartition> partitions = pollResult.partitions();\n \n-    /**\n-     * Perform additional stop operations when Event consuming was terminated.\n-     */\n-    protected void postStop() {\n+            // ConsumerRecords::count works for O(n), where n is partition count\n+            int eventCount = pollResult.count();\n+            List<Event> events = new ArrayList<>(eventCount);\n \n-    }\n+            int droppedEvents = 0;\n \n-    /**\n-     * Subscribe Sink. Should be called before polling\n-     */\n-    protected final void subscribe() {\n-        consumer.subscribe(pattern);\n-    }\n+            for (TopicPartition partition : partitions) {\n+              List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n+              for (ConsumerRecord<UUID, Event> record : records) {\n+                Event event = record.value();\n+                if (event == null) {// Received non-deserializable data, should be ignored\n+                  droppedEvents++;\n+                  continue;\n+                }\n+                events.add(event);\n+              }\n+            }\n \n-    /**\n-     * Unsubscribe Sink. Should be called if Sink cannot process Events.\n-     */\n-    protected final void unsubscribe() {\n-        LOGGER.debug(\"Sink unsubscribe if any\");\n-        try {\n-            consumer.unsubscribe();\n+            ProcessorResult result = processor.process(events);\n+            if (result.isSuccess()) {\n+              try {\n+                commit();\n+                droppedEventsMeter.mark(droppedEvents);\n+                processedEventsMeter.mark(result.getProcessedEvents());\n+                rejectedEventsMeter.mark(result.getRejectedEvents());\n+                totalEventsMeter.mark(events.size());\n+              } catch (CommitFailedException ex) {\n+                LOGGER.warn(\"Commit failed due to rebalancing\", ex);\n+                continue;\n+              }\n+            }\n+          }\n         } catch (Exception ex) {\n-            /* ignore */\n+          LOGGER.error(\"Unspecified exception has been acquired\", ex);\n+        } finally {\n+          unsubscribe();\n         }\n-    }\n-\n-    /**\n-     * Poll Events from Kafka. Should be called when Sink subscribed.\n-     *\n-     * @return polled Events\n-     * @throws WakeupException if poll terminated due to shutdown\n-     */\n-    protected final ConsumerRecords<UUID, Event> poll() throws WakeupException {\n-        return consumer.poll(pollTimeout);\n-    }\n+      }\n \n-    protected final void commit() {\n-        consumer.commitSync();\n+      processor.awaitAvailability(availabilityTimeoutMs);\n     }\n-\n-    protected final void commit(Map<TopicPartition, OffsetAndMetadata> offsets) {\n-        consumer.commitSync(offsets);\n-    }\n-\n-    private static class Props {\n-        static final PropertyDescription<Long> POLL_TIMEOUT_MS =\n-                PropertyDescriptions.longProperty(\"pollTimeoutMs\").\n-                        withDefaultValue(6_000L).\n-                        build();\n-\n-        static final PropertyDescription<Integer> BATCH_SIZE =\n-                PropertyDescriptions.integerProperty(\"batchSize\").\n-                        withDefaultValue(1000).\n-                        build();\n-\n-        static final PropertyDescription<String> GROUP_ID =\n-                PropertyDescriptions.stringProperty(\"groupId\").\n-                        withDefaultValue(null).\n-                        build();\n-\n-        static final PropertyDescription<Long> AVAILABILITY_TIMEOUT_MS =\n-                PropertyDescriptions.longProperty(\"availabilityTimeoutMs\").\n-                        withDefaultValue(2_000L).\n-                        build();\n+  }\n+\n+  /**\n+   * Perform additional stop operations when Event consuming was terminated.\n+   */\n+  protected void postStop() {\n+\n+  }\n+\n+  /**\n+   * Subscribe Sink. Should be called before polling\n+   */\n+  protected final void subscribe() {\n+    consumer.subscribe(pattern);\n+  }\n+\n+  /**\n+   * Unsubscribe Sink. Should be called if Sink cannot process Events.\n+   */\n+  protected final void unsubscribe() {\n+    LOGGER.debug(\"Sink unsubscribe if any\");\n+    try {\n+      consumer.unsubscribe();\n+    } catch (Exception ex) {\n+      /* ignore */\n     }\n+  }\n+\n+  /**\n+   * Poll Events from Kafka. Should be called when Sink subscribed.\n+   *\n+   * @return polled Events\n+   * @throws WakeupException if poll terminated due to shutdown\n+   */\n+  protected final ConsumerRecords<UUID, Event> poll() throws WakeupException {\n+    return consumer.poll(pollTimeout);\n+  }\n+\n+  protected final void commit() {\n+    consumer.commitSync();\n+  }\n+\n+  protected final void commit(Map<TopicPartition, OffsetAndMetadata> offsets) {\n+    consumer.commitSync(offsets);\n+  }\n+\n+  private static class Props {\n+    static final PropertyDescription<Long> POLL_TIMEOUT_MS =\n+      PropertyDescriptions.longProperty(\"pollTimeoutMs\").\n+        withDefaultValue(6_000L).\n+        build();\n+\n+    static final PropertyDescription<Integer> BATCH_SIZE =\n+      PropertyDescriptions.integerProperty(\"batchSize\").\n+        withDefaultValue(1000).\n+        build();\n+\n+    static final PropertyDescription<String> GROUP_ID =\n+      PropertyDescriptions.stringProperty(\"groupId\").\n+        withDefaultValue(null).\n+        build();\n+\n+    static final PropertyDescription<Long> AVAILABILITY_TIMEOUT_MS =\n+      PropertyDescriptions.longProperty(\"availabilityTimeoutMs\").\n+        withDefaultValue(2_000L).\n+        build();\n+  }\n }\n",
            "diff_size": 274
        },
        {
            "tool": "naturalize",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/38/Sink.java\nindex 7e1865e28f4..35991809bfa 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/naturalize/38/Sink.java\n@@ -67,7 +67,7 @@ public class Sink {\n             List<PatternMatcher> patternMatchers,\n             EventDeserializer deserializer,\n             MetricsCollector metricsCollector) {\n-        this.executor = executor;\n+    this.executor = executor;\n         this.applicationId = applicationId;\n         this.properties = properties;\n         this.processor = processor;\n@@ -149,8 +149,7 @@ public class Sink {\n         while (isRunning()) {\n             if (processor.isAvailable()) {\n                 try {\n-\n-                    subscribe();\n+    subscribe();\n \n                     while (processor.isAvailable()) {\n                         ConsumerRecords<UUID, Event> pollResult;\n@@ -175,7 +174,7 @@ public class Sink {\n                             List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                             for (ConsumerRecord<UUID, Event> record : records) {\n                                 Event event = record.value();\n-                                if (event == null) {// Received non-deserializable data, should be ignored\n+                                if (event == null) { // Received non-deserializable data, should be ignored\n                                     droppedEvents++;\n                                     continue;\n                                 }\n@@ -254,23 +253,15 @@ public class Sink {\n \n     private static class Props {\n         static final PropertyDescription<Long> POLL_TIMEOUT_MS =\n-                PropertyDescriptions.longProperty(\"pollTimeoutMs\").\n-                        withDefaultValue(6_000L).\n-                        build();\n+                PropertyDescriptions.longProperty(\"pollTimeoutMs\").withDefaultValue(6_000L).build();\n \n         static final PropertyDescription<Integer> BATCH_SIZE =\n-                PropertyDescriptions.integerProperty(\"batchSize\").\n-                        withDefaultValue(1000).\n-                        build();\n+                PropertyDescriptions.integerProperty(\"batchSize\").withDefaultValue(1000).build();\n \n         static final PropertyDescription<String> GROUP_ID =\n-                PropertyDescriptions.stringProperty(\"groupId\").\n-                        withDefaultValue(null).\n-                        build();\n+                PropertyDescriptions.stringProperty(\"groupId\").withDefaultValue(null).build();\n \n         static final PropertyDescription<Long> AVAILABILITY_TIMEOUT_MS =\n-                PropertyDescriptions.longProperty(\"availabilityTimeoutMs\").\n-                        withDefaultValue(2_000L).\n-                        build();\n+                PropertyDescriptions.longProperty(\"availabilityTimeoutMs\").withDefaultValue(2_000L).build();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 17
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "174",
                    "column": "52",
                    "severity": "warning",
                    "message": "'{' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/38/Sink.java\nindex 7e1865e28f4..c5149ca1bc2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/codebuff/38/Sink.java\n@@ -22,7 +22,6 @@ import ru.kontur.vostok.hercules.util.PatternMatcher;\n import ru.kontur.vostok.hercules.util.properties.PropertyDescription;\n import ru.kontur.vostok.hercules.util.properties.PropertyDescriptions;\n import ru.kontur.vostok.hercules.util.text.StringUtil;\n-\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n@@ -36,43 +35,40 @@ import java.util.regex.Pattern;\n /**\n  * @author Gregory Koshelev\n  */\n+\n+\n public class Sink {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(Sink.class);\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(Sink.class);\n     private volatile boolean running = false;\n-\n     private final ExecutorService executor;\n     private final String applicationId;\n     private final Properties properties;\n     private final Processor processor;\n     private final List<PatternMatcher> patternMatchers;\n-\n     private final Duration pollTimeout;\n     private final int batchSize;\n     private final long availabilityTimeoutMs;\n-\n     private final Pattern pattern;\n     private final KafkaConsumer<UUID, Event> consumer;\n-\n     private final Meter droppedEventsMeter;\n     private final Meter processedEventsMeter;\n     private final Meter rejectedEventsMeter;\n     private final Meter totalEventsMeter;\n \n     public Sink(\n-            ExecutorService executor,\n-            String applicationId,\n-            Properties properties,\n-            Processor processor,\n-            List<PatternMatcher> patternMatchers,\n-            EventDeserializer deserializer,\n-            MetricsCollector metricsCollector) {\n+        ExecutorService executor,\n+        String applicationId,\n+        Properties properties,\n+        Processor processor,\n+        List<PatternMatcher> patternMatchers,\n+        EventDeserializer deserializer, MetricsCollector metricsCollector\n+    ) {\n         this.executor = executor;\n         this.applicationId = applicationId;\n         this.properties = properties;\n         this.processor = processor;\n         this.patternMatchers = patternMatchers;\n-\n         this.pollTimeout = Duration.ofMillis(Props.POLL_TIMEOUT_MS.extract(properties));\n         this.batchSize = Props.BATCH_SIZE.extract(properties);\n         this.availabilityTimeoutMs = Props.AVAILABILITY_TIMEOUT_MS.extract(properties);\n@@ -92,9 +88,7 @@ public class Sink {\n \n         UuidDeserializer keyDeserializer = new UuidDeserializer();\n         EventDeserializer valueDeserializer = deserializer;\n-\n         this.consumer = new KafkaConsumer<>(consumerProperties, keyDeserializer, valueDeserializer);\n-\n         droppedEventsMeter = metricsCollector.meter(\"droppedEvents\");\n         processedEventsMeter = metricsCollector.meter(\"processedEvents\");\n         rejectedEventsMeter = metricsCollector.meter(\"rejectedEvents\");\n@@ -104,15 +98,16 @@ public class Sink {\n     /**\n      * Start sink.\n      */\n+\n     public final void start() {\n         running = true;\n-\n         executor.execute(this::run);\n     }\n \n     /**\n      * Stop Sink.\n      */\n+\n     public final void stop() {\n         running = false;\n \n@@ -120,12 +115,14 @@ public class Sink {\n             consumer.wakeup();\n         } catch (Exception ex) {\n             /* ignore */\n+\n         }\n \n         try {\n             consumer.close();\n         } catch (Exception ex) {\n             /* ignore */\n+\n         }\n \n         postStop();\n@@ -136,6 +133,7 @@ public class Sink {\n      *\n      * @return {@code true} if Sink is running and {@code false} if Sink is stopping\n      */\n+\n     public final boolean isRunning() {\n         return running;\n     }\n@@ -145,11 +143,11 @@ public class Sink {\n      * <p>\n      * Sink awaits availability of {@link Processor}. Also, it controls {@link #isRunning()} during operations.\n      */\n+\n     public final void run() {\n         while (isRunning()) {\n             if (processor.isAvailable()) {\n                 try {\n-\n                     subscribe();\n \n                     while (processor.isAvailable()) {\n@@ -168,9 +166,7 @@ public class Sink {\n                         // ConsumerRecords::count works for O(n), where n is partition count\n                         int eventCount = pollResult.count();\n                         List<Event> events = new ArrayList<>(eventCount);\n-\n                         int droppedEvents = 0;\n-\n                         for (TopicPartition partition : partitions) {\n                             List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                             for (ConsumerRecord<UUID, Event> record : records) {\n@@ -179,6 +175,7 @@ public class Sink {\n                                     droppedEvents++;\n                                     continue;\n                                 }\n+\n                                 events.add(event);\n                             }\n                         }\n@@ -211,6 +208,7 @@ public class Sink {\n     /**\n      * Perform additional stop operations when Event consuming was terminated.\n      */\n+\n     protected void postStop() {\n \n     }\n@@ -218,6 +216,7 @@ public class Sink {\n     /**\n      * Subscribe Sink. Should be called before polling\n      */\n+\n     protected final void subscribe() {\n         consumer.subscribe(pattern);\n     }\n@@ -225,12 +224,15 @@ public class Sink {\n     /**\n      * Unsubscribe Sink. Should be called if Sink cannot process Events.\n      */\n+\n     protected final void unsubscribe() {\n         LOGGER.debug(\"Sink unsubscribe if any\");\n+\n         try {\n             consumer.unsubscribe();\n         } catch (Exception ex) {\n             /* ignore */\n+\n         }\n     }\n \n@@ -240,6 +242,7 @@ public class Sink {\n      * @return polled Events\n      * @throws WakeupException if poll terminated due to shutdown\n      */\n+\n     protected final ConsumerRecords<UUID, Event> poll() throws WakeupException {\n         return consumer.poll(pollTimeout);\n     }\n@@ -253,24 +256,20 @@ public class Sink {\n     }\n \n     private static class Props {\n-        static final PropertyDescription<Long> POLL_TIMEOUT_MS =\n-                PropertyDescriptions.longProperty(\"pollTimeoutMs\").\n-                        withDefaultValue(6_000L).\n-                        build();\n-\n-        static final PropertyDescription<Integer> BATCH_SIZE =\n-                PropertyDescriptions.integerProperty(\"batchSize\").\n-                        withDefaultValue(1000).\n-                        build();\n-\n-        static final PropertyDescription<String> GROUP_ID =\n-                PropertyDescriptions.stringProperty(\"groupId\").\n-                        withDefaultValue(null).\n-                        build();\n-\n-        static final PropertyDescription<Long> AVAILABILITY_TIMEOUT_MS =\n-                PropertyDescriptions.longProperty(\"availabilityTimeoutMs\").\n-                        withDefaultValue(2_000L).\n-                        build();\n+        static final PropertyDescription<Long> POLL_TIMEOUT_MS = PropertyDescriptions.longProperty(\"pollTimeoutMs\")\n+        .withDefaultValue(6_000L)\n+        .build();\n+\n+        static final PropertyDescription<Integer> BATCH_SIZE = PropertyDescriptions.integerProperty(\"batchSize\")\n+        .withDefaultValue(1000)\n+        .build();\n+\n+        static final PropertyDescription<String> GROUP_ID = PropertyDescriptions.stringProperty(\"groupId\")\n+        .withDefaultValue(null)\n+        .build();\n+\n+        static final PropertyDescription<Long> AVAILABILITY_TIMEOUT_MS = PropertyDescriptions.longProperty(\"availabilityTimeoutMs\")\n+        .withDefaultValue(2_000L)\n+        .build();\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 56
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/38/Sink.java\nindex 7e1865e28f4..c50afdf054b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_random/38/Sink.java\n@@ -175,7 +175,7 @@ public class Sink {\n                             List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                             for (ConsumerRecord<UUID, Event> record : records) {\n                                 Event event = record.value();\n-                                if (event == null) {// Received non-deserializable data, should be ignored\n+                                if (event == null) { // Received non-deserializable data, should be ignored\n                                     droppedEvents++;\n                                     continue;\n                                 }\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/38/Sink.java\nindex 7e1865e28f4..c50afdf054b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/errored/1/38/Sink.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/vostok-hercules/styler_three_grams/38/Sink.java\n@@ -175,7 +175,7 @@ public class Sink {\n                             List<ConsumerRecord<UUID, Event>> records = pollResult.records(partition);\n                             for (ConsumerRecord<UUID, Event> record : records) {\n                                 Event event = record.value();\n-                                if (event == null) {// Received non-deserializable data, should be ignored\n+                                if (event == null) { // Received non-deserializable data, should be ignored\n                                     droppedEvents++;\n                                     continue;\n                                 }\n",
            "diff_size": 1
        }
    ],
    "repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "codebuff"
    ]
}