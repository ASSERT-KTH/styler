{
    "project_name": "IQSS-dataverse",
    "error_id": "3",
    "information": {
        "errors": [
            {
                "line": "402",
                "column": "1",
                "severity": "error",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "    \n\n\tpublic boolean runReplaceFile(Long oldFileId,\n                            String newFileName, \n                            String newFileContentType, \n                            String newStorageIdentifier, ",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "566",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/3/AddReplaceFileHelper.java\nindex d01e9b4e2f3..ccee47f6ba7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler/3/AddReplaceFileHelper.java\n@@ -397,9 +397,8 @@ public class AddReplaceFileHelper{\n         \n         return this.runAddReplaceFile(fileToReplace.getOwner(), newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n     }\n-    \n \n-\tpublic boolean runReplaceFile(Long oldFileId,\n+     public boolean runReplaceFile(Long oldFileId,\n                             String newFileName, \n                             String newFileContentType, \n                             String newStorageIdentifier, \n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/3/AddReplaceFileHelper.java\nindex d01e9b4e2f3..4711677cd89 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/intellij/3/AddReplaceFileHelper.java\n@@ -3,6 +3,7 @@\n  * To change this template file, choose Tools | Templates\n  * and open the template in the editor.\n  */\n+\n package edu.harvard.iq.dataverse.datasetutility;\n \n import edu.harvard.iq.dataverse.DataFile;\n@@ -50,297 +51,294 @@ import org.apache.commons.io.IOUtils;\n import org.ocpsoft.common.util.Strings;\n \n /**\n- *  Methods to add or replace a single file.\n- * \n- *  Usage example:\n- *\n+ * Methods to add or replace a single file.\n+ * <p>\n+ * Usage example:\n+ * <p>\n  * // (1) Instantiate the class\n- * \n- *  AddReplaceFileHelper addFileHelper = new AddReplaceFileHelper(dvRequest2,\n- *                                               this.ingestService,\n- *                                               this.datasetService,\n- *                                               this.fileService,\n- *                                               this.permissionSvc,\n- *                                               this.commandEngine);\n- * \n+ * <p>\n+ * AddReplaceFileHelper addFileHelper = new AddReplaceFileHelper(dvRequest2,\n+ * this.ingestService,\n+ * this.datasetService,\n+ * this.fileService,\n+ * this.permissionSvc,\n+ * this.commandEngine);\n+ * <p>\n  * // (2) Run file \"ADD\"\n- *\n- *  addFileHelper.runAddFileByDatasetId(datasetId,\n- *                               newFileName,\n- *                               newFileContentType,\n- *                               newFileInputStream);\n- *  // (2a) Check for errors\n- *  if (addFileHelper.hasError()){\n- *      // get some errors\n- *      System.out.println(addFileHelper.getErrorMessagesAsString(\"\\n\"));\n- *  }\n- * \n- *\n+ * <p>\n+ * addFileHelper.runAddFileByDatasetId(datasetId,\n+ * newFileName,\n+ * newFileContentType,\n+ * newFileInputStream);\n+ * // (2a) Check for errors\n+ * if (addFileHelper.hasError()){\n+ * // get some errors\n+ * System.out.println(addFileHelper.getErrorMessagesAsString(\"\\n\"));\n+ * }\n+ * <p>\n+ * <p>\n  * // OR (3) Run file \"REPLACE\"\n+ * <p>\n+ * addFileHelper.runReplaceFile(datasetId,\n+ * newFileName,\n+ * newFileContentType,\n+ * newFileInputStream,\n+ * fileToReplaceId);\n+ * // (2a) Check for errors\n+ * if (addFileHelper.hasError()){\n+ * // get some errors\n+ * System.out.println(addFileHelper.getErrorMessagesAsString(\"\\n\"));\n+ * }\n  *\n- *  addFileHelper.runReplaceFile(datasetId,\n- *                               newFileName,\n- *                               newFileContentType,\n- *                               newFileInputStream,\n- *                               fileToReplaceId);\n- *  // (2a) Check for errors\n- *  if (addFileHelper.hasError()){\n- *      // get some errors\n- *      System.out.println(addFileHelper.getErrorMessagesAsString(\"\\n\"));\n- *  }\n- *\n- * \n- * \n  * @author rmp553\n  */\n-public class AddReplaceFileHelper{\n-    \n-    private static final Logger logger = Logger.getLogger(AddReplaceFileHelper.class.getCanonicalName());\n-    \n-    public static String FILE_ADD_OPERATION = \"FILE_ADD_OPERATION\";\n-    public static String FILE_REPLACE_OPERATION = \"FILE_REPLACE_OPERATION\";\n-    public static String FILE_REPLACE_FORCE_OPERATION = \"FILE_REPLACE_FORCE_OPERATION\";\n-    \n-            \n-    private String currentOperation;\n-    \n-    // -----------------------------------\n-    // All the needed EJBs, passed to the constructor\n-    // -----------------------------------\n-    private IngestServiceBean ingestService;\n-    private DatasetServiceBean datasetService;\n-    private DataFileServiceBean fileService;        \n-    private PermissionServiceBean permissionService;\n-    private EjbDataverseEngine commandEngine;\n-    private SystemConfig systemConfig;\n-    \n-    // -----------------------------------\n-    // Instance variables directly added\n-    // -----------------------------------\n-    private Dataset dataset;                    // constructor (for add, not replace)\n-    private DataverseRequest dvRequest;         // constructor\n-    private InputStream newFileInputStream;     // step 30\n-    private String newFileName;                 // step 30\n-    private String newFileContentType;          // step 30\n-    private String newStorageIdentifier;        // step 30\n-    private String newCheckSum;                 // step 30\n-    private ChecksumType newCheckSumType;       //step 30\n-    \n-    // -- Optional  \n-    private DataFile fileToReplace;             // step 25\n-    \n-    // -----------------------------------\n-    // Instance variables derived from other input\n-    // -----------------------------------\n-    private User user;\n-    private DatasetVersion workingVersion;\n-    private DatasetVersion clone;\n-    List<DataFile> initialFileList; \n-    List<DataFile> finalFileList;\n-    \n-    // -----------------------------------\n-    // Ingested files\n-    // -----------------------------------\n-    private List<DataFile> newlyAddedFiles; \n-    private List<FileMetadata> newlyAddedFileMetadatas;\n-    // -----------------------------------\n-    // For error handling\n-    // -----------------------------------\n-    \n-    private boolean errorFound;\n-    private List<String> errorMessages;\n-    private Response.Status httpErrorCode; // optional\n-    \n-    // For Force Replace, this becomes a warning rather than an error\n-    //\n-    private boolean contentTypeWarningFound;\n-    private String contentTypeWarningString;\n-    \n-    private boolean duplicateFileErrorFound;\n+public class AddReplaceFileHelper {\n+\n+  private static final Logger logger = Logger.getLogger(AddReplaceFileHelper.class.getCanonicalName());\n+\n+  public static String FILE_ADD_OPERATION = \"FILE_ADD_OPERATION\";\n+  public static String FILE_REPLACE_OPERATION = \"FILE_REPLACE_OPERATION\";\n+  public static String FILE_REPLACE_FORCE_OPERATION = \"FILE_REPLACE_FORCE_OPERATION\";\n+\n+\n+  private String currentOperation;\n+\n+  // -----------------------------------\n+  // All the needed EJBs, passed to the constructor\n+  // -----------------------------------\n+  private IngestServiceBean ingestService;\n+  private DatasetServiceBean datasetService;\n+  private DataFileServiceBean fileService;\n+  private PermissionServiceBean permissionService;\n+  private EjbDataverseEngine commandEngine;\n+  private SystemConfig systemConfig;\n+\n+  // -----------------------------------\n+  // Instance variables directly added\n+  // -----------------------------------\n+  private Dataset dataset;                    // constructor (for add, not replace)\n+  private DataverseRequest dvRequest;         // constructor\n+  private InputStream newFileInputStream;     // step 30\n+  private String newFileName;                 // step 30\n+  private String newFileContentType;          // step 30\n+  private String newStorageIdentifier;        // step 30\n+  private String newCheckSum;                 // step 30\n+  private ChecksumType newCheckSumType;       //step 30\n \n-    private String duplicateFileErrorString;\n+  // -- Optional\n+  private DataFile fileToReplace;             // step 25\n+\n+  // -----------------------------------\n+  // Instance variables derived from other input\n+  // -----------------------------------\n+  private User user;\n+  private DatasetVersion workingVersion;\n+  private DatasetVersion clone;\n+  List<DataFile> initialFileList;\n+  List<DataFile> finalFileList;\n+\n+  // -----------------------------------\n+  // Ingested files\n+  // -----------------------------------\n+  private List<DataFile> newlyAddedFiles;\n+  private List<FileMetadata> newlyAddedFileMetadatas;\n+  // -----------------------------------\n+  // For error handling\n+  // -----------------------------------\n+\n+  private boolean errorFound;\n+  private List<String> errorMessages;\n+  private Response.Status httpErrorCode; // optional\n+\n+  // For Force Replace, this becomes a warning rather than an error\n+  //\n+  private boolean contentTypeWarningFound;\n+  private String contentTypeWarningString;\n+\n+  private boolean duplicateFileErrorFound;\n+\n+  private String duplicateFileErrorString;\n+\n+  private boolean duplicateFileWarningFound;\n+  private String duplicateFileWarningString;\n+\n+  private String duplicateFileComponentMessage;\n+\n+  public String getDuplicateFileComponentMessage() {\n+    return duplicateFileComponentMessage;\n+  }\n+\n+  public void setDuplicateFileComponentMessage(String duplicateFileComponentMessage) {\n+    this.duplicateFileComponentMessage = duplicateFileComponentMessage;\n+  }\n+\n+  public boolean isDuplicateFileErrorFound() {\n+    return duplicateFileErrorFound;\n+  }\n+\n+  public void setDuplicateFileErrorFound(boolean duplicateFileErrorFound) {\n+    this.duplicateFileErrorFound = duplicateFileErrorFound;\n+  }\n+\n+  public String getDuplicateFileErrorString() {\n+    return duplicateFileErrorString;\n+  }\n+\n+  public void setDuplicateFileErrorString(String duplicateFileErrorString) {\n+    this.duplicateFileErrorString = duplicateFileErrorString;\n+  }\n+\n+  public boolean isDuplicateFileWarningFound() {\n+    return duplicateFileWarningFound;\n+  }\n \n-    private boolean duplicateFileWarningFound;\n-    private String duplicateFileWarningString;\n-    \n-    private String duplicateFileComponentMessage;\n+  public void setDuplicateFileWarningFound(boolean duplicateFileWarningFound) {\n+    this.duplicateFileWarningFound = duplicateFileWarningFound;\n+  }\n \n-    public String getDuplicateFileComponentMessage() {\n-        return duplicateFileComponentMessage;\n-    }\n+  public String getDuplicateFileWarningString() {\n+    return duplicateFileWarningString;\n+  }\n \n-    public void setDuplicateFileComponentMessage(String duplicateFileComponentMessage) {\n-        this.duplicateFileComponentMessage = duplicateFileComponentMessage;\n-    }\n-    \n-    public boolean isDuplicateFileErrorFound() {\n-        return duplicateFileErrorFound;\n-    }\n+  public void setDuplicateFileWarningString(String duplicateFileWarningString) {\n+    this.duplicateFileWarningString = duplicateFileWarningString;\n+  }\n+\n+  public void resetFileHelper() {\n+\n+    initErrorHandling();\n+\n+    // operation\n+    currentOperation = null;\n+\n+    // dataset level\n+    dataset = null;\n+\n+    // file to replace\n+    fileToReplace = null;\n+\n+    newFileInputStream = null;\n+    newFileName = null;\n+    newFileContentType = null;\n \n-    public void setDuplicateFileErrorFound(boolean duplicateFileErrorFound) {\n-        this.duplicateFileErrorFound = duplicateFileErrorFound;\n-    }\n+    // file lists\n+    initialFileList = null;\n+    finalFileList = null;\n \n-    public String getDuplicateFileErrorString() {\n-        return duplicateFileErrorString;\n-    }\n+    // final files\n+    newlyAddedFiles = null;\n+    newlyAddedFileMetadatas = null;\n+\n+  }\n \n-    public void setDuplicateFileErrorString(String duplicateFileErrorString) {\n-        this.duplicateFileErrorString = duplicateFileErrorString;\n+  /**\n+   * MAIN CONSTRUCTOR -- minimal requirements\n+   *\n+   * @param dataset\n+   * @param ingestService\n+   * @param datasetService\n+   * @param dvRequest\n+   */\n+  public AddReplaceFileHelper(DataverseRequest dvRequest,\n+                              IngestServiceBean ingestService,\n+                              DatasetServiceBean datasetService,\n+                              DataFileServiceBean fileService,\n+                              PermissionServiceBean permissionService,\n+                              EjbDataverseEngine commandEngine,\n+                              SystemConfig systemConfig) {\n+\n+    // ---------------------------------\n+    // make sure DataverseRequest isn't null and has a user\n+    // ---------------------------------\n+    if (dvRequest == null) {\n+      throw new NullPointerException(\"dvRequest cannot be null\");\n     }\n-    \n-    public boolean isDuplicateFileWarningFound() {\n-        return duplicateFileWarningFound;\n+    if (dvRequest.getUser() == null) {\n+      throw new NullPointerException(\"dvRequest cannot have a null user\");\n     }\n \n-    public void setDuplicateFileWarningFound(boolean duplicateFileWarningFound) {\n-        this.duplicateFileWarningFound = duplicateFileWarningFound;\n+    // ---------------------------------\n+    // make sure services aren't null\n+    // ---------------------------------\n+    if (ingestService == null) {\n+      throw new NullPointerException(\"ingestService cannot be null\");\n     }\n-\n-    public String getDuplicateFileWarningString() {\n-        return duplicateFileWarningString;\n+    if (datasetService == null) {\n+      throw new NullPointerException(\"datasetService cannot be null\");\n     }\n-\n-    public void setDuplicateFileWarningString(String duplicateFileWarningString) {\n-        this.duplicateFileWarningString = duplicateFileWarningString;\n+    if (fileService == null) {\n+      throw new NullPointerException(\"fileService cannot be null\");\n     }\n-    \n-    public void resetFileHelper(){\n-        \n-        initErrorHandling();\n-        \n-        // operation\n-        currentOperation = null;\n-        \n-        // dataset level\n-        dataset = null;\n-        \n-        // file to replace\n-        fileToReplace = null;\n-        \n-        newFileInputStream = null;    \n-        newFileName = null;    \n-        newFileContentType = null;    \n-    \n-        // file lists\n-        initialFileList = null;\n-        finalFileList = null;\n-        \n-        // final files\n-        newlyAddedFiles = null;\n-        newlyAddedFileMetadatas = null;\n-        \n+    if (permissionService == null) {\n+      throw new NullPointerException(\"ingestService cannot be null\");\n+    }\n+    if (commandEngine == null) {\n+      throw new NullPointerException(\"commandEngine cannot be null\");\n+    }\n+    if (systemConfig == null) {\n+      throw new NullPointerException(\"systemConfig cannot be null\");\n     }\n-    \n-    /** \n-     * MAIN CONSTRUCTOR -- minimal requirements\n-     * \n-     * @param dataset\n-     * @param ingestService\n-     * @param datasetService\n-     * @param dvRequest \n-     */\n-    public AddReplaceFileHelper(DataverseRequest dvRequest, \n-                            IngestServiceBean ingestService,                            \n-                            DatasetServiceBean datasetService,\n-                            DataFileServiceBean fileService,\n-                            PermissionServiceBean permissionService,\n-                            EjbDataverseEngine commandEngine,\n-                            SystemConfig systemConfig){\n-\n-        // ---------------------------------\n-        // make sure DataverseRequest isn't null and has a user\n-        // ---------------------------------\n-        if (dvRequest == null){\n-            throw new NullPointerException(\"dvRequest cannot be null\");\n-        }\n-        if (dvRequest.getUser() == null){\n-            throw new NullPointerException(\"dvRequest cannot have a null user\");\n-        }\n \n-        // ---------------------------------\n-        // make sure services aren't null\n-        // ---------------------------------\n-        if (ingestService == null){\n-            throw new NullPointerException(\"ingestService cannot be null\");\n-        }\n-        if (datasetService == null){\n-            throw new NullPointerException(\"datasetService cannot be null\");\n-        }\n-        if (fileService == null){\n-            throw new NullPointerException(\"fileService cannot be null\");\n-        }\n-        if (permissionService == null){\n-            throw new NullPointerException(\"ingestService cannot be null\");\n-        }\n-        if (commandEngine == null){\n-            throw new NullPointerException(\"commandEngine cannot be null\");\n-        }\n-        if (systemConfig == null) {\n-            throw new NullPointerException(\"systemConfig cannot be null\");\n-        }\n+    // ---------------------------------\n \n-        // ---------------------------------\n-        \n-        this.ingestService = ingestService;\n-        this.datasetService = datasetService;\n-        this.fileService = fileService;\n-        this.permissionService = permissionService;\n-        this.commandEngine = commandEngine;\n-        this.systemConfig = systemConfig;\n-        \n-        \n-        \n-        initErrorHandling();\n-        \n-        // Initiate instance vars\n-        this.dataset = null;\n-        this.dvRequest = dvRequest;\n-        this.user = dvRequest.getUser();\n-        \n-    }\n-    \n-    /**\n-     * \n-     * @param chosenDataset\n-     * @param newFileName\n-     * @param newFileContentType\n-     * @param newFileInputStream\n-     * @param optionalFileParams\n-     * @return \n-     */\n-    public boolean runAddFileByDataset(Dataset chosenDataset, \n-            String newFileName, \n-            String newFileContentType, \n-            String newStorageIdentifier,\n-            InputStream newFileInputStream,\n-            OptionalFileParams optionalFileParams){\n-        \n-        msgt(\">> runAddFileByDatasetId\");\n+    this.ingestService = ingestService;\n+    this.datasetService = datasetService;\n+    this.fileService = fileService;\n+    this.permissionService = permissionService;\n+    this.commandEngine = commandEngine;\n+    this.systemConfig = systemConfig;\n \n-        initErrorHandling();\n-        \n-        this.currentOperation = FILE_ADD_OPERATION;\n-        \n-        if (!this.step_001_loadDataset(chosenDataset)){\n-            return false;\n-        }\n-        \n-        //return this.runAddFile(this.dataset, newFileName, newFileContentType, newFileInputStream, optionalFileParams);\n-        return this.runAddReplaceFile(dataset, newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n \n+    initErrorHandling();\n+\n+    // Initiate instance vars\n+    this.dataset = null;\n+    this.dvRequest = dvRequest;\n+    this.user = dvRequest.getUser();\n+\n+  }\n+\n+  /**\n+   * @param chosenDataset\n+   * @param newFileName\n+   * @param newFileContentType\n+   * @param newFileInputStream\n+   * @param optionalFileParams\n+   * @return\n+   */\n+  public boolean runAddFileByDataset(Dataset chosenDataset,\n+                                     String newFileName,\n+                                     String newFileContentType,\n+                                     String newStorageIdentifier,\n+                                     InputStream newFileInputStream,\n+                                     OptionalFileParams optionalFileParams) {\n+\n+    msgt(\">> runAddFileByDatasetId\");\n+\n+    initErrorHandling();\n+\n+    this.currentOperation = FILE_ADD_OPERATION;\n+\n+    if (!this.step_001_loadDataset(chosenDataset)) {\n+      return false;\n     }\n-    \n-    \n-    /**\n-     * After the constructor, this method is called to add a file\n-     * \n-     * @param dataset\n-     * @param newFileName\n-     * @param newFileContentType\n-     * @param newFileInputStream\n-     * @return \n-     */\n+\n+    //return this.runAddFile(this.dataset, newFileName, newFileContentType, newFileInputStream, optionalFileParams);\n+    return this.runAddReplaceFile(dataset, newFileName, newFileContentType, newStorageIdentifier, newFileInputStream,\n+      optionalFileParams);\n+\n+  }\n+\n+\n+  /**\n+   * After the constructor, this method is called to add a file\n+   *\n+   * @param dataset\n+   * @param newFileName\n+   * @param newFileContentType\n+   * @param newFileInputStream\n+   * @return\n+   */\n     /*\n     public boolean runAddFile(Dataset dataset,\n                             String newFileName, \n@@ -358,848 +356,849 @@ public class AddReplaceFileHelper{\n         \n         return this.runAddReplaceFile(dataset, newFileName, newFileContentType, newFileInputStream, optionalFileParams);\n     }*/\n-    \n \n-    /**\n-     * After the constructor, this method is called to replace a file\n-     * \n-     * @param dataset\n-     * @param newFileName\n-     * @param newFileContentType\n-     * @param newStorageIdentifier2 \n-     * @param newFileInputStream\n-     * @return \n-     */\n-    public boolean runForceReplaceFile(Long oldFileId,\n-                        String newFileName, \n-                        String newFileContentType, \n-                        String newStorageIdentifier,\n-                        InputStream newFileInputStream,\n-                        OptionalFileParams optionalFileParams){\n-        \n-        msgt(\">> runForceReplaceFile\");\n-        initErrorHandling();\n \n-        this.currentOperation = FILE_REPLACE_FORCE_OPERATION;\n+  /**\n+   * After the constructor, this method is called to replace a file\n+   *\n+   * @param dataset\n+   * @param newFileName\n+   * @param newFileContentType\n+   * @param newStorageIdentifier2\n+   * @param newFileInputStream\n+   * @return\n+   */\n+  public boolean runForceReplaceFile(Long oldFileId,\n+                                     String newFileName,\n+                                     String newFileContentType,\n+                                     String newStorageIdentifier,\n+                                     InputStream newFileInputStream,\n+                                     OptionalFileParams optionalFileParams) {\n \n-               \n-        if (oldFileId==null){\n-            this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n-            return false;\n-        }\n-       \n-        // Loads local variable \"fileToReplace\"\n-        //\n-        if (!this.step_005_loadFileToReplaceById(oldFileId)){\n-            return false;\n-        }\n+    msgt(\">> runForceReplaceFile\");\n+    initErrorHandling();\n \n-        \n-        return this.runAddReplaceFile(fileToReplace.getOwner(), newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n-    }\n-    \n+    this.currentOperation = FILE_REPLACE_FORCE_OPERATION;\n \n-\tpublic boolean runReplaceFile(Long oldFileId,\n-                            String newFileName, \n-                            String newFileContentType, \n-                            String newStorageIdentifier, \n-                            InputStream newFileInputStream,\n-                            OptionalFileParams optionalFileParams){\n-    \n-        msgt(\">> runReplaceFile\");\n \n-        initErrorHandling();\n-        this.currentOperation = FILE_REPLACE_OPERATION;\n-        \n-        if (oldFileId==null){\n-            this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n-            return false;\n-        }\n-        \n-         \n-        // Loads local variable \"fileToReplace\"\n-        //\n-        if (!this.step_005_loadFileToReplaceById(oldFileId)){\n-            return false;\n-        }\n-        return this.runAddReplaceFile(fileToReplace.getOwner(), newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n-    }\n-    \n-    \n-    \n-    /**\n-     * Here we're going to run through the steps to ADD or REPLACE a file\n-     * \n-     * The difference between ADD and REPLACE (add/delete) is:\n-     * \n-     *  oldFileId - For ADD, set to null\n-     *  oldFileId - For REPLACE, set to id of file to replace \n-     * \n-     * This has now been broken into Phase 1 and Phase 2\n-     * \n-     * The APIs will use this method and call Phase 1 & Phase 2 consecutively\n-     * \n-     * The UI will call Phase 1 on initial upload and \n-     *   then run Phase 2 if the user chooses to save the changes.\n-     * @param newStorageIdentifier \n-     * \n-     * \n-     * @return \n-     */\n-    \n-    private boolean runAddReplaceFile(Dataset owner,  \n-            String newFileName, String newFileContentType, \n-            String newStorageIdentifier, InputStream newFileInputStream,\n-            OptionalFileParams optionalFileParams){\n-        \n-        // Run \"Phase 1\" - Initial ingest of file + error check\n-        // But don't save the dataset version yet\n-        //\n-        boolean phase1Success = runAddReplacePhase1(owner,  \n-                                        newFileName,  \n-                                        newFileContentType,  \n-                                        newStorageIdentifier,\n-                                        newFileInputStream,\n-                                        optionalFileParams\n-                                        );\n-        if (!phase1Success){\n-            return false;\n-        }\n-        \n-       \n-        return runAddReplacePhase2();\n-        \n+    if (oldFileId == null) {\n+      this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n+      return false;\n     }\n \n-    /**\n-     * Note: UI replace is always a \"force replace\" which means\n-     *  the replacement file can have a different content type\n-     * \n-     * @param oldFileId\n-     * @param newFileName\n-     * @param newFileContentType\n-     * @param newFileInputStream\n-     * @param optionalFileParams\n-     * @return \n-     */\n-    public boolean runReplaceFromUI_Phase1(Long oldFileId,  \n-            String newFileName, \n-            String newFileContentType,\n-            InputStream newFileInputStream,\n-            String fullStorageId,\n-            OptionalFileParams optionalFileParams){\n-        \n-        \n-        initErrorHandling();\n-        this.currentOperation = FILE_REPLACE_FORCE_OPERATION;\n-        \n-        if (oldFileId==null){\n-            this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n-            return false;\n-        }\n-        \n-         \n-        // Loads local variable \"fileToReplace\"\n-        //\n-        if (!this.step_005_loadFileToReplaceById(oldFileId)){\n-            return false;\n-        }\n-        //Update params to match existing file (except checksum, which should match the new file)\n-        if(fileToReplace != null) {\n-            String checksum = optionalFileParams.getCheckSum();\n-            ChecksumType checkSumType = optionalFileParams.getCheckSumType();\n-            try {\n-                optionalFileParams = new OptionalFileParams(fileToReplace);\n-                optionalFileParams.setCheckSum(checksum, checkSumType);\n-            } catch (DataFileTagException e) {\n-                // Shouldn't happen since fileToReplace should have valid tags\n-                e.printStackTrace();\n-            }\n-        }\n+    // Loads local variable \"fileToReplace\"\n+    //\n+    if (!this.step_005_loadFileToReplaceById(oldFileId)) {\n+      return false;\n+    }\n \n-        return this.runAddReplacePhase1(fileToReplace.getOwner(), \n-                newFileName, \n-                newFileContentType,\n-                fullStorageId,\n-                newFileInputStream, \n-                optionalFileParams);\n \n-       \n-    }\n-    \n-    \n-    /**\n-     * For the UI: File add/replace has been broken into 2 steps\n-     * \n-     * Phase 1 (here): Add/replace the file and make sure there are no errors\n-     *          But don't update the Dataset (yet)\n-     * @param newStorageIdentifier \n-     * \n-     * @return \n-     */\n-    private boolean runAddReplacePhase1(Dataset owner,  \n-            String newFileName, \n-            String newFileContentType,\n-            String newStorageIdentifier, InputStream newFileInputStream,\n-            OptionalFileParams optionalFileParams){\n-        \n-        if (this.hasError()){\n-            return false;   // possible to have errors already...\n-        }\n+    return this.runAddReplaceFile(fileToReplace.getOwner(), newFileName, newFileContentType, newStorageIdentifier,\n+      newFileInputStream, optionalFileParams);\n+  }\n \n-        msgt(\"step_001_loadDataset\");\n-        if (!this.step_001_loadDataset(owner)){\n-            return false;\n-        }\n-        \n-        msgt(\"step_010_VerifyUserAndPermissions\");\n-        if (!this.step_010_VerifyUserAndPermissions()){\n-            return false;\n-            \n-        }\n \n-        msgt(\"step_020_loadNewFile\");\n-        if (!this.step_020_loadNewFile(newFileName, newFileContentType, newStorageIdentifier, newFileInputStream)){\n-            return false;\n-            \n-        }\n-        if(optionalFileParams != null) {\n-        \tif(optionalFileParams.hasCheckSum()) {\n-        \t\tnewCheckSum = optionalFileParams.getCheckSum();\n-        \t\tnewCheckSumType = optionalFileParams.getCheckSumType();\n-        \t}\n-        }\n+  public boolean runReplaceFile(Long oldFileId,\n+                                String newFileName,\n+                                String newFileContentType,\n+                                String newStorageIdentifier,\n+                                InputStream newFileInputStream,\n+                                OptionalFileParams optionalFileParams) {\n \n-        msgt(\"step_030_createNewFilesViaIngest\");\n-        if (!this.step_030_createNewFilesViaIngest()){\n-            return false;\n-            \n-        }\n+    msgt(\">> runReplaceFile\");\n \n-        msgt(\"step_050_checkForConstraintViolations\");\n-        if (!this.step_050_checkForConstraintViolations()){\n-            return false;            \n-        }\n-        \n-        msgt(\"step_055_loadOptionalFileParams\");\n-        if (!this.step_055_loadOptionalFileParams(optionalFileParams)){\n-            return false;            \n-        }\n-        \n-        // if the fileToReplace hasn't been released,\n-        if (fileToReplace != null && !fileToReplace.isReleased()) {\n-            DataFile df = finalFileList.get(0); // step_055 uses a loop and assumes only one file\n-            // set the replacement file's previous and root datafileIds to match (unless\n-            // they are the defaults)\n-            if (fileToReplace.getPreviousDataFileId() != null) {\n-                df.setPreviousDataFileId(fileToReplace.getPreviousDataFileId());\n-                df.setRootDataFileId(fileToReplace.getRootDataFileId());\n-            }\n-            // Reuse any file PID during a replace operation (if File PIDs are in use)\n-            if (systemConfig.isFilePIDsEnabled()) {\n-                df.setGlobalId(fileToReplace.getGlobalId());\n-                df.setGlobalIdCreateTime(fileToReplace.getGlobalIdCreateTime());\n-                // Should be true or fileToReplace wouldn't have an identifier (since it's not\n-                // yet released in this if statement)\n-                df.setIdentifierRegistered(fileToReplace.isIdentifierRegistered());\n-                fileToReplace.setGlobalId(null);\n-            }\n-        }\n+    initErrorHandling();\n+    this.currentOperation = FILE_REPLACE_OPERATION;\n \n-        return true;\n+    if (oldFileId == null) {\n+      this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n+      return false;\n     }\n-    \n-    \n-    public boolean runReplaceFromUI_Phase2(){\n-        return runAddReplacePhase2();\n+\n+\n+    // Loads local variable \"fileToReplace\"\n+    //\n+    if (!this.step_005_loadFileToReplaceById(oldFileId)) {\n+      return false;\n+    }\n+    return this.runAddReplaceFile(fileToReplace.getOwner(), newFileName, newFileContentType, newStorageIdentifier,\n+      newFileInputStream, optionalFileParams);\n+  }\n+\n+\n+  /**\n+   * Here we're going to run through the steps to ADD or REPLACE a file\n+   * <p>\n+   * The difference between ADD and REPLACE (add/delete) is:\n+   * <p>\n+   * oldFileId - For ADD, set to null\n+   * oldFileId - For REPLACE, set to id of file to replace\n+   * <p>\n+   * This has now been broken into Phase 1 and Phase 2\n+   * <p>\n+   * The APIs will use this method and call Phase 1 & Phase 2 consecutively\n+   * <p>\n+   * The UI will call Phase 1 on initial upload and\n+   * then run Phase 2 if the user chooses to save the changes.\n+   *\n+   * @param newStorageIdentifier\n+   * @return\n+   */\n+\n+  private boolean runAddReplaceFile(Dataset owner,\n+                                    String newFileName, String newFileContentType,\n+                                    String newStorageIdentifier, InputStream newFileInputStream,\n+                                    OptionalFileParams optionalFileParams) {\n+\n+    // Run \"Phase 1\" - Initial ingest of file + error check\n+    // But don't save the dataset version yet\n+    //\n+    boolean phase1Success = runAddReplacePhase1(owner,\n+      newFileName,\n+      newFileContentType,\n+      newStorageIdentifier,\n+      newFileInputStream,\n+      optionalFileParams\n+    );\n+    if (!phase1Success) {\n+      return false;\n     }\n-    \n \n-    /**\n-     * Called from the UI backing bean\n-     * \n-     * @param categoriesList\n-     * @return \n-     */\n-    public boolean updateCategoriesFromUI(List<String> categoriesList){\n-        if (hasError()){\n-            logger.severe(\"Should not be calling this method\");\n-            return false;\n-        }\n-        \n-        if ((finalFileList==null)||(finalFileList.size()==0)){\n-            throw new NullPointerException(\"finalFileList needs at least 1 file!!\");\n-        }\n-        \n-        // don't need to make updates\n-        //\n-        if (categoriesList ==null){\n-            return true;           \n-        }\n-        \n-        // remove nulls, dupes, etc.\n-        //\n-        categoriesList = Util.removeDuplicatesNullsEmptyStrings(categoriesList);\n-        if (categoriesList.isEmpty()){\n-            return true;\n-        }\n-        \n-        for (DataFile df : finalFileList){\n-            \n-            df.getFileMetadata().setCategoriesByName(categoriesList);\n-        }\n-        \n-        return true;\n+\n+    return runAddReplacePhase2();\n+\n+  }\n+\n+  /**\n+   * Note: UI replace is always a \"force replace\" which means\n+   * the replacement file can have a different content type\n+   *\n+   * @param oldFileId\n+   * @param newFileName\n+   * @param newFileContentType\n+   * @param newFileInputStream\n+   * @param optionalFileParams\n+   * @return\n+   */\n+  public boolean runReplaceFromUI_Phase1(Long oldFileId,\n+                                         String newFileName,\n+                                         String newFileContentType,\n+                                         InputStream newFileInputStream,\n+                                         String fullStorageId,\n+                                         OptionalFileParams optionalFileParams) {\n+\n+\n+    initErrorHandling();\n+    this.currentOperation = FILE_REPLACE_FORCE_OPERATION;\n+\n+    if (oldFileId == null) {\n+      this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n+      return false;\n     }\n-    \n-    /**\n-     * Called from the UI backing bean\n \n-     * @param label\n-     * @param description\n-     * @param restricted\n-     * @return \n-     */\n-    public boolean updateLabelDescriptionRestrictedFromUI(String label, String description, Boolean restricted){\n-                \n-        if (hasError()){\n-            logger.severe(\"Should not be calling this method\");\n-            return false;\n-        }\n-        \n-        if ((finalFileList==null)||(finalFileList.size()==0)){\n-            throw new NullPointerException(\"finalFileList needs at least 1 file!!\");\n-        }\n-        \n-        \n-        for (DataFile df : finalFileList){\n-            \n-            // update description\n-            if (description != null){\n-                df.getFileMetadata().setDescription(description.trim());\n-            }        \n-\n-            // update label\n-            if (label != null){\n-                df.getFileMetadata().setLabel(label.trim());\n-            }               \n-            \n-            // update restriction\n-            if (restricted == null){\n-                restricted = false;\n-            }\n-            \n-            df.getFileMetadata().setRestricted(restricted);\n-        }\n-        \n-        return true;\n+\n+    // Loads local variable \"fileToReplace\"\n+    //\n+    if (!this.step_005_loadFileToReplaceById(oldFileId)) {\n+      return false;\n+    }\n+    //Update params to match existing file (except checksum, which should match the new file)\n+    if (fileToReplace != null) {\n+      String checksum = optionalFileParams.getCheckSum();\n+      ChecksumType checkSumType = optionalFileParams.getCheckSumType();\n+      try {\n+        optionalFileParams = new OptionalFileParams(fileToReplace);\n+        optionalFileParams.setCheckSum(checksum, checkSumType);\n+      } catch (DataFileTagException e) {\n+        // Shouldn't happen since fileToReplace should have valid tags\n+        e.printStackTrace();\n+      }\n     }\n-    \n-    /**\n-     * For the UI: File add/replace has been broken into 2 steps\n-     * \n-     * Phase 2 (here): Phase 1 has run ok, Update the Dataset -- issue the commands!\n-     * \n-     * @return \n-     */\n-    private boolean runAddReplacePhase2(){\n-        \n-        if (this.hasError()){\n-            return false;   // possible to have errors already...\n-        }\n \n-        if ((finalFileList ==  null)||(finalFileList.isEmpty())){\n-            addError(getBundleErr(\"phase2_called_early_no_new_files\"));\n-            return false;\n-        }\n-        \n-         msgt(\"step_060_addFilesViaIngestService\");\n-        if (!this.step_060_addFilesViaIngestService()){\n-            return false;\n-            \n-        }\n-        \n-        if (this.isFileReplaceOperation()){\n-            msgt(\"step_080_run_update_dataset_command_for_replace\");\n-            if (!this.step_080_run_update_dataset_command_for_replace()){\n-                return false;            \n-            }\n-            \n-        }else{\n-            msgt(\"step_070_run_update_dataset_command\");\n-            if (!this.step_070_run_update_dataset_command()){\n-                return false;            \n-            }\n-        }\n-        \n-        msgt(\"step_090_notifyUser\");\n-        if (!this.step_090_notifyUser()){\n-            return false;            \n-        }\n+    return this.runAddReplacePhase1(fileToReplace.getOwner(),\n+      newFileName,\n+      newFileContentType,\n+      fullStorageId,\n+      newFileInputStream,\n+      optionalFileParams);\n \n-        msgt(\"step_100_startIngestJobs\");\n-        if (!this.step_100_startIngestJobs()){\n-            return false;            \n-        }\n \n-        return true;\n+  }\n+\n+\n+  /**\n+   * For the UI: File add/replace has been broken into 2 steps\n+   * <p>\n+   * Phase 1 (here): Add/replace the file and make sure there are no errors\n+   * But don't update the Dataset (yet)\n+   *\n+   * @param newStorageIdentifier\n+   * @return\n+   */\n+  private boolean runAddReplacePhase1(Dataset owner,\n+                                      String newFileName,\n+                                      String newFileContentType,\n+                                      String newStorageIdentifier, InputStream newFileInputStream,\n+                                      OptionalFileParams optionalFileParams) {\n+\n+    if (this.hasError()) {\n+      return false;   // possible to have errors already...\n     }\n-    \n-    \n-    /**\n-     *  Get for currentOperation\n-     *  @return String\n-     */\n-    public String getCurrentOperation(){\n-        return this.currentOperation;\n+\n+    msgt(\"step_001_loadDataset\");\n+    if (!this.step_001_loadDataset(owner)) {\n+      return false;\n     }\n \n-    \n-    /**\n-     * Is this a file FORCE replace operation?\n-     * \n-     * Only overrides warnings of content type change\n-     * \n-     * @return \n-     */\n-    public boolean isForceFileOperation(){\n-        \n-        return this.currentOperation.equals(FILE_REPLACE_FORCE_OPERATION);\n+    msgt(\"step_010_VerifyUserAndPermissions\");\n+    if (!this.step_010_VerifyUserAndPermissions()) {\n+      return false;\n+\n     }\n-    \n-    /**\n-     * Is this a file replace operation?\n-     * @return \n-     */\n-    public boolean isFileReplaceOperation(){\n-    \n-        if (this.currentOperation.equals(FILE_REPLACE_OPERATION)){\n-            return true;\n-        }else if (this.currentOperation.equals(FILE_REPLACE_FORCE_OPERATION)){\n-            return true;\n-        }\n+\n+    msgt(\"step_020_loadNewFile\");\n+    if (!this.step_020_loadNewFile(newFileName, newFileContentType, newStorageIdentifier, newFileInputStream)) {\n+      return false;\n+\n+    }\n+    if (optionalFileParams != null) {\n+      if (optionalFileParams.hasCheckSum()) {\n+        newCheckSum = optionalFileParams.getCheckSum();\n+        newCheckSumType = optionalFileParams.getCheckSumType();\n+      }\n+    }\n+\n+    msgt(\"step_030_createNewFilesViaIngest\");\n+    if (!this.step_030_createNewFilesViaIngest()) {\n+      return false;\n+\n+    }\n+\n+    msgt(\"step_050_checkForConstraintViolations\");\n+    if (!this.step_050_checkForConstraintViolations()) {\n+      return false;\n+    }\n+\n+    msgt(\"step_055_loadOptionalFileParams\");\n+    if (!this.step_055_loadOptionalFileParams(optionalFileParams)) {\n+      return false;\n+    }\n+\n+    // if the fileToReplace hasn't been released,\n+    if (fileToReplace != null && !fileToReplace.isReleased()) {\n+      DataFile df = finalFileList.get(0); // step_055 uses a loop and assumes only one file\n+      // set the replacement file's previous and root datafileIds to match (unless\n+      // they are the defaults)\n+      if (fileToReplace.getPreviousDataFileId() != null) {\n+        df.setPreviousDataFileId(fileToReplace.getPreviousDataFileId());\n+        df.setRootDataFileId(fileToReplace.getRootDataFileId());\n+      }\n+      // Reuse any file PID during a replace operation (if File PIDs are in use)\n+      if (systemConfig.isFilePIDsEnabled()) {\n+        df.setGlobalId(fileToReplace.getGlobalId());\n+        df.setGlobalIdCreateTime(fileToReplace.getGlobalIdCreateTime());\n+        // Should be true or fileToReplace wouldn't have an identifier (since it's not\n+        // yet released in this if statement)\n+        df.setIdentifierRegistered(fileToReplace.isIdentifierRegistered());\n+        fileToReplace.setGlobalId(null);\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+\n+  public boolean runReplaceFromUI_Phase2() {\n+    return runAddReplacePhase2();\n+  }\n+\n+\n+  /**\n+   * Called from the UI backing bean\n+   *\n+   * @param categoriesList\n+   * @return\n+   */\n+  public boolean updateCategoriesFromUI(List<String> categoriesList) {\n+    if (hasError()) {\n+      logger.severe(\"Should not be calling this method\");\n+      return false;\n+    }\n+\n+    if ((finalFileList == null) || (finalFileList.size() == 0)) {\n+      throw new NullPointerException(\"finalFileList needs at least 1 file!!\");\n+    }\n+\n+    // don't need to make updates\n+    //\n+    if (categoriesList == null) {\n+      return true;\n+    }\n+\n+    // remove nulls, dupes, etc.\n+    //\n+    categoriesList = Util.removeDuplicatesNullsEmptyStrings(categoriesList);\n+    if (categoriesList.isEmpty()) {\n+      return true;\n+    }\n+\n+    for (DataFile df : finalFileList) {\n+\n+      df.getFileMetadata().setCategoriesByName(categoriesList);\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Called from the UI backing bean\n+   *\n+   * @param label\n+   * @param description\n+   * @param restricted\n+   * @return\n+   */\n+  public boolean updateLabelDescriptionRestrictedFromUI(String label, String description, Boolean restricted) {\n+\n+    if (hasError()) {\n+      logger.severe(\"Should not be calling this method\");\n+      return false;\n+    }\n+\n+    if ((finalFileList == null) || (finalFileList.size() == 0)) {\n+      throw new NullPointerException(\"finalFileList needs at least 1 file!!\");\n+    }\n+\n+\n+    for (DataFile df : finalFileList) {\n+\n+      // update description\n+      if (description != null) {\n+        df.getFileMetadata().setDescription(description.trim());\n+      }\n+\n+      // update label\n+      if (label != null) {\n+        df.getFileMetadata().setLabel(label.trim());\n+      }\n+\n+      // update restriction\n+      if (restricted == null) {\n+        restricted = false;\n+      }\n+\n+      df.getFileMetadata().setRestricted(restricted);\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * For the UI: File add/replace has been broken into 2 steps\n+   * <p>\n+   * Phase 2 (here): Phase 1 has run ok, Update the Dataset -- issue the commands!\n+   *\n+   * @return\n+   */\n+  private boolean runAddReplacePhase2() {\n+\n+    if (this.hasError()) {\n+      return false;   // possible to have errors already...\n+    }\n+\n+    if ((finalFileList == null) || (finalFileList.isEmpty())) {\n+      addError(getBundleErr(\"phase2_called_early_no_new_files\"));\n+      return false;\n+    }\n+\n+    msgt(\"step_060_addFilesViaIngestService\");\n+    if (!this.step_060_addFilesViaIngestService()) {\n+      return false;\n+\n+    }\n+\n+    if (this.isFileReplaceOperation()) {\n+      msgt(\"step_080_run_update_dataset_command_for_replace\");\n+      if (!this.step_080_run_update_dataset_command_for_replace()) {\n         return false;\n+      }\n+\n+    } else {\n+      msgt(\"step_070_run_update_dataset_command\");\n+      if (!this.step_070_run_update_dataset_command()) {\n+        return false;\n+      }\n     }\n-    \n-    /**\n-     * Is this a file add operation?\n-     * \n-     * @return \n-     */\n-    public boolean isFileAddOperation(){\n-    \n-        return this.currentOperation.equals(FILE_ADD_OPERATION);\n+\n+    msgt(\"step_090_notifyUser\");\n+    if (!this.step_090_notifyUser()) {\n+      return false;\n     }\n \n-    /**\n-     * Initialize error handling vars\n-     */\n-    private void initErrorHandling(){\n+    msgt(\"step_100_startIngestJobs\");\n+    if (!this.step_100_startIngestJobs()) {\n+      return false;\n+    }\n \n-        this.errorFound = false;\n-        this.errorMessages = new ArrayList<>();\n-        this.httpErrorCode = null;\n-        \n-        \n-        contentTypeWarningFound = false;\n-        contentTypeWarningString = null;\n+    return true;\n+  }\n+\n+\n+  /**\n+   * Get for currentOperation\n+   *\n+   * @return String\n+   */\n+  public String getCurrentOperation() {\n+    return this.currentOperation;\n+  }\n+\n+\n+  /**\n+   * Is this a file FORCE replace operation?\n+   * <p>\n+   * Only overrides warnings of content type change\n+   *\n+   * @return\n+   */\n+  public boolean isForceFileOperation() {\n+\n+    return this.currentOperation.equals(FILE_REPLACE_FORCE_OPERATION);\n+  }\n+\n+  /**\n+   * Is this a file replace operation?\n+   *\n+   * @return\n+   */\n+  public boolean isFileReplaceOperation() {\n+\n+    if (this.currentOperation.equals(FILE_REPLACE_OPERATION)) {\n+      return true;\n+    } else if (this.currentOperation.equals(FILE_REPLACE_FORCE_OPERATION)) {\n+      return true;\n     }\n-         \n-    \n+    return false;\n+  }\n \n-    /**\n-     * Add error message\n-     * \n-     * @param errMsg \n-     */\n-    private void addError(String errMsg){\n-        \n-        if (errMsg == null){\n-            throw new NullPointerException(\"errMsg cannot be null\");\n-        }\n-        this.errorFound = true;\n- \n-        logger.fine(errMsg);\n-        this.errorMessages.add(errMsg);\n+  /**\n+   * Is this a file add operation?\n+   *\n+   * @return\n+   */\n+  public boolean isFileAddOperation() {\n+\n+    return this.currentOperation.equals(FILE_ADD_OPERATION);\n+  }\n+\n+  /**\n+   * Initialize error handling vars\n+   */\n+  private void initErrorHandling() {\n+\n+    this.errorFound = false;\n+    this.errorMessages = new ArrayList<>();\n+    this.httpErrorCode = null;\n+\n+\n+    contentTypeWarningFound = false;\n+    contentTypeWarningString = null;\n+  }\n+\n+\n+  /**\n+   * Add error message\n+   *\n+   * @param errMsg\n+   */\n+  private void addError(String errMsg) {\n+\n+    if (errMsg == null) {\n+      throw new NullPointerException(\"errMsg cannot be null\");\n     }\n-    \n-    /**\n-     * Add Error mesage and, if it's known, the HTTP response code\n-     * \n-     * @param badHttpResponse, e.g. Response.Status.FORBIDDEN\n-     * @param errMsg \n-     */\n-    private void addError(Response.Status badHttpResponse, String errMsg){\n-        \n-        if (badHttpResponse == null){\n-            throw new NullPointerException(\"badHttpResponse cannot be null\");\n-        }\n-        if (errMsg == null){\n-            throw new NullPointerException(\"errMsg cannot be null\");\n-        }\n-      \n-        this.httpErrorCode = badHttpResponse;\n-        \n-        this.addError(errMsg);\n-                \n-        \n+    this.errorFound = true;\n+\n+    logger.fine(errMsg);\n+    this.errorMessages.add(errMsg);\n+  }\n+\n+  /**\n+   * Add Error mesage and, if it's known, the HTTP response code\n+   *\n+   * @param badHttpResponse, e.g. Response.Status.FORBIDDEN\n+   * @param errMsg\n+   */\n+  private void addError(Response.Status badHttpResponse, String errMsg) {\n+\n+    if (badHttpResponse == null) {\n+      throw new NullPointerException(\"badHttpResponse cannot be null\");\n     }\n-    \n-    private void addErrorWarning(String errMsg){\n-        if (errMsg == null){\n-            throw new NullPointerException(\"errMsg cannot be null\");\n-        }\n- \n-        logger.severe(errMsg);\n-        this.setDuplicateFileWarning(errMsg);\n-        this.errorMessages.add(errMsg);\n-        \n+    if (errMsg == null) {\n+      throw new NullPointerException(\"errMsg cannot be null\");\n     }\n-    \n-    \n-    private void addErrorSevere(String errMsg){\n-        \n-        if (errMsg == null){\n-            throw new NullPointerException(\"errMsg cannot be null\");\n-        }\n-        this.errorFound = true;\n- \n-        logger.severe(errMsg);\n-        this.errorMessages.add(errMsg);\n+\n+    this.httpErrorCode = badHttpResponse;\n+\n+    this.addError(errMsg);\n+\n+\n+  }\n+\n+  private void addErrorWarning(String errMsg) {\n+    if (errMsg == null) {\n+      throw new NullPointerException(\"errMsg cannot be null\");\n     }\n \n-    \n-    /**\n-     * Was an error found?\n-     * \n-     * @return \n-     */\n-    public boolean hasError(){\n-        return this.errorFound;\n-        \n+    logger.severe(errMsg);\n+    this.setDuplicateFileWarning(errMsg);\n+    this.errorMessages.add(errMsg);\n+\n+  }\n+\n+\n+  private void addErrorSevere(String errMsg) {\n+\n+    if (errMsg == null) {\n+      throw new NullPointerException(\"errMsg cannot be null\");\n     }\n-    \n-    /**\n-     * get error messages\n-     * \n-     * @return \n-     */\n-    public List<String> getErrorMessages(){\n-        return this.errorMessages;\n-    }   \n+    this.errorFound = true;\n \n-    /**\n-     * get error messages as string \n-     * \n-     * @param joinString\n-     * @return \n-     */\n-    public String getErrorMessagesAsString(String joinString){\n-        if (joinString==null){\n-            joinString = \"\\n\";\n-        }\n-        return String.join(joinString, this.errorMessages);\n-    }   \n+    logger.severe(errMsg);\n+    this.errorMessages.add(errMsg);\n+  }\n \n-   \n-    /**\n-     * For API use, return the HTTP error code\n-     * \n-     * Default is BAD_REQUEST\n-     * \n-     * @return \n-     */\n-    public Response.Status getHttpErrorCode(){\n-       \n-        if (!hasError()){\n-            logger.severe(\"Do not call this method unless there is an error!  check '.hasError()'\");\n-        }\n-        \n-        if (httpErrorCode == null){\n-            return Response.Status.BAD_REQUEST;\n-        }else{\n-            return httpErrorCode;\n-        }\n+\n+  /**\n+   * Was an error found?\n+   *\n+   * @return\n+   */\n+  public boolean hasError() {\n+    return this.errorFound;\n+\n+  }\n+\n+  /**\n+   * get error messages\n+   *\n+   * @return\n+   */\n+  public List<String> getErrorMessages() {\n+    return this.errorMessages;\n+  }\n+\n+  /**\n+   * get error messages as string\n+   *\n+   * @param joinString\n+   * @return\n+   */\n+  public String getErrorMessagesAsString(String joinString) {\n+    if (joinString == null) {\n+      joinString = \"\\n\";\n     }\n-    \n-    \n-    /**\n-     * Convenience method for getting bundle properties\n-     * \n-     * @param msgName\n-     * @return \n-     * @deprecated This method is deprecated because you have to know to search\n-     * only part of a bundle key (\"add_file_error\") rather than the full bundle\n-     * key (\"file.addreplace.error.add.add_file_error\") leading you to believe\n-     * that the bundle key is not used.\n-     */\n-    @Deprecated\n-    private String getBundleMsg(String msgName, boolean isErr){\n-        if (msgName == null){\n-            throw new NullPointerException(\"msgName cannot be null\");\n-        }\n-        if (isErr){        \n-            return BundleUtil.getStringFromBundle(\"file.addreplace.error.\" + msgName);\n-        }else{\n-            return BundleUtil.getStringFromBundle(\"file.addreplace.success.\" + msgName);\n-        }\n-       \n+    return String.join(joinString, this.errorMessages);\n+  }\n+\n+\n+  /**\n+   * For API use, return the HTTP error code\n+   * <p>\n+   * Default is BAD_REQUEST\n+   *\n+   * @return\n+   */\n+  public Response.Status getHttpErrorCode() {\n+\n+    if (!hasError()) {\n+      logger.severe(\"Do not call this method unless there is an error!  check '.hasError()'\");\n     }\n-    \n-    /**\n-     * Convenience method for getting bundle error message\n-     * \n-     * @param msgName\n-     * @return \n-     */\n-    private String getBundleErr(String msgName){\n-        return this.getBundleMsg(msgName, true);\n+\n+    if (httpErrorCode == null) {\n+      return Response.Status.BAD_REQUEST;\n+    } else {\n+      return httpErrorCode;\n     }\n-    \n-    \n-     \n-    /**\n-     * \n-     */\n-    private boolean step_001_loadDataset(Dataset selectedDataset){\n+  }\n \n-        if (this.hasError()){\n-            return false;\n-        }\n \n-        if (selectedDataset == null){\n-            this.addErrorSevere(getBundleErr(\"dataset_is_null\"));\n-            return false;\n-        }\n+  /**\n+   * Convenience method for getting bundle properties\n+   *\n+   * @param msgName\n+   * @return\n+   * @deprecated This method is deprecated because you have to know to search\n+   * only part of a bundle key (\"add_file_error\") rather than the full bundle\n+   * key (\"file.addreplace.error.add.add_file_error\") leading you to believe\n+   * that the bundle key is not used.\n+   */\n+  @Deprecated\n+  private String getBundleMsg(String msgName, boolean isErr) {\n+    if (msgName == null) {\n+      throw new NullPointerException(\"msgName cannot be null\");\n+    }\n+    if (isErr) {\n+      return BundleUtil.getStringFromBundle(\"file.addreplace.error.\" + msgName);\n+    } else {\n+      return BundleUtil.getStringFromBundle(\"file.addreplace.success.\" + msgName);\n+    }\n \n-        dataset = selectedDataset;\n-        \n-        return true;\n+  }\n+\n+  /**\n+   * Convenience method for getting bundle error message\n+   *\n+   * @param msgName\n+   * @return\n+   */\n+  private String getBundleErr(String msgName) {\n+    return this.getBundleMsg(msgName, true);\n+  }\n+\n+\n+  /**\n+   *\n+   */\n+  private boolean step_001_loadDataset(Dataset selectedDataset) {\n+\n+    if (this.hasError()) {\n+      return false;\n     }\n-    \n-    \n-    \n-    /**\n-     *  Step 10 Verify User and Permissions\n-     * \n-     * \n-     * @return \n-     */\n-    private boolean step_010_VerifyUserAndPermissions(){\n-        \n-        if (this.hasError()){\n-            return false;\n-        }\n-                \n-        return step_015_auto_check_permissions(dataset);\n \n+    if (selectedDataset == null) {\n+      this.addErrorSevere(getBundleErr(\"dataset_is_null\"));\n+      return false;\n     }\n-    \n-    private boolean step_015_auto_check_permissions(Dataset datasetToCheck){\n-        \n-        if (this.hasError()){\n-            return false;\n-        }\n-        \n-        if (datasetToCheck == null){\n-            addError(getBundleErr(\"dataset_is_null\"));\n-            return false;\n-        }\n-        \n-        // Make a temp. command\n-        //\n-        \n-        Command updateDatasetVersionCommand = new UpdateDatasetVersionCommand(datasetToCheck, dvRequest);\n-        \n-        // Can this user run the command?\n-        //\n-        if (!permissionService.isUserAllowedOn(dvRequest.getUser(), updateDatasetVersionCommand, datasetToCheck)) {\n-            addError(Response.Status.FORBIDDEN,getBundleErr(\"no_edit_dataset_permission\"));\n-           return false;\n-        }\n-        \n-        return true;\n-        \n+\n+    dataset = selectedDataset;\n+\n+    return true;\n+  }\n+\n+\n+  /**\n+   * Step 10 Verify User and Permissions\n+   *\n+   * @return\n+   */\n+  private boolean step_010_VerifyUserAndPermissions() {\n+\n+    if (this.hasError()) {\n+      return false;\n     }\n-    \n-    \n-    private boolean step_020_loadNewFile(String fileName, String fileContentType, String storageIdentifier, InputStream fileInputStream){\n-        \n-        if (this.hasError()){\n-            return false;\n-        }\n-        \n-        if (fileName == null){\n-            this.addErrorSevere(getBundleErr(\"filename_undetermined\"));\n-            return false;\n-            \n-        }\n \n-        if (fileContentType == null){\n-            this.addErrorSevere(getBundleErr(\"file_content_type_undetermined\"));\n-            return false;\n-            \n-        }\n-        \n-\t\tif (fileInputStream == null) {\n-\t\t\tif (storageIdentifier == null) {\n-\t\t\t\tthis.addErrorSevere(getBundleErr(\"file_upload_failed\"));\n-\t\t\t\treturn false;\n-\t\t\t} \n-\t\t} \n-\t\t\n-        newFileName = fileName;\n-        newFileContentType = fileContentType;\n-        \n-        //One of these will be null\n-    \tnewStorageIdentifier = storageIdentifier;\n-        newFileInputStream = fileInputStream;\n-        \n-        return true;\n+    return step_015_auto_check_permissions(dataset);\n+\n+  }\n+\n+  private boolean step_015_auto_check_permissions(Dataset datasetToCheck) {\n+\n+    if (this.hasError()) {\n+      return false;\n     }\n \n-    \n-    /**\n-     * Optional: old file to replace\n-     * \n-     * @param oldFile\n-     * @return \n-     */\n-    private boolean step_005_loadFileToReplaceById(Long dataFileId){\n-        \n-        if (this.hasError()){\n-            return false;\n-        }\n-        \n-        //  Check for Null\n-        //\n-        if (dataFileId == null){\n-            this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n-            return false;\n-        }\n-        \n-        // Does the file exist?\n-        //\n-        DataFile existingFile = fileService.find(dataFileId);\n-        \n-        if (existingFile == null){           \n-            this.addError(BundleUtil.getStringFromBundle(\"file.addreplace.error.existing_file_to_replace_not_found_by_id\", Collections.singletonList(dataFileId.toString())));\n-            return false;\n-        } \n-        \n+    if (datasetToCheck == null) {\n+      addError(getBundleErr(\"dataset_is_null\"));\n+      return false;\n+    }\n+\n+    // Make a temp. command\n+    //\n+\n+    Command updateDatasetVersionCommand = new UpdateDatasetVersionCommand(datasetToCheck, dvRequest);\n+\n+    // Can this user run the command?\n+    //\n+    if (!permissionService.isUserAllowedOn(dvRequest.getUser(), updateDatasetVersionCommand, datasetToCheck)) {\n+      addError(Response.Status.FORBIDDEN, getBundleErr(\"no_edit_dataset_permission\"));\n+      return false;\n+    }\n+\n+    return true;\n+\n+  }\n+\n+\n+  private boolean step_020_loadNewFile(String fileName, String fileContentType, String storageIdentifier,\n+                                       InputStream fileInputStream) {\n+\n+    if (this.hasError()) {\n+      return false;\n+    }\n+\n+    if (fileName == null) {\n+      this.addErrorSevere(getBundleErr(\"filename_undetermined\"));\n+      return false;\n+\n+    }\n+\n+    if (fileContentType == null) {\n+      this.addErrorSevere(getBundleErr(\"file_content_type_undetermined\"));\n+      return false;\n+\n+    }\n+\n+    if (fileInputStream == null) {\n+      if (storageIdentifier == null) {\n+        this.addErrorSevere(getBundleErr(\"file_upload_failed\"));\n+        return false;\n+      }\n+    }\n+\n+    newFileName = fileName;\n+    newFileContentType = fileContentType;\n+\n+    //One of these will be null\n+    newStorageIdentifier = storageIdentifier;\n+    newFileInputStream = fileInputStream;\n+\n+    return true;\n+  }\n+\n+\n+  /**\n+   * Optional: old file to replace\n+   *\n+   * @param oldFile\n+   * @return\n+   */\n+  private boolean step_005_loadFileToReplaceById(Long dataFileId) {\n+\n+    if (this.hasError()) {\n+      return false;\n+    }\n+\n+    //  Check for Null\n+    //\n+    if (dataFileId == null) {\n+      this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n+      return false;\n+    }\n+\n+    // Does the file exist?\n+    //\n+    DataFile existingFile = fileService.find(dataFileId);\n+\n+    if (existingFile == null) {\n+      this.addError(BundleUtil.getStringFromBundle(\"file.addreplace.error.existing_file_to_replace_not_found_by_id\",\n+        Collections.singletonList(dataFileId.toString())));\n+      return false;\n+    }\n+\n+\n+    // Do we have permission to replace this file? e.g. Edit the file's dataset\n+    //\n+    if (!step_015_auto_check_permissions(existingFile.getOwner())) {\n+      return false;\n+    }\n+    ;\n+    // Is the file in the latest dataset version?\n+    //\n+    if (!step_007_auto_isReplacementInLatestVersion(existingFile)) {\n+      return false;\n+    }\n+\n+    fileToReplace = existingFile;\n+\n+    return true;\n \n-        // Do we have permission to replace this file? e.g. Edit the file's dataset\n-        //\n-        if (!step_015_auto_check_permissions(existingFile.getOwner())){\n-            return false;\n-        };\n-        // Is the file in the latest dataset version?\n-        //\n-        if (!step_007_auto_isReplacementInLatestVersion(existingFile)){\n-            return false;\n+  }\n+\n+  /**\n+   * Make sure the file to replace is in the workingVersion\n+   * -- e.g. that it wasn't deleted from a previous Version\n+   *\n+   * @return\n+   */\n+  private boolean step_007_auto_isReplacementInLatestVersion(DataFile existingFile) {\n+\n+    if (existingFile == null) {\n+      throw new NullPointerException(\"existingFile cannot be null!\");\n+    }\n+\n+    if (this.hasError()) {\n+      return false;\n+    }\n+\n+\n+    DatasetVersion latestVersion = existingFile.getOwner().getLatestVersion();\n+\n+    boolean fileInLatestVersion = false;\n+    for (FileMetadata fm : latestVersion.getFileMetadatas()) {\n+      if (fm.getDataFile().getId() != null) {\n+        if (Objects.equals(existingFile.getId(), fm.getDataFile().getId())) {\n+          fileInLatestVersion = true;\n         }\n-        \n-        fileToReplace = existingFile;\n-        \n-        return true;        \n+      }\n+    }\n+    if (!fileInLatestVersion) {\n+      addError(getBundleErr(\"existing_file_not_in_latest_published_version\"));\n+      return false;\n+    }\n+    return true;\n+  }\n \n+\n+  private boolean step_030_createNewFilesViaIngest() {\n+\n+    if (this.hasError()) {\n+      return false;\n+    }\n+\n+    // Load the working version of the Dataset\n+    workingVersion = dataset.getEditVersion();\n+    clone = workingVersion.cloneDatasetVersion();\n+    try {\n+      initialFileList = FileUtil.createDataFiles(workingVersion,\n+        this.newFileInputStream,\n+        this.newFileName,\n+        this.newFileContentType,\n+        this.newStorageIdentifier,\n+        this.newCheckSum,\n+        this.newCheckSumType,\n+        this.systemConfig);\n+\n+    } catch (IOException ex) {\n+      if (!Strings.isNullOrEmpty(ex.getMessage())) {\n+        this.addErrorSevere(getBundleErr(\"ingest_create_file_err\") + \" \" + ex.getMessage());\n+      } else {\n+        this.addErrorSevere(getBundleErr(\"ingest_create_file_err\"));\n+      }\n+      logger.severe(ex.toString());\n+      this.runMajorCleanup();\n+      return false;\n+    } finally {\n+      IOUtils.closeQuietly(this.newFileInputStream);\n     }\n-    \n     /**\n-     * Make sure the file to replace is in the workingVersion\n-     *  -- e.g. that it wasn't deleted from a previous Version\n-     * \n-     * @return \n+     * This only happens:\n+     *  (1) the dataset was empty\n+     *  (2) the new file (or new file unzipped) did not ingest via \"createDataFiles\"\n      */\n-    private boolean step_007_auto_isReplacementInLatestVersion(DataFile existingFile){\n-        \n-        if (existingFile == null){\n-            throw new NullPointerException(\"existingFile cannot be null!\");\n-        }\n-\n-        if (this.hasError()){\n-            return false;\n-        }\n-        \n-        \n-        DatasetVersion latestVersion = existingFile.getOwner().getLatestVersion();\n-        \n-        boolean fileInLatestVersion = false;\n-        for (FileMetadata fm : latestVersion.getFileMetadatas()){\n-            if (fm.getDataFile().getId() != null){\n-                if (Objects.equals(existingFile.getId(),fm.getDataFile().getId())){\n-                    fileInLatestVersion = true;\n-                }\n-            }\n-        }\n-        if (!fileInLatestVersion){\n-            addError(getBundleErr(\"existing_file_not_in_latest_published_version\"));\n-            return false;                        \n-        }\n-        return true;\n+    if (initialFileList.isEmpty()) {\n+      this.addErrorSevere(getBundleErr(\"initial_file_list_empty\"));\n+      this.runMajorCleanup();\n+      return false;\n     }\n-    \n-    \n-    private boolean step_030_createNewFilesViaIngest(){\n-        \n-        if (this.hasError()){\n-            return false;\n-        }\n \n-        // Load the working version of the Dataset\n-        workingVersion = dataset.getEditVersion();\n-        clone =   workingVersion.cloneDatasetVersion();\n-        try {\n-            initialFileList = FileUtil.createDataFiles(workingVersion,\n-                    this.newFileInputStream,\n-                    this.newFileName,\n-                    this.newFileContentType,\n-                    this.newStorageIdentifier,\n-                    this.newCheckSum,\n-                    this.newCheckSumType,\n-                    this.systemConfig);\n-\n-        } catch (IOException ex) {\n-            if (!Strings.isNullOrEmpty(ex.getMessage())) {\n-                this.addErrorSevere(getBundleErr(\"ingest_create_file_err\") + \" \" + ex.getMessage());\n-            } else {\n-                this.addErrorSevere(getBundleErr(\"ingest_create_file_err\"));\n-            }\n-            logger.severe(ex.toString());\n-            this.runMajorCleanup(); \n-            return false;\n-        } finally {\n-            IOUtils.closeQuietly(this.newFileInputStream);\n-         }\n-         /**\n-         * This only happens:\n-         *  (1) the dataset was empty\n-         *  (2) the new file (or new file unzipped) did not ingest via \"createDataFiles\"\n-         */\n-        if (initialFileList.isEmpty()){\n-            this.addErrorSevere(getBundleErr(\"initial_file_list_empty\"));\n-            this.runMajorCleanup();\n-            return false;\n-        }\n-        \n-        /**\n-         * REPLACE: File replacement is limited to a single file!!\n-         * \n-         * ADD: When adding files, some types of individual files\n-         * are broken into several files--which is OK\n-         */\n-        if (isFileReplaceOperation()){\n-            if (initialFileList.size() > 1){\n-                this.addError(getBundleErr(\"initial_file_list_more_than_one\"));\n-                this.runMajorCleanup();\n-                return false;\n+    /**\n+     * REPLACE: File replacement is limited to a single file!!\n+     *\n+     * ADD: When adding files, some types of individual files\n+     * are broken into several files--which is OK\n+     */\n+    if (isFileReplaceOperation()) {\n+      if (initialFileList.size() > 1) {\n+        this.addError(getBundleErr(\"initial_file_list_more_than_one\"));\n+        this.runMajorCleanup();\n+        return false;\n \n-            }\n-        }\n-        \n-        if (this.step_040_auto_checkForDuplicates()){\n-            return true;\n-        }\n+      }\n+    }\n+\n+    if (this.step_040_auto_checkForDuplicates()) {\n+      return true;\n+    }\n                        \n \n         /*\n@@ -1207,165 +1206,169 @@ public class AddReplaceFileHelper{\n         if (this.step_045_auto_checkForFileReplaceDuplicate()) {\n             return true;\n         }*/\n-        \n-        return false;\n+\n+    return false;\n+  }\n+\n+\n+  /**\n+   * Create a \"final file list\"\n+   * <p>\n+   * This is always run after step 30 -- the ingest\n+   *\n+   * @return\n+   */\n+  private boolean step_040_auto_checkForDuplicates() {\n+    this.duplicateFileErrorString = \"\";\n+    this.duplicateFileErrorFound = false;\n+\n+    msgt(\"step_040_auto_checkForDuplicates\");\n+    if (this.hasError()) {\n+      return false;\n     }\n-    \n-    \n-    /**\n-     * Create a \"final file list\" \n-     * \n-     * This is always run after step 30 -- the ingest\n-     * \n-     * @return \n-     */\n-    private boolean step_040_auto_checkForDuplicates(){\n-        this.duplicateFileErrorString = \"\";\n-        this.duplicateFileErrorFound = false;\n-        \n-        msgt(\"step_040_auto_checkForDuplicates\");\n-        if (this.hasError()){\n-            return false;\n-        }\n-        \n-        // Double checked -- this check also happens in step 30\n-        //\n-        if (initialFileList.isEmpty()){\n-            this.addErrorSevere(getBundleErr(\"initial_file_list_empty\"));\n-            return false;\n-        }\n \n-        // Initialize new file list\n-        this.finalFileList = new ArrayList<>();\n+    // Double checked -- this check also happens in step 30\n+    //\n+    if (initialFileList.isEmpty()) {\n+      this.addErrorSevere(getBundleErr(\"initial_file_list_empty\"));\n+      return false;\n+    }\n \n-        String warningMessage  = null;\n-        \n+    // Initialize new file list\n+    this.finalFileList = new ArrayList<>();\n \n-        if (isFileReplaceOperation() && this.fileToReplace == null){\n-            // This error shouldn't happen if steps called correctly\n-            this.addErrorSevere(getBundleErr(\"existing_file_to_replace_is_null\") + \" (This error shouldn't happen if steps called in sequence....checkForFileReplaceDuplicate)\");\n-            return false;\n-        }\n-        \n-        // -----------------------------------------------------------\n-        // Iterate through the recently ingest files\n-        // -----------------------------------------------------------\n-        for (DataFile df : initialFileList){\n-             msg(\"Checking file: \" + df.getFileMetadata().getLabel());\n-\n-            // -----------------------------------------------------------\n-            // (1) Check for ingest warnings\n-            // -----------------------------------------------------------\n-            if (df.isIngestProblem()) {\n-                if (df.getIngestReportMessage() != null) {\n-                    // may collect multiple error messages\n-                    this.addError(df.getIngestReportMessage());\n-                }\n-                df.setIngestDone();\n-            }\n-          \n-            \n-            // -----------------------------------------------------------\n-            // (2) Check for duplicates\n-            // Only a warning now\n-            // -----------------------------------------------------------     \n-            if (isFileReplaceOperation() && Objects.equals(df.getChecksumValue(), fileToReplace.getChecksumValue())){\n-                this.addError(getBundleErr(\"replace.new_file_same_as_replacement\"));                \n-                this.duplicateFileErrorFound = true;\n-                this.duplicateFileErrorString = getBundleErr(\"replace.new_file_same_as_replacement\");\n-                break;\n-            } \n-            \n-            if (DuplicateFileChecker.isDuplicateOriginalWay(workingVersion, df.getFileMetadata())){\n-                String dupeName = df.getFileMetadata().getLabel();\n-                this.duplicateFileWarningFound = true;\n-                this.duplicateFileWarningString = BundleUtil.getStringFromBundle(\"file.addreplace.warning.duplicate_file\", \n-                                Arrays.asList(dupeName));\n-                this.addErrorWarning(this.duplicateFileWarningString); \n-\n-            }             \n-            finalFileList.add(df);\n-        }\n-        \n-        if (this.hasError()){\n-            // We're recovering from the duplicate check.\n-            msg(\"We're recovering from a duplicate check 1\");\n-            runMajorCleanup();\n-            msg(\"We're recovering from a duplicate check 2\");\n-            finalFileList.clear();           \n-            return false;\n-        }\n-        \n-       /**\n-         * REPLACE: File replacement is limited to a single file!!\n-         * \n-         * ADD: When adding files, some types of individual files\n-         * are broken into several files--which is OK\n-         */\n-            \n-       /**\n-        *  Also: check that the file is being replaced with the same content type\n-        *  file. Treat this as a fatal error, unless this is a \"force replace\" \n-        *  operation; then it should be treated as merely a warning.\n-        */\n-        if (isFileReplaceOperation()){\n-        \n-            if (finalFileList.size() > 1){     \n-                String errMsg = \"(This shouldn't happen -- error should have been detected in 030_createNewFilesViaIngest)\";\n-                this.addErrorSevere(getBundleErr(\"initial_file_list_more_than_one\") + \" \" + errMsg);            \n-                return false;\n-            }\n-            \n-            // Has the content type of the file changed?\n-            //\n-            String fileType = fileToReplace.getOriginalFileFormat() != null ? fileToReplace.getOriginalFileFormat() : fileToReplace.getContentType();\n-            if (!finalFileList.get(0).getContentType().equalsIgnoreCase(fileType)) {\n-                String friendlyType = fileToReplace.getOriginalFormatLabel() != null ? fileToReplace.getOriginalFormatLabel() : fileToReplace.getFriendlyType();\n-                \n-                List<String> errParams = Arrays.asList(friendlyType,\n-                                                finalFileList.get(0).getFriendlyType());\n-                \n-                String contentTypeErr = BundleUtil.getStringFromBundle(\"file.addreplace.error.replace.new_file_has_different_content_type\", \n-                                errParams);\n-                                        \n-                if (isForceFileOperation()){\n-                    // for force replace, just give a warning\n-                    this.setContentTypeWarning(contentTypeErr);\n-                }else{\n-                    // not a force replace? it's an error\n-                    this.addError(contentTypeErr);\n-                    runMajorCleanup();\n-                    return false;\n-                }\n-            }\n-        }\n-        \n-        if (finalFileList.isEmpty()){\n-            this.addErrorSevere(\"There are no files to add.  (This error shouldn't happen if steps called in sequence....step_040_auto_checkForDuplicates)\");                \n-            return false;\n+    String warningMessage = null;\n+\n+\n+    if (isFileReplaceOperation() && this.fileToReplace == null) {\n+      // This error shouldn't happen if steps called correctly\n+      this.addErrorSevere(getBundleErr(\"existing_file_to_replace_is_null\") +\n+        \" (This error shouldn't happen if steps called in sequence....checkForFileReplaceDuplicate)\");\n+      return false;\n+    }\n+\n+    // -----------------------------------------------------------\n+    // Iterate through the recently ingest files\n+    // -----------------------------------------------------------\n+    for (DataFile df : initialFileList) {\n+      msg(\"Checking file: \" + df.getFileMetadata().getLabel());\n+\n+      // -----------------------------------------------------------\n+      // (1) Check for ingest warnings\n+      // -----------------------------------------------------------\n+      if (df.isIngestProblem()) {\n+        if (df.getIngestReportMessage() != null) {\n+          // may collect multiple error messages\n+          this.addError(df.getIngestReportMessage());\n         }\n-        \n-        \n-        return true;\n-    } // end step_040_auto_checkForDuplicates\n-    \n-    \n+        df.setIngestDone();\n+      }\n+\n+\n+      // -----------------------------------------------------------\n+      // (2) Check for duplicates\n+      // Only a warning now\n+      // -----------------------------------------------------------\n+      if (isFileReplaceOperation() && Objects.equals(df.getChecksumValue(), fileToReplace.getChecksumValue())) {\n+        this.addError(getBundleErr(\"replace.new_file_same_as_replacement\"));\n+        this.duplicateFileErrorFound = true;\n+        this.duplicateFileErrorString = getBundleErr(\"replace.new_file_same_as_replacement\");\n+        break;\n+      }\n+\n+      if (DuplicateFileChecker.isDuplicateOriginalWay(workingVersion, df.getFileMetadata())) {\n+        String dupeName = df.getFileMetadata().getLabel();\n+        this.duplicateFileWarningFound = true;\n+        this.duplicateFileWarningString = BundleUtil.getStringFromBundle(\"file.addreplace.warning.duplicate_file\",\n+          Arrays.asList(dupeName));\n+        this.addErrorWarning(this.duplicateFileWarningString);\n+\n+      }\n+      finalFileList.add(df);\n+    }\n+\n+    if (this.hasError()) {\n+      // We're recovering from the duplicate check.\n+      msg(\"We're recovering from a duplicate check 1\");\n+      runMajorCleanup();\n+      msg(\"We're recovering from a duplicate check 2\");\n+      finalFileList.clear();\n+      return false;\n+    }\n+\n+    /**\n+     * REPLACE: File replacement is limited to a single file!!\n+     *\n+     * ADD: When adding files, some types of individual files\n+     * are broken into several files--which is OK\n+     */\n+\n     /**\n-     * This is always checked.   \n-     * \n-     * For ADD: If there is not replacement file, then the check is considered a success\n-     * For REPLACE: The checksum is examined against the \"finalFileList\" list\n-     * \n-     * NOTE: this method was always called AFTER the main duplicate check; \n-     * So we would never detect this condition - of the file being replaced with \n-     * the same file... because it would always be caught as simply an attempt\n-     * to replace a file with a file alraedy in the dataset! \n-     * So I commented it out, instead modifying the method above, step_040_auto_checkForDuplicates()\n-     * to do both - check (first) if a file is being replaced with the exact same file;\n-     * and check if a file, or files being uploaded are duplicates of files already \n-     * in the dataset. AND the replacement content type too. -- L.A. Jan 16 2017\n-     * \n+     *  Also: check that the file is being replaced with the same content type\n+     *  file. Treat this as a fatal error, unless this is a \"force replace\"\n+     *  operation; then it should be treated as merely a warning.\n      */\n+    if (isFileReplaceOperation()) {\n+\n+      if (finalFileList.size() > 1) {\n+        String errMsg = \"(This shouldn't happen -- error should have been detected in 030_createNewFilesViaIngest)\";\n+        this.addErrorSevere(getBundleErr(\"initial_file_list_more_than_one\") + \" \" + errMsg);\n+        return false;\n+      }\n+\n+      // Has the content type of the file changed?\n+      //\n+      String fileType = fileToReplace.getOriginalFileFormat() != null ? fileToReplace.getOriginalFileFormat() :\n+        fileToReplace.getContentType();\n+      if (!finalFileList.get(0).getContentType().equalsIgnoreCase(fileType)) {\n+        String friendlyType = fileToReplace.getOriginalFormatLabel() != null ? fileToReplace.getOriginalFormatLabel() :\n+          fileToReplace.getFriendlyType();\n+\n+        List<String> errParams = Arrays.asList(friendlyType,\n+          finalFileList.get(0).getFriendlyType());\n+\n+        String contentTypeErr =\n+          BundleUtil.getStringFromBundle(\"file.addreplace.error.replace.new_file_has_different_content_type\",\n+            errParams);\n+\n+        if (isForceFileOperation()) {\n+          // for force replace, just give a warning\n+          this.setContentTypeWarning(contentTypeErr);\n+        } else {\n+          // not a force replace? it's an error\n+          this.addError(contentTypeErr);\n+          runMajorCleanup();\n+          return false;\n+        }\n+      }\n+    }\n+\n+    if (finalFileList.isEmpty()) {\n+      this.addErrorSevere(\n+        \"There are no files to add.  (This error shouldn't happen if steps called in sequence....step_040_auto_checkForDuplicates)\");\n+      return false;\n+    }\n+\n+\n+    return true;\n+  } // end step_040_auto_checkForDuplicates\n+\n+\n+  /**\n+   * This is always checked.\n+   * <p>\n+   * For ADD: If there is not replacement file, then the check is considered a success\n+   * For REPLACE: The checksum is examined against the \"finalFileList\" list\n+   * <p>\n+   * NOTE: this method was always called AFTER the main duplicate check;\n+   * So we would never detect this condition - of the file being replaced with\n+   * the same file... because it would always be caught as simply an attempt\n+   * to replace a file with a file alraedy in the dataset!\n+   * So I commented it out, instead modifying the method above, step_040_auto_checkForDuplicates()\n+   * to do both - check (first) if a file is being replaced with the exact same file;\n+   * and check if a file, or files being uploaded are duplicates of files already\n+   * in the dataset. AND the replacement content type too. -- L.A. Jan 16 2017\n+   */\n     /*private boolean step_045_auto_checkForFileReplaceDuplicate(){\n         \n         if (this.hasError()){\n@@ -1396,367 +1399,366 @@ public class AddReplaceFileHelper{\n             \n             if (Objects.equals(df.getChecksumValue(), fileToReplace.getChecksumValue())){\n                 this.addError(getBundleErr(\"replace.new_file_same_as_replacement\"));                                \n-                break;\n-            }\n-\n-            // Has the content type of the file changed?\n-            //\n-            if (!df.getContentType().equalsIgnoreCase(fileToReplace.getContentType())){\n-            \n-                List<String> errParams = Arrays.asList(fileToReplace.getFriendlyType(),\n-                                                df.getFriendlyType());\n-                \n-                String contentTypeErr = BundleUtil.getStringFromBundle(\"file.addreplace.error.replace.new_file_has_different_content_type\", \n-                                errParams);\n-                                        \n-                if (isForceFileOperation()){\n-                    // for force replace, just give a warning\n-                    this.setContentTypeWarning(contentTypeErr);\n-                }else{\n-                    // not a force replace? it's an error\n-                    this.addError(contentTypeErr);\n-                }\n-            }\n-\n-        }\n-        \n-        if (hasError()){\n-            runMajorCleanup();\n-            return false;\n-        }\n-        \n-        return true;\n-        \n-    } // end step_045_auto_checkForFileReplaceDuplicate\n-    */\n-    \n-    \n-    \n-    private boolean step_050_checkForConstraintViolations(){\n-                \n-        if (this.hasError()){\n-            return false;\n-        }\n-        \n-        if (finalFileList.isEmpty()){\n-            // This error shouldn't happen if steps called in sequence....\n-            this.addErrorSevere(getBundleErr(\"final_file_list_empty\"));\n-            return false;\n-        }\n-\n-        // -----------------------------------------------------------\n-        // Iterate through checking for constraint violations\n-        //  Gather all error messages\n-        // -----------------------------------------------------------   \n-        Set<ConstraintViolation> constraintViolations = workingVersion.validate();    \n-\n-        // -----------------------------------------------------------   \n-        // No violations found\n-        // -----------------------------------------------------------   \n-        if (constraintViolations.isEmpty()){\n-            return true;\n-        }\n-        \n-        // -----------------------------------------------------------   \n-        // violations found: gather all error messages\n-        // -----------------------------------------------------------   \n-        List<String> errMsgs = new ArrayList<>();\n-        for (ConstraintViolation violation : constraintViolations){\n-            this.addError(violation.getMessage());\n-        }\n-        \n-        return this.hasError();\n-    }\n-    \n-    \n-    /**\n-     * Load optional file params such as description, tags, fileDataTags, etc..\n-     * \n-     * @param optionalFileParams\n-     * @return \n-     */\n-    private boolean step_055_loadOptionalFileParams(OptionalFileParams optionalFileParams){\n-        \n-        if (hasError()){\n-            return false;\n-        }\n-\n-        // --------------------------------------------\n-        // OK, the object may be null\n-        // --------------------------------------------\n-        if (optionalFileParams == null){\n-            return true;\n-        }\n-        \n-            \n-        // --------------------------------------------\n-        // Iterate through files (should only be 1 for now)\n-        // Add tags, description, etc\n-        // --------------------------------------------\n-        for (DataFile df : finalFileList){\n-            try {\n-                optionalFileParams.addOptionalParams(df);\n-                \n-                // call restriction command here\n-                boolean restrict = optionalFileParams.getRestriction();\n-                if (restrict != df.getFileMetadata().isRestricted()) {\n-                    commandEngine.submit(new RestrictFileCommand(df, dvRequest, restrict));\n-                }\n-                \n-            } catch (DataFileTagException ex) {\n-                Logger.getLogger(AddReplaceFileHelper.class.getName()).log(Level.SEVERE, null, ex);\n-                addError(ex.getMessage());\n-                return false;\n-            } catch (CommandException ex) {\n-                addError(ex.getMessage());\n-            }\n-        }\n-        \n-        \n-        return true;\n-    }\n-    \n-    private boolean step_060_addFilesViaIngestService(){\n-                       \n-        if (this.hasError()){\n-            return false;\n-        }\n-                \n-        if (finalFileList.isEmpty()){\n-            // This error shouldn't happen if steps called in sequence....\n-            this.addErrorSevere(getBundleErr(\"final_file_list_empty\"));                \n-            return false;\n-        }\n-        \n-        int nFiles = finalFileList.size();\n-        finalFileList = ingestService.saveAndAddFilesToDataset(workingVersion, finalFileList, fileToReplace);\n-\n-        if (nFiles != finalFileList.size()) {\n-            if (nFiles == 1) {\n-                addError(\"Failed to save the content of the uploaded file.\");\n-            } else {\n-                addError(\"Failed to save the content of at least one of the uploaded files.\");\n-            }\n-            return false;\n-        }\n-        \n-        return true;\n-    }\n-    \n-    \n-    /**\n-     * Create and run the update dataset command\n-     * \n-     * @return \n-     */\n-    private boolean step_070_run_update_dataset_command(){\n-        \n-        if (this.hasError()){\n-            return false;\n-        }\n-\n-        Command<Dataset> update_cmd;\n-        String deleteStorageLocation = null;\n-        long deleteFileId=-1;\n-        if(isFileReplaceOperation()) {\n-            List<FileMetadata> filesToDelete = new ArrayList<FileMetadata>();\n-            filesToDelete.add(fileToReplace.getFileMetadata());\n-            \n-            if(!fileToReplace.isReleased()) {\n-                //If file is only in draft version, also need to delete the physical file\n-            deleteStorageLocation = fileService.getPhysicalFileToDelete(fileToReplace);\n-            deleteFileId=fileToReplace.getId();\n+                break;\n             }\n-            //Adding the file to the delete list for the command will delete this filemetadata and, if the file hasn't been released, the datafile itself. \n-            update_cmd = new UpdateDatasetVersionCommand(dataset, dvRequest, filesToDelete, clone);\n-        } else {\n-          update_cmd = new UpdateDatasetVersionCommand(dataset, dvRequest, clone);\n-        }\n-        ((UpdateDatasetVersionCommand) update_cmd).setValidateLenient(true);  \n-        \n-        try {            \n-            // Submit the update dataset command \n-            // and update the local dataset object\n+\n+            // Has the content type of the file changed?\n             //\n-            dataset = commandEngine.submit(update_cmd);\n-        } catch (CommandException ex) {\n-            /**\n-             * @todo Add a test to exercise this error.\n-             */\n-            this.addErrorSevere(getBundleErr(\"add.add_file_error\"));\n-            logger.severe(ex.getMessage());\n-            return false;\n-        }catch (EJBException ex) {\n-            /**\n-             * @todo Add a test to exercise this error.\n-             */\n-            this.addErrorSevere(\"add.add_file_error (see logs)\");\n-            logger.severe(ex.getMessage());\n-            return false;\n-        }\n-        //Sanity check\n-        if(isFileReplaceOperation()) {\n-            if (deleteStorageLocation != null) {\n-                // Finalize the delete of the physical file \n-                // (File service will double-check that the datafile no \n-                // longer exists in the database, before proceeding to \n-                // delete the physical file)\n-                try {\n-                    fileService.finalizeFileDelete(deleteFileId, deleteStorageLocation);\n-                } catch (IOException ioex) {\n-                    logger.warning(\"Failed to delete the physical file associated with the deleted datafile id=\"\n-                            + deleteFileId + \", storage location: \" + deleteStorageLocation);\n+            if (!df.getContentType().equalsIgnoreCase(fileToReplace.getContentType())){\n+            \n+                List<String> errParams = Arrays.asList(fileToReplace.getFriendlyType(),\n+                                                df.getFriendlyType());\n+                \n+                String contentTypeErr = BundleUtil.getStringFromBundle(\"file.addreplace.error.replace.new_file_has_different_content_type\", \n+                                errParams);\n+                                        \n+                if (isForceFileOperation()){\n+                    // for force replace, just give a warning\n+                    this.setContentTypeWarning(contentTypeErr);\n+                }else{\n+                    // not a force replace? it's an error\n+                    this.addError(contentTypeErr);\n                 }\n             }\n-        }\n-        return true;\n-    }\n-    \n \n-    private boolean runMajorCleanup(){\n-        \n-        // (1) remove unsaved files from the working version\n-        removeUnSavedFilesFromWorkingVersion();\n-        \n-        // ----------------------------------------------------\n-        // (2) if the working version is brand new, delete it\n-        //      It doesn't have an \"id\" so you can't use the DeleteDatasetVersionCommand\n-        // ----------------------------------------------------\n-        // Remove this working version from the dataset\n-        Iterator<DatasetVersion> versionIterator = dataset.getVersions().iterator();\n-        msgt(\"Clear Files\");\n-        while (versionIterator.hasNext()) {\n-            DatasetVersion dsv = versionIterator.next();\n-            if (dsv.getId() == null){\n-                versionIterator.remove();\n-            }\n         }\n         \n-        return true;\n-        \n-    }\n-    \n-    /**\n-     * We are outta here!  Remove everything unsaved from the edit version!\n-     * \n-     * @return \n-     */\n-    private boolean removeUnSavedFilesFromWorkingVersion(){\n-        msgt(\"Clean up: removeUnSavedFilesFromWorkingVersion\");\n-        \n-        // -----------------------------------------------------------\n-        // (1) Remove all new FileMetadata objects\n-        // -----------------------------------------------------------                        \n-        //Iterator<FileMetadata> fmIt = dataset.getEditVersion().getFileMetadatas().iterator();//  \n-        Iterator<FileMetadata> fmIt = workingVersion.getFileMetadatas().iterator(); //dataset.getEditVersion().getFileMetadatas().iterator();//  \n-        while (fmIt.hasNext()) {\n-            FileMetadata fm = fmIt.next();\n-            if (fm.getDataFile().getId() == null){\n-                fmIt.remove();\n-            }\n+        if (hasError()){\n+            runMajorCleanup();\n+            return false;\n         }\n         \n-        // -----------------------------------------------------------\n-        // (2) Remove all new DataFile objects\n-        // -----------------------------------------------------------                        \n-        Iterator<DataFile> dfIt = dataset.getFiles().iterator();\n-        msgt(\"Clear Files\");\n-        while (dfIt.hasNext()) {\n-            DataFile df = dfIt.next();\n-            if (df.getId() == null){\n-                dfIt.remove();\n-            }\n-        }\n         return true;\n         \n+    } // end step_045_auto_checkForFileReplaceDuplicate\n+    */\n+  private boolean step_050_checkForConstraintViolations() {\n+\n+    if (this.hasError()) {\n+      return false;\n     }\n-    \n-    \n-    private boolean step_080_run_update_dataset_command_for_replace(){\n \n-        if (!isFileReplaceOperation()){\n-            // Shouldn't happen!\n-            this.addErrorSevere(getBundleErr(\"only_replace_operation\") + \" (step_080_run_update_dataset_command_for_replace)\");\n-            return false;\n+    if (finalFileList.isEmpty()) {\n+      // This error shouldn't happen if steps called in sequence....\n+      this.addErrorSevere(getBundleErr(\"final_file_list_empty\"));\n+      return false;\n+    }\n+\n+    // -----------------------------------------------------------\n+    // Iterate through checking for constraint violations\n+    //  Gather all error messages\n+    // -----------------------------------------------------------\n+    Set<ConstraintViolation> constraintViolations = workingVersion.validate();\n+\n+    // -----------------------------------------------------------\n+    // No violations found\n+    // -----------------------------------------------------------\n+    if (constraintViolations.isEmpty()) {\n+      return true;\n+    }\n+\n+    // -----------------------------------------------------------\n+    // violations found: gather all error messages\n+    // -----------------------------------------------------------\n+    List<String> errMsgs = new ArrayList<>();\n+    for (ConstraintViolation violation : constraintViolations) {\n+      this.addError(violation.getMessage());\n+    }\n+\n+    return this.hasError();\n+  }\n+\n+\n+  /**\n+   * Load optional file params such as description, tags, fileDataTags, etc..\n+   *\n+   * @param optionalFileParams\n+   * @return\n+   */\n+  private boolean step_055_loadOptionalFileParams(OptionalFileParams optionalFileParams) {\n+\n+    if (hasError()) {\n+      return false;\n+    }\n+\n+    // --------------------------------------------\n+    // OK, the object may be null\n+    // --------------------------------------------\n+    if (optionalFileParams == null) {\n+      return true;\n+    }\n+\n+\n+    // --------------------------------------------\n+    // Iterate through files (should only be 1 for now)\n+    // Add tags, description, etc\n+    // --------------------------------------------\n+    for (DataFile df : finalFileList) {\n+      try {\n+        optionalFileParams.addOptionalParams(df);\n+\n+        // call restriction command here\n+        boolean restrict = optionalFileParams.getRestriction();\n+        if (restrict != df.getFileMetadata().isRestricted()) {\n+          commandEngine.submit(new RestrictFileCommand(df, dvRequest, restrict));\n         }\n \n-        if (this.hasError()){\n-            return false;\n+      } catch (DataFileTagException ex) {\n+        Logger.getLogger(AddReplaceFileHelper.class.getName()).log(Level.SEVERE, null, ex);\n+        addError(ex.getMessage());\n+        return false;\n+      } catch (CommandException ex) {\n+        addError(ex.getMessage());\n+      }\n+    }\n+\n+\n+    return true;\n+  }\n+\n+  private boolean step_060_addFilesViaIngestService() {\n+\n+    if (this.hasError()) {\n+      return false;\n+    }\n+\n+    if (finalFileList.isEmpty()) {\n+      // This error shouldn't happen if steps called in sequence....\n+      this.addErrorSevere(getBundleErr(\"final_file_list_empty\"));\n+      return false;\n+    }\n+\n+    int nFiles = finalFileList.size();\n+    finalFileList = ingestService.saveAndAddFilesToDataset(workingVersion, finalFileList, fileToReplace);\n+\n+    if (nFiles != finalFileList.size()) {\n+      if (nFiles == 1) {\n+        addError(\"Failed to save the content of the uploaded file.\");\n+      } else {\n+        addError(\"Failed to save the content of at least one of the uploaded files.\");\n+      }\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+\n+  /**\n+   * Create and run the update dataset command\n+   *\n+   * @return\n+   */\n+  private boolean step_070_run_update_dataset_command() {\n+\n+    if (this.hasError()) {\n+      return false;\n+    }\n+\n+    Command<Dataset> update_cmd;\n+    String deleteStorageLocation = null;\n+    long deleteFileId = -1;\n+    if (isFileReplaceOperation()) {\n+      List<FileMetadata> filesToDelete = new ArrayList<FileMetadata>();\n+      filesToDelete.add(fileToReplace.getFileMetadata());\n+\n+      if (!fileToReplace.isReleased()) {\n+        //If file is only in draft version, also need to delete the physical file\n+        deleteStorageLocation = fileService.getPhysicalFileToDelete(fileToReplace);\n+        deleteFileId = fileToReplace.getId();\n+      }\n+      //Adding the file to the delete list for the command will delete this filemetadata and, if the file hasn't been released, the datafile itself.\n+      update_cmd = new UpdateDatasetVersionCommand(dataset, dvRequest, filesToDelete, clone);\n+    } else {\n+      update_cmd = new UpdateDatasetVersionCommand(dataset, dvRequest, clone);\n+    }\n+    ((UpdateDatasetVersionCommand) update_cmd).setValidateLenient(true);\n+\n+    try {\n+      // Submit the update dataset command\n+      // and update the local dataset object\n+      //\n+      dataset = commandEngine.submit(update_cmd);\n+    } catch (CommandException ex) {\n+      /**\n+       * @todo Add a test to exercise this error.\n+       */\n+      this.addErrorSevere(getBundleErr(\"add.add_file_error\"));\n+      logger.severe(ex.getMessage());\n+      return false;\n+    } catch (EJBException ex) {\n+      /**\n+       * @todo Add a test to exercise this error.\n+       */\n+      this.addErrorSevere(\"add.add_file_error (see logs)\");\n+      logger.severe(ex.getMessage());\n+      return false;\n+    }\n+    //Sanity check\n+    if (isFileReplaceOperation()) {\n+      if (deleteStorageLocation != null) {\n+        // Finalize the delete of the physical file\n+        // (File service will double-check that the datafile no\n+        // longer exists in the database, before proceeding to\n+        // delete the physical file)\n+        try {\n+          fileService.finalizeFileDelete(deleteFileId, deleteStorageLocation);\n+        } catch (IOException ioex) {\n+          logger.warning(\"Failed to delete the physical file associated with the deleted datafile id=\"\n+            + deleteFileId + \", storage location: \" + deleteStorageLocation);\n         }\n+      }\n+    }\n+    return true;\n+  }\n \n-        // -----------------------------------------------------------\n-        // Set the \"root file ids\" and \"previous file ids\"\n-        // THIS IS A KEY STEP - SPLIT IT OUT\n-        //  (1) Old file: Set the Root File Id on the original file  \n-        //  (2) New file: Set the previousFileId to the id of the original file\n-        //  (3) New file: Set the rootFileId to the rootFileId of the original file\n-        // -----------------------------------------------------------\n- \n-        \n-        if (fileToReplace.isReleased()) {\n-            /*\n-             * Check the root file id on fileToReplace, updating it if necessary\n-             */\n-            if (fileToReplace.getRootDataFileId().equals(DataFile.ROOT_DATAFILE_ID_DEFAULT)) {\n-\n-                fileToReplace.setRootDataFileId(fileToReplace.getId());\n-                fileToReplace = fileService.save(fileToReplace);\n-            }\n \n-            /*\n-             * Go through the final file list, settting the rootFileId and previousFileId\n-             */\n-            for (DataFile df : finalFileList) {\n-                df.setPreviousDataFileId(fileToReplace.getId());\n+  private boolean runMajorCleanup() {\n \n-                df.setRootDataFileId(fileToReplace.getRootDataFileId());\n+    // (1) remove unsaved files from the working version\n+    removeUnSavedFilesFromWorkingVersion();\n \n-            }\n-        }\n-        // Call the update dataset command which will delete the replaced filemetadata and file in needed (if file is not released)\n-        //\n-        return step_070_run_update_dataset_command();\n-        \n-       \n+    // ----------------------------------------------------\n+    // (2) if the working version is brand new, delete it\n+    //      It doesn't have an \"id\" so you can't use the DeleteDatasetVersionCommand\n+    // ----------------------------------------------------\n+    // Remove this working version from the dataset\n+    Iterator<DatasetVersion> versionIterator = dataset.getVersions().iterator();\n+    msgt(\"Clear Files\");\n+    while (versionIterator.hasNext()) {\n+      DatasetVersion dsv = versionIterator.next();\n+      if (dsv.getId() == null) {\n+        versionIterator.remove();\n+      }\n     }\n-            \n-    /**\n-     * We want the version of the newly added file that has an id set\n-     * \n-     * TODO: This is inefficient/expensive.  Need to redo it in a sane way\n-     *      - e.g. Query to find \n-     *          (1) latest dataset version in draft\n-     *          (2) pick off files that are NOT released\n-     *          (3) iterate through only those files\n-     *      - or an alternate/better version\n-     * \n-     * @param df \n-     */\n-    private void setNewlyAddedFiles(List<DataFile> datafiles){\n-        \n-        if (hasError()){\n-            return;\n-        }\n-            \n-        // Init. newly added file list\n-        newlyAddedFiles = new ArrayList<>();\n-        newlyAddedFileMetadatas = new ArrayList<>();\n-        \n-        // Loop of uglinesss...but expect 1 to 4 files in final file list\n-        List<FileMetadata> latestFileMetadatas = dataset.getEditVersion().getFileMetadatas();\n-        \n-        \n-        for (DataFile newlyAddedFile : finalFileList){\n-            \n-             for (FileMetadata fm : latestFileMetadatas){\n-                 if (newlyAddedFile.getChecksumValue().equals(fm.getDataFile().getChecksumValue())){\n-                    if (newlyAddedFile.getStorageIdentifier().equals(fm.getDataFile().getStorageIdentifier())){\n-                        newlyAddedFiles.add(fm.getDataFile());\n-                        newlyAddedFileMetadatas.add(fm);\n-                    }\n-                }\n-             }\n+\n+    return true;\n+\n+  }\n+\n+  /**\n+   * We are outta here!  Remove everything unsaved from the edit version!\n+   *\n+   * @return\n+   */\n+  private boolean removeUnSavedFilesFromWorkingVersion() {\n+    msgt(\"Clean up: removeUnSavedFilesFromWorkingVersion\");\n+\n+    // -----------------------------------------------------------\n+    // (1) Remove all new FileMetadata objects\n+    // -----------------------------------------------------------\n+    //Iterator<FileMetadata> fmIt = dataset.getEditVersion().getFileMetadatas().iterator();//\n+    Iterator<FileMetadata> fmIt =\n+      workingVersion.getFileMetadatas().iterator(); //dataset.getEditVersion().getFileMetadatas().iterator();//\n+    while (fmIt.hasNext()) {\n+      FileMetadata fm = fmIt.next();\n+      if (fm.getDataFile().getId() == null) {\n+        fmIt.remove();\n+      }\n+    }\n+\n+    // -----------------------------------------------------------\n+    // (2) Remove all new DataFile objects\n+    // -----------------------------------------------------------\n+    Iterator<DataFile> dfIt = dataset.getFiles().iterator();\n+    msgt(\"Clear Files\");\n+    while (dfIt.hasNext()) {\n+      DataFile df = dfIt.next();\n+      if (df.getId() == null) {\n+        dfIt.remove();\n+      }\n+    }\n+    return true;\n+\n+  }\n+\n+\n+  private boolean step_080_run_update_dataset_command_for_replace() {\n+\n+    if (!isFileReplaceOperation()) {\n+      // Shouldn't happen!\n+      this\n+        .addErrorSevere(getBundleErr(\"only_replace_operation\") + \" (step_080_run_update_dataset_command_for_replace)\");\n+      return false;\n+    }\n+\n+    if (this.hasError()) {\n+      return false;\n+    }\n+\n+    // -----------------------------------------------------------\n+    // Set the \"root file ids\" and \"previous file ids\"\n+    // THIS IS A KEY STEP - SPLIT IT OUT\n+    //  (1) Old file: Set the Root File Id on the original file\n+    //  (2) New file: Set the previousFileId to the id of the original file\n+    //  (3) New file: Set the rootFileId to the rootFileId of the original file\n+    // -----------------------------------------------------------\n+\n+\n+    if (fileToReplace.isReleased()) {\n+      /*\n+       * Check the root file id on fileToReplace, updating it if necessary\n+       */\n+      if (fileToReplace.getRootDataFileId().equals(DataFile.ROOT_DATAFILE_ID_DEFAULT)) {\n+\n+        fileToReplace.setRootDataFileId(fileToReplace.getId());\n+        fileToReplace = fileService.save(fileToReplace);\n+      }\n+\n+      /*\n+       * Go through the final file list, settting the rootFileId and previousFileId\n+       */\n+      for (DataFile df : finalFileList) {\n+        df.setPreviousDataFileId(fileToReplace.getId());\n+\n+        df.setRootDataFileId(fileToReplace.getRootDataFileId());\n+\n+      }\n+    }\n+    // Call the update dataset command which will delete the replaced filemetadata and file in needed (if file is not released)\n+    //\n+    return step_070_run_update_dataset_command();\n+\n+\n+  }\n+\n+  /**\n+   * We want the version of the newly added file that has an id set\n+   * <p>\n+   * TODO: This is inefficient/expensive.  Need to redo it in a sane way\n+   * - e.g. Query to find\n+   * (1) latest dataset version in draft\n+   * (2) pick off files that are NOT released\n+   * (3) iterate through only those files\n+   * - or an alternate/better version\n+   *\n+   * @param df\n+   */\n+  private void setNewlyAddedFiles(List<DataFile> datafiles) {\n+\n+    if (hasError()) {\n+      return;\n+    }\n+\n+    // Init. newly added file list\n+    newlyAddedFiles = new ArrayList<>();\n+    newlyAddedFileMetadatas = new ArrayList<>();\n+\n+    // Loop of uglinesss...but expect 1 to 4 files in final file list\n+    List<FileMetadata> latestFileMetadatas = dataset.getEditVersion().getFileMetadatas();\n+\n+\n+    for (DataFile newlyAddedFile : finalFileList) {\n+\n+      for (FileMetadata fm : latestFileMetadatas) {\n+        if (newlyAddedFile.getChecksumValue().equals(fm.getDataFile().getChecksumValue())) {\n+          if (newlyAddedFile.getStorageIdentifier().equals(fm.getDataFile().getStorageIdentifier())) {\n+            newlyAddedFiles.add(fm.getDataFile());\n+            newlyAddedFileMetadatas.add(fm);\n+          }\n         }\n+      }\n+    }\n         /*\n        \n         newlyAddedFile = df;\n@@ -1773,193 +1775,197 @@ public class AddReplaceFileHelper{\n             }\n         }\n         */\n-        \n-    }\n \n-    /**\n-     * For a successful replace operation, return a the first newly added file\n-     * @return \n-     */\n-    public DataFile getFirstNewlyAddedFile(){\n-        \n-        if ((newlyAddedFiles == null)||(newlyAddedFiles.size() == 0)){\n-            return null;\n-        }\n-        return newlyAddedFiles.get(0);\n-    }\n-        \n-    public List<DataFile> getNewlyAddedFiles(){\n-        \n-        return newlyAddedFiles;\n-    }\n-    \n-    public List<FileMetadata> getNewlyAddedFileMetadatas(){\n-        \n-        return newlyAddedFileMetadatas;\n-    }\n-    \n-    \n-    public String getSuccessResult() throws NoFilesException{\n-        if (hasError()){\n-            throw new NoFilesException(\"Don't call this method if an error exists!! First check 'hasError()'\");\n-        }\n+  }\n \n-        if (newlyAddedFiles == null){\n-            throw new NullPointerException(\"newlyAddedFiles is null!\");\n-        }\n-        \n-        return getSuccessResultAsJsonObjectBuilder().toString();\n-        \n-    }\n-    \n-    public JsonObjectBuilder getSuccessResultAsJsonObjectBuilder() throws NoFilesException{\n-        \n-        if (hasError()){\n-            throw new NoFilesException(\"Don't call this method if an error exists!! First check 'hasError()'\");\n-        }\n-        \n-        if (newlyAddedFiles == null){\n-            throw new NullPointerException(\"newlyAddedFiles is null!\");\n-        }\n-        \n-        if (newlyAddedFiles.isEmpty()){\n-            throw new NoFilesException(\"newlyAddedFiles is empty!\");\n-        }\n-        \n-        return JsonPrinter.jsonDataFileList(newlyAddedFiles);\n-    }\n-    \n-    \n-    /**\n-     * Currently this is a placeholder if we decide to send\n-     * user notifications.\n-     * \n-     */\n-    private boolean step_090_notifyUser(){\n-        if (this.hasError()){\n-            return false;\n-        }\n-       \n-        // Create a notification!\n-       \n-        // skip for now, may be part of dataset update listening\n-        //\n-        return true;\n+  /**\n+   * For a successful replace operation, return a the first newly added file\n+   *\n+   * @return\n+   */\n+  public DataFile getFirstNewlyAddedFile() {\n+\n+    if ((newlyAddedFiles == null) || (newlyAddedFiles.size() == 0)) {\n+      return null;\n     }\n-    \n+    return newlyAddedFiles.get(0);\n+  }\n \n-    private boolean step_100_startIngestJobs(){\n-        if (this.hasError()){\n-            return false;\n-        }\n-                \n-        // Should only be one file in the list\n-        setNewlyAddedFiles(finalFileList);\n-        \n-        // clear old file list\n-        //\n-        finalFileList.clear();\n+  public List<DataFile> getNewlyAddedFiles() {\n \n-        // TODO: Need to run ingwest async......\n-        //if (true){\n-            //return true;\n-        //}\n-        \n-        msg(\"pre ingest start\");\n-        // start the ingest!\n-        //\n-               \n-        ingestService.startIngestJobsForDataset(dataset, dvRequest.getAuthenticatedUser());\n-        \n-        msg(\"post ingest start\");\n-        return true;\n-    }\n+    return newlyAddedFiles;\n+  }\n \n-    \n-    private void msg(String m){\n-        logger.fine(m);\n-        //System.out.println(m);\n+  public List<FileMetadata> getNewlyAddedFileMetadatas() {\n+\n+    return newlyAddedFileMetadatas;\n+  }\n+\n+\n+  public String getSuccessResult() throws NoFilesException {\n+    if (hasError()) {\n+      throw new NoFilesException(\"Don't call this method if an error exists!! First check 'hasError()'\");\n     }\n-    private void dashes(){\n-        msg(\"----------------\");\n+\n+    if (newlyAddedFiles == null) {\n+      throw new NullPointerException(\"newlyAddedFiles is null!\");\n     }\n-    private void msgt(String m){\n-        dashes(); msg(m); dashes();\n+\n+    return getSuccessResultAsJsonObjectBuilder().toString();\n+\n+  }\n+\n+  public JsonObjectBuilder getSuccessResultAsJsonObjectBuilder() throws NoFilesException {\n+\n+    if (hasError()) {\n+      throw new NoFilesException(\"Don't call this method if an error exists!! First check 'hasError()'\");\n     }\n-    \n-    \n-    /**\n-     * Return file list before saving\n-     * \n-     * Used for UI display\n-     * \n-     * @return \n-     */\n-    public List<DataFile> getFileListBeforeSave(){\n-        \n-        return this.finalFileList;\n+\n+    if (newlyAddedFiles == null) {\n+      throw new NullPointerException(\"newlyAddedFiles is null!\");\n     }\n-    \n-    public Boolean isFinalFileListEmpty (){\n-        return this.finalFileList.isEmpty();\n+\n+    if (newlyAddedFiles.isEmpty()) {\n+      throw new NoFilesException(\"newlyAddedFiles is empty!\");\n     }\n-    \n-    \n-    /**\n-     * Return file list before saving\n-     * \n-     * Used for UI display\n-     * \n-     * @return \n-     */\n-    public List<FileMetadata> getNewFileMetadatasBeforeSave(){\n-        \n-        if (this.finalFileList.size() == 0){\n-            return null;\n-        }\n-        \n-        List<FileMetadata> fileMetadatas = new ArrayList<>();\n-        for (DataFile df : finalFileList){\n-            fileMetadatas.add(df.getFileMetadata());\n-        }\n-        \n-        return fileMetadatas;\n-        \n+\n+    return JsonPrinter.jsonDataFileList(newlyAddedFiles);\n+  }\n+\n+\n+  /**\n+   * Currently this is a placeholder if we decide to send\n+   * user notifications.\n+   */\n+  private boolean step_090_notifyUser() {\n+    if (this.hasError()) {\n+      return false;\n     }\n-    \n-    public void setContentTypeWarning(String warningString){\n-        \n-        if ((warningString == null)||(warningString.isEmpty())){\n-            throw new NullPointerException(\"warningString cannot be null\");\n-        }\n-        \n-        contentTypeWarningFound = true;\n-        contentTypeWarningString = warningString;\n+\n+    // Create a notification!\n+\n+    // skip for now, may be part of dataset update listening\n+    //\n+    return true;\n+  }\n+\n+\n+  private boolean step_100_startIngestJobs() {\n+    if (this.hasError()) {\n+      return false;\n     }\n-    \n-    public boolean hasContentTypeWarning(){\n-        return this.contentTypeWarningFound;\n+\n+    // Should only be one file in the list\n+    setNewlyAddedFiles(finalFileList);\n+\n+    // clear old file list\n+    //\n+    finalFileList.clear();\n+\n+    // TODO: Need to run ingwest async......\n+    //if (true){\n+    //return true;\n+    //}\n+\n+    msg(\"pre ingest start\");\n+    // start the ingest!\n+    //\n+\n+    ingestService.startIngestJobsForDataset(dataset, dvRequest.getAuthenticatedUser());\n+\n+    msg(\"post ingest start\");\n+    return true;\n+  }\n+\n+\n+  private void msg(String m) {\n+    logger.fine(m);\n+    //System.out.println(m);\n+  }\n+\n+  private void dashes() {\n+    msg(\"----------------\");\n+  }\n+\n+  private void msgt(String m) {\n+    dashes();\n+    msg(m);\n+    dashes();\n+  }\n+\n+\n+  /**\n+   * Return file list before saving\n+   * <p>\n+   * Used for UI display\n+   *\n+   * @return\n+   */\n+  public List<DataFile> getFileListBeforeSave() {\n+\n+    return this.finalFileList;\n+  }\n+\n+  public Boolean isFinalFileListEmpty() {\n+    return this.finalFileList.isEmpty();\n+  }\n+\n+\n+  /**\n+   * Return file list before saving\n+   * <p>\n+   * Used for UI display\n+   *\n+   * @return\n+   */\n+  public List<FileMetadata> getNewFileMetadatasBeforeSave() {\n+\n+    if (this.finalFileList.size() == 0) {\n+      return null;\n     }\n-    \n-    public String getContentTypeWarningString(){\n-        if (!hasContentTypeWarning()){\n-            // not really a NullPointerException but want to blow up here without adding try/catch everywhere\n-            //\n-            throw new NullPointerException(\"Don't call this method without checking 'hasContentTypeWarning()'\");\n-        }\n-        return contentTypeWarningString;\n+\n+    List<FileMetadata> fileMetadatas = new ArrayList<>();\n+    for (DataFile df : finalFileList) {\n+      fileMetadatas.add(df.getFileMetadata());\n     }\n-    \n-    private String duplicateFileWarning;\n \n-    public String getDuplicateFileWarning() {\n-        return duplicateFileWarning;\n+    return fileMetadatas;\n+\n+  }\n+\n+  public void setContentTypeWarning(String warningString) {\n+\n+    if ((warningString == null) || (warningString.isEmpty())) {\n+      throw new NullPointerException(\"warningString cannot be null\");\n     }\n \n-    public void setDuplicateFileWarning(String duplicateFileWarning) {\n-        this.duplicateFileWarning = duplicateFileWarning;\n+    contentTypeWarningFound = true;\n+    contentTypeWarningString = warningString;\n+  }\n+\n+  public boolean hasContentTypeWarning() {\n+    return this.contentTypeWarningFound;\n+  }\n+\n+  public String getContentTypeWarningString() {\n+    if (!hasContentTypeWarning()) {\n+      // not really a NullPointerException but want to blow up here without adding try/catch everywhere\n+      //\n+      throw new NullPointerException(\"Don't call this method without checking 'hasContentTypeWarning()'\");\n     }\n-    \n+    return contentTypeWarningString;\n+  }\n+\n+  private String duplicateFileWarning;\n+\n+  public String getDuplicateFileWarning() {\n+    return duplicateFileWarning;\n+  }\n+\n+  public void setDuplicateFileWarning(String duplicateFileWarning) {\n+    this.duplicateFileWarning = duplicateFileWarning;\n+  }\n+\n } // end class\n   /*\n     DatasetPage sequence:\n@@ -2017,19 +2023,19 @@ public class AddReplaceFileHelper{\n                 - check if dataset has a template\n             - creates UserNotification message\n     \n-    */  \n-    // Checks:\n-    //   - Does the md5 already exist in the dataset?\n-    //   - If it's a replace, has the name and/or extension changed?\n-    //   On failure, send back warning\n-    //\n-    // - All looks good\n-    // - Create a DataFile\n-    // - Create a FileMetadata\n-    // - Copy the Dataset version, making a new DRAFT\n-    //      - If it's replace, don't copy the file being replaced\n-    // - Add this new file.\n-    // ....\n+    */\n+// Checks:\n+//   - Does the md5 already exist in the dataset?\n+//   - If it's a replace, has the name and/or extension changed?\n+//   On failure, send back warning\n+//\n+// - All looks good\n+// - Create a DataFile\n+// - Create a FileMetadata\n+// - Copy the Dataset version, making a new DRAFT\n+//      - If it's replace, don't copy the file being replaced\n+// - Add this new file.\n+// ....\n     \n     \n \n",
            "diff_size": 2827
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/3/AddReplaceFileHelper.java\nindex d01e9b4e2f3..623a98384b2 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/codebuff/3/AddReplaceFileHelper.java\n@@ -93,15 +93,17 @@ import org.ocpsoft.common.util.Strings;\n  * \n  * @author rmp553\n  */\n-public class AddReplaceFileHelper{\n-    \n+\n+\n+public class AddReplaceFileHelper {\n+\n     private static final Logger logger = Logger.getLogger(AddReplaceFileHelper.class.getCanonicalName());\n-    \n+\n     public static String FILE_ADD_OPERATION = \"FILE_ADD_OPERATION\";\n+\n     public static String FILE_REPLACE_OPERATION = \"FILE_REPLACE_OPERATION\";\n+\n     public static String FILE_REPLACE_FORCE_OPERATION = \"FILE_REPLACE_FORCE_OPERATION\";\n-    \n-            \n     private String currentOperation;\n     \n     // -----------------------------------\n@@ -109,7 +111,7 @@ public class AddReplaceFileHelper{\n     // -----------------------------------\n     private IngestServiceBean ingestService;\n     private DatasetServiceBean datasetService;\n-    private DataFileServiceBean fileService;        \n+    private DataFileServiceBean fileService;\n     private PermissionServiceBean permissionService;\n     private EjbDataverseEngine commandEngine;\n     private SystemConfig systemConfig;\n@@ -135,18 +137,17 @@ public class AddReplaceFileHelper{\n     private User user;\n     private DatasetVersion workingVersion;\n     private DatasetVersion clone;\n-    List<DataFile> initialFileList; \n+    List<DataFile> initialFileList;\n     List<DataFile> finalFileList;\n     \n     // -----------------------------------\n     // Ingested files\n     // -----------------------------------\n-    private List<DataFile> newlyAddedFiles; \n+    private List<DataFile> newlyAddedFiles;\n     private List<FileMetadata> newlyAddedFileMetadatas;\n     // -----------------------------------\n     // For error handling\n     // -----------------------------------\n-    \n     private boolean errorFound;\n     private List<String> errorMessages;\n     private Response.Status httpErrorCode; // optional\n@@ -155,14 +156,10 @@ public class AddReplaceFileHelper{\n     //\n     private boolean contentTypeWarningFound;\n     private String contentTypeWarningString;\n-    \n     private boolean duplicateFileErrorFound;\n-\n     private String duplicateFileErrorString;\n-\n     private boolean duplicateFileWarningFound;\n     private String duplicateFileWarningString;\n-    \n     private String duplicateFileComponentMessage;\n \n     public String getDuplicateFileComponentMessage() {\n@@ -172,7 +169,7 @@ public class AddReplaceFileHelper{\n     public void setDuplicateFileComponentMessage(String duplicateFileComponentMessage) {\n         this.duplicateFileComponentMessage = duplicateFileComponentMessage;\n     }\n-    \n+\n     public boolean isDuplicateFileErrorFound() {\n         return duplicateFileErrorFound;\n     }\n@@ -188,7 +185,7 @@ public class AddReplaceFileHelper{\n     public void setDuplicateFileErrorString(String duplicateFileErrorString) {\n         this.duplicateFileErrorString = duplicateFileErrorString;\n     }\n-    \n+\n     public boolean isDuplicateFileWarningFound() {\n         return duplicateFileWarningFound;\n     }\n@@ -204,9 +201,8 @@ public class AddReplaceFileHelper{\n     public void setDuplicateFileWarningString(String duplicateFileWarningString) {\n         this.duplicateFileWarningString = duplicateFileWarningString;\n     }\n-    \n-    public void resetFileHelper(){\n-        \n+\n+    public void resetFileHelper() {\n         initErrorHandling();\n         \n         // operation\n@@ -217,9 +213,8 @@ public class AddReplaceFileHelper{\n         \n         // file to replace\n         fileToReplace = null;\n-        \n-        newFileInputStream = null;    \n-        newFileName = null;    \n+        newFileInputStream = null;\n+        newFileName = null;\n         newFileContentType = null;    \n     \n         // file lists\n@@ -229,7 +224,6 @@ public class AddReplaceFileHelper{\n         // final files\n         newlyAddedFiles = null;\n         newlyAddedFileMetadatas = null;\n-        \n     }\n     \n     /** \n@@ -240,64 +234,61 @@ public class AddReplaceFileHelper{\n      * @param datasetService\n      * @param dvRequest \n      */\n-    public AddReplaceFileHelper(DataverseRequest dvRequest, \n-                            IngestServiceBean ingestService,                            \n-                            DatasetServiceBean datasetService,\n-                            DataFileServiceBean fileService,\n-                            PermissionServiceBean permissionService,\n-                            EjbDataverseEngine commandEngine,\n-                            SystemConfig systemConfig){\n+\n+    public AddReplaceFileHelper(DataverseRequest dvRequest, IngestServiceBean ingestService, DatasetServiceBean datasetService, DataFileServiceBean fileService, PermissionServiceBean permissionService, EjbDataverseEngine commandEngine, SystemConfig systemConfig) {\n \n         // ---------------------------------\n         // make sure DataverseRequest isn't null and has a user\n         // ---------------------------------\n-        if (dvRequest == null){\n+        if (dvRequest == null) {\n             throw new NullPointerException(\"dvRequest cannot be null\");\n         }\n-        if (dvRequest.getUser() == null){\n+\n+        if (dvRequest.getUser() == null) {\n             throw new NullPointerException(\"dvRequest cannot have a null user\");\n         }\n \n         // ---------------------------------\n         // make sure services aren't null\n         // ---------------------------------\n-        if (ingestService == null){\n+\n+        if (ingestService == null) {\n             throw new NullPointerException(\"ingestService cannot be null\");\n         }\n-        if (datasetService == null){\n+\n+        if (datasetService == null) {\n             throw new NullPointerException(\"datasetService cannot be null\");\n         }\n-        if (fileService == null){\n+\n+        if (fileService == null) {\n             throw new NullPointerException(\"fileService cannot be null\");\n         }\n-        if (permissionService == null){\n+\n+        if (permissionService == null) {\n             throw new NullPointerException(\"ingestService cannot be null\");\n         }\n-        if (commandEngine == null){\n+\n+        if (commandEngine == null) {\n             throw new NullPointerException(\"commandEngine cannot be null\");\n         }\n+\n         if (systemConfig == null) {\n             throw new NullPointerException(\"systemConfig cannot be null\");\n         }\n \n         // ---------------------------------\n-        \n         this.ingestService = ingestService;\n         this.datasetService = datasetService;\n         this.fileService = fileService;\n         this.permissionService = permissionService;\n         this.commandEngine = commandEngine;\n         this.systemConfig = systemConfig;\n-        \n-        \n-        \n         initErrorHandling();\n         \n         // Initiate instance vars\n         this.dataset = null;\n         this.dvRequest = dvRequest;\n         this.user = dvRequest.getUser();\n-        \n     }\n     \n     /**\n@@ -309,26 +300,17 @@ public class AddReplaceFileHelper{\n      * @param optionalFileParams\n      * @return \n      */\n-    public boolean runAddFileByDataset(Dataset chosenDataset, \n-            String newFileName, \n-            String newFileContentType, \n-            String newStorageIdentifier,\n-            InputStream newFileInputStream,\n-            OptionalFileParams optionalFileParams){\n-        \n-        msgt(\">> runAddFileByDatasetId\");\n \n+    public boolean runAddFileByDataset(Dataset chosenDataset, String newFileName, String newFileContentType, String newStorageIdentifier, InputStream newFileInputStream, OptionalFileParams optionalFileParams) {\n+        msgt(\">> runAddFileByDatasetId\");\n         initErrorHandling();\n-        \n         this.currentOperation = FILE_ADD_OPERATION;\n-        \n-        if (!this.step_001_loadDataset(chosenDataset)){\n+        if (!this.step_001_loadDataset(chosenDataset)) {\n             return false;\n         }\n         \n         //return this.runAddFile(this.dataset, newFileName, newFileContentType, newFileInputStream, optionalFileParams);\n         return this.runAddReplaceFile(dataset, newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n-\n     }\n     \n     \n@@ -370,48 +352,35 @@ public class AddReplaceFileHelper{\n      * @param newFileInputStream\n      * @return \n      */\n-    public boolean runForceReplaceFile(Long oldFileId,\n-                        String newFileName, \n-                        String newFileContentType, \n-                        String newStorageIdentifier,\n-                        InputStream newFileInputStream,\n-                        OptionalFileParams optionalFileParams){\n-        \n+\n+    public boolean runForceReplaceFile(Long oldFileId, String newFileName, String newFileContentType, String newStorageIdentifier, InputStream newFileInputStream, OptionalFileParams optionalFileParams) {\n         msgt(\">> runForceReplaceFile\");\n         initErrorHandling();\n-\n         this.currentOperation = FILE_REPLACE_FORCE_OPERATION;\n-\n-               \n-        if (oldFileId==null){\n+        if (oldFileId == null) {\n             this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n             return false;\n         }\n        \n         // Loads local variable \"fileToReplace\"\n         //\n-        if (!this.step_005_loadFileToReplaceById(oldFileId)){\n+\n+        if (!this.step_005_loadFileToReplaceById(oldFileId)) {\n             return false;\n         }\n-\n-        \n-        return this.runAddReplaceFile(fileToReplace.getOwner(), newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n+        return this.runAddReplaceFile(fileToReplace.getOwner(),\n+                                         newFileName,\n+                                         newFileContentType,\n+                                         newStorageIdentifier,\n+                                         newFileInputStream,\n+                                         optionalFileParams);\n     }\n-    \n \n-\tpublic boolean runReplaceFile(Long oldFileId,\n-                            String newFileName, \n-                            String newFileContentType, \n-                            String newStorageIdentifier, \n-                            InputStream newFileInputStream,\n-                            OptionalFileParams optionalFileParams){\n-    \n+    public boolean runReplaceFile(Long oldFileId, String newFileName, String newFileContentType, String newStorageIdentifier, InputStream newFileInputStream, OptionalFileParams optionalFileParams) {\n         msgt(\">> runReplaceFile\");\n-\n         initErrorHandling();\n         this.currentOperation = FILE_REPLACE_OPERATION;\n-        \n-        if (oldFileId==null){\n+        if (oldFileId == null) {\n             this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n             return false;\n         }\n@@ -419,10 +388,16 @@ public class AddReplaceFileHelper{\n          \n         // Loads local variable \"fileToReplace\"\n         //\n-        if (!this.step_005_loadFileToReplaceById(oldFileId)){\n+\n+        if (!this.step_005_loadFileToReplaceById(oldFileId)) {\n             return false;\n         }\n-        return this.runAddReplaceFile(fileToReplace.getOwner(), newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n+        return this.runAddReplaceFile(fileToReplace.getOwner(),\n+                                         newFileName,\n+                                         newFileContentType,\n+                                         newStorageIdentifier,\n+                                         newFileInputStream,\n+                                         optionalFileParams);\n     }\n     \n     \n@@ -446,29 +421,17 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    \n-    private boolean runAddReplaceFile(Dataset owner,  \n-            String newFileName, String newFileContentType, \n-            String newStorageIdentifier, InputStream newFileInputStream,\n-            OptionalFileParams optionalFileParams){\n+\n+    private boolean runAddReplaceFile(Dataset owner, String newFileName, String newFileContentType, String newStorageIdentifier, InputStream newFileInputStream, OptionalFileParams optionalFileParams) {\n         \n         // Run \"Phase 1\" - Initial ingest of file + error check\n         // But don't save the dataset version yet\n         //\n-        boolean phase1Success = runAddReplacePhase1(owner,  \n-                                        newFileName,  \n-                                        newFileContentType,  \n-                                        newStorageIdentifier,\n-                                        newFileInputStream,\n-                                        optionalFileParams\n-                                        );\n-        if (!phase1Success){\n+        boolean phase1Success = runAddReplacePhase1(owner, newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n+        if (!phase1Success) {\n             return false;\n         }\n-        \n-       \n         return runAddReplacePhase2();\n-        \n     }\n \n     /**\n@@ -482,18 +445,11 @@ public class AddReplaceFileHelper{\n      * @param optionalFileParams\n      * @return \n      */\n-    public boolean runReplaceFromUI_Phase1(Long oldFileId,  \n-            String newFileName, \n-            String newFileContentType,\n-            InputStream newFileInputStream,\n-            String fullStorageId,\n-            OptionalFileParams optionalFileParams){\n-        \n-        \n+\n+    public boolean runReplaceFromUI_Phase1(Long oldFileId, String newFileName, String newFileContentType, InputStream newFileInputStream, String fullStorageId, OptionalFileParams optionalFileParams) {\n         initErrorHandling();\n         this.currentOperation = FILE_REPLACE_FORCE_OPERATION;\n-        \n-        if (oldFileId==null){\n+        if (oldFileId == null) {\n             this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n             return false;\n         }\n@@ -501,11 +457,13 @@ public class AddReplaceFileHelper{\n          \n         // Loads local variable \"fileToReplace\"\n         //\n-        if (!this.step_005_loadFileToReplaceById(oldFileId)){\n+\n+        if (!this.step_005_loadFileToReplaceById(oldFileId)) {\n             return false;\n         }\n         //Update params to match existing file (except checksum, which should match the new file)\n-        if(fileToReplace != null) {\n+\n+        if (fileToReplace != null) {\n             String checksum = optionalFileParams.getCheckSum();\n             ChecksumType checkSumType = optionalFileParams.getCheckSumType();\n             try {\n@@ -516,15 +474,12 @@ public class AddReplaceFileHelper{\n                 e.printStackTrace();\n             }\n         }\n-\n-        return this.runAddReplacePhase1(fileToReplace.getOwner(), \n-                newFileName, \n-                newFileContentType,\n-                fullStorageId,\n-                newFileInputStream, \n-                optionalFileParams);\n-\n-       \n+        return this.runAddReplacePhase1(fileToReplace.getOwner(),\n+                                           newFileName,\n+                                           newFileContentType,\n+                                           fullStorageId,\n+                                           newFileInputStream,\n+                                           optionalFileParams);\n     }\n     \n     \n@@ -537,56 +492,45 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    private boolean runAddReplacePhase1(Dataset owner,  \n-            String newFileName, \n-            String newFileContentType,\n-            String newStorageIdentifier, InputStream newFileInputStream,\n-            OptionalFileParams optionalFileParams){\n-        \n-        if (this.hasError()){\n+\n+    private boolean runAddReplacePhase1(Dataset owner, String newFileName, String newFileContentType, String newStorageIdentifier, InputStream newFileInputStream, OptionalFileParams optionalFileParams) {\n+        if (this.hasError()) {\n             return false;   // possible to have errors already...\n         }\n-\n         msgt(\"step_001_loadDataset\");\n-        if (!this.step_001_loadDataset(owner)){\n+        if (!this.step_001_loadDataset(owner)) {\n             return false;\n         }\n-        \n         msgt(\"step_010_VerifyUserAndPermissions\");\n-        if (!this.step_010_VerifyUserAndPermissions()){\n+        if (!this.step_010_VerifyUserAndPermissions()) {\n             return false;\n-            \n         }\n-\n         msgt(\"step_020_loadNewFile\");\n-        if (!this.step_020_loadNewFile(newFileName, newFileContentType, newStorageIdentifier, newFileInputStream)){\n+        if (!this.step_020_loadNewFile(newFileName, newFileContentType, newStorageIdentifier, newFileInputStream)) {\n             return false;\n-            \n-        }\n-        if(optionalFileParams != null) {\n-        \tif(optionalFileParams.hasCheckSum()) {\n-        \t\tnewCheckSum = optionalFileParams.getCheckSum();\n-        \t\tnewCheckSumType = optionalFileParams.getCheckSumType();\n-        \t}\n         }\n \n+        if (optionalFileParams != null) {\n+            if (optionalFileParams.hasCheckSum()) {\n+                newCheckSum = optionalFileParams.getCheckSum();\n+                newCheckSumType = optionalFileParams.getCheckSumType();\n+            }\n+        }\n         msgt(\"step_030_createNewFilesViaIngest\");\n-        if (!this.step_030_createNewFilesViaIngest()){\n+        if (!this.step_030_createNewFilesViaIngest()) {\n             return false;\n-            \n         }\n-\n         msgt(\"step_050_checkForConstraintViolations\");\n-        if (!this.step_050_checkForConstraintViolations()){\n-            return false;            \n+        if (!this.step_050_checkForConstraintViolations()) {\n+            return false;\n         }\n-        \n         msgt(\"step_055_loadOptionalFileParams\");\n-        if (!this.step_055_loadOptionalFileParams(optionalFileParams)){\n-            return false;            \n+        if (!this.step_055_loadOptionalFileParams(optionalFileParams)) {\n+            return false;\n         }\n         \n         // if the fileToReplace hasn't been released,\n+\n         if (fileToReplace != null && !fileToReplace.isReleased()) {\n             DataFile df = finalFileList.get(0); // step_055 uses a loop and assumes only one file\n             // set the replacement file's previous and root datafileIds to match (unless\n@@ -596,6 +540,7 @@ public class AddReplaceFileHelper{\n                 df.setRootDataFileId(fileToReplace.getRootDataFileId());\n             }\n             // Reuse any file PID during a replace operation (if File PIDs are in use)\n+\n             if (systemConfig.isFilePIDsEnabled()) {\n                 df.setGlobalId(fileToReplace.getGlobalId());\n                 df.setGlobalIdCreateTime(fileToReplace.getGlobalIdCreateTime());\n@@ -605,12 +550,10 @@ public class AddReplaceFileHelper{\n                 fileToReplace.setGlobalId(null);\n             }\n         }\n-\n         return true;\n     }\n-    \n-    \n-    public boolean runReplaceFromUI_Phase2(){\n+\n+    public boolean runReplaceFromUI_Phase2() {\n         return runAddReplacePhase2();\n     }\n     \n@@ -621,34 +564,34 @@ public class AddReplaceFileHelper{\n      * @param categoriesList\n      * @return \n      */\n-    public boolean updateCategoriesFromUI(List<String> categoriesList){\n-        if (hasError()){\n+\n+    public boolean updateCategoriesFromUI(List<String> categoriesList) {\n+        if (hasError()) {\n             logger.severe(\"Should not be calling this method\");\n             return false;\n         }\n-        \n-        if ((finalFileList==null)||(finalFileList.size()==0)){\n+\n+        if ((finalFileList == null) || (finalFileList.size() == 0)) {\n             throw new NullPointerException(\"finalFileList needs at least 1 file!!\");\n         }\n         \n         // don't need to make updates\n         //\n-        if (categoriesList ==null){\n-            return true;           \n+\n+        if (categoriesList == null) {\n+            return true;\n         }\n         \n         // remove nulls, dupes, etc.\n         //\n         categoriesList = Util.removeDuplicatesNullsEmptyStrings(categoriesList);\n-        if (categoriesList.isEmpty()){\n+        if (categoriesList.isEmpty()) {\n             return true;\n         }\n-        \n-        for (DataFile df : finalFileList){\n-            \n+\n+        for (DataFile df : finalFileList) {\n             df.getFileMetadata().setCategoriesByName(categoriesList);\n         }\n-        \n         return true;\n     }\n     \n@@ -660,38 +603,37 @@ public class AddReplaceFileHelper{\n      * @param restricted\n      * @return \n      */\n-    public boolean updateLabelDescriptionRestrictedFromUI(String label, String description, Boolean restricted){\n-                \n-        if (hasError()){\n+\n+    public boolean updateLabelDescriptionRestrictedFromUI(String label, String description, Boolean restricted) {\n+        if (hasError()) {\n             logger.severe(\"Should not be calling this method\");\n             return false;\n         }\n-        \n-        if ((finalFileList==null)||(finalFileList.size()==0)){\n+\n+        if ((finalFileList == null) || (finalFileList.size() == 0)) {\n             throw new NullPointerException(\"finalFileList needs at least 1 file!!\");\n         }\n-        \n-        \n-        for (DataFile df : finalFileList){\n+\n+        for (DataFile df : finalFileList) {\n             \n             // update description\n-            if (description != null){\n+            if (description != null) {\n                 df.getFileMetadata().setDescription(description.trim());\n             }        \n \n             // update label\n-            if (label != null){\n+\n+            if (label != null) {\n                 df.getFileMetadata().setLabel(label.trim());\n             }               \n             \n             // update restriction\n-            if (restricted == null){\n+\n+            if (restricted == null) {\n                 restricted = false;\n             }\n-            \n             df.getFileMetadata().setRestricted(restricted);\n         }\n-        \n         return true;\n     }\n     \n@@ -702,46 +644,40 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    private boolean runAddReplacePhase2(){\n-        \n-        if (this.hasError()){\n+\n+    private boolean runAddReplacePhase2() {\n+        if (this.hasError()) {\n             return false;   // possible to have errors already...\n         }\n \n-        if ((finalFileList ==  null)||(finalFileList.isEmpty())){\n+        if ((finalFileList == null) || (finalFileList.isEmpty())) {\n             addError(getBundleErr(\"phase2_called_early_no_new_files\"));\n             return false;\n         }\n-        \n-         msgt(\"step_060_addFilesViaIngestService\");\n-        if (!this.step_060_addFilesViaIngestService()){\n+        msgt(\"step_060_addFilesViaIngestService\");\n+        if (!this.step_060_addFilesViaIngestService()) {\n             return false;\n-            \n         }\n-        \n-        if (this.isFileReplaceOperation()){\n+\n+        if (this.isFileReplaceOperation()) {\n             msgt(\"step_080_run_update_dataset_command_for_replace\");\n-            if (!this.step_080_run_update_dataset_command_for_replace()){\n-                return false;            \n+            if (!this.step_080_run_update_dataset_command_for_replace()) {\n+                return false;\n             }\n-            \n-        }else{\n+        } else {\n             msgt(\"step_070_run_update_dataset_command\");\n-            if (!this.step_070_run_update_dataset_command()){\n-                return false;            \n+            if (!this.step_070_run_update_dataset_command()) {\n+                return false;\n             }\n         }\n-        \n         msgt(\"step_090_notifyUser\");\n-        if (!this.step_090_notifyUser()){\n-            return false;            \n+        if (!this.step_090_notifyUser()) {\n+            return false;\n         }\n-\n         msgt(\"step_100_startIngestJobs\");\n-        if (!this.step_100_startIngestJobs()){\n-            return false;            \n+        if (!this.step_100_startIngestJobs()) {\n+            return false;\n         }\n-\n         return true;\n     }\n     \n@@ -750,7 +686,8 @@ public class AddReplaceFileHelper{\n      *  Get for currentOperation\n      *  @return String\n      */\n-    public String getCurrentOperation(){\n+\n+    public String getCurrentOperation() {\n         return this.currentOperation;\n     }\n \n@@ -762,8 +699,8 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    public boolean isForceFileOperation(){\n-        \n+\n+    public boolean isForceFileOperation() {\n         return this.currentOperation.equals(FILE_REPLACE_FORCE_OPERATION);\n     }\n     \n@@ -771,11 +708,11 @@ public class AddReplaceFileHelper{\n      * Is this a file replace operation?\n      * @return \n      */\n-    public boolean isFileReplaceOperation(){\n-    \n-        if (this.currentOperation.equals(FILE_REPLACE_OPERATION)){\n+\n+    public boolean isFileReplaceOperation() {\n+        if (this.currentOperation.equals(FILE_REPLACE_OPERATION)) {\n             return true;\n-        }else if (this.currentOperation.equals(FILE_REPLACE_FORCE_OPERATION)){\n+        } else if (this.currentOperation.equals(FILE_REPLACE_FORCE_OPERATION)) {\n             return true;\n         }\n         return false;\n@@ -786,21 +723,19 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    public boolean isFileAddOperation(){\n-    \n+\n+    public boolean isFileAddOperation() {\n         return this.currentOperation.equals(FILE_ADD_OPERATION);\n     }\n \n     /**\n      * Initialize error handling vars\n      */\n-    private void initErrorHandling(){\n \n+    private void initErrorHandling() {\n         this.errorFound = false;\n         this.errorMessages = new ArrayList<>();\n         this.httpErrorCode = null;\n-        \n-        \n         contentTypeWarningFound = false;\n         contentTypeWarningString = null;\n     }\n@@ -812,13 +747,12 @@ public class AddReplaceFileHelper{\n      * \n      * @param errMsg \n      */\n-    private void addError(String errMsg){\n-        \n-        if (errMsg == null){\n+\n+    private void addError(String errMsg) {\n+        if (errMsg == null) {\n             throw new NullPointerException(\"errMsg cannot be null\");\n         }\n         this.errorFound = true;\n- \n         logger.fine(errMsg);\n         this.errorMessages.add(errMsg);\n     }\n@@ -829,41 +763,33 @@ public class AddReplaceFileHelper{\n      * @param badHttpResponse, e.g. Response.Status.FORBIDDEN\n      * @param errMsg \n      */\n-    private void addError(Response.Status badHttpResponse, String errMsg){\n-        \n-        if (badHttpResponse == null){\n+\n+    private void addError(Response.Status badHttpResponse, String errMsg) {\n+        if (badHttpResponse == null) {\n             throw new NullPointerException(\"badHttpResponse cannot be null\");\n         }\n-        if (errMsg == null){\n+\n+        if (errMsg == null) {\n             throw new NullPointerException(\"errMsg cannot be null\");\n         }\n-      \n         this.httpErrorCode = badHttpResponse;\n-        \n         this.addError(errMsg);\n-                \n-        \n     }\n-    \n-    private void addErrorWarning(String errMsg){\n-        if (errMsg == null){\n+\n+    private void addErrorWarning(String errMsg) {\n+        if (errMsg == null) {\n             throw new NullPointerException(\"errMsg cannot be null\");\n         }\n- \n         logger.severe(errMsg);\n         this.setDuplicateFileWarning(errMsg);\n         this.errorMessages.add(errMsg);\n-        \n     }\n-    \n-    \n-    private void addErrorSevere(String errMsg){\n-        \n-        if (errMsg == null){\n+\n+    private void addErrorSevere(String errMsg) {\n+        if (errMsg == null) {\n             throw new NullPointerException(\"errMsg cannot be null\");\n         }\n         this.errorFound = true;\n- \n         logger.severe(errMsg);\n         this.errorMessages.add(errMsg);\n     }\n@@ -874,9 +800,9 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    public boolean hasError(){\n+\n+    public boolean hasError() {\n         return this.errorFound;\n-        \n     }\n     \n     /**\n@@ -884,7 +810,8 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    public List<String> getErrorMessages(){\n+\n+    public List<String> getErrorMessages() {\n         return this.errorMessages;\n     }   \n \n@@ -894,8 +821,9 @@ public class AddReplaceFileHelper{\n      * @param joinString\n      * @return \n      */\n-    public String getErrorMessagesAsString(String joinString){\n-        if (joinString==null){\n+\n+    public String getErrorMessagesAsString(String joinString) {\n+        if (joinString == null) {\n             joinString = \"\\n\";\n         }\n         return String.join(joinString, this.errorMessages);\n@@ -909,15 +837,15 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    public Response.Status getHttpErrorCode(){\n-       \n-        if (!hasError()){\n+\n+    public Response.Status getHttpErrorCode() {\n+        if (!hasError()) {\n             logger.severe(\"Do not call this method unless there is an error!  check '.hasError()'\");\n         }\n-        \n-        if (httpErrorCode == null){\n+\n+        if (httpErrorCode == null) {\n             return Response.Status.BAD_REQUEST;\n-        }else{\n+        } else {\n             return httpErrorCode;\n         }\n     }\n@@ -933,17 +861,18 @@ public class AddReplaceFileHelper{\n      * key (\"file.addreplace.error.add.add_file_error\") leading you to believe\n      * that the bundle key is not used.\n      */\n+\n     @Deprecated\n-    private String getBundleMsg(String msgName, boolean isErr){\n-        if (msgName == null){\n+    private String getBundleMsg(String msgName, boolean isErr) {\n+        if (msgName == null) {\n             throw new NullPointerException(\"msgName cannot be null\");\n         }\n-        if (isErr){        \n+\n+        if (isErr) {\n             return BundleUtil.getStringFromBundle(\"file.addreplace.error.\" + msgName);\n-        }else{\n+        } else {\n             return BundleUtil.getStringFromBundle(\"file.addreplace.success.\" + msgName);\n         }\n-       \n     }\n     \n     /**\n@@ -952,7 +881,8 @@ public class AddReplaceFileHelper{\n      * @param msgName\n      * @return \n      */\n-    private String getBundleErr(String msgName){\n+\n+    private String getBundleErr(String msgName) {\n         return this.getBundleMsg(msgName, true);\n     }\n     \n@@ -961,19 +891,17 @@ public class AddReplaceFileHelper{\n     /**\n      * \n      */\n-    private boolean step_001_loadDataset(Dataset selectedDataset){\n \n-        if (this.hasError()){\n+    private boolean step_001_loadDataset(Dataset selectedDataset) {\n+        if (this.hasError()) {\n             return false;\n         }\n \n-        if (selectedDataset == null){\n+        if (selectedDataset == null) {\n             this.addErrorSevere(getBundleErr(\"dataset_is_null\"));\n             return false;\n         }\n-\n         dataset = selectedDataset;\n-        \n         return true;\n     }\n     \n@@ -985,76 +913,65 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    private boolean step_010_VerifyUserAndPermissions(){\n-        \n-        if (this.hasError()){\n+\n+    private boolean step_010_VerifyUserAndPermissions() {\n+        if (this.hasError()) {\n             return false;\n         }\n-                \n         return step_015_auto_check_permissions(dataset);\n-\n     }\n-    \n-    private boolean step_015_auto_check_permissions(Dataset datasetToCheck){\n-        \n-        if (this.hasError()){\n+\n+    private boolean step_015_auto_check_permissions(Dataset datasetToCheck) {\n+        if (this.hasError()) {\n             return false;\n         }\n-        \n-        if (datasetToCheck == null){\n+\n+        if (datasetToCheck == null) {\n             addError(getBundleErr(\"dataset_is_null\"));\n             return false;\n         }\n         \n         // Make a temp. command\n         //\n-        \n+\n         Command updateDatasetVersionCommand = new UpdateDatasetVersionCommand(datasetToCheck, dvRequest);\n         \n         // Can this user run the command?\n         //\n         if (!permissionService.isUserAllowedOn(dvRequest.getUser(), updateDatasetVersionCommand, datasetToCheck)) {\n-            addError(Response.Status.FORBIDDEN,getBundleErr(\"no_edit_dataset_permission\"));\n-           return false;\n+            addError(Response.Status.FORBIDDEN, getBundleErr(\"no_edit_dataset_permission\"));\n+            return false;\n         }\n-        \n         return true;\n-        \n     }\n-    \n-    \n-    private boolean step_020_loadNewFile(String fileName, String fileContentType, String storageIdentifier, InputStream fileInputStream){\n-        \n-        if (this.hasError()){\n+\n+    private boolean step_020_loadNewFile(String fileName, String fileContentType, String storageIdentifier, InputStream fileInputStream) {\n+        if (this.hasError()) {\n             return false;\n         }\n-        \n-        if (fileName == null){\n+\n+        if (fileName == null) {\n             this.addErrorSevere(getBundleErr(\"filename_undetermined\"));\n             return false;\n-            \n         }\n \n-        if (fileContentType == null){\n+        if (fileContentType == null) {\n             this.addErrorSevere(getBundleErr(\"file_content_type_undetermined\"));\n             return false;\n-            \n         }\n-        \n-\t\tif (fileInputStream == null) {\n-\t\t\tif (storageIdentifier == null) {\n-\t\t\t\tthis.addErrorSevere(getBundleErr(\"file_upload_failed\"));\n-\t\t\t\treturn false;\n-\t\t\t} \n-\t\t} \n-\t\t\n+\n+        if (fileInputStream == null) {\n+            if (storageIdentifier == null) {\n+                this.addErrorSevere(getBundleErr(\"file_upload_failed\"));\n+                return false;\n+            }\n+        }\n         newFileName = fileName;\n         newFileContentType = fileContentType;\n         \n         //One of these will be null\n-    \tnewStorageIdentifier = storageIdentifier;\n+        newStorageIdentifier = storageIdentifier;\n         newFileInputStream = fileInputStream;\n-        \n         return true;\n     }\n \n@@ -1065,44 +982,45 @@ public class AddReplaceFileHelper{\n      * @param oldFile\n      * @return \n      */\n-    private boolean step_005_loadFileToReplaceById(Long dataFileId){\n-        \n-        if (this.hasError()){\n+\n+    private boolean step_005_loadFileToReplaceById(Long dataFileId) {\n+        if (this.hasError()) {\n             return false;\n         }\n         \n         //  Check for Null\n         //\n-        if (dataFileId == null){\n+\n+        if (dataFileId == null) {\n             this.addErrorSevere(getBundleErr(\"existing_file_to_replace_id_is_null\"));\n             return false;\n         }\n         \n         // Does the file exist?\n         //\n+\n         DataFile existingFile = fileService.find(dataFileId);\n-        \n-        if (existingFile == null){           \n-            this.addError(BundleUtil.getStringFromBundle(\"file.addreplace.error.existing_file_to_replace_not_found_by_id\", Collections.singletonList(dataFileId.toString())));\n+        if (existingFile == null) {\n+            this.addError(BundleUtil.getStringFromBundle(\"file.addreplace.error.existing_file_to_replace_not_found_by_id\",\n+                                                         Collections.singletonList(dataFileId.toString())));\n             return false;\n         } \n         \n \n         // Do we have permission to replace this file? e.g. Edit the file's dataset\n         //\n-        if (!step_015_auto_check_permissions(existingFile.getOwner())){\n+\n+        if (!step_015_auto_check_permissions(existingFile.getOwner())) {\n             return false;\n-        };\n+        }\n+        ;\n         // Is the file in the latest dataset version?\n         //\n-        if (!step_007_auto_isReplacementInLatestVersion(existingFile)){\n+        if (!step_007_auto_isReplacementInLatestVersion(existingFile)) {\n             return false;\n         }\n-        \n         fileToReplace = existingFile;\n-        \n-        return true;        \n-\n+        return true;\n     }\n     \n     /**\n@@ -1111,54 +1029,43 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    private boolean step_007_auto_isReplacementInLatestVersion(DataFile existingFile){\n-        \n-        if (existingFile == null){\n+\n+    private boolean step_007_auto_isReplacementInLatestVersion(DataFile existingFile) {\n+        if (existingFile == null) {\n             throw new NullPointerException(\"existingFile cannot be null!\");\n         }\n \n-        if (this.hasError()){\n+        if (this.hasError()) {\n             return false;\n         }\n-        \n-        \n+\n         DatasetVersion latestVersion = existingFile.getOwner().getLatestVersion();\n-        \n         boolean fileInLatestVersion = false;\n-        for (FileMetadata fm : latestVersion.getFileMetadatas()){\n-            if (fm.getDataFile().getId() != null){\n-                if (Objects.equals(existingFile.getId(),fm.getDataFile().getId())){\n+        for (FileMetadata fm : latestVersion.getFileMetadatas()) {\n+            if (fm.getDataFile().getId() != null) {\n+                if (Objects.equals(existingFile.getId(), fm.getDataFile().getId())) {\n                     fileInLatestVersion = true;\n                 }\n             }\n         }\n-        if (!fileInLatestVersion){\n+\n+        if (!fileInLatestVersion) {\n             addError(getBundleErr(\"existing_file_not_in_latest_published_version\"));\n-            return false;                        \n+            return false;\n         }\n         return true;\n     }\n-    \n-    \n-    private boolean step_030_createNewFilesViaIngest(){\n-        \n-        if (this.hasError()){\n+\n+    private boolean step_030_createNewFilesViaIngest() {\n+        if (this.hasError()) {\n             return false;\n         }\n \n         // Load the working version of the Dataset\n         workingVersion = dataset.getEditVersion();\n-        clone =   workingVersion.cloneDatasetVersion();\n+        clone = workingVersion.cloneDatasetVersion();\n         try {\n-            initialFileList = FileUtil.createDataFiles(workingVersion,\n-                    this.newFileInputStream,\n-                    this.newFileName,\n-                    this.newFileContentType,\n-                    this.newStorageIdentifier,\n-                    this.newCheckSum,\n-                    this.newCheckSumType,\n-                    this.systemConfig);\n-\n+            initialFileList = FileUtil.createDataFiles(workingVersion, this.newFileInputStream, this.newFileName, this.newFileContentType, this.newStorageIdentifier, this.newCheckSum, this.newCheckSumType, this.systemConfig);\n         } catch (IOException ex) {\n             if (!Strings.isNullOrEmpty(ex.getMessage())) {\n                 this.addErrorSevere(getBundleErr(\"ingest_create_file_err\") + \" \" + ex.getMessage());\n@@ -1166,17 +1073,18 @@ public class AddReplaceFileHelper{\n                 this.addErrorSevere(getBundleErr(\"ingest_create_file_err\"));\n             }\n             logger.severe(ex.toString());\n-            this.runMajorCleanup(); \n+            this.runMajorCleanup();\n             return false;\n         } finally {\n             IOUtils.closeQuietly(this.newFileInputStream);\n-         }\n+        }\n          /**\n          * This only happens:\n          *  (1) the dataset was empty\n          *  (2) the new file (or new file unzipped) did not ingest via \"createDataFiles\"\n          */\n-        if (initialFileList.isEmpty()){\n+\n+        if (initialFileList.isEmpty()) {\n             this.addErrorSevere(getBundleErr(\"initial_file_list_empty\"));\n             this.runMajorCleanup();\n             return false;\n@@ -1188,16 +1096,16 @@ public class AddReplaceFileHelper{\n          * ADD: When adding files, some types of individual files\n          * are broken into several files--which is OK\n          */\n-        if (isFileReplaceOperation()){\n-            if (initialFileList.size() > 1){\n+\n+        if (isFileReplaceOperation()) {\n+            if (initialFileList.size() > 1) {\n                 this.addError(getBundleErr(\"initial_file_list_more_than_one\"));\n                 this.runMajorCleanup();\n                 return false;\n-\n             }\n         }\n-        \n-        if (this.step_040_auto_checkForDuplicates()){\n+\n+        if (this.step_040_auto_checkForDuplicates()) {\n             return true;\n         }\n                        \n@@ -1207,7 +1115,6 @@ public class AddReplaceFileHelper{\n         if (this.step_045_auto_checkForFileReplaceDuplicate()) {\n             return true;\n         }*/\n-        \n         return false;\n     }\n     \n@@ -1219,29 +1126,27 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    private boolean step_040_auto_checkForDuplicates(){\n+\n+    private boolean step_040_auto_checkForDuplicates() {\n         this.duplicateFileErrorString = \"\";\n         this.duplicateFileErrorFound = false;\n-        \n         msgt(\"step_040_auto_checkForDuplicates\");\n-        if (this.hasError()){\n+        if (this.hasError()) {\n             return false;\n         }\n         \n         // Double checked -- this check also happens in step 30\n         //\n-        if (initialFileList.isEmpty()){\n+\n+        if (initialFileList.isEmpty()) {\n             this.addErrorSevere(getBundleErr(\"initial_file_list_empty\"));\n             return false;\n         }\n \n         // Initialize new file list\n         this.finalFileList = new ArrayList<>();\n-\n-        String warningMessage  = null;\n-        \n-\n-        if (isFileReplaceOperation() && this.fileToReplace == null){\n+        String warningMessage = null;\n+        if (isFileReplaceOperation() && this.fileToReplace == null) {\n             // This error shouldn't happen if steps called correctly\n             this.addErrorSevere(getBundleErr(\"existing_file_to_replace_is_null\") + \" (This error shouldn't happen if steps called in sequence....checkForFileReplaceDuplicate)\");\n             return false;\n@@ -1250,8 +1155,9 @@ public class AddReplaceFileHelper{\n         // -----------------------------------------------------------\n         // Iterate through the recently ingest files\n         // -----------------------------------------------------------\n-        for (DataFile df : initialFileList){\n-             msg(\"Checking file: \" + df.getFileMetadata().getLabel());\n+\n+        for (DataFile df : initialFileList) {\n+            msg(\"Checking file: \" + df.getFileMetadata().getLabel());\n \n             // -----------------------------------------------------------\n             // (1) Check for ingest warnings\n@@ -1269,30 +1175,29 @@ public class AddReplaceFileHelper{\n             // (2) Check for duplicates\n             // Only a warning now\n             // -----------------------------------------------------------     \n-            if (isFileReplaceOperation() && Objects.equals(df.getChecksumValue(), fileToReplace.getChecksumValue())){\n-                this.addError(getBundleErr(\"replace.new_file_same_as_replacement\"));                \n+\n+            if (isFileReplaceOperation() && Objects.equals(df.getChecksumValue(), fileToReplace.getChecksumValue())) {\n+                this.addError(getBundleErr(\"replace.new_file_same_as_replacement\"));\n                 this.duplicateFileErrorFound = true;\n                 this.duplicateFileErrorString = getBundleErr(\"replace.new_file_same_as_replacement\");\n                 break;\n-            } \n-            \n-            if (DuplicateFileChecker.isDuplicateOriginalWay(workingVersion, df.getFileMetadata())){\n+            }\n+\n+            if (DuplicateFileChecker.isDuplicateOriginalWay(workingVersion, df.getFileMetadata())) {\n                 String dupeName = df.getFileMetadata().getLabel();\n                 this.duplicateFileWarningFound = true;\n-                this.duplicateFileWarningString = BundleUtil.getStringFromBundle(\"file.addreplace.warning.duplicate_file\", \n-                                Arrays.asList(dupeName));\n-                this.addErrorWarning(this.duplicateFileWarningString); \n-\n-            }             \n+                this.duplicateFileWarningString = BundleUtil.getStringFromBundle(\"file.addreplace.warning.duplicate_file\", Arrays.asList(dupeName));\n+                this.addErrorWarning(this.duplicateFileWarningString);\n+            }\n             finalFileList.add(df);\n         }\n-        \n-        if (this.hasError()){\n+\n+        if (this.hasError()) {\n             // We're recovering from the duplicate check.\n             msg(\"We're recovering from a duplicate check 1\");\n             runMajorCleanup();\n             msg(\"We're recovering from a duplicate check 2\");\n-            finalFileList.clear();           \n+            finalFileList.clear();\n             return false;\n         }\n         \n@@ -1308,30 +1213,26 @@ public class AddReplaceFileHelper{\n         *  file. Treat this as a fatal error, unless this is a \"force replace\" \n         *  operation; then it should be treated as merely a warning.\n         */\n-        if (isFileReplaceOperation()){\n-        \n-            if (finalFileList.size() > 1){     \n+\n+        if (isFileReplaceOperation()) {\n+            if (finalFileList.size() > 1) {\n                 String errMsg = \"(This shouldn't happen -- error should have been detected in 030_createNewFilesViaIngest)\";\n-                this.addErrorSevere(getBundleErr(\"initial_file_list_more_than_one\") + \" \" + errMsg);            \n+                this.addErrorSevere(getBundleErr(\"initial_file_list_more_than_one\") + \" \" + errMsg);\n                 return false;\n             }\n             \n             // Has the content type of the file changed?\n             //\n+\n             String fileType = fileToReplace.getOriginalFileFormat() != null ? fileToReplace.getOriginalFileFormat() : fileToReplace.getContentType();\n             if (!finalFileList.get(0).getContentType().equalsIgnoreCase(fileType)) {\n                 String friendlyType = fileToReplace.getOriginalFormatLabel() != null ? fileToReplace.getOriginalFormatLabel() : fileToReplace.getFriendlyType();\n-                \n-                List<String> errParams = Arrays.asList(friendlyType,\n-                                                finalFileList.get(0).getFriendlyType());\n-                \n-                String contentTypeErr = BundleUtil.getStringFromBundle(\"file.addreplace.error.replace.new_file_has_different_content_type\", \n-                                errParams);\n-                                        \n-                if (isForceFileOperation()){\n+                List<String> errParams = Arrays.asList(friendlyType, finalFileList.get(0).getFriendlyType());\n+                String contentTypeErr = BundleUtil.getStringFromBundle(\"file.addreplace.error.replace.new_file_has_different_content_type\", errParams);\n+                if (isForceFileOperation()) {\n                     // for force replace, just give a warning\n                     this.setContentTypeWarning(contentTypeErr);\n-                }else{\n+                } else {\n                     // not a force replace? it's an error\n                     this.addError(contentTypeErr);\n                     runMajorCleanup();\n@@ -1339,13 +1240,11 @@ public class AddReplaceFileHelper{\n                 }\n             }\n         }\n-        \n-        if (finalFileList.isEmpty()){\n-            this.addErrorSevere(\"There are no files to add.  (This error shouldn't happen if steps called in sequence....step_040_auto_checkForDuplicates)\");                \n+\n+        if (finalFileList.isEmpty()) {\n+            this.addErrorSevere(\"There are no files to add.  (This error shouldn't happen if steps called in sequence....step_040_auto_checkForDuplicates)\");\n             return false;\n         }\n-        \n-        \n         return true;\n     } // end step_040_auto_checkForDuplicates\n     \n@@ -1429,16 +1328,13 @@ public class AddReplaceFileHelper{\n         \n     } // end step_045_auto_checkForFileReplaceDuplicate\n     */\n-    \n-    \n-    \n-    private boolean step_050_checkForConstraintViolations(){\n-                \n-        if (this.hasError()){\n+\n+    private boolean step_050_checkForConstraintViolations() {\n+        if (this.hasError()) {\n             return false;\n         }\n-        \n-        if (finalFileList.isEmpty()){\n+\n+        if (finalFileList.isEmpty()) {\n             // This error shouldn't happen if steps called in sequence....\n             this.addErrorSevere(getBundleErr(\"final_file_list_empty\"));\n             return false;\n@@ -1448,23 +1344,24 @@ public class AddReplaceFileHelper{\n         // Iterate through checking for constraint violations\n         //  Gather all error messages\n         // -----------------------------------------------------------   \n+\n         Set<ConstraintViolation> constraintViolations = workingVersion.validate();    \n \n         // -----------------------------------------------------------   \n         // No violations found\n         // -----------------------------------------------------------   \n-        if (constraintViolations.isEmpty()){\n+        if (constraintViolations.isEmpty()) {\n             return true;\n         }\n         \n         // -----------------------------------------------------------   \n         // violations found: gather all error messages\n         // -----------------------------------------------------------   \n+\n         List<String> errMsgs = new ArrayList<>();\n-        for (ConstraintViolation violation : constraintViolations){\n+        for (ConstraintViolation violation : constraintViolations) {\n             this.addError(violation.getMessage());\n         }\n-        \n         return this.hasError();\n     }\n     \n@@ -1475,16 +1372,17 @@ public class AddReplaceFileHelper{\n      * @param optionalFileParams\n      * @return \n      */\n-    private boolean step_055_loadOptionalFileParams(OptionalFileParams optionalFileParams){\n-        \n-        if (hasError()){\n+\n+    private boolean step_055_loadOptionalFileParams(OptionalFileParams optionalFileParams) {\n+        if (hasError()) {\n             return false;\n         }\n \n         // --------------------------------------------\n         // OK, the object may be null\n         // --------------------------------------------\n-        if (optionalFileParams == null){\n+\n+        if (optionalFileParams == null) {\n             return true;\n         }\n         \n@@ -1493,7 +1391,8 @@ public class AddReplaceFileHelper{\n         // Iterate through files (should only be 1 for now)\n         // Add tags, description, etc\n         // --------------------------------------------\n-        for (DataFile df : finalFileList){\n+\n+        for (DataFile df : finalFileList) {\n             try {\n                 optionalFileParams.addOptionalParams(df);\n                 \n@@ -1502,7 +1401,6 @@ public class AddReplaceFileHelper{\n                 if (restrict != df.getFileMetadata().isRestricted()) {\n                     commandEngine.submit(new RestrictFileCommand(df, dvRequest, restrict));\n                 }\n-                \n             } catch (DataFileTagException ex) {\n                 Logger.getLogger(AddReplaceFileHelper.class.getName()).log(Level.SEVERE, null, ex);\n                 addError(ex.getMessage());\n@@ -1511,26 +1409,22 @@ public class AddReplaceFileHelper{\n                 addError(ex.getMessage());\n             }\n         }\n-        \n-        \n         return true;\n     }\n-    \n-    private boolean step_060_addFilesViaIngestService(){\n-                       \n-        if (this.hasError()){\n+\n+    private boolean step_060_addFilesViaIngestService() {\n+        if (this.hasError()) {\n             return false;\n         }\n-                \n-        if (finalFileList.isEmpty()){\n+\n+        if (finalFileList.isEmpty()) {\n             // This error shouldn't happen if steps called in sequence....\n-            this.addErrorSevere(getBundleErr(\"final_file_list_empty\"));                \n+            this.addErrorSevere(getBundleErr(\"final_file_list_empty\"));\n             return false;\n         }\n-        \n+\n         int nFiles = finalFileList.size();\n         finalFileList = ingestService.saveAndAddFilesToDataset(workingVersion, finalFileList, fileToReplace);\n-\n         if (nFiles != finalFileList.size()) {\n             if (nFiles == 1) {\n                 addError(\"Failed to save the content of the uploaded file.\");\n@@ -1539,7 +1433,6 @@ public class AddReplaceFileHelper{\n             }\n             return false;\n         }\n-        \n         return true;\n     }\n     \n@@ -1549,31 +1442,29 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    private boolean step_070_run_update_dataset_command(){\n-        \n-        if (this.hasError()){\n+\n+    private boolean step_070_run_update_dataset_command() {\n+        if (this.hasError()) {\n             return false;\n         }\n \n         Command<Dataset> update_cmd;\n         String deleteStorageLocation = null;\n-        long deleteFileId=-1;\n-        if(isFileReplaceOperation()) {\n+        long deleteFileId = -1;\n+        if (isFileReplaceOperation()) {\n             List<FileMetadata> filesToDelete = new ArrayList<FileMetadata>();\n             filesToDelete.add(fileToReplace.getFileMetadata());\n-            \n-            if(!fileToReplace.isReleased()) {\n+            if (!fileToReplace.isReleased()) {\n                 //If file is only in draft version, also need to delete the physical file\n-            deleteStorageLocation = fileService.getPhysicalFileToDelete(fileToReplace);\n-            deleteFileId=fileToReplace.getId();\n+                deleteStorageLocation = fileService.getPhysicalFileToDelete(fileToReplace);\n+                deleteFileId = fileToReplace.getId();\n             }\n             //Adding the file to the delete list for the command will delete this filemetadata and, if the file hasn't been released, the datafile itself. \n             update_cmd = new UpdateDatasetVersionCommand(dataset, dvRequest, filesToDelete, clone);\n         } else {\n-          update_cmd = new UpdateDatasetVersionCommand(dataset, dvRequest, clone);\n+            update_cmd = new UpdateDatasetVersionCommand(dataset, dvRequest, clone);\n         }\n-        ((UpdateDatasetVersionCommand) update_cmd).setValidateLenient(true);  \n-        \n+        ((UpdateDatasetVersionCommand) update_cmd).setValidateLenient(true);\n         try {            \n             // Submit the update dataset command \n             // and update the local dataset object\n@@ -1586,7 +1477,7 @@ public class AddReplaceFileHelper{\n             this.addErrorSevere(getBundleErr(\"add.add_file_error\"));\n             logger.severe(ex.getMessage());\n             return false;\n-        }catch (EJBException ex) {\n+        } catch (EJBException ex) {\n             /**\n              * @todo Add a test to exercise this error.\n              */\n@@ -1595,7 +1486,8 @@ public class AddReplaceFileHelper{\n             return false;\n         }\n         //Sanity check\n-        if(isFileReplaceOperation()) {\n+\n+        if (isFileReplaceOperation()) {\n             if (deleteStorageLocation != null) {\n                 // Finalize the delete of the physical file \n                 // (File service will double-check that the datafile no \n@@ -1604,16 +1496,14 @@ public class AddReplaceFileHelper{\n                 try {\n                     fileService.finalizeFileDelete(deleteFileId, deleteStorageLocation);\n                 } catch (IOException ioex) {\n-                    logger.warning(\"Failed to delete the physical file associated with the deleted datafile id=\"\n-                            + deleteFileId + \", storage location: \" + deleteStorageLocation);\n+                    logger.warning(\"Failed to delete the physical file associated with the deleted datafile id=\" + deleteFileId + \", storage location: \" + deleteStorageLocation);\n                 }\n             }\n         }\n         return true;\n     }\n-    \n \n-    private boolean runMajorCleanup(){\n+    private boolean runMajorCleanup() {\n         \n         // (1) remove unsaved files from the working version\n         removeUnSavedFilesFromWorkingVersion();\n@@ -1627,13 +1517,11 @@ public class AddReplaceFileHelper{\n         msgt(\"Clear Files\");\n         while (versionIterator.hasNext()) {\n             DatasetVersion dsv = versionIterator.next();\n-            if (dsv.getId() == null){\n+            if (dsv.getId() == null) {\n                 versionIterator.remove();\n             }\n         }\n-        \n         return true;\n-        \n     }\n     \n     /**\n@@ -1641,7 +1529,8 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    private boolean removeUnSavedFilesFromWorkingVersion(){\n+\n+    private boolean removeUnSavedFilesFromWorkingVersion() {\n         msgt(\"Clean up: removeUnSavedFilesFromWorkingVersion\");\n         \n         // -----------------------------------------------------------\n@@ -1651,7 +1540,7 @@ public class AddReplaceFileHelper{\n         Iterator<FileMetadata> fmIt = workingVersion.getFileMetadatas().iterator(); //dataset.getEditVersion().getFileMetadatas().iterator();//  \n         while (fmIt.hasNext()) {\n             FileMetadata fm = fmIt.next();\n-            if (fm.getDataFile().getId() == null){\n+            if (fm.getDataFile().getId() == null) {\n                 fmIt.remove();\n             }\n         }\n@@ -1659,28 +1548,26 @@ public class AddReplaceFileHelper{\n         // -----------------------------------------------------------\n         // (2) Remove all new DataFile objects\n         // -----------------------------------------------------------                        \n+\n         Iterator<DataFile> dfIt = dataset.getFiles().iterator();\n         msgt(\"Clear Files\");\n         while (dfIt.hasNext()) {\n             DataFile df = dfIt.next();\n-            if (df.getId() == null){\n+            if (df.getId() == null) {\n                 dfIt.remove();\n             }\n         }\n         return true;\n-        \n     }\n-    \n-    \n-    private boolean step_080_run_update_dataset_command_for_replace(){\n \n-        if (!isFileReplaceOperation()){\n+    private boolean step_080_run_update_dataset_command_for_replace() {\n+        if (!isFileReplaceOperation()) {\n             // Shouldn't happen!\n             this.addErrorSevere(getBundleErr(\"only_replace_operation\") + \" (step_080_run_update_dataset_command_for_replace)\");\n             return false;\n         }\n \n-        if (this.hasError()){\n+        if (this.hasError()) {\n             return false;\n         }\n \n@@ -1691,14 +1578,12 @@ public class AddReplaceFileHelper{\n         //  (2) New file: Set the previousFileId to the id of the original file\n         //  (3) New file: Set the rootFileId to the rootFileId of the original file\n         // -----------------------------------------------------------\n- \n-        \n+\n         if (fileToReplace.isReleased()) {\n             /*\n              * Check the root file id on fileToReplace, updating it if necessary\n              */\n             if (fileToReplace.getRootDataFileId().equals(DataFile.ROOT_DATAFILE_ID_DEFAULT)) {\n-\n                 fileToReplace.setRootDataFileId(fileToReplace.getId());\n                 fileToReplace = fileService.save(fileToReplace);\n             }\n@@ -1706,18 +1591,15 @@ public class AddReplaceFileHelper{\n             /*\n              * Go through the final file list, settting the rootFileId and previousFileId\n              */\n+\n             for (DataFile df : finalFileList) {\n                 df.setPreviousDataFileId(fileToReplace.getId());\n-\n                 df.setRootDataFileId(fileToReplace.getRootDataFileId());\n-\n             }\n         }\n         // Call the update dataset command which will delete the replaced filemetadata and file in needed (if file is not released)\n         //\n         return step_070_run_update_dataset_command();\n-        \n-       \n     }\n             \n     /**\n@@ -1732,9 +1614,9 @@ public class AddReplaceFileHelper{\n      * \n      * @param df \n      */\n-    private void setNewlyAddedFiles(List<DataFile> datafiles){\n-        \n-        if (hasError()){\n+\n+    private void setNewlyAddedFiles(List<DataFile> datafiles) {\n+        if (hasError()) {\n             return;\n         }\n             \n@@ -1744,18 +1626,15 @@ public class AddReplaceFileHelper{\n         \n         // Loop of uglinesss...but expect 1 to 4 files in final file list\n         List<FileMetadata> latestFileMetadatas = dataset.getEditVersion().getFileMetadatas();\n-        \n-        \n-        for (DataFile newlyAddedFile : finalFileList){\n-            \n-             for (FileMetadata fm : latestFileMetadatas){\n-                 if (newlyAddedFile.getChecksumValue().equals(fm.getDataFile().getChecksumValue())){\n-                    if (newlyAddedFile.getStorageIdentifier().equals(fm.getDataFile().getStorageIdentifier())){\n+        for (DataFile newlyAddedFile : finalFileList) {\n+            for (FileMetadata fm : latestFileMetadatas) {\n+                if (newlyAddedFile.getChecksumValue().equals(fm.getDataFile().getChecksumValue())) {\n+                    if (newlyAddedFile.getStorageIdentifier().equals(fm.getDataFile().getStorageIdentifier())) {\n                         newlyAddedFiles.add(fm.getDataFile());\n                         newlyAddedFileMetadatas.add(fm);\n                     }\n                 }\n-             }\n+            }\n         }\n         /*\n        \n@@ -1773,59 +1652,51 @@ public class AddReplaceFileHelper{\n             }\n         }\n         */\n-        \n     }\n \n     /**\n      * For a successful replace operation, return a the first newly added file\n      * @return \n      */\n-    public DataFile getFirstNewlyAddedFile(){\n-        \n-        if ((newlyAddedFiles == null)||(newlyAddedFiles.size() == 0)){\n+\n+    public DataFile getFirstNewlyAddedFile() {\n+        if ((newlyAddedFiles == null) || (newlyAddedFiles.size() == 0)) {\n             return null;\n         }\n         return newlyAddedFiles.get(0);\n     }\n-        \n-    public List<DataFile> getNewlyAddedFiles(){\n-        \n+\n+    public List<DataFile> getNewlyAddedFiles() {\n         return newlyAddedFiles;\n     }\n-    \n-    public List<FileMetadata> getNewlyAddedFileMetadatas(){\n-        \n+\n+    public List<FileMetadata> getNewlyAddedFileMetadatas() {\n         return newlyAddedFileMetadatas;\n     }\n-    \n-    \n-    public String getSuccessResult() throws NoFilesException{\n-        if (hasError()){\n+\n+    public String getSuccessResult() throws NoFilesException {\n+        if (hasError()) {\n             throw new NoFilesException(\"Don't call this method if an error exists!! First check 'hasError()'\");\n         }\n \n-        if (newlyAddedFiles == null){\n+        if (newlyAddedFiles == null) {\n             throw new NullPointerException(\"newlyAddedFiles is null!\");\n         }\n-        \n         return getSuccessResultAsJsonObjectBuilder().toString();\n-        \n     }\n-    \n-    public JsonObjectBuilder getSuccessResultAsJsonObjectBuilder() throws NoFilesException{\n-        \n-        if (hasError()){\n+\n+    public JsonObjectBuilder getSuccessResultAsJsonObjectBuilder() throws NoFilesException {\n+        if (hasError()) {\n             throw new NoFilesException(\"Don't call this method if an error exists!! First check 'hasError()'\");\n         }\n-        \n-        if (newlyAddedFiles == null){\n+\n+        if (newlyAddedFiles == null) {\n             throw new NullPointerException(\"newlyAddedFiles is null!\");\n         }\n-        \n-        if (newlyAddedFiles.isEmpty()){\n+\n+        if (newlyAddedFiles.isEmpty()) {\n             throw new NoFilesException(\"newlyAddedFiles is empty!\");\n         }\n-        \n         return JsonPrinter.jsonDataFileList(newlyAddedFiles);\n     }\n     \n@@ -1835,8 +1706,9 @@ public class AddReplaceFileHelper{\n      * user notifications.\n      * \n      */\n-    private boolean step_090_notifyUser(){\n-        if (this.hasError()){\n+\n+    private boolean step_090_notifyUser() {\n+        if (this.hasError()) {\n             return false;\n         }\n        \n@@ -1846,10 +1718,9 @@ public class AddReplaceFileHelper{\n         //\n         return true;\n     }\n-    \n \n-    private boolean step_100_startIngestJobs(){\n-        if (this.hasError()){\n+    private boolean step_100_startIngestJobs() {\n+        if (this.hasError()) {\n             return false;\n         }\n                 \n@@ -1864,27 +1735,27 @@ public class AddReplaceFileHelper{\n         //if (true){\n             //return true;\n         //}\n-        \n         msg(\"pre ingest start\");\n         // start the ingest!\n         //\n-               \n         ingestService.startIngestJobsForDataset(dataset, dvRequest.getAuthenticatedUser());\n-        \n         msg(\"post ingest start\");\n         return true;\n     }\n \n-    \n-    private void msg(String m){\n+    private void msg(String m) {\n         logger.fine(m);\n         //System.out.println(m);\n     }\n-    private void dashes(){\n+\n+    private void dashes() {\n         msg(\"----------------\");\n     }\n-    private void msgt(String m){\n-        dashes(); msg(m); dashes();\n+\n+    private void msgt(String m) {\n+        dashes();\n+        msg(m);\n+        dashes();\n     }\n     \n     \n@@ -1895,12 +1766,12 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    public List<DataFile> getFileListBeforeSave(){\n-        \n+\n+    public List<DataFile> getFileListBeforeSave() {\n         return this.finalFileList;\n     }\n-    \n-    public Boolean isFinalFileListEmpty (){\n+\n+    public Boolean isFinalFileListEmpty() {\n         return this.finalFileList.isEmpty();\n     }\n     \n@@ -1912,44 +1783,40 @@ public class AddReplaceFileHelper{\n      * \n      * @return \n      */\n-    public List<FileMetadata> getNewFileMetadatasBeforeSave(){\n-        \n-        if (this.finalFileList.size() == 0){\n+\n+    public List<FileMetadata> getNewFileMetadatasBeforeSave() {\n+        if (this.finalFileList.size() == 0) {\n             return null;\n         }\n-        \n+\n         List<FileMetadata> fileMetadatas = new ArrayList<>();\n-        for (DataFile df : finalFileList){\n+        for (DataFile df : finalFileList) {\n             fileMetadatas.add(df.getFileMetadata());\n         }\n-        \n         return fileMetadatas;\n-        \n     }\n-    \n-    public void setContentTypeWarning(String warningString){\n-        \n-        if ((warningString == null)||(warningString.isEmpty())){\n+\n+    public void setContentTypeWarning(String warningString) {\n+        if ((warningString == null) || (warningString.isEmpty())) {\n             throw new NullPointerException(\"warningString cannot be null\");\n         }\n-        \n         contentTypeWarningFound = true;\n         contentTypeWarningString = warningString;\n     }\n-    \n-    public boolean hasContentTypeWarning(){\n+\n+    public boolean hasContentTypeWarning() {\n         return this.contentTypeWarningFound;\n     }\n-    \n-    public String getContentTypeWarningString(){\n-        if (!hasContentTypeWarning()){\n+\n+    public String getContentTypeWarningString() {\n+        if (!hasContentTypeWarning()) {\n             // not really a NullPointerException but want to blow up here without adding try/catch everywhere\n             //\n             throw new NullPointerException(\"Don't call this method without checking 'hasContentTypeWarning()'\");\n         }\n         return contentTypeWarningString;\n     }\n-    \n+\n     private String duplicateFileWarning;\n \n     public String getDuplicateFileWarning() {\n@@ -1959,82 +1826,5 @@ public class AddReplaceFileHelper{\n     public void setDuplicateFileWarning(String duplicateFileWarning) {\n         this.duplicateFileWarning = duplicateFileWarning;\n     }\n-    \n-} // end class\n-  /*\n-    DatasetPage sequence:\n-    \n-    (A) editFilesFragment.xhtml -> EditDataFilesPage.handleFileUpload\n-    (B) EditDataFilesPage.java -> handleFileUpload\n-        (1) UploadedFile uf  event.getFile() // UploadedFile\n-            --------\n-                UploadedFile interface:\n-                    public String getFileName()\n-                    public InputStream getInputstream() throws IOException;\n-                    public long getSize();\n-                    public byte[] getContents();\n-                    public String getContentType();\n-                    public void write(String string) throws Exception;\n-            --------\n-        (2) List<DataFile> dFileList = null;     \n-        try {\n-            // Note: A single file may be unzipped into multiple files\n-            dFileList = ingestService.createDataFiles(workingVersion, uFile.getInputstream(), uFile.getFileName(), uFile.getContentType());\n-        }\n-    \n-        (3) processUploadedFileList(dFileList);\n-\n-    (C) EditDataFilesPage.java -> processUploadedFileList\n-        - iterate through list of DataFile objects -- which COULD happen with a single .zip\n-            - isDuplicate check\n-            - if good:\n-                - newFiles.add(dataFile);        // looks good\n-                - fileMetadatas.add(dataFile.getFileMetadata());\n-            - return null;    // looks good, return null\n-    (D) save()  // in the UI, user clicks the button.  API is automatic if no errors\n-        \n-        (1) Look for constraintViolations:\n-            // DatasetVersion workingVersion;\n-            Set<ConstraintViolation> constraintViolations = workingVersion.validate();\n-                if (!constraintViolations.isEmpty()) {\n-                 //JsfHelper.addFlashMessage(JH.localize(\"dataset.message.validationError\"));\n-                 JH.addMessage(FacesMessage.SEVERITY_ERROR, JH.localize(\"dataset.message.validationError\"));\n-                //FacesContext.getCurrentInstance().addMessage(null, new FacesMessage(FacesMessage.SEVERITY_ERROR, \"Validation Error\", \"See below for details.\"));\n-                return \"\";\n-            }\n-    \n-         (2) Use the ingestService for a final check\n-            // ask Leonid if this is needed for API\n-            // One last check before we save the files - go through the newly-uploaded \n-            // ones and modify their names so that there are no duplicates. \n-            // (but should we really be doing it here? - maybe a better approach to do it\n-            // in the ingest service bean, when the files get uploaded.)\n-            // Finally, save the files permanently: \n-            ingestService.saveAndAddFilesToDataset(workingVersion, newFiles);\n-\n-         (3) Use the API to save the dataset\n-            - make new CreateDatasetCommand\n-                - check if dataset has a template\n-            - creates UserNotification message\n-    \n-    */  \n-    // Checks:\n-    //   - Does the md5 already exist in the dataset?\n-    //   - If it's a replace, has the name and/or extension changed?\n-    //   On failure, send back warning\n-    //\n-    // - All looks good\n-    // - Create a DataFile\n-    // - Create a FileMetadata\n-    // - Copy the Dataset version, making a new DRAFT\n-    //      - If it's replace, don't copy the file being replaced\n-    // - Add this new file.\n-    // ....\n-    \n-    \n \n-/*\n-    1) Recovery from adding same file and duplicate being found\n-        - draft ok\n-        - published verion - nope\n-*/\n\\ No newline at end of file\n+}\n\\ No newline at end of file\n",
            "diff_size": 673
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "566",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/3/AddReplaceFileHelper.java\nindex d01e9b4e2f3..ccee47f6ba7 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_random/3/AddReplaceFileHelper.java\n@@ -397,9 +397,8 @@ public class AddReplaceFileHelper{\n         \n         return this.runAddReplaceFile(fileToReplace.getOwner(), newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n     }\n-    \n \n-\tpublic boolean runReplaceFile(Long oldFileId,\n+     public boolean runReplaceFile(Long oldFileId,\n                             String newFileName, \n                             String newFileContentType, \n                             String newStorageIdentifier, \n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "566",
                    "column": "9",
                    "severity": "error",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/3/AddReplaceFileHelper.java\nindex d01e9b4e2f3..ed36fe9a4d8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/errored/1/3/AddReplaceFileHelper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/IQSS-dataverse/styler_three_grams/3/AddReplaceFileHelper.java\n@@ -397,9 +397,8 @@ public class AddReplaceFileHelper{\n         \n         return this.runAddReplaceFile(fileToReplace.getOwner(), newFileName, newFileContentType, newStorageIdentifier, newFileInputStream, optionalFileParams);\n     }\n-    \n \n-\tpublic boolean runReplaceFile(Long oldFileId,\n+    public boolean runReplaceFile(Long oldFileId,\n                             String newFileName, \n                             String newFileContentType, \n                             String newStorageIdentifier, \n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}