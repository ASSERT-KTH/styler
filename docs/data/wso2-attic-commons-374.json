{
    "project_name": "wso2-attic-commons",
    "error_id": "374",
    "information": {
        "errors": [
            {
                "line": "184",
                "severity": "error",
                "message": "Line is longer than 120 characters (found 121).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "                    // TODO: JACOB \"bad-process\" ex\n                    throw new IllegalStateException(\n                            \"Receive attempted on channel containing replicated receive! Channel= \" + comm.getChannel());\n                }\n                if (group.isReplicated())\n                    chnlFrame.replicatedRecv = true;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "184",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/374/ExecutionQueueImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/374/ExecutionQueueImpl.java\nindex 9d001ec180b..57e7447329f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/374/ExecutionQueueImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/intellij/374/ExecutionQueueImpl.java\n@@ -16,6 +16,7 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n+\n package org.apache.ode.jacob.vpu;\n \n import org.apache.commons.logging.Log;\n@@ -63,758 +64,778 @@ import java.util.zip.GZIPOutputStream;\n  * A fast, in-memory {@link org.apache.ode.jacob.soup.ExecutionQueue} implementation.\n  */\n public class ExecutionQueueImpl implements ExecutionQueue {\n-    /** Class-level logger. */\n-    private static final Log __log = LogFactory.getLog(ExecutionQueueImpl.class);\n-\n-    private ClassLoader _classLoader;\n+  /**\n+   * Class-level logger.\n+   */\n+  private static final Log __log = LogFactory.getLog(ExecutionQueueImpl.class);\n \n-    public static ConcurrentHashMap<String, ObjectStreamClass> _classDescriptors\n-        = new ConcurrentHashMap<String, ObjectStreamClass>();\n+  private ClassLoader _classLoader;\n \n-    /**\n-     * Cached set of enqueued {@link Continuation} objects (i.e. those read using\n-     * {@link #enqueueReaction(org.apache.ode.jacob.soup.Continuation)}).\n-     * These reactions are \"cached\"--that is it is not sent directly to the DAO\n-     * layer--to minimize unnecessary serialization/deserialization of closures.\n-     * This is a pretty useful optimization, as most {@link Continuation}s are\n-     * enqueued, and then immediately dequeued in the next cycle. By caching\n-     * {@link Continuation}s, we eliminate practically all serialization of\n-     * these objects, the only exception being cases where the system decides to\n-     * stop processing a particular soup despite the soup being able to make\n-     * forward progress; this scenario would occur if a maximum processign\n-     * time-per-instance policy were in effect.\n-     */\n-    private Set<Continuation> _reactions = new HashSet<Continuation>();\n+  public static ConcurrentHashMap<String, ObjectStreamClass> _classDescriptors\n+    = new ConcurrentHashMap<String, ObjectStreamClass>();\n \n-    private Map<Integer, ChannelFrame> _channels = new HashMap<Integer, ChannelFrame>();\n+  /**\n+   * Cached set of enqueued {@link Continuation} objects (i.e. those read using\n+   * {@link #enqueueReaction(org.apache.ode.jacob.soup.Continuation)}).\n+   * These reactions are \"cached\"--that is it is not sent directly to the DAO\n+   * layer--to minimize unnecessary serialization/deserialization of closures.\n+   * This is a pretty useful optimization, as most {@link Continuation}s are\n+   * enqueued, and then immediately dequeued in the next cycle. By caching\n+   * {@link Continuation}s, we eliminate practically all serialization of\n+   * these objects, the only exception being cases where the system decides to\n+   * stop processing a particular soup despite the soup being able to make\n+   * forward progress; this scenario would occur if a maximum processign\n+   * time-per-instance policy were in effect.\n+   */\n+  private Set<Continuation> _reactions = new HashSet<Continuation>();\n+\n+  private Map<Integer, ChannelFrame> _channels = new HashMap<Integer, ChannelFrame>();\n \n-    /**\n-     * The \"expected\" cycle counter, use to detect database serialization\n-     * issues.\n-     */\n-    private int _currentCycle;\n+  /**\n+   * The \"expected\" cycle counter, use to detect database serialization\n+   * issues.\n+   */\n+  private int _currentCycle;\n+\n+  private int _objIdCounter;\n \n-    private int _objIdCounter;\n+  private ExecutionQueueStatistics _statistics = new ExecutionQueueStatistics();\n \n-    private ExecutionQueueStatistics _statistics = new ExecutionQueueStatistics();\n+  private ReplacementMap _replacementMap;\n \n-    private ReplacementMap _replacementMap;\n+  private Serializable _gdata;\n \n-    private Serializable _gdata;\n+  private Map<Object, LinkedList<IndexedObject>> _index = new HashMap<Object, LinkedList<IndexedObject>>();\n \n-    private Map<Object, LinkedList<IndexedObject>> _index = new HashMap<Object, LinkedList<IndexedObject>>();\n+  public ExecutionQueueImpl(ClassLoader classLoader) {\n+    _classLoader = classLoader;\n+  }\n \n-    public ExecutionQueueImpl(ClassLoader classLoader) {\n-        _classLoader = classLoader;\n-    }\n+  public void setClassLoader(ClassLoader classLoader) {\n+    _classLoader = classLoader;\n+  }\n \n-    public void setClassLoader(ClassLoader classLoader) {\n-        _classLoader = classLoader;\n-    }\n-\n-    public void setReplacementMap(ReplacementMap replacementMap) {\n-        _replacementMap = replacementMap;\n-    }\n-\n-    public Map<Object, LinkedList<IndexedObject>> getIndex() {\n-        return _index;\n-    }\n-\n-    public void add(CommChannel channel) {\n-        if (__log.isTraceEnabled())\n-            __log.trace(ObjectPrinter.stringifyMethodEnter(\"add\", new Object[] { \"channel\", channel }));\n-\n-        verifyNew(channel);\n-        ChannelFrame cframe = new ChannelFrame(channel.getType(), ++_objIdCounter, channel.getType().getName(), channel\n-                .getDescription());\n-        _channels.put(cframe.getId(), cframe);\n-        assignId(channel, cframe.getId());\n-    }\n+  public void setReplacementMap(ReplacementMap replacementMap) {\n+    _replacementMap = replacementMap;\n+  }\n \n-    public void enqueueReaction(Continuation continuation) {\n-        if (__log.isTraceEnabled())\n-            __log.trace(ObjectPrinter.stringifyMethodEnter(\"enqueueReaction\", new Object[] { \"continuation\",\n-                    continuation }));\n+  public Map<Object, LinkedList<IndexedObject>> getIndex() {\n+    return _index;\n+  }\n \n-        verifyNew(continuation);\n-        _reactions.add(continuation);\n+  public void add(CommChannel channel) {\n+    if (__log.isTraceEnabled()) {\n+      __log.trace(ObjectPrinter.stringifyMethodEnter(\"add\", new Object[] {\"channel\", channel}));\n     }\n \n-    public Continuation dequeueReaction() {\n-        if (__log.isTraceEnabled()) {\n-            __log.trace(ObjectPrinter.stringifyMethodEnter(\"dequeueReaction\", CollectionUtils.EMPTY_OBJECT_ARRAY));\n-        }\n-\n-        Continuation continuation = null;\n-        if (!_reactions.isEmpty()) {\n-            Iterator it = _reactions.iterator();\n-            continuation = (Continuation) it.next();\n-            it.remove();\n-        }\n-        return continuation;\n-    }\n-\n-    public void add(CommGroup group) {\n-        if (__log.isTraceEnabled())\n-            __log.trace(ObjectPrinter.stringifyMethodEnter(\"add\", new Object[] { \"group\", group }));\n-\n-        verifyNew(group);\n-        CommGroupFrame commGroupFrame = new CommGroupFrame(group.isReplicated());\n-        for (Iterator i = group.getElements(); i.hasNext();) {\n-            Comm comm = (Comm) i.next();\n-            ChannelFrame chnlFrame = findChannelFrame(comm.getChannel().getId());\n-            if (comm instanceof CommSend) {\n-                if (chnlFrame.replicatedSend) {\n-                    // TODO: JACOB \"bad-process\" ex\n-                    throw new IllegalStateException(\"Send attempted on channel containing replicated send! Channel= \"\n-                            + comm.getChannel());\n-                }\n-                if (group.isReplicated())\n-                    chnlFrame.replicatedSend = true;\n-\n-                CommSend commSend = (CommSend) comm;\n-                MessageFrame mframe = new MessageFrame(commGroupFrame, chnlFrame, commSend.getMethod().getName(),\n-                        commSend.getArgs());\n-                commGroupFrame.commFrames.add(mframe);\n-                chnlFrame.msgFrames.add(mframe);\n-            } else if (comm instanceof CommRecv) {\n-                if (chnlFrame.replicatedRecv) {\n-                    // TODO: JACOB \"bad-process\" ex\n-                    throw new IllegalStateException(\n-                            \"Receive attempted on channel containing replicated receive! Channel= \" + comm.getChannel());\n-                }\n-                if (group.isReplicated())\n-                    chnlFrame.replicatedRecv = true;\n-                CommRecv commRecv = (CommRecv) comm;\n-                ObjectFrame oframe = new ObjectFrame(commGroupFrame, chnlFrame, commRecv.getContinuation());\n-                commGroupFrame.commFrames.add(oframe);\n-                chnlFrame.objFrames.add(oframe);\n-            }\n-        }\n-\n-        // Match communications.\n-        for (Iterator i = group.getElements(); i.hasNext();) {\n-            Comm comm = (Comm) i.next();\n-            matchCommunications(comm.getChannel());\n-        }\n-    }\n-\n-    private ChannelFrame findChannelFrame(Object id) {\n-        ChannelFrame chnlFrame = _channels.get(id);\n-        if (chnlFrame == null) {\n-            throw new IllegalArgumentException(\"No such channel; id=\" + id);\n-        }\n-        return chnlFrame;\n-    }\n-\n-    public int cycle() {\n-        if (__log.isTraceEnabled()) {\n-            __log.trace(ObjectPrinter.stringifyMethodEnter(\"cycle\", CollectionUtils.EMPTY_OBJECT_ARRAY));\n-        }\n-\n-        return ++_currentCycle;\n-    }\n+    verifyNew(channel);\n+    ChannelFrame cframe = new ChannelFrame(channel.getType(), ++_objIdCounter, channel.getType().getName(), channel\n+      .getDescription());\n+    _channels.put(cframe.getId(), cframe);\n+    assignId(channel, cframe.getId());\n+  }\n \n-    public String createExport(CommChannel channel) {\n-        if (__log.isTraceEnabled())\n-            __log.trace(ObjectPrinter.stringifyMethodEnter(\"createExport\", new Object[] { \"channel\", channel }));\n-        ChannelFrame cframe = findChannelFrame(channel.getId());\n-        cframe.refCount++;\n-        return channel.getId().toString();\n+  public void enqueueReaction(Continuation continuation) {\n+    if (__log.isTraceEnabled()) {\n+      __log.trace(ObjectPrinter.stringifyMethodEnter(\"enqueueReaction\", new Object[] {\"continuation\",\n+        continuation}));\n     }\n \n-    public CommChannel consumeExport(String exportId) {\n-        if (__log.isTraceEnabled()) {\n-            __log.trace(ObjectPrinter.stringifyMethodEnter(\"consumeExport\", new Object[] { \"exportId\", exportId }));\n-        }\n+    verifyNew(continuation);\n+    _reactions.add(continuation);\n+  }\n \n-        Integer id = Integer.valueOf(exportId);\n-        ChannelFrame cframe = findChannelFrame(id);\n-        cframe.refCount--;\n-        CommChannel commChannel = new CommChannel(cframe.type);\n-        commChannel.setId(id);\n-        commChannel.setDescription(\"EXPORTED CHANNEL\");\n-        return commChannel;\n+  public Continuation dequeueReaction() {\n+    if (__log.isTraceEnabled()) {\n+      __log.trace(ObjectPrinter.stringifyMethodEnter(\"dequeueReaction\", CollectionUtils.EMPTY_OBJECT_ARRAY));\n     }\n \n-    public boolean hasReactions() {\n-        return !_reactions.isEmpty();\n+    Continuation continuation = null;\n+    if (!_reactions.isEmpty()) {\n+      Iterator it = _reactions.iterator();\n+      continuation = (Continuation) it.next();\n+      it.remove();\n     }\n+    return continuation;\n+  }\n \n-    public void flush() {\n-        if (__log.isTraceEnabled()) {\n-            __log.trace(ObjectPrinter.stringifyMethodEnter(\"flush\", CollectionUtils.EMPTY_OBJECT_ARRAY));\n-        }\n+  public void add(CommGroup group) {\n+    if (__log.isTraceEnabled()) {\n+      __log.trace(ObjectPrinter.stringifyMethodEnter(\"add\", new Object[] {\"group\", group}));\n     }\n \n-    public void read(InputStream iis) throws IOException, ClassNotFoundException {\n-        _channels.clear();\n-        _reactions.clear();\n-        _index.clear();\n-\n-        ExecutionQueueInputStream sis = new ExecutionQueueInputStream(iis);\n-\n-        _objIdCounter = sis.readInt();\n-        _currentCycle = sis.readInt();\n-        int reactions = sis.readInt();\n-        for (int i = 0; i < reactions; ++i) {\n-            JacobObject closure = (JacobObject) sis.readObject();\n-            String methodName = sis.readUTF();\n-            Method method = closure.getMethod(methodName);\n-            int numArgs = sis.readInt();\n-            Object[] args = new Object[numArgs];\n-            for (int j = 0; j < numArgs; ++j) {\n-                args[j] = sis.readObject();\n-            }\n-            _reactions.add(new Continuation(closure, method, args));\n+    verifyNew(group);\n+    CommGroupFrame commGroupFrame = new CommGroupFrame(group.isReplicated());\n+    for (Iterator i = group.getElements(); i.hasNext(); ) {\n+      Comm comm = (Comm) i.next();\n+      ChannelFrame chnlFrame = findChannelFrame(comm.getChannel().getId());\n+      if (comm instanceof CommSend) {\n+        if (chnlFrame.replicatedSend) {\n+          // TODO: JACOB \"bad-process\" ex\n+          throw new IllegalStateException(\"Send attempted on channel containing replicated send! Channel= \"\n+            + comm.getChannel());\n+        }\n+        if (group.isReplicated()) {\n+          chnlFrame.replicatedSend = true;\n         }\n \n-        int numChannels = sis.readInt();\n-        for (int i = 0; i < numChannels; ++i) {\n-            int objFrames = sis.readInt();\n-            for (int j = 0; j < objFrames; ++j) {\n-                sis.readObject();\n-            }\n-            int msgFrames = sis.readInt();\n-            for (int j = 0; j < msgFrames; ++j) {\n-                sis.readObject();\n-            }\n+        CommSend commSend = (CommSend) comm;\n+        MessageFrame mframe = new MessageFrame(commGroupFrame, chnlFrame, commSend.getMethod().getName(),\n+          commSend.getArgs());\n+        commGroupFrame.commFrames.add(mframe);\n+        chnlFrame.msgFrames.add(mframe);\n+      } else if (comm instanceof CommRecv) {\n+        if (chnlFrame.replicatedRecv) {\n+          // TODO: JACOB \"bad-process\" ex\n+          throw new IllegalStateException(\n+            \"Receive attempted on channel containing replicated receive! Channel= \" + comm.getChannel());\n         }\n-\n-        numChannels = sis.readInt();\n-        for (int i = 0; i < numChannels; ++i) {\n-            ChannelFrame cframe = (ChannelFrame) sis.readObject();\n-            _channels.put(cframe.getId(), cframe);\n+        if (group.isReplicated()) {\n+          chnlFrame.replicatedRecv = true;\n         }\n-        _gdata = (Serializable) sis.readObject();\n-        sis.close();\n+        CommRecv commRecv = (CommRecv) comm;\n+        ObjectFrame oframe = new ObjectFrame(commGroupFrame, chnlFrame, commRecv.getContinuation());\n+        commGroupFrame.commFrames.add(oframe);\n+        chnlFrame.objFrames.add(oframe);\n+      }\n     }\n \n-    private void index(IndexedObject object) {\n-        LinkedList<IndexedObject> vals = _index.get(object.getKey());\n-        if (vals == null) {\n-            vals = new LinkedList<IndexedObject>();\n-            _index.put(object.getKey(), vals);\n-        }\n-        vals.add(object);\n-    }\n+    // Match communications.\n+    for (Iterator i = group.getElements(); i.hasNext(); ) {\n+      Comm comm = (Comm) i.next();\n+      matchCommunications(comm.getChannel());\n+    }\n+  }\n+\n+  private ChannelFrame findChannelFrame(Object id) {\n+    ChannelFrame chnlFrame = _channels.get(id);\n+    if (chnlFrame == null) {\n+      throw new IllegalArgumentException(\"No such channel; id=\" + id);\n+    }\n+    return chnlFrame;\n+  }\n+\n+  public int cycle() {\n+    if (__log.isTraceEnabled()) {\n+      __log.trace(ObjectPrinter.stringifyMethodEnter(\"cycle\", CollectionUtils.EMPTY_OBJECT_ARRAY));\n+    }\n+\n+    return ++_currentCycle;\n+  }\n+\n+  public String createExport(CommChannel channel) {\n+    if (__log.isTraceEnabled()) {\n+      __log.trace(ObjectPrinter.stringifyMethodEnter(\"createExport\", new Object[] {\"channel\", channel}));\n+    }\n+    ChannelFrame cframe = findChannelFrame(channel.getId());\n+    cframe.refCount++;\n+    return channel.getId().toString();\n+  }\n+\n+  public CommChannel consumeExport(String exportId) {\n+    if (__log.isTraceEnabled()) {\n+      __log.trace(ObjectPrinter.stringifyMethodEnter(\"consumeExport\", new Object[] {\"exportId\", exportId}));\n+    }\n+\n+    Integer id = Integer.valueOf(exportId);\n+    ChannelFrame cframe = findChannelFrame(id);\n+    cframe.refCount--;\n+    CommChannel commChannel = new CommChannel(cframe.type);\n+    commChannel.setId(id);\n+    commChannel.setDescription(\"EXPORTED CHANNEL\");\n+    return commChannel;\n+  }\n+\n+  public boolean hasReactions() {\n+    return !_reactions.isEmpty();\n+  }\n+\n+  public void flush() {\n+    if (__log.isTraceEnabled()) {\n+      __log.trace(ObjectPrinter.stringifyMethodEnter(\"flush\", CollectionUtils.EMPTY_OBJECT_ARRAY));\n+    }\n+  }\n+\n+  public void read(InputStream iis) throws IOException, ClassNotFoundException {\n+    _channels.clear();\n+    _reactions.clear();\n+    _index.clear();\n+\n+    ExecutionQueueInputStream sis = new ExecutionQueueInputStream(iis);\n+\n+    _objIdCounter = sis.readInt();\n+    _currentCycle = sis.readInt();\n+    int reactions = sis.readInt();\n+    for (int i = 0; i < reactions; ++i) {\n+      JacobObject closure = (JacobObject) sis.readObject();\n+      String methodName = sis.readUTF();\n+      Method method = closure.getMethod(methodName);\n+      int numArgs = sis.readInt();\n+      Object[] args = new Object[numArgs];\n+      for (int j = 0; j < numArgs; ++j) {\n+        args[j] = sis.readObject();\n+      }\n+      _reactions.add(new Continuation(closure, method, args));\n+    }\n+\n+    int numChannels = sis.readInt();\n+    for (int i = 0; i < numChannels; ++i) {\n+      int objFrames = sis.readInt();\n+      for (int j = 0; j < objFrames; ++j) {\n+        sis.readObject();\n+      }\n+      int msgFrames = sis.readInt();\n+      for (int j = 0; j < msgFrames; ++j) {\n+        sis.readObject();\n+      }\n+    }\n \n-    public void write(OutputStream oos) throws IOException {\n-        flush();\n+    numChannels = sis.readInt();\n+    for (int i = 0; i < numChannels; ++i) {\n+      ChannelFrame cframe = (ChannelFrame) sis.readObject();\n+      _channels.put(cframe.getId(), cframe);\n+    }\n+    _gdata = (Serializable) sis.readObject();\n+    sis.close();\n+  }\n \n-        ExecutionQueueOutputStream sos = new ExecutionQueueOutputStream(oos);\n+  private void index(IndexedObject object) {\n+    LinkedList<IndexedObject> vals = _index.get(object.getKey());\n+    if (vals == null) {\n+      vals = new LinkedList<IndexedObject>();\n+      _index.put(object.getKey(), vals);\n+    }\n+    vals.add(object);\n+  }\n+\n+  public void write(OutputStream oos) throws IOException {\n+    flush();\n+\n+    ExecutionQueueOutputStream sos = new ExecutionQueueOutputStream(oos);\n //        XQXMLOutputStream sos = createObjectOutputStream(new OutputStreamWriter(oos));\n \n-        sos.writeInt(_objIdCounter);\n-        sos.writeInt(_currentCycle);\n-\n-        // Write out the reactions.\n-        sos.writeInt(_reactions.size());\n-        for (Continuation c : _reactions) {\n-            sos.writeObject(c.getClosure());\n-            sos.writeUTF(c.getMethod().getName());\n-            sos.writeInt(c.getArgs() == null ? 0 : c.getArgs().length);\n-            for (int j = 0; c.getArgs() != null && j < c.getArgs().length; ++j)\n-                sos.writeObject(c.getArgs()[j]);\n-        }\n+    sos.writeInt(_objIdCounter);\n+    sos.writeInt(_currentCycle);\n+\n+    // Write out the reactions.\n+    sos.writeInt(_reactions.size());\n+    for (Continuation c : _reactions) {\n+      sos.writeObject(c.getClosure());\n+      sos.writeUTF(c.getMethod().getName());\n+      sos.writeInt(c.getArgs() == null ? 0 : c.getArgs().length);\n+      for (int j = 0; c.getArgs() != null && j < c.getArgs().length; ++j) {\n+        sos.writeObject(c.getArgs()[j]);\n+      }\n+    }\n+\n+    sos.writeInt(_channels.values().size());\n+    for (Iterator i = _channels.values().iterator(); i.hasNext(); ) {\n+      ChannelFrame cframe = (ChannelFrame) i.next();\n+      sos.writeInt(cframe.objFrames.size());\n+      for (Iterator j = cframe.objFrames.iterator(); j.hasNext(); ) {\n+        sos.writeObject(j.next());\n+      }\n+      sos.writeInt(cframe.msgFrames.size());\n+      for (Iterator j = cframe.msgFrames.iterator(); j.hasNext(); ) {\n+        sos.writeObject(j.next());\n+      }\n+    }\n+\n+    Set referencedChannels = sos.getSerializedChannels();\n+    for (Iterator i = _channels.values().iterator(); i.hasNext(); ) {\n+      ChannelFrame cframe = (ChannelFrame) i.next();\n+      if (referencedChannels.contains(Integer.valueOf(cframe.id)) || cframe.refCount > 0) {\n+        // skip\n+      } else {\n+        if (__log.isDebugEnabled()) {\n+          __log.debug(\"GC Channel: \" + cframe);\n+        }\n+        i.remove();\n+      }\n+\n+    }\n+\n+    sos.writeInt(_channels.values().size());\n+    for (Iterator i = _channels.values().iterator(); i.hasNext(); ) {\n+      ChannelFrame cframe = (ChannelFrame) i.next();\n+      if (__log.isDebugEnabled()) {\n+        __log.debug(\"Writing Channel: \" + cframe);\n+      }\n+      sos.writeObject(cframe);\n+    }\n+\n+    // Write the global data.\n+    sos.writeObject(_gdata);\n+    sos.close();\n+  }\n+\n+  public boolean isComplete() {\n+    // If we have more reactions we're not done.\n+    if (!_reactions.isEmpty()) {\n+      return false;\n+    }\n+\n+    // If we have no reactions, but there are some channels that have\n+    // external references, we are not done.\n+    for (Iterator<ChannelFrame> i = _channels.values().iterator(); i.hasNext(); ) {\n+      if (i.next().refCount > 0) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  public void dumpState(PrintStream ps) {\n+    ps.print(this.toString());\n+    ps.println(\" state dump:\");\n+    ps.println(\"-- GENERAL INFO\");\n+    ps.println(\"   Current Cycle          : \" + _currentCycle);\n+    ps.println(\"   Num. Reactions  : \" + _reactions.size());\n+    _statistics.printStatistics(ps);\n+    if (!_reactions.isEmpty()) {\n+      ps.println(\"-- REACTIONS\");\n+      int cnt = 0;\n+      for (Iterator i = _reactions.iterator(); i.hasNext(); ) {\n+        Continuation continuation = (Continuation) i.next();\n+        ps.println(\"   #\" + (++cnt) + \":  \" + continuation.toString());\n+      }\n+    }\n+  }\n+\n+  private void matchCommunications(CommChannel channel) {\n+    if (__log.isTraceEnabled()) {\n+      __log.trace(ObjectPrinter.stringifyMethodEnter(\"matchCommunications\", new Object[] {\"channel\", channel}));\n+    }\n+    ChannelFrame cframe = _channels.get(channel.getId());\n+    while (cframe != null && !cframe.msgFrames.isEmpty() && !cframe.objFrames.isEmpty()) {\n+      MessageFrame mframe = cframe.msgFrames.iterator().next();\n+      ObjectFrame oframe = cframe.objFrames.iterator().next();\n+\n+      Continuation continuation = new Continuation(oframe._continuation, oframe._continuation\n+        .getMethod(mframe.method), mframe.args);\n+      if (__log.isInfoEnabled()) {\n+        continuation.setDescription(channel + \" ? {...} | \" + channel + \" ! \" + mframe.method + \"(...)\");\n+      }\n+      enqueueReaction(continuation);\n+      if (!mframe.commGroupFrame.replicated) {\n+        removeCommGroup(mframe.commGroupFrame);\n+      }\n+      if (!oframe.commGroupFrame.replicated) {\n+        removeCommGroup(oframe.commGroupFrame);\n+      }\n+    }\n+\n+    // Do some cleanup, if the channel is empty we can remove it from memory.\n+    // if (cframe != null && cframe.msgFrames.isEmpty() &&\n+    // cframe.objFrames.isEmpty() && cframe.refCount ==0)\n+    // _channels.values().remove(cframe);\n+  }\n+\n+  /**\n+   * Verify that a {@link ExecutionQueueObject} is new, that is it has not\n+   * already been added to the soup.\n+   *\n+   * @param so object to check.\n+   * @throws IllegalArgumentException in case the object is not new\n+   */\n+  private void verifyNew(ExecutionQueueObject so) throws IllegalArgumentException {\n+    if (so.getId() != null) {\n+      throw new IllegalArgumentException(\"The object \" + so + \" is not new!\");\n+    }\n+  }\n+\n+  private void assignId(ExecutionQueueObject so, Object id) {\n+    so.setId(id);\n+  }\n+\n+  private void removeCommGroup(CommGroupFrame groupFrame) {\n+    // Add all channels reference in the group to the GC candidate set.\n+    for (Iterator i = groupFrame.commFrames.iterator(); i.hasNext(); ) {\n+      CommFrame frame = (CommFrame) i.next();\n+      if (frame instanceof ObjectFrame) {\n+        assert frame.channelFrame.objFrames.contains(frame);\n+        frame.channelFrame.objFrames.remove(frame);\n+      } else {\n+        assert frame instanceof MessageFrame;\n+        assert frame.channelFrame.msgFrames.contains(frame);\n+        frame.channelFrame.msgFrames.remove(frame);\n+      }\n+    }\n+  }\n+\n+  public void setGlobalData(Serializable data) {\n+    _gdata = data;\n+  }\n+\n+  public Serializable getGlobalData() {\n+    return _gdata;\n+  }\n+\n+  private static class ChannelFrame implements Externalizable {\n+    Class type;\n+\n+    int id;\n \n-        sos.writeInt(_channels.values().size());\n-        for (Iterator i = _channels.values().iterator(); i.hasNext();) {\n-            ChannelFrame cframe = (ChannelFrame) i.next();\n-            sos.writeInt(cframe.objFrames.size());\n-            for (Iterator j = cframe.objFrames.iterator(); j.hasNext();) {\n-                sos.writeObject(j.next());\n-            }\n-            sos.writeInt(cframe.msgFrames.size());\n-            for (Iterator j = cframe.msgFrames.iterator(); j.hasNext();) {\n-                sos.writeObject(j.next());\n-            }\n-        }\n+    /**\n+     * External Reference Count\n+     */\n+    int refCount;\n \n-        Set referencedChannels = sos.getSerializedChannels();\n-        for (Iterator i = _channels.values().iterator(); i.hasNext();) {\n-            ChannelFrame cframe = (ChannelFrame) i.next();\n-            if (referencedChannels.contains(Integer.valueOf(cframe.id)) || cframe.refCount > 0) {\n-                // skip\n-            } else {\n-                if (__log.isDebugEnabled())\n-                    __log.debug(\"GC Channel: \" + cframe);\n-                i.remove();\n-            }\n+    boolean replicatedSend;\n \n-        }\n+    boolean replicatedRecv;\n \n-        sos.writeInt(_channels.values().size());\n-        for (Iterator i = _channels.values().iterator(); i.hasNext();) {\n-            ChannelFrame cframe = (ChannelFrame) i.next();\n-            if (__log.isDebugEnabled()) {\n-                __log.debug(\"Writing Channel: \" + cframe);\n-            }\n-            sos.writeObject(cframe);\n-        }\n+    Set<ObjectFrame> objFrames = new HashSet<ObjectFrame>();\n \n-        // Write the global data.\n-        sos.writeObject(_gdata);\n-        sos.close();\n-    }\n+    Set<MessageFrame> msgFrames = new HashSet<MessageFrame>();\n \n-    public boolean isComplete() {\n-        // If we have more reactions we're not done.\n-        if (!_reactions.isEmpty()) {\n-            return false;\n-        }\n+    public String description;\n \n-        // If we have no reactions, but there are some channels that have\n-        // external references, we are not done.\n-        for (Iterator<ChannelFrame> i = _channels.values().iterator(); i.hasNext();) {\n-            if (i.next().refCount > 0) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public void dumpState(PrintStream ps) {\n-        ps.print(this.toString());\n-        ps.println(\" state dump:\");\n-        ps.println(\"-- GENERAL INFO\");\n-        ps.println(\"   Current Cycle          : \" + _currentCycle);\n-        ps.println(\"   Num. Reactions  : \" + _reactions.size());\n-        _statistics.printStatistics(ps);\n-        if (!_reactions.isEmpty()) {\n-            ps.println(\"-- REACTIONS\");\n-            int cnt = 0;\n-            for (Iterator i = _reactions.iterator(); i.hasNext();) {\n-                Continuation continuation = (Continuation) i.next();\n-                ps.println(\"   #\" + (++cnt) + \":  \" + continuation.toString());\n-            }\n-        }\n+    public ChannelFrame() {\n     }\n \n-    private void matchCommunications(CommChannel channel) {\n-        if (__log.isTraceEnabled()) {\n-            __log.trace(ObjectPrinter.stringifyMethodEnter(\"matchCommunications\", new Object[] { \"channel\", channel }));\n-        }\n-        ChannelFrame cframe = _channels.get(channel.getId());\n-        while (cframe != null && !cframe.msgFrames.isEmpty() && !cframe.objFrames.isEmpty()) {\n-            MessageFrame mframe = cframe.msgFrames.iterator().next();\n-            ObjectFrame oframe = cframe.objFrames.iterator().next();\n-\n-            Continuation continuation = new Continuation(oframe._continuation, oframe._continuation\n-                    .getMethod(mframe.method), mframe.args);\n-            if (__log.isInfoEnabled()) {\n-                continuation.setDescription(channel + \" ? {...} | \" + channel + \" ! \" + mframe.method + \"(...)\");\n-            }\n-            enqueueReaction(continuation);\n-            if (!mframe.commGroupFrame.replicated) {\n-                removeCommGroup(mframe.commGroupFrame);\n-            }\n-            if (!oframe.commGroupFrame.replicated) {\n-                removeCommGroup(oframe.commGroupFrame);\n-            }\n-        }\n-\n-        // Do some cleanup, if the channel is empty we can remove it from memory.\n-        // if (cframe != null && cframe.msgFrames.isEmpty() &&\n-        // cframe.objFrames.isEmpty() && cframe.refCount ==0)\n-        // _channels.values().remove(cframe);\n+    public ChannelFrame(Class type, int id, String name, String description) {\n+      this.type = type;\n+      this.id = id;\n+      this.description = description;\n     }\n \n-    /**\n-     * Verify that a {@link ExecutionQueueObject} is new, that is it has not\n-     * already been added to the soup.\n-     *\n-     * @param so object to check.\n-     * @throws IllegalArgumentException in case the object is not new\n-     */\n-    private void verifyNew(ExecutionQueueObject so) throws IllegalArgumentException {\n-        if (so.getId() != null)\n-            throw new IllegalArgumentException(\"The object \" + so + \" is not new!\");\n-    }\n-\n-    private void assignId(ExecutionQueueObject so, Object id) {\n-        so.setId(id);\n-    }\n-\n-    private void removeCommGroup(CommGroupFrame groupFrame) {\n-        // Add all channels reference in the group to the GC candidate set.\n-        for (Iterator i = groupFrame.commFrames.iterator(); i.hasNext();) {\n-            CommFrame frame = (CommFrame) i.next();\n-            if (frame instanceof ObjectFrame) {\n-                assert frame.channelFrame.objFrames.contains(frame);\n-                frame.channelFrame.objFrames.remove(frame);\n-            } else {\n-                assert frame instanceof MessageFrame;\n-                assert frame.channelFrame.msgFrames.contains(frame);\n-                frame.channelFrame.msgFrames.remove(frame);\n-            }\n-        }\n+    public Integer getId() {\n+      return Integer.valueOf(id);\n     }\n \n-    public void setGlobalData(Serializable data) {\n-        _gdata = data;\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+      type = (Class) in.readObject();\n+      id = in.readInt();\n+      description = in.readUTF();\n+      refCount = in.readInt();\n+      replicatedSend = in.readBoolean();\n+      replicatedRecv = in.readBoolean();\n+      int cnt = in.readInt();\n+      for (int i = 0; i < cnt; ++i) {\n+        objFrames.add((ObjectFrame) in.readObject());\n+      }\n+      cnt = in.readInt();\n+      for (int i = 0; i < cnt; ++i) {\n+        msgFrames.add((MessageFrame) in.readObject());\n+      }\n     }\n \n-    public Serializable getGlobalData() {\n-        return _gdata;\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+      out.writeObject(type);\n+      out.writeInt(id);\n+      out.writeUTF(description == null ? \"\" : description);\n+      out.writeInt(refCount);\n+      out.writeBoolean(replicatedSend);\n+      out.writeBoolean(replicatedRecv);\n+      out.writeInt(objFrames.size());\n+      for (Iterator<ObjectFrame> i = objFrames.iterator(); i.hasNext(); ) {\n+        out.writeObject(i.next());\n+      }\n+      out.writeInt(msgFrames.size());\n+      for (Iterator<MessageFrame> i = msgFrames.iterator(); i.hasNext(); ) {\n+        out.writeObject(i.next());\n+      }\n     }\n \n-    private static class ChannelFrame implements Externalizable {\n-        Class type;\n-\n-        int id;\n-\n-        /** External Reference Count */\n-        int refCount;\n-\n-        boolean replicatedSend;\n-\n-        boolean replicatedRecv;\n-\n-        Set<ObjectFrame> objFrames = new HashSet<ObjectFrame>();\n+    public String toString() {\n+      StringBuffer buf = new StringBuffer(32);\n+      buf.append(\"{CFRAME \");\n+      buf.append(type.getSimpleName());\n+      buf.append(':');\n+      buf.append(description);\n+      buf.append('#');\n+      buf.append(id);\n+      buf.append(\" refCount=\");\n+      buf.append(refCount);\n+      buf.append(\", msgs=\");\n+      buf.append(msgFrames.size());\n+      if (replicatedSend) {\n+        buf.append(\"R\");\n+      }\n+      buf.append(\", objs=\");\n+      buf.append(objFrames.size());\n+      if (replicatedRecv) {\n+        buf.append(\"R\");\n+      }\n+      buf.append(\"}\");\n+      return buf.toString();\n+    }\n+  }\n \n-        Set<MessageFrame> msgFrames = new HashSet<MessageFrame>();\n+  private static class CommGroupFrame implements Serializable {\n+    boolean replicated;\n \n-        public String description;\n+    public Set<CommFrame> commFrames = new HashSet<CommFrame>();\n \n-        public ChannelFrame() {\n-        }\n-\n-        public ChannelFrame(Class type, int id, String name, String description) {\n-            this.type = type;\n-            this.id = id;\n-            this.description = description;\n-        }\n+    public CommGroupFrame(boolean replicated) {\n+      this.replicated = replicated;\n+    }\n \n-        public Integer getId() {\n-            return Integer.valueOf(id);\n-        }\n+  }\n \n-        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n-            type = (Class) in.readObject();\n-            id = in.readInt();\n-            description = in.readUTF();\n-            refCount = in.readInt();\n-            replicatedSend = in.readBoolean();\n-            replicatedRecv = in.readBoolean();\n-            int cnt = in.readInt();\n-            for (int i = 0; i < cnt; ++i) {\n-                objFrames.add((ObjectFrame) in.readObject());\n-            }\n-            cnt = in.readInt();\n-            for (int i = 0; i < cnt; ++i) {\n-                msgFrames.add((MessageFrame) in.readObject());\n-            }\n-        }\n+  private static class CommFrame implements Externalizable {\n+    CommGroupFrame commGroupFrame;\n \n-        public void writeExternal(ObjectOutput out) throws IOException {\n-            out.writeObject(type);\n-            out.writeInt(id);\n-            out.writeUTF(description == null ? \"\" : description);\n-            out.writeInt(refCount);\n-            out.writeBoolean(replicatedSend);\n-            out.writeBoolean(replicatedRecv);\n-            out.writeInt(objFrames.size());\n-            for (Iterator<ObjectFrame> i = objFrames.iterator(); i.hasNext();) {\n-                out.writeObject(i.next());\n-            }\n-            out.writeInt(msgFrames.size());\n-            for (Iterator<MessageFrame> i = msgFrames.iterator(); i.hasNext();)\n-                out.writeObject(i.next());\n-        }\n+    ChannelFrame channelFrame;\n \n-        public String toString() {\n-            StringBuffer buf = new StringBuffer(32);\n-            buf.append(\"{CFRAME \");\n-            buf.append(type.getSimpleName());\n-            buf.append(':');\n-            buf.append(description);\n-            buf.append('#');\n-            buf.append(id);\n-            buf.append(\" refCount=\");\n-            buf.append(refCount);\n-            buf.append(\", msgs=\");\n-            buf.append(msgFrames.size());\n-            if (replicatedSend) {\n-                buf.append(\"R\");\n-            }\n-            buf.append(\", objs=\");\n-            buf.append(objFrames.size());\n-            if (replicatedRecv) {\n-                buf.append(\"R\");\n-            }\n-            buf.append(\"}\");\n-            return buf.toString();\n-        }\n+    public CommFrame() {\n     }\n \n-    private static class CommGroupFrame implements Serializable {\n-        boolean replicated;\n-\n-        public Set<CommFrame> commFrames = new HashSet<CommFrame>();\n-\n-        public CommGroupFrame(boolean replicated) {\n-            this.replicated = replicated;\n-        }\n-\n+    CommFrame(CommGroupFrame commGroupFrame, ChannelFrame channelFrame) {\n+      this.commGroupFrame = commGroupFrame;\n+      this.channelFrame = channelFrame;\n     }\n \n-    private static class CommFrame implements Externalizable {\n-        CommGroupFrame commGroupFrame;\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+      commGroupFrame = (CommGroupFrame) in.readObject();\n+      channelFrame = (ChannelFrame) in.readObject();\n+    }\n \n-        ChannelFrame channelFrame;\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+      out.writeObject(commGroupFrame);\n+      out.writeObject(channelFrame);\n+    }\n+  }\n \n-        public CommFrame() {\n-        }\n+  private static class ObjectFrame extends CommFrame implements Externalizable {\n+    private static final long serialVersionUID = -7212430608484116919L;\n \n-        CommFrame(CommGroupFrame commGroupFrame, ChannelFrame channelFrame) {\n-            this.commGroupFrame = commGroupFrame;\n-            this.channelFrame = channelFrame;\n-        }\n+    ChannelListener _continuation;\n \n-        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n-            commGroupFrame = (CommGroupFrame) in.readObject();\n-            channelFrame = (ChannelFrame) in.readObject();\n-        }\n+    public ObjectFrame() {\n+      super();\n+    }\n \n-        public void writeExternal(ObjectOutput out) throws IOException {\n-            out.writeObject(commGroupFrame);\n-            out.writeObject(channelFrame);\n-        }\n+    public ObjectFrame(CommGroupFrame commGroupFrame, ChannelFrame channelFrame, ChannelListener continuation) {\n+      super(commGroupFrame, channelFrame);\n+      this._continuation = continuation;\n     }\n \n-    private static class ObjectFrame extends CommFrame implements Externalizable {\n-        private static final long serialVersionUID = -7212430608484116919L;\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+      super.readExternal(in);\n+      _continuation = (ChannelListener) in.readObject();\n+    }\n \n-        ChannelListener _continuation;\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+      super.writeExternal(out);\n+      out.writeObject(_continuation);\n+    }\n+  }\n \n-        public ObjectFrame() {\n-            super();\n-        }\n+  private static class MessageFrame extends CommFrame implements Externalizable {\n+    private static final long serialVersionUID = -1112437852498126297L;\n \n-        public ObjectFrame(CommGroupFrame commGroupFrame, ChannelFrame channelFrame, ChannelListener continuation) {\n-            super(commGroupFrame, channelFrame);\n-            this._continuation = continuation;\n-        }\n+    String method;\n \n-        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n-            super.readExternal(in);\n-            _continuation = (ChannelListener) in.readObject();\n-        }\n+    Object[] args;\n \n-        public void writeExternal(ObjectOutput out) throws IOException {\n-            super.writeExternal(out);\n-            out.writeObject(_continuation);\n-        }\n+    public MessageFrame() {\n+      super();\n     }\n \n-    private static class MessageFrame extends CommFrame implements Externalizable {\n-        private static final long serialVersionUID = -1112437852498126297L;\n+    public MessageFrame(CommGroupFrame commFrame, ChannelFrame channelFrame, String method, Object[] args) {\n+      super(commFrame, channelFrame);\n+      this.method = method;\n+      this.args = args == null ? CollectionUtils.EMPTY_CLASS_ARRAY : args;\n+    }\n \n-        String method;\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+      super.readExternal(in);\n+      method = in.readUTF();\n+      int numArgs = in.readInt();\n+      args = new Object[numArgs];\n+      for (int i = 0; i < numArgs; ++i) {\n+        args[i] = in.readObject();\n+      }\n \n-        Object[] args;\n+    }\n \n-        public MessageFrame() {\n-            super();\n-        }\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+      super.writeExternal(out);\n+      out.writeUTF(method);\n+      out.writeInt(args.length);\n+      for (int i = 0; i < args.length; ++i) {\n+        out.writeObject(args[i]);\n+      }\n+    }\n+  }\n \n-        public MessageFrame(CommGroupFrame commFrame, ChannelFrame channelFrame, String method, Object[] args) {\n-            super(commFrame, channelFrame);\n-            this.method = method;\n-            this.args = args == null ? CollectionUtils.EMPTY_CLASS_ARRAY : args;\n-        }\n+  /**\n+   * DOCUMENTME.\n+   * <p>\n+   * Created on Feb 16, 2004 at 8:09:48 PM.\n+   * </p>\n+   *\n+   * @author Maciej Szefler <a href=\"mailto:mbs@fivesight.com\">mbs</a>\n+   */\n+  private class ExecutionQueueOutputStream extends ObjectOutputStream {\n+    private Set<Object> _serializedChannels = new HashSet<Object>();\n \n-        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n-            super.readExternal(in);\n-            method = in.readUTF();\n-            int numArgs = in.readInt();\n-            args = new Object[numArgs];\n-            for (int i = 0; i < numArgs; ++i)\n-                args[i] = in.readObject();\n+    public ExecutionQueueOutputStream(OutputStream outputStream) throws IOException {\n+      super(new GZIPOutputStream(outputStream));\n+      enableReplaceObject(true);\n+    }\n \n-        }\n+    public Set<Object> getSerializedChannels() {\n+      return _serializedChannels;\n+    }\n \n-        public void writeExternal(ObjectOutput out) throws IOException {\n-            super.writeExternal(out);\n-            out.writeUTF(method);\n-            out.writeInt(args.length);\n-            for (int i = 0; i < args.length; ++i)\n-                out.writeObject(args[i]);\n-        }\n+    protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {\n+      if (Serializable.class.isAssignableFrom(desc.forClass())) {\n+        writeBoolean(true);\n+        writeUTF(desc.getName());\n+      } else {\n+        writeBoolean(false);\n+        super.writeClassDescriptor(desc);\n+      }\n     }\n \n     /**\n-     * DOCUMENTME.\n-     * <p>\n-     * Created on Feb 16, 2004 at 8:09:48 PM.\n-     * </p>\n+     * Use this method to spy on any channels that are being serialized to\n+     * this stream.\n      *\n-     * @author Maciej Szefler <a href=\"mailto:mbs@fivesight.com\">mbs</a>\n+     * @param obj\n+     * @return\n+     * @throws IOException\n      */\n-    private class ExecutionQueueOutputStream extends ObjectOutputStream {\n-        private Set<Object> _serializedChannels = new HashSet<Object>();\n+    protected Object replaceObject(Object obj) throws IOException {\n+      if (!Serializable.class.isAssignableFrom(obj.getClass())) {\n+        return null;\n+      }\n \n-        public ExecutionQueueOutputStream(OutputStream outputStream) throws IOException {\n-            super(new GZIPOutputStream(outputStream));\n-            enableReplaceObject(true);\n+      if (obj instanceof org.apache.ode.jacob.Channel) {\n+        CommChannel commChannel = (CommChannel) ChannelFactory.getBackend((Channel) obj);\n+        _serializedChannels.add(commChannel.getId());\n+        return new ChannelRef(commChannel.getType(), (Integer) commChannel.getId());\n+      } else if (_replacementMap != null && _replacementMap.isReplaceable(obj)) {\n+        Object replacement = _replacementMap.getReplacement(obj);\n+        if (__log.isDebugEnabled()) {\n+          __log.debug(\"ReplacmentMap: getReplacement(\" + obj + \") = \" + replacement);\n         }\n+        return replacement;\n+      }\n \n-        public Set<Object> getSerializedChannels() {\n-            return _serializedChannels;\n-        }\n+      return obj;\n+    }\n \n-        protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {\n-            if (Serializable.class.isAssignableFrom(desc.forClass())) {\n-                writeBoolean(true);\n-                writeUTF(desc.getName());\n-            } else {\n-                writeBoolean(false);\n-                super.writeClassDescriptor(desc);\n-            }\n-        }\n+  }\n \n-        /**\n-         * Use this method to spy on any channels that are being serialized to\n-         * this stream.\n-         *\n-         * @param obj\n-         * @return\n-         * @throws IOException\n-         */\n-        protected Object replaceObject(Object obj) throws IOException {\n-            if (!Serializable.class.isAssignableFrom(obj.getClass()))\n-                return null;\n-\n-            if (obj instanceof org.apache.ode.jacob.Channel) {\n-                CommChannel commChannel = (CommChannel) ChannelFactory.getBackend((Channel) obj);\n-                _serializedChannels.add(commChannel.getId());\n-                return new ChannelRef(commChannel.getType(), (Integer) commChannel.getId());\n-            } else if (_replacementMap != null && _replacementMap.isReplaceable(obj)) {\n-                Object replacement = _replacementMap.getReplacement(obj);\n-                if (__log.isDebugEnabled())\n-                    __log.debug(\"ReplacmentMap: getReplacement(\" + obj + \") = \" + replacement);\n-                return replacement;\n-            }\n-\n-            return obj;\n-        }\n+  /**\n+   *\n+   */\n+  public class ExecutionQueueInputStream extends ObjectInputStream {\n+    private Set<CommChannel> _deserializedChannels = new HashSet<CommChannel>();\n \n+    public ExecutionQueueInputStream(InputStream in) throws IOException {\n+      super(new GZIPInputStream(in));\n+      enableResolveObject(true);\n     }\n \n-    /**\n-     */\n-    public class ExecutionQueueInputStream extends ObjectInputStream {\n-        private Set<CommChannel> _deserializedChannels = new HashSet<CommChannel>();\n+    public Set<CommChannel> getSerializedChannels() {\n+      return _deserializedChannels;\n+    }\n \n-        public ExecutionQueueInputStream(InputStream in) throws IOException {\n-            super(new GZIPInputStream(in));\n-            enableResolveObject(true);\n-        }\n+    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n+      return Class.forName(desc.getName(), true, _classLoader);\n+    }\n \n-        public Set<CommChannel> getSerializedChannels() {\n-            return _deserializedChannels;\n+    protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException {\n+      boolean ser = readBoolean();\n+      if (ser) {\n+        String clsName = readUTF();\n+        ObjectStreamClass cached = _classDescriptors.get(clsName);\n+        if (cached == null) {\n+          cached = ObjectStreamClass.lookup(Class.forName(clsName, true, _classLoader));\n+          _classDescriptors.put(clsName, cached);\n         }\n+        return cached;\n+      }\n+      return super.readClassDescriptor();\n+    }\n \n-        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n-            return Class.forName(desc.getName(), true, _classLoader);\n-        }\n+    protected Object resolveObject(Object obj) throws IOException {\n+      Object resolved;\n \n-        protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException {\n-            boolean ser = readBoolean();\n-            if (ser) {\n-                String clsName = readUTF();\n-                ObjectStreamClass cached = _classDescriptors.get(clsName);\n-                if (cached == null) {\n-                    cached = ObjectStreamClass.lookup(Class.forName(clsName, true, _classLoader));\n-                    _classDescriptors.put(clsName, cached);\n-                }\n-                return cached;\n-            }\n-            return super.readClassDescriptor();\n+      if (obj instanceof ChannelRef) {\n+        // We know this is a channel reference, so we have to resolve\n+        // the channel.\n+        ChannelRef oref = (ChannelRef) obj;\n+        CommChannel channel = new CommChannel(oref._type);\n+        channel.setId(oref._id);\n+        _deserializedChannels.add(channel);\n+        resolved = ChannelFactory.createChannel(channel, channel.getType());\n+      } else if (_replacementMap != null && _replacementMap.isReplacement(obj)) {\n+        resolved = _replacementMap.getOriginal(obj);\n+        if (__log.isDebugEnabled()) {\n+          __log.debug(\"ReplacementMap: getOriginal(\" + obj + \") = \" + resolved);\n         }\n+      } else {\n+        resolved = obj;\n+      }\n \n-        protected Object resolveObject(Object obj) throws IOException {\n-            Object resolved;\n-\n-            if (obj instanceof ChannelRef) {\n-                // We know this is a channel reference, so we have to resolve\n-                // the channel.\n-                ChannelRef oref = (ChannelRef) obj;\n-                CommChannel channel = new CommChannel(oref._type);\n-                channel.setId(oref._id);\n-                _deserializedChannels.add(channel);\n-                resolved = ChannelFactory.createChannel(channel, channel.getType());\n-            } else if (_replacementMap != null && _replacementMap.isReplacement(obj)) {\n-                resolved = _replacementMap.getOriginal(obj);\n-                if (__log.isDebugEnabled()) {\n-                    __log.debug(\"ReplacementMap: getOriginal(\" + obj + \") = \" + resolved);\n-                }\n-            } else {\n-                resolved = obj;\n-            }\n-\n-            if (resolved != null && resolved instanceof IndexedObject)\n-                index((IndexedObject) resolved);\n-\n-            return resolved;\n-        }\n+      if (resolved != null && resolved instanceof IndexedObject) {\n+        index((IndexedObject) resolved);\n+      }\n+\n+      return resolved;\n     }\n+  }\n \n-    private static final class ChannelRef implements Externalizable {\n-        private Class _type;\n+  private static final class ChannelRef implements Externalizable {\n+    private Class _type;\n \n-        private Integer _id;\n+    private Integer _id;\n \n-        private ChannelRef(Class type, Integer id) {\n-            _type = type;\n-            _id = id;\n-        }\n+    private ChannelRef(Class type, Integer id) {\n+      _type = type;\n+      _id = id;\n+    }\n \n-        public ChannelRef() {\n-        }\n+    public ChannelRef() {\n+    }\n \n-        public boolean equals(Object obj) {\n-            return ((ChannelRef) obj)._id.equals(_id);\n-        }\n+    public boolean equals(Object obj) {\n+      return ((ChannelRef) obj)._id.equals(_id);\n+    }\n \n-        public int hashCode() {\n-            return _id.hashCode();\n-        }\n+    public int hashCode() {\n+      return _id.hashCode();\n+    }\n \n-        public void writeExternal(ObjectOutput out) throws IOException {\n-            out.writeObject(_type);\n-            out.writeInt(_id.intValue());\n-        }\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+      out.writeObject(_type);\n+      out.writeInt(_id.intValue());\n+    }\n \n-        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n-            _type = (Class) in.readObject();\n-            _id = Integer.valueOf(in.readInt());\n-        }\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+      _type = (Class) in.readObject();\n+      _id = Integer.valueOf(in.readInt());\n     }\n+  }\n \n-    private static final class ExecutionQueueStatistics {\n-        public long cloneClosureTimeMs;\n+  private static final class ExecutionQueueStatistics {\n+    public long cloneClosureTimeMs;\n \n-        public long cloneClosureBytes;\n+    public long cloneClosureBytes;\n \n-        public long cloneClousreCount;\n+    public long cloneClousreCount;\n \n-        public long cloneClosureReadTimeMs;\n+    public long cloneClosureReadTimeMs;\n \n-        public void printStatistics(PrintStream ps) {\n-            Field[] fields = getClass().getFields();\n+    public void printStatistics(PrintStream ps) {\n+      Field[] fields = getClass().getFields();\n \n-            for (int i = 0; i < fields.length; ++i) {\n-                ps.print(fields[i].getName());\n-                ps.print(\" = \");\n+      for (int i = 0; i < fields.length; ++i) {\n+        ps.print(fields[i].getName());\n+        ps.print(\" = \");\n \n-                try {\n-                    ps.println(fields[i].get(this));\n-                } catch (Exception ex) {\n-                    ps.println(ex.toString());\n-                }\n-            }\n+        try {\n+          ps.println(fields[i].get(this));\n+        } catch (Exception ex) {\n+          ps.println(ex.toString());\n         }\n+      }\n     }\n+  }\n }\n",
            "diff_size": 1013
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "183",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "402",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 139).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/374/ExecutionQueueImpl.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/374/ExecutionQueueImpl.java\nindex 9d001ec180b..d837c9ebb34 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/errored/1/374/ExecutionQueueImpl.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/wso2-attic-commons/naturalize/374/ExecutionQueueImpl.java\n@@ -135,8 +135,7 @@ public class ExecutionQueueImpl implements ExecutionQueue {\n         if (__log.isTraceEnabled())\n             __log.trace(ObjectPrinter.stringifyMethodEnter(\"enqueueReaction\", new Object[] { \"continuation\",\n                     continuation }));\n-\n-        verifyNew(continuation);\n+verifyNew(continuation);\n         _reactions.add(continuation);\n     }\n \n@@ -400,8 +399,7 @@ public class ExecutionQueueImpl implements ExecutionQueue {\n             MessageFrame mframe = cframe.msgFrames.iterator().next();\n             ObjectFrame oframe = cframe.objFrames.iterator().next();\n \n-            Continuation continuation = new Continuation(oframe._continuation, oframe._continuation\n-                    .getMethod(mframe.method), mframe.args);\n+            Continuation continuation = new Continuation(oframe._continuation, oframe._continuation.getMethod(mframe.method), mframe.args);\n             if (__log.isInfoEnabled()) {\n                 continuation.setDescription(channel + \" ? {...} | \" + channel + \" ! \" + mframe.method + \"(...)\");\n             }\n@@ -632,8 +630,7 @@ public class ExecutionQueueImpl implements ExecutionQueue {\n             args = new Object[numArgs];\n             for (int i = 0; i < numArgs; ++i)\n                 args[i] = in.readObject();\n-\n-        }\n+    }\n \n         public void writeExternal(ObjectOutput out) throws IOException {\n             super.writeExternal(out);\n@@ -817,4 +814,4 @@ public class ExecutionQueueImpl implements ExecutionQueue {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 7
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "184",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "184",
                    "severity": "error",
                    "message": "Line is longer than 120 characters (found 121).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}