{
    "project_name": "moquette-io-moquette",
    "error_id": "43",
    "information": {
        "errors": [
            {
                "line": "173",
                "severity": "warning",
                "message": "Line is longer than 120 characters (found 128).",
                "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
            }
        ]
    },
    "source_code": "        boolean allowAnonymous = props.boolProp(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, true);\n        boolean allowZeroByteClientId = props.boolProp(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, false);\n        boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT, false);\n        m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator,\n                allowAnonymous, allowZeroByteClientId, authorizator, interceptor,\n            sessionsRepository, reauthorizeSubscriptionsOnConnect);",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "173",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "173",
                    "column": "121",
                    "severity": "warning",
                    "message": "',' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler/43/ProtocolProcessorBootstrapper.java\nindex 123ba81fb48..6eb9d72567b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler/43/ProtocolProcessorBootstrapper.java\n@@ -170,7 +170,7 @@ public class ProtocolProcessorBootstrapper {\n         LOG.info(\"Initializing MQTT protocol processor...\");\n         boolean allowAnonymous = props.boolProp(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, true);\n         boolean allowZeroByteClientId = props.boolProp(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, false);\n-        boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT, false);\n+        boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT ,false);\n         m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator,\n                 allowAnonymous, allowZeroByteClientId, authorizator, interceptor,\n             sessionsRepository, reauthorizeSubscriptionsOnConnect);\n",
            "diff_size": 1
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/43/ProtocolProcessorBootstrapper.java\nindex 123ba81fb48..f89c201f868 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/intellij/43/ProtocolProcessorBootstrapper.java\n@@ -47,219 +47,217 @@ import java.util.concurrent.ScheduledExecutorService;\n  */\n public class ProtocolProcessorBootstrapper {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(ProtocolProcessorBootstrapper.class);\n-    public static final String INMEMDB_STORE_CLASS = \"io.moquette.persistence.MemoryStorageService\";\n+  private static final Logger LOG = LoggerFactory.getLogger(ProtocolProcessorBootstrapper.class);\n+  public static final String INMEMDB_STORE_CLASS = \"io.moquette.persistence.MemoryStorageService\";\n \n-    private ISessionsStore m_sessionsStore;\n+  private ISessionsStore m_sessionsStore;\n \n-    private ISubscriptionsStore subscriptionsStore;\n+  private ISubscriptionsStore subscriptionsStore;\n \n-    private Runnable storeShutdown;\n+  private Runnable storeShutdown;\n \n-    private final ProtocolProcessor m_processor = new ProtocolProcessor();\n-    private ConnectionDescriptorStore connectionDescriptors;\n+  private final ProtocolProcessor m_processor = new ProtocolProcessor();\n+  private ConnectionDescriptorStore connectionDescriptors;\n \n-    public ProtocolProcessorBootstrapper() {\n+  public ProtocolProcessorBootstrapper() {\n+  }\n+\n+  /**\n+   * Initialize the processing part of the broker.\n+   *\n+   * @param props             the properties carrier where some props like port end host could be loaded. For\n+   *                          the full list check of configurable properties check moquette.conf file.\n+   * @param embeddedObservers a list of callbacks to be notified of certain events inside the broker. Could be\n+   *                          empty list of null.\n+   * @param authenticator     an implementation of the authenticator to be used, if null load that specified in\n+   *                          config and fallback on the default one (permit all).\n+   * @param authorizator      an implementation of the authorizator to be used, if null load that specified in\n+   *                          config and fallback on the default one (permit all).\n+   * @param server            the server to init.\n+   * @return the processor created for the broker.\n+   */\n+  public ProtocolProcessor init(IConfig props, List<? extends InterceptHandler> embeddedObservers,\n+                                IAuthenticator authenticator, IAuthorizatorPolicy authorizator, Server server) {\n+    IMessagesStore messagesStore;\n+    LOG.info(\"Initializing messages and sessions stores...\");\n+    String storageClassName = props.getProperty(BrokerConstants.STORAGE_CLASS_NAME, INMEMDB_STORE_CLASS);\n+    if (storageClassName == null || storageClassName.isEmpty()) {\n+      LOG.error(\"storage_class property not defined\");\n+      throw new IllegalArgumentException(\"Can't find a valid persistence layer\");\n+    }\n+    final IStore store = instantiateConfiguredStore(storageClassName, props, server.getScheduler());\n+    if (store == null) {\n+      throw new IllegalArgumentException(\"Can't start the persistence layer\");\n     }\n+    store.initStore();\n+    messagesStore = store.messagesStore();\n+    m_sessionsStore = store.sessionsStore();\n+    SessionsRepository sessionsRepository = new SessionsRepository(this.m_sessionsStore, server.getScheduler());\n+    sessionsRepository.init();\n+    this.subscriptionsStore = m_sessionsStore.subscriptionStore();\n+    storeShutdown = new Runnable() {\n \n-    /**\n-     * Initialize the processing part of the broker.\n-     *\n-     * @param props\n-     *            the properties carrier where some props like port end host could be loaded. For\n-     *            the full list check of configurable properties check moquette.conf file.\n-     * @param embeddedObservers\n-     *            a list of callbacks to be notified of certain events inside the broker. Could be\n-     *            empty list of null.\n-     * @param authenticator\n-     *            an implementation of the authenticator to be used, if null load that specified in\n-     *            config and fallback on the default one (permit all).\n-     * @param authorizator\n-     *            an implementation of the authorizator to be used, if null load that specified in\n-     *            config and fallback on the default one (permit all).\n-     * @param server\n-     *            the server to init.\n-     * @return the processor created for the broker.\n-     */\n-    public ProtocolProcessor init(IConfig props, List<? extends InterceptHandler> embeddedObservers,\n-                                  IAuthenticator authenticator, IAuthorizatorPolicy authorizator, Server server) {\n-        IMessagesStore messagesStore;\n-        LOG.info(\"Initializing messages and sessions stores...\");\n-        String storageClassName = props.getProperty(BrokerConstants.STORAGE_CLASS_NAME, INMEMDB_STORE_CLASS);\n-        if (storageClassName == null || storageClassName.isEmpty()) {\n-            LOG.error(\"storage_class property not defined\");\n-            throw new IllegalArgumentException(\"Can't find a valid persistence layer\");\n-        }\n-        final IStore store = instantiateConfiguredStore(storageClassName, props, server.getScheduler());\n-        if (store == null) {\n-            throw new IllegalArgumentException(\"Can't start the persistence layer\");\n-        }\n-        store.initStore();\n-        messagesStore = store.messagesStore();\n-        m_sessionsStore = store.sessionsStore();\n-        SessionsRepository sessionsRepository = new SessionsRepository(this.m_sessionsStore, server.getScheduler());\n-        sessionsRepository.init();\n-        this.subscriptionsStore = m_sessionsStore.subscriptionStore();\n-        storeShutdown = new Runnable() {\n+      @Override\n+      public void run() {\n+        store.close();\n+      }\n+    };\n \n-            @Override\n-            public void run() {\n-                store.close();\n-            }\n-        };\n+    LOG.info(\"Configuring message interceptors...\");\n \n-        LOG.info(\"Configuring message interceptors...\");\n+    List<InterceptHandler> observers = new ArrayList<>(embeddedObservers);\n+    String interceptorClassName = props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n+    if (interceptorClassName != null && !interceptorClassName.isEmpty()) {\n+      InterceptHandler handler = loadClass(interceptorClassName, InterceptHandler.class, Server.class, server);\n+      if (handler != null) {\n+        observers.add(handler);\n+      }\n+    }\n+    BrokerInterceptor interceptor = new BrokerInterceptor(props, observers);\n \n-        List<InterceptHandler> observers = new ArrayList<>(embeddedObservers);\n-        String interceptorClassName = props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n-        if (interceptorClassName != null && !interceptorClassName.isEmpty()) {\n-            InterceptHandler handler = loadClass(interceptorClassName, InterceptHandler.class, Server.class, server);\n-            if (handler != null) {\n-                observers.add(handler);\n-            }\n-        }\n-        BrokerInterceptor interceptor = new BrokerInterceptor(props, observers);\n+    LOG.info(\"Initializing subscriptions store...\");\n+    ISubscriptionsDirectory subscriptions = new CTrieSubscriptionDirectory();\n+    subscriptions.init(sessionsRepository);\n \n-        LOG.info(\"Initializing subscriptions store...\");\n-        ISubscriptionsDirectory subscriptions = new CTrieSubscriptionDirectory();\n-        subscriptions.init(sessionsRepository);\n+    LOG.info(\"Configuring MQTT authenticator...\");\n+    String authenticatorClassName = props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, \"\");\n \n-        LOG.info(\"Configuring MQTT authenticator...\");\n-        String authenticatorClassName = props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, \"\");\n+    if (authenticator == null && !authenticatorClassName.isEmpty()) {\n+      authenticator = loadClass(authenticatorClassName, IAuthenticator.class, IConfig.class, props);\n+    }\n \n-        if (authenticator == null && !authenticatorClassName.isEmpty()) {\n-            authenticator = loadClass(authenticatorClassName, IAuthenticator.class, IConfig.class, props);\n-        }\n+    IResourceLoader resourceLoader = props.getResourceLoader();\n+    if (authenticator == null) {\n+      String passwdPath = props.getProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME, \"\");\n+      if (passwdPath.isEmpty()) {\n+        authenticator = new AcceptAllAuthenticator();\n+      } else {\n+        authenticator = new ResourceAuthenticator(resourceLoader, passwdPath);\n+      }\n+      LOG.info(\"An {} authenticator instance will be used\", authenticator.getClass().getName());\n+    }\n \n-        IResourceLoader resourceLoader = props.getResourceLoader();\n-        if (authenticator == null) {\n-            String passwdPath = props.getProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME, \"\");\n-            if (passwdPath.isEmpty()) {\n-                authenticator = new AcceptAllAuthenticator();\n-            } else {\n-                authenticator = new ResourceAuthenticator(resourceLoader, passwdPath);\n-            }\n-            LOG.info(\"An {} authenticator instance will be used\", authenticator.getClass().getName());\n-        }\n+    LOG.info(\"Configuring MQTT authorizator...\");\n+    String authorizatorClassName = props.getProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME, \"\");\n+    if (authorizator == null && !authorizatorClassName.isEmpty()) {\n+      authorizator = loadClass(authorizatorClassName, IAuthorizatorPolicy.class, IConfig.class, props);\n+    }\n \n-        LOG.info(\"Configuring MQTT authorizator...\");\n-        String authorizatorClassName = props.getProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME, \"\");\n-        if (authorizator == null && !authorizatorClassName.isEmpty()) {\n-            authorizator = loadClass(authorizatorClassName, IAuthorizatorPolicy.class, IConfig.class, props);\n+    if (authorizator == null) {\n+      String aclFilePath = props.getProperty(BrokerConstants.ACL_FILE_PROPERTY_NAME, \"\");\n+      if (aclFilePath != null && !aclFilePath.isEmpty()) {\n+        authorizator = new DenyAllAuthorizatorPolicy();\n+        try {\n+          LOG.info(\"Parsing ACL file. Path = {}\", aclFilePath);\n+          authorizator = ACLFileParser.parse(resourceLoader.loadResource(aclFilePath));\n+        } catch (ParseException pex) {\n+          LOG.error(\"Unable to parse ACL file. path=\" + aclFilePath, pex);\n         }\n+      } else {\n+        authorizator = new PermitAllAuthorizatorPolicy();\n+      }\n+      LOG.info(\"An {} authorizator instance will be used\", authorizator.getClass().getName());\n+    }\n \n-        if (authorizator == null) {\n-            String aclFilePath = props.getProperty(BrokerConstants.ACL_FILE_PROPERTY_NAME, \"\");\n-            if (aclFilePath != null && !aclFilePath.isEmpty()) {\n-                authorizator = new DenyAllAuthorizatorPolicy();\n-                try {\n-                    LOG.info(\"Parsing ACL file. Path = {}\", aclFilePath);\n-                    authorizator = ACLFileParser.parse(resourceLoader.loadResource(aclFilePath));\n-                } catch (ParseException pex) {\n-                    LOG.error(\"Unable to parse ACL file. path=\" + aclFilePath, pex);\n-                }\n-            } else {\n-                authorizator = new PermitAllAuthorizatorPolicy();\n-            }\n-            LOG.info(\"An {} authorizator instance will be used\", authorizator.getClass().getName());\n-        }\n+    LOG.info(\"Initializing connection descriptor store...\");\n+    connectionDescriptors = new ConnectionDescriptorStore();\n \n-        LOG.info(\"Initializing connection descriptor store...\");\n-        connectionDescriptors = new ConnectionDescriptorStore();\n+    LOG.info(\"Initializing MQTT protocol processor...\");\n+    boolean allowAnonymous = props.boolProp(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, true);\n+    boolean allowZeroByteClientId = props.boolProp(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, false);\n+    boolean reauthorizeSubscriptionsOnConnect =\n+        props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT, false);\n+    m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator,\n+        allowAnonymous, allowZeroByteClientId, authorizator, interceptor,\n+        sessionsRepository, reauthorizeSubscriptionsOnConnect);\n+    return m_processor;\n+  }\n \n-        LOG.info(\"Initializing MQTT protocol processor...\");\n-        boolean allowAnonymous = props.boolProp(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, true);\n-        boolean allowZeroByteClientId = props.boolProp(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, false);\n-        boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT, false);\n-        m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator,\n-                allowAnonymous, allowZeroByteClientId, authorizator, interceptor,\n-            sessionsRepository, reauthorizeSubscriptionsOnConnect);\n-        return m_processor;\n+  private IStore instantiateConfiguredStore(String storageClassName, IConfig props,\n+                                            ScheduledExecutorService scheduledExecutor) {\n+    LOG.info(\"Loading storage class {}\", storageClassName);\n+    Class<? extends IStore> storageClass;\n+    try {\n+      storageClass = this.getClass().getClassLoader()\n+          .loadClass(storageClassName)\n+          .asSubclass(IStore.class);\n+    } catch (ClassNotFoundException cnfex) {\n+      LOG.error(\"Cannot find storage class \" + storageClassName + \" in classpath\", cnfex);\n+      return null;\n     }\n \n-    private IStore instantiateConfiguredStore(String storageClassName, IConfig props,\n-                                              ScheduledExecutorService scheduledExecutor) {\n-        LOG.info(\"Loading storage class {}\", storageClassName);\n-        Class<? extends IStore> storageClass;\n-        try {\n-            storageClass = this.getClass().getClassLoader()\n-                .loadClass(storageClassName)\n-                .asSubclass(IStore.class);\n-        } catch (ClassNotFoundException cnfex) {\n-            LOG.error(\"Cannot find storage class \" + storageClassName + \" in classpath\", cnfex);\n-            return null;\n-        }\n+    final Constructor<? extends IStore> constructor;\n+    try {\n+      constructor = storageClass\n+          .getConstructor(IConfig.class, ScheduledExecutorService.class);\n+    } catch (NoSuchMethodException nsmex) {\n+      LOG.error(\"Cannot find constructor with required params IConfig, ScheduledExecutorService \", nsmex);\n+      return null;\n+    }\n+    try {\n+      return constructor.newInstance(props, scheduledExecutor);\n+    } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n+      LOG.error(\"Cannot instantiate the \" + storageClassName + \" instance\", ex);\n+    }\n \n-        final Constructor<? extends IStore> constructor;\n-        try {\n-            constructor = storageClass\n-                .getConstructor(IConfig.class, ScheduledExecutorService.class);\n-        } catch (NoSuchMethodException nsmex) {\n-            LOG.error(\"Cannot find constructor with required params IConfig, ScheduledExecutorService \", nsmex);\n-            return null;\n-        }\n-        try {\n-            return constructor.newInstance(props, scheduledExecutor);\n-        } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n-            LOG.error(\"Cannot instantiate the \" + storageClassName + \" instance\", ex);\n-        }\n+    return null;\n+  }\n \n+  @SuppressWarnings(\"unchecked\")\n+  private <T, U> T loadClass(String className, Class<T> intrface, Class<U> constructorArgClass, U props) {\n+    T instance = null;\n+    try {\n+      // check if constructor with constructor arg class parameter\n+      // exists\n+      LOG.info(\"Invoking constructor with {} argument. ClassName={}, interfaceName={}\",\n+          constructorArgClass.getName(), className, intrface.getName());\n+      instance = this.getClass().getClassLoader()\n+          .loadClass(className)\n+          .asSubclass(intrface)\n+          .getConstructor(constructorArgClass)\n+          .newInstance(props);\n+    } catch (InstantiationException | IllegalAccessException | ClassNotFoundException ex) {\n+      LOG.warn(\"Unable to invoke constructor with {} argument. ClassName={}, interfaceName={}, cause={}, \" +\n+              \"errorMessage={}\", constructorArgClass.getName(), className, intrface.getName(), ex.getCause(),\n+          ex.getMessage());\n+      return null;\n+    } catch (NoSuchMethodException | InvocationTargetException e) {\n+      try {\n+        LOG.info(\"Invoking default constructor. ClassName={}, interfaceName={}\", className, intrface.getName());\n+        // fallback to default constructor\n+        instance = this.getClass().getClassLoader()\n+            .loadClass(className)\n+            .asSubclass(intrface)\n+            .getDeclaredConstructor().newInstance();\n+      } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n+          NoSuchMethodException | InvocationTargetException ex) {\n+        LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n+            \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n         return null;\n+      }\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private <T, U> T loadClass(String className, Class<T> intrface, Class<U> constructorArgClass, U props) {\n-        T instance = null;\n-        try {\n-            // check if constructor with constructor arg class parameter\n-            // exists\n-            LOG.info(\"Invoking constructor with {} argument. ClassName={}, interfaceName={}\",\n-                    constructorArgClass.getName(), className, intrface.getName());\n-            instance = this.getClass().getClassLoader()\n-                .loadClass(className)\n-                .asSubclass(intrface)\n-                .getConstructor(constructorArgClass)\n-                .newInstance(props);\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException ex) {\n-            LOG.warn(\"Unable to invoke constructor with {} argument. ClassName={}, interfaceName={}, cause={}, \" +\n-                     \"errorMessage={}\", constructorArgClass.getName(), className, intrface.getName(), ex.getCause(),\n-                     ex.getMessage());\n-            return null;\n-        } catch (NoSuchMethodException | InvocationTargetException e) {\n-            try {\n-                LOG.info(\"Invoking default constructor. ClassName={}, interfaceName={}\", className, intrface.getName());\n-                // fallback to default constructor\n-                instance = this.getClass().getClassLoader()\n-                    .loadClass(className)\n-                    .asSubclass(intrface)\n-                    .getDeclaredConstructor().newInstance();\n-            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n-                     NoSuchMethodException | InvocationTargetException ex) {\n-                LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n-                          \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n-                return null;\n-            }\n-        }\n+    return instance;\n+  }\n \n-        return instance;\n-    }\n+  public ISessionsStore getSessionsStore() {\n+    return m_sessionsStore;\n+  }\n \n-    public ISessionsStore getSessionsStore() {\n-        return m_sessionsStore;\n-    }\n+  public List<Subscription> getSubscriptions() {\n+    return this.subscriptionsStore.listAllSubscriptions();\n+  }\n \n-    public List<Subscription> getSubscriptions() {\n-        return this.subscriptionsStore.listAllSubscriptions();\n+  public void shutdown() {\n+    if (storeShutdown != null) {\n+      storeShutdown.run();\n     }\n-\n-    public void shutdown() {\n-        if (storeShutdown != null)\n-            storeShutdown.run();\n-        if (m_processor != null)\n-            m_processor.shutdown();\n+    if (m_processor != null) {\n+      m_processor.shutdown();\n     }\n+  }\n \n-    public ConnectionDescriptorStore getConnectionDescriptors() {\n-        return connectionDescriptors;\n-    }\n+  public ConnectionDescriptorStore getConnectionDescriptors() {\n+    return connectionDescriptors;\n+  }\n }\n",
            "diff_size": 290
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "84",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 181).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "172",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "174",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 137).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "178",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 131).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/43/ProtocolProcessorBootstrapper.java\nindex 123ba81fb48..b0e296b4beb 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/naturalize/43/ProtocolProcessorBootstrapper.java\n@@ -81,9 +81,8 @@ public class ProtocolProcessorBootstrapper {\n      *            the server to init.\n      * @return the processor created for the broker.\n      */\n-    public ProtocolProcessor init(IConfig props, List<? extends InterceptHandler> embeddedObservers,\n-                                  IAuthenticator authenticator, IAuthorizatorPolicy authorizator, Server server) {\n-        IMessagesStore messagesStore;\n+    public ProtocolProcessor init(IConfig props, List<? extends InterceptHandler> embeddedObservers, IAuthenticator authenticator, IAuthorizatorPolicy authorizator, Server server) {\n+    IMessagesStore messagesStore;\n         LOG.info(\"Initializing messages and sessions stores...\");\n         String storageClassName = props.getProperty(BrokerConstants.STORAGE_CLASS_NAME, INMEMDB_STORE_CLASS);\n         if (storageClassName == null || storageClassName.isEmpty()) {\n@@ -172,14 +171,12 @@ public class ProtocolProcessorBootstrapper {\n         boolean allowZeroByteClientId = props.boolProp(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, false);\n         boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT, false);\n         m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator,\n-                allowAnonymous, allowZeroByteClientId, authorizator, interceptor,\n-            sessionsRepository, reauthorizeSubscriptionsOnConnect);\n+                allowAnonymous, allowZeroByteClientId, authorizator, interceptor, sessionsRepository, reauthorizeSubscriptionsOnConnect);\n         return m_processor;\n     }\n \n-    private IStore instantiateConfiguredStore(String storageClassName, IConfig props,\n-                                              ScheduledExecutorService scheduledExecutor) {\n-        LOG.info(\"Loading storage class {}\", storageClassName);\n+    private IStore instantiateConfiguredStore(String storageClassName, IConfig props, ScheduledExecutorService scheduledExecutor) {\n+    LOG.info(\"Loading storage class {}\", storageClassName);\n         Class<? extends IStore> storageClass;\n         try {\n             storageClass = this.getClass().getClassLoader()\n@@ -235,9 +232,9 @@ public class ProtocolProcessorBootstrapper {\n                     .getDeclaredConstructor().newInstance();\n             } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n                      NoSuchMethodException | InvocationTargetException ex) {\n-                LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n+    LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n                           \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n-                return null;\n+return null;\n             }\n         }\n \n@@ -262,4 +259,4 @@ public class ProtocolProcessorBootstrapper {\n     public ConnectionDescriptorStore getConnectionDescriptors() {\n         return connectionDescriptors;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 11
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "45",
                    "severity": "warning",
                    "message": "two or more consecutive empty lines",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpMultilineCheck"
                },
                {
                    "line": "167",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "168",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 231).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "172",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 131).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "216",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 228).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "228",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 151).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "229",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 193).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/43/ProtocolProcessorBootstrapper.java\nindex 123ba81fb48..d43c455b358 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/codebuff/43/ProtocolProcessorBootstrapper.java\n@@ -34,7 +34,6 @@ import io.moquette.spi.security.IAuthenticator;\n import io.moquette.spi.security.IAuthorizatorPolicy;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.text.ParseException;\n@@ -45,17 +44,16 @@ import java.util.concurrent.ScheduledExecutorService;\n /**\n  * It's main responsibility is bootstrap the ProtocolProcessor.\n  */\n+\n+\n public class ProtocolProcessorBootstrapper {\n \n     private static final Logger LOG = LoggerFactory.getLogger(ProtocolProcessorBootstrapper.class);\n-    public static final String INMEMDB_STORE_CLASS = \"io.moquette.persistence.MemoryStorageService\";\n \n+    public static final String INMEMDB_STORE_CLASS = \"io.moquette.persistence.MemoryStorageService\";\n     private ISessionsStore m_sessionsStore;\n-\n     private ISubscriptionsStore subscriptionsStore;\n-\n     private Runnable storeShutdown;\n-\n     private final ProtocolProcessor m_processor = new ProtocolProcessor();\n     private ConnectionDescriptorStore connectionDescriptors;\n \n@@ -81,8 +79,11 @@ public class ProtocolProcessorBootstrapper {\n      *            the server to init.\n      * @return the processor created for the broker.\n      */\n-    public ProtocolProcessor init(IConfig props, List<? extends InterceptHandler> embeddedObservers,\n-                                  IAuthenticator authenticator, IAuthorizatorPolicy authorizator, Server server) {\n+\n+    public ProtocolProcessor init(IConfig props,\n+                                  List<? extends InterceptHandler> embeddedObservers,\n+                                  IAuthenticator authenticator,\n+                                  IAuthorizatorPolicy authorizator, Server server) {\n         IMessagesStore messagesStore;\n         LOG.info(\"Initializing messages and sessions stores...\");\n         String storageClassName = props.getProperty(BrokerConstants.STORAGE_CLASS_NAME, INMEMDB_STORE_CLASS);\n@@ -107,9 +108,7 @@ public class ProtocolProcessorBootstrapper {\n                 store.close();\n             }\n         };\n-\n         LOG.info(\"Configuring message interceptors...\");\n-\n         List<InterceptHandler> observers = new ArrayList<>(embeddedObservers);\n         String interceptorClassName = props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);\n         if (interceptorClassName != null && !interceptorClassName.isEmpty()) {\n@@ -118,15 +117,13 @@ public class ProtocolProcessorBootstrapper {\n                 observers.add(handler);\n             }\n         }\n-        BrokerInterceptor interceptor = new BrokerInterceptor(props, observers);\n \n+        BrokerInterceptor interceptor = new BrokerInterceptor(props, observers);\n         LOG.info(\"Initializing subscriptions store...\");\n         ISubscriptionsDirectory subscriptions = new CTrieSubscriptionDirectory();\n         subscriptions.init(sessionsRepository);\n-\n         LOG.info(\"Configuring MQTT authenticator...\");\n         String authenticatorClassName = props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME, \"\");\n-\n         if (authenticator == null && !authenticatorClassName.isEmpty()) {\n             authenticator = loadClass(authenticatorClassName, IAuthenticator.class, IConfig.class, props);\n         }\n@@ -141,7 +138,6 @@ public class ProtocolProcessorBootstrapper {\n             }\n             LOG.info(\"An {} authenticator instance will be used\", authenticator.getClass().getName());\n         }\n-\n         LOG.info(\"Configuring MQTT authorizator...\");\n         String authorizatorClassName = props.getProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME, \"\");\n         if (authorizator == null && !authorizatorClassName.isEmpty()) {\n@@ -163,37 +159,31 @@ public class ProtocolProcessorBootstrapper {\n             }\n             LOG.info(\"An {} authorizator instance will be used\", authorizator.getClass().getName());\n         }\n-\n         LOG.info(\"Initializing connection descriptor store...\");\n         connectionDescriptors = new ConnectionDescriptorStore();\n-\n         LOG.info(\"Initializing MQTT protocol processor...\");\n         boolean allowAnonymous = props.boolProp(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, true);\n         boolean allowZeroByteClientId = props.boolProp(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, false);\n         boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT, false);\n-        m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator,\n-                allowAnonymous, allowZeroByteClientId, authorizator, interceptor,\n-            sessionsRepository, reauthorizeSubscriptionsOnConnect);\n+        m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator, allowAnonymous, allowZeroByteClientId, authorizator, interceptor, sessionsRepository, reauthorizeSubscriptionsOnConnect);\n         return m_processor;\n     }\n \n-    private IStore instantiateConfiguredStore(String storageClassName, IConfig props,\n-                                              ScheduledExecutorService scheduledExecutor) {\n+    private IStore instantiateConfiguredStore(String storageClassName, IConfig props, ScheduledExecutorService scheduledExecutor) {\n         LOG.info(\"Loading storage class {}\", storageClassName);\n         Class<? extends IStore> storageClass;\n         try {\n-            storageClass = this.getClass().getClassLoader()\n-                .loadClass(storageClassName)\n-                .asSubclass(IStore.class);\n+            storageClass = this.getClass()\n+.getClassLoader()\n+.loadClass(storageClassName)\n+.asSubclass(IStore.class);\n         } catch (ClassNotFoundException cnfex) {\n             LOG.error(\"Cannot find storage class \" + storageClassName + \" in classpath\", cnfex);\n             return null;\n         }\n-\n         final Constructor<? extends IStore> constructor;\n         try {\n-            constructor = storageClass\n-                .getConstructor(IConfig.class, ScheduledExecutorService.class);\n+            constructor = storageClass.getConstructor(IConfig.class, ScheduledExecutorService.class);\n         } catch (NoSuchMethodException nsmex) {\n             LOG.error(\"Cannot find constructor with required params IConfig, ScheduledExecutorService \", nsmex);\n             return null;\n@@ -203,7 +193,6 @@ public class ProtocolProcessorBootstrapper {\n         } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n             LOG.error(\"Cannot instantiate the \" + storageClassName + \" instance\", ex);\n         }\n-\n         return null;\n     }\n \n@@ -214,33 +203,33 @@ public class ProtocolProcessorBootstrapper {\n             // check if constructor with constructor arg class parameter\n             // exists\n             LOG.info(\"Invoking constructor with {} argument. ClassName={}, interfaceName={}\",\n-                    constructorArgClass.getName(), className, intrface.getName());\n-            instance = this.getClass().getClassLoader()\n-                .loadClass(className)\n-                .asSubclass(intrface)\n-                .getConstructor(constructorArgClass)\n-                .newInstance(props);\n+                constructorArgClass.getName(),\n+                className,\n+                intrface.getName());\n+            instance = this.getClass()\n+.getClassLoader()\n+.loadClass(className)\n+.asSubclass(intrface)\n+.getConstructor(constructorArgClass)\n+.newInstance(props);\n         } catch (InstantiationException | IllegalAccessException | ClassNotFoundException ex) {\n-            LOG.warn(\"Unable to invoke constructor with {} argument. ClassName={}, interfaceName={}, cause={}, \" +\n-                     \"errorMessage={}\", constructorArgClass.getName(), className, intrface.getName(), ex.getCause(),\n-                     ex.getMessage());\n+            LOG.warn(\"Unable to invoke constructor with {} argument. ClassName={}, interfaceName={}, cause={}, \" + \"errorMessage={}\", constructorArgClass.getName(), className, intrface.getName(), ex.getCause(), ex.getMessage());\n             return null;\n         } catch (NoSuchMethodException | InvocationTargetException e) {\n             try {\n                 LOG.info(\"Invoking default constructor. ClassName={}, interfaceName={}\", className, intrface.getName());\n                 // fallback to default constructor\n-                instance = this.getClass().getClassLoader()\n-                    .loadClass(className)\n-                    .asSubclass(intrface)\n-                    .getDeclaredConstructor().newInstance();\n-            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException |\n-                     NoSuchMethodException | InvocationTargetException ex) {\n-                LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" +\n-                          \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n+                instance = this.getClass()\n+.getClassLoader()\n+.loadClass(className)\n+.asSubclass(intrface)\n+.getDeclaredConstructor()\n+.newInstance();\n+            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException | InvocationTargetException ex) {\n+                LOG.error(\"Unable to invoke default constructor. ClassName={}, interfaceName={}, cause={}, \" + \"errorMessage={}\", className, intrface.getName(), ex.getCause(), ex.getMessage());\n                 return null;\n             }\n         }\n-\n         return instance;\n     }\n \n@@ -262,4 +251,4 @@ public class ProtocolProcessorBootstrapper {\n     public ConnectionDescriptorStore getConnectionDescriptors() {\n         return connectionDescriptors;\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 57
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "173",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 128).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "173",
                    "column": "121",
                    "severity": "warning",
                    "message": "',' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_random/43/ProtocolProcessorBootstrapper.java\nindex 123ba81fb48..6eb9d72567b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_random/43/ProtocolProcessorBootstrapper.java\n@@ -170,7 +170,7 @@ public class ProtocolProcessorBootstrapper {\n         LOG.info(\"Initializing MQTT protocol processor...\");\n         boolean allowAnonymous = props.boolProp(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, true);\n         boolean allowZeroByteClientId = props.boolProp(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, false);\n-        boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT, false);\n+        boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT ,false);\n         m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator,\n                 allowAnonymous, allowZeroByteClientId, authorizator, interceptor,\n             sessionsRepository, reauthorizeSubscriptionsOnConnect);\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "173",
                    "severity": "warning",
                    "message": "Line is longer than 120 characters (found 231).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "173",
                    "column": "130",
                    "severity": "warning",
                    "message": "';' is not followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAfterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_three_grams/43/ProtocolProcessorBootstrapper.java\nindex 123ba81fb48..a0cd1e3c15b 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/errored/1/43/ProtocolProcessorBootstrapper.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/moquette-io-moquette/styler_three_grams/43/ProtocolProcessorBootstrapper.java\n@@ -170,8 +170,7 @@ public class ProtocolProcessorBootstrapper {\n         LOG.info(\"Initializing MQTT protocol processor...\");\n         boolean allowAnonymous = props.boolProp(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME, true);\n         boolean allowZeroByteClientId = props.boolProp(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME, false);\n-        boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT, false);\n-        m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator,\n+        boolean reauthorizeSubscriptionsOnConnect = props.boolProp(BrokerConstants. REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT, false) ;m_processor.init(connectionDescriptors, subscriptions, messagesStore, m_sessionsStore, authenticator,\n                 allowAnonymous, allowZeroByteClientId, authorizator, interceptor,\n             sessionsRepository, reauthorizeSubscriptionsOnConnect);\n         return m_processor;\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}