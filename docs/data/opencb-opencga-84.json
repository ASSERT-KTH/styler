{
    "project_name": "opencb-opencga",
    "error_id": "84",
    "information": {
        "errors": [
            {
                "line": "29",
                "column": "28",
                "severity": "error",
                "message": "',' is preceded with whitespace.",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
            }
        ]
    },
    "source_code": "                    .setScanners(\n                            new SubTypesScanner()\n                            ,\n                            new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, ToolExecutor.class.getName()))\n                    )\n                    .addUrls(ClasspathHelper.forJavaClassPath())",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/84/ToolExecutorFactory.java\nindex e52358e4303..37e60961b0c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler/84/ToolExecutorFactory.java\n@@ -25,8 +25,7 @@ public class ToolExecutorFactory {\n         if (executorsCache == null) {\n             Reflections reflections = new Reflections(new ConfigurationBuilder()\n                     .setScanners(\n-                            new SubTypesScanner()\n-                            ,\n+                            new SubTypesScanner(),\n                             new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, ToolExecutor.class.getName()))\n                     )\n                     .addUrls(ClasspathHelper.forJavaClassPath())\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "29",
                    "column": "14",
                    "severity": "error",
                    "message": "',' is preceded with whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/84/ToolExecutorFactory.java\nindex e52358e4303..bd65e7969a1 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/intellij/84/ToolExecutorFactory.java\n@@ -17,133 +17,133 @@ import java.lang.reflect.Modifier;\n import java.util.*;\n \n public class ToolExecutorFactory {\n-    private final Logger logger = LoggerFactory.getLogger(ToolExecutorFactory.class);\n-\n-    private static Set<Class<? extends OpenCgaToolExecutor>> executorsCache;\n-\n-    private static synchronized Set<Class<? extends OpenCgaToolExecutor>> loadExecutors() {\n-        if (executorsCache == null) {\n-            Reflections reflections = new Reflections(new ConfigurationBuilder()\n-                    .setScanners(\n-                            new SubTypesScanner()\n-                            ,\n-                            new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, ToolExecutor.class.getName()))\n-                    )\n-                    .addUrls(ClasspathHelper.forJavaClassPath())\n-                    .filterInputsBy(input -> input != null && input.endsWith(\".class\"))\n-            );\n-\n-            executorsCache = reflections.getSubTypesOf(OpenCgaToolExecutor.class);\n+  private final Logger logger = LoggerFactory.getLogger(ToolExecutorFactory.class);\n+\n+  private static Set<Class<? extends OpenCgaToolExecutor>> executorsCache;\n+\n+  private static synchronized Set<Class<? extends OpenCgaToolExecutor>> loadExecutors() {\n+    if (executorsCache == null) {\n+      Reflections reflections = new Reflections(new ConfigurationBuilder()\n+          .setScanners(\n+              new SubTypesScanner()\n+              ,\n+              new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, ToolExecutor.class.getName()))\n+          )\n+          .addUrls(ClasspathHelper.forJavaClassPath())\n+          .filterInputsBy(input -> input != null && input.endsWith(\".class\"))\n+      );\n+\n+      executorsCache = reflections.getSubTypesOf(OpenCgaToolExecutor.class);\n+    }\n+    return executorsCache;\n+  }\n+\n+  public final Class<? extends OpenCgaToolExecutor> getToolExecutorClass(String toolId, String toolExecutorId) {\n+    return getToolExecutorClass(toolId, toolExecutorId, OpenCgaToolExecutor.class);\n+  }\n+\n+  public final <T extends OpenCgaToolExecutor> Class<? extends T> getToolExecutorClass(\n+      String toolId, String toolExecutorId, Class<T> clazz) {\n+    return getToolExecutorClass(toolId, toolExecutorId, clazz, null, null);\n+  }\n+\n+  public final <T extends OpenCgaToolExecutor> Class<? extends T> getToolExecutorClass(\n+      String toolId, String toolExecutorId, Class<T> clazz,\n+      List<ToolExecutor.Source> sourceTypes,\n+      List<ToolExecutor.Framework> availableFrameworks) {\n+    Objects.requireNonNull(clazz);\n+\n+    List<Class<? extends T>> candidateClasses = new ArrayList<>();\n+    // If the given class is not abstract, check if matches the criteria.\n+    if (!Modifier.isAbstract(clazz.getModifiers())) {\n+      if (isValidClass(toolId, toolExecutorId, clazz, clazz, sourceTypes, availableFrameworks)) {\n+        if (StringUtils.isNotEmpty(toolExecutorId) || Modifier.isFinal(clazz.getModifiers())) {\n+          // Shortcut to skip reflection\n+          return clazz;\n         }\n-        return executorsCache;\n+        candidateClasses.add(clazz);\n+      }\n     }\n \n-    public final Class<? extends OpenCgaToolExecutor> getToolExecutorClass(String toolId, String toolExecutorId) {\n-        return getToolExecutorClass(toolId, toolExecutorId, OpenCgaToolExecutor.class);\n+    Set<Class<? extends OpenCgaToolExecutor>> typesAnnotatedWith = loadExecutors();\n+    for (Class<? extends OpenCgaToolExecutor> aClass : typesAnnotatedWith) {\n+      if (isValidClass(toolId, toolExecutorId, clazz, aClass, sourceTypes, availableFrameworks)) {\n+        candidateClasses.add((Class<? extends T>) aClass);\n+      }\n     }\n-\n-    public final <T extends OpenCgaToolExecutor> Class<? extends T> getToolExecutorClass(\n-            String toolId, String toolExecutorId, Class<T> clazz) {\n-        return getToolExecutorClass(toolId, toolExecutorId, clazz, null, null);\n+    if (candidateClasses.isEmpty()) {\n+      return null;\n+    } else if (candidateClasses.size() == 1) {\n+      return candidateClasses.get(0);\n+    } else {\n+      logger.info(\"Found multiple \" + OpenCgaToolExecutor.class.getName() + \" candidates.\");\n+      for (Class<? extends T> matchedClass : candidateClasses) {\n+        logger.info(\" - \" + matchedClass);\n+      }\n+      logger.info(\"Sort by framework and source preference.\");\n+\n+      // Prefer the executor that matches better with the source\n+      // Prefer the executor that matches better with the framework\n+      List<ToolExecutor.Framework> finalAvailableFrameworks =\n+          availableFrameworks == null ? Collections.emptyList() : availableFrameworks;\n+      List<ToolExecutor.Source> finalSourceTypes =\n+          sourceTypes == null ? Collections.emptyList() : sourceTypes;\n+\n+      Comparator<Class<? extends T>> comparator = Comparator.<Class<? extends T>>comparingInt(c1 -> {\n+        ToolExecutor annot1 = c1.getAnnotation(ToolExecutor.class);\n+        return finalAvailableFrameworks.indexOf(annot1.framework());\n+      }).thenComparingInt(c -> {\n+        ToolExecutor annot = c.getAnnotation(ToolExecutor.class);\n+        return finalSourceTypes.indexOf(annot.source());\n+      }).thenComparing(Class::getName);\n+\n+      candidateClasses.sort(comparator);\n+\n+      return candidateClasses.get(0);\n     }\n+  }\n \n-    public final <T extends OpenCgaToolExecutor> Class<? extends T> getToolExecutorClass(\n-            String toolId, String toolExecutorId, Class<T> clazz,\n-            List<ToolExecutor.Source> sourceTypes,\n-            List<ToolExecutor.Framework> availableFrameworks) {\n-        Objects.requireNonNull(clazz);\n-\n-        List<Class<? extends T>> candidateClasses = new ArrayList<>();\n-        // If the given class is not abstract, check if matches the criteria.\n-        if (!Modifier.isAbstract(clazz.getModifiers())) {\n-            if (isValidClass(toolId, toolExecutorId, clazz, clazz, sourceTypes, availableFrameworks)) {\n-                if (StringUtils.isNotEmpty(toolExecutorId) || Modifier.isFinal(clazz.getModifiers())) {\n-                    // Shortcut to skip reflection\n-                    return clazz;\n-                }\n-                candidateClasses.add(clazz);\n-            }\n-        }\n-\n-        Set<Class<? extends OpenCgaToolExecutor>> typesAnnotatedWith = loadExecutors();\n-        for (Class<? extends OpenCgaToolExecutor> aClass : typesAnnotatedWith) {\n-            if (isValidClass(toolId, toolExecutorId, clazz, aClass, sourceTypes, availableFrameworks)) {\n-                candidateClasses.add((Class<? extends T>) aClass);\n-            }\n-        }\n-        if (candidateClasses.isEmpty()) {\n-            return null;\n-        } else if (candidateClasses.size() == 1) {\n-            return candidateClasses.get(0);\n-        } else {\n-            logger.info(\"Found multiple \" + OpenCgaToolExecutor.class.getName() + \" candidates.\");\n-            for (Class<? extends T> matchedClass : candidateClasses) {\n-                logger.info(\" - \" + matchedClass);\n-            }\n-            logger.info(\"Sort by framework and source preference.\");\n-\n-            // Prefer the executor that matches better with the source\n-            // Prefer the executor that matches better with the framework\n-            List<ToolExecutor.Framework> finalAvailableFrameworks =\n-                    availableFrameworks == null ? Collections.emptyList() : availableFrameworks;\n-            List<ToolExecutor.Source> finalSourceTypes =\n-                    sourceTypes == null ? Collections.emptyList() : sourceTypes;\n-\n-            Comparator<Class<? extends T>> comparator = Comparator.<Class<? extends T>>comparingInt(c1 -> {\n-                ToolExecutor annot1 = c1.getAnnotation(ToolExecutor.class);\n-                return finalAvailableFrameworks.indexOf(annot1.framework());\n-            }).thenComparingInt(c -> {\n-                ToolExecutor annot = c.getAnnotation(ToolExecutor.class);\n-                return finalSourceTypes.indexOf(annot.source());\n-            }).thenComparing(Class::getName);\n-\n-            candidateClasses.sort(comparator);\n-\n-            return candidateClasses.get(0);\n-        }\n+  private <T> boolean isValidClass(String toolId, String toolExecutorId, Class<?> parentClass, Class<?> aClass,\n+                                   List<ToolExecutor.Source> sourceTypes,\n+                                   List<ToolExecutor.Framework> availableFrameworks) {\n+    if (!parentClass.isAssignableFrom(aClass)) {\n+      return false;\n     }\n-\n-    private <T> boolean isValidClass(String toolId, String toolExecutorId, Class<?> parentClass, Class<?> aClass,\n-                                     List<ToolExecutor.Source> sourceTypes,\n-                                     List<ToolExecutor.Framework> availableFrameworks) {\n-        if (!parentClass.isAssignableFrom(aClass)) {\n-            return false;\n-        }\n-        ToolExecutor annotation = aClass.getAnnotation(ToolExecutor.class);\n-        if (annotation == null) {\n-            return false;\n-        }\n-        if (!annotation.tool().equals(toolId)) {\n-            return false;\n-        }\n-        if (StringUtils.isNotEmpty(toolExecutorId) && !toolExecutorId.equals(annotation.id())) {\n-            return false;\n-        }\n-        if (CollectionUtils.isNotEmpty(sourceTypes) && !sourceTypes.contains(annotation.source())) {\n-            return false;\n-        }\n-        if (CollectionUtils.isNotEmpty(availableFrameworks) && !availableFrameworks.contains(annotation.framework())) {\n-            return false;\n-        }\n-        return true;\n+    ToolExecutor annotation = aClass.getAnnotation(ToolExecutor.class);\n+    if (annotation == null) {\n+      return false;\n     }\n+    if (!annotation.tool().equals(toolId)) {\n+      return false;\n+    }\n+    if (StringUtils.isNotEmpty(toolExecutorId) && !toolExecutorId.equals(annotation.id())) {\n+      return false;\n+    }\n+    if (CollectionUtils.isNotEmpty(sourceTypes) && !sourceTypes.contains(annotation.source())) {\n+      return false;\n+    }\n+    if (CollectionUtils.isNotEmpty(availableFrameworks) && !availableFrameworks.contains(annotation.framework())) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  public final <T extends OpenCgaToolExecutor> T getToolExecutor(String toolId, String toolExecutorId, Class<T> clazz,\n+                                                                 List<ToolExecutor.Source> sourceTypes,\n+                                                                 List<ToolExecutor.Framework> availableFrameworks)\n+      throws ToolExecutorException {\n+    Class<? extends T> executorClass = getToolExecutorClass(toolId, toolExecutorId, clazz, sourceTypes, availableFrameworks);\n+    if (executorClass == null) {\n+      throw ToolExecutorException.executorNotFound(clazz, toolId, toolExecutorId, sourceTypes, availableFrameworks);\n+    }\n+    try {\n+      T t = executorClass.newInstance();\n+      logger.info(\"Using \" + clazz.getName() + \" '\" + t.getId() + \"' : \" + executorClass);\n \n-    public final <T extends OpenCgaToolExecutor> T getToolExecutor(String toolId, String toolExecutorId, Class<T> clazz,\n-                                                                      List<ToolExecutor.Source> sourceTypes,\n-                                                                      List<ToolExecutor.Framework> availableFrameworks)\n-            throws ToolExecutorException {\n-        Class<? extends T> executorClass = getToolExecutorClass(toolId, toolExecutorId, clazz, sourceTypes, availableFrameworks);\n-        if (executorClass == null) {\n-            throw ToolExecutorException.executorNotFound(clazz, toolId, toolExecutorId, sourceTypes, availableFrameworks);\n-        }\n-        try {\n-            T t = executorClass.newInstance();\n-            logger.info(\"Using \" + clazz.getName() + \" '\" + t.getId() + \"' : \" + executorClass);\n-\n-            return t;\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            throw ToolExecutorException.cantInstantiate(executorClass, e);\n-        }\n+      return t;\n+    } catch (InstantiationException | IllegalAccessException e) {\n+      throw ToolExecutorException.cantInstantiate(executorClass, e);\n     }\n+  }\n \n }\n",
            "diff_size": 201
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "85",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 144).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                },
                {
                    "line": "88",
                    "column": "88",
                    "severity": "error",
                    "message": "'>' is followed by whitespace.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.GenericWhitespaceCheck"
                },
                {
                    "line": "129",
                    "severity": "error",
                    "message": "Line is longer than 140 characters (found 150).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/84/ToolExecutorFactory.java\nindex e52358e4303..4b6b513a595 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/naturalize/84/ToolExecutorFactory.java\n@@ -25,10 +25,8 @@ public class ToolExecutorFactory {\n         if (executorsCache == null) {\n             Reflections reflections = new Reflections(new ConfigurationBuilder()\n                     .setScanners(\n-                            new SubTypesScanner()\n-                            ,\n-                            new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, ToolExecutor.class.getName()))\n-                    )\n+                            new SubTypesScanner(),\n+                            new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, ToolExecutor.class.getName())))\n                     .addUrls(ClasspathHelper.forJavaClassPath())\n                     .filterInputsBy(input -> input != null && input.endsWith(\".class\"))\n             );\n@@ -84,12 +82,10 @@ public class ToolExecutorFactory {\n \n             // Prefer the executor that matches better with the source\n             // Prefer the executor that matches better with the framework\n-            List<ToolExecutor.Framework> finalAvailableFrameworks =\n-                    availableFrameworks == null ? Collections.emptyList() : availableFrameworks;\n-            List<ToolExecutor.Source> finalSourceTypes =\n-                    sourceTypes == null ? Collections.emptyList() : sourceTypes;\n+            List<ToolExecutor.Framework> finalAvailableFrameworks = availableFrameworks == null ? Collections.emptyList() : availableFrameworks;\n+            List<ToolExecutor.Source> finalSourceTypes = sourceTypes == null ? Collections.emptyList() : sourceTypes;\n \n-            Comparator<Class<? extends T>> comparator = Comparator.<Class<? extends T>>comparingInt(c1 -> {\n+            Comparator<Class<? extends T>> comparator = Comparator.<Class<? extends T>> comparingInt(c1 -> {\n                 ToolExecutor annot1 = c1.getAnnotation(ToolExecutor.class);\n                 return finalAvailableFrameworks.indexOf(annot1.framework());\n             }).thenComparingInt(c -> {\n@@ -106,7 +102,7 @@ public class ToolExecutorFactory {\n     private <T> boolean isValidClass(String toolId, String toolExecutorId, Class<?> parentClass, Class<?> aClass,\n                                      List<ToolExecutor.Source> sourceTypes,\n                                      List<ToolExecutor.Framework> availableFrameworks) {\n-        if (!parentClass.isAssignableFrom(aClass)) {\n+    if (!parentClass.isAssignableFrom(aClass)) {\n             return false;\n         }\n         ToolExecutor annotation = aClass.getAnnotation(ToolExecutor.class);\n@@ -130,8 +126,7 @@ public class ToolExecutorFactory {\n \n     public final <T extends OpenCgaToolExecutor> T getToolExecutor(String toolId, String toolExecutorId, Class<T> clazz,\n                                                                       List<ToolExecutor.Source> sourceTypes,\n-                                                                      List<ToolExecutor.Framework> availableFrameworks)\n-            throws ToolExecutorException {\n+                                                                      List<ToolExecutor.Framework> availableFrameworks) throws ToolExecutorException {\n         Class<? extends T> executorClass = getToolExecutorClass(toolId, toolExecutorId, clazz, sourceTypes, availableFrameworks);\n         if (executorClass == null) {\n             throw ToolExecutorException.executorNotFound(clazz, toolId, toolExecutorId, sourceTypes, availableFrameworks);\n@@ -146,4 +141,4 @@ public class ToolExecutorFactory {\n         }\n     }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 13
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/84/ToolExecutorFactory.java\nindex e52358e4303..37e60961b0c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_random/84/ToolExecutorFactory.java\n@@ -25,8 +25,7 @@ public class ToolExecutorFactory {\n         if (executorsCache == null) {\n             Reflections reflections = new Reflections(new ConfigurationBuilder()\n                     .setScanners(\n-                            new SubTypesScanner()\n-                            ,\n+                            new SubTypesScanner(),\n                             new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, ToolExecutor.class.getName()))\n                     )\n                     .addUrls(ClasspathHelper.forJavaClassPath())\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/84/ToolExecutorFactory.java\nindex e52358e4303..37e60961b0c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/errored/1/84/ToolExecutorFactory.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/opencb-opencga/styler_three_grams/84/ToolExecutorFactory.java\n@@ -25,8 +25,7 @@ public class ToolExecutorFactory {\n         if (executorsCache == null) {\n             Reflections reflections = new Reflections(new ConfigurationBuilder()\n                     .setScanners(\n-                            new SubTypesScanner()\n-                            ,\n+                            new SubTypesScanner(),\n                             new TypeAnnotationsScanner().filterResultsBy(s -> StringUtils.equals(s, ToolExecutor.class.getName()))\n                     )\n                     .addUrls(ClasspathHelper.forJavaClassPath())\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "styler",
        "styler_random",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff"
    ]
}