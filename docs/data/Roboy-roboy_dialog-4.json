{
    "project_name": "Roboy-roboy_dialog",
    "error_id": "4",
    "information": {
        "errors": [
            {
                "line": "47",
                "severity": "error",
                "message": "Line has trailing spaces.",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
            }
        ]
    },
    "source_code": "  public String isPruned(Derivation deriv) {\n    // atomic: Prune atomic formula at root.\n    //   e.g., Prevent \"Who was taller, Lincoln or Obama\" --> fb:en.lincoln generated from lexicon without any computation   \n    if (containsStrategy(atomic)) {\n      if (deriv.isRoot(ex.numTokens()) && deriv.formula instanceof ValueFormula)\n        return atomic;",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler/4/DefaultDerivationPruningComputer.java\nindex d47b5196a39..cc31fbce3c8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler/4/DefaultDerivationPruningComputer.java\n@@ -44,8 +44,8 @@ public class DefaultDerivationPruningComputer extends DerivationPruningComputer\n   @Override\n   public String isPruned(Derivation deriv) {\n     // atomic: Prune atomic formula at root.\n-    //   e.g., Prevent \"Who was taller, Lincoln or Obama\" --> fb:en.lincoln generated from lexicon without any computation   \n-    if (containsStrategy(atomic)) {\n+    //   e.g., Prevent \"Who was taller, Lincoln or Obama\" --> fb:en.lincoln generated from lexicon without any computation    if (containsStrategy(atomic)) {\n+      if (containsStrategy(atomic)) {\n       if (deriv.isRoot(ex.numTokens()) && deriv.formula instanceof ValueFormula)\n         return atomic;\n     }\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/intellij/4/DefaultDerivationPruningComputer.java\nindex d47b5196a39..c9da305302f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/intellij/4/DefaultDerivationPruningComputer.java\n@@ -11,151 +11,169 @@ import fig.basic.Option;\n  * @author ppasupat\n  */\n public class DefaultDerivationPruningComputer extends DerivationPruningComputer {\n-  public static class Options {\n-    @Option(gloss = \"(for badSummarizerHead) allow count on sets of size 1\")\n-    public boolean allowCountOne = false;\n-  }\n-  public static Options opts = new Options();\n+    public static class Options {\n+        @Option(gloss = \"(for badSummarizerHead) allow count on sets of size 1\")\n+        public boolean allowCountOne = false;\n+    }\n \n-  public DefaultDerivationPruningComputer(DerivationPruner pruner) {\n-    super(pruner);\n-  }\n+    public static Options opts = new Options();\n \n-  public static final String atomic = \"atomic\";\n-  public static final String emptyDenotation = \"emptyDenotation\";\n-  public static final String nonLambdaError = \"nonLambdaError\";\n-  public static final String tooManyValues = \"tooManyValues\";\n-  public static final String doubleSummarizers = \"doubleSummarizers\";\n-  public static final String multipleSuperlatives = \"multipleSuperlatives\";\n-  public static final String sameMerge = \"sameMerge\";\n-  public static final String mistypedMerge = \"mistypedMerge\";\n-  public static final String unsortedMerge = \"unsortedMerge\";\n-  public static final String badSummarizerHead = \"badSummarizerHead\";\n+    public DefaultDerivationPruningComputer(DerivationPruner pruner) {\n+        super(pruner);\n+    }\n \n-  @Override\n-  public Collection<String> getAllStrategyNames() {\n-    return Arrays.asList(\n-        atomic,\n-        emptyDenotation, nonLambdaError, tooManyValues,\n-        doubleSummarizers, multipleSuperlatives,\n-        sameMerge, mistypedMerge, unsortedMerge, badSummarizerHead);\n-  }\n+    public static final String atomic = \"atomic\";\n+    public static final String emptyDenotation = \"emptyDenotation\";\n+    public static final String nonLambdaError = \"nonLambdaError\";\n+    public static final String tooManyValues = \"tooManyValues\";\n+    public static final String doubleSummarizers = \"doubleSummarizers\";\n+    public static final String multipleSuperlatives = \"multipleSuperlatives\";\n+    public static final String sameMerge = \"sameMerge\";\n+    public static final String mistypedMerge = \"mistypedMerge\";\n+    public static final String unsortedMerge = \"unsortedMerge\";\n+    public static final String badSummarizerHead = \"badSummarizerHead\";\n \n-  @Override\n-  public String isPruned(Derivation deriv) {\n-    // atomic: Prune atomic formula at root.\n-    //   e.g., Prevent \"Who was taller, Lincoln or Obama\" --> fb:en.lincoln generated from lexicon without any computation   \n-    if (containsStrategy(atomic)) {\n-      if (deriv.isRoot(ex.numTokens()) && deriv.formula instanceof ValueFormula)\n-        return atomic;\n-    }\n-    // emptyDenotation: Prune if the denotation is empty\n-    if (containsStrategy(emptyDenotation)) {\n-      deriv.ensureExecuted(parser.executor, ex.context);\n-      if (deriv.value instanceof ListValue && ((ListValue) deriv.value).values.isEmpty())\n-        return emptyDenotation;\n-    }\n-    // nonLambdaError: Prune if the denotation is an error and the formula is not a partial formula\n-    if (containsStrategy(nonLambdaError) && !isLambdaFormula(deriv.formula)) {\n-      deriv.ensureExecuted(parser.executor, ex.context);\n-      if (deriv.value instanceof ErrorValue)\n-        return nonLambdaError;\n-    }\n-    // tooManyValues: Prune if the denotation has too many values (at $ROOT only)\n-    if (containsStrategy(tooManyValues) && deriv.isRoot(ex.numTokens())) {\n-      if (!(deriv.value instanceof ListValue) ||\n-          ((ListValue) deriv.value).values.size() > DerivationPruner.opts.maxNumValues)\n-        return tooManyValues;\n-    }\n-    // doubleSummarizers: Prune when two summarizers (aggregate or superlative) are directly nested\n-    // e.g., in (sum (avg ...)) and (min (argmax ...)), the outer operation is redundant\n-    if (containsStrategy(doubleSummarizers)) {\n-      Formula innerFormula = null;\n-      if (deriv.formula instanceof SuperlativeFormula)\n-        innerFormula = ((SuperlativeFormula) deriv.formula).head;\n-      else if (deriv.formula instanceof AggregateFormula)\n-        innerFormula = ((AggregateFormula) deriv.formula).child;\n-      if (innerFormula != null &&\n-          (innerFormula instanceof SuperlativeFormula || innerFormula instanceof AggregateFormula))\n-        return doubleSummarizers;\n+    @Override\n+    public Collection<String> getAllStrategyNames() {\n+        return Arrays.asList(\n+            atomic,\n+            emptyDenotation, nonLambdaError, tooManyValues,\n+            doubleSummarizers, multipleSuperlatives,\n+            sameMerge, mistypedMerge, unsortedMerge, badSummarizerHead);\n     }\n-    // multipleSuperlatives: Prune when more than one superlatives are used\n-    // (don't need to be adjacent)\n-    if (containsStrategy(multipleSuperlatives)) {\n-      List<LispTree> stack = new ArrayList<>();\n-      int count = 0;\n-      stack.add(deriv.formula.toLispTree());\n-      while (!stack.isEmpty()) {\n-        LispTree tree = stack.remove(stack.size() - 1);\n-        if (tree.isLeaf()) {\n-          if (\"argmax\".equals(tree.value) || \"argmin\".equals(tree.value)) {\n-            count++;\n-            if (count >= 2)\n-              return multipleSuperlatives;\n-          }\n-        } else {\n-          for (LispTree subtree : tree.children)\n-            stack.add(subtree);\n+\n+    @Override\n+    public String isPruned(Derivation deriv) {\n+        // atomic: Prune atomic formula at root.\n+        //   e.g., Prevent \"Who was taller, Lincoln or Obama\" --> fb:en.lincoln generated from lexicon without any computation\n+        if (containsStrategy(atomic)) {\n+            if (deriv.isRoot(ex.numTokens()) && deriv.formula instanceof ValueFormula) {\n+                return atomic;\n+            }\n         }\n-      }\n-    }\n-    // sameMerge: Prune merge formulas with two identical children\n-    if (containsStrategy(sameMerge) && deriv.formula instanceof MergeFormula) {\n-      MergeFormula merge = (MergeFormula) deriv.formula;\n-      if (merge.child1.equals(merge.child2))\n-        return sameMerge;\n-    }\n-    // mistypedMerge: Prune merge formulas with children of different types\n-    if (containsStrategy(mistypedMerge) && deriv.formula instanceof MergeFormula) {\n-      MergeFormula merge = (MergeFormula) deriv.formula;\n-      SemType type1 = TypeInference.inferType(merge.child1, true);\n-      SemType type2 = TypeInference.inferType(merge.child2, true);\n-      if (!type1.meet(type2).isValid())\n-        return mistypedMerge;\n-    }\n-    // unsortedMerge: Prune merge formulas where the children's string forms are not lexicographically sorted.\n-    //   Will remove redundant (and Y X) when (and Y X) is already present.\n-    if (containsStrategy(unsortedMerge) && deriv.formula instanceof MergeFormula) {\n-      MergeFormula merge = (MergeFormula) deriv.formula;\n-      String child1 = merge.child1.toString(), child2 = merge.child2.toString();\n-      if (child1.compareTo(child2) >= 0)\n-        return unsortedMerge;\n-    }\n-    // badSummarizerHead: Prune if the head of a superlative or a non-count aggregate\n-    // is empty or is a single object\n-    if (containsStrategy(badSummarizerHead)) {\n-      Formula innerFormula = null;\n-      boolean isCount = false;\n-      if (deriv.formula instanceof SuperlativeFormula)\n-        innerFormula = ((SuperlativeFormula) deriv.formula).head;\n-      else if (deriv.formula instanceof AggregateFormula) {\n-        innerFormula = ((AggregateFormula) deriv.formula).child;\n-        if (((AggregateFormula) deriv.formula).mode == AggregateFormula.Mode.count)\n-          isCount = true;\n-      }\n-      if (innerFormula != null) {\n-        try {\n-          TypeInference.inferType(innerFormula);\n-          Value innerValue = parser.executor.execute(innerFormula, ex.context).value;\n-          if (innerValue instanceof ListValue) {\n-            int size = ((ListValue) innerValue).values.size();\n-            if (size == 0 || (size == 1 && !(opts.allowCountOne && isCount)))\n-              return badSummarizerHead;\n-          }\n-        } catch (Exception e) {\n-          // TypeInference fails; probably because of free variables. No need to do anything.\n+        // emptyDenotation: Prune if the denotation is empty\n+        if (containsStrategy(emptyDenotation)) {\n+            deriv.ensureExecuted(parser.executor, ex.context);\n+            if (deriv.value instanceof ListValue && ((ListValue) deriv.value).values.isEmpty()) {\n+                return emptyDenotation;\n+            }\n         }\n-      }\n+        // nonLambdaError: Prune if the denotation is an error and the formula is not a partial formula\n+        if (containsStrategy(nonLambdaError) && !isLambdaFormula(deriv.formula)) {\n+            deriv.ensureExecuted(parser.executor, ex.context);\n+            if (deriv.value instanceof ErrorValue) {\n+                return nonLambdaError;\n+            }\n+        }\n+        // tooManyValues: Prune if the denotation has too many values (at $ROOT only)\n+        if (containsStrategy(tooManyValues) && deriv.isRoot(ex.numTokens())) {\n+            if (!(deriv.value instanceof ListValue) ||\n+                ((ListValue) deriv.value).values.size() > DerivationPruner.opts.maxNumValues) {\n+                return tooManyValues;\n+            }\n+        }\n+        // doubleSummarizers: Prune when two summarizers (aggregate or superlative) are directly nested\n+        // e.g., in (sum (avg ...)) and (min (argmax ...)), the outer operation is redundant\n+        if (containsStrategy(doubleSummarizers)) {\n+            Formula innerFormula = null;\n+            if (deriv.formula instanceof SuperlativeFormula) {\n+                innerFormula = ((SuperlativeFormula) deriv.formula).head;\n+            } else if (deriv.formula instanceof AggregateFormula) {\n+                innerFormula = ((AggregateFormula) deriv.formula).child;\n+            }\n+            if (innerFormula != null &&\n+                (innerFormula instanceof SuperlativeFormula || innerFormula instanceof AggregateFormula)) {\n+                return doubleSummarizers;\n+            }\n+        }\n+        // multipleSuperlatives: Prune when more than one superlatives are used\n+        // (don't need to be adjacent)\n+        if (containsStrategy(multipleSuperlatives)) {\n+            List<LispTree> stack = new ArrayList<>();\n+            int count = 0;\n+            stack.add(deriv.formula.toLispTree());\n+            while (!stack.isEmpty()) {\n+                LispTree tree = stack.remove(stack.size() - 1);\n+                if (tree.isLeaf()) {\n+                    if (\"argmax\".equals(tree.value) || \"argmin\".equals(tree.value)) {\n+                        count++;\n+                        if (count >= 2) {\n+                            return multipleSuperlatives;\n+                        }\n+                    }\n+                } else {\n+                    for (LispTree subtree : tree.children) {\n+                        stack.add(subtree);\n+                    }\n+                }\n+            }\n+        }\n+        // sameMerge: Prune merge formulas with two identical children\n+        if (containsStrategy(sameMerge) && deriv.formula instanceof MergeFormula) {\n+            MergeFormula merge = (MergeFormula) deriv.formula;\n+            if (merge.child1.equals(merge.child2)) {\n+                return sameMerge;\n+            }\n+        }\n+        // mistypedMerge: Prune merge formulas with children of different types\n+        if (containsStrategy(mistypedMerge) && deriv.formula instanceof MergeFormula) {\n+            MergeFormula merge = (MergeFormula) deriv.formula;\n+            SemType type1 = TypeInference.inferType(merge.child1, true);\n+            SemType type2 = TypeInference.inferType(merge.child2, true);\n+            if (!type1.meet(type2).isValid()) {\n+                return mistypedMerge;\n+            }\n+        }\n+        // unsortedMerge: Prune merge formulas where the children's string forms are not lexicographically sorted.\n+        //   Will remove redundant (and Y X) when (and Y X) is already present.\n+        if (containsStrategy(unsortedMerge) && deriv.formula instanceof MergeFormula) {\n+            MergeFormula merge = (MergeFormula) deriv.formula;\n+            String child1 = merge.child1.toString(), child2 = merge.child2.toString();\n+            if (child1.compareTo(child2) >= 0) {\n+                return unsortedMerge;\n+            }\n+        }\n+        // badSummarizerHead: Prune if the head of a superlative or a non-count aggregate\n+        // is empty or is a single object\n+        if (containsStrategy(badSummarizerHead)) {\n+            Formula innerFormula = null;\n+            boolean isCount = false;\n+            if (deriv.formula instanceof SuperlativeFormula) {\n+                innerFormula = ((SuperlativeFormula) deriv.formula).head;\n+            } else if (deriv.formula instanceof AggregateFormula) {\n+                innerFormula = ((AggregateFormula) deriv.formula).child;\n+                if (((AggregateFormula) deriv.formula).mode == AggregateFormula.Mode.count) {\n+                    isCount = true;\n+                }\n+            }\n+            if (innerFormula != null) {\n+                try {\n+                    TypeInference.inferType(innerFormula);\n+                    Value innerValue = parser.executor.execute(innerFormula, ex.context).value;\n+                    if (innerValue instanceof ListValue) {\n+                        int size = ((ListValue) innerValue).values.size();\n+                        if (size == 0 || (size == 1 && !(opts.allowCountOne && isCount))) {\n+                            return badSummarizerHead;\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    // TypeInference fails; probably because of free variables. No need to do anything.\n+                }\n+            }\n+        }\n+        return null;\n     }\n-    return null;\n-  }\n \n-  // Helper function: return true if the result is clearly a binary\n-  private boolean isLambdaFormula(Formula formula) {\n-    if (formula instanceof LambdaFormula) return true;\n-    if (formula instanceof ValueFormula &&\n-        CanonicalNames.isBinary(((ValueFormula<?>) formula).value)) return true;\n-    return false;\n-  }\n+    // Helper function: return true if the result is clearly a binary\n+    private boolean isLambdaFormula(Formula formula) {\n+        if (formula instanceof LambdaFormula) {\n+            return true;\n+        }\n+        if (formula instanceof ValueFormula &&\n+            CanonicalNames.isBinary(((ValueFormula<?>) formula).value)) {\n+            return true;\n+        }\n+        return false;\n+    }\n \n }\n",
            "diff_size": 246
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "47",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/naturalize/4/DefaultDerivationPruningComputer.java\nindex d47b5196a39..28f3ae1b68c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/naturalize/4/DefaultDerivationPruningComputer.java\n@@ -158,4 +158,4 @@ public class DefaultDerivationPruningComputer extends DerivationPruningComputer\n     return false;\n   }\n \n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 1
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "53",
                    "severity": "error",
                    "message": "Line has trailing spaces.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/codebuff/4/DefaultDerivationPruningComputer.java\nindex d47b5196a39..bb9488e22ac 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/codebuff/4/DefaultDerivationPruningComputer.java\n@@ -1,7 +1,6 @@\n package edu.stanford.nlp.sempre;\n \n import java.util.*;\n-\n import fig.basic.LispTree;\n import fig.basic.Option;\n \n@@ -10,11 +9,14 @@ import fig.basic.Option;\n  *\n  * @author ppasupat\n  */\n+\n+\n public class DefaultDerivationPruningComputer extends DerivationPruningComputer {\n   public static class Options {\n     @Option(gloss = \"(for badSummarizerHead) allow count on sets of size 1\")\n     public boolean allowCountOne = false;\n   }\n+\n   public static Options opts = new Options();\n \n   public DefaultDerivationPruningComputer(DerivationPruner pruner) {\n@@ -22,23 +24,27 @@ public class DefaultDerivationPruningComputer extends DerivationPruningComputer\n   }\n \n   public static final String atomic = \"atomic\";\n+\n   public static final String emptyDenotation = \"emptyDenotation\";\n+\n   public static final String nonLambdaError = \"nonLambdaError\";\n+\n   public static final String tooManyValues = \"tooManyValues\";\n+\n   public static final String doubleSummarizers = \"doubleSummarizers\";\n+\n   public static final String multipleSuperlatives = \"multipleSuperlatives\";\n+\n   public static final String sameMerge = \"sameMerge\";\n+\n   public static final String mistypedMerge = \"mistypedMerge\";\n+\n   public static final String unsortedMerge = \"unsortedMerge\";\n-  public static final String badSummarizerHead = \"badSummarizerHead\";\n \n+  public static final String badSummarizerHead = \"badSummarizerHead\";\n   @Override\n   public Collection<String> getAllStrategyNames() {\n-    return Arrays.asList(\n-        atomic,\n-        emptyDenotation, nonLambdaError, tooManyValues,\n-        doubleSummarizers, multipleSuperlatives,\n-        sameMerge, mistypedMerge, unsortedMerge, badSummarizerHead);\n+    return Arrays.asList(atomic, emptyDenotation, nonLambdaError, tooManyValues, doubleSummarizers, multipleSuperlatives, sameMerge, mistypedMerge, unsortedMerge, badSummarizerHead);\n   }\n \n   @Override\n@@ -50,37 +56,40 @@ public class DefaultDerivationPruningComputer extends DerivationPruningComputer\n         return atomic;\n     }\n     // emptyDenotation: Prune if the denotation is empty\n+\n     if (containsStrategy(emptyDenotation)) {\n       deriv.ensureExecuted(parser.executor, ex.context);\n       if (deriv.value instanceof ListValue && ((ListValue) deriv.value).values.isEmpty())\n         return emptyDenotation;\n     }\n     // nonLambdaError: Prune if the denotation is an error and the formula is not a partial formula\n+\n     if (containsStrategy(nonLambdaError) && !isLambdaFormula(deriv.formula)) {\n       deriv.ensureExecuted(parser.executor, ex.context);\n       if (deriv.value instanceof ErrorValue)\n         return nonLambdaError;\n     }\n     // tooManyValues: Prune if the denotation has too many values (at $ROOT only)\n+\n     if (containsStrategy(tooManyValues) && deriv.isRoot(ex.numTokens())) {\n-      if (!(deriv.value instanceof ListValue) ||\n-          ((ListValue) deriv.value).values.size() > DerivationPruner.opts.maxNumValues)\n+      if (!(deriv.value instanceof ListValue) || ((ListValue) deriv.value).values.size() > DerivationPruner.opts.maxNumValues)\n         return tooManyValues;\n     }\n     // doubleSummarizers: Prune when two summarizers (aggregate or superlative) are directly nested\n     // e.g., in (sum (avg ...)) and (min (argmax ...)), the outer operation is redundant\n+\n     if (containsStrategy(doubleSummarizers)) {\n       Formula innerFormula = null;\n       if (deriv.formula instanceof SuperlativeFormula)\n         innerFormula = ((SuperlativeFormula) deriv.formula).head;\n       else if (deriv.formula instanceof AggregateFormula)\n         innerFormula = ((AggregateFormula) deriv.formula).child;\n-      if (innerFormula != null &&\n-          (innerFormula instanceof SuperlativeFormula || innerFormula instanceof AggregateFormula))\n+      if (innerFormula != null && (innerFormula instanceof SuperlativeFormula || innerFormula instanceof AggregateFormula))\n         return doubleSummarizers;\n     }\n     // multipleSuperlatives: Prune when more than one superlatives are used\n     // (don't need to be adjacent)\n+\n     if (containsStrategy(multipleSuperlatives)) {\n       List<LispTree> stack = new ArrayList<>();\n       int count = 0;\n@@ -100,12 +109,14 @@ public class DefaultDerivationPruningComputer extends DerivationPruningComputer\n       }\n     }\n     // sameMerge: Prune merge formulas with two identical children\n+\n     if (containsStrategy(sameMerge) && deriv.formula instanceof MergeFormula) {\n       MergeFormula merge = (MergeFormula) deriv.formula;\n       if (merge.child1.equals(merge.child2))\n         return sameMerge;\n     }\n     // mistypedMerge: Prune merge formulas with children of different types\n+\n     if (containsStrategy(mistypedMerge) && deriv.formula instanceof MergeFormula) {\n       MergeFormula merge = (MergeFormula) deriv.formula;\n       SemType type1 = TypeInference.inferType(merge.child1, true);\n@@ -115,6 +126,7 @@ public class DefaultDerivationPruningComputer extends DerivationPruningComputer\n     }\n     // unsortedMerge: Prune merge formulas where the children's string forms are not lexicographically sorted.\n     //   Will remove redundant (and Y X) when (and Y X) is already present.\n+\n     if (containsStrategy(unsortedMerge) && deriv.formula instanceof MergeFormula) {\n       MergeFormula merge = (MergeFormula) deriv.formula;\n       String child1 = merge.child1.toString(), child2 = merge.child2.toString();\n@@ -123,19 +135,22 @@ public class DefaultDerivationPruningComputer extends DerivationPruningComputer\n     }\n     // badSummarizerHead: Prune if the head of a superlative or a non-count aggregate\n     // is empty or is a single object\n+\n     if (containsStrategy(badSummarizerHead)) {\n       Formula innerFormula = null;\n       boolean isCount = false;\n       if (deriv.formula instanceof SuperlativeFormula)\n         innerFormula = ((SuperlativeFormula) deriv.formula).head;\n       else if (deriv.formula instanceof AggregateFormula) {\n-        innerFormula = ((AggregateFormula) deriv.formula).child;\n-        if (((AggregateFormula) deriv.formula).mode == AggregateFormula.Mode.count)\n-          isCount = true;\n+      innerFormula = ((AggregateFormula) deriv.formula).child;\n+      if (((AggregateFormula) deriv.formula).mode == AggregateFormula.Mode.count)\n+        isCount = true;\n       }\n+\n       if (innerFormula != null) {\n         try {\n           TypeInference.inferType(innerFormula);\n+\n           Value innerValue = parser.executor.execute(innerFormula, ex.context).value;\n           if (innerValue instanceof ListValue) {\n             int size = ((ListValue) innerValue).values.size();\n@@ -151,11 +166,12 @@ public class DefaultDerivationPruningComputer extends DerivationPruningComputer\n   }\n \n   // Helper function: return true if the result is clearly a binary\n+\n   private boolean isLambdaFormula(Formula formula) {\n-    if (formula instanceof LambdaFormula) return true;\n-    if (formula instanceof ValueFormula &&\n-        CanonicalNames.isBinary(((ValueFormula<?>) formula).value)) return true;\n+    if (formula instanceof LambdaFormula)\n+      return true;\n+    if (formula instanceof ValueFormula && CanonicalNames.isBinary(((ValueFormula<?>) formula).value))\n+      return true;\n     return false;\n   }\n-\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 44
        },
        {
            "tool": "styler_random",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler_random/4/DefaultDerivationPruningComputer.java\nindex d47b5196a39..cc31fbce3c8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/errored/1/4/DefaultDerivationPruningComputer.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/Roboy-roboy_dialog/styler_random/4/DefaultDerivationPruningComputer.java\n@@ -44,8 +44,8 @@ public class DefaultDerivationPruningComputer extends DerivationPruningComputer\n   @Override\n   public String isPruned(Derivation deriv) {\n     // atomic: Prune atomic formula at root.\n-    //   e.g., Prevent \"Who was taller, Lincoln or Obama\" --> fb:en.lincoln generated from lexicon without any computation   \n-    if (containsStrategy(atomic)) {\n+    //   e.g., Prevent \"Who was taller, Lincoln or Obama\" --> fb:en.lincoln generated from lexicon without any computation    if (containsStrategy(atomic)) {\n+      if (containsStrategy(atomic)) {\n       if (deriv.isRoot(ex.numTokens()) && deriv.formula instanceof ValueFormula)\n         return atomic;\n     }\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": null,
            "diff": null
        }
    ],
    "repaired_by": [
        "styler",
        "intellij",
        "styler_random"
    ],
    "not_repaired_by": [
        "naturalize",
        "codebuff",
        "styler_three_grams"
    ]
}