{
    "project_name": "codefollower-H2-Research",
    "error_id": "235",
    "information": {
        "errors": [
            {
                "line": "927",
                "column": "19",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "        }\n        case ARRAY:\n        case ROW: // Special storage type for ValueRow\n        {\n            int len = readVarInt();\n            Value[] list = new Value[len];",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/235/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/235/Data.java\nindex bd50ecf0d5c..d261228165a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/235/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler/235/Data.java\n@@ -924,8 +924,9 @@ public class Data {\n             }\n         }\n         case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n-        {\n+        case ROW:\n+        // Special storage type for ValueRow\n+{\n             int len = readVarInt();\n             Value[] list = new Value[len];\n             for (int i = 0; i < len; i++) {\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "926",
                    "column": "17",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/235/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/235/Data.java\nindex bd50ecf0d5c..bf1d546fcfe 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/235/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/intellij/235/Data.java\n@@ -6,6 +6,7 @@\n  * The variable size number format code is a port from SQLite,\n  * but stored in reverse order (least significant bits in the first byte).\n  */\n+\n package org.h2.store;\n \n import java.io.IOException;\n@@ -67,1409 +68,1406 @@ import org.h2.value.ValueUuid;\n  */\n public class Data {\n \n-    /**\n-     * The length of an integer value.\n-     */\n-    public static final int LENGTH_INT = 4;\n+  /**\n+   * The length of an integer value.\n+   */\n+  public static final int LENGTH_INT = 4;\n \n-    /**\n-     * The length of a long value.\n-     */\n-    public static final int LENGTH_LONG = 8;\n+  /**\n+   * The length of a long value.\n+   */\n+  public static final int LENGTH_LONG = 8;\n \n-    private static final byte NULL = 0;\n-    private static final byte BYTE = 2;\n-    private static final byte SHORT = 3;\n-    private static final byte INT = 4;\n-    private static final byte LONG = 5;\n-    private static final byte DECIMAL = 6;\n-    private static final byte DOUBLE = 7;\n-    private static final byte FLOAT = 8;\n-    private static final byte TIME = 9;\n-    private static final byte DATE = 10;\n-    private static final byte TIMESTAMP = 11;\n-    private static final byte BYTES = 12;\n-    private static final byte STRING = 13;\n-    private static final byte STRING_IGNORECASE = 14;\n-    private static final byte BLOB = 15;\n-    private static final byte CLOB = 16;\n-    private static final byte ARRAY = 17;\n-    private static final byte RESULT_SET = 18;\n-    private static final byte JAVA_OBJECT = 19;\n-    private static final byte UUID = 20;\n-    private static final byte STRING_FIXED = 21;\n-    private static final byte GEOMETRY = 22;\n-    private static final byte TIMESTAMP_TZ = 24;\n-    private static final byte ENUM = 25;\n-    private static final byte INTERVAL = 26;\n-    private static final byte ROW = 27;\n-    private static final byte INT_0_15 = 32;\n-    private static final byte LONG_0_7 = 48;\n-    private static final byte DECIMAL_0_1 = 56;\n-    private static final byte DECIMAL_SMALL_0 = 58;\n-    private static final byte DECIMAL_SMALL = 59;\n-    private static final byte DOUBLE_0_1 = 60;\n-    private static final byte FLOAT_0_1 = 62;\n-    private static final byte BOOLEAN_FALSE = 64;\n-    private static final byte BOOLEAN_TRUE = 65;\n-    private static final byte INT_NEG = 66;\n-    private static final byte LONG_NEG = 67;\n-    private static final byte STRING_0_31 = 68;\n-    private static final int BYTES_0_31 = 100;\n-    private static final int LOCAL_TIME = 132;\n-    private static final int LOCAL_DATE = 133;\n-    private static final int LOCAL_TIMESTAMP = 134;\n-    private static final int CUSTOM_DATA_TYPE = 135;\n-    private static final int JSON = 136;\n+  private static final byte NULL = 0;\n+  private static final byte BYTE = 2;\n+  private static final byte SHORT = 3;\n+  private static final byte INT = 4;\n+  private static final byte LONG = 5;\n+  private static final byte DECIMAL = 6;\n+  private static final byte DOUBLE = 7;\n+  private static final byte FLOAT = 8;\n+  private static final byte TIME = 9;\n+  private static final byte DATE = 10;\n+  private static final byte TIMESTAMP = 11;\n+  private static final byte BYTES = 12;\n+  private static final byte STRING = 13;\n+  private static final byte STRING_IGNORECASE = 14;\n+  private static final byte BLOB = 15;\n+  private static final byte CLOB = 16;\n+  private static final byte ARRAY = 17;\n+  private static final byte RESULT_SET = 18;\n+  private static final byte JAVA_OBJECT = 19;\n+  private static final byte UUID = 20;\n+  private static final byte STRING_FIXED = 21;\n+  private static final byte GEOMETRY = 22;\n+  private static final byte TIMESTAMP_TZ = 24;\n+  private static final byte ENUM = 25;\n+  private static final byte INTERVAL = 26;\n+  private static final byte ROW = 27;\n+  private static final byte INT_0_15 = 32;\n+  private static final byte LONG_0_7 = 48;\n+  private static final byte DECIMAL_0_1 = 56;\n+  private static final byte DECIMAL_SMALL_0 = 58;\n+  private static final byte DECIMAL_SMALL = 59;\n+  private static final byte DOUBLE_0_1 = 60;\n+  private static final byte FLOAT_0_1 = 62;\n+  private static final byte BOOLEAN_FALSE = 64;\n+  private static final byte BOOLEAN_TRUE = 65;\n+  private static final byte INT_NEG = 66;\n+  private static final byte LONG_NEG = 67;\n+  private static final byte STRING_0_31 = 68;\n+  private static final int BYTES_0_31 = 100;\n+  private static final int LOCAL_TIME = 132;\n+  private static final int LOCAL_DATE = 133;\n+  private static final int LOCAL_TIMESTAMP = 134;\n+  private static final int CUSTOM_DATA_TYPE = 135;\n+  private static final int JSON = 136;\n \n-    private static final long MILLIS_PER_MINUTE = 1000 * 60;\n+  private static final long MILLIS_PER_MINUTE = 1000 * 60;\n \n-    /**\n-     * The data itself.\n-     */\n-    private byte[] data;\n+  /**\n+   * The data itself.\n+   */\n+  private byte[] data;\n \n-    /**\n-     * The current write or read position.\n-     */\n-    private int pos;\n+  /**\n+   * The current write or read position.\n+   */\n+  private int pos;\n \n-    /**\n-     * The data handler responsible for lob objects.\n-     */\n-    private final DataHandler handler;\n+  /**\n+   * The data handler responsible for lob objects.\n+   */\n+  private final DataHandler handler;\n \n-    private final boolean storeLocalTime;\n+  private final boolean storeLocalTime;\n \n-    private Data(DataHandler handler, byte[] data, boolean storeLocalTime) {\n-        this.handler = handler;\n-        this.data = data;\n-        this.storeLocalTime = storeLocalTime;\n-    }\n+  private Data(DataHandler handler, byte[] data, boolean storeLocalTime) {\n+    this.handler = handler;\n+    this.data = data;\n+    this.storeLocalTime = storeLocalTime;\n+  }\n \n-    /**\n-     * Update an integer at the given position.\n-     * The current position is not change.\n-     *\n-     * @param pos the position\n-     * @param x the value\n-     */\n-    public void setInt(int pos, int x) {\n-        Bits.writeInt(data, pos, x);\n-    }\n+  /**\n+   * Update an integer at the given position.\n+   * The current position is not change.\n+   *\n+   * @param pos the position\n+   * @param x   the value\n+   */\n+  public void setInt(int pos, int x) {\n+    Bits.writeInt(data, pos, x);\n+  }\n \n-    /**\n-     * Write an integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @param x the value\n-     */\n-    public void writeInt(int x) {\n-        Bits.writeInt(data, pos, x);\n-        pos += 4;\n-    }\n+  /**\n+   * Write an integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @param x the value\n+   */\n+  public void writeInt(int x) {\n+    Bits.writeInt(data, pos, x);\n+    pos += 4;\n+  }\n \n-    /**\n-     * Read an integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @return the value\n-     */\n-    public int readInt() {\n-        int x = Bits.readInt(data, pos);\n-        pos += 4;\n-        return x;\n-    }\n+  /**\n+   * Read an integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @return the value\n+   */\n+  public int readInt() {\n+    int x = Bits.readInt(data, pos);\n+    pos += 4;\n+    return x;\n+  }\n \n-    /**\n-     * Get the length of a String. This includes the bytes required to encode\n-     * the length.\n-     *\n-     * @param s the string\n-     * @return the number of bytes required\n-     */\n-    public static int getStringLen(String s) {\n-        int len = s.length();\n-        return getStringWithoutLengthLen(s, len) + getVarIntLen(len);\n-    }\n+  /**\n+   * Get the length of a String. This includes the bytes required to encode\n+   * the length.\n+   *\n+   * @param s the string\n+   * @return the number of bytes required\n+   */\n+  public static int getStringLen(String s) {\n+    int len = s.length();\n+    return getStringWithoutLengthLen(s, len) + getVarIntLen(len);\n+  }\n \n-    /**\n-     * Calculate the length of String, excluding the bytes required to encode\n-     * the length.\n-     * <p>\n-     * For performance reasons the internal representation of a String is\n-     * similar to UTF-8, but not exactly UTF-8.\n-     *\n-     * @param s the string\n-     * @param len the length of the string\n-     * @return the number of bytes required\n-     */\n-    private static int getStringWithoutLengthLen(String s, int len) {\n-        int plus = 0;\n-        for (int i = 0; i < len; i++) {\n-            char c = s.charAt(i);\n-            if (c >= 0x800) {\n-                plus += 2;\n-            } else if (c >= 0x80) {\n-                plus++;\n-            }\n-        }\n-        return len + plus;\n+  /**\n+   * Calculate the length of String, excluding the bytes required to encode\n+   * the length.\n+   * <p>\n+   * For performance reasons the internal representation of a String is\n+   * similar to UTF-8, but not exactly UTF-8.\n+   *\n+   * @param s   the string\n+   * @param len the length of the string\n+   * @return the number of bytes required\n+   */\n+  private static int getStringWithoutLengthLen(String s, int len) {\n+    int plus = 0;\n+    for (int i = 0; i < len; i++) {\n+      char c = s.charAt(i);\n+      if (c >= 0x800) {\n+        plus += 2;\n+      } else if (c >= 0x80) {\n+        plus++;\n+      }\n     }\n+    return len + plus;\n+  }\n \n-    /**\n-     * Read a String value.\n-     * The current position is incremented.\n-     *\n-     * @return the value\n-     */\n-    public String readString() {\n-        int len = readVarInt();\n-        return readString(len);\n-    }\n+  /**\n+   * Read a String value.\n+   * The current position is incremented.\n+   *\n+   * @return the value\n+   */\n+  public String readString() {\n+    int len = readVarInt();\n+    return readString(len);\n+  }\n \n-    /**\n-     * Read a String from the byte array.\n-     * <p>\n-     * For performance reasons the internal representation of a String is\n-     * similar to UTF-8, but not exactly UTF-8.\n-     *\n-     * @param len the length of the resulting string\n-     * @return the String\n-     */\n-    private String readString(int len) {\n-        byte[] buff = data;\n-        int p = pos;\n-        char[] chars = new char[len];\n-        for (int i = 0; i < len; i++) {\n-            int x = buff[p++] & 0xff;\n-            if (x < 0x80) {\n-                chars[i] = (char) x;\n-            } else if (x >= 0xe0) {\n-                chars[i] = (char) (((x & 0xf) << 12) +\n-                        ((buff[p++] & 0x3f) << 6) +\n-                        (buff[p++] & 0x3f));\n-            } else {\n-                chars[i] = (char) (((x & 0x1f) << 6) +\n-                        (buff[p++] & 0x3f));\n-            }\n-        }\n-        pos = p;\n-        return new String(chars);\n+  /**\n+   * Read a String from the byte array.\n+   * <p>\n+   * For performance reasons the internal representation of a String is\n+   * similar to UTF-8, but not exactly UTF-8.\n+   *\n+   * @param len the length of the resulting string\n+   * @return the String\n+   */\n+  private String readString(int len) {\n+    byte[] buff = data;\n+    int p = pos;\n+    char[] chars = new char[len];\n+    for (int i = 0; i < len; i++) {\n+      int x = buff[p++] & 0xff;\n+      if (x < 0x80) {\n+        chars[i] = (char) x;\n+      } else if (x >= 0xe0) {\n+        chars[i] = (char) (((x & 0xf) << 12) +\n+            ((buff[p++] & 0x3f) << 6) +\n+            (buff[p++] & 0x3f));\n+      } else {\n+        chars[i] = (char) (((x & 0x1f) << 6) +\n+            (buff[p++] & 0x3f));\n+      }\n     }\n+    pos = p;\n+    return new String(chars);\n+  }\n \n-    /**\n-     * Write a String.\n-     * The current position is incremented.\n-     *\n-     * @param s the value\n-     */\n-    public void writeString(String s) {\n-        int len = s.length();\n-        writeVarInt(len);\n-        writeStringWithoutLength(s, len);\n-    }\n+  /**\n+   * Write a String.\n+   * The current position is incremented.\n+   *\n+   * @param s the value\n+   */\n+  public void writeString(String s) {\n+    int len = s.length();\n+    writeVarInt(len);\n+    writeStringWithoutLength(s, len);\n+  }\n \n-    /**\n-     * Write a String.\n-     * <p>\n-     * For performance reasons the internal representation of a String is\n-     * similar to UTF-8, but not exactly UTF-8.\n-     *\n-     * @param s the string\n-     * @param len the number of characters to write\n-     */\n-    private void writeStringWithoutLength(String s, int len) {\n-        int p = pos;\n-        byte[] buff = data;\n-        for (int i = 0; i < len; i++) {\n-            int c = s.charAt(i);\n-            if (c < 0x80) {\n-                buff[p++] = (byte) c;\n-            } else if (c >= 0x800) {\n-                buff[p++] = (byte) (0xe0 | (c >> 12));\n-                buff[p++] = (byte) (((c >> 6) & 0x3f));\n-                buff[p++] = (byte) (c & 0x3f);\n-            } else {\n-                buff[p++] = (byte) (0xc0 | (c >> 6));\n-                buff[p++] = (byte) (c & 0x3f);\n-            }\n-        }\n-        pos = p;\n+  /**\n+   * Write a String.\n+   * <p>\n+   * For performance reasons the internal representation of a String is\n+   * similar to UTF-8, but not exactly UTF-8.\n+   *\n+   * @param s   the string\n+   * @param len the number of characters to write\n+   */\n+  private void writeStringWithoutLength(String s, int len) {\n+    int p = pos;\n+    byte[] buff = data;\n+    for (int i = 0; i < len; i++) {\n+      int c = s.charAt(i);\n+      if (c < 0x80) {\n+        buff[p++] = (byte) c;\n+      } else if (c >= 0x800) {\n+        buff[p++] = (byte) (0xe0 | (c >> 12));\n+        buff[p++] = (byte) (((c >> 6) & 0x3f));\n+        buff[p++] = (byte) (c & 0x3f);\n+      } else {\n+        buff[p++] = (byte) (0xc0 | (c >> 6));\n+        buff[p++] = (byte) (c & 0x3f);\n+      }\n     }\n+    pos = p;\n+  }\n \n-    private void writeStringWithoutLength(char[] chars, int len) {\n-        int p = pos;\n-        byte[] buff = data;\n-        for (int i = 0; i < len; i++) {\n-            int c = chars[i];\n-            if (c < 0x80) {\n-                buff[p++] = (byte) c;\n-            } else if (c >= 0x800) {\n-                buff[p++] = (byte) (0xe0 | (c >> 12));\n-                buff[p++] = (byte) (((c >> 6) & 0x3f));\n-                buff[p++] = (byte) (c & 0x3f);\n-            } else {\n-                buff[p++] = (byte) (0xc0 | (c >> 6));\n-                buff[p++] = (byte) (c & 0x3f);\n-            }\n-        }\n-        pos = p;\n+  private void writeStringWithoutLength(char[] chars, int len) {\n+    int p = pos;\n+    byte[] buff = data;\n+    for (int i = 0; i < len; i++) {\n+      int c = chars[i];\n+      if (c < 0x80) {\n+        buff[p++] = (byte) c;\n+      } else if (c >= 0x800) {\n+        buff[p++] = (byte) (0xe0 | (c >> 12));\n+        buff[p++] = (byte) (((c >> 6) & 0x3f));\n+        buff[p++] = (byte) (c & 0x3f);\n+      } else {\n+        buff[p++] = (byte) (0xc0 | (c >> 6));\n+        buff[p++] = (byte) (c & 0x3f);\n+      }\n     }\n+    pos = p;\n+  }\n \n-    /**\n-     * Create a new buffer for the given handler. The\n-     * handler will decide what type of buffer is created.\n-     *\n-     * @param handler the data handler\n-     * @param capacity the initial capacity of the buffer\n-     * @param storeLocalTime\n-     *            store DATE, TIME, and TIMESTAMP values with local time storage\n-     *            format\n-     * @return the buffer\n-     */\n-    public static Data create(DataHandler handler, int capacity, boolean storeLocalTime) {\n-        return new Data(handler, new byte[capacity], storeLocalTime);\n-    }\n+  /**\n+   * Create a new buffer for the given handler. The\n+   * handler will decide what type of buffer is created.\n+   *\n+   * @param handler        the data handler\n+   * @param capacity       the initial capacity of the buffer\n+   * @param storeLocalTime store DATE, TIME, and TIMESTAMP values with local time storage\n+   *                       format\n+   * @return the buffer\n+   */\n+  public static Data create(DataHandler handler, int capacity, boolean storeLocalTime) {\n+    return new Data(handler, new byte[capacity], storeLocalTime);\n+  }\n \n-    /**\n-     * Create a new buffer using the given data for the given handler. The\n-     * handler will decide what type of buffer is created.\n-     *\n-     * @param handler the data handler\n-     * @param buff the data\n-     * @param storeLocalTime\n-     *            store DATE, TIME, and TIMESTAMP values with local time storage\n-     *            format\n-     * @return the buffer\n-     */\n-    public static Data create(DataHandler handler, byte[] buff, boolean storeLocalTime) {\n-        return new Data(handler, buff, storeLocalTime);\n-    }\n+  /**\n+   * Create a new buffer using the given data for the given handler. The\n+   * handler will decide what type of buffer is created.\n+   *\n+   * @param handler        the data handler\n+   * @param buff           the data\n+   * @param storeLocalTime store DATE, TIME, and TIMESTAMP values with local time storage\n+   *                       format\n+   * @return the buffer\n+   */\n+  public static Data create(DataHandler handler, byte[] buff, boolean storeLocalTime) {\n+    return new Data(handler, buff, storeLocalTime);\n+  }\n \n-    /**\n-     * Get the current write position of this buffer, which is the current\n-     * length.\n-     *\n-     * @return the length\n-     */\n-    public int length() {\n-        return pos;\n-    }\n+  /**\n+   * Get the current write position of this buffer, which is the current\n+   * length.\n+   *\n+   * @return the length\n+   */\n+  public int length() {\n+    return pos;\n+  }\n \n-    /**\n-     * Get the byte array used for this page.\n-     *\n-     * @return the byte array\n-     */\n-    public byte[] getBytes() {\n-        return data;\n-    }\n+  /**\n+   * Get the byte array used for this page.\n+   *\n+   * @return the byte array\n+   */\n+  public byte[] getBytes() {\n+    return data;\n+  }\n \n-    /**\n-     * Set the position to 0.\n-     */\n-    public void reset() {\n-        pos = 0;\n-    }\n+  /**\n+   * Set the position to 0.\n+   */\n+  public void reset() {\n+    pos = 0;\n+  }\n \n-    /**\n-     * Append a number of bytes to this buffer.\n-     *\n-     * @param buff the data\n-     * @param off the offset in the data\n-     * @param len the length in bytes\n-     */\n-    public void write(byte[] buff, int off, int len) {\n-        System.arraycopy(buff, off, data, pos, len);\n-        pos += len;\n-    }\n+  /**\n+   * Append a number of bytes to this buffer.\n+   *\n+   * @param buff the data\n+   * @param off  the offset in the data\n+   * @param len  the length in bytes\n+   */\n+  public void write(byte[] buff, int off, int len) {\n+    System.arraycopy(buff, off, data, pos, len);\n+    pos += len;\n+  }\n \n-    /**\n-     * Copy a number of bytes to the given buffer from the current position. The\n-     * current position is incremented accordingly.\n-     *\n-     * @param buff the output buffer\n-     * @param off the offset in the output buffer\n-     * @param len the number of bytes to copy\n-     */\n-    public void read(byte[] buff, int off, int len) {\n-        System.arraycopy(data, pos, buff, off, len);\n-        pos += len;\n-    }\n+  /**\n+   * Copy a number of bytes to the given buffer from the current position. The\n+   * current position is incremented accordingly.\n+   *\n+   * @param buff the output buffer\n+   * @param off  the offset in the output buffer\n+   * @param len  the number of bytes to copy\n+   */\n+  public void read(byte[] buff, int off, int len) {\n+    System.arraycopy(data, pos, buff, off, len);\n+    pos += len;\n+  }\n \n-    /**\n-     * Append one single byte.\n-     *\n-     * @param x the value\n-     */\n-    public void writeByte(byte x) {\n-        data[pos++] = x;\n-    }\n+  /**\n+   * Append one single byte.\n+   *\n+   * @param x the value\n+   */\n+  public void writeByte(byte x) {\n+    data[pos++] = x;\n+  }\n \n-    /**\n-     * Read one single byte.\n-     *\n-     * @return the value\n-     */\n-    public byte readByte() {\n-        return data[pos++];\n-    }\n+  /**\n+   * Read one single byte.\n+   *\n+   * @return the value\n+   */\n+  public byte readByte() {\n+    return data[pos++];\n+  }\n \n-    /**\n-     * Read a long value. This method reads two int values and combines them.\n-     *\n-     * @return the long value\n-     */\n-    public long readLong() {\n-        long x = Bits.readLong(data, pos);\n-        pos += 8;\n-        return x;\n-    }\n+  /**\n+   * Read a long value. This method reads two int values and combines them.\n+   *\n+   * @return the long value\n+   */\n+  public long readLong() {\n+    long x = Bits.readLong(data, pos);\n+    pos += 8;\n+    return x;\n+  }\n \n-    /**\n-     * Append a long value. This method writes two int values.\n-     *\n-     * @param x the value\n-     */\n-    public void writeLong(long x) {\n-        Bits.writeLong(data, pos, x);\n-        pos += 8;\n-    }\n+  /**\n+   * Append a long value. This method writes two int values.\n+   *\n+   * @param x the value\n+   */\n+  public void writeLong(long x) {\n+    Bits.writeLong(data, pos, x);\n+    pos += 8;\n+  }\n \n-    /**\n-     * Append a value.\n-     *\n-     * @param v the value\n-     */\n-    public void writeValue(Value v) {\n-        int start = pos;\n-        if (v == ValueNull.INSTANCE) {\n-            data[pos++] = NULL;\n-            return;\n-        }\n-        int type = v.getValueType();\n-        switch (type) {\n-        case Value.BOOLEAN:\n-            writeByte(v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n-            break;\n-        case Value.BYTE:\n-            writeByte(BYTE);\n-            writeByte(v.getByte());\n-            break;\n-        case Value.SHORT:\n-            writeByte(SHORT);\n-            writeShortInt(v.getShort());\n-            break;\n-        case Value.ENUM:\n-        case Value.INT: {\n-            int x = v.getInt();\n-            if (x < 0) {\n-                writeByte(INT_NEG);\n-                writeVarInt(-x);\n-            } else if (x < 16) {\n-                writeByte((byte) (INT_0_15 + x));\n-            } else {\n-                writeByte(type == Value.INT ? INT : ENUM);\n-                writeVarInt(x);\n-            }\n-            break;\n-        }\n-        case Value.LONG: {\n-            long x = v.getLong();\n-            if (x < 0) {\n-                writeByte(LONG_NEG);\n-                writeVarLong(-x);\n-            } else if (x < 8) {\n-                writeByte((byte) (LONG_0_7 + x));\n-            } else {\n-                writeByte(LONG);\n-                writeVarLong(x);\n-            }\n-            break;\n-        }\n-        case Value.DECIMAL: {\n-            BigDecimal x = v.getBigDecimal();\n-            if (BigDecimal.ZERO.equals(x)) {\n-                writeByte(DECIMAL_0_1);\n-            } else if (BigDecimal.ONE.equals(x)) {\n-                writeByte((byte) (DECIMAL_0_1 + 1));\n-            } else {\n-                int scale = x.scale();\n-                BigInteger b = x.unscaledValue();\n-                int bits = b.bitLength();\n-                if (bits <= 63) {\n-                    if (scale == 0) {\n-                        writeByte(DECIMAL_SMALL_0);\n-                        writeVarLong(b.longValue());\n-                    } else {\n-                        writeByte(DECIMAL_SMALL);\n-                        writeVarInt(scale);\n-                        writeVarLong(b.longValue());\n-                    }\n-                } else {\n-                    writeByte(DECIMAL);\n-                    writeVarInt(scale);\n-                    byte[] bytes = b.toByteArray();\n-                    writeVarInt(bytes.length);\n-                    write(bytes, 0, bytes.length);\n-                }\n-            }\n-            break;\n-        }\n-        case Value.TIME:\n-            if (storeLocalTime) {\n-                writeByte((byte) LOCAL_TIME);\n-                ValueTime t = (ValueTime) v;\n-                long nanos = t.getNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                writeVarLong(millis);\n-                writeVarLong(nanos);\n-            } else {\n-                writeByte(TIME);\n-                writeVarLong(DateTimeUtils.getTimeLocalWithoutDst(v.getTime()));\n-            }\n-            break;\n-        case Value.DATE: {\n-            if (storeLocalTime) {\n-                writeByte((byte) LOCAL_DATE);\n-                long x = ((ValueDate) v).getDateValue();\n-                writeVarLong(x);\n-            } else {\n-                writeByte(DATE);\n-                long x = DateTimeUtils.getTimeLocalWithoutDst(v.getDate());\n-                writeVarLong(x / MILLIS_PER_MINUTE);\n-            }\n-            break;\n-        }\n-        case Value.TIMESTAMP: {\n-            if (storeLocalTime) {\n-                writeByte((byte) LOCAL_TIMESTAMP);\n-                ValueTimestamp ts = (ValueTimestamp) v;\n-                long dateValue = ts.getDateValue();\n-                writeVarLong(dateValue);\n-                long nanos = ts.getTimeNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                writeVarLong(millis);\n-                writeVarLong(nanos);\n-            } else {\n-                Timestamp ts = v.getTimestamp();\n-                writeByte(TIMESTAMP);\n-                writeVarLong(DateTimeUtils.getTimeLocalWithoutDst(ts));\n-                writeVarInt(ts.getNanos() % 1_000_000);\n-            }\n-            break;\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            writeByte(TIMESTAMP_TZ);\n-            writeVarLong(ts.getDateValue());\n-            writeVarLong(ts.getTimeNanos());\n-            writeVarInt(ts.getTimeZoneOffsetMins());\n-            break;\n-        }\n-        case Value.GEOMETRY:\n-            // fall though\n-        case Value.JAVA_OBJECT: {\n-            writeByte(type == Value.GEOMETRY ? GEOMETRY : JAVA_OBJECT);\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            writeVarInt(len);\n-            write(b, 0, len);\n-            break;\n-        }\n-        case Value.BYTES: {\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            if (len < 32) {\n-                writeByte((byte) (BYTES_0_31 + len));\n-                write(b, 0, len);\n-            } else {\n-                writeByte(BYTES);\n-                writeVarInt(len);\n-                write(b, 0, len);\n-            }\n-            break;\n-        }\n-        case Value.UUID: {\n-            writeByte(UUID);\n-            ValueUuid uuid = (ValueUuid) v;\n-            writeLong(uuid.getHigh());\n-            writeLong(uuid.getLow());\n-            break;\n-        }\n-        case Value.STRING: {\n-            String s = v.getString();\n-            int len = s.length();\n-            if (len < 32) {\n-                writeByte((byte) (STRING_0_31 + len));\n-                writeStringWithoutLength(s, len);\n-            } else {\n-                writeByte(STRING);\n-                writeString(s);\n-            }\n-            break;\n-        }\n-        case Value.STRING_IGNORECASE:\n-            writeByte(STRING_IGNORECASE);\n-            writeString(v.getString());\n-            break;\n-        case Value.STRING_FIXED:\n-            writeByte(STRING_FIXED);\n-            writeString(v.getString());\n-            break;\n-        case Value.DOUBLE: {\n-            double x = v.getDouble();\n-            if (x == 1.0d) {\n-                writeByte((byte) (DOUBLE_0_1 + 1));\n-            } else {\n-                long d = Double.doubleToLongBits(x);\n-                if (d == ValueDouble.ZERO_BITS) {\n-                    writeByte(DOUBLE_0_1);\n-                } else {\n-                    writeByte(DOUBLE);\n-                    writeVarLong(Long.reverse(d));\n-                }\n-            }\n-            break;\n-        }\n-        case Value.FLOAT: {\n-            float x = v.getFloat();\n-            if (x == 1.0f) {\n-                writeByte((byte) (FLOAT_0_1 + 1));\n-            } else {\n-                int f = Float.floatToIntBits(x);\n-                if (f == ValueFloat.ZERO_BITS) {\n-                    writeByte(FLOAT_0_1);\n-                } else {\n-                    writeByte(FLOAT);\n-                    writeVarInt(Integer.reverse(f));\n-                }\n-            }\n-            break;\n-        }\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            writeByte(type == Value.BLOB ? BLOB : CLOB);\n-            if (v instanceof ValueLob) {\n-                ValueLob lob = (ValueLob) v;\n-                byte[] small = lob.getSmall();\n-                if (small == null) {\n-                    int t = -1;\n-                    if (!lob.isLinkedToTable()) {\n-                        t = -2;\n-                    }\n-                    writeVarInt(t);\n-                    writeVarInt(lob.getTableId());\n-                    writeVarInt(lob.getObjectId());\n-                    writeVarLong(lob.getType().getPrecision());\n-                    writeByte((byte) (lob.isCompressed() ? 1 : 0));\n-                    if (t == -2) {\n-                        writeString(lob.getFileName());\n-                    }\n-                } else {\n-                    writeVarInt(small.length);\n-                    write(small, 0, small.length);\n-                }\n-            } else {\n-                ValueLobDb lob = (ValueLobDb) v;\n-                byte[] small = lob.getSmall();\n-                if (small == null) {\n-                    writeVarInt(-3);\n-                    writeVarInt(lob.getTableId());\n-                    writeVarLong(lob.getLobId());\n-                    writeVarLong(lob.getType().getPrecision());\n-                } else {\n-                    writeVarInt(small.length);\n-                    write(small, 0, small.length);\n-                }\n-            }\n-            break;\n-        }\n-        case Value.ARRAY:\n-        case Value.ROW: {\n-            writeByte(type == Value.ARRAY ? ARRAY : ROW);\n-            Value[] list = ((ValueCollectionBase) v).getList();\n-            writeVarInt(list.length);\n-            for (Value x : list) {\n-                writeValue(x);\n-            }\n-            break;\n-        }\n-        case Value.RESULT_SET: {\n-            writeByte(RESULT_SET);\n-            ResultInterface result = ((ValueResultSet) v).getResult();\n-            result.reset();\n-            int columnCount = result.getVisibleColumnCount();\n-            writeVarInt(columnCount);\n-            for (int i = 0; i < columnCount; i++) {\n-                writeString(result.getAlias(i));\n-                writeString(result.getColumnName(i));\n-                TypeInfo columnType = result.getColumnType(i);\n-                writeVarInt(columnType.getValueType());\n-                writeVarLong(columnType.getPrecision());\n-                writeVarInt(columnType.getScale());\n-            }\n-            while (result.next()) {\n-                writeByte((byte) 1);\n-                Value[] row = result.currentRow();\n-                for (int i = 0; i < columnCount; i++) {\n-                    writeValue(row[i]);\n-                }\n-            }\n-            writeByte((byte) 0);\n-            break;\n-        }\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE: {\n-            ValueInterval interval = (ValueInterval) v;\n-            int ordinal = type - Value.INTERVAL_YEAR;\n-            if (interval.isNegative()) {\n-                ordinal = ~ordinal;\n-            }\n-            writeByte(INTERVAL);\n-            writeByte((byte) ordinal);\n-            writeVarLong(interval.getLeading());\n-            break;\n-        }\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND: {\n-            ValueInterval interval = (ValueInterval) v;\n-            int ordinal = type - Value.INTERVAL_YEAR;\n-            if (interval.isNegative()) {\n-                ordinal = ~ordinal;\n-            }\n-            writeByte(INTERVAL);\n-            writeByte((byte) ordinal);\n-            writeVarLong(interval.getLeading());\n-            writeVarLong(interval.getRemaining());\n-            break;\n-        }\n-        case Value.JSON: {\n-            writeByte((byte) JSON);\n-            writeString(v.getString());\n-            break;\n-        }\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                byte[] b = v.getBytesNoCopy();\n-                writeByte((byte) CUSTOM_DATA_TYPE);\n-                writeVarInt(type);\n-                writeVarInt(b.length);\n-                write(b, 0, b.length);\n-                break;\n-            }\n-            DbException.throwInternalError(\"type=\" + v.getValueType());\n-        }\n-        assert pos - start == getValueLen(v)\n-                : \"value size error: got \" + (pos - start) + \" expected \" + getValueLen(v);\n+  /**\n+   * Append a value.\n+   *\n+   * @param v the value\n+   */\n+  public void writeValue(Value v) {\n+    int start = pos;\n+    if (v == ValueNull.INSTANCE) {\n+      data[pos++] = NULL;\n+      return;\n     }\n-\n-    /**\n-     * Read a value.\n-     *\n-     * @return the value\n-     */\n-    public Value readValue() {\n-        int type = data[pos++] & 255;\n-        switch (type) {\n-        case NULL:\n-            return ValueNull.INSTANCE;\n-        case BOOLEAN_TRUE:\n-            return ValueBoolean.TRUE;\n-        case BOOLEAN_FALSE:\n-            return ValueBoolean.FALSE;\n-        case INT_NEG:\n-            return ValueInt.get(-readVarInt());\n-        case ENUM:\n-        case INT:\n-            return ValueInt.get(readVarInt());\n-        case LONG_NEG:\n-            return ValueLong.get(-readVarLong());\n-        case Value.LONG:\n-            return ValueLong.get(readVarLong());\n-        case BYTE:\n-            return ValueByte.get(readByte());\n-        case SHORT:\n-            return ValueShort.get(readShortInt());\n-        case DECIMAL_0_1:\n-            return (ValueDecimal) ValueDecimal.ZERO;\n-        case DECIMAL_0_1 + 1:\n-            return (ValueDecimal) ValueDecimal.ONE;\n-        case DECIMAL_SMALL_0:\n-            return ValueDecimal.get(BigDecimal.valueOf(readVarLong()));\n-        case DECIMAL_SMALL: {\n-            int scale = readVarInt();\n-            return ValueDecimal.get(BigDecimal.valueOf(readVarLong(), scale));\n-        }\n-        case DECIMAL: {\n-            int scale = readVarInt();\n-            int len = readVarInt();\n-            byte[] buff = Utils.newBytes(len);\n-            read(buff, 0, len);\n-            BigInteger b = new BigInteger(buff);\n-            return ValueDecimal.get(new BigDecimal(b, scale));\n-        }\n-        case LOCAL_DATE: {\n-            return ValueDate.fromDateValue(readVarLong());\n-        }\n-        case DATE: {\n-            long x = readVarLong() * MILLIS_PER_MINUTE;\n-            return ValueDate.fromMillis(DateTimeUtils.getTimeUTCWithoutDst(x));\n-        }\n-        case LOCAL_TIME: {\n-            long nanos = readVarLong() * 1_000_000 + readVarLong();\n-            return ValueTime.fromNanos(nanos);\n-        }\n-        case TIME:\n-            // need to normalize the year, month and day\n-            return ValueTime.fromMillis(\n-                    DateTimeUtils.getTimeUTCWithoutDst(readVarLong()));\n-        case LOCAL_TIMESTAMP: {\n-            long dateValue = readVarLong();\n-            long nanos = readVarLong() * 1_000_000 + readVarLong();\n-            return ValueTimestamp.fromDateValueAndNanos(dateValue, nanos);\n-        }\n-        case TIMESTAMP: {\n-            return ValueTimestamp.fromMillisNanos(\n-                    DateTimeUtils.getTimeUTCWithoutDst(readVarLong()),\n-                    readVarInt() % 1_000_000);\n-        }\n-        case TIMESTAMP_TZ: {\n-            long dateValue = readVarLong();\n-            long nanos = readVarLong();\n-            short tz = (short) readVarInt();\n-            return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n-        }\n-        case BYTES: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueBytes.getNoCopy(b);\n-        }\n-        case GEOMETRY: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueGeometry.get(b);\n-        }\n-        case JAVA_OBJECT: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueJavaObject.getNoCopy(null, b, handler);\n-        }\n-        case UUID:\n-            return ValueUuid.get(readLong(), readLong());\n-        case STRING:\n-            return ValueString.get(readString());\n-        case STRING_IGNORECASE:\n-            return ValueStringIgnoreCase.get(readString());\n-        case STRING_FIXED:\n-            return ValueStringFixed.get(readString());\n-        case FLOAT_0_1:\n-            return ValueFloat.ZERO;\n-        case FLOAT_0_1 + 1:\n-            return ValueFloat.ONE;\n-        case DOUBLE_0_1:\n-            return ValueDouble.ZERO;\n-        case DOUBLE_0_1 + 1:\n-            return ValueDouble.ONE;\n-        case DOUBLE:\n-            return ValueDouble.get(Double.longBitsToDouble(Long.reverse(readVarLong())));\n-        case FLOAT:\n-            return ValueFloat.get(Float.intBitsToFloat(Integer.reverse(readVarInt())));\n-        case BLOB:\n-        case CLOB: {\n-            int smallLen = readVarInt();\n-            if (smallLen >= 0) {\n-                byte[] small = Utils.newBytes(smallLen);\n-                read(small, 0, smallLen);\n-                return ValueLobDb.createSmallLob(type == BLOB ? Value.BLOB : Value.CLOB, small);\n-            } else if (smallLen == -3) {\n-                int tableId = readVarInt();\n-                long lobId = readVarLong();\n-                long precision = readVarLong();\n-                return ValueLobDb.create(type == BLOB ? Value.BLOB : Value.CLOB, handler, tableId,\n-                        lobId, null, precision);\n+    int type = v.getValueType();\n+    switch (type) {\n+      case Value.BOOLEAN:\n+        writeByte(v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n+        break;\n+      case Value.BYTE:\n+        writeByte(BYTE);\n+        writeByte(v.getByte());\n+        break;\n+      case Value.SHORT:\n+        writeByte(SHORT);\n+        writeShortInt(v.getShort());\n+        break;\n+      case Value.ENUM:\n+      case Value.INT: {\n+        int x = v.getInt();\n+        if (x < 0) {\n+          writeByte(INT_NEG);\n+          writeVarInt(-x);\n+        } else if (x < 16) {\n+          writeByte((byte) (INT_0_15 + x));\n+        } else {\n+          writeByte(type == Value.INT ? INT : ENUM);\n+          writeVarInt(x);\n+        }\n+        break;\n+      }\n+      case Value.LONG: {\n+        long x = v.getLong();\n+        if (x < 0) {\n+          writeByte(LONG_NEG);\n+          writeVarLong(-x);\n+        } else if (x < 8) {\n+          writeByte((byte) (LONG_0_7 + x));\n+        } else {\n+          writeByte(LONG);\n+          writeVarLong(x);\n+        }\n+        break;\n+      }\n+      case Value.DECIMAL: {\n+        BigDecimal x = v.getBigDecimal();\n+        if (BigDecimal.ZERO.equals(x)) {\n+          writeByte(DECIMAL_0_1);\n+        } else if (BigDecimal.ONE.equals(x)) {\n+          writeByte((byte) (DECIMAL_0_1 + 1));\n+        } else {\n+          int scale = x.scale();\n+          BigInteger b = x.unscaledValue();\n+          int bits = b.bitLength();\n+          if (bits <= 63) {\n+            if (scale == 0) {\n+              writeByte(DECIMAL_SMALL_0);\n+              writeVarLong(b.longValue());\n             } else {\n-                int tableId = readVarInt();\n-                int objectId = readVarInt();\n-                long precision = 0;\n-                boolean compression = false;\n-                // -1: regular; -2: regular, but not linked (in this case:\n-                // including file name)\n-                if (smallLen == -1 || smallLen == -2) {\n-                    precision = readVarLong();\n-                    compression = readByte() == 1;\n-                }\n-                if (smallLen == -2) {\n-                    String filename = readString();\n-                    return ValueLob.openUnlinked(type == BLOB ? Value.BLOB : Value.CLOB, handler, tableId,\n-                            objectId, precision, compression, filename);\n-                }\n-                return ValueLob.openLinked(type == BLOB ? Value.BLOB : Value.CLOB, handler, tableId,\n-                        objectId, precision, compression);\n-            }\n-        }\n-        case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n-        {\n-            int len = readVarInt();\n-            Value[] list = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                list[i] = readValue();\n-            }\n-            return type == ARRAY ? ValueArray.get(list) : ValueRow.get(list);\n-        }\n-        case RESULT_SET: {\n-            SimpleResult rs = new SimpleResult();\n-            int columns = readVarInt();\n-            for (int i = 0; i < columns; i++) {\n-                rs.addColumn(readString(), readString(), readVarInt(), readVarLong(), readVarInt());\n-            }\n-            while (readByte() != 0) {\n-                Value[] o = new Value[columns];\n-                for (int i = 0; i < columns; i++) {\n-                    o[i] = readValue();\n-                }\n-                rs.addRow(o);\n-            }\n-            return ValueResultSet.get(rs);\n-        }\n-        case INTERVAL: {\n-            int ordinal = readByte();\n-            boolean negative = ordinal < 0;\n-            if (negative) {\n-                ordinal = ~ordinal;\n+              writeByte(DECIMAL_SMALL);\n+              writeVarInt(scale);\n+              writeVarLong(b.longValue());\n             }\n-            return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readVarLong(),\n-                    ordinal < 5 ? 0 : readVarLong());\n-        }\n-        case CUSTOM_DATA_TYPE: {\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                int customType = readVarInt();\n-                int len = readVarInt();\n-                byte[] b = Utils.newBytes(len);\n-                read(b, 0, len);\n-                return JdbcUtils.customDataTypesHandler.convert(\n-                        ValueBytes.getNoCopy(b), customType);\n+          } else {\n+            writeByte(DECIMAL);\n+            writeVarInt(scale);\n+            byte[] bytes = b.toByteArray();\n+            writeVarInt(bytes.length);\n+            write(bytes, 0, bytes.length);\n+          }\n+        }\n+        break;\n+      }\n+      case Value.TIME:\n+        if (storeLocalTime) {\n+          writeByte((byte) LOCAL_TIME);\n+          ValueTime t = (ValueTime) v;\n+          long nanos = t.getNanos();\n+          long millis = nanos / 1_000_000;\n+          nanos -= millis * 1_000_000;\n+          writeVarLong(millis);\n+          writeVarLong(nanos);\n+        } else {\n+          writeByte(TIME);\n+          writeVarLong(DateTimeUtils.getTimeLocalWithoutDst(v.getTime()));\n+        }\n+        break;\n+      case Value.DATE: {\n+        if (storeLocalTime) {\n+          writeByte((byte) LOCAL_DATE);\n+          long x = ((ValueDate) v).getDateValue();\n+          writeVarLong(x);\n+        } else {\n+          writeByte(DATE);\n+          long x = DateTimeUtils.getTimeLocalWithoutDst(v.getDate());\n+          writeVarLong(x / MILLIS_PER_MINUTE);\n+        }\n+        break;\n+      }\n+      case Value.TIMESTAMP: {\n+        if (storeLocalTime) {\n+          writeByte((byte) LOCAL_TIMESTAMP);\n+          ValueTimestamp ts = (ValueTimestamp) v;\n+          long dateValue = ts.getDateValue();\n+          writeVarLong(dateValue);\n+          long nanos = ts.getTimeNanos();\n+          long millis = nanos / 1_000_000;\n+          nanos -= millis * 1_000_000;\n+          writeVarLong(millis);\n+          writeVarLong(nanos);\n+        } else {\n+          Timestamp ts = v.getTimestamp();\n+          writeByte(TIMESTAMP);\n+          writeVarLong(DateTimeUtils.getTimeLocalWithoutDst(ts));\n+          writeVarInt(ts.getNanos() % 1_000_000);\n+        }\n+        break;\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+        writeByte(TIMESTAMP_TZ);\n+        writeVarLong(ts.getDateValue());\n+        writeVarLong(ts.getTimeNanos());\n+        writeVarInt(ts.getTimeZoneOffsetMins());\n+        break;\n+      }\n+      case Value.GEOMETRY:\n+        // fall though\n+      case Value.JAVA_OBJECT: {\n+        writeByte(type == Value.GEOMETRY ? GEOMETRY : JAVA_OBJECT);\n+        byte[] b = v.getBytesNoCopy();\n+        int len = b.length;\n+        writeVarInt(len);\n+        write(b, 0, len);\n+        break;\n+      }\n+      case Value.BYTES: {\n+        byte[] b = v.getBytesNoCopy();\n+        int len = b.length;\n+        if (len < 32) {\n+          writeByte((byte) (BYTES_0_31 + len));\n+          write(b, 0, len);\n+        } else {\n+          writeByte(BYTES);\n+          writeVarInt(len);\n+          write(b, 0, len);\n+        }\n+        break;\n+      }\n+      case Value.UUID: {\n+        writeByte(UUID);\n+        ValueUuid uuid = (ValueUuid) v;\n+        writeLong(uuid.getHigh());\n+        writeLong(uuid.getLow());\n+        break;\n+      }\n+      case Value.STRING: {\n+        String s = v.getString();\n+        int len = s.length();\n+        if (len < 32) {\n+          writeByte((byte) (STRING_0_31 + len));\n+          writeStringWithoutLength(s, len);\n+        } else {\n+          writeByte(STRING);\n+          writeString(s);\n+        }\n+        break;\n+      }\n+      case Value.STRING_IGNORECASE:\n+        writeByte(STRING_IGNORECASE);\n+        writeString(v.getString());\n+        break;\n+      case Value.STRING_FIXED:\n+        writeByte(STRING_FIXED);\n+        writeString(v.getString());\n+        break;\n+      case Value.DOUBLE: {\n+        double x = v.getDouble();\n+        if (x == 1.0d) {\n+          writeByte((byte) (DOUBLE_0_1 + 1));\n+        } else {\n+          long d = Double.doubleToLongBits(x);\n+          if (d == ValueDouble.ZERO_BITS) {\n+            writeByte(DOUBLE_0_1);\n+          } else {\n+            writeByte(DOUBLE);\n+            writeVarLong(Long.reverse(d));\n+          }\n+        }\n+        break;\n+      }\n+      case Value.FLOAT: {\n+        float x = v.getFloat();\n+        if (x == 1.0f) {\n+          writeByte((byte) (FLOAT_0_1 + 1));\n+        } else {\n+          int f = Float.floatToIntBits(x);\n+          if (f == ValueFloat.ZERO_BITS) {\n+            writeByte(FLOAT_0_1);\n+          } else {\n+            writeByte(FLOAT);\n+            writeVarInt(Integer.reverse(f));\n+          }\n+        }\n+        break;\n+      }\n+      case Value.BLOB:\n+      case Value.CLOB: {\n+        writeByte(type == Value.BLOB ? BLOB : CLOB);\n+        if (v instanceof ValueLob) {\n+          ValueLob lob = (ValueLob) v;\n+          byte[] small = lob.getSmall();\n+          if (small == null) {\n+            int t = -1;\n+            if (!lob.isLinkedToTable()) {\n+              t = -2;\n             }\n-            throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n-                    \"No CustomDataTypesHandler has been set up\");\n-        }\n-        case JSON: {\n-            String s = readString();\n-            return ValueJson.get(s);\n-        }\n-        default:\n-            if (type >= INT_0_15 && type < INT_0_15 + 16) {\n-                return ValueInt.get(type - INT_0_15);\n-            } else if (type >= LONG_0_7 && type < LONG_0_7 + 8) {\n-                return ValueLong.get(type - LONG_0_7);\n-            } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n-                int len = type - BYTES_0_31;\n-                byte[] b = Utils.newBytes(len);\n-                read(b, 0, len);\n-                return ValueBytes.getNoCopy(b);\n-            } else if (type >= STRING_0_31 && type < STRING_0_31 + 32) {\n-                return ValueString.get(readString(type - STRING_0_31));\n+            writeVarInt(t);\n+            writeVarInt(lob.getTableId());\n+            writeVarInt(lob.getObjectId());\n+            writeVarLong(lob.getType().getPrecision());\n+            writeByte((byte) (lob.isCompressed() ? 1 : 0));\n+            if (t == -2) {\n+              writeString(lob.getFileName());\n             }\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n-        }\n+          } else {\n+            writeVarInt(small.length);\n+            write(small, 0, small.length);\n+          }\n+        } else {\n+          ValueLobDb lob = (ValueLobDb) v;\n+          byte[] small = lob.getSmall();\n+          if (small == null) {\n+            writeVarInt(-3);\n+            writeVarInt(lob.getTableId());\n+            writeVarLong(lob.getLobId());\n+            writeVarLong(lob.getType().getPrecision());\n+          } else {\n+            writeVarInt(small.length);\n+            write(small, 0, small.length);\n+          }\n+        }\n+        break;\n+      }\n+      case Value.ARRAY:\n+      case Value.ROW: {\n+        writeByte(type == Value.ARRAY ? ARRAY : ROW);\n+        Value[] list = ((ValueCollectionBase) v).getList();\n+        writeVarInt(list.length);\n+        for (Value x : list) {\n+          writeValue(x);\n+        }\n+        break;\n+      }\n+      case Value.RESULT_SET: {\n+        writeByte(RESULT_SET);\n+        ResultInterface result = ((ValueResultSet) v).getResult();\n+        result.reset();\n+        int columnCount = result.getVisibleColumnCount();\n+        writeVarInt(columnCount);\n+        for (int i = 0; i < columnCount; i++) {\n+          writeString(result.getAlias(i));\n+          writeString(result.getColumnName(i));\n+          TypeInfo columnType = result.getColumnType(i);\n+          writeVarInt(columnType.getValueType());\n+          writeVarLong(columnType.getPrecision());\n+          writeVarInt(columnType.getScale());\n+        }\n+        while (result.next()) {\n+          writeByte((byte) 1);\n+          Value[] row = result.currentRow();\n+          for (int i = 0; i < columnCount; i++) {\n+            writeValue(row[i]);\n+          }\n+        }\n+        writeByte((byte) 0);\n+        break;\n+      }\n+      case Value.INTERVAL_YEAR:\n+      case Value.INTERVAL_MONTH:\n+      case Value.INTERVAL_DAY:\n+      case Value.INTERVAL_HOUR:\n+      case Value.INTERVAL_MINUTE: {\n+        ValueInterval interval = (ValueInterval) v;\n+        int ordinal = type - Value.INTERVAL_YEAR;\n+        if (interval.isNegative()) {\n+          ordinal = ~ordinal;\n+        }\n+        writeByte(INTERVAL);\n+        writeByte((byte) ordinal);\n+        writeVarLong(interval.getLeading());\n+        break;\n+      }\n+      case Value.INTERVAL_SECOND:\n+      case Value.INTERVAL_YEAR_TO_MONTH:\n+      case Value.INTERVAL_DAY_TO_HOUR:\n+      case Value.INTERVAL_DAY_TO_MINUTE:\n+      case Value.INTERVAL_DAY_TO_SECOND:\n+      case Value.INTERVAL_HOUR_TO_MINUTE:\n+      case Value.INTERVAL_HOUR_TO_SECOND:\n+      case Value.INTERVAL_MINUTE_TO_SECOND: {\n+        ValueInterval interval = (ValueInterval) v;\n+        int ordinal = type - Value.INTERVAL_YEAR;\n+        if (interval.isNegative()) {\n+          ordinal = ~ordinal;\n+        }\n+        writeByte(INTERVAL);\n+        writeByte((byte) ordinal);\n+        writeVarLong(interval.getLeading());\n+        writeVarLong(interval.getRemaining());\n+        break;\n+      }\n+      case Value.JSON: {\n+        writeByte((byte) JSON);\n+        writeString(v.getString());\n+        break;\n+      }\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          byte[] b = v.getBytesNoCopy();\n+          writeByte((byte) CUSTOM_DATA_TYPE);\n+          writeVarInt(type);\n+          writeVarInt(b.length);\n+          write(b, 0, b.length);\n+          break;\n+        }\n+        DbException.throwInternalError(\"type=\" + v.getValueType());\n     }\n+    assert pos - start == getValueLen(v)\n+        : \"value size error: got \" + (pos - start) + \" expected \" + getValueLen(v);\n+  }\n \n-    /**\n-     * Calculate the number of bytes required to encode the given value.\n-     *\n-     * @param v the value\n-     * @return the number of bytes required to store this value\n-     */\n-    public int getValueLen(Value v) {\n-        return getValueLen(v, storeLocalTime);\n+  /**\n+   * Read a value.\n+   *\n+   * @return the value\n+   */\n+  public Value readValue() {\n+    int type = data[pos++] & 255;\n+    switch (type) {\n+      case NULL:\n+        return ValueNull.INSTANCE;\n+      case BOOLEAN_TRUE:\n+        return ValueBoolean.TRUE;\n+      case BOOLEAN_FALSE:\n+        return ValueBoolean.FALSE;\n+      case INT_NEG:\n+        return ValueInt.get(-readVarInt());\n+      case ENUM:\n+      case INT:\n+        return ValueInt.get(readVarInt());\n+      case LONG_NEG:\n+        return ValueLong.get(-readVarLong());\n+      case Value.LONG:\n+        return ValueLong.get(readVarLong());\n+      case BYTE:\n+        return ValueByte.get(readByte());\n+      case SHORT:\n+        return ValueShort.get(readShortInt());\n+      case DECIMAL_0_1:\n+        return (ValueDecimal) ValueDecimal.ZERO;\n+      case DECIMAL_0_1 + 1:\n+        return (ValueDecimal) ValueDecimal.ONE;\n+      case DECIMAL_SMALL_0:\n+        return ValueDecimal.get(BigDecimal.valueOf(readVarLong()));\n+      case DECIMAL_SMALL: {\n+        int scale = readVarInt();\n+        return ValueDecimal.get(BigDecimal.valueOf(readVarLong(), scale));\n+      }\n+      case DECIMAL: {\n+        int scale = readVarInt();\n+        int len = readVarInt();\n+        byte[] buff = Utils.newBytes(len);\n+        read(buff, 0, len);\n+        BigInteger b = new BigInteger(buff);\n+        return ValueDecimal.get(new BigDecimal(b, scale));\n+      }\n+      case LOCAL_DATE: {\n+        return ValueDate.fromDateValue(readVarLong());\n+      }\n+      case DATE: {\n+        long x = readVarLong() * MILLIS_PER_MINUTE;\n+        return ValueDate.fromMillis(DateTimeUtils.getTimeUTCWithoutDst(x));\n+      }\n+      case LOCAL_TIME: {\n+        long nanos = readVarLong() * 1_000_000 + readVarLong();\n+        return ValueTime.fromNanos(nanos);\n+      }\n+      case TIME:\n+        // need to normalize the year, month and day\n+        return ValueTime.fromMillis(\n+            DateTimeUtils.getTimeUTCWithoutDst(readVarLong()));\n+      case LOCAL_TIMESTAMP: {\n+        long dateValue = readVarLong();\n+        long nanos = readVarLong() * 1_000_000 + readVarLong();\n+        return ValueTimestamp.fromDateValueAndNanos(dateValue, nanos);\n+      }\n+      case TIMESTAMP: {\n+        return ValueTimestamp.fromMillisNanos(\n+            DateTimeUtils.getTimeUTCWithoutDst(readVarLong()),\n+            readVarInt() % 1_000_000);\n+      }\n+      case TIMESTAMP_TZ: {\n+        long dateValue = readVarLong();\n+        long nanos = readVarLong();\n+        short tz = (short) readVarInt();\n+        return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n+      }\n+      case BYTES: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueBytes.getNoCopy(b);\n+      }\n+      case GEOMETRY: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueGeometry.get(b);\n+      }\n+      case JAVA_OBJECT: {\n+        int len = readVarInt();\n+        byte[] b = Utils.newBytes(len);\n+        read(b, 0, len);\n+        return ValueJavaObject.getNoCopy(null, b, handler);\n+      }\n+      case UUID:\n+        return ValueUuid.get(readLong(), readLong());\n+      case STRING:\n+        return ValueString.get(readString());\n+      case STRING_IGNORECASE:\n+        return ValueStringIgnoreCase.get(readString());\n+      case STRING_FIXED:\n+        return ValueStringFixed.get(readString());\n+      case FLOAT_0_1:\n+        return ValueFloat.ZERO;\n+      case FLOAT_0_1 + 1:\n+        return ValueFloat.ONE;\n+      case DOUBLE_0_1:\n+        return ValueDouble.ZERO;\n+      case DOUBLE_0_1 + 1:\n+        return ValueDouble.ONE;\n+      case DOUBLE:\n+        return ValueDouble.get(Double.longBitsToDouble(Long.reverse(readVarLong())));\n+      case FLOAT:\n+        return ValueFloat.get(Float.intBitsToFloat(Integer.reverse(readVarInt())));\n+      case BLOB:\n+      case CLOB: {\n+        int smallLen = readVarInt();\n+        if (smallLen >= 0) {\n+          byte[] small = Utils.newBytes(smallLen);\n+          read(small, 0, smallLen);\n+          return ValueLobDb.createSmallLob(type == BLOB ? Value.BLOB : Value.CLOB, small);\n+        } else if (smallLen == -3) {\n+          int tableId = readVarInt();\n+          long lobId = readVarLong();\n+          long precision = readVarLong();\n+          return ValueLobDb.create(type == BLOB ? Value.BLOB : Value.CLOB, handler, tableId,\n+              lobId, null, precision);\n+        } else {\n+          int tableId = readVarInt();\n+          int objectId = readVarInt();\n+          long precision = 0;\n+          boolean compression = false;\n+          // -1: regular; -2: regular, but not linked (in this case:\n+          // including file name)\n+          if (smallLen == -1 || smallLen == -2) {\n+            precision = readVarLong();\n+            compression = readByte() == 1;\n+          }\n+          if (smallLen == -2) {\n+            String filename = readString();\n+            return ValueLob.openUnlinked(type == BLOB ? Value.BLOB : Value.CLOB, handler, tableId,\n+                objectId, precision, compression, filename);\n+          }\n+          return ValueLob.openLinked(type == BLOB ? Value.BLOB : Value.CLOB, handler, tableId,\n+              objectId, precision, compression);\n+        }\n+      }\n+      case ARRAY:\n+      case ROW: // Special storage type for ValueRow\n+      {\n+        int len = readVarInt();\n+        Value[] list = new Value[len];\n+        for (int i = 0; i < len; i++) {\n+          list[i] = readValue();\n+        }\n+        return type == ARRAY ? ValueArray.get(list) : ValueRow.get(list);\n+      }\n+      case RESULT_SET: {\n+        SimpleResult rs = new SimpleResult();\n+        int columns = readVarInt();\n+        for (int i = 0; i < columns; i++) {\n+          rs.addColumn(readString(), readString(), readVarInt(), readVarLong(), readVarInt());\n+        }\n+        while (readByte() != 0) {\n+          Value[] o = new Value[columns];\n+          for (int i = 0; i < columns; i++) {\n+            o[i] = readValue();\n+          }\n+          rs.addRow(o);\n+        }\n+        return ValueResultSet.get(rs);\n+      }\n+      case INTERVAL: {\n+        int ordinal = readByte();\n+        boolean negative = ordinal < 0;\n+        if (negative) {\n+          ordinal = ~ordinal;\n+        }\n+        return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readVarLong(),\n+            ordinal < 5 ? 0 : readVarLong());\n+      }\n+      case CUSTOM_DATA_TYPE: {\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          int customType = readVarInt();\n+          int len = readVarInt();\n+          byte[] b = Utils.newBytes(len);\n+          read(b, 0, len);\n+          return JdbcUtils.customDataTypesHandler.convert(\n+              ValueBytes.getNoCopy(b), customType);\n+        }\n+        throw DbException.get(ErrorCode.UNKNOWN_DATA_TYPE_1,\n+            \"No CustomDataTypesHandler has been set up\");\n+      }\n+      case JSON: {\n+        String s = readString();\n+        return ValueJson.get(s);\n+      }\n+      default:\n+        if (type >= INT_0_15 && type < INT_0_15 + 16) {\n+          return ValueInt.get(type - INT_0_15);\n+        } else if (type >= LONG_0_7 && type < LONG_0_7 + 8) {\n+          return ValueLong.get(type - LONG_0_7);\n+        } else if (type >= BYTES_0_31 && type < BYTES_0_31 + 32) {\n+          int len = type - BYTES_0_31;\n+          byte[] b = Utils.newBytes(len);\n+          read(b, 0, len);\n+          return ValueBytes.getNoCopy(b);\n+        } else if (type >= STRING_0_31 && type < STRING_0_31 + 32) {\n+          return ValueString.get(readString(type - STRING_0_31));\n+        }\n+        throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n     }\n+  }\n \n-    /**\n-     * Calculate the number of bytes required to encode the given value.\n-     *\n-     * @param v the value\n-     * @param storeLocalTime\n-     *            calculate size of DATE, TIME, and TIMESTAMP values with local\n-     *            time storage format\n-     * @return the number of bytes required to store this value\n-     */\n-    public static int getValueLen(Value v, boolean storeLocalTime) {\n-        if (v == ValueNull.INSTANCE) {\n-            return 1;\n-        }\n-        switch (v.getValueType()) {\n-        case Value.BOOLEAN:\n-            return 1;\n-        case Value.BYTE:\n-            return 2;\n-        case Value.SHORT:\n-            return 3;\n-        case Value.ENUM:\n-        case Value.INT: {\n-            int x = v.getInt();\n-            if (x < 0) {\n-                return 1 + getVarIntLen(-x);\n-            } else if (x < 16) {\n-                return 1;\n-            } else {\n-                return 1 + getVarIntLen(x);\n-            }\n-        }\n-        case Value.LONG: {\n-            long x = v.getLong();\n-            if (x < 0) {\n-                return 1 + getVarLongLen(-x);\n-            } else if (x < 8) {\n-                return 1;\n-            } else {\n-                return 1 + getVarLongLen(x);\n-            }\n-        }\n-        case Value.DOUBLE: {\n-            double x = v.getDouble();\n-            if (x == 1.0d) {\n-                return 1;\n-            }\n-            long d = Double.doubleToLongBits(x);\n-            if (d == ValueDouble.ZERO_BITS) {\n-                return 1;\n-            }\n-            return 1 + getVarLongLen(Long.reverse(d));\n-        }\n-        case Value.FLOAT: {\n-            float x = v.getFloat();\n-            if (x == 1.0f) {\n-                return 1;\n-            }\n-            int f = Float.floatToIntBits(x);\n-            if (f == ValueFloat.ZERO_BITS) {\n-                return 1;\n-            }\n-            return 1 + getVarIntLen(Integer.reverse(f));\n-        }\n-        case Value.STRING: {\n-            String s = v.getString();\n-            int len = s.length();\n-            if (len < 32) {\n-                return 1 + getStringWithoutLengthLen(s, len);\n-            }\n-            return 1 + getStringLen(s);\n-        }\n-        case Value.STRING_IGNORECASE:\n-        case Value.STRING_FIXED:\n-            return 1 + getStringLen(v.getString());\n-        case Value.DECIMAL: {\n-            BigDecimal x = v.getBigDecimal();\n-            if (BigDecimal.ZERO.equals(x)) {\n-                return 1;\n-            } else if (BigDecimal.ONE.equals(x)) {\n-                return 1;\n-            }\n-            int scale = x.scale();\n-            BigInteger b = x.unscaledValue();\n-            int bits = b.bitLength();\n-            if (bits <= 63) {\n-                if (scale == 0) {\n-                    return 1 + getVarLongLen(b.longValue());\n-                }\n-                return 1 + getVarIntLen(scale) + getVarLongLen(b.longValue());\n-            }\n-            byte[] bytes = b.toByteArray();\n-            return 1 + getVarIntLen(scale) + getVarIntLen(bytes.length) + bytes.length;\n-        }\n-        case Value.TIME:\n-            if (storeLocalTime) {\n-                long nanos = ((ValueTime) v).getNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                return 1 + getVarLongLen(millis) + getVarLongLen(nanos);\n-            }\n-            return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(v.getTime()));\n-        case Value.DATE: {\n-            if (storeLocalTime) {\n-                long dateValue = ((ValueDate) v).getDateValue();\n-                return 1 + getVarLongLen(dateValue);\n-            }\n-            long x = DateTimeUtils.getTimeLocalWithoutDst(v.getDate());\n-            return 1 + getVarLongLen(x / MILLIS_PER_MINUTE);\n-        }\n-        case Value.TIMESTAMP: {\n-            if (storeLocalTime) {\n-                ValueTimestamp ts = (ValueTimestamp) v;\n-                long dateValue = ts.getDateValue();\n-                long nanos = ts.getTimeNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                return 1 + getVarLongLen(dateValue) + getVarLongLen(millis) +\n-                        getVarLongLen(nanos);\n-            }\n-            Timestamp ts = v.getTimestamp();\n-            return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(ts)) +\n-                    getVarIntLen(ts.getNanos() % 1_000_000);\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            long dateValue = ts.getDateValue();\n-            long nanos = ts.getTimeNanos();\n-            short tz = ts.getTimeZoneOffsetMins();\n-            return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) +\n-                    getVarIntLen(tz);\n-        }\n-        case Value.GEOMETRY:\n-        case Value.JAVA_OBJECT: {\n-            byte[] b = v.getBytesNoCopy();\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        case Value.BYTES: {\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            if (len < 32) {\n-                return 1 + b.length;\n-            }\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        case Value.UUID:\n-            return 1 + LENGTH_LONG + LENGTH_LONG;\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            int len = 1;\n-            if (v instanceof ValueLob) {\n-                ValueLob lob = (ValueLob) v;\n-                byte[] small = lob.getSmall();\n-                if (small == null) {\n-                    int t = -1;\n-                    if (!lob.isLinkedToTable()) {\n-                        t = -2;\n-                    }\n-                    len += getVarIntLen(t);\n-                    len += getVarIntLen(lob.getTableId());\n-                    len += getVarIntLen(lob.getObjectId());\n-                    len += getVarLongLen(lob.getType().getPrecision());\n-                    len += 1;\n-                    if (t == -2) {\n-                        len += getStringLen(lob.getFileName());\n-                    }\n-                } else {\n-                    len += getVarIntLen(small.length);\n-                    len += small.length;\n-                }\n-            } else {\n-                ValueLobDb lob = (ValueLobDb) v;\n-                byte[] small = lob.getSmall();\n-                if (small == null) {\n-                    len += getVarIntLen(-3);\n-                    len += getVarIntLen(lob.getTableId());\n-                    len += getVarLongLen(lob.getLobId());\n-                    len += getVarLongLen(lob.getType().getPrecision());\n-                } else {\n-                    len += getVarIntLen(small.length);\n-                    len += small.length;\n-                }\n-            }\n-            return len;\n-        }\n-        case Value.ARRAY:\n-        case Value.ROW: {\n-            Value[] list = ((ValueCollectionBase) v).getList();\n-            int len = 1 + getVarIntLen(list.length);\n-            for (Value x : list) {\n-                len += getValueLen(x, storeLocalTime);\n-            }\n-            return len;\n-        }\n-        case Value.RESULT_SET: {\n-            int len = 1;\n-            ResultInterface result = ((ValueResultSet) v).getResult();\n-            int columnCount = result.getVisibleColumnCount();\n-            len += getVarIntLen(columnCount);\n-            for (int i = 0; i < columnCount; i++) {\n-                len += getStringLen(result.getAlias(i));\n-                len += getStringLen(result.getColumnName(i));\n-                TypeInfo columnType = result.getColumnType(i);\n-                len += getVarIntLen(columnType.getValueType());\n-                len += getVarLongLen(columnType.getPrecision());\n-                len += getVarIntLen(columnType.getScale());\n-            }\n-            while (result.next()) {\n-                len++;\n-                Value[] row = result.currentRow();\n-                for (int i = 0; i < columnCount; i++) {\n-                    Value val = row[i];\n-                    len += getValueLen(val, storeLocalTime);\n-                }\n+  /**\n+   * Calculate the number of bytes required to encode the given value.\n+   *\n+   * @param v the value\n+   * @return the number of bytes required to store this value\n+   */\n+  public int getValueLen(Value v) {\n+    return getValueLen(v, storeLocalTime);\n+  }\n+\n+  /**\n+   * Calculate the number of bytes required to encode the given value.\n+   *\n+   * @param v              the value\n+   * @param storeLocalTime calculate size of DATE, TIME, and TIMESTAMP values with local\n+   *                       time storage format\n+   * @return the number of bytes required to store this value\n+   */\n+  public static int getValueLen(Value v, boolean storeLocalTime) {\n+    if (v == ValueNull.INSTANCE) {\n+      return 1;\n+    }\n+    switch (v.getValueType()) {\n+      case Value.BOOLEAN:\n+        return 1;\n+      case Value.BYTE:\n+        return 2;\n+      case Value.SHORT:\n+        return 3;\n+      case Value.ENUM:\n+      case Value.INT: {\n+        int x = v.getInt();\n+        if (x < 0) {\n+          return 1 + getVarIntLen(-x);\n+        } else if (x < 16) {\n+          return 1;\n+        } else {\n+          return 1 + getVarIntLen(x);\n+        }\n+      }\n+      case Value.LONG: {\n+        long x = v.getLong();\n+        if (x < 0) {\n+          return 1 + getVarLongLen(-x);\n+        } else if (x < 8) {\n+          return 1;\n+        } else {\n+          return 1 + getVarLongLen(x);\n+        }\n+      }\n+      case Value.DOUBLE: {\n+        double x = v.getDouble();\n+        if (x == 1.0d) {\n+          return 1;\n+        }\n+        long d = Double.doubleToLongBits(x);\n+        if (d == ValueDouble.ZERO_BITS) {\n+          return 1;\n+        }\n+        return 1 + getVarLongLen(Long.reverse(d));\n+      }\n+      case Value.FLOAT: {\n+        float x = v.getFloat();\n+        if (x == 1.0f) {\n+          return 1;\n+        }\n+        int f = Float.floatToIntBits(x);\n+        if (f == ValueFloat.ZERO_BITS) {\n+          return 1;\n+        }\n+        return 1 + getVarIntLen(Integer.reverse(f));\n+      }\n+      case Value.STRING: {\n+        String s = v.getString();\n+        int len = s.length();\n+        if (len < 32) {\n+          return 1 + getStringWithoutLengthLen(s, len);\n+        }\n+        return 1 + getStringLen(s);\n+      }\n+      case Value.STRING_IGNORECASE:\n+      case Value.STRING_FIXED:\n+        return 1 + getStringLen(v.getString());\n+      case Value.DECIMAL: {\n+        BigDecimal x = v.getBigDecimal();\n+        if (BigDecimal.ZERO.equals(x)) {\n+          return 1;\n+        } else if (BigDecimal.ONE.equals(x)) {\n+          return 1;\n+        }\n+        int scale = x.scale();\n+        BigInteger b = x.unscaledValue();\n+        int bits = b.bitLength();\n+        if (bits <= 63) {\n+          if (scale == 0) {\n+            return 1 + getVarLongLen(b.longValue());\n+          }\n+          return 1 + getVarIntLen(scale) + getVarLongLen(b.longValue());\n+        }\n+        byte[] bytes = b.toByteArray();\n+        return 1 + getVarIntLen(scale) + getVarIntLen(bytes.length) + bytes.length;\n+      }\n+      case Value.TIME:\n+        if (storeLocalTime) {\n+          long nanos = ((ValueTime) v).getNanos();\n+          long millis = nanos / 1_000_000;\n+          nanos -= millis * 1_000_000;\n+          return 1 + getVarLongLen(millis) + getVarLongLen(nanos);\n+        }\n+        return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(v.getTime()));\n+      case Value.DATE: {\n+        if (storeLocalTime) {\n+          long dateValue = ((ValueDate) v).getDateValue();\n+          return 1 + getVarLongLen(dateValue);\n+        }\n+        long x = DateTimeUtils.getTimeLocalWithoutDst(v.getDate());\n+        return 1 + getVarLongLen(x / MILLIS_PER_MINUTE);\n+      }\n+      case Value.TIMESTAMP: {\n+        if (storeLocalTime) {\n+          ValueTimestamp ts = (ValueTimestamp) v;\n+          long dateValue = ts.getDateValue();\n+          long nanos = ts.getTimeNanos();\n+          long millis = nanos / 1_000_000;\n+          nanos -= millis * 1_000_000;\n+          return 1 + getVarLongLen(dateValue) + getVarLongLen(millis) +\n+              getVarLongLen(nanos);\n+        }\n+        Timestamp ts = v.getTimestamp();\n+        return 1 + getVarLongLen(DateTimeUtils.getTimeLocalWithoutDst(ts)) +\n+            getVarIntLen(ts.getNanos() % 1_000_000);\n+      }\n+      case Value.TIMESTAMP_TZ: {\n+        ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+        long dateValue = ts.getDateValue();\n+        long nanos = ts.getTimeNanos();\n+        short tz = ts.getTimeZoneOffsetMins();\n+        return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) +\n+            getVarIntLen(tz);\n+      }\n+      case Value.GEOMETRY:\n+      case Value.JAVA_OBJECT: {\n+        byte[] b = v.getBytesNoCopy();\n+        return 1 + getVarIntLen(b.length) + b.length;\n+      }\n+      case Value.BYTES: {\n+        byte[] b = v.getBytesNoCopy();\n+        int len = b.length;\n+        if (len < 32) {\n+          return 1 + b.length;\n+        }\n+        return 1 + getVarIntLen(b.length) + b.length;\n+      }\n+      case Value.UUID:\n+        return 1 + LENGTH_LONG + LENGTH_LONG;\n+      case Value.BLOB:\n+      case Value.CLOB: {\n+        int len = 1;\n+        if (v instanceof ValueLob) {\n+          ValueLob lob = (ValueLob) v;\n+          byte[] small = lob.getSmall();\n+          if (small == null) {\n+            int t = -1;\n+            if (!lob.isLinkedToTable()) {\n+              t = -2;\n             }\n-            len++;\n-            return len;\n-        }\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE: {\n-            ValueInterval interval = (ValueInterval) v;\n-            return 2 + getVarLongLen(interval.getLeading());\n-        }\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND: {\n-            ValueInterval interval = (ValueInterval) v;\n-            return 2 + getVarLongLen(interval.getLeading()) + getVarLongLen(interval.getRemaining());\n-        }\n-        case Value.JSON:\n-            String s = v.getString();\n-            return 1 + getStringLen(s);\n-        default:\n-            if (JdbcUtils.customDataTypesHandler != null) {\n-                byte[] b = v.getBytesNoCopy();\n-                return 1 + getVarIntLen(v.getValueType())\n-                    + getVarIntLen(b.length) + b.length;\n+            len += getVarIntLen(t);\n+            len += getVarIntLen(lob.getTableId());\n+            len += getVarIntLen(lob.getObjectId());\n+            len += getVarLongLen(lob.getType().getPrecision());\n+            len += 1;\n+            if (t == -2) {\n+              len += getStringLen(lob.getFileName());\n             }\n-            throw DbException.throwInternalError(\"type=\" + v.getValueType());\n-        }\n+          } else {\n+            len += getVarIntLen(small.length);\n+            len += small.length;\n+          }\n+        } else {\n+          ValueLobDb lob = (ValueLobDb) v;\n+          byte[] small = lob.getSmall();\n+          if (small == null) {\n+            len += getVarIntLen(-3);\n+            len += getVarIntLen(lob.getTableId());\n+            len += getVarLongLen(lob.getLobId());\n+            len += getVarLongLen(lob.getType().getPrecision());\n+          } else {\n+            len += getVarIntLen(small.length);\n+            len += small.length;\n+          }\n+        }\n+        return len;\n+      }\n+      case Value.ARRAY:\n+      case Value.ROW: {\n+        Value[] list = ((ValueCollectionBase) v).getList();\n+        int len = 1 + getVarIntLen(list.length);\n+        for (Value x : list) {\n+          len += getValueLen(x, storeLocalTime);\n+        }\n+        return len;\n+      }\n+      case Value.RESULT_SET: {\n+        int len = 1;\n+        ResultInterface result = ((ValueResultSet) v).getResult();\n+        int columnCount = result.getVisibleColumnCount();\n+        len += getVarIntLen(columnCount);\n+        for (int i = 0; i < columnCount; i++) {\n+          len += getStringLen(result.getAlias(i));\n+          len += getStringLen(result.getColumnName(i));\n+          TypeInfo columnType = result.getColumnType(i);\n+          len += getVarIntLen(columnType.getValueType());\n+          len += getVarLongLen(columnType.getPrecision());\n+          len += getVarIntLen(columnType.getScale());\n+        }\n+        while (result.next()) {\n+          len++;\n+          Value[] row = result.currentRow();\n+          for (int i = 0; i < columnCount; i++) {\n+            Value val = row[i];\n+            len += getValueLen(val, storeLocalTime);\n+          }\n+        }\n+        len++;\n+        return len;\n+      }\n+      case Value.INTERVAL_YEAR:\n+      case Value.INTERVAL_MONTH:\n+      case Value.INTERVAL_DAY:\n+      case Value.INTERVAL_HOUR:\n+      case Value.INTERVAL_MINUTE: {\n+        ValueInterval interval = (ValueInterval) v;\n+        return 2 + getVarLongLen(interval.getLeading());\n+      }\n+      case Value.INTERVAL_SECOND:\n+      case Value.INTERVAL_YEAR_TO_MONTH:\n+      case Value.INTERVAL_DAY_TO_HOUR:\n+      case Value.INTERVAL_DAY_TO_MINUTE:\n+      case Value.INTERVAL_DAY_TO_SECOND:\n+      case Value.INTERVAL_HOUR_TO_MINUTE:\n+      case Value.INTERVAL_HOUR_TO_SECOND:\n+      case Value.INTERVAL_MINUTE_TO_SECOND: {\n+        ValueInterval interval = (ValueInterval) v;\n+        return 2 + getVarLongLen(interval.getLeading()) + getVarLongLen(interval.getRemaining());\n+      }\n+      case Value.JSON:\n+        String s = v.getString();\n+        return 1 + getStringLen(s);\n+      default:\n+        if (JdbcUtils.customDataTypesHandler != null) {\n+          byte[] b = v.getBytesNoCopy();\n+          return 1 + getVarIntLen(v.getValueType())\n+              + getVarIntLen(b.length) + b.length;\n+        }\n+        throw DbException.throwInternalError(\"type=\" + v.getValueType());\n     }\n+  }\n \n-    /**\n-     * Set the current read / write position.\n-     *\n-     * @param pos the new position\n-     */\n-    public void setPos(int pos) {\n-        this.pos = pos;\n-    }\n+  /**\n+   * Set the current read / write position.\n+   *\n+   * @param pos the new position\n+   */\n+  public void setPos(int pos) {\n+    this.pos = pos;\n+  }\n \n-    /**\n-     * Write a short integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @param x the value\n-     */\n-    public void writeShortInt(int x) {\n-        byte[] buff = data;\n-        buff[pos++] = (byte) (x >> 8);\n-        buff[pos++] = (byte) x;\n-    }\n+  /**\n+   * Write a short integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @param x the value\n+   */\n+  public void writeShortInt(int x) {\n+    byte[] buff = data;\n+    buff[pos++] = (byte) (x >> 8);\n+    buff[pos++] = (byte) x;\n+  }\n \n-    /**\n-     * Read an short integer at the current position.\n-     * The current position is incremented.\n-     *\n-     * @return the value\n-     */\n-    public short readShortInt() {\n-        byte[] buff = data;\n-        return (short) (((buff[pos++] & 0xff) << 8) + (buff[pos++] & 0xff));\n-    }\n+  /**\n+   * Read an short integer at the current position.\n+   * The current position is incremented.\n+   *\n+   * @return the value\n+   */\n+  public short readShortInt() {\n+    byte[] buff = data;\n+    return (short) (((buff[pos++] & 0xff) << 8) + (buff[pos++] & 0xff));\n+  }\n \n-    /**\n-     * Shrink the array to this size.\n-     *\n-     * @param size the new size\n-     */\n-    public void truncate(int size) {\n-        if (pos > size) {\n-            byte[] buff = Arrays.copyOf(data, size);\n-            this.pos = size;\n-            data = buff;\n-        }\n+  /**\n+   * Shrink the array to this size.\n+   *\n+   * @param size the new size\n+   */\n+  public void truncate(int size) {\n+    if (pos > size) {\n+      byte[] buff = Arrays.copyOf(data, size);\n+      this.pos = size;\n+      data = buff;\n     }\n+  }\n \n-    /**\n-     * The number of bytes required for a variable size int.\n-     *\n-     * @param x the value\n-     * @return the len\n-     */\n-    private static int getVarIntLen(int x) {\n-        if ((x & (-1 << 7)) == 0) {\n-            return 1;\n-        } else if ((x & (-1 << 14)) == 0) {\n-            return 2;\n-        } else if ((x & (-1 << 21)) == 0) {\n-            return 3;\n-        } else if ((x & (-1 << 28)) == 0) {\n-            return 4;\n-        }\n-        return 5;\n+  /**\n+   * The number of bytes required for a variable size int.\n+   *\n+   * @param x the value\n+   * @return the len\n+   */\n+  private static int getVarIntLen(int x) {\n+    if ((x & (-1 << 7)) == 0) {\n+      return 1;\n+    } else if ((x & (-1 << 14)) == 0) {\n+      return 2;\n+    } else if ((x & (-1 << 21)) == 0) {\n+      return 3;\n+    } else if ((x & (-1 << 28)) == 0) {\n+      return 4;\n     }\n+    return 5;\n+  }\n \n-    /**\n-     * Write a variable size int.\n-     *\n-     * @param x the value\n-     */\n-    public void writeVarInt(int x) {\n-        while ((x & ~0x7f) != 0) {\n-            data[pos++] = (byte) (x | 0x80);\n-            x >>>= 7;\n-        }\n-        data[pos++] = (byte) x;\n+  /**\n+   * Write a variable size int.\n+   *\n+   * @param x the value\n+   */\n+  public void writeVarInt(int x) {\n+    while ((x & ~0x7f) != 0) {\n+      data[pos++] = (byte) (x | 0x80);\n+      x >>>= 7;\n     }\n+    data[pos++] = (byte) x;\n+  }\n \n-    /**\n-     * Read a variable size int.\n-     *\n-     * @return the value\n-     */\n-    public int readVarInt() {\n-        int b = data[pos];\n-        if (b >= 0) {\n-            pos++;\n-            return b;\n-        }\n-        // a separate function so that this one can be inlined\n-        return readVarIntRest(b);\n+  /**\n+   * Read a variable size int.\n+   *\n+   * @return the value\n+   */\n+  public int readVarInt() {\n+    int b = data[pos];\n+    if (b >= 0) {\n+      pos++;\n+      return b;\n     }\n+    // a separate function so that this one can be inlined\n+    return readVarIntRest(b);\n+  }\n \n-    private int readVarIntRest(int b) {\n-        int x = b & 0x7f;\n-        b = data[pos + 1];\n-        if (b >= 0) {\n-            pos += 2;\n-            return x | (b << 7);\n-        }\n-        x |= (b & 0x7f) << 7;\n-        b = data[pos + 2];\n-        if (b >= 0) {\n-            pos += 3;\n-            return x | (b << 14);\n-        }\n-        x |= (b & 0x7f) << 14;\n-        b = data[pos + 3];\n-        if (b >= 0) {\n-            pos += 4;\n-            return x | b << 21;\n-        }\n-        x |= ((b & 0x7f) << 21) | (data[pos + 4] << 28);\n-        pos += 5;\n-        return x;\n+  private int readVarIntRest(int b) {\n+    int x = b & 0x7f;\n+    b = data[pos + 1];\n+    if (b >= 0) {\n+      pos += 2;\n+      return x | (b << 7);\n     }\n-\n-    /**\n-     * The number of bytes required for a variable size long.\n-     *\n-     * @param x the value\n-     * @return the len\n-     */\n-    public static int getVarLongLen(long x) {\n-        int i = 1;\n-        while (true) {\n-            x >>>= 7;\n-            if (x == 0) {\n-                return i;\n-            }\n-            i++;\n-        }\n+    x |= (b & 0x7f) << 7;\n+    b = data[pos + 2];\n+    if (b >= 0) {\n+      pos += 3;\n+      return x | (b << 14);\n     }\n-\n-    /**\n-     * Write a variable size long.\n-     *\n-     * @param x the value\n-     */\n-    public void writeVarLong(long x) {\n-        while ((x & ~0x7f) != 0) {\n-            data[pos++] = (byte) (x | 0x80);\n-            x >>>= 7;\n-        }\n-        data[pos++] = (byte) x;\n+    x |= (b & 0x7f) << 14;\n+    b = data[pos + 3];\n+    if (b >= 0) {\n+      pos += 4;\n+      return x | b << 21;\n     }\n+    x |= ((b & 0x7f) << 21) | (data[pos + 4] << 28);\n+    pos += 5;\n+    return x;\n+  }\n \n-    /**\n-     * Read a variable size long.\n-     *\n-     * @return the value\n-     */\n-    public long readVarLong() {\n-        long x = data[pos++];\n-        if (x >= 0) {\n-            return x;\n-        }\n-        x &= 0x7f;\n-        for (int s = 7;; s += 7) {\n-            long b = data[pos++];\n-            x |= (b & 0x7f) << s;\n-            if (b >= 0) {\n-                return x;\n-            }\n-        }\n+  /**\n+   * The number of bytes required for a variable size long.\n+   *\n+   * @param x the value\n+   * @return the len\n+   */\n+  public static int getVarLongLen(long x) {\n+    int i = 1;\n+    while (true) {\n+      x >>>= 7;\n+      if (x == 0) {\n+        return i;\n+      }\n+      i++;\n     }\n+  }\n \n-    /**\n-     * Check if there is still enough capacity in the buffer.\n-     * This method extends the buffer if required.\n-     *\n-     * @param plus the number of additional bytes required\n-     */\n-    public void checkCapacity(int plus) {\n-        if (pos + plus >= data.length) {\n-            // a separate method to simplify inlining\n-            expand(plus);\n-        }\n+  /**\n+   * Write a variable size long.\n+   *\n+   * @param x the value\n+   */\n+  public void writeVarLong(long x) {\n+    while ((x & ~0x7f) != 0) {\n+      data[pos++] = (byte) (x | 0x80);\n+      x >>>= 7;\n     }\n+    data[pos++] = (byte) x;\n+  }\n \n-    private void expand(int plus) {\n-        // must copy everything, because pos could be 0 and data may be\n-        // still required\n-        data = Utils.copyBytes(data, (data.length + plus) * 2);\n+  /**\n+   * Read a variable size long.\n+   *\n+   * @return the value\n+   */\n+  public long readVarLong() {\n+    long x = data[pos++];\n+    if (x >= 0) {\n+      return x;\n+    }\n+    x &= 0x7f;\n+    for (int s = 7; ; s += 7) {\n+      long b = data[pos++];\n+      x |= (b & 0x7f) << s;\n+      if (b >= 0) {\n+        return x;\n+      }\n     }\n+  }\n \n-    /**\n-     * Fill up the buffer with empty space and an (initially empty) checksum\n-     * until the size is a multiple of Constants.FILE_BLOCK_SIZE.\n-     */\n-    public void fillAligned() {\n-        // 0..6 > 8, 7..14 > 16, 15..22 > 24, ...\n-        int len = MathUtils.roundUpInt(pos + 2, Constants.FILE_BLOCK_SIZE);\n-        pos = len;\n-        if (data.length < len) {\n-            checkCapacity(len - data.length);\n-        }\n+  /**\n+   * Check if there is still enough capacity in the buffer.\n+   * This method extends the buffer if required.\n+   *\n+   * @param plus the number of additional bytes required\n+   */\n+  public void checkCapacity(int plus) {\n+    if (pos + plus >= data.length) {\n+      // a separate method to simplify inlining\n+      expand(plus);\n     }\n+  }\n \n-    /**\n-     * Copy a String from a reader to an output stream.\n-     *\n-     * @param source the reader\n-     * @param target the output stream\n-     */\n-    public static void copyString(Reader source, OutputStream target)\n-            throws IOException {\n-        char[] buff = new char[Constants.IO_BUFFER_SIZE];\n-        Data d = new Data(null, new byte[3 * Constants.IO_BUFFER_SIZE], false);\n-        while (true) {\n-            int l = source.read(buff);\n-            if (l < 0) {\n-                break;\n-            }\n-            d.writeStringWithoutLength(buff, l);\n-            target.write(d.data, 0, d.pos);\n-            d.reset();\n-        }\n+  private void expand(int plus) {\n+    // must copy everything, because pos could be 0 and data may be\n+    // still required\n+    data = Utils.copyBytes(data, (data.length + plus) * 2);\n+  }\n+\n+  /**\n+   * Fill up the buffer with empty space and an (initially empty) checksum\n+   * until the size is a multiple of Constants.FILE_BLOCK_SIZE.\n+   */\n+  public void fillAligned() {\n+    // 0..6 > 8, 7..14 > 16, 15..22 > 24, ...\n+    int len = MathUtils.roundUpInt(pos + 2, Constants.FILE_BLOCK_SIZE);\n+    pos = len;\n+    if (data.length < len) {\n+      checkCapacity(len - data.length);\n     }\n+  }\n \n-    public DataHandler getHandler() {\n-        return handler;\n+  /**\n+   * Copy a String from a reader to an output stream.\n+   *\n+   * @param source the reader\n+   * @param target the output stream\n+   */\n+  public static void copyString(Reader source, OutputStream target)\n+      throws IOException {\n+    char[] buff = new char[Constants.IO_BUFFER_SIZE];\n+    Data d = new Data(null, new byte[3 * Constants.IO_BUFFER_SIZE], false);\n+    while (true) {\n+      int l = source.read(buff);\n+      if (l < 0) {\n+        break;\n+      }\n+      d.writeStringWithoutLength(buff, l);\n+      target.write(d.data, 0, d.pos);\n+      d.reset();\n     }\n+  }\n+\n+  public DataHandler getHandler() {\n+    return handler;\n+  }\n \n }\n",
            "diff_size": 1922
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "927",
                    "column": "18",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/235/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/235/Data.java\nindex bd50ecf0d5c..0d6e8ba7b20 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/235/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_random/235/Data.java\n@@ -924,7 +924,7 @@ public class Data {\n             }\n         }\n         case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n+        case ROW:// Special storage type for ValueRow\n         {\n             int len = readVarInt();\n             Value[] list = new Value[len];\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/235/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/235/Data.java\nindex bd50ecf0d5c..d261228165a 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/errored/1/235/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/codefollower-H2-Research/styler_three_grams/235/Data.java\n@@ -924,8 +924,9 @@ public class Data {\n             }\n         }\n         case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n-        {\n+        case ROW:\n+        // Special storage type for ValueRow\n+{\n             int len = readVarInt();\n             Value[] list = new Value[len];\n             for (int i = 0; i < len; i++) {\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}