{
    "project_name": "NationalSecurityAgency-datawave",
    "error_id": "53",
    "information": {
        "errors": [
            {
                "line": "29",
                "severity": "error",
                "message": "Accumulo non-public classes imported",
                "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
            }
        ]
    },
    "source_code": "import org.apache.accumulo.core.data.Range;\nimport org.apache.accumulo.core.data.Value;\nimport org.apache.accumulo.core.util.PeekingIterator;\nimport org.apache.commons.jexl2.parser.JexlNode;\n\nimport com.google.common.base.Function;",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "29",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "29",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/53/ShardRangeStream.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/53/ShardRangeStream.java\nindex f2a15daf8f9..4156a8de245 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/53/ShardRangeStream.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/intellij/53/ShardRangeStream.java\n@@ -33,97 +33,102 @@ import com.google.common.base.Function;\n import com.google.common.collect.Iterators;\n \n public class ShardRangeStream extends RangeStream {\n-    \n-    public ShardRangeStream(ShardQueryConfiguration config, ScannerFactory scanners, MetadataHelper helper) {\n-        super(config, scanners, helper);\n-    }\n-    \n-    @Override\n-    public CloseableIterable<QueryPlan> streamPlans(JexlNode node) {\n-        try {\n-            String queryString = JexlStringBuildingVisitor.buildQuery(node);\n-            \n-            int stackStart = config.getBaseIteratorPriority() + 40;\n-            BatchScanner scanner = scanners.newScanner(config.getShardTableName(), config.getAuthorizations(), config.getNumQueryThreads(), config.getQuery(),\n-                            true);\n-            \n-            IteratorSetting cfg = new IteratorSetting(stackStart++, \"query\", FieldIndexOnlyQueryIterator.class);\n-            \n-            DefaultQueryPlanner.addOption(cfg, QueryOptions.QUERY, queryString, false);\n-            \n-            try {\n-                DefaultQueryPlanner.addOption(cfg, QueryOptions.INDEX_ONLY_FIELDS,\n-                                QueryOptions.buildFieldStringFromSet(metadataHelper.getIndexOnlyFields(config.getDatatypeFilter())), true);\n-                DefaultQueryPlanner.addOption(cfg, QueryOptions.INDEXED_FIELDS,\n-                                QueryOptions.buildFieldStringFromSet(metadataHelper.getIndexedFields(config.getDatatypeFilter())), true);\n-            } catch (TableNotFoundException e) {\n-                throw new RuntimeException(e);\n-            }\n-            \n-            DefaultQueryPlanner.addOption(cfg, QueryOptions.START_TIME, Long.toString(config.getBeginDate().getTime()), false);\n-            DefaultQueryPlanner.addOption(cfg, QueryOptions.DATATYPE_FILTER, config.getDatatypeFilterAsString(), false);\n-            DefaultQueryPlanner.addOption(cfg, QueryOptions.END_TIME, Long.toString(config.getEndDate().getTime()), false);\n-            \n-            DefaultQueryPlanner.configureTypeMappings(config, cfg, metadataHelper, true);\n-            \n-            scanner.setRanges(Collections.singleton(rangeForTerm(null, null, config)));\n-            \n-            scanner.addScanIterator(cfg);\n-            \n-            Iterator<Entry<Key,Value>> kvIter = scanner.iterator();\n-            \n-            itr = Collections.emptyIterator();\n-            \n-            if (kvIter.hasNext()) {\n-                PeekingIterator<Entry<Key,Value>> peeking = new PeekingIterator<>(kvIter);\n-                Entry<Key,Value> peekKey = peeking.peek();\n-                ErrorKey errorKey = ErrorKey.getErrorKey(peekKey.getKey());\n-                if (errorKey != null) {\n-                    switch (errorKey.getErrorType()) {\n-                        case UNINDEXED_FIELD:\n-                            this.context = StreamContext.UNINDEXED;\n-                            break;\n-                        case UNKNOWN:\n-                            this.context = StreamContext.ABSENT;\n-                    }\n-                } else {\n-                    itr = Iterators.transform(peeking, new FieldIndexParser(node));\n-                    this.context = StreamContext.PRESENT;\n-                }\n-                \n-            } else {\n-                this.context = StreamContext.ABSENT;\n-                \n-            }\n-            \n-        } catch (TableNotFoundException | DatawaveQueryException e) {\n-            throw new RuntimeException(e);\n-        } finally {\n-            // shut down the executor as all threads have completed\n-            shutdownThreads();\n+\n+  public ShardRangeStream(ShardQueryConfiguration config, ScannerFactory scanners, MetadataHelper helper) {\n+    super(config, scanners, helper);\n+  }\n+\n+  @Override\n+  public CloseableIterable<QueryPlan> streamPlans(JexlNode node) {\n+    try {\n+      String queryString = JexlStringBuildingVisitor.buildQuery(node);\n+\n+      int stackStart = config.getBaseIteratorPriority() + 40;\n+      BatchScanner scanner = scanners\n+          .newScanner(config.getShardTableName(), config.getAuthorizations(), config.getNumQueryThreads(),\n+              config.getQuery(),\n+              true);\n+\n+      IteratorSetting cfg = new IteratorSetting(stackStart++, \"query\", FieldIndexOnlyQueryIterator.class);\n+\n+      DefaultQueryPlanner.addOption(cfg, QueryOptions.QUERY, queryString, false);\n+\n+      try {\n+        DefaultQueryPlanner.addOption(cfg, QueryOptions.INDEX_ONLY_FIELDS,\n+            QueryOptions.buildFieldStringFromSet(metadataHelper.getIndexOnlyFields(config.getDatatypeFilter())), true);\n+        DefaultQueryPlanner.addOption(cfg, QueryOptions.INDEXED_FIELDS,\n+            QueryOptions.buildFieldStringFromSet(metadataHelper.getIndexedFields(config.getDatatypeFilter())), true);\n+      } catch (TableNotFoundException e) {\n+        throw new RuntimeException(e);\n+      }\n+\n+      DefaultQueryPlanner\n+          .addOption(cfg, QueryOptions.START_TIME, Long.toString(config.getBeginDate().getTime()), false);\n+      DefaultQueryPlanner.addOption(cfg, QueryOptions.DATATYPE_FILTER, config.getDatatypeFilterAsString(), false);\n+      DefaultQueryPlanner.addOption(cfg, QueryOptions.END_TIME, Long.toString(config.getEndDate().getTime()), false);\n+\n+      DefaultQueryPlanner.configureTypeMappings(config, cfg, metadataHelper, true);\n+\n+      scanner.setRanges(Collections.singleton(rangeForTerm(null, null, config)));\n+\n+      scanner.addScanIterator(cfg);\n+\n+      Iterator<Entry<Key, Value>> kvIter = scanner.iterator();\n+\n+      itr = Collections.emptyIterator();\n+\n+      if (kvIter.hasNext()) {\n+        PeekingIterator<Entry<Key, Value>> peeking = new PeekingIterator<>(kvIter);\n+        Entry<Key, Value> peekKey = peeking.peek();\n+        ErrorKey errorKey = ErrorKey.getErrorKey(peekKey.getKey());\n+        if (errorKey != null) {\n+          switch (errorKey.getErrorType()) {\n+            case UNINDEXED_FIELD:\n+              this.context = StreamContext.UNINDEXED;\n+              break;\n+            case UNKNOWN:\n+              this.context = StreamContext.ABSENT;\n+          }\n+        } else {\n+          itr = Iterators.transform(peeking, new FieldIndexParser(node));\n+          this.context = StreamContext.PRESENT;\n         }\n-        \n-        return this;\n+\n+      } else {\n+        this.context = StreamContext.ABSENT;\n+\n+      }\n+\n+    } catch (TableNotFoundException | DatawaveQueryException e) {\n+      throw new RuntimeException(e);\n+    } finally {\n+      // shut down the executor as all threads have completed\n+      shutdownThreads();\n     }\n-    \n-    @Override\n-    public Range rangeForTerm(String term, String field, Date start, Date end) {\n-        return new Range(new Key(DateHelper.format(start) + \"_\"), false, new Key(DateHelper.format(end) + \"_\" + '\\uffff'), false);\n+\n+    return this;\n+  }\n+\n+  @Override\n+  public Range rangeForTerm(String term, String field, Date start, Date end) {\n+    return new Range(new Key(DateHelper.format(start) + \"_\"), false, new Key(DateHelper.format(end) + \"_\" + '\\uffff'),\n+        false);\n+  }\n+\n+  public class FieldIndexParser implements Function<Entry<Key, Value>, QueryPlan> {\n+    protected JexlNode node;\n+\n+    /**\n+     * @param node\n+     */\n+    public FieldIndexParser(JexlNode node) {\n+      this.node = node;\n     }\n-    \n-    public class FieldIndexParser implements Function<Entry<Key,Value>,QueryPlan> {\n-        protected JexlNode node;\n-        \n-        /**\n-         * @param node\n-         */\n-        public FieldIndexParser(JexlNode node) {\n-            this.node = node;\n-        }\n-        \n-        public QueryPlan apply(Entry<Key,Value> entry) {\n-            return new QueryPlan(node, new Range(new Key(entry.getKey().getRow(), entry.getKey().getColumnFamily()), true, entry.getKey().followingKey(\n-                            PartialKey.ROW_COLFAM), false));\n-        }\n+\n+    public QueryPlan apply(Entry<Key, Value> entry) {\n+      return new QueryPlan(node, new Range(new Key(entry.getKey().getRow(), entry.getKey().getColumnFamily()), true,\n+          entry.getKey().followingKey(\n+              PartialKey.ROW_COLFAM), false));\n     }\n+  }\n }\n",
            "diff_size": 113
        },
        {
            "tool": "naturalize",
            "errors": [
                {
                    "line": "29",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/53/ShardRangeStream.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/53/ShardRangeStream.java\nindex f2a15daf8f9..2132a225e15 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/53/ShardRangeStream.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/naturalize/53/ShardRangeStream.java\n@@ -44,8 +44,7 @@ public class ShardRangeStream extends RangeStream {\n             String queryString = JexlStringBuildingVisitor.buildQuery(node);\n             \n             int stackStart = config.getBaseIteratorPriority() + 40;\n-            BatchScanner scanner = scanners.newScanner(config.getShardTableName(), config.getAuthorizations(), config.getNumQueryThreads(), config.getQuery(),\n-                            true);\n+            BatchScanner scanner = scanners.newScanner(config.getShardTableName(), config.getAuthorizations(), config.getNumQueryThreads(), config.getQuery(), true);\n             \n             IteratorSetting cfg = new IteratorSetting(stackStart++, \"query\", FieldIndexOnlyQueryIterator.class);\n             \n@@ -126,4 +125,4 @@ public class ShardRangeStream extends RangeStream {\n                             PartialKey.ROW_COLFAM), false));\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 3
        },
        {
            "tool": "codebuff",
            "errors": [
                {
                    "line": "27",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/53/ShardRangeStream.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/53/ShardRangeStream.java\nindex f2a15daf8f9..a7afeb3eaaf 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/errored/1/53/ShardRangeStream.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/NationalSecurityAgency-datawave/codebuff/53/ShardRangeStream.java\n@@ -4,7 +4,6 @@ import java.util.Collections;\n import java.util.Date;\n import java.util.Iterator;\n import java.util.Map.Entry;\n-\n import datawave.query.config.ShardQueryConfiguration;\n import datawave.query.index.lookup.IndexStream.StreamContext;\n import datawave.query.CloseableIterable;\n@@ -18,7 +17,6 @@ import datawave.query.planner.QueryPlan;\n import datawave.query.tables.ScannerFactory;\n import datawave.query.util.MetadataHelper;\n import datawave.util.time.DateHelper;\n-\n import org.apache.accumulo.core.client.BatchScanner;\n import org.apache.accumulo.core.client.IteratorSetting;\n import org.apache.accumulo.core.client.TableNotFoundException;\n@@ -28,52 +26,41 @@ import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.util.PeekingIterator;\n import org.apache.commons.jexl2.parser.JexlNode;\n-\n import com.google.common.base.Function;\n import com.google.common.collect.Iterators;\n \n+\n public class ShardRangeStream extends RangeStream {\n-    \n     public ShardRangeStream(ShardQueryConfiguration config, ScannerFactory scanners, MetadataHelper helper) {\n         super(config, scanners, helper);\n     }\n-    \n+\n     @Override\n     public CloseableIterable<QueryPlan> streamPlans(JexlNode node) {\n         try {\n             String queryString = JexlStringBuildingVisitor.buildQuery(node);\n-            \n             int stackStart = config.getBaseIteratorPriority() + 40;\n-            BatchScanner scanner = scanners.newScanner(config.getShardTableName(), config.getAuthorizations(), config.getNumQueryThreads(), config.getQuery(),\n-                            true);\n-            \n+            BatchScanner scanner = scanners.newScanner(config.getShardTableName(), config.getAuthorizations(), config.getNumQueryThreads(), config.getQuery(), true);\n             IteratorSetting cfg = new IteratorSetting(stackStart++, \"query\", FieldIndexOnlyQueryIterator.class);\n-            \n             DefaultQueryPlanner.addOption(cfg, QueryOptions.QUERY, queryString, false);\n-            \n             try {\n-                DefaultQueryPlanner.addOption(cfg, QueryOptions.INDEX_ONLY_FIELDS,\n-                                QueryOptions.buildFieldStringFromSet(metadataHelper.getIndexOnlyFields(config.getDatatypeFilter())), true);\n-                DefaultQueryPlanner.addOption(cfg, QueryOptions.INDEXED_FIELDS,\n-                                QueryOptions.buildFieldStringFromSet(metadataHelper.getIndexedFields(config.getDatatypeFilter())), true);\n+                DefaultQueryPlanner.addOption(cfg, QueryOptions.INDEX_ONLY_FIELDS, QueryOptions.buildFieldStringFromSet(metadataHelper.getIndexOnlyFields(config.getDatatypeFilter())), true);\n+                DefaultQueryPlanner.addOption(cfg,\n+                    QueryOptions.INDEXED_FIELDS,\n+                        QueryOptions.buildFieldStringFromSet(metadataHelper.getIndexedFields(config.getDatatypeFilter())),\n+                                                  true);\n             } catch (TableNotFoundException e) {\n                 throw new RuntimeException(e);\n             }\n-            \n             DefaultQueryPlanner.addOption(cfg, QueryOptions.START_TIME, Long.toString(config.getBeginDate().getTime()), false);\n             DefaultQueryPlanner.addOption(cfg, QueryOptions.DATATYPE_FILTER, config.getDatatypeFilterAsString(), false);\n             DefaultQueryPlanner.addOption(cfg, QueryOptions.END_TIME, Long.toString(config.getEndDate().getTime()), false);\n-            \n             DefaultQueryPlanner.configureTypeMappings(config, cfg, metadataHelper, true);\n-            \n             scanner.setRanges(Collections.singleton(rangeForTerm(null, null, config)));\n-            \n             scanner.addScanIterator(cfg);\n-            \n+\n             Iterator<Entry<Key,Value>> kvIter = scanner.iterator();\n-            \n             itr = Collections.emptyIterator();\n-            \n             if (kvIter.hasNext()) {\n                 PeekingIterator<Entry<Key,Value>> peeking = new PeekingIterator<>(kvIter);\n                 Entry<Key,Value> peekKey = peeking.peek();\n@@ -90,40 +77,40 @@ public class ShardRangeStream extends RangeStream {\n                     itr = Iterators.transform(peeking, new FieldIndexParser(node));\n                     this.context = StreamContext.PRESENT;\n                 }\n-                \n             } else {\n                 this.context = StreamContext.ABSENT;\n-                \n             }\n-            \n         } catch (TableNotFoundException | DatawaveQueryException e) {\n             throw new RuntimeException(e);\n         } finally {\n             // shut down the executor as all threads have completed\n             shutdownThreads();\n         }\n-        \n         return this;\n     }\n-    \n+\n     @Override\n     public Range rangeForTerm(String term, String field, Date start, Date end) {\n         return new Range(new Key(DateHelper.format(start) + \"_\"), false, new Key(DateHelper.format(end) + \"_\" + '\\uffff'), false);\n     }\n-    \n+\n     public class FieldIndexParser implements Function<Entry<Key,Value>,QueryPlan> {\n+\n         protected JexlNode node;\n         \n         /**\n          * @param node\n          */\n+\n         public FieldIndexParser(JexlNode node) {\n             this.node = node;\n         }\n-        \n+\n         public QueryPlan apply(Entry<Key,Value> entry) {\n-            return new QueryPlan(node, new Range(new Key(entry.getKey().getRow(), entry.getKey().getColumnFamily()), true, entry.getKey().followingKey(\n-                            PartialKey.ROW_COLFAM), false));\n+            return new QueryPlan(node, new Range(new Key(entry.getKey().getRow(), entry.getKey().getColumnFamily()),\n+                true,\n+                    entry.getKey().followingKey(PartialKey.ROW_COLFAM),\n+                        false));\n         }\n     }\n-}\n+}\n\\ No newline at end of file\n",
            "diff_size": 38
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "29",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "29",
                    "severity": "error",
                    "message": "Accumulo non-public classes imported",
                    "source": "com.puppycrawl.tools.checkstyle.checks.regexp.RegexpSinglelineJavaCheck"
                }
            ],
            "diff": "",
            "diff_size": 0
        }
    ],
    "repaired_by": [],
    "not_repaired_by": [
        "styler",
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random",
        "styler_three_grams"
    ]
}