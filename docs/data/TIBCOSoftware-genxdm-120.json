{
    "project_name": "TIBCOSoftware-genxdm",
    "error_id": "120",
    "information": {
        "errors": [
            {
                "line": "29",
                "column": "1",
                "severity": "warning",
                "message": "File contains tab characters (this is the first instance).",
                "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
            }
        ]
    },
    "source_code": "public final class StringRegExParser\n{\n\t/**\n\t * characters excluded from XmlChar ::= [^\\#x2D#x5B#x5D]\n\t */\n\tprivate static final String XMLCHAR = \"-[]\";",
    "results": [
        {
            "tool": "styler",
            "errors": [
                {
                    "line": "30",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/120/StringRegExParser.java\nindex 68b7abfae3f..573ee67058c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler/120/StringRegExParser.java\n@@ -26,10 +26,10 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  */\n public final class StringRegExParser\n {\n-\t/**\n+/**\n \t * characters excluded from XmlChar ::= [^\\#x2D#x5B#x5D]\n \t */\n-\tprivate static final String XMLCHAR = \"-[]\";\n+ private static final String XMLCHAR = \"-[]\";\n \n \t/**\n \t * characters excluded from Char ::= [^.\\?*+()|#x5B#x5D]\n",
            "diff_size": 2
        },
        {
            "tool": "intellij",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/120/StringRegExParser.java\nindex 68b7abfae3f..7c438593dde 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/intellij/120/StringRegExParser.java\n@@ -1,18 +1,19 @@\n /**\n  * Copyright (c) 2009-2010 TIBCO Software Inc.\n- *\n+ * <p>\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.genxdm.processor.w3c.xs.regex.string;\n \n import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n@@ -24,558 +25,515 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  * <p/>\n  * XML name characters are approximated with Unicode properties\n  */\n-public final class StringRegExParser\n-{\n-\t/**\n-\t * characters excluded from XmlChar ::= [^\\#x2D#x5B#x5D]\n-\t */\n-\tprivate static final String XMLCHAR = \"-[]\";\n-\n-\t/**\n-\t * characters excluded from Char ::= [^.\\?*+()|#x5B#x5D]\n-\t */\n-\tprivate static final String CHAR = \".\\\\?*+()|[]\";\n-\tprivate static final boolean DOT_IS_SPECIAL = true;\n-\tprivate static final boolean DOT_NORMAL_CHAR = false;\n-\n-\t/**\n-\t * parse the XML-Schema regular expression, returning a PatternTerm. the result will be null if the expression is\n-\t * empty.\n-\t * \n-\t * @throws StringRegExException\n-\t *             if invalid expression.\n-\t */\n-\tpublic static StringRegExPatternTerm parse(final String expr) throws StringRegExException\n-\t{\n-\t\treturn StringRegExParser.parse(new StringRegExPatternInput(expr));\n-\t}\n-\n-\t/**\n-\t * parse the XML-Schema regular expression, returning a PatternTerm. the result will be null if the expression is\n-\t * empty.\n-\t * \n-\t * @throws StringRegExException\n-\t *             if invalid expression.\n-\t */\n-\tpublic static StringRegExPatternTerm parse(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tif (!input.hasNext())\n-\t\t{\n-\t\t\tfinal StringRegExPatternTerm empty = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n-\t\t\tempty.setOccurrence(0, 0);\n-\t\t\treturn empty;\n-\t\t}\n-\t\tfinal StringRegExPatternTerm term = parseExpr(input);\n-\t\tif (input.hasNext())\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidPattern, null);\n-\t\t}\n-\t\treturn term;\n-\t}\n-\n-\t/**\n-\t * expr ::= branch ( '|' branch )*\n-\t */\n-\tprivate static StringRegExPatternTerm parseExpr(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tStringRegExPatternTerm branch = parseBranch(input);\n-\t\tif (branch != null && peekIs(input, OR))\n-\t\t{\n-\t\t\t// if (expr == null)\n-\t\t\tfinal StringRegExPatternTerm expr = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_CHOICE);\n-\t\t\texpr.addSubTerm(branch);\n-\t\t\twhile (peekIs(input, OR))\n-\t\t\t{\n-\t\t\t\tinput.next(); // skip OR\n-\t\t\t\tbranch = parseBranch(input);\n-\t\t\t\tif (branch == null)\n-\t\t\t\t{\n-\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidPatternEmptyBranch, null);\n-\t\t\t\t}\n-\t\t\t\texpr.addSubTerm(branch);\n-\t\t\t}\n-\t\t\treturn expr;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn branch;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * branch ::= piece ( piece )*\n-\t */\n-\tprivate static StringRegExPatternTerm parseBranch(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tStringRegExPatternTerm branch;\n-\t\tStringRegExPatternTerm piece = parsePiece(input);\n-\t\tif (piece != null && input.hasNext() && !peekIs(input, OR) && !peekIs(input, RPAREN))\n-\t\t{\n-\t\t\tbranch = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n-\t\t\tbranch.addSubTerm(piece);\n-\t\t\twhile (input.hasNext() && !peekIs(input, OR) && !peekIs(input, RPAREN))\n-\t\t\t{\n-\t\t\t\tpiece = parsePiece(input);\n-\t\t\t\tbranch.addSubTerm(piece);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tbranch = piece;\n-\t\t}\n-\t\treturn branch;\n-\t}\n-\n-\t/**\n-\t * piece ::= atom ( occurrence )? occurrence ::= '?' | '*' | '+' | ( '{' int (',' ( int )?) '}' )\n-\t */\n-\tprivate static StringRegExPatternTerm parsePiece(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tfinal StringRegExPatternTerm atom = parseAtom(input);\n-\t\tif (atom == null)\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidPatternEmptyAtom, null);\n-\t\t}\n-\t\tif (input.hasNext())\n-\t\t{\n-\t\t\tString s = input.peek();\n-\t\t\tchar c = s.charAt(0);\n-\t\t\tif (c == ZERO_OR_ONE)\n-\t\t\t{\n-\t\t\t\tatom.setOccurrence(0, 1);\n-\t\t\t\tinput.next();\n-\t\t\t}\n-\t\t\telse if (c == ZERO_OR_MORE)\n-\t\t\t{\n-\t\t\t\tatom.setOccurrence(0, RegExBridge.UNBOUNDED);\n-\t\t\t\tinput.next();\n-\t\t\t}\n-\t\t\telse if (c == ONE_OR_MORE)\n-\t\t\t{\n-\t\t\t\tatom.setOccurrence(1, RegExBridge.UNBOUNDED);\n-\t\t\t\tinput.next();\n-\t\t\t}\n-\t\t\telse if (c == LBRACE)\n-\t\t\t{\n-\t\t\t\tinput.next(); // skip lbrace\n-\t\t\t\tif (peekIs(input, ','))\n-\t\t\t\t{\n-\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidCommaQuantifier, null);\n-\t\t\t\t}\n-\t\t\t\tint min = parseInt(input);\n-\t\t\t\tint max;\n-\t\t\t\t// {n} is allowed, and is used repeated in examples\n-\t\t\t\t// elsewhere in the rec\n-\t\t\t\tif (!peekIs(input, ','))\n-\t\t\t\t\tmax = min;// throw new RuntimeException(\"invalid qualifier: no comma\");\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tinput.next(); // skip comma\n-\t\t\t\t\tif (peekIs(input, RBRACE))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tmax = RegExBridge.UNBOUNDED;\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tmax = parseInt(input);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (max < min || min < 0)\n-\t\t\t\t{\n-\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidRangeQualifier, new Object[] { min, max });\n-\t\t\t\t}\n-\t\t\t\tif (!peekIs(input, RBRACE))\n-\t\t\t\t{\n-\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidQualifierNoClosure, null);\n-\t\t\t\t}\n-\t\t\t\tatom.setOccurrence(min, max);\n-\t\t\t\tinput.next(); // skip brace\n-\t\t\t}\n-\t\t}\n-\t\treturn atom;\n-\t}\n-\n-\t/**\n-\t * atom ::= ( '(' expr ')' ) | char-expr | char-escape | normal char | char ref\n-\t */\n-\tprivate static StringRegExPatternTerm parseAtom(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tif (peekIs(input, LPAREN))\n-\t\t{\n-\t\t\tinput.next(); // skip lparen\n-\t\t\tStringRegExPatternTerm expr = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n-\t\t\texpr.addSubTerm(parseExpr(input));\n-\t\t\tif (!peekIs(input, RPAREN))\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidAtomNoClosure, null);\n-\t\t\t}\n-\t\t\tinput.next(); // skip rparen\n-\t\t\treturn expr;\n-\t\t}\n-\t\telse if (peekIs(input, LBRACKET))\n-\t\t{\n-\t\t\t// character expression\n-\t\t\treturn parseCharExpr(input);\n-\t\t}\n-\t\t/*\n-\t\t * Errata still pending but WorkGroup decided to classify as error\n-\t\t * http://www.w3.org/2001/05/xmlschema-rec-comments#pfiregexXmlCharRef\n-\t\t * \n-\t\t * else if (peekIs(input, REFERENCE)){ // character reference input.next(); if (!peekIs(input, '#')) throw new\n-\t\t * RuntimeException(\"invalid character reference: missing #\"); input.next(); int value = 0; int base = 10; if\n-\t\t * (peekIs(input, 'x')){ input.next(); base = 16; } while (input.hasNext() && !peekIs(input, ';')){ String s =\n-\t\t * (String) input.next(); char c = s.charAt(0); value = value * base + Character.digit(c, base); } if\n-\t\t * (!peekIs(input, ';')) throw new RuntimeException(\"invalid character reference: missing ;\"); input.next();\n-\t\t * StringPatternTerm atom = new StringPatternTerm(StringPatternTerm.TYPE_LEAF_POSITIVE); atom.addChar((char)\n-\t\t * value); return atom; }\n-\t\t */\n-\t\telse\n-\t\t{\n-\t\t\tif (!input.hasNext())\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidEmptyAtom, null);\n-\t\t\t}\n-\t\t\tStringRegExPatternTerm atom = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n-\t\t\tparseChar(input, atom, CHAR, DOT_IS_SPECIAL);\n-\t\t\treturn atom;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * char-expr ::= '[' '^'? char-range+ ('-' char-expr)? ']'\n-\t */\n-\tprivate static StringRegExPatternTerm parseCharExpr(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tinput.next(); // skip lbracket\n-\t\tfinal boolean negative = peekIs(input, NOT);\n-\t\tif (negative)\n-\t\t{\n-\t\t\tinput.next(); // skip not\n-\t\t}\n-\t\tfinal StringRegExPatternTerm.Type type = negative ? StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE : StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE;\n-\t\tfinal StringRegExPatternTerm atom = new StringRegExPatternTerm(type);\n-\t\tif (peekIs(input, LBRACKET))\n-\t\t{\n-\t\t\t// must be subtraction\n-\t\t\tfinal StringRegExPatternTerm a = parseCharExpr(input);\n-\t\t\tatom.addSubTerm(a);\n-\t\t\tif (peekIs(input, RANGE))\n-\t\t\t{\n-\t\t\t\tinput.next(); // skip subtraction\n-\t\t\t\tfinal StringRegExPatternTerm b = parseCharExpr(input);\n-\t\t\t\tatom.addNegativeTerm(b);\n-\t\t\t}\n-\t\t\tif (!peekIs(input, RBRACKET))\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidSubtractionNoClosure, null);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tdo\n-\t\t\t{\n-\t\t\t\tchar first = (char)0; // first char of potential range\n-\t\t\t\tif (peekIs(input, MINUS))\n-\t\t\t\t{\n-\t\t\t\t\tinput.next();\n-\t\t\t\t\tif (peekIs(input, LBRACKET))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tatom.addNegativeTerm(parseCharExpr(input));\n-\t\t\t\t\t\tif (!peekIs(input, RBRACKET))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"]\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tatom.addChar(MINUS);\n-\t\t\t\t\t\tfirst = MINUS;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tfirst = parseChar(input, atom, XMLCHAR, DOT_NORMAL_CHAR);\n-\t\t\t\t}\n-\n-\t\t\t\tif (first != 0 && peekIs(input, RANGE))\n-\t\t\t\t{\n-\t\t\t\t\tinput.next(); // skip range char\n-\t\t\t\t\tif (!peekIs(input, RBRACKET))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal char last = parseChar(input, atom, XMLCHAR, DOT_NORMAL_CHAR);\n-\t\t\t\t\t\tif (last == 0)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidCharRange, null);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (first > last)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidCharRangeEx, new Object[] { first, last });\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tatom.combineRanges();\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tatom.addChar(MINUS); // add as normal char\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twhile (!peekIs(input, RBRACKET) && input.hasNext());\n-\t\t\tif (!input.hasNext())\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"]\");\n-\t\t\t}\n-\t\t}\n-\t\tinput.next(); // skip rbracket\n-\t\treturn atom;\n-\t}\n-\n-\t/**\n-\t * char-range ::= char-group | (char ('-' char)?)\n-\t */\n-\t// private static void parseCharRange(PatternInput input, StringPatternTerm atom){\n-\t// char first = parseChar(input, atom, XMLCHARINCDASH, DOT_IS_SPECIAL);\n-\t// }\n-\t/**\n-\t * char-group ::= char | meta-char | char-class\n-\t * <p/>\n-\t * if the normal parameter is true then: Normal Character [10] Char ::= [^.\\?*+()|#x5B#x5D]\n-\t */\n-\tprivate static char parseChar(final StringRegExPatternInput input, final StringRegExPatternTerm atom, final String excluded, final boolean specialDot) throws StringRegExException\n-\t{\n-\t\tString s = input.next();\n-\t\tchar c = s.charAt(0);\n-\t\tif (c == '\\\\' && input.hasNext())\n-\t\t{\n-\t\t\ts = input.next();\n-\t\t\tc = s.charAt(0);\n-\t\t\tswitch (c)\n-\t\t\t{\n-\t\t\t\tcase 'n':\n-\t\t\t\t\tatom.addChar(NEWLINE);\n-\t\t\t\tbreak;\n-\t\t\t\tcase 'r':\n-\t\t\t\t\tatom.addChar(RETURN);\n-\t\t\t\tbreak;\n-\t\t\t\tcase 't':\n-\t\t\t\t\tatom.addChar(TAB);\n-\t\t\t\tbreak;\n-\t\t\t\tcase '\\\\':\n-\t\t\t\tcase '.':\n-\t\t\t\tcase '-':\n-\t\t\t\tcase '|':\n-\t\t\t\tcase '^':\n-\t\t\t\tcase '?':\n-\t\t\t\tcase '*':\n-\t\t\t\tcase '+':\n-\t\t\t\tcase '[':\n-\t\t\t\tcase ']':\n-\t\t\t\tcase '(':\n-\t\t\t\tcase ')':\n-\t\t\t\tcase '{':\n-\t\t\t\tcase '}':\n-\t\t\t\t\tatom.addChar(c);\n-\t\t\t\tbreak;\n-\t\t\t\tcase 'p':\n-\t\t\t\tcase 'P':\n-\t\t\t\t\tatom.addSubTerm(createUnicodeBlockTerm(c, input));\n-\t\t\t\t\treturn (char)0;\n-\t\t\t\tdefault:\n-\t\t\t\t\tatom.addSubTerm(createXMLTerm(c));\n-\t\t\t\t\treturn (char)0;\n-\t\t\t}\n-\t\t\treturn c;\n-\t\t}\n-\t\tif (c == '.' && specialDot)\n-\t\t{\n-\t\t\t// all but line ends\n-\t\t\tStringRegExPatternTerm t = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n-\t\t\tt.addChar(NEWLINE);\n-\t\t\tt.addChar(RETURN);\n-\t\t\tatom.addSubTerm(t);\n-\t\t\treturn (char)0;\n-\t\t}\n-\t\tif (excluded.indexOf((int)c) != -1)\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidChar, StringRegExPatternTerm.charString(c));\n-\t\t}\n-\t\tatom.addChar(c);\n-\t\treturn c;\n-\t}\n-\n-\t/**\n-\t * returns a new StringPatternTerm corresponding to the given meta-character.\n-\t */\n-\tprivate static StringRegExPatternTerm createXMLTerm(char c) throws StringRegExException\n-\t{\n-\t\tStringRegExPatternTerm term;\n-\t\tif (c == 's' || c == 'i' || c == 'c' || c == 'd' || c == 'W')\n-\t\t\tterm = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n-\t\telse\n-\t\t\tterm = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n-\t\tc = Character.toLowerCase(c);\n-\t\tif (c == 's')\n-\t\t{\n-\t\t\tterm.addChar(' ');\n-\t\t\tterm.addChar(NEWLINE);\n-\t\t\tterm.addChar(RETURN);\n-\t\t\tterm.addChar(TAB);\n-\t\t}\n-\t\telse if (c == 'i')\n-\t\t{\n-\t\t\t// name start char (approximate)\n-\t\t\tStringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"L\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Nl\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tterm.addChar(':');\n-\t\t\tterm.addChar('_');\n-\t\t}\n-\t\telse if (c == 'c')\n-\t\t{\n-\t\t\t// name char (approximate)\n-\t\t\tStringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"L\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Nl\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Nd\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Mc\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Me\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Mn\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Lm\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tterm.addChar(':');\n-\t\t\tterm.addChar('_');\n-\t\t\tterm.addChar('-');\n-\t\t\tterm.addChar('.');\n-\t\t}\n-\t\telse if (c == 'd')\n-\t\t{\n-\t\t\tStringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"Nd\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t}\n-\t\telse if (c == 'w')\n-\t\t{\n-\t\t\tStringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"P\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"S\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"C\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.unrecognizedEscapeChar, c);\n-\t\t}\n-\t\treturn term;\n-\t}\n-\n-\t/**\n-\t * Handles block escapes, which are of the form: \"\\p{IsBlockName}\" or maybe\n-\t * \"\\p{L[ultmo]?|M[nce]?|N[dlo]?|P[cdseifo]?|Z[slp]?|S[mcko]?|C[cfon]?}\n-\t * <p/>\n-\t * [27] catEsc ::= '\\p{' charProp '}' [28] complEsc ::= '\\P{' charProp '}' [29] charProp ::= IsCategory | IsBlock\n-\t * [30] IsCategory ::= Letters | Marks | Numbers | Punctuation | Separators | Symbols | Others [31] Letters ::= 'L'\n-\t * [ultmo]? [32] Marks ::= 'M' [nce]? [33] Numbers ::= 'N' [dlo]? [34] Punctuation::= 'P' [cdseifo]? [35] Separators\n-\t * ::= 'Z' [slp]? [36] Symbols ::= 'S' [mcko]? [37] Others ::= 'C' [cfon]?\n-\t * \n-\t * @param c\n-\t *            either 'p' or 'P'\n-\t * @param input\n-\t *            c has just been consumed\n-\t */\n-\tprivate static StringRegExPatternTerm createUnicodeBlockTerm(char c, StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tif (peekIs(input, '{'))\n-\t\t{\n-\t\t\tinput.next();\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.expectedBraceAfter, c);\n-\t\t}\n-\t\tStringBuilder blockName = new StringBuilder();\n-\t\twhile (input.hasNext() && !peekIs(input, RBRACE))\n-\t\t{\n-\t\t\tblockName.append(input.next());\n-\t\t}\n-\t\tif (peekIs(input, RBRACE))\n-\t\t{\n-\t\t\tinput.next();\n-\t\t\tif (blockName.length() > 0 && blockName.length() <= 2)\n-\t\t\t{\n-\t\t\t\treturn createUnicodePropertyTerm(blockName.toString());\n-\t\t\t}\n-\t\t\telse if (blockName.length() > 2 && blockName.charAt(0) == 'I' && blockName.charAt(1) == 's')\n-\t\t\t{\n-\t\t\t\tStringRegExPatternTerm term = new StringRegExPatternTerm(c == 'p' ? StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE : StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n-\t\t\t\tterm.setBlock(blockName.substring(2));\n-\t\t\t\treturn term;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.blockBeginWIs, null);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"}\");\n-\t\t}\n-\t}\n-\n-\tprivate static StringRegExPatternTerm createUnicodePropertyTerm(final String propertyName) throws StringRegExException\n-\t{\n-\t\tfinal StringRegExPatternTerm term = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n-\t\tterm.setCategory(propertyName);\n-\t\treturn term;\n-\t}\n-\n-\t/**\n-\t * parse a non-negative int\n-\t */\n-\tprivate static int parseInt(final StringRegExPatternInput input)\n-\t{\n-\t\tint n = 0;\n-\t\twhile (input.hasNext())\n-\t\t{\n-\t\t\tchar c = input.peek().charAt(0);\n-\t\t\tif (c <= '9' && c >= '0')\n-\t\t\t{\n-\t\t\t\tinput.next();\n-\t\t\t\tn = 10 * n + ((int)c - (int)'0');\n-\t\t\t}\n-\t\t\telse\n-\t\t\t\tbreak;\n-\t\t}\n-\t\treturn n;\n-\t}\n-\n-\tstatic boolean peekIs(StringRegExPatternInput input, char c)\n-\t{\n-\t\treturn input.hasNext() && input.peek().charAt(0) == c;\n-\t}\n-\n-\tpublic static final char NEWLINE = '\\n';\n-\tpublic static final char RETURN = '\\r';\n-\tpublic static final char TAB = '\\t';\n-\tstatic final char ESCAPE = '\\\\';\n-\tstatic final char WILDCARD = '.';\n-\tstatic final char RANGE = '-';\n-\tstatic final char OR = '|';\n-\tstatic final char NOT = '^';\n-\tstatic final char ZERO_OR_ONE = '?';\n-\tstatic final char ZERO_OR_MORE = '*';\n-\tstatic final char ONE_OR_MORE = '+';\n-\tstatic final char LBRACE = '{';\n-\tstatic final char RBRACE = '}';\n-\tstatic final char LPAREN = '(';\n-\tstatic final char RPAREN = ')';\n-\tstatic final char LBRACKET = '[';\n-\tstatic final char RBRACKET = ']';\n-\tstatic final char MINUS = '-';\n-\t// static final char REFERENCE = '&';\n+public final class StringRegExParser {\n+    /**\n+     * characters excluded from XmlChar ::= [^\\#x2D#x5B#x5D]\n+     */\n+    private static final String XMLCHAR = \"-[]\";\n+\n+    /**\n+     * characters excluded from Char ::= [^.\\?*+()|#x5B#x5D]\n+     */\n+    private static final String CHAR = \".\\\\?*+()|[]\";\n+\n+    private static final boolean DOT_IS_SPECIAL = true;\n+\n+    private static final boolean DOT_NORMAL_CHAR = false;\n+\n+    /**\n+     * parse the XML-Schema regular expression, returning a PatternTerm. the result will be null if the expression is\n+     * empty.\n+     *\n+     * @throws StringRegExException\n+     *             if invalid expression.\n+     */\n+    public static StringRegExPatternTerm parse(final String expr) throws StringRegExException {\n+        return StringRegExParser.parse(new StringRegExPatternInput(expr));\n+    }\n+\n+    /**\n+     * parse the XML-Schema regular expression, returning a PatternTerm. the result will be null if the expression is\n+     * empty.\n+     *\n+     * @throws StringRegExException\n+     *             if invalid expression.\n+     */\n+    public static StringRegExPatternTerm parse(final StringRegExPatternInput input)\n+        throws StringRegExException {\n+        if (!input.hasNext()) {\n+            final StringRegExPatternTerm empty =\n+                new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n+            empty.setOccurrence(0, 0);\n+            return empty;\n+        }\n+        final StringRegExPatternTerm term = parseExpr(input);\n+        if (input.hasNext()) {\n+            throw new StringRegExException(StringRegExException.Kind.invalidPattern, null);\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * expr ::= branch ( '|' branch )*\n+     */\n+    private static StringRegExPatternTerm parseExpr(final StringRegExPatternInput input)\n+        throws StringRegExException {\n+        StringRegExPatternTerm branch = parseBranch(input);\n+        if (branch != null && peekIs(input, OR)) {\n+            // if (expr == null)\n+            final StringRegExPatternTerm expr =\n+                new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_CHOICE);\n+            expr.addSubTerm(branch);\n+            while (peekIs(input, OR)) {\n+                input.next(); // skip OR\n+                branch = parseBranch(input);\n+                if (branch == null) {\n+                    throw new StringRegExException(\n+                        StringRegExException.Kind.invalidPatternEmptyBranch, null);\n+                }\n+                expr.addSubTerm(branch);\n+            }\n+            return expr;\n+        } else {\n+            return branch;\n+        }\n+    }\n+\n+    /**\n+     * branch ::= piece ( piece )*\n+     */\n+    private static StringRegExPatternTerm parseBranch(final StringRegExPatternInput input)\n+        throws StringRegExException {\n+        StringRegExPatternTerm branch;\n+        StringRegExPatternTerm piece = parsePiece(input);\n+        if (piece != null && input.hasNext() && !peekIs(input, OR) && !peekIs(input, RPAREN)) {\n+            branch = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n+            branch.addSubTerm(piece);\n+            while (input.hasNext() && !peekIs(input, OR) && !peekIs(input, RPAREN)) {\n+                piece = parsePiece(input);\n+                branch.addSubTerm(piece);\n+            }\n+        } else {\n+            branch = piece;\n+        }\n+        return branch;\n+    }\n+\n+    /**\n+     * piece ::= atom ( occurrence )? occurrence ::= '?' | '*' | '+' | ( '{' int (',' ( int )?) '}' )\n+     */\n+    private static StringRegExPatternTerm parsePiece(final StringRegExPatternInput input)\n+        throws StringRegExException {\n+        final StringRegExPatternTerm atom = parseAtom(input);\n+        if (atom == null) {\n+            throw new StringRegExException(StringRegExException.Kind.invalidPatternEmptyAtom, null);\n+        }\n+        if (input.hasNext()) {\n+            String s = input.peek();\n+            char c = s.charAt(0);\n+            if (c == ZERO_OR_ONE) {\n+                atom.setOccurrence(0, 1);\n+                input.next();\n+            } else if (c == ZERO_OR_MORE) {\n+                atom.setOccurrence(0, RegExBridge.UNBOUNDED);\n+                input.next();\n+            } else if (c == ONE_OR_MORE) {\n+                atom.setOccurrence(1, RegExBridge.UNBOUNDED);\n+                input.next();\n+            } else if (c == LBRACE) {\n+                input.next(); // skip lbrace\n+                if (peekIs(input, ',')) {\n+                    throw new StringRegExException(StringRegExException.Kind.invalidCommaQuantifier,\n+                        null);\n+                }\n+                int min = parseInt(input);\n+                int max;\n+                // {n} is allowed, and is used repeated in examples\n+                // elsewhere in the rec\n+                if (!peekIs(input, ',')) {\n+                    max = min;// throw new RuntimeException(\"invalid qualifier: no comma\");\n+                } else {\n+                    input.next(); // skip comma\n+                    if (peekIs(input, RBRACE)) {\n+                        max = RegExBridge.UNBOUNDED;\n+                    } else {\n+                        max = parseInt(input);\n+                    }\n+                }\n+                if (max < min || min < 0) {\n+                    throw new StringRegExException(StringRegExException.Kind.invalidRangeQualifier,\n+                        new Object[] {min, max});\n+                }\n+                if (!peekIs(input, RBRACE)) {\n+                    throw new StringRegExException(\n+                        StringRegExException.Kind.invalidQualifierNoClosure, null);\n+                }\n+                atom.setOccurrence(min, max);\n+                input.next(); // skip brace\n+            }\n+        }\n+        return atom;\n+    }\n+\n+    /**\n+     * atom ::= ( '(' expr ')' ) | char-expr | char-escape | normal char | char ref\n+     */\n+    private static StringRegExPatternTerm parseAtom(final StringRegExPatternInput input)\n+        throws StringRegExException {\n+        if (peekIs(input, LPAREN)) {\n+            input.next(); // skip lparen\n+            StringRegExPatternTerm expr =\n+                new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n+            expr.addSubTerm(parseExpr(input));\n+            if (!peekIs(input, RPAREN)) {\n+                throw new StringRegExException(StringRegExException.Kind.invalidAtomNoClosure,\n+                    null);\n+            }\n+            input.next(); // skip rparen\n+            return expr;\n+        } else if (peekIs(input, LBRACKET)) {\n+            // character expression\n+            return parseCharExpr(input);\n+        }\n+        /*\n+         * Errata still pending but WorkGroup decided to classify as error\n+         * http://www.w3.org/2001/05/xmlschema-rec-comments#pfiregexXmlCharRef\n+         *\n+         * else if (peekIs(input, REFERENCE)){ // character reference input.next(); if (!peekIs(input, '#')) throw new\n+         * RuntimeException(\"invalid character reference: missing #\"); input.next(); int value = 0; int base = 10; if\n+         * (peekIs(input, 'x')){ input.next(); base = 16; } while (input.hasNext() && !peekIs(input, ';')){ String s =\n+         * (String) input.next(); char c = s.charAt(0); value = value * base + Character.digit(c, base); } if\n+         * (!peekIs(input, ';')) throw new RuntimeException(\"invalid character reference: missing ;\"); input.next();\n+         * StringPatternTerm atom = new StringPatternTerm(StringPatternTerm.TYPE_LEAF_POSITIVE); atom.addChar((char)\n+         * value); return atom; }\n+         */\n+        else {\n+            if (!input.hasNext()) {\n+                throw new StringRegExException(StringRegExException.Kind.invalidEmptyAtom, null);\n+            }\n+            StringRegExPatternTerm atom =\n+                new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n+            parseChar(input, atom, CHAR, DOT_IS_SPECIAL);\n+            return atom;\n+        }\n+    }\n+\n+    /**\n+     * char-expr ::= '[' '^'? char-range+ ('-' char-expr)? ']'\n+     */\n+    private static StringRegExPatternTerm parseCharExpr(final StringRegExPatternInput input)\n+        throws StringRegExException {\n+        input.next(); // skip lbracket\n+        final boolean negative = peekIs(input, NOT);\n+        if (negative) {\n+            input.next(); // skip not\n+        }\n+        final StringRegExPatternTerm.Type type =\n+            negative ? StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE :\n+                StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE;\n+        final StringRegExPatternTerm atom = new StringRegExPatternTerm(type);\n+        if (peekIs(input, LBRACKET)) {\n+            // must be subtraction\n+            final StringRegExPatternTerm a = parseCharExpr(input);\n+            atom.addSubTerm(a);\n+            if (peekIs(input, RANGE)) {\n+                input.next(); // skip subtraction\n+                final StringRegExPatternTerm b = parseCharExpr(input);\n+                atom.addNegativeTerm(b);\n+            }\n+            if (!peekIs(input, RBRACKET)) {\n+                throw new StringRegExException(\n+                    StringRegExException.Kind.invalidSubtractionNoClosure, null);\n+            }\n+        } else {\n+            do {\n+                char first = (char) 0; // first char of potential range\n+                if (peekIs(input, MINUS)) {\n+                    input.next();\n+                    if (peekIs(input, LBRACKET)) {\n+                        atom.addNegativeTerm(parseCharExpr(input));\n+                        if (!peekIs(input, RBRACKET)) {\n+                            throw new StringRegExException(\n+                                StringRegExException.Kind.invalidExprMissing, \"]\");\n+                        }\n+                    } else {\n+                        atom.addChar(MINUS);\n+                        first = MINUS;\n+                    }\n+                } else {\n+                    first = parseChar(input, atom, XMLCHAR, DOT_NORMAL_CHAR);\n+                }\n+\n+                if (first != 0 && peekIs(input, RANGE)) {\n+                    input.next(); // skip range char\n+                    if (!peekIs(input, RBRACKET)) {\n+                        final char last = parseChar(input, atom, XMLCHAR, DOT_NORMAL_CHAR);\n+                        if (last == 0) {\n+                            throw new StringRegExException(\n+                                StringRegExException.Kind.invalidCharRange, null);\n+                        }\n+                        if (first > last) {\n+                            throw new StringRegExException(\n+                                StringRegExException.Kind.invalidCharRangeEx,\n+                                new Object[] {first, last});\n+                        }\n+                        atom.combineRanges();\n+                    } else {\n+                        atom.addChar(MINUS); // add as normal char\n+                    }\n+                }\n+            }\n+            while (!peekIs(input, RBRACKET) && input.hasNext());\n+            if (!input.hasNext()) {\n+                throw new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"]\");\n+            }\n+        }\n+        input.next(); // skip rbracket\n+        return atom;\n+    }\n+\n+    /**\n+     * char-range ::= char-group | (char ('-' char)?)\n+     */\n+    // private static void parseCharRange(PatternInput input, StringPatternTerm atom){\n+    // char first = parseChar(input, atom, XMLCHARINCDASH, DOT_IS_SPECIAL);\n+    // }\n+\n+    /**\n+     * char-group ::= char | meta-char | char-class\n+     * <p/>\n+     * if the normal parameter is true then: Normal Character [10] Char ::= [^.\\?*+()|#x5B#x5D]\n+     */\n+    private static char parseChar(final StringRegExPatternInput input,\n+                                  final StringRegExPatternTerm atom, final String excluded,\n+                                  final boolean specialDot) throws StringRegExException {\n+        String s = input.next();\n+        char c = s.charAt(0);\n+        if (c == '\\\\' && input.hasNext()) {\n+            s = input.next();\n+            c = s.charAt(0);\n+            switch (c) {\n+                case 'n':\n+                    atom.addChar(NEWLINE);\n+                    break;\n+                case 'r':\n+                    atom.addChar(RETURN);\n+                    break;\n+                case 't':\n+                    atom.addChar(TAB);\n+                    break;\n+                case '\\\\':\n+                case '.':\n+                case '-':\n+                case '|':\n+                case '^':\n+                case '?':\n+                case '*':\n+                case '+':\n+                case '[':\n+                case ']':\n+                case '(':\n+                case ')':\n+                case '{':\n+                case '}':\n+                    atom.addChar(c);\n+                    break;\n+                case 'p':\n+                case 'P':\n+                    atom.addSubTerm(createUnicodeBlockTerm(c, input));\n+                    return (char) 0;\n+                default:\n+                    atom.addSubTerm(createXMLTerm(c));\n+                    return (char) 0;\n+            }\n+            return c;\n+        }\n+        if (c == '.' && specialDot) {\n+            // all but line ends\n+            StringRegExPatternTerm t =\n+                new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n+            t.addChar(NEWLINE);\n+            t.addChar(RETURN);\n+            atom.addSubTerm(t);\n+            return (char) 0;\n+        }\n+        if (excluded.indexOf((int) c) != -1) {\n+            throw new StringRegExException(StringRegExException.Kind.invalidChar,\n+                StringRegExPatternTerm.charString(c));\n+        }\n+        atom.addChar(c);\n+        return c;\n+    }\n+\n+    /**\n+     * returns a new StringPatternTerm corresponding to the given meta-character.\n+     */\n+    private static StringRegExPatternTerm createXMLTerm(char c) throws StringRegExException {\n+        StringRegExPatternTerm term;\n+        if (c == 's' || c == 'i' || c == 'c' || c == 'd' || c == 'W') {\n+            term = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n+        } else {\n+            term = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n+        }\n+        c = Character.toLowerCase(c);\n+        if (c == 's') {\n+            term.addChar(' ');\n+            term.addChar(NEWLINE);\n+            term.addChar(RETURN);\n+            term.addChar(TAB);\n+        } else if (c == 'i') {\n+            // name start char (approximate)\n+            StringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"L\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Nl\");\n+            term.addSubTerm(subTerm);\n+            term.addChar(':');\n+            term.addChar('_');\n+        } else if (c == 'c') {\n+            // name char (approximate)\n+            StringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"L\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Nl\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Nd\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Mc\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Me\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Mn\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Lm\");\n+            term.addSubTerm(subTerm);\n+            term.addSubTerm(subTerm);\n+            term.addChar(':');\n+            term.addChar('_');\n+            term.addChar('-');\n+            term.addChar('.');\n+        } else if (c == 'd') {\n+            StringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"Nd\");\n+            term.addSubTerm(subTerm);\n+        } else if (c == 'w') {\n+            StringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"P\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"S\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"C\");\n+            term.addSubTerm(subTerm);\n+        } else {\n+            throw new StringRegExException(StringRegExException.Kind.unrecognizedEscapeChar, c);\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * Handles block escapes, which are of the form: \"\\p{IsBlockName}\" or maybe\n+     * \"\\p{L[ultmo]?|M[nce]?|N[dlo]?|P[cdseifo]?|Z[slp]?|S[mcko]?|C[cfon]?}\n+     * <p/>\n+     * [27] catEsc ::= '\\p{' charProp '}' [28] complEsc ::= '\\P{' charProp '}' [29] charProp ::= IsCategory | IsBlock\n+     * [30] IsCategory ::= Letters | Marks | Numbers | Punctuation | Separators | Symbols | Others [31] Letters ::= 'L'\n+     * [ultmo]? [32] Marks ::= 'M' [nce]? [33] Numbers ::= 'N' [dlo]? [34] Punctuation::= 'P' [cdseifo]? [35] Separators\n+     * ::= 'Z' [slp]? [36] Symbols ::= 'S' [mcko]? [37] Others ::= 'C' [cfon]?\n+     *\n+     * @param c\n+     *            either 'p' or 'P'\n+     * @param input\n+     *            c has just been consumed\n+     */\n+    private static StringRegExPatternTerm createUnicodeBlockTerm(char c,\n+                                                                 StringRegExPatternInput input)\n+        throws StringRegExException {\n+        if (peekIs(input, '{')) {\n+            input.next();\n+        } else {\n+            throw new StringRegExException(StringRegExException.Kind.expectedBraceAfter, c);\n+        }\n+        StringBuilder blockName = new StringBuilder();\n+        while (input.hasNext() && !peekIs(input, RBRACE)) {\n+            blockName.append(input.next());\n+        }\n+        if (peekIs(input, RBRACE)) {\n+            input.next();\n+            if (blockName.length() > 0 && blockName.length() <= 2) {\n+                return createUnicodePropertyTerm(blockName.toString());\n+            } else if (blockName.length() > 2 && blockName.charAt(0) == 'I' &&\n+                blockName.charAt(1) == 's') {\n+                StringRegExPatternTerm term = new StringRegExPatternTerm(\n+                    c == 'p' ? StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE :\n+                        StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n+                term.setBlock(blockName.substring(2));\n+                return term;\n+            } else {\n+                throw new StringRegExException(StringRegExException.Kind.blockBeginWIs, null);\n+            }\n+        } else {\n+            throw new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"}\");\n+        }\n+    }\n+\n+    private static StringRegExPatternTerm createUnicodePropertyTerm(final String propertyName)\n+        throws StringRegExException {\n+        final StringRegExPatternTerm term =\n+            new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n+        term.setCategory(propertyName);\n+        return term;\n+    }\n+\n+    /**\n+     * parse a non-negative int\n+     */\n+    private static int parseInt(final StringRegExPatternInput input) {\n+        int n = 0;\n+        while (input.hasNext()) {\n+            char c = input.peek().charAt(0);\n+            if (c <= '9' && c >= '0') {\n+                input.next();\n+                n = 10 * n + ((int) c - (int) '0');\n+            } else {\n+                break;\n+            }\n+        }\n+        return n;\n+    }\n+\n+    static boolean peekIs(StringRegExPatternInput input, char c) {\n+        return input.hasNext() && input.peek().charAt(0) == c;\n+    }\n+\n+    public static final char NEWLINE = '\\n';\n+\n+    public static final char RETURN = '\\r';\n+\n+    public static final char TAB = '\\t';\n+\n+    static final char ESCAPE = '\\\\';\n+\n+    static final char WILDCARD = '.';\n+\n+    static final char RANGE = '-';\n+\n+    static final char OR = '|';\n+\n+    static final char NOT = '^';\n+\n+    static final char ZERO_OR_ONE = '?';\n+\n+    static final char ZERO_OR_MORE = '*';\n+\n+    static final char ONE_OR_MORE = '+';\n+\n+    static final char LBRACE = '{';\n+\n+    static final char RBRACE = '}';\n+\n+    static final char LPAREN = '(';\n+\n+    static final char RPAREN = ')';\n+\n+    static final char LBRACKET = '[';\n+\n+    static final char RBRACKET = ']';\n+\n+    static final char MINUS = '-';\n+    // static final char REFERENCE = '&';\n }\n",
            "diff_size": 559
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/120/StringRegExParser.java\nindex 68b7abfae3f..7fc898647f8 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/codebuff/120/StringRegExParser.java\n@@ -24,558 +24,581 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  * <p/>\n  * XML name characters are approximated with Unicode properties\n  */\n+\n public final class StringRegExParser\n {\n-\t/**\n-\t * characters excluded from XmlChar ::= [^\\#x2D#x5B#x5D]\n-\t */\n-\tprivate static final String XMLCHAR = \"-[]\";\n-\n-\t/**\n-\t * characters excluded from Char ::= [^.\\?*+()|#x5B#x5D]\n-\t */\n-\tprivate static final String CHAR = \".\\\\?*+()|[]\";\n-\tprivate static final boolean DOT_IS_SPECIAL = true;\n-\tprivate static final boolean DOT_NORMAL_CHAR = false;\n-\n-\t/**\n-\t * parse the XML-Schema regular expression, returning a PatternTerm. the result will be null if the expression is\n-\t * empty.\n-\t * \n-\t * @throws StringRegExException\n-\t *             if invalid expression.\n-\t */\n-\tpublic static StringRegExPatternTerm parse(final String expr) throws StringRegExException\n-\t{\n-\t\treturn StringRegExParser.parse(new StringRegExPatternInput(expr));\n-\t}\n-\n-\t/**\n-\t * parse the XML-Schema regular expression, returning a PatternTerm. the result will be null if the expression is\n-\t * empty.\n-\t * \n-\t * @throws StringRegExException\n-\t *             if invalid expression.\n-\t */\n-\tpublic static StringRegExPatternTerm parse(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tif (!input.hasNext())\n-\t\t{\n-\t\t\tfinal StringRegExPatternTerm empty = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n-\t\t\tempty.setOccurrence(0, 0);\n-\t\t\treturn empty;\n-\t\t}\n-\t\tfinal StringRegExPatternTerm term = parseExpr(input);\n-\t\tif (input.hasNext())\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidPattern, null);\n-\t\t}\n-\t\treturn term;\n-\t}\n-\n-\t/**\n-\t * expr ::= branch ( '|' branch )*\n-\t */\n-\tprivate static StringRegExPatternTerm parseExpr(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tStringRegExPatternTerm branch = parseBranch(input);\n-\t\tif (branch != null && peekIs(input, OR))\n-\t\t{\n-\t\t\t// if (expr == null)\n-\t\t\tfinal StringRegExPatternTerm expr = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_CHOICE);\n-\t\t\texpr.addSubTerm(branch);\n-\t\t\twhile (peekIs(input, OR))\n-\t\t\t{\n-\t\t\t\tinput.next(); // skip OR\n-\t\t\t\tbranch = parseBranch(input);\n-\t\t\t\tif (branch == null)\n-\t\t\t\t{\n-\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidPatternEmptyBranch, null);\n-\t\t\t\t}\n-\t\t\t\texpr.addSubTerm(branch);\n-\t\t\t}\n-\t\t\treturn expr;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn branch;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * branch ::= piece ( piece )*\n-\t */\n-\tprivate static StringRegExPatternTerm parseBranch(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tStringRegExPatternTerm branch;\n-\t\tStringRegExPatternTerm piece = parsePiece(input);\n-\t\tif (piece != null && input.hasNext() && !peekIs(input, OR) && !peekIs(input, RPAREN))\n-\t\t{\n-\t\t\tbranch = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n-\t\t\tbranch.addSubTerm(piece);\n-\t\t\twhile (input.hasNext() && !peekIs(input, OR) && !peekIs(input, RPAREN))\n-\t\t\t{\n-\t\t\t\tpiece = parsePiece(input);\n-\t\t\t\tbranch.addSubTerm(piece);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tbranch = piece;\n-\t\t}\n-\t\treturn branch;\n-\t}\n-\n-\t/**\n-\t * piece ::= atom ( occurrence )? occurrence ::= '?' | '*' | '+' | ( '{' int (',' ( int )?) '}' )\n-\t */\n-\tprivate static StringRegExPatternTerm parsePiece(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tfinal StringRegExPatternTerm atom = parseAtom(input);\n-\t\tif (atom == null)\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidPatternEmptyAtom, null);\n-\t\t}\n-\t\tif (input.hasNext())\n-\t\t{\n-\t\t\tString s = input.peek();\n-\t\t\tchar c = s.charAt(0);\n-\t\t\tif (c == ZERO_OR_ONE)\n-\t\t\t{\n-\t\t\t\tatom.setOccurrence(0, 1);\n-\t\t\t\tinput.next();\n-\t\t\t}\n-\t\t\telse if (c == ZERO_OR_MORE)\n-\t\t\t{\n-\t\t\t\tatom.setOccurrence(0, RegExBridge.UNBOUNDED);\n-\t\t\t\tinput.next();\n-\t\t\t}\n-\t\t\telse if (c == ONE_OR_MORE)\n-\t\t\t{\n-\t\t\t\tatom.setOccurrence(1, RegExBridge.UNBOUNDED);\n-\t\t\t\tinput.next();\n-\t\t\t}\n-\t\t\telse if (c == LBRACE)\n-\t\t\t{\n-\t\t\t\tinput.next(); // skip lbrace\n-\t\t\t\tif (peekIs(input, ','))\n-\t\t\t\t{\n-\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidCommaQuantifier, null);\n-\t\t\t\t}\n-\t\t\t\tint min = parseInt(input);\n-\t\t\t\tint max;\n-\t\t\t\t// {n} is allowed, and is used repeated in examples\n-\t\t\t\t// elsewhere in the rec\n-\t\t\t\tif (!peekIs(input, ','))\n-\t\t\t\t\tmax = min;// throw new RuntimeException(\"invalid qualifier: no comma\");\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tinput.next(); // skip comma\n-\t\t\t\t\tif (peekIs(input, RBRACE))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tmax = RegExBridge.UNBOUNDED;\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tmax = parseInt(input);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (max < min || min < 0)\n-\t\t\t\t{\n-\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidRangeQualifier, new Object[] { min, max });\n-\t\t\t\t}\n-\t\t\t\tif (!peekIs(input, RBRACE))\n-\t\t\t\t{\n-\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidQualifierNoClosure, null);\n-\t\t\t\t}\n-\t\t\t\tatom.setOccurrence(min, max);\n-\t\t\t\tinput.next(); // skip brace\n-\t\t\t}\n-\t\t}\n-\t\treturn atom;\n-\t}\n-\n-\t/**\n-\t * atom ::= ( '(' expr ')' ) | char-expr | char-escape | normal char | char ref\n-\t */\n-\tprivate static StringRegExPatternTerm parseAtom(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tif (peekIs(input, LPAREN))\n-\t\t{\n-\t\t\tinput.next(); // skip lparen\n-\t\t\tStringRegExPatternTerm expr = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n-\t\t\texpr.addSubTerm(parseExpr(input));\n-\t\t\tif (!peekIs(input, RPAREN))\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidAtomNoClosure, null);\n-\t\t\t}\n-\t\t\tinput.next(); // skip rparen\n-\t\t\treturn expr;\n-\t\t}\n-\t\telse if (peekIs(input, LBRACKET))\n-\t\t{\n-\t\t\t// character expression\n-\t\t\treturn parseCharExpr(input);\n-\t\t}\n-\t\t/*\n-\t\t * Errata still pending but WorkGroup decided to classify as error\n-\t\t * http://www.w3.org/2001/05/xmlschema-rec-comments#pfiregexXmlCharRef\n-\t\t * \n-\t\t * else if (peekIs(input, REFERENCE)){ // character reference input.next(); if (!peekIs(input, '#')) throw new\n-\t\t * RuntimeException(\"invalid character reference: missing #\"); input.next(); int value = 0; int base = 10; if\n-\t\t * (peekIs(input, 'x')){ input.next(); base = 16; } while (input.hasNext() && !peekIs(input, ';')){ String s =\n-\t\t * (String) input.next(); char c = s.charAt(0); value = value * base + Character.digit(c, base); } if\n-\t\t * (!peekIs(input, ';')) throw new RuntimeException(\"invalid character reference: missing ;\"); input.next();\n-\t\t * StringPatternTerm atom = new StringPatternTerm(StringPatternTerm.TYPE_LEAF_POSITIVE); atom.addChar((char)\n-\t\t * value); return atom; }\n-\t\t */\n-\t\telse\n-\t\t{\n-\t\t\tif (!input.hasNext())\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidEmptyAtom, null);\n-\t\t\t}\n-\t\t\tStringRegExPatternTerm atom = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n-\t\t\tparseChar(input, atom, CHAR, DOT_IS_SPECIAL);\n-\t\t\treturn atom;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * char-expr ::= '[' '^'? char-range+ ('-' char-expr)? ']'\n-\t */\n-\tprivate static StringRegExPatternTerm parseCharExpr(final StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tinput.next(); // skip lbracket\n-\t\tfinal boolean negative = peekIs(input, NOT);\n-\t\tif (negative)\n-\t\t{\n-\t\t\tinput.next(); // skip not\n-\t\t}\n-\t\tfinal StringRegExPatternTerm.Type type = negative ? StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE : StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE;\n-\t\tfinal StringRegExPatternTerm atom = new StringRegExPatternTerm(type);\n-\t\tif (peekIs(input, LBRACKET))\n-\t\t{\n-\t\t\t// must be subtraction\n-\t\t\tfinal StringRegExPatternTerm a = parseCharExpr(input);\n-\t\t\tatom.addSubTerm(a);\n-\t\t\tif (peekIs(input, RANGE))\n-\t\t\t{\n-\t\t\t\tinput.next(); // skip subtraction\n-\t\t\t\tfinal StringRegExPatternTerm b = parseCharExpr(input);\n-\t\t\t\tatom.addNegativeTerm(b);\n-\t\t\t}\n-\t\t\tif (!peekIs(input, RBRACKET))\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidSubtractionNoClosure, null);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tdo\n-\t\t\t{\n-\t\t\t\tchar first = (char)0; // first char of potential range\n-\t\t\t\tif (peekIs(input, MINUS))\n-\t\t\t\t{\n-\t\t\t\t\tinput.next();\n-\t\t\t\t\tif (peekIs(input, LBRACKET))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tatom.addNegativeTerm(parseCharExpr(input));\n-\t\t\t\t\t\tif (!peekIs(input, RBRACKET))\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"]\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tatom.addChar(MINUS);\n-\t\t\t\t\t\tfirst = MINUS;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tfirst = parseChar(input, atom, XMLCHAR, DOT_NORMAL_CHAR);\n-\t\t\t\t}\n-\n-\t\t\t\tif (first != 0 && peekIs(input, RANGE))\n-\t\t\t\t{\n-\t\t\t\t\tinput.next(); // skip range char\n-\t\t\t\t\tif (!peekIs(input, RBRACKET))\n-\t\t\t\t\t{\n-\t\t\t\t\t\tfinal char last = parseChar(input, atom, XMLCHAR, DOT_NORMAL_CHAR);\n-\t\t\t\t\t\tif (last == 0)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidCharRange, null);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tif (first > last)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidCharRangeEx, new Object[] { first, last });\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tatom.combineRanges();\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tatom.addChar(MINUS); // add as normal char\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\twhile (!peekIs(input, RBRACKET) && input.hasNext());\n-\t\t\tif (!input.hasNext())\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"]\");\n-\t\t\t}\n-\t\t}\n-\t\tinput.next(); // skip rbracket\n-\t\treturn atom;\n-\t}\n-\n-\t/**\n-\t * char-range ::= char-group | (char ('-' char)?)\n-\t */\n-\t// private static void parseCharRange(PatternInput input, StringPatternTerm atom){\n-\t// char first = parseChar(input, atom, XMLCHARINCDASH, DOT_IS_SPECIAL);\n-\t// }\n-\t/**\n-\t * char-group ::= char | meta-char | char-class\n-\t * <p/>\n-\t * if the normal parameter is true then: Normal Character [10] Char ::= [^.\\?*+()|#x5B#x5D]\n-\t */\n-\tprivate static char parseChar(final StringRegExPatternInput input, final StringRegExPatternTerm atom, final String excluded, final boolean specialDot) throws StringRegExException\n-\t{\n-\t\tString s = input.next();\n-\t\tchar c = s.charAt(0);\n-\t\tif (c == '\\\\' && input.hasNext())\n-\t\t{\n-\t\t\ts = input.next();\n-\t\t\tc = s.charAt(0);\n-\t\t\tswitch (c)\n-\t\t\t{\n-\t\t\t\tcase 'n':\n-\t\t\t\t\tatom.addChar(NEWLINE);\n-\t\t\t\tbreak;\n-\t\t\t\tcase 'r':\n-\t\t\t\t\tatom.addChar(RETURN);\n-\t\t\t\tbreak;\n-\t\t\t\tcase 't':\n-\t\t\t\t\tatom.addChar(TAB);\n-\t\t\t\tbreak;\n-\t\t\t\tcase '\\\\':\n-\t\t\t\tcase '.':\n-\t\t\t\tcase '-':\n-\t\t\t\tcase '|':\n-\t\t\t\tcase '^':\n-\t\t\t\tcase '?':\n-\t\t\t\tcase '*':\n-\t\t\t\tcase '+':\n-\t\t\t\tcase '[':\n-\t\t\t\tcase ']':\n-\t\t\t\tcase '(':\n-\t\t\t\tcase ')':\n-\t\t\t\tcase '{':\n-\t\t\t\tcase '}':\n-\t\t\t\t\tatom.addChar(c);\n-\t\t\t\tbreak;\n-\t\t\t\tcase 'p':\n-\t\t\t\tcase 'P':\n-\t\t\t\t\tatom.addSubTerm(createUnicodeBlockTerm(c, input));\n-\t\t\t\t\treturn (char)0;\n-\t\t\t\tdefault:\n-\t\t\t\t\tatom.addSubTerm(createXMLTerm(c));\n-\t\t\t\t\treturn (char)0;\n-\t\t\t}\n-\t\t\treturn c;\n-\t\t}\n-\t\tif (c == '.' && specialDot)\n-\t\t{\n-\t\t\t// all but line ends\n-\t\t\tStringRegExPatternTerm t = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n-\t\t\tt.addChar(NEWLINE);\n-\t\t\tt.addChar(RETURN);\n-\t\t\tatom.addSubTerm(t);\n-\t\t\treturn (char)0;\n-\t\t}\n-\t\tif (excluded.indexOf((int)c) != -1)\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidChar, StringRegExPatternTerm.charString(c));\n-\t\t}\n-\t\tatom.addChar(c);\n-\t\treturn c;\n-\t}\n-\n-\t/**\n-\t * returns a new StringPatternTerm corresponding to the given meta-character.\n-\t */\n-\tprivate static StringRegExPatternTerm createXMLTerm(char c) throws StringRegExException\n-\t{\n-\t\tStringRegExPatternTerm term;\n-\t\tif (c == 's' || c == 'i' || c == 'c' || c == 'd' || c == 'W')\n-\t\t\tterm = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n-\t\telse\n-\t\t\tterm = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n-\t\tc = Character.toLowerCase(c);\n-\t\tif (c == 's')\n-\t\t{\n-\t\t\tterm.addChar(' ');\n-\t\t\tterm.addChar(NEWLINE);\n-\t\t\tterm.addChar(RETURN);\n-\t\t\tterm.addChar(TAB);\n-\t\t}\n-\t\telse if (c == 'i')\n-\t\t{\n-\t\t\t// name start char (approximate)\n-\t\t\tStringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"L\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Nl\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tterm.addChar(':');\n-\t\t\tterm.addChar('_');\n-\t\t}\n-\t\telse if (c == 'c')\n-\t\t{\n-\t\t\t// name char (approximate)\n-\t\t\tStringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"L\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Nl\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Nd\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Mc\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Me\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Mn\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"Lm\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tterm.addChar(':');\n-\t\t\tterm.addChar('_');\n-\t\t\tterm.addChar('-');\n-\t\t\tterm.addChar('.');\n-\t\t}\n-\t\telse if (c == 'd')\n-\t\t{\n-\t\t\tStringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"Nd\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t}\n-\t\telse if (c == 'w')\n-\t\t{\n-\t\t\tStringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"P\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"S\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t\tsubTerm = createUnicodePropertyTerm(\"C\");\n-\t\t\tterm.addSubTerm(subTerm);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.unrecognizedEscapeChar, c);\n-\t\t}\n-\t\treturn term;\n-\t}\n-\n-\t/**\n-\t * Handles block escapes, which are of the form: \"\\p{IsBlockName}\" or maybe\n-\t * \"\\p{L[ultmo]?|M[nce]?|N[dlo]?|P[cdseifo]?|Z[slp]?|S[mcko]?|C[cfon]?}\n-\t * <p/>\n-\t * [27] catEsc ::= '\\p{' charProp '}' [28] complEsc ::= '\\P{' charProp '}' [29] charProp ::= IsCategory | IsBlock\n-\t * [30] IsCategory ::= Letters | Marks | Numbers | Punctuation | Separators | Symbols | Others [31] Letters ::= 'L'\n-\t * [ultmo]? [32] Marks ::= 'M' [nce]? [33] Numbers ::= 'N' [dlo]? [34] Punctuation::= 'P' [cdseifo]? [35] Separators\n-\t * ::= 'Z' [slp]? [36] Symbols ::= 'S' [mcko]? [37] Others ::= 'C' [cfon]?\n-\t * \n-\t * @param c\n-\t *            either 'p' or 'P'\n-\t * @param input\n-\t *            c has just been consumed\n-\t */\n-\tprivate static StringRegExPatternTerm createUnicodeBlockTerm(char c, StringRegExPatternInput input) throws StringRegExException\n-\t{\n-\t\tif (peekIs(input, '{'))\n-\t\t{\n-\t\t\tinput.next();\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.expectedBraceAfter, c);\n-\t\t}\n-\t\tStringBuilder blockName = new StringBuilder();\n-\t\twhile (input.hasNext() && !peekIs(input, RBRACE))\n-\t\t{\n-\t\t\tblockName.append(input.next());\n-\t\t}\n-\t\tif (peekIs(input, RBRACE))\n-\t\t{\n-\t\t\tinput.next();\n-\t\t\tif (blockName.length() > 0 && blockName.length() <= 2)\n-\t\t\t{\n-\t\t\t\treturn createUnicodePropertyTerm(blockName.toString());\n-\t\t\t}\n-\t\t\telse if (blockName.length() > 2 && blockName.charAt(0) == 'I' && blockName.charAt(1) == 's')\n-\t\t\t{\n-\t\t\t\tStringRegExPatternTerm term = new StringRegExPatternTerm(c == 'p' ? StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE : StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n-\t\t\t\tterm.setBlock(blockName.substring(2));\n-\t\t\t\treturn term;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tthrow new StringRegExException(StringRegExException.Kind.blockBeginWIs, null);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"}\");\n-\t\t}\n-\t}\n-\n-\tprivate static StringRegExPatternTerm createUnicodePropertyTerm(final String propertyName) throws StringRegExException\n-\t{\n-\t\tfinal StringRegExPatternTerm term = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n-\t\tterm.setCategory(propertyName);\n-\t\treturn term;\n-\t}\n-\n-\t/**\n-\t * parse a non-negative int\n-\t */\n-\tprivate static int parseInt(final StringRegExPatternInput input)\n-\t{\n-\t\tint n = 0;\n-\t\twhile (input.hasNext())\n-\t\t{\n-\t\t\tchar c = input.peek().charAt(0);\n-\t\t\tif (c <= '9' && c >= '0')\n-\t\t\t{\n-\t\t\t\tinput.next();\n-\t\t\t\tn = 10 * n + ((int)c - (int)'0');\n-\t\t\t}\n-\t\t\telse\n-\t\t\t\tbreak;\n-\t\t}\n-\t\treturn n;\n-\t}\n-\n-\tstatic boolean peekIs(StringRegExPatternInput input, char c)\n-\t{\n-\t\treturn input.hasNext() && input.peek().charAt(0) == c;\n-\t}\n-\n-\tpublic static final char NEWLINE = '\\n';\n-\tpublic static final char RETURN = '\\r';\n-\tpublic static final char TAB = '\\t';\n-\tstatic final char ESCAPE = '\\\\';\n-\tstatic final char WILDCARD = '.';\n-\tstatic final char RANGE = '-';\n-\tstatic final char OR = '|';\n-\tstatic final char NOT = '^';\n-\tstatic final char ZERO_OR_ONE = '?';\n-\tstatic final char ZERO_OR_MORE = '*';\n-\tstatic final char ONE_OR_MORE = '+';\n-\tstatic final char LBRACE = '{';\n-\tstatic final char RBRACE = '}';\n-\tstatic final char LPAREN = '(';\n-\tstatic final char RPAREN = ')';\n-\tstatic final char LBRACKET = '[';\n-\tstatic final char RBRACKET = ']';\n-\tstatic final char MINUS = '-';\n-\t// static final char REFERENCE = '&';\n-}\n+    /**\n+     * characters excluded from XmlChar ::= [^\\#x2D#x5B#x5D]\n+     */\n+    private static final String XMLCHAR = \"-[]\";\n+\n+    /**\n+     * characters excluded from Char ::= [^.\\?*+()|#x5B#x5D]\n+     */\n+    private static final String CHAR = \".\\\\?*+()|[]\";\n+    private static final boolean DOT_IS_SPECIAL = true;\n+    private static final boolean DOT_NORMAL_CHAR = false;\n+\n+    /**\n+     * parse the XML-Schema regular expression, returning a PatternTerm. the result will be null if the expression is\n+     * empty.\n+     * \n+     * @throws StringRegExException\n+     *             if invalid expression.\n+     */\n+    public static StringRegExPatternTerm parse(final String expr)\n+        throws StringRegExException\n+    {\n+        return StringRegExParser.parse(new StringRegExPatternInput(expr));\n+    }\n+\n+    /**\n+     * parse the XML-Schema regular expression, returning a PatternTerm. the result will be null if the expression is\n+     * empty.\n+     * \n+     * @throws StringRegExException\n+     *             if invalid expression.\n+     */\n+\n+    public static StringRegExPatternTerm parse(final StringRegExPatternInput input)\n+        throws StringRegExException\n+    {\n+        if (!input.hasNext())\n+        {\n+            final StringRegExPatternTerm empty = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n+            empty.setOccurrence(0, 0);\n+            return empty;\n+        }\n+\n+        final StringRegExPatternTerm term = parseExpr(input);\n+        if (input.hasNext())\n+        {\n+            throw new StringRegExException(StringRegExException.Kind.invalidPattern, null);\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * expr ::= branch ( '|' branch )*\n+     */\n+\n+    private static StringRegExPatternTerm parseExpr(final StringRegExPatternInput input)\n+        throws StringRegExException\n+    {\n+        StringRegExPatternTerm branch = parseBranch(input);\n+        if (branch != null && peekIs(input, OR))\n+        {\n+            // if (expr == null)\n+            final StringRegExPatternTerm expr = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_CHOICE);\n+            expr.addSubTerm(branch);\n+            while (peekIs(input, OR))\n+            {\n+                input.next(); // skip OR\n+                branch = parseBranch(input);\n+                if (branch == null)\n+                {\n+                    throw new StringRegExException(StringRegExException.Kind.invalidPatternEmptyBranch, null);\n+                }\n+                expr.addSubTerm(branch);\n+            }\n+            return expr;\n+        }\n+        else\n+        {\n+            return branch;\n+        }\n+    }\n+\n+    /**\n+     * branch ::= piece ( piece )*\n+     */\n+\n+    private static StringRegExPatternTerm parseBranch(final StringRegExPatternInput input)\n+        throws StringRegExException\n+    {\n+        StringRegExPatternTerm branch;\n+        StringRegExPatternTerm piece = parsePiece(input);\n+        if (piece != null && input.hasNext() && !peekIs(input, OR) && !peekIs(input, RPAREN))\n+        {\n+            branch = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n+            branch.addSubTerm(piece);\n+            while (input.hasNext() && !peekIs(input, OR) && !peekIs(input, RPAREN))\n+            {\n+                piece = parsePiece(input);\n+                branch.addSubTerm(piece);\n+            }\n+        }\n+        else\n+        {\n+            branch = piece;\n+        }\n+        return branch;\n+    }\n+\n+    /**\n+     * piece ::= atom ( occurrence )? occurrence ::= '?' | '*' | '+' | ( '{' int (',' ( int )?) '}' )\n+     */\n+\n+    private static StringRegExPatternTerm parsePiece(final StringRegExPatternInput input)\n+        throws StringRegExException\n+    {\n+        final StringRegExPatternTerm atom = parseAtom(input);\n+        if (atom == null)\n+        {\n+            throw new StringRegExException(StringRegExException.Kind.invalidPatternEmptyAtom, null);\n+        }\n+        if (input.hasNext())\n+        {\n+            String s = input.peek();\n+            char c = s.charAt(0);\n+            if (c == ZERO_OR_ONE)\n+            {\n+                atom.setOccurrence(0, 1);\n+                input.next();\n+            }\n+            else if (c == ZERO_OR_MORE)\n+            {\n+                atom.setOccurrence(0, RegExBridge.UNBOUNDED);\n+                input.next();\n+            }\n+            else if (c == ONE_OR_MORE)\n+            {\n+                atom.setOccurrence(1, RegExBridge.UNBOUNDED);\n+                input.next();\n+            }\n+            else if (c == LBRACE)\n+            {\n+                input.next(); // skip lbrace\n+                if (peekIs(input, ','))\n+                {\n+                    throw new StringRegExException(StringRegExException.Kind.invalidCommaQuantifier, null);\n+                }\n+                int min = parseInt(input);\n+                int max;\n+                // {n} is allowed, and is used repeated in examples\n+                // elsewhere in the rec\n+                if (!peekIs(input, ','))\n+                    max = min;// throw new RuntimeException(\"invalid qualifier: no comma\");\n+                else\n+                {\n+                    input.next(); // skip comma\n+                    if (peekIs(input, RBRACE))\n+                    {\n+                        max = RegExBridge.UNBOUNDED;\n+                    }\n+                    else\n+                    {\n+                        max = parseInt(input);\n+                    }\n+                }\n+                if (max < min || min < 0)\n+                {\n+                    throw new StringRegExException(StringRegExException.Kind.invalidRangeQualifier, new Object[] { min, max });\n+                }\n+                if (!peekIs(input, RBRACE))\n+                {\n+                    throw new StringRegExException(StringRegExException.Kind.invalidQualifierNoClosure, null);\n+                }\n+                atom.setOccurrence(min, max);\n+                input.next(); // skip brace\n+            }\n+        }\n+        return atom;\n+    }\n+\n+    /**\n+     * atom ::= ( '(' expr ')' ) | char-expr | char-escape | normal char | char ref\n+     */\n+\n+    private static StringRegExPatternTerm parseAtom(final StringRegExPatternInput input)\n+        throws StringRegExException\n+    {\n+        if (peekIs(input, LPAREN))\n+        {\n+            input.next(); // skip lparen\n+            StringRegExPatternTerm expr = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_SEQ);\n+            expr.addSubTerm(parseExpr(input));\n+            if (!peekIs(input, RPAREN))\n+            {\n+                throw new StringRegExException(StringRegExException.Kind.invalidAtomNoClosure, null);\n+            }\n+            input.next(); // skip rparen\n+            return expr;\n+        }\n+        else if (peekIs(input, LBRACKET))\n+        {\n+            // character expression\n+            return parseCharExpr(input);\n+        }\n+        /*\n+         * Errata still pending but WorkGroup decided to classify as error\n+         * http://www.w3.org/2001/05/xmlschema-rec-comments#pfiregexXmlCharRef\n+         * \n+         * else if (peekIs(input, REFERENCE)){ // character reference input.next(); if (!peekIs(input, '#')) throw new\n+         * RuntimeException(\"invalid character reference: missing #\"); input.next(); int value = 0; int base = 10; if\n+         * (peekIs(input, 'x')){ input.next(); base = 16; } while (input.hasNext() && !peekIs(input, ';')){ String s =\n+         * (String) input.next(); char c = s.charAt(0); value = value * base + Character.digit(c, base); } if\n+         * (!peekIs(input, ';')) throw new RuntimeException(\"invalid character reference: missing ;\"); input.next();\n+         * StringPatternTerm atom = new StringPatternTerm(StringPatternTerm.TYPE_LEAF_POSITIVE); atom.addChar((char)\n+         * value); return atom; }\n+         */\n+        else\n+        {\n+            if (!input.hasNext())\n+            {\n+                throw new StringRegExException(StringRegExException.Kind.invalidEmptyAtom, null);\n+            }\n+            StringRegExPatternTerm atom = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n+            parseChar(input, atom, CHAR, DOT_IS_SPECIAL);\n+            return atom;\n+        }\n+    }\n+\n+    /**\n+     * char-expr ::= '[' '^'? char-range+ ('-' char-expr)? ']'\n+     */\n+\n+    private static StringRegExPatternTerm parseCharExpr(final StringRegExPatternInput input)\n+        throws StringRegExException\n+    {\n+        input.next(); // skip lbracket\n+\n+        final boolean negative = peekIs(input, NOT);\n+        if (negative)\n+        {\n+            input.next(); // skip not\n+        }\n+\n+        final StringRegExPatternTerm.Type type = negative ? StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE : StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE;\n+        final StringRegExPatternTerm atom = new StringRegExPatternTerm(type);\n+        if (peekIs(input, LBRACKET))\n+        {\n+            // must be subtraction\n+            final StringRegExPatternTerm a = parseCharExpr(input);\n+            atom.addSubTerm(a);\n+            if (peekIs(input, RANGE))\n+            {\n+                input.next(); // skip subtraction\n+\n+                final StringRegExPatternTerm b = parseCharExpr(input);\n+                atom.addNegativeTerm(b);\n+            }\n+            if (!peekIs(input, RBRACKET))\n+            {\n+                throw new StringRegExException(StringRegExException.Kind.invalidSubtractionNoClosure, null);\n+            }\n+        }\n+        else\n+        {\n+            do {\n+                char first = (char)0; // first char of potential range\n+                if (peekIs(input, MINUS))\n+                {\n+                    input.next();\n+                    if (peekIs(input, LBRACKET))\n+                    {\n+                        atom.addNegativeTerm(parseCharExpr(input));\n+                        if (!peekIs(input, RBRACKET))\n+                        {\n+                            throw new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"]\");\n+                        }\n+                    }\n+                    else\n+                    {\n+                        atom.addChar(MINUS);\n+                        first = MINUS;\n+                    }\n+                }\n+                else\n+                {\n+                    first = parseChar(input, atom, XMLCHAR, DOT_NORMAL_CHAR);\n+                }\n+                if (first != 0 && peekIs(input, RANGE))\n+                {\n+                    input.next(); // skip range char\n+                    if (!peekIs(input, RBRACKET))\n+                    {\n+                        final char last = parseChar(input, atom, XMLCHAR, DOT_NORMAL_CHAR);\n+                        if (last == 0)\n+                        {\n+                            throw new StringRegExException(StringRegExException.Kind.invalidCharRange, null);\n+                        }\n+                        if (first > last)\n+                        {\n+                            throw new StringRegExException(StringRegExException.Kind.invalidCharRangeEx, new Object[] { first, last });\n+                        }\n+                        atom.combineRanges();\n+                    }\n+                    else\n+                    {\n+                        atom.addChar(MINUS); // add as normal char\n+                    }\n+                }\n+            } while (!peekIs(input, RBRACKET) && input.hasNext());\n+            if (!input.hasNext())\n+            {\n+                throw new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"]\");\n+            }\n+        }\n+        input.next(); // skip rbracket\n+        return atom;\n+    }\n+\n+    /**\n+     * char-range ::= char-group | (char ('-' char)?)\n+     */\n+    // private static void parseCharRange(PatternInput input, StringPatternTerm atom){\n+    // char first = parseChar(input, atom, XMLCHARINCDASH, DOT_IS_SPECIAL);\n+    // }\n+    /**\n+     * char-group ::= char | meta-char | char-class\n+     * <p/>\n+     * if the normal parameter is true then: Normal Character [10] Char ::= [^.\\?*+()|#x5B#x5D]\n+     */\n+\n+    private static char parseChar(final StringRegExPatternInput input, final StringRegExPatternTerm atom, final String excluded, final boolean specialDot)\n+        throws StringRegExException\n+    {\n+        String s = input.next();\n+        char c = s.charAt(0);\n+        if (c == '\\\\' && input.hasNext())\n+        {\n+            s = input.next();\n+            c = s.charAt(0);\n+            switch (c)\n+            {\n+                case 'n':\n+                atom.addChar(NEWLINE);\n+                break;\n+                case 'r':\n+                atom.addChar(RETURN);\n+                break;\n+                case 't':\n+                atom.addChar(TAB);\n+                break;\n+                case '\\\\':\n+                case '.':\n+                case '-':\n+                case '|':\n+                case '^':\n+                case '?':\n+                case '*':\n+                case '+':\n+                case '[':\n+                case ']':\n+                case '(':\n+                case ')':\n+                case '{':\n+                case '}':\n+                atom.addChar(c);\n+                break;\n+                case 'p':\n+                case 'P':\n+                atom.addSubTerm(createUnicodeBlockTerm(c, input));\n+                return (char)0;\n+                default:\n+                atom.addSubTerm(createXMLTerm(c));\n+                return (char)0;\n+            }\n+            return c;\n+        }\n+        if (c == '.' && specialDot)\n+        {\n+            // all but line ends\n+            StringRegExPatternTerm t = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n+            t.addChar(NEWLINE);\n+            t.addChar(RETURN);\n+            atom.addSubTerm(t);\n+            return (char)0;\n+        }\n+        if (excluded.indexOf((int)c) != -1)\n+        {\n+            throw new StringRegExException(StringRegExException.Kind.invalidChar, StringRegExPatternTerm.charString(c));\n+        }\n+        atom.addChar(c);\n+        return c;\n+    }\n+\n+    /**\n+     * returns a new StringPatternTerm corresponding to the given meta-character.\n+     */\n+\n+    private static StringRegExPatternTerm createXMLTerm(char c)\n+        throws StringRegExException\n+    {\n+        StringRegExPatternTerm term;\n+        if (c == 's' || c == 'i' || c == 'c' || c == 'd' || c == 'W')\n+            term = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n+        else\n+            term = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n+        c = Character.toLowerCase(c);\n+        if (c == 's')\n+        {\n+            term.addChar(' ');\n+            term.addChar(NEWLINE);\n+            term.addChar(RETURN);\n+            term.addChar(TAB);\n+        }\n+        else if (c == 'i')\n+        {\n+            // name start char (approximate)\n+            StringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"L\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Nl\");\n+            term.addSubTerm(subTerm);\n+            term.addChar(':');\n+            term.addChar('_');\n+        }\n+        else if (c == 'c')\n+        {\n+            // name char (approximate)\n+            StringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"L\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Nl\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Nd\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Mc\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Me\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Mn\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"Lm\");\n+            term.addSubTerm(subTerm);\n+            term.addSubTerm(subTerm);\n+            term.addChar(':');\n+            term.addChar('_');\n+            term.addChar('-');\n+            term.addChar('.');\n+        }\n+        else if (c == 'd')\n+        {\n+            StringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"Nd\");\n+            term.addSubTerm(subTerm);\n+        }\n+        else if (c == 'w')\n+        {\n+            StringRegExPatternTerm subTerm = createUnicodePropertyTerm(\"P\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"S\");\n+            term.addSubTerm(subTerm);\n+            subTerm = createUnicodePropertyTerm(\"C\");\n+            term.addSubTerm(subTerm);\n+        }\n+        else\n+        {\n+            throw new StringRegExException(StringRegExException.Kind.unrecognizedEscapeChar, c);\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * Handles block escapes, which are of the form: \"\\p{IsBlockName}\" or maybe\n+     * \"\\p{L[ultmo]?|M[nce]?|N[dlo]?|P[cdseifo]?|Z[slp]?|S[mcko]?|C[cfon]?}\n+     * <p/>\n+     * [27] catEsc ::= '\\p{' charProp '}' [28] complEsc ::= '\\P{' charProp '}' [29] charProp ::= IsCategory | IsBlock\n+     * [30] IsCategory ::= Letters | Marks | Numbers | Punctuation | Separators | Symbols | Others [31] Letters ::= 'L'\n+     * [ultmo]? [32] Marks ::= 'M' [nce]? [33] Numbers ::= 'N' [dlo]? [34] Punctuation::= 'P' [cdseifo]? [35] Separators\n+     * ::= 'Z' [slp]? [36] Symbols ::= 'S' [mcko]? [37] Others ::= 'C' [cfon]?\n+     * \n+     * @param c\n+     *            either 'p' or 'P'\n+     * @param input\n+     *            c has just been consumed\n+     */\n+\n+    private static StringRegExPatternTerm createUnicodeBlockTerm(char c, StringRegExPatternInput input)\n+        throws StringRegExException\n+    {\n+        if (peekIs(input, '{'))\n+        {\n+            input.next();\n+        }\n+        else\n+        {\n+            throw new StringRegExException(StringRegExException.Kind.expectedBraceAfter, c);\n+        }\n+        StringBuilder blockName = new StringBuilder();\n+        while (input.hasNext() && !peekIs(input, RBRACE))\n+        {\n+            blockName.append(input.next());\n+        }\n+        if (peekIs(input, RBRACE))\n+        {\n+            input.next();\n+            if (blockName.length() > 0 && blockName.length() <= 2)\n+            {\n+                return createUnicodePropertyTerm(blockName.toString());\n+            }\n+            else if (blockName.length() > 2 && blockName.charAt(0) == 'I' && blockName.charAt(1) == 's')\n+            {\n+                StringRegExPatternTerm term = new StringRegExPatternTerm(c == 'p' ? StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE : StringRegExPatternTerm.Type.TYPE_LEAF_NEGATIVE);\n+                term.setBlock(blockName.substring(2));\n+                return term;\n+            }\n+            else\n+            {\n+                throw new StringRegExException(StringRegExException.Kind.blockBeginWIs, null);\n+            }\n+        }\n+        else\n+        {\n+            throw new StringRegExException(StringRegExException.Kind.invalidExprMissing, \"}\");\n+        }\n+    }\n+\n+    private static StringRegExPatternTerm createUnicodePropertyTerm(final String propertyName)\n+        throws StringRegExException\n+    {\n+        final StringRegExPatternTerm term = new StringRegExPatternTerm(StringRegExPatternTerm.Type.TYPE_LEAF_POSITIVE);\n+        term.setCategory(propertyName);\n+        return term;\n+    }\n+\n+    /**\n+     * parse a non-negative int\n+     */\n+\n+    private static int parseInt(final StringRegExPatternInput input)\n+    {\n+        int n = 0;\n+        while (input.hasNext())\n+        {\n+            char c = input.peek().charAt(0);\n+            if (c <= '9' && c >= '0')\n+            {\n+                input.next();\n+                n = 10 * n + ((int)c - (int)'0');\n+            }\n+            else\n+            break;\n+        }\n+        return n;\n+    }\n+\n+    static boolean peekIs(StringRegExPatternInput input, char c)\n+    {\n+        return input.hasNext() && input.peek().charAt(0) == c;\n+    }\n+\n+    public static final char NEWLINE = '\\n';\n+    public static final char RETURN = '\\r';\n+    public static final char TAB = '\\t';\n+    static final char ESCAPE = '\\\\';\n+    static final char WILDCARD = '.';\n+    static final char RANGE = '-';\n+    static final char OR = '|';\n+    static final char NOT = '^';\n+    static final char ZERO_OR_ONE = '?';\n+    static final char ZERO_OR_MORE = '*';\n+    static final char ONE_OR_MORE = '+';\n+    static final char LBRACE = '{';\n+    static final char RBRACE = '}';\n+    static final char LPAREN = '(';\n+    static final char RPAREN = ')';\n+    static final char LBRACKET = '[';\n+    static final char RBRACKET = ']';\n+    static final char MINUS = '-';\n+    // static final char REFERENCE = '&';\n+}\n\\ No newline at end of file\n",
            "diff_size": 576
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "30",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/120/StringRegExParser.java\nindex 68b7abfae3f..573ee67058c 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_random/120/StringRegExParser.java\n@@ -26,10 +26,10 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  */\n public final class StringRegExParser\n {\n-\t/**\n+/**\n \t * characters excluded from XmlChar ::= [^\\#x2D#x5B#x5D]\n \t */\n-\tprivate static final String XMLCHAR = \"-[]\";\n+ private static final String XMLCHAR = \"-[]\";\n \n \t/**\n \t * characters excluded from Char ::= [^.\\?*+()|#x5B#x5D]\n",
            "diff_size": 2
        },
        {
            "tool": "styler_three_grams",
            "errors": [
                {
                    "line": "30",
                    "column": "1",
                    "severity": "warning",
                    "message": "File contains tab characters (this is the first instance).",
                    "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.FileTabCharacterCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/120/StringRegExParser.java\nindex 68b7abfae3f..bcadfb2fd0f 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/errored/1/120/StringRegExParser.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/TIBCOSoftware-genxdm/styler_three_grams/120/StringRegExParser.java\n@@ -26,10 +26,10 @@ import org.genxdm.processor.w3c.xs.regex.api.RegExBridge;\n  */\n public final class StringRegExParser\n {\n-\t/**\n+    /**\n \t * characters excluded from XmlChar ::= [^\\#x2D#x5B#x5D]\n \t */\n-\tprivate static final String XMLCHAR = \"-[]\";\n+ private static final String XMLCHAR = \"-[]\";\n \n \t/**\n \t * characters excluded from Char ::= [^.\\?*+()|#x5B#x5D]\n",
            "diff_size": 2
        }
    ],
    "repaired_by": [
        "intellij",
        "codebuff"
    ],
    "not_repaired_by": [
        "styler",
        "naturalize",
        "styler_random",
        "styler_three_grams"
    ]
}