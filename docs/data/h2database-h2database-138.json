{
    "project_name": "h2database-h2database",
    "error_id": "138",
    "information": {
        "errors": [
            {
                "line": "916",
                "column": "19",
                "severity": "warning",
                "message": "Don't use trailing comments.",
                "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
            }
        ]
    },
    "source_code": "        }\n        case ARRAY:\n        case ROW: // Special storage type for ValueRow\n        {\n            int len = readVarInt();\n            Value[] list = new Value[len];",
    "results": [
        {
            "tool": "styler",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/138/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/138/Data.java\nindex cae5530066b..3fdb3d23851 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/138/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler/138/Data.java\n@@ -913,8 +913,9 @@ public class Data {\n             }\n         }\n         case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n-        {\n+        case ROW:\n+            // Special storage type for ValueRow\n+         {\n             int len = readVarInt();\n             Value[] list = new Value[len];\n             for (int i = 0; i < len; i++) {\n",
            "diff_size": 3
        },
        {
            "tool": "intellij",
            "errors": [
                {
                    "line": "942",
                    "column": "23",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/138/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/138/Data.java\nindex cae5530066b..09fb4dd7a19 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/138/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/intellij/138/Data.java\n@@ -6,6 +6,7 @@\n  * The variable size number format code is a port from SQLite,\n  * but stored in reverse order (least significant bits in the first byte).\n  */\n+\n package org.h2.store;\n \n import java.io.IOException;\n@@ -135,7 +136,8 @@ public class Data {\n      * reasons. Datetime storage code of PageStore has issues with all time zone\n      * transitions, so this buggy logic is preserved as is too.\n      */\n-    private static int zoneOffsetMillis = new GregorianCalendar().get(Calendar.ZONE_OFFSET);\n+    private static int zoneOffsetMillis =\n+            new GregorianCalendar().get(Calendar.ZONE_OFFSET);\n \n     /**\n      * The data itself.\n@@ -165,7 +167,7 @@ public class Data {\n      * The current position is not change.\n      *\n      * @param pos the position\n-     * @param x the value\n+     * @param x   the value\n      */\n     public void setInt(int pos, int x) {\n         Bits.writeInt(data, pos, x);\n@@ -213,7 +215,7 @@ public class Data {\n      * For performance reasons the internal representation of a String is\n      * similar to UTF-8, but not exactly UTF-8.\n      *\n-     * @param s the string\n+     * @param s   the string\n      * @param len the length of the string\n      * @return the number of bytes required\n      */\n@@ -289,7 +291,7 @@ public class Data {\n      * For performance reasons the internal representation of a String is\n      * similar to UTF-8, but not exactly UTF-8.\n      *\n-     * @param s the string\n+     * @param s   the string\n      * @param len the number of characters to write\n      */\n     private void writeStringWithoutLength(String s, int len) {\n@@ -334,14 +336,14 @@ public class Data {\n      * Create a new buffer for the given handler. The\n      * handler will decide what type of buffer is created.\n      *\n-     * @param handler the data handler\n-     * @param capacity the initial capacity of the buffer\n-     * @param storeLocalTime\n-     *            store DATE, TIME, and TIMESTAMP values with local time storage\n-     *            format\n+     * @param handler        the data handler\n+     * @param capacity       the initial capacity of the buffer\n+     * @param storeLocalTime store DATE, TIME, and TIMESTAMP values with local time storage\n+     *                       format\n      * @return the buffer\n      */\n-    public static Data create(DataHandler handler, int capacity, boolean storeLocalTime) {\n+    public static Data create(DataHandler handler, int capacity,\n+                              boolean storeLocalTime) {\n         return new Data(handler, new byte[capacity], storeLocalTime);\n     }\n \n@@ -349,14 +351,14 @@ public class Data {\n      * Create a new buffer using the given data for the given handler. The\n      * handler will decide what type of buffer is created.\n      *\n-     * @param handler the data handler\n-     * @param buff the data\n-     * @param storeLocalTime\n-     *            store DATE, TIME, and TIMESTAMP values with local time storage\n-     *            format\n+     * @param handler        the data handler\n+     * @param buff           the data\n+     * @param storeLocalTime store DATE, TIME, and TIMESTAMP values with local time storage\n+     *                       format\n      * @return the buffer\n      */\n-    public static Data create(DataHandler handler, byte[] buff, boolean storeLocalTime) {\n+    public static Data create(DataHandler handler, byte[] buff,\n+                              boolean storeLocalTime) {\n         return new Data(handler, buff, storeLocalTime);\n     }\n \n@@ -390,8 +392,8 @@ public class Data {\n      * Append a number of bytes to this buffer.\n      *\n      * @param buff the data\n-     * @param off the offset in the data\n-     * @param len the length in bytes\n+     * @param off  the offset in the data\n+     * @param len  the length in bytes\n      */\n     public void write(byte[] buff, int off, int len) {\n         System.arraycopy(buff, off, data, pos, len);\n@@ -403,8 +405,8 @@ public class Data {\n      * current position is incremented accordingly.\n      *\n      * @param buff the output buffer\n-     * @param off the offset in the output buffer\n-     * @param len the number of bytes to copy\n+     * @param off  the offset in the output buffer\n+     * @param len  the number of bytes to copy\n      */\n     public void read(byte[] buff, int off, int len) {\n         System.arraycopy(data, pos, buff, off, len);\n@@ -463,320 +465,326 @@ public class Data {\n         }\n         int type = v.getValueType();\n         switch (type) {\n-        case Value.BOOLEAN:\n-            writeByte(v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n-            break;\n-        case Value.TINYINT:\n-            writeByte(TINYINT);\n-            writeByte(v.getByte());\n-            break;\n-        case Value.SMALLINT:\n-            writeByte(SMALLINT);\n-            writeShortInt(v.getShort());\n-            break;\n-        case Value.ENUM:\n-        case Value.INTEGER: {\n-            int x = v.getInt();\n-            if (x < 0) {\n-                writeByte(INT_NEG);\n-                writeVarInt(-x);\n-            } else if (x < 16) {\n-                writeByte((byte) (INT_0_15 + x));\n-            } else {\n-                writeByte(type == Value.INTEGER ? INTEGER : ENUM);\n-                writeVarInt(x);\n+            case Value.BOOLEAN:\n+                writeByte(v.getBoolean() ? BOOLEAN_TRUE : BOOLEAN_FALSE);\n+                break;\n+            case Value.TINYINT:\n+                writeByte(TINYINT);\n+                writeByte(v.getByte());\n+                break;\n+            case Value.SMALLINT:\n+                writeByte(SMALLINT);\n+                writeShortInt(v.getShort());\n+                break;\n+            case Value.ENUM:\n+            case Value.INTEGER: {\n+                int x = v.getInt();\n+                if (x < 0) {\n+                    writeByte(INT_NEG);\n+                    writeVarInt(-x);\n+                } else if (x < 16) {\n+                    writeByte((byte) (INT_0_15 + x));\n+                } else {\n+                    writeByte(type == Value.INTEGER ? INTEGER : ENUM);\n+                    writeVarInt(x);\n+                }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.BIGINT: {\n-            long x = v.getLong();\n-            if (x < 0) {\n-                writeByte(BIGINT_NEG);\n-                writeVarLong(-x);\n-            } else if (x < 8) {\n-                writeByte((byte) (BIGINT_0_7 + x));\n-            } else {\n-                writeByte(BIGINT);\n-                writeVarLong(x);\n+            case Value.BIGINT: {\n+                long x = v.getLong();\n+                if (x < 0) {\n+                    writeByte(BIGINT_NEG);\n+                    writeVarLong(-x);\n+                } else if (x < 8) {\n+                    writeByte((byte) (BIGINT_0_7 + x));\n+                } else {\n+                    writeByte(BIGINT);\n+                    writeVarLong(x);\n+                }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.NUMERIC: {\n-            BigDecimal x = v.getBigDecimal();\n-            if (BigDecimal.ZERO.equals(x)) {\n-                writeByte(NUMERIC_0_1);\n-            } else if (BigDecimal.ONE.equals(x)) {\n-                writeByte((byte) (NUMERIC_0_1 + 1));\n-            } else {\n-                int scale = x.scale();\n-                BigInteger b = x.unscaledValue();\n-                int bits = b.bitLength();\n-                if (bits <= 63) {\n-                    if (scale == 0) {\n-                        writeByte(NUMERIC_SMALL_0);\n-                        writeVarLong(b.longValue());\n+            case Value.NUMERIC: {\n+                BigDecimal x = v.getBigDecimal();\n+                if (BigDecimal.ZERO.equals(x)) {\n+                    writeByte(NUMERIC_0_1);\n+                } else if (BigDecimal.ONE.equals(x)) {\n+                    writeByte((byte) (NUMERIC_0_1 + 1));\n+                } else {\n+                    int scale = x.scale();\n+                    BigInteger b = x.unscaledValue();\n+                    int bits = b.bitLength();\n+                    if (bits <= 63) {\n+                        if (scale == 0) {\n+                            writeByte(NUMERIC_SMALL_0);\n+                            writeVarLong(b.longValue());\n+                        } else {\n+                            writeByte(NUMERIC_SMALL);\n+                            writeVarInt(scale);\n+                            writeVarLong(b.longValue());\n+                        }\n                     } else {\n-                        writeByte(NUMERIC_SMALL);\n+                        writeByte(NUMERIC);\n                         writeVarInt(scale);\n-                        writeVarLong(b.longValue());\n+                        byte[] bytes = b.toByteArray();\n+                        writeVarInt(bytes.length);\n+                        write(bytes, 0, bytes.length);\n                     }\n-                } else {\n-                    writeByte(NUMERIC);\n-                    writeVarInt(scale);\n-                    byte[] bytes = b.toByteArray();\n-                    writeVarInt(bytes.length);\n-                    write(bytes, 0, bytes.length);\n                 }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.TIME:\n-            if (storeLocalTime) {\n-                writeByte((byte) LOCAL_TIME);\n-                ValueTime t = (ValueTime) v;\n-                long nanos = t.getNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                writeVarLong(millis);\n-                writeVarInt((int) nanos);\n-            } else {\n-                writeByte(TIME);\n-                writeVarLong(LegacyDateTimeUtils.toTime(null, null, v).getTime() + zoneOffsetMillis);\n+            case Value.TIME:\n+                if (storeLocalTime) {\n+                    writeByte((byte) LOCAL_TIME);\n+                    ValueTime t = (ValueTime) v;\n+                    long nanos = t.getNanos();\n+                    long millis = nanos / 1_000_000;\n+                    nanos -= millis * 1_000_000;\n+                    writeVarLong(millis);\n+                    writeVarInt((int) nanos);\n+                } else {\n+                    writeByte(TIME);\n+                    writeVarLong(LegacyDateTimeUtils.toTime(null, null, v)\n+                            .getTime() + zoneOffsetMillis);\n+                }\n+                break;\n+            case Value.TIME_TZ: {\n+                writeByte((byte) TIME_TZ);\n+                ValueTimeTimeZone ts = (ValueTimeTimeZone) v;\n+                long nanosOfDay = ts.getNanos();\n+                writeVarInt(\n+                        (int) (nanosOfDay / DateTimeUtils.NANOS_PER_SECOND));\n+                writeVarInt(\n+                        (int) (nanosOfDay % DateTimeUtils.NANOS_PER_SECOND));\n+                writeTimeZone(ts.getTimeZoneOffsetSeconds());\n+                break;\n             }\n-            break;\n-        case Value.TIME_TZ: {\n-            writeByte((byte) TIME_TZ);\n-            ValueTimeTimeZone ts = (ValueTimeTimeZone) v;\n-            long nanosOfDay = ts.getNanos();\n-            writeVarInt((int) (nanosOfDay / DateTimeUtils.NANOS_PER_SECOND));\n-            writeVarInt((int) (nanosOfDay % DateTimeUtils.NANOS_PER_SECOND));\n-            writeTimeZone(ts.getTimeZoneOffsetSeconds());\n-            break;\n-        }\n-        case Value.DATE: {\n-            if (storeLocalTime) {\n-                writeByte((byte) LOCAL_DATE);\n-                long x = ((ValueDate) v).getDateValue();\n-                writeVarLong(x);\n-            } else {\n-                writeByte(DATE);\n-                long x = LegacyDateTimeUtils.toDate(null, null, v).getTime() + zoneOffsetMillis;\n-                writeVarLong(x / MILLIS_PER_MINUTE);\n+            case Value.DATE: {\n+                if (storeLocalTime) {\n+                    writeByte((byte) LOCAL_DATE);\n+                    long x = ((ValueDate) v).getDateValue();\n+                    writeVarLong(x);\n+                } else {\n+                    writeByte(DATE);\n+                    long x = LegacyDateTimeUtils.toDate(null, null, v)\n+                            .getTime() + zoneOffsetMillis;\n+                    writeVarLong(x / MILLIS_PER_MINUTE);\n+                }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.TIMESTAMP: {\n-            if (storeLocalTime) {\n-                writeByte((byte) LOCAL_TIMESTAMP);\n-                ValueTimestamp ts = (ValueTimestamp) v;\n-                long dateValue = ts.getDateValue();\n-                writeVarLong(dateValue);\n-                long nanos = ts.getTimeNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                writeVarLong(millis);\n-                writeVarInt((int) nanos);\n-            } else {\n-                Timestamp ts = LegacyDateTimeUtils.toTimestamp(null, null, v);\n-                writeByte(TIMESTAMP);\n-                writeVarLong(ts.getTime() + zoneOffsetMillis);\n-                writeVarInt(ts.getNanos() % 1_000_000);\n+            case Value.TIMESTAMP: {\n+                if (storeLocalTime) {\n+                    writeByte((byte) LOCAL_TIMESTAMP);\n+                    ValueTimestamp ts = (ValueTimestamp) v;\n+                    long dateValue = ts.getDateValue();\n+                    writeVarLong(dateValue);\n+                    long nanos = ts.getTimeNanos();\n+                    long millis = nanos / 1_000_000;\n+                    nanos -= millis * 1_000_000;\n+                    writeVarLong(millis);\n+                    writeVarInt((int) nanos);\n+                } else {\n+                    Timestamp ts =\n+                            LegacyDateTimeUtils.toTimestamp(null, null, v);\n+                    writeByte(TIMESTAMP);\n+                    writeVarLong(ts.getTime() + zoneOffsetMillis);\n+                    writeVarInt(ts.getNanos() % 1_000_000);\n+                }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n-            if (timeZoneOffset % 60 == 0) {\n-                writeByte(TIMESTAMP_TZ);\n-                writeVarLong(ts.getDateValue());\n-                writeVarLong(ts.getTimeNanos());\n-                writeVarInt(timeZoneOffset / 60);\n-            } else {\n-                writeByte((byte) TIMESTAMP_TZ_2);\n-                writeVarLong(ts.getDateValue());\n-                writeVarLong(ts.getTimeNanos());\n-                writeTimeZone(timeZoneOffset);\n+            case Value.TIMESTAMP_TZ: {\n+                ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n+                int timeZoneOffset = ts.getTimeZoneOffsetSeconds();\n+                if (timeZoneOffset % 60 == 0) {\n+                    writeByte(TIMESTAMP_TZ);\n+                    writeVarLong(ts.getDateValue());\n+                    writeVarLong(ts.getTimeNanos());\n+                    writeVarInt(timeZoneOffset / 60);\n+                } else {\n+                    writeByte((byte) TIMESTAMP_TZ_2);\n+                    writeVarLong(ts.getDateValue());\n+                    writeVarLong(ts.getTimeNanos());\n+                    writeTimeZone(timeZoneOffset);\n+                }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.GEOMETRY:\n-            // fall though\n-        case Value.JAVA_OBJECT: {\n-            writeByte(type == Value.GEOMETRY ? GEOMETRY : JAVA_OBJECT);\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            writeVarInt(len);\n-            write(b, 0, len);\n-            break;\n-        }\n-        case Value.VARBINARY: {\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            if (len < 32) {\n-                writeByte((byte) (VARBINARY_0_31 + len));\n-                write(b, 0, len);\n-            } else {\n-                writeByte(VARBINARY);\n+            case Value.GEOMETRY:\n+                // fall though\n+            case Value.JAVA_OBJECT: {\n+                writeByte(type == Value.GEOMETRY ? GEOMETRY : JAVA_OBJECT);\n+                byte[] b = v.getBytesNoCopy();\n+                int len = b.length;\n                 writeVarInt(len);\n                 write(b, 0, len);\n+                break;\n             }\n-            break;\n-        }\n-        case Value.UUID: {\n-            writeByte(UUID);\n-            ValueUuid uuid = (ValueUuid) v;\n-            writeLong(uuid.getHigh());\n-            writeLong(uuid.getLow());\n-            break;\n-        }\n-        case Value.VARCHAR: {\n-            String s = v.getString();\n-            int len = s.length();\n-            if (len < 32) {\n-                writeByte((byte) (VARCHAR_0_31 + len));\n-                writeStringWithoutLength(s, len);\n-            } else {\n-                writeByte(VARCHAR);\n-                writeString(s);\n+            case Value.VARBINARY: {\n+                byte[] b = v.getBytesNoCopy();\n+                int len = b.length;\n+                if (len < 32) {\n+                    writeByte((byte) (VARBINARY_0_31 + len));\n+                    write(b, 0, len);\n+                } else {\n+                    writeByte(VARBINARY);\n+                    writeVarInt(len);\n+                    write(b, 0, len);\n+                }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.VARCHAR_IGNORECASE:\n-            writeByte(VARCHAR_IGNORECASE);\n-            writeString(v.getString());\n-            break;\n-        case Value.CHAR:\n-            writeByte(CHAR);\n-            writeString(v.getString());\n-            break;\n-        case Value.DOUBLE: {\n-            double x = v.getDouble();\n-            if (x == 1.0d) {\n-                writeByte((byte) (DOUBLE_0_1 + 1));\n-            } else {\n-                long d = Double.doubleToLongBits(x);\n-                if (d == ValueDouble.ZERO_BITS) {\n-                    writeByte(DOUBLE_0_1);\n+            case Value.UUID: {\n+                writeByte(UUID);\n+                ValueUuid uuid = (ValueUuid) v;\n+                writeLong(uuid.getHigh());\n+                writeLong(uuid.getLow());\n+                break;\n+            }\n+            case Value.VARCHAR: {\n+                String s = v.getString();\n+                int len = s.length();\n+                if (len < 32) {\n+                    writeByte((byte) (VARCHAR_0_31 + len));\n+                    writeStringWithoutLength(s, len);\n                 } else {\n-                    writeByte(DOUBLE);\n-                    writeVarLong(Long.reverse(d));\n+                    writeByte(VARCHAR);\n+                    writeString(s);\n                 }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.REAL: {\n-            float x = v.getFloat();\n-            if (x == 1.0f) {\n-                writeByte((byte) (REAL_0_1 + 1));\n-            } else {\n-                int f = Float.floatToIntBits(x);\n-                if (f == ValueReal.ZERO_BITS) {\n-                    writeByte(REAL_0_1);\n+            case Value.VARCHAR_IGNORECASE:\n+                writeByte(VARCHAR_IGNORECASE);\n+                writeString(v.getString());\n+                break;\n+            case Value.CHAR:\n+                writeByte(CHAR);\n+                writeString(v.getString());\n+                break;\n+            case Value.DOUBLE: {\n+                double x = v.getDouble();\n+                if (x == 1.0d) {\n+                    writeByte((byte) (DOUBLE_0_1 + 1));\n                 } else {\n-                    writeByte(REAL);\n-                    writeVarInt(Integer.reverse(f));\n+                    long d = Double.doubleToLongBits(x);\n+                    if (d == ValueDouble.ZERO_BITS) {\n+                        writeByte(DOUBLE_0_1);\n+                    } else {\n+                        writeByte(DOUBLE);\n+                        writeVarLong(Long.reverse(d));\n+                    }\n                 }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            writeByte(type == Value.BLOB ? BLOB : CLOB);\n-            ValueLob lob = (ValueLob) v;\n-            byte[] small = lob.getSmall();\n-            if (small == null) {\n-                writeVarInt(-3);\n-                writeVarInt(lob.getTableId());\n-                writeVarLong(lob.getLobId());\n-                writeVarLong(lob.getType().getPrecision());\n-            } else {\n-                writeVarInt(small.length);\n-                write(small, 0, small.length);\n+            case Value.REAL: {\n+                float x = v.getFloat();\n+                if (x == 1.0f) {\n+                    writeByte((byte) (REAL_0_1 + 1));\n+                } else {\n+                    int f = Float.floatToIntBits(x);\n+                    if (f == ValueReal.ZERO_BITS) {\n+                        writeByte(REAL_0_1);\n+                    } else {\n+                        writeByte(REAL);\n+                        writeVarInt(Integer.reverse(f));\n+                    }\n+                }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.ARRAY:\n-        case Value.ROW: {\n-            writeByte(type == Value.ARRAY ? ARRAY : ROW);\n-            Value[] list = ((ValueCollectionBase) v).getList();\n-            writeVarInt(list.length);\n-            for (Value x : list) {\n-                writeValue(x);\n+            case Value.BLOB:\n+            case Value.CLOB: {\n+                writeByte(type == Value.BLOB ? BLOB : CLOB);\n+                ValueLob lob = (ValueLob) v;\n+                byte[] small = lob.getSmall();\n+                if (small == null) {\n+                    writeVarInt(-3);\n+                    writeVarInt(lob.getTableId());\n+                    writeVarLong(lob.getLobId());\n+                    writeVarLong(lob.getType().getPrecision());\n+                } else {\n+                    writeVarInt(small.length);\n+                    write(small, 0, small.length);\n+                }\n+                break;\n             }\n-            break;\n-        }\n-        case Value.RESULT_SET: {\n-            writeByte(RESULT_SET);\n-            ResultInterface result = ((ValueResultSet) v).getResult();\n-            result.reset();\n-            int columnCount = result.getVisibleColumnCount();\n-            writeVarInt(columnCount);\n-            for (int i = 0; i < columnCount; i++) {\n-                writeString(result.getAlias(i));\n-                writeString(result.getColumnName(i));\n-                TypeInfo columnType = result.getColumnType(i);\n-                writeVarInt(columnType.getValueType());\n-                writeVarLong(columnType.getPrecision());\n-                writeVarInt(columnType.getScale());\n+            case Value.ARRAY:\n+            case Value.ROW: {\n+                writeByte(type == Value.ARRAY ? ARRAY : ROW);\n+                Value[] list = ((ValueCollectionBase) v).getList();\n+                writeVarInt(list.length);\n+                for (Value x : list) {\n+                    writeValue(x);\n+                }\n+                break;\n             }\n-            while (result.next()) {\n-                writeByte((byte) 1);\n-                Value[] row = result.currentRow();\n+            case Value.RESULT_SET: {\n+                writeByte(RESULT_SET);\n+                ResultInterface result = ((ValueResultSet) v).getResult();\n+                result.reset();\n+                int columnCount = result.getVisibleColumnCount();\n+                writeVarInt(columnCount);\n                 for (int i = 0; i < columnCount; i++) {\n-                    writeValue(row[i]);\n+                    writeString(result.getAlias(i));\n+                    writeString(result.getColumnName(i));\n+                    TypeInfo columnType = result.getColumnType(i);\n+                    writeVarInt(columnType.getValueType());\n+                    writeVarLong(columnType.getPrecision());\n+                    writeVarInt(columnType.getScale());\n+                }\n+                while (result.next()) {\n+                    writeByte((byte) 1);\n+                    Value[] row = result.currentRow();\n+                    for (int i = 0; i < columnCount; i++) {\n+                        writeValue(row[i]);\n+                    }\n                 }\n+                writeByte((byte) 0);\n+                break;\n             }\n-            writeByte((byte) 0);\n-            break;\n-        }\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE: {\n-            ValueInterval interval = (ValueInterval) v;\n-            int ordinal = type - Value.INTERVAL_YEAR;\n-            if (interval.isNegative()) {\n-                ordinal = ~ordinal;\n+            case Value.INTERVAL_YEAR:\n+            case Value.INTERVAL_MONTH:\n+            case Value.INTERVAL_DAY:\n+            case Value.INTERVAL_HOUR:\n+            case Value.INTERVAL_MINUTE: {\n+                ValueInterval interval = (ValueInterval) v;\n+                int ordinal = type - Value.INTERVAL_YEAR;\n+                if (interval.isNegative()) {\n+                    ordinal = ~ordinal;\n+                }\n+                writeByte(INTERVAL);\n+                writeByte((byte) ordinal);\n+                writeVarLong(interval.getLeading());\n+                break;\n             }\n-            writeByte(INTERVAL);\n-            writeByte((byte) ordinal);\n-            writeVarLong(interval.getLeading());\n-            break;\n-        }\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND: {\n-            ValueInterval interval = (ValueInterval) v;\n-            int ordinal = type - Value.INTERVAL_YEAR;\n-            if (interval.isNegative()) {\n-                ordinal = ~ordinal;\n+            case Value.INTERVAL_SECOND:\n+            case Value.INTERVAL_YEAR_TO_MONTH:\n+            case Value.INTERVAL_DAY_TO_HOUR:\n+            case Value.INTERVAL_DAY_TO_MINUTE:\n+            case Value.INTERVAL_DAY_TO_SECOND:\n+            case Value.INTERVAL_HOUR_TO_MINUTE:\n+            case Value.INTERVAL_HOUR_TO_SECOND:\n+            case Value.INTERVAL_MINUTE_TO_SECOND: {\n+                ValueInterval interval = (ValueInterval) v;\n+                int ordinal = type - Value.INTERVAL_YEAR;\n+                if (interval.isNegative()) {\n+                    ordinal = ~ordinal;\n+                }\n+                writeByte(INTERVAL);\n+                writeByte((byte) ordinal);\n+                writeVarLong(interval.getLeading());\n+                writeVarLong(interval.getRemaining());\n+                break;\n             }\n-            writeByte(INTERVAL);\n-            writeByte((byte) ordinal);\n-            writeVarLong(interval.getLeading());\n-            writeVarLong(interval.getRemaining());\n-            break;\n-        }\n-        case Value.JSON: {\n-            writeByte((byte) JSON);\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            writeVarInt(len);\n-            write(b, 0, len);\n-            break;\n-        }\n-        default:\n-            DbException.throwInternalError(\"type=\" + v.getValueType());\n+            case Value.JSON: {\n+                writeByte((byte) JSON);\n+                byte[] b = v.getBytesNoCopy();\n+                int len = b.length;\n+                writeVarInt(len);\n+                write(b, 0, len);\n+                break;\n+            }\n+            default:\n+                DbException.throwInternalError(\"type=\" + v.getValueType());\n         }\n         assert pos - start == getValueLen(v)\n-                : \"value size error: got \" + (pos - start) + \" expected \" + getValueLen(v);\n+                : \"value size error: got \" + (pos - start) + \" expected \" +\n+                getValueLen(v);\n     }\n \n     /**\n@@ -787,191 +795,216 @@ public class Data {\n     public Value readValue() {\n         int type = data[pos++] & 255;\n         switch (type) {\n-        case NULL:\n-            return ValueNull.INSTANCE;\n-        case BOOLEAN_TRUE:\n-            return ValueBoolean.TRUE;\n-        case BOOLEAN_FALSE:\n-            return ValueBoolean.FALSE;\n-        case INT_NEG:\n-            return ValueInteger.get(-readVarInt());\n-        case ENUM:\n-        case INTEGER:\n-            return ValueInteger.get(readVarInt());\n-        case BIGINT_NEG:\n-            return ValueBigint.get(-readVarLong());\n-        case Value.BIGINT:\n-            return ValueBigint.get(readVarLong());\n-        case TINYINT:\n-            return ValueTinyint.get(readByte());\n-        case SMALLINT:\n-            return ValueSmallint.get(readShortInt());\n-        case NUMERIC_0_1:\n-            return ValueNumeric.ZERO;\n-        case NUMERIC_0_1 + 1:\n-            return ValueNumeric.ONE;\n-        case NUMERIC_SMALL_0:\n-            return ValueNumeric.get(BigDecimal.valueOf(readVarLong()));\n-        case NUMERIC_SMALL: {\n-            int scale = readVarInt();\n-            return ValueNumeric.get(BigDecimal.valueOf(readVarLong(), scale));\n-        }\n-        case NUMERIC: {\n-            int scale = readVarInt();\n-            int len = readVarInt();\n-            byte[] buff = Utils.newBytes(len);\n-            read(buff, 0, len);\n-            BigInteger b = new BigInteger(buff);\n-            return ValueNumeric.get(new BigDecimal(b, scale));\n-        }\n-        case LOCAL_DATE:\n-            return ValueDate.fromDateValue(readVarLong());\n-        case DATE: {\n-            long ms = readVarLong() * MILLIS_PER_MINUTE - zoneOffsetMillis;\n-            return ValueDate.fromDateValue(LegacyDateTimeUtils.dateValueFromLocalMillis(\n-                    ms + LegacyDateTimeUtils.getTimeZoneOffsetMillis(null, ms)));\n-        }\n-        case LOCAL_TIME:\n-            return ValueTime.fromNanos(readVarLong() * 1_000_000 + readVarInt());\n-        case TIME: {\n-            long ms = readVarLong() - zoneOffsetMillis;\n-            return ValueTime.fromNanos(LegacyDateTimeUtils.nanosFromLocalMillis(\n-                    ms + LegacyDateTimeUtils.getTimeZoneOffsetMillis(null, ms)));\n-        }\n-        case TIME_TZ:\n-            return ValueTimeTimeZone.fromNanos(readVarInt() * DateTimeUtils.NANOS_PER_SECOND + readVarInt(),\n-                    readTimeZone());\n-        case LOCAL_TIMESTAMP:\n-            return ValueTimestamp.fromDateValueAndNanos(readVarLong(), readVarLong() * 1_000_000 + readVarInt());\n-        case TIMESTAMP:\n-            return LegacyDateTimeUtils.fromTimestamp(null, readVarLong() - zoneOffsetMillis, readVarInt() % 1_000_000);\n-        case TIMESTAMP_TZ: {\n-            long dateValue = readVarLong();\n-            long nanos = readVarLong();\n-            int tz = readVarInt() * 60;\n-            return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n-        }\n-        case TIMESTAMP_TZ_2: {\n-            long dateValue = readVarLong();\n-            long nanos = readVarLong();\n-            int tz = readTimeZone();\n-            return ValueTimestampTimeZone.fromDateValueAndNanos(dateValue, nanos, tz);\n-        }\n-        case VARBINARY: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueVarbinary.getNoCopy(b);\n-        }\n-        case GEOMETRY: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueGeometry.get(b);\n-        }\n-        case JAVA_OBJECT: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueJavaObject.getNoCopy(null, b, handler);\n-        }\n-        case UUID:\n-            return ValueUuid.get(readLong(), readLong());\n-        case VARCHAR:\n-            return ValueVarchar.get(readString());\n-        case VARCHAR_IGNORECASE:\n-            return ValueVarcharIgnoreCase.get(readString());\n-        case CHAR:\n-            return ValueChar.get(readString());\n-        case REAL_0_1:\n-            return ValueReal.ZERO;\n-        case REAL_0_1 + 1:\n-            return ValueReal.ONE;\n-        case DOUBLE_0_1:\n-            return ValueDouble.ZERO;\n-        case DOUBLE_0_1 + 1:\n-            return ValueDouble.ONE;\n-        case DOUBLE:\n-            return ValueDouble.get(Double.longBitsToDouble(Long.reverse(readVarLong())));\n-        case REAL:\n-            return ValueReal.get(Float.intBitsToFloat(Integer.reverse(readVarInt())));\n-        case BLOB:\n-        case CLOB: {\n-            int smallLen = readVarInt();\n-            if (smallLen >= 0) {\n-                byte[] small = Utils.newBytes(smallLen);\n-                read(small, 0, smallLen);\n-                return ValueLob.createSmallLob(type == BLOB ? Value.BLOB : Value.CLOB, small);\n-            } else if (smallLen == -3) {\n-                int tableId = readVarInt();\n-                long lobId = readVarLong();\n-                long precision = readVarLong();\n-                return ValueLob.create(type == BLOB ? Value.BLOB : Value.CLOB, handler, tableId,\n-                        lobId, null, precision);\n-            } else {\n-                throw getOldLobException(smallLen);\n+            case NULL:\n+                return ValueNull.INSTANCE;\n+            case BOOLEAN_TRUE:\n+                return ValueBoolean.TRUE;\n+            case BOOLEAN_FALSE:\n+                return ValueBoolean.FALSE;\n+            case INT_NEG:\n+                return ValueInteger.get(-readVarInt());\n+            case ENUM:\n+            case INTEGER:\n+                return ValueInteger.get(readVarInt());\n+            case BIGINT_NEG:\n+                return ValueBigint.get(-readVarLong());\n+            case Value.BIGINT:\n+                return ValueBigint.get(readVarLong());\n+            case TINYINT:\n+                return ValueTinyint.get(readByte());\n+            case SMALLINT:\n+                return ValueSmallint.get(readShortInt());\n+            case NUMERIC_0_1:\n+                return ValueNumeric.ZERO;\n+            case NUMERIC_0_1 + 1:\n+                return ValueNumeric.ONE;\n+            case NUMERIC_SMALL_0:\n+                return ValueNumeric.get(BigDecimal.valueOf(readVarLong()));\n+            case NUMERIC_SMALL: {\n+                int scale = readVarInt();\n+                return ValueNumeric\n+                        .get(BigDecimal.valueOf(readVarLong(), scale));\n             }\n-        }\n-        case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n-        {\n-            int len = readVarInt();\n-            Value[] list = new Value[len];\n-            for (int i = 0; i < len; i++) {\n-                list[i] = readValue();\n+            case NUMERIC: {\n+                int scale = readVarInt();\n+                int len = readVarInt();\n+                byte[] buff = Utils.newBytes(len);\n+                read(buff, 0, len);\n+                BigInteger b = new BigInteger(buff);\n+                return ValueNumeric.get(new BigDecimal(b, scale));\n             }\n-            return type == ARRAY ? ValueArray.get(list) : ValueRow.get(list);\n-        }\n-        case RESULT_SET: {\n-            SimpleResult rs = new SimpleResult();\n-            int columns = readVarInt();\n-            for (int i = 0; i < columns; i++) {\n-                rs.addColumn(readString(), readString(), readVarInt(), readVarLong(), readVarInt());\n+            case LOCAL_DATE:\n+                return ValueDate.fromDateValue(readVarLong());\n+            case DATE: {\n+                long ms = readVarLong() * MILLIS_PER_MINUTE - zoneOffsetMillis;\n+                return ValueDate.fromDateValue(\n+                        LegacyDateTimeUtils.dateValueFromLocalMillis(\n+                                ms + LegacyDateTimeUtils\n+                                        .getTimeZoneOffsetMillis(null, ms)));\n+            }\n+            case LOCAL_TIME:\n+                return ValueTime\n+                        .fromNanos(readVarLong() * 1_000_000 + readVarInt());\n+            case TIME: {\n+                long ms = readVarLong() - zoneOffsetMillis;\n+                return ValueTime\n+                        .fromNanos(LegacyDateTimeUtils.nanosFromLocalMillis(\n+                                ms + LegacyDateTimeUtils\n+                                        .getTimeZoneOffsetMillis(null, ms)));\n+            }\n+            case TIME_TZ:\n+                return ValueTimeTimeZone.fromNanos(\n+                        readVarInt() * DateTimeUtils.NANOS_PER_SECOND +\n+                                readVarInt(),\n+                        readTimeZone());\n+            case LOCAL_TIMESTAMP:\n+                return ValueTimestamp.fromDateValueAndNanos(readVarLong(),\n+                        readVarLong() * 1_000_000 + readVarInt());\n+            case TIMESTAMP:\n+                return LegacyDateTimeUtils\n+                        .fromTimestamp(null, readVarLong() - zoneOffsetMillis,\n+                                readVarInt() % 1_000_000);\n+            case TIMESTAMP_TZ: {\n+                long dateValue = readVarLong();\n+                long nanos = readVarLong();\n+                int tz = readVarInt() * 60;\n+                return ValueTimestampTimeZone\n+                        .fromDateValueAndNanos(dateValue, nanos, tz);\n+            }\n+            case TIMESTAMP_TZ_2: {\n+                long dateValue = readVarLong();\n+                long nanos = readVarLong();\n+                int tz = readTimeZone();\n+                return ValueTimestampTimeZone\n+                        .fromDateValueAndNanos(dateValue, nanos, tz);\n+            }\n+            case VARBINARY: {\n+                int len = readVarInt();\n+                byte[] b = Utils.newBytes(len);\n+                read(b, 0, len);\n+                return ValueVarbinary.getNoCopy(b);\n+            }\n+            case GEOMETRY: {\n+                int len = readVarInt();\n+                byte[] b = Utils.newBytes(len);\n+                read(b, 0, len);\n+                return ValueGeometry.get(b);\n+            }\n+            case JAVA_OBJECT: {\n+                int len = readVarInt();\n+                byte[] b = Utils.newBytes(len);\n+                read(b, 0, len);\n+                return ValueJavaObject.getNoCopy(null, b, handler);\n+            }\n+            case UUID:\n+                return ValueUuid.get(readLong(), readLong());\n+            case VARCHAR:\n+                return ValueVarchar.get(readString());\n+            case VARCHAR_IGNORECASE:\n+                return ValueVarcharIgnoreCase.get(readString());\n+            case CHAR:\n+                return ValueChar.get(readString());\n+            case REAL_0_1:\n+                return ValueReal.ZERO;\n+            case REAL_0_1 + 1:\n+                return ValueReal.ONE;\n+            case DOUBLE_0_1:\n+                return ValueDouble.ZERO;\n+            case DOUBLE_0_1 + 1:\n+                return ValueDouble.ONE;\n+            case DOUBLE:\n+                return ValueDouble.get(Double\n+                        .longBitsToDouble(Long.reverse(readVarLong())));\n+            case REAL:\n+                return ValueReal.get(Float\n+                        .intBitsToFloat(Integer.reverse(readVarInt())));\n+            case BLOB:\n+            case CLOB: {\n+                int smallLen = readVarInt();\n+                if (smallLen >= 0) {\n+                    byte[] small = Utils.newBytes(smallLen);\n+                    read(small, 0, smallLen);\n+                    return ValueLob.createSmallLob(\n+                            type == BLOB ? Value.BLOB : Value.CLOB, small);\n+                } else if (smallLen == -3) {\n+                    int tableId = readVarInt();\n+                    long lobId = readVarLong();\n+                    long precision = readVarLong();\n+                    return ValueLob\n+                            .create(type == BLOB ? Value.BLOB : Value.CLOB,\n+                                    handler, tableId,\n+                                    lobId, null, precision);\n+                } else {\n+                    throw getOldLobException(smallLen);\n+                }\n+            }\n+            case ARRAY:\n+            case ROW: // Special storage type for ValueRow\n+            {\n+                int len = readVarInt();\n+                Value[] list = new Value[len];\n+                for (int i = 0; i < len; i++) {\n+                    list[i] = readValue();\n+                }\n+                return type == ARRAY ? ValueArray.get(list) :\n+                        ValueRow.get(list);\n             }\n-            while (readByte() != 0) {\n-                Value[] o = new Value[columns];\n+            case RESULT_SET: {\n+                SimpleResult rs = new SimpleResult();\n+                int columns = readVarInt();\n                 for (int i = 0; i < columns; i++) {\n-                    o[i] = readValue();\n+                    rs.addColumn(readString(), readString(), readVarInt(),\n+                            readVarLong(), readVarInt());\n                 }\n-                rs.addRow(o);\n+                while (readByte() != 0) {\n+                    Value[] o = new Value[columns];\n+                    for (int i = 0; i < columns; i++) {\n+                        o[i] = readValue();\n+                    }\n+                    rs.addRow(o);\n+                }\n+                return ValueResultSet.get(rs);\n             }\n-            return ValueResultSet.get(rs);\n-        }\n-        case INTERVAL: {\n-            int ordinal = readByte();\n-            boolean negative = ordinal < 0;\n-            if (negative) {\n-                ordinal = ~ordinal;\n+            case INTERVAL: {\n+                int ordinal = readByte();\n+                boolean negative = ordinal < 0;\n+                if (negative) {\n+                    ordinal = ~ordinal;\n+                }\n+                return ValueInterval\n+                        .from(IntervalQualifier.valueOf(ordinal), negative,\n+                                readVarLong(),\n+                                ordinal < 5 ? 0 : readVarLong());\n             }\n-            return ValueInterval.from(IntervalQualifier.valueOf(ordinal), negative, readVarLong(),\n-                    ordinal < 5 ? 0 : readVarLong());\n-        }\n-        case JSON: {\n-            int len = readVarInt();\n-            byte[] b = Utils.newBytes(len);\n-            read(b, 0, len);\n-            return ValueJson.getInternal(b);\n-        }\n-        default:\n-            if (type >= INT_0_15 && type < INT_0_15 + 16) {\n-                return ValueInteger.get(type - INT_0_15);\n-            } else if (type >= BIGINT_0_7 && type < BIGINT_0_7 + 8) {\n-                return ValueBigint.get(type - BIGINT_0_7);\n-            } else if (type >= VARBINARY_0_31 && type < VARBINARY_0_31 + 32) {\n-                int len = type - VARBINARY_0_31;\n+            case JSON: {\n+                int len = readVarInt();\n                 byte[] b = Utils.newBytes(len);\n                 read(b, 0, len);\n-                return ValueVarbinary.getNoCopy(b);\n-            } else if (type >= VARCHAR_0_31 && type < VARCHAR_0_31 + 32) {\n-                return ValueVarchar.get(readString(type - VARCHAR_0_31));\n+                return ValueJson.getInternal(b);\n             }\n-            throw DbException.get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n+            default:\n+                if (type >= INT_0_15 && type < INT_0_15 + 16) {\n+                    return ValueInteger.get(type - INT_0_15);\n+                } else if (type >= BIGINT_0_7 && type < BIGINT_0_7 + 8) {\n+                    return ValueBigint.get(type - BIGINT_0_7);\n+                } else if (type >= VARBINARY_0_31 &&\n+                        type < VARBINARY_0_31 + 32) {\n+                    int len = type - VARBINARY_0_31;\n+                    byte[] b = Utils.newBytes(len);\n+                    read(b, 0, len);\n+                    return ValueVarbinary.getNoCopy(b);\n+                } else if (type >= VARCHAR_0_31 && type < VARCHAR_0_31 + 32) {\n+                    return ValueVarchar.get(readString(type - VARCHAR_0_31));\n+                }\n+                throw DbException\n+                        .get(ErrorCode.FILE_CORRUPTED_1, \"type: \" + type);\n         }\n     }\n \n     private DbException getOldLobException(int smallLen) {\n         if (handler == null) {\n-            return DbException.get(ErrorCode.FILE_CORRUPTED_1, \"lob type: \" + smallLen);\n+            return DbException\n+                    .get(ErrorCode.FILE_CORRUPTED_1, \"lob type: \" + smallLen);\n         } else {\n             String s = handler.toString();\n             int idx = s.lastIndexOf(':');\n@@ -995,10 +1028,9 @@ public class Data {\n     /**\n      * Calculate the number of bytes required to encode the given value.\n      *\n-     * @param v the value\n-     * @param storeLocalTime\n-     *            calculate size of DATE, TIME, and TIMESTAMP values with local\n-     *            time storage format\n+     * @param v              the value\n+     * @param storeLocalTime calculate size of DATE, TIME, and TIMESTAMP values with local\n+     *                       time storage format\n      * @return the number of bytes required to store this value\n      */\n     public static int getValueLen(Value v, boolean storeLocalTime) {\n@@ -1006,218 +1038,231 @@ public class Data {\n             return 1;\n         }\n         switch (v.getValueType()) {\n-        case Value.BOOLEAN:\n-            return 1;\n-        case Value.TINYINT:\n-            return 2;\n-        case Value.SMALLINT:\n-            return 3;\n-        case Value.ENUM:\n-        case Value.INTEGER: {\n-            int x = v.getInt();\n-            if (x < 0) {\n-                return 1 + getVarIntLen(-x);\n-            } else if (x < 16) {\n-                return 1;\n-            } else {\n-                return 1 + getVarIntLen(x);\n-            }\n-        }\n-        case Value.BIGINT: {\n-            long x = v.getLong();\n-            if (x < 0) {\n-                return 1 + getVarLongLen(-x);\n-            } else if (x < 8) {\n-                return 1;\n-            } else {\n-                return 1 + getVarLongLen(x);\n-            }\n-        }\n-        case Value.DOUBLE: {\n-            double x = v.getDouble();\n-            if (x == 1.0d) {\n+            case Value.BOOLEAN:\n                 return 1;\n+            case Value.TINYINT:\n+                return 2;\n+            case Value.SMALLINT:\n+                return 3;\n+            case Value.ENUM:\n+            case Value.INTEGER: {\n+                int x = v.getInt();\n+                if (x < 0) {\n+                    return 1 + getVarIntLen(-x);\n+                } else if (x < 16) {\n+                    return 1;\n+                } else {\n+                    return 1 + getVarIntLen(x);\n+                }\n             }\n-            long d = Double.doubleToLongBits(x);\n-            if (d == ValueDouble.ZERO_BITS) {\n-                return 1;\n+            case Value.BIGINT: {\n+                long x = v.getLong();\n+                if (x < 0) {\n+                    return 1 + getVarLongLen(-x);\n+                } else if (x < 8) {\n+                    return 1;\n+                } else {\n+                    return 1 + getVarLongLen(x);\n+                }\n             }\n-            return 1 + getVarLongLen(Long.reverse(d));\n-        }\n-        case Value.REAL: {\n-            float x = v.getFloat();\n-            if (x == 1.0f) {\n-                return 1;\n+            case Value.DOUBLE: {\n+                double x = v.getDouble();\n+                if (x == 1.0d) {\n+                    return 1;\n+                }\n+                long d = Double.doubleToLongBits(x);\n+                if (d == ValueDouble.ZERO_BITS) {\n+                    return 1;\n+                }\n+                return 1 + getVarLongLen(Long.reverse(d));\n             }\n-            int f = Float.floatToIntBits(x);\n-            if (f == ValueReal.ZERO_BITS) {\n-                return 1;\n+            case Value.REAL: {\n+                float x = v.getFloat();\n+                if (x == 1.0f) {\n+                    return 1;\n+                }\n+                int f = Float.floatToIntBits(x);\n+                if (f == ValueReal.ZERO_BITS) {\n+                    return 1;\n+                }\n+                return 1 + getVarIntLen(Integer.reverse(f));\n             }\n-            return 1 + getVarIntLen(Integer.reverse(f));\n-        }\n-        case Value.VARCHAR: {\n-            String s = v.getString();\n-            int len = s.length();\n-            if (len < 32) {\n-                return 1 + getStringWithoutLengthLen(s, len);\n+            case Value.VARCHAR: {\n+                String s = v.getString();\n+                int len = s.length();\n+                if (len < 32) {\n+                    return 1 + getStringWithoutLengthLen(s, len);\n+                }\n+                return 1 + getStringLen(s);\n             }\n-            return 1 + getStringLen(s);\n-        }\n-        case Value.VARCHAR_IGNORECASE:\n-        case Value.CHAR:\n-            return 1 + getStringLen(v.getString());\n-        case Value.NUMERIC: {\n-            BigDecimal x = v.getBigDecimal();\n-            if (BigDecimal.ZERO.equals(x)) {\n-                return 1;\n-            } else if (BigDecimal.ONE.equals(x)) {\n-                return 1;\n+            case Value.VARCHAR_IGNORECASE:\n+            case Value.CHAR:\n+                return 1 + getStringLen(v.getString());\n+            case Value.NUMERIC: {\n+                BigDecimal x = v.getBigDecimal();\n+                if (BigDecimal.ZERO.equals(x)) {\n+                    return 1;\n+                } else if (BigDecimal.ONE.equals(x)) {\n+                    return 1;\n+                }\n+                int scale = x.scale();\n+                BigInteger b = x.unscaledValue();\n+                int bits = b.bitLength();\n+                if (bits <= 63) {\n+                    if (scale == 0) {\n+                        return 1 + getVarLongLen(b.longValue());\n+                    }\n+                    return 1 + getVarIntLen(scale) +\n+                            getVarLongLen(b.longValue());\n+                }\n+                byte[] bytes = b.toByteArray();\n+                return 1 + getVarIntLen(scale) + getVarIntLen(bytes.length) +\n+                        bytes.length;\n             }\n-            int scale = x.scale();\n-            BigInteger b = x.unscaledValue();\n-            int bits = b.bitLength();\n-            if (bits <= 63) {\n-                if (scale == 0) {\n-                    return 1 + getVarLongLen(b.longValue());\n+            case Value.TIME:\n+                if (storeLocalTime) {\n+                    long nanos = ((ValueTime) v).getNanos();\n+                    long millis = nanos / 1_000_000;\n+                    nanos -= millis * 1_000_000;\n+                    return 1 + getVarLongLen(millis) + getVarLongLen(nanos);\n                 }\n-                return 1 + getVarIntLen(scale) + getVarLongLen(b.longValue());\n+                return 1 + getVarLongLen(\n+                        LegacyDateTimeUtils.toTime(null, null, v).getTime() +\n+                                zoneOffsetMillis);\n+            case Value.TIME_TZ: {\n+                ValueTimeTimeZone ts = (ValueTimeTimeZone) v;\n+                long nanosOfDay = ts.getNanos();\n+                int tz = ts.getTimeZoneOffsetSeconds();\n+                return 1 + getVarIntLen(\n+                        (int) (nanosOfDay / DateTimeUtils.NANOS_PER_SECOND))\n+                        + getVarIntLen(\n+                        (int) (nanosOfDay % DateTimeUtils.NANOS_PER_SECOND)) +\n+                        getTimeZoneLen(tz);\n             }\n-            byte[] bytes = b.toByteArray();\n-            return 1 + getVarIntLen(scale) + getVarIntLen(bytes.length) + bytes.length;\n-        }\n-        case Value.TIME:\n-            if (storeLocalTime) {\n-                long nanos = ((ValueTime) v).getNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                return 1 + getVarLongLen(millis) + getVarLongLen(nanos);\n+            case Value.DATE: {\n+                if (storeLocalTime) {\n+                    long dateValue = ((ValueDate) v).getDateValue();\n+                    return 1 + getVarLongLen(dateValue);\n+                }\n+                long x = LegacyDateTimeUtils.toDate(null, null, v).getTime() +\n+                        zoneOffsetMillis;\n+                return 1 + getVarLongLen(x / MILLIS_PER_MINUTE);\n             }\n-            return 1 + getVarLongLen(LegacyDateTimeUtils.toTime(null, null, v).getTime() + zoneOffsetMillis);\n-        case Value.TIME_TZ: {\n-            ValueTimeTimeZone ts = (ValueTimeTimeZone) v;\n-            long nanosOfDay = ts.getNanos();\n-            int tz = ts.getTimeZoneOffsetSeconds();\n-            return 1 + getVarIntLen((int) (nanosOfDay / DateTimeUtils.NANOS_PER_SECOND))\n-                    + getVarIntLen((int) (nanosOfDay % DateTimeUtils.NANOS_PER_SECOND)) + getTimeZoneLen(tz);\n-        }\n-        case Value.DATE: {\n-            if (storeLocalTime) {\n-                long dateValue = ((ValueDate) v).getDateValue();\n-                return 1 + getVarLongLen(dateValue);\n+            case Value.TIMESTAMP: {\n+                if (storeLocalTime) {\n+                    ValueTimestamp ts = (ValueTimestamp) v;\n+                    long dateValue = ts.getDateValue();\n+                    long nanos = ts.getTimeNanos();\n+                    long millis = nanos / 1_000_000;\n+                    nanos -= millis * 1_000_000;\n+                    return 1 + getVarLongLen(dateValue) +\n+                            getVarLongLen(millis) +\n+                            getVarLongLen(nanos);\n+                }\n+                Timestamp ts = LegacyDateTimeUtils.toTimestamp(null, null, v);\n+                return 1 + getVarLongLen(ts.getTime() + zoneOffsetMillis) +\n+                        getVarIntLen(ts.getNanos() % 1_000_000);\n             }\n-            long x = LegacyDateTimeUtils.toDate(null, null, v).getTime() + zoneOffsetMillis;\n-            return 1 + getVarLongLen(x / MILLIS_PER_MINUTE);\n-        }\n-        case Value.TIMESTAMP: {\n-            if (storeLocalTime) {\n-                ValueTimestamp ts = (ValueTimestamp) v;\n+            case Value.TIMESTAMP_TZ: {\n+                ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n                 long dateValue = ts.getDateValue();\n                 long nanos = ts.getTimeNanos();\n-                long millis = nanos / 1_000_000;\n-                nanos -= millis * 1_000_000;\n-                return 1 + getVarLongLen(dateValue) + getVarLongLen(millis) +\n-                        getVarLongLen(nanos);\n+                int tz = ts.getTimeZoneOffsetSeconds();\n+                return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) +\n+                        (tz % 60 == 0 ? getVarIntLen(tz / 60) :\n+                                getTimeZoneLen(tz));\n             }\n-            Timestamp ts = LegacyDateTimeUtils.toTimestamp(null, null, v);\n-            return 1 + getVarLongLen(ts.getTime() + zoneOffsetMillis) + getVarIntLen(ts.getNanos() % 1_000_000);\n-        }\n-        case Value.TIMESTAMP_TZ: {\n-            ValueTimestampTimeZone ts = (ValueTimestampTimeZone) v;\n-            long dateValue = ts.getDateValue();\n-            long nanos = ts.getTimeNanos();\n-            int tz = ts.getTimeZoneOffsetSeconds();\n-            return 1 + getVarLongLen(dateValue) + getVarLongLen(nanos) +\n-                    (tz % 60 == 0 ? getVarIntLen(tz / 60) : getTimeZoneLen(tz));\n-        }\n-        case Value.GEOMETRY:\n-        case Value.JAVA_OBJECT: {\n-            byte[] b = v.getBytesNoCopy();\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        case Value.VARBINARY: {\n-            byte[] b = v.getBytesNoCopy();\n-            int len = b.length;\n-            if (len < 32) {\n-                return 1 + b.length;\n+            case Value.GEOMETRY:\n+            case Value.JAVA_OBJECT: {\n+                byte[] b = v.getBytesNoCopy();\n+                return 1 + getVarIntLen(b.length) + b.length;\n             }\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        case Value.UUID:\n-            return 1 + LENGTH_LONG + LENGTH_LONG;\n-        case Value.BLOB:\n-        case Value.CLOB: {\n-            int len = 1;\n-            ValueLob lob = (ValueLob) v;\n-            byte[] small = lob.getSmall();\n-            if (small == null) {\n-                len += getVarIntLen(-3);\n-                len += getVarIntLen(lob.getTableId());\n-                len += getVarLongLen(lob.getLobId());\n-                len += getVarLongLen(lob.getType().getPrecision());\n-            } else {\n-                len += getVarIntLen(small.length);\n-                len += small.length;\n+            case Value.VARBINARY: {\n+                byte[] b = v.getBytesNoCopy();\n+                int len = b.length;\n+                if (len < 32) {\n+                    return 1 + b.length;\n+                }\n+                return 1 + getVarIntLen(b.length) + b.length;\n             }\n-            return len;\n-        }\n-        case Value.ARRAY:\n-        case Value.ROW: {\n-            Value[] list = ((ValueCollectionBase) v).getList();\n-            int len = 1 + getVarIntLen(list.length);\n-            for (Value x : list) {\n-                len += getValueLen(x, storeLocalTime);\n+            case Value.UUID:\n+                return 1 + LENGTH_LONG + LENGTH_LONG;\n+            case Value.BLOB:\n+            case Value.CLOB: {\n+                int len = 1;\n+                ValueLob lob = (ValueLob) v;\n+                byte[] small = lob.getSmall();\n+                if (small == null) {\n+                    len += getVarIntLen(-3);\n+                    len += getVarIntLen(lob.getTableId());\n+                    len += getVarLongLen(lob.getLobId());\n+                    len += getVarLongLen(lob.getType().getPrecision());\n+                } else {\n+                    len += getVarIntLen(small.length);\n+                    len += small.length;\n+                }\n+                return len;\n             }\n-            return len;\n-        }\n-        case Value.RESULT_SET: {\n-            int len = 1;\n-            ResultInterface result = ((ValueResultSet) v).getResult();\n-            int columnCount = result.getVisibleColumnCount();\n-            len += getVarIntLen(columnCount);\n-            for (int i = 0; i < columnCount; i++) {\n-                len += getStringLen(result.getAlias(i));\n-                len += getStringLen(result.getColumnName(i));\n-                TypeInfo columnType = result.getColumnType(i);\n-                len += getVarIntLen(columnType.getValueType());\n-                len += getVarLongLen(columnType.getPrecision());\n-                len += getVarIntLen(columnType.getScale());\n+            case Value.ARRAY:\n+            case Value.ROW: {\n+                Value[] list = ((ValueCollectionBase) v).getList();\n+                int len = 1 + getVarIntLen(list.length);\n+                for (Value x : list) {\n+                    len += getValueLen(x, storeLocalTime);\n+                }\n+                return len;\n             }\n-            while (result.next()) {\n-                len++;\n-                Value[] row = result.currentRow();\n+            case Value.RESULT_SET: {\n+                int len = 1;\n+                ResultInterface result = ((ValueResultSet) v).getResult();\n+                int columnCount = result.getVisibleColumnCount();\n+                len += getVarIntLen(columnCount);\n                 for (int i = 0; i < columnCount; i++) {\n-                    Value val = row[i];\n-                    len += getValueLen(val, storeLocalTime);\n+                    len += getStringLen(result.getAlias(i));\n+                    len += getStringLen(result.getColumnName(i));\n+                    TypeInfo columnType = result.getColumnType(i);\n+                    len += getVarIntLen(columnType.getValueType());\n+                    len += getVarLongLen(columnType.getPrecision());\n+                    len += getVarIntLen(columnType.getScale());\n                 }\n+                while (result.next()) {\n+                    len++;\n+                    Value[] row = result.currentRow();\n+                    for (int i = 0; i < columnCount; i++) {\n+                        Value val = row[i];\n+                        len += getValueLen(val, storeLocalTime);\n+                    }\n+                }\n+                len++;\n+                return len;\n             }\n-            len++;\n-            return len;\n-        }\n-        case Value.INTERVAL_YEAR:\n-        case Value.INTERVAL_MONTH:\n-        case Value.INTERVAL_DAY:\n-        case Value.INTERVAL_HOUR:\n-        case Value.INTERVAL_MINUTE: {\n-            ValueInterval interval = (ValueInterval) v;\n-            return 2 + getVarLongLen(interval.getLeading());\n-        }\n-        case Value.INTERVAL_SECOND:\n-        case Value.INTERVAL_YEAR_TO_MONTH:\n-        case Value.INTERVAL_DAY_TO_HOUR:\n-        case Value.INTERVAL_DAY_TO_MINUTE:\n-        case Value.INTERVAL_DAY_TO_SECOND:\n-        case Value.INTERVAL_HOUR_TO_MINUTE:\n-        case Value.INTERVAL_HOUR_TO_SECOND:\n-        case Value.INTERVAL_MINUTE_TO_SECOND: {\n-            ValueInterval interval = (ValueInterval) v;\n-            return 2 + getVarLongLen(interval.getLeading()) + getVarLongLen(interval.getRemaining());\n-        }\n-        case Value.JSON: {\n-            byte[] b = v.getBytesNoCopy();\n-            return 1 + getVarIntLen(b.length) + b.length;\n-        }\n-        default:\n-            throw DbException.throwInternalError(\"type=\" + v.getValueType());\n+            case Value.INTERVAL_YEAR:\n+            case Value.INTERVAL_MONTH:\n+            case Value.INTERVAL_DAY:\n+            case Value.INTERVAL_HOUR:\n+            case Value.INTERVAL_MINUTE: {\n+                ValueInterval interval = (ValueInterval) v;\n+                return 2 + getVarLongLen(interval.getLeading());\n+            }\n+            case Value.INTERVAL_SECOND:\n+            case Value.INTERVAL_YEAR_TO_MONTH:\n+            case Value.INTERVAL_DAY_TO_HOUR:\n+            case Value.INTERVAL_DAY_TO_MINUTE:\n+            case Value.INTERVAL_DAY_TO_SECOND:\n+            case Value.INTERVAL_HOUR_TO_MINUTE:\n+            case Value.INTERVAL_HOUR_TO_SECOND:\n+            case Value.INTERVAL_MINUTE_TO_SECOND: {\n+                ValueInterval interval = (ValueInterval) v;\n+                return 2 + getVarLongLen(interval.getLeading()) +\n+                        getVarLongLen(interval.getRemaining());\n+            }\n+            case Value.JSON: {\n+                byte[] b = v.getBytesNoCopy();\n+                return 1 + getVarIntLen(b.length) + b.length;\n+            }\n+            default:\n+                throw DbException\n+                        .throwInternalError(\"type=\" + v.getValueType());\n         }\n     }\n \n@@ -1378,7 +1423,7 @@ public class Data {\n             return x;\n         }\n         x &= 0x7f;\n-        for (int s = 7;; s += 7) {\n+        for (int s = 7; ; s += 7) {\n             long b = data[pos++];\n             x |= (b & 0x7f) << s;\n             if (b >= 0) {\n",
            "diff_size": 947
        },
        {
            "tool": "naturalize",
            "errors": null,
            "diff": null
        },
        {
            "tool": "codebuff",
            "errors": null,
            "diff": null
        },
        {
            "tool": "styler_random",
            "errors": [
                {
                    "line": "916",
                    "column": "18",
                    "severity": "warning",
                    "message": "Don't use trailing comments.",
                    "source": "com.puppycrawl.tools.checkstyle.checks.TrailingCommentCheck"
                }
            ],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/138/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/138/Data.java\nindex cae5530066b..8c49c7b56bc 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/138/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_random/138/Data.java\n@@ -913,7 +913,7 @@ public class Data {\n             }\n         }\n         case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n+        case ROW:// Special storage type for ValueRow\n         {\n             int len = readVarInt();\n             Value[] list = new Value[len];\n",
            "diff_size": 1
        },
        {
            "tool": "styler_three_grams",
            "errors": [],
            "diff": "diff --git a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/138/Data.java b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/138/Data.java\nindex cae5530066b..3fdb3d23851 100644\n--- a/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/errored/1/138/Data.java\n+++ b/home/fernanda/mnt/fernanda/git-styler/styler/python/experiments/results/h2database-h2database/styler_three_grams/138/Data.java\n@@ -913,8 +913,9 @@ public class Data {\n             }\n         }\n         case ARRAY:\n-        case ROW: // Special storage type for ValueRow\n-        {\n+        case ROW:\n+            // Special storage type for ValueRow\n+         {\n             int len = readVarInt();\n             Value[] list = new Value[len];\n             for (int i = 0; i < len; i++) {\n",
            "diff_size": 3
        }
    ],
    "repaired_by": [
        "styler",
        "styler_three_grams"
    ],
    "not_repaired_by": [
        "intellij",
        "naturalize",
        "codebuff",
        "styler_random"
    ]
}